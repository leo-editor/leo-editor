<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.8: http://docutils.sourceforge.net/" />
<title>The Essentials of Leo</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document" id="the-essentials-of-leo">
<h1 class="title">The Essentials of Leo</h1>

<!-- rst3: filename: html\techReport.html -->
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#old" id="id1">Old</a><ul>
<li><a class="reference internal" href="#leos-window-outlines-clones" id="id2">Leo’s window, outlines &amp; clones</a></li>
<li><a class="reference internal" href="#relations-organizer-nodes-views-tasks-and-metadata" id="id3">Relations: organizer nodes, views, tasks and metadata</a></li>
<li><a class="reference internal" href="#plugins" id="id4">Plugins</a></li>
<li><a class="reference internal" href="#derived-files-and-special-nodes" id="id5">Derived files and special nodes</a></li>
<li><a class="reference internal" href="#markup-for-scripts" id="id6">Markup for scripts</a></li>
<li><a class="reference internal" href="#scripting-leo" id="id7">Scripting Leo</a></li>
<li><a class="reference internal" href="#leos-modules-and-classes" id="id8">Leo’s modules and classes</a></li>
<li><a class="reference internal" href="#predefined-symbols-in-scripts" id="id9">Predefined symbols in scripts</a></li>
<li><a class="reference internal" href="#accessing-data" id="id10">Accessing data</a></li>
<li><a class="reference internal" href="#traversing-outlines" id="id11">Traversing outlines</a></li>
<li><a class="reference internal" href="#executing-commands-from-scripts" id="id12">Executing commands from scripts</a></li>
<li><a class="reference internal" href="#bringing-scripts-to-data" id="id13">Bringing scripts to data</a></li>
<li><a class="reference internal" href="#unit-testing-with-test-and-suite-nodes" id="id14">Unit Testing with &#64;test and &#64;suite nodes</a></li>
<li><a class="reference internal" href="#plugins-and-hooks" id="id15">Plugins and hooks</a></li>
<li><a class="reference internal" href="#contacts" id="id16">Contacts</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="old">
<h1><a class="toc-backref" href="#id1">Old</a></h1>
<div class="section" id="leos-window-outlines-clones">
<h2><a class="toc-backref" href="#id2">Leo’s window, outlines &amp; clones</a></h2>
<p>Leo organizes all data into nodes containing a <strong>headline</strong>, an expandable page of
<strong>body text</strong> and a (possibly empty) subtree of <strong>descendant nodes</strong>. The <strong>contents</strong> of a
node are its headline and body text. Leo’s main window contains an <strong>outline</strong> pane
at the top left, a <strong>log pane</strong> at the top right, and a <strong>body pane</strong> at the bottom. The
outline pane shows headlines; the body pane shows the body text of the selected
headline. The log pane displays messages from Leo.</p>
<p>Small red arrows mark <strong>cloned nodes</strong> (clones). Clones share the same content and
descendants. All clones of the same node are equivalent, so changing the
contents of one node (call it node N) changes the contents of all clones of N.
Furthermore, inserting, deleting or changing any descendant of node N causes the
corresponding insertion, deletion or change in all other clones of N.</p>
</div>
<div class="section" id="relations-organizer-nodes-views-tasks-and-metadata">
<h2><a class="toc-backref" href="#id3">Relations: organizer nodes, views, tasks and metadata</a></h2>
<p>Clones allow you to organize data in multiple ways within the same outline. You
do not have to choose a single ‘correct’ organization: you can organize your
data in as many ways as you like.</p>
<p>You can use <strong>organizer nodes</strong> to create explicit relations (relationships) among
the data in your outline. The headline of the organizer node is the
relationship’s name. Now make clones of nodes from other parts of the outline
that participate in the relation. Drag the newly created clones so they become
children of the organizer node. You may want to create other (non-cloned)
children of the organizer node that contain data found nowhere else in the
outline. Voilà: you have just created the set of all nodes that pertain to the
relationship. The organizer node is the relation; the terms relation,
relationship and organizer node are interchangeable.</p>
<p>Three kinds of relations deserve special mention. A <strong>view</strong> is a relation (an
organizer node) containing all nodes related to a desired view (or slice) of the
data in the outline. Similarly, a <strong>task</strong> is an organizer node containing all nodes
related to a task. Relations are not limited to tasks or views: the notion of
relationship is completely general. Headlines naturally describe the data in
body text. That is, nodes relate <strong>metadata</strong> (descriptions of data) to data.
Separating data from metadata is useful for humans. It is even more valuable for
scripts: scripts can access data and metadata without complex parsing.</p>
</div>
<div class="section" id="plugins">
<h2><a class="toc-backref" href="#id4">Plugins</a></h2>
<p>Plugins are Python (.py) files contained in Leo’s plugins folder. Users can
write plugins to change how Leo works and to add new features without changing
Leo’s core code. We’ll discuss plugins in more detail later.</p>
</div>
<div class="section" id="derived-files-and-special-nodes">
<h2><a class="toc-backref" href="#id5">Derived files and special nodes</a></h2>
<p>Leo can generate many external files called <strong>derived files</strong> from an outline. Leo
outlines can organize files throughout your computer’s file system. Nodes whose
headlines start with ‘&#64;’ are special nodes. Several <strong>special nodes</strong> indicate the
root of a tree that generates a derived file:</p>
<pre class="literal-block">
&#64;asis filename    Creates a derived file. Ignores all markup in body text.
&#64;file filename    Creates a derived file. Duplicates outline structure in .leo file.
&#64;nosent filename  Creates a derived file without sentinels.
&#64;thin filename    (Recommended) Like &#64;file, but thin derived files contain all outline structure.
</pre>
<p>Leo recognizes several other special nodes:</p>
<pre class="literal-block">
&#64;settings   Defines settings local to the .leo file.
&#64;url url    Double-clicking the node’s icon opens the url in Leo or in a browser.
</pre>
<p>The scripting plugin scans for the following nodes when opening an outline:</p>
<pre class="literal-block">
&#64;button         Creates a button in the **icon area** at the top of the Leo window.
&#64;plugin plugin  Enables a plugin if the plugin has not already been enabled.
&#64;script         Executes a script when opening the outline. This is a security risk: it is disabled by default.
</pre>
<p>Plugins, &#64;button nodes and &#64;script nodes can create other kinds of special nodes:</p>
<pre class="literal-block">
&#64;suite       Creates a suite of unit tests from script in body. Requires scripting plugin.
&#64;test        Creates a unit text from script in body. Requires scripting plugin.
&#64;rst         Outputs a tree containing markup for reStructuredText. Requires rst2 plugin.
&#64;run command Double clicking the node’s icon executes the command.  Requires run_nodes plugin.
</pre>
</div>
<div class="section" id="markup-for-scripts">
<h2><a class="toc-backref" href="#id6">Markup for scripts</a></h2>
<p>Leo’s Execute Script command <strong>preprocesses</strong> the script to be executed by scanning
a node N and its descendents looking for markup. <strong>Markup</strong> is special syntax that
controls this preprocessing. If node N contains no markup, the resulting script
is just N’s body text. Otherwise, the preprocessed script will include text from
descendent nodes as described below. The main kinds of markup are <strong>section
references</strong>, <strong>directives</strong> and <strong>doc parts</strong>.</p>
<ol class="arabic">
<li><p class="first"><strong>Section references</strong> have the form:</p>
<pre class="literal-block">
&lt;&lt;section name&gt;&gt;
</pre>
<p>The &lt;&lt; and &gt;&gt; must appear on the same line. Conversely, any line
containing &lt;&lt; and &gt;&gt; is a section reference, regardless of context. However,
section references are not recognized in doc parts. Any characters may appear
between &lt;&lt; and &gt;&gt;.</p>
<p>Section references are functional pseudo-code: while preprocessing a script, Leo
replaces section references by the actual text of the section’s definition.
Sections are defined in <strong>section definition nodes</strong>, whose headlines start with a
section reference and whose body text defines the section. Each section
definition node must descend from the node containing the section reference.</p>
</li>
<li><p class="first"><strong>Directives</strong> start with ‘&#64;’ in the leftmost column of body text. Directives
specify options and control Leo’s operation. The &#64;others directive is the
minimal markup needed to organize scripts. &#64;others tells Leo to insert the
preprocessed text of all descendant nodes (except section definition nodes) at
the spot at which the &#64;others directive occurs. Nodes are inserted in <strong>outline
order</strong>, the order in which nodes appear in the outline. <strong>Important</strong>: Leo adds the
whitespace preceding the &#64;others directive to the indentation of all
preprocessed text.</p>
<p>Using &#64;others is more convenient than using section references. Use &#64;others when
the order of included text does not matter:</p>
<pre class="literal-block">
class myClass:
        &#64;others # Include the methods of the class. Order doesn’t matter.
</pre>
<p>Use section references when the order of included text does matter. In the following script, for example,
&lt;&lt; imports &gt;&gt; ensures that imports come first. The &#64;others directive then includes the body text of all other
descendant nodes:</p>
<pre class="literal-block">
&#64;language python
&lt;&lt; imports&gt;&gt;
&#64;others # Define classes &amp; functions in child nodes.
main()
</pre>
<p>Here is a list of all of Leo’s standard directives:</p>
<pre class="literal-block">
&#64;whitespace (or &#64;doc)   Starts a doc part &amp; ends code part.
&#64;all                    Like &#64;others, but includes all descendent nodes.
&#64;c, &#64;code               Starts a code part and ends a doc part.
&#64;color                  Enables syntax coloring.
&#64;delims                 Temporarily changes comment delims.
&#64;nocolor, &#64;killcolor    Disables syntax coloring.
&#64;comment                Sets comment delimiters in external (derived) files.
&#64;language languagename  Sets language for syntax coloring and comments.
&#64;lineending lineending  Sets ending of lines in derived files.
&#64;others                 Inserts body text of all descendents except definition nodes.
&#64;pagewidth n            Sets page width for justifying comments in doc parts.
&#64;path path              Sets prefix to use in relative file names in &#64;file nodes, etc.
&#64;root filename          Marks the root of a tree that creates an external file.
&#64;raw, &#64;end_raw          Inhibits sections references in a range of text. (&#64;file only.)
&#64;tabwidth n             Sets width of tabs (negative widths convert tabs to spaces.)
&#64;wrap, &#64;nowrap          Controls wrapping of text in body pane.
</pre>
</li>
<li><p class="first">Doc parts start with the ‘&#64;’ directive and continue until the end of the body text or until the ‘&#64;c’ directive.
Body text not in a doc part is in a code part. Here is an example of a doc part:</p>
<pre class="literal-block">
&#64; This is a doc part. Doc parts may span many lines. Leo converts doc parts to comments.
Leo reformats the doc part by justifying lines so they are no longer than the page width.
&#64;c
</pre>
<p>Leo reformats doc parts by justifying the text into comment lines.
The &#64;pagewidth directive controls the length of these comment lines.
The &#64;language and &#64;comment directives specify the comment delimiters used in doc parts.</p>
</li>
</ol>
</div>
<div class="section" id="scripting-leo">
<h2><a class="toc-backref" href="#id7">Scripting Leo</a></h2>
<p>The Execute Script command preprocesses the selected text of the presently
selected outline node, or the entire text of the node if there is no selected
text. See the section called Markup for Scripts for a discussion of how Leo
preprocesses scripts. That section also discusses how Leo organizes scripts
using outlines. Conversely, scripts can use outlines to organize their data. To
write such scripts you must understand at least the basics of Leo’s modules and
classes...</p>
</div>
<div class="section" id="leos-modules-and-classes">
<h2><a class="toc-backref" href="#id8">Leo’s modules and classes</a></h2>
<p>Leo’s source code is organized as a collection of modules. The following
paragraphs describe five of the most important modules. See LeoPy.leo (Leo’s
full source code) for more details: scripts have full access to all of Leo’s
classes and data.</p>
<ol class="arabic simple">
<li>The <strong>leoGlobals</strong> module contains utility functions.
By convention, in Leo’s code g is always the leoGlobals module.</li>
<li>The <strong>leoApp</strong> module defines a class representing the entire Leo application.
<strong>g.app</strong> is the singleton object of this class: the application object.
The instance variables (ivars) of the application object are Leo’s global variables.</li>
<li>The leoCommands module defines the Commands class.
A commander is an instance of this class.
Commanders contain the operations that can be performed on a particular outline.
Each open Leo outline has its own commander.
By convention, in Leo’s code <strong>c</strong> is always a commander.</li>
<li>The leoFrame module defines the base leoFrame class for objects that create and manage
the visual appearance of Leo’s windows and panes.
The <strong>leoTkinterFrame</strong> and <strong>leoTkinterTree</strong> modules contain subclasses of the base classes in the leoFrame module.
A frame (an instance of the leoFrame class, or a subclass)
contains all the internal data needed to manage a Leo window.
<strong>c.frame</strong> is the frame associated with commander c.
If <strong>f</strong> is a frame, <strong>f.c</strong> is the frame’s commander, <strong>f.body</strong> is the frame’s body pane,
<strong>f.tree</strong> is the frame’s outline pane, and <strong>f.log</strong> is the frame’s log pane.</li>
<li>The leoNodes module defines several classes that implement Leo’s fundamental data structures.
These classes are complex.
Happily, scripts can and should ignore these complications by accessing nodes using
high-level methods of the position class.</li>
</ol>
<p>A <strong>position</strong> (an instance of the position class) is the state of some traversal of an outline. Equivalently, a position is a particular visual place in an outline. Cloned nodes may appear many times in an outline. Non-cloned nodes may also appear in many places: consider a non-cloned descendant of a cloned node. By convention, in Leo’s source code p is a position.</p>
</div>
<div class="section" id="predefined-symbols-in-scripts">
<h2><a class="toc-backref" href="#id9">Predefined symbols in scripts</a></h2>
<p>When executing scripts Leo predefines the following three symbols:
<strong>c</strong> is the commander of the outline in which the script is defined,
<strong>g</strong> is the leoGlobals module and
<strong>p</strong> is the position of the selected node in c’s outline, i.e., c.currentPosition().</p>
</div>
<div class="section" id="accessing-data">
<h2><a class="toc-backref" href="#id10">Accessing data</a></h2>
<p>Scripts should get and set data using high-level access methods. Here are some important getters:</p>
<pre class="literal-block">
g.app                The application object. Its ivars are Leo’s global variables.
g.app.windowList     The list of all open frames.
c.currentPosition()  The position of the selected node.
c.rootPosition()     The position of the first node in the outline.
p.headString()       The headline of position p.
p.bodyString()       The body text of position p.
p.childIndex()       The number of siblings that precede p.
p.numberOfChildren() The number of p’s children.
p.level()            The number of p’s ancestors.
p.hasChildren()      True if p has children.
p.isAncestorOf(p2)   True if p2 is a child, grandchild, etc. of p.
p.isCloned()         True if p is a clone.
p.isDirty()          True if p’s contents have been changed.
p.isExpanded()       True if p has children and p’s outline is expanded.
p.isMarked()         True if p’s headline is marked.
p.isVisible()        True if all of p’s ancestors are expanded.
</pre>
<p>And here are some important setters:</p>
<pre class="literal-block">
p.setBodyStringOrPane(s) Set body text of p to s.
p.setHeadString(s)       Set headline of p to s.
</pre>
</div>
<div class="section" id="traversing-outlines">
<h2><a class="toc-backref" href="#id11">Traversing outlines</a></h2>
<p>Scripts can visit some or all of the nodes of a Leo outline using the following iterators:</p>
<pre class="literal-block">
c.allNodes_iter             # All positions in the outline, in outline order.
p.children_iter()           # All children of p.
p.parents_iter()            # All parents of p.
p.siblings_iter()           # All siblings of p, including p.
p.following_siblings_iter() # All siblings following p, not including p.
</pre>
<p>For example, the following prints all the nodes of an outline, properly indented:</p>
<pre class="literal-block">
for p in c.allNodes_iter():
    print ' '*p.level(), p.headString()
</pre>
</div>
<div class="section" id="executing-commands-from-scripts">
<h2><a class="toc-backref" href="#id12">Executing commands from scripts</a></h2>
<p>Scripts may open other Leo outlines, or execute any of Leo’s commands.  Here are some examples:</p>
<pre class="literal-block">
ok,frame = g.openWithFileName(path,c)       # Opens the .leo file found at path.
c.deleteOutline()   # Deletes the selected node.
c.insertHeadline()  # Inserts a new node after present position.
</pre>
<p>For more examples, see Chapter 7: Scripting Leo with Python, in Leo’s Users Guide.</p>
</div>
<div class="section" id="bringing-scripts-to-data">
<h2><a class="toc-backref" href="#id13">Bringing scripts to data</a></h2>
<p>The scripting plugin creates two buttons in the icon area at the top of the Leo
window. The Run Script button executes the script in the selected node just
like the Execute Script command. The Script Button button creates a new
button whose headline is the headline of the presently selected node, call it
node N. Pressing this button executes the script in node N with p predefined as
c.currentPosition() at the time the script is executed. This clever trick
brings the script to the data in the selected outline.</p>
</div>
<div class="section" id="unit-testing-with-test-and-suite-nodes">
<h2><a class="toc-backref" href="#id14">Unit Testing with &#64;test and &#64;suite nodes</a></h2>
<p>test.leo contains all of Leo’s unit tests. An &#64;button node in test.leo
creates a blue Unit Test button in the icon area. This button is an
excellent example of bringing scripts to data. The Unit Test button executes
all the unit tests specified by &#64;test and &#64;suite nodes in the selected
outline. <strong>Important</strong>: &#64;button, &#64;test and &#64;suite nodes require the
scripting plugin to be enabled.</p>
<p>&#64;test nodes greatly simplify unit testing. The Unit Test button creates
a unit test from the body text of each &#64;test node. In effect, the Unit
Test button automatically creates an instance of unittest.TestCase whose
run method is the body text of the &#64;test node. There is no need to create
TestCase objects explicitly!</p>
<p>&#64;suite nodes support legacy unit tests. When the Unit Test script button
finds an &#64;suite node it executes the script in its body text. This script
should create a suite of unit tests and set:</p>
<pre class="literal-block">
g.app.scriptDict['suite'] = suite
</pre>
<p>where suite is the created suite. The Unit Test button then runs that
created suite of unit tests.</p>
</div>
<div class="section" id="plugins-and-hooks">
<h2><a class="toc-backref" href="#id15">Plugins and hooks</a></h2>
<p>Plugins are Python (.py) files in Leo’s plugin subdirectory. It is easy to
create new plugins: Leo’s users have contributed dozens of plugins that extend
Leo’s capabilities in new ways. Leo imports all enabled plugins during startup.
The file pluginsManager.txt lists all enabled plugins. You can use the plugin
manager plugin to control plugins without updating pluginsManager.txt by hand.</p>
<p>Plugins can override any class, method or function in Leo’s core, the files in
Leo’s src subdirectory (the files derived from LeoPy.leo). Besides altering
Leo’s core, plugins can register functions called hooks that Leo calls at
various times during Leo’s execution. Events that trigger hooks include key
pressed events, screen drawing events, node selection events and many others.
When importing a plugin, Leo will call the top-level init() function if it
exists. This function should register the plugin’s hooks by calling
leoPlugins.registerHandler.</p>
<p>For full details about hooks and events see Chapter 8: Customizing Leo, in
Leo’s Users Guide. The file leoPlugins.leo contains all plugins that are
presently distributed with Leo; studying these plugins is a good way of learning
to write your own plugins.</p>
</div>
<div class="section" id="contacts">
<h2><a class="toc-backref" href="#id16">Contacts</a></h2>
<ul class="simple">
<li>Leo’s home page:  google edreamleo or <a class="reference external" href="http://webpages.charter.net/edreamleo/front.html">http://webpages.charter.net/edreamleo/front.html</a></li>
<li>Edward K. Ream:  <a class="reference external" href="mailto:edreamleo&#64;charter.net">edreamleo&#64;charter.net</a>, 166 N. Prospect Ave., Madison WI 53726, (608) 231-0766</li>
</ul>
</div>
</div>
</div>
</body>
</html>
