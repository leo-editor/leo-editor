<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070615131954"><vh>Startup</vh>
<v t="ekr.20070427110751"><vh>@chapters</vh></v>
<v t="ekr.20111017085134.16069"><vh>Disabled buttons</vh>
<v t="ekr.20111017085134.16070"><vh>@@button jython</vh></v>
<v t="ekr.20111017085134.16071"><vh>@@button pydoc</vh></v>
<v t="ekr.20111017085134.16072"><vh>@@button check-dirty</vh></v>
<v t="ekr.20111017085134.16073"><vh>@@button Ipython</vh></v>
<v t="ekr.20111017085134.16074"><vh>@@button Lines Down</vh>
<v t="ekr.20111017085134.16075"><vh>moveLinesDown</vh></v>
</v>
<v t="ekr.20111017085134.16076"><vh>@@button Lines Up</vh>
<v t="ekr.20111017085134.16077"><vh>moveLinesUp</vh></v>
</v>
<v t="ekr.20111017085134.16078"><vh>@@button lispCall @key=alt+6</vh>
<v t="ekr.20111017085134.16079"><vh>ctor</vh></v>
<v t="ekr.20111017085134.16080"><vh>run &amp; helpers</vh>
<v t="ekr.20111017085134.16081"><vh>findCalls</vh></v>
<v t="ekr.20111017085134.16082"><vh>findDefs</vh></v>
<v t="ekr.20111017085134.16083"><vh>stripComments</vh></v>
<v t="ekr.20111017085134.16084"><vh>stripLispIds</vh></v>
<v t="ekr.20111017085134.16085"><vh>stripStrings</vh></v>
</v>
<v t="ekr.20111017085134.16086"><vh>class token</vh></v>
<v t="ekr.20111017085134.16087"><vh>choose</vh></v>
<v t="ekr.20111017085134.16088"><vh>dumpList</vh></v>
<v t="ekr.20111017085134.16089"><vh>Parsing...</vh>
<v t="ekr.20111017085134.16090"><vh>parse</vh></v>
<v t="ekr.20111017085134.16091"><vh>scan &amp; helpers</vh>
<v t="ekr.20111017085134.16092"><vh>skipComment</vh></v>
<v t="ekr.20111017085134.16093"><vh>skipId</vh></v>
<v t="ekr.20111017085134.16094"><vh>skipString</vh></v>
</v>
<v t="ekr.20111017085134.16095"><vh>scanForest</vh></v>
</v>
<v t="ekr.20111017085134.16096"><vh>Code generators...</vh>
<v t="ekr.20111017085134.16097"><vh>gen</vh></v>
<v t="ekr.20111017085134.16098"><vh>gen_token</vh></v>
<v t="ekr.20111017085134.16099"><vh>gen_block &amp; helper</vh>
<v t="ekr.20111017085134.16100"><vh>gen_block_id</vh></v>
</v>
<v t="ekr.20111017085134.16101"><vh>gen_call &amp; helper</vh>
<v t="ekr.20111017085134.16102"><vh>gen_arg</vh></v>
</v>
<v t="ekr.20111017085134.16103"><vh>gen_def</vh></v>
<v t="ekr.20111017085134.16104"><vh>gen_if &amp; helpers</vh>
<v t="ekr.20111017085134.16105"><vh>gen_then</vh></v>
</v>
<v t="ekr.20111017085134.16106"><vh>gen_expr</vh></v>
<v t="ekr.20111017085134.16107"><vh>gen_let &amp; helper</vh>
<v t="ekr.20111017085134.16108"><vh>gen_let_bindings</vh></v>
</v>
<v t="ekr.20111017085134.16109"><vh>put...</vh>
<v t="ekr.20111017085134.16110"><vh>put </vh></v>
<v t="ekr.20111017085134.16111"><vh>put_token</vh></v>
<v t="ekr.20111017085134.16112"><vh>put_code &amp; put_code_line</vh></v>
<v t="ekr.20111017085134.16113"><vh>put_code_token</vh></v>
</v>
</v>
</v>
<v t="ekr.20111017085134.16114"><vh>@@button outlineToClipboard</vh></v>
</v>
</v>
<v t="ekr.20061008055616"><vh>Scripts</vh>
<v t="ekr.20051110111150" descendentVnodeUnknownAttributes="7d71005506302e352e313371017d710258120000007273745f687474705f61747472696275746571035d71042858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333922206e616d653d22687474702d6e6f64652d6d61726b65722d3339223e710558040000003c2f613e71065d71072858340000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e710858060000003c2f6469763e71095d710a28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710b58060000003c2f6469763e710c5d710d2858060000003c626f64793e710e58070000003c2f626f64793e710f5d71102858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711158070000003c2f68746d6c3e71124e6565656558070000003c2f6469763e0a7113583e0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e0a7114587e0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323022206e616d653d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e46756e6374696f6e7320646566696e656420696e206c656f476c6f62616c732e70793c2f613e3c2f68313e0a71156573732e"
expanded="ekr.20060824111500.108,"><vh>@thin leoScripts.txt</vh></v>
<v t="ekr.20110914030246.2405"><vh>@file gen_blender_docs.py</vh></v>
<v t="maphew.20130612230051.2793"><vh>Windows</vh>
<v t="maphew.20130809155103.2862"><vh>@auto create-leobat.bat</vh></v>
<v t="maphew.20130809155103.2863"><vh>@file build-leo.bat</vh></v>
<v t="maphew.20130613230258.2801"><vh>@file elevate.py</vh></v>
<v t="maphew.20130611235500.2658"><vh>@file register-leo.leox</vh></v>
<v t="maphew.20130611235500.2665"><vh>@file unregister-leo.leox</vh></v>
</v>
</v>
<v t="ekr.20130810093044.16933"><vh>Recently contributed/modified scripts</vh>
<v t="ekr.20130810093044.16934"><vh>By Terry Brown</vh>
<v t="tbrown.20141110113251.1"><vh>Capture idea / ph. msg / to-do item</vh></v>
<v t="ekr.20130810093044.16935"><vh>add @script node</vh></v>
<v t="ekr.20130810093044.16936"><vh>Cross-outline to-do item editing</vh>
<v t="ekr.20130810093044.16937"><vh>Re: Cross-outline node editing</vh></v>
<v t="ekr.20130810093044.16938"><vh>Re: Cross-outline node editing</vh></v>
<v t="ekr.20130810093044.16939"><vh>Re: Cross-outline node editing</vh></v>
</v>
<v t="ekr.20130810093044.16940"><vh>export full contents</vh>
<v t="ekr.20130810093044.16941"><vh>script</vh></v>
</v>
<v t="ekr.20130816100419.23046"><vh>Full tree preview script</vh>
<v t="ekr.20130816100419.23047"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
</v>
<v t="ekr.20130810093044.16942"><vh>Indexing files for full text search</vh>
<v t="ekr.20130810093044.16943"><vh>Re: Idea/needed: system command queue</vh></v>
<v t="ekr.20130810093044.16944"><vh>Re: Idea/needed: system command queue</vh></v>
</v>
<v t="ekr.20130810093044.16945"><vh>persistent state with json as a leo abbreviation</vh>
<v t="ekr.20130810093044.16946"><vh>Re: persistent state with json as a leo abbreviation</vh></v>
<v t="ekr.20130810093044.16947"><vh>Re: persistent state with json as a leo abbreviation</vh></v>
<v t="ekr.20130810093044.16948"><vh>Re: persistent state with json as a leo abbreviation</vh></v>
</v>
<v t="ekr.20130810093044.16949"><vh>Tool for diffing Leo files</vh>
<v t="ekr.20130810093044.16950"><vh>Re: Tool for diffing Leo files</vh></v>
</v>
<v t="ekr.20140312052111.19343"><vh>Set line height (Qt 4.8 and above)</vh></v>
<v t="ekr.20141105055521.14"><vh>Load files into Leo from the command line</vh></v>
<v t="ekr.20141105055521.17"><vh>Snippet: execute code after typing has not happened for a while</vh></v>
<v t="ekr.20141105055521.18"><vh>Tool for diffing Leo files</vh></v>
</v>
<v t="ekr.20130810093044.16951"><vh>By EKR</vh>
<v t="ekr.20121220111212.13257"><vh>@button write-unit-tests</vh>
<v t="ekr.20121220111212.13258"><vh>&lt;&lt; about this script &gt;&gt;</vh></v>
<v t="ekr.20121220111212.13259"><vh>class TestWriter</vh>
<v t="ekr.20121220111212.13260"><vh>&lt;&lt; define file_template &gt;&gt;</vh></v>
<v t="ekr.20121220111212.13261"><vh>&lt;&lt; define test_template &gt;&gt;</vh></v>
<v t="ekr.20121220111212.13262"><vh> ctor</vh></v>
<v t="ekr.20121220111212.13263"><vh>clean</vh></v>
<v t="ekr.20121220111212.13264"><vh>get_body</vh></v>
<v t="ekr.20121220111212.13265"><vh>run</vh></v>
<v t="ekr.20121220111212.13266"><vh>test</vh></v>
<v t="ekr.20121220111212.13267"><vh>write_file</vh></v>
</v>
</v>
<v t="ekr.20130810093044.16954"><vh>Create global data structures from in modes/*.py files</vh></v>
<v t="ekr.20130810093044.16955"><vh>get all comments from modes (slow)</vh>
<v t="ekr.20130810093044.16956"><vh>get_paths</vh></v>
<v t="ekr.20130810093044.16957"><vh>import_module</vh></v>
</v>
<v t="ekr.20130810093044.16958"><vh>import-org-mode</vh>
<v t="ekr.20130810093044.16959"><vh>import-org-mode (command, not used)</vh>
<v t="ekr.20130810093044.16960"><vh>ctor</vh></v>
<v t="ekr.20130810093044.16961"><vh>go</vh></v>
<v t="ekr.20130810093044.16962"><vh>scan</vh></v>
<v t="ekr.20130810093044.16963"><vh>test</vh></v>
</v>
<v t="ekr.20130810093044.16964"><vh>@@button import-org-mode</vh>
<v t="ekr.20130810093044.16965"><vh>scan</vh></v>
</v>
<v t="ekr.20130810093044.16966"><vh>test-import-org-mode</vh></v>
</v>
<v t="ekr.20130810093044.16967"><vh>jinja2 templating script</vh></v>
<v t="ekr.20121013084734.16370"><vh>Recursive import using c.recursiveImport</vh></v>
<v t="ekr.20130920214241.12461"><vh>script to search for all changed methods</vh></v>
<v t="ekr.20140426052603.18106"><vh>@button replace g.choose</vh>
<v t="ekr.20140426052603.18107"><vh>run</vh></v>
<v t="ekr.20140426052603.18108"><vh>find</vh></v>
<v t="ekr.20140426052603.18109"><vh>get_arg</vh></v>
<v t="ekr.20140426052603.18110"><vh>munge</vh></v>
<v t="ekr.20140426052603.18111"><vh>replace</vh></v>
</v>
<v t="ekr.20140729094250.19180"><vh>Check all colorizer files for problem regex's</vh></v>
<v t="ekr.20141105055521.15"><vh>Print gnxs &amp; gnxDict</vh></v>
<v t="ekr.20141105055521.16"><vh>Safely replace body.x with body.wrapper.x</vh></v>
</v>
<v t="ekr.20130810093044.16969"><vh>By Brian Theado</vh>
<v t="ekr.20130810093044.16970"><vh>Display function call hierarchy in Leo</vh>
<v t="ekr.20130810093044.16971"><vh>call tree</vh>
<v t="ekr.20130810093044.16972"><vh>displayCalltree</vh></v>
<v t="ekr.20130810093044.16973"><vh>trace session</vh></v>
</v>
</v>
</v>
<v t="ekr.20130812034101.12556"><vh>By Matt Wilkie</vh>
<v t="ekr.20140704052551.17948"><vh>Console script: Install Leo from scratch on Windows</vh></v>
<v t="ekr.20130812034101.12558"><vh>Script: Add docutils to python3 </vh></v>
<v t="ekr.20140704052551.17941"><vh>Script: Add Windows handler for .leo files</vh></v>
<v t="ekr.20140704052551.17946"><vh>Script: Set icon for .leo files</vh></v>
<v t="ekr.20141105055521.13"><vh>Script: Dictionary to Leo outline</vh></v>
</v>
</v>
<v t="ekr.20141116105945.2"><vh>@persistence</vh>
<v t="ekr.20141116105945.3"><vh>@data:@auto create-leobat.bat</vh>
<v t="ekr.20141116105945.4"><vh>@gnxs</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20061008055616"></t>
<t tx="ekr.20070427110751"></t>
<t tx="ekr.20070615131954"></t>
<t tx="ekr.20111017085134.16069"></t>
<t tx="ekr.20111017085134.16070"># **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.h
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
</t>
<t tx="ekr.20111017085134.16071">import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()</t>
<t tx="ekr.20111017085134.16072"># This works, but is too slow to be really useful.

count = 0
for p in c.all_unique_positions():
    if p.isDirty():
        c.checkPythonNode (p,suppressErrors=False)
        count += 1
        
g.es('%s nodes checked' % count)</t>
<t tx="ekr.20111017085134.16073">from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()</t>
<t tx="ekr.20111017085134.16074"># Move selected text of the body down one line.

@others

moveLinesDown(c,p)</t>
<t tx="ekr.20111017085134.16075">def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20111017085134.16076"># Move selected text of the body up one line.

@others

moveLinesUp(c,p)</t>
<t tx="ekr.20111017085134.16077">def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20111017085134.16078">'''Analyze external calls in lisp files.'''

import glob
class lispAnalyzer:
    @others

base = '/media/disk/XEmacs/XEmacs-21.4.13/lisp/*.el'
paths = glob.glob(base)
# g.es(g.listToString(paths))
paths = [paths[0]]

x = lispAnalyzer(c,paths)
x.run()</t>
<t tx="ekr.20111017085134.16079">def __init__ (self,c,paths):

    self.c = c
    self.paths = paths

    # Debugging.
    self.debug = True
    self.trace = False

    # Semantic info.
    self.def_keywords = ('defun','defvar',)
    self.indent_keywords = ('if','prog','prog1','progn','set',)
    self.expr_keywords = ('and','not','or',)

    self.indent = 0 # Indentation of production output.

    # Dispatch dictionary.
    self.dispatchDict = {}</t>
<t tx="ekr.20111017085134.16080">def run(self):

    fn = self.paths[0]
    f = open(fn)
    s = f.read()
    g.es_print(fn)
    # g.trace(s)
    s = self.stripStrings(s)
    s = self.stripComments(s)
    defs = self.findDefs(s)
    calls = self.findCalls(s,defs)
    calls = self.stripLispIds(calls)
    defs.sort()
    calls.sort()
    g.trace('defs...\n',g.listToString(defs))
    g.trace('calls...\n',g.listToString(calls))
</t>
<t tx="ekr.20111017085134.16081">def findCalls (self,s,defs):

    calls = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            theId = s[i:j].strip()
            if theId not in defs and theId not in calls:
                calls.append(theId)
            i = j
        else: i += 1
        assert progress &lt; i

    return calls       
</t>
<t tx="ekr.20111017085134.16082">def findDefs (self,s):

    defs = [] ; tag = '(defun'
    i = 0
    while True:
        progress = i
        j = s.find(tag,i)
        if j == -1:
            return defs
        i = j + len(tag)
        j = g.skip_ws(s,i)
        if j &gt; i:
            k = self.skipId(s,j)
            if k &gt; j:
                defs.append(s[j:k])
            i = k
        assert progress &lt; i 
</t>
<t tx="ekr.20111017085134.16083">def stripComments(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == ';':
            i = self.skipComment(s,i)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="ekr.20111017085134.16084">def stripLispIds (self,aList):

    lispIds = [
        't','f',
        'apply',
        'boundp',
        'car','cons','cdr','consp',
        'eq','equal','eval',
        'lamda','lambda',
        'macro',
        'nil','not','null','numberp',
        'or',
        'unless',
        'vector','vectorp',
        # special forms
        'and',
        'catch',
        'cond',
        'condition-case',
        'defconst',
        'defmacro',
        'defun',
        'defvar',
        'function',
        'if',
        'interactive',
        'let',
        'let*',
        'or',
        'prog1',
        'prog2',
        'progn',
        'quote',
        'save-current-buffer',
        'save-excursion',
        'save-restriction',
        'save-window-excursion',
        'setq',
        'setq-default',
        'track-mouse',
        'unwind-protect',
        'while',
        'with-output-to-temp-buffer',
    ]

    return [z for z in aList if z not in lispIds]</t>
<t tx="ekr.20111017085134.16085">def stripStrings(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == '"':
            i = self.skipString(s,i)
        elif ch == "'":
            i = self.skipId(s,i+1)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="ekr.20111017085134.16086">class token:

    '''Representing one elisp syntactic entity,
    with a list of preceding comments.'''

    def __init__ (self,comments,kind,val):
        self.comments = comments[:]
        self.kind = kind
        self.val = val
            # For blocks, a list of tokens.
            # For all other tokens, the spelling of the token.

    def __repr__ (self):
        return '&lt;token kind: %s, val: %s&gt;' % (self.kind,self.val)

    def __str__ (self):
        if self.kind == 'block:':
            return 'block: [snip]'
        elif self.kind == 'string:':
            return '%s%s' % (self.kind,self.val[:20])
        else:
            return '%s%s' % (self.kind,self.val)
</t>
<t tx="ekr.20111017085134.16087">def choose(self,cond,a,b): # warning: evaluates all arguments

    if cond: return a
    else: return b
</t>
<t tx="ekr.20111017085134.16088">def dumpList(self,aList):

    if type(aList) == type([]):
        result = self.dumpListHelper(aList,indent=0)
        return '\n'.join(result)
    else:
        return repr(aList)

def dumpListHelper(self,aList,indent):

    result = []
    leading = ' ' * (4 * indent)

    for z in aList:
        if z is None:
            result.append('%s%s' % (leading,'None'))
        elif z == []:
            result.append('%s%s' % (leading,'[]'))
        elif type(z) == type([]):
            result.append('%s%s' % (leading,'['))
            result.extend(self.dumpListHelper(z,indent+1))
            result.append('%s%s' % (leading,']'))
        elif isinstance(z,self.token):
            if z.kind=='block:':
                result.append('%s%s' % (leading,'block:'))
                result.extend(self.dumpListHelper(z.val,indent+1))
                # result.append('%s%s' % (leading,'block:]'))
            else:
                result.append('%s%s' % (leading,str(z)))
        else:
            result.append('%s%s' % (leading,str(z)))

    return result

listToString = dumpList</t>
<t tx="ekr.20111017085134.16089"></t>
<t tx="ekr.20111017085134.16090">def parse(self,s):

    # Generate the nodes, including directive and section references.
    return self.scanForest(s)
</t>
<t tx="ekr.20111017085134.16091">def scan(self,s,i):

    '''Scan an elisp expression.'''

    start = i ; end = len(s) ; result = []
    comments = [] ; token = self.token
    # A hack. ignore initial @language lisp
    tag = '@language lisp'
    if i == 0 and s[i:i+len(tag)]==tag:
        i += len(tag)
    while i &lt; end:
        progress = i
        ch = s[i]
        if ch == ';':
            j = self.skipComment(s,i)
            start = i = j
        elif ch == '"':
            j = self.skipString(s,i)
            start = i = j
        elif ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            result.append(token(comments,'id:',s[i:j]))
            start = i = j
        elif ch =='(':
            i += 1
            j,aList = self.scan(s,i)
            result.append(token(comments,'block:',aList))
            start = i = j
        elif ch == ')':
            i += 1
            return i,result
        else:
            # if ch == "'": ch = 'quote'
            # if ch not in (' ','\t','\n','\r'):
                # result.append(token(comments,'op:',ch))
            i += 1
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

    if start &lt; end:
        tail = s[start:end].strip()
        if tail:
            result.append(token(comments,'tail:',tail))
            comment = []
    if comments:
        result.append(token(comments,'trailing-comment:',''))

    return i,result
</t>
<t tx="ekr.20111017085134.16092">def skipComment (self,s,i):

    '''Skip a comment.'''

    while i &lt; len(s):
        if s[i] == '\n':
            break
        i += 1
    return i
</t>
<t tx="ekr.20111017085134.16093">def skipId (self,s,i):

    while i &lt; len(s):
        ch = s[i]
        if ch.isalnum() or ch in ('_','-'):
            i += 1
        else:
            break
    return i
</t>
<t tx="ekr.20111017085134.16094">def skipString(self,s,i):

    """Skip a string literal."""

    assert(s[i] == '"')
    i += 1
    while i &lt; len(s):
        ch = s[i]
        if ch == '\\' : i += 2
        elif ch == '"':
            i += 1 ; break
        else: i += 1

    return i</t>
<t tx="ekr.20111017085134.16095">def scanForest (self,s):

    i = 0 ; result = []

    while i &lt; len(s):
        progress = i
        i,aList = self.scan(s,i)
        aList and result.extend(aList)
        assert i &gt; progress

    return result


</t>
<t tx="ekr.20111017085134.16096">@ From Richard Deibenkorn:

1. Attempt what is not certain. Certainty may or may not come later. It may then
be a valuable delusion.

2. The pretty, initial position which falls short of completeness is not to be
valued--except as stimulus for further moves.

3. Do search.  But in order to find other than what is looked for.

4. Use and respond to the initial fresh qualities but consider them absolutely
expendable.
</t>
<t tx="ekr.20111017085134.16097">def gen(self,tokens,indent,init=False):

    result = []

    if init: result.append('='*40)

    for token in tokens:
        aList = self.gen_token(token,indent)
        result.extend(aList)

    if init: result.append('-'*40)

    return result

</t>
<t tx="ekr.20111017085134.16098">def gen_token(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            self.gen_block(token,indent)
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="ekr.20111017085134.16099">def gen_block (self,token,indent):

    if not (token and token.val):
        return []

    blockList = token.val
    token2 = blockList[0]
    result = []

    if token2.kind.startswith('id'):
        aList = self.gen_block_id(token2.val,blockList,indent)
    else:
        if self.debug:
            self.put('block...',[],indent,result)
        aList = self.gen(token.val,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16100">def gen_block_id (self,theId,tokens,indent):

    result = []

    # Eventually there will be a lookup of the dispatch dict here.
    if theId == 'let':
        aList = self.gen_let(tokens,indent)
    elif theId == 'if':
        aList = self.gen_if(tokens,indent)
    elif theId in self.def_keywords:
        aList = self.gen_def(theId,tokens,indent)
    elif theId in self.indent_keywords:
        self.put('%s...' % (theId),[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
    elif theId in self.expr_keywords:
        aList = self.gen_expr(theId,tokens[1:],indent+1)
    else:
        aList = self.gen_call(theId,tokens[1:],indent)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16101">def gen_call (self,funcId,tokens,indent):

    result = []

    if self.debug:
        self.put('call: %s' % (funcId),[],indent,result)
        for token in tokens:
            aList = self.gen_arg(token,indent+1)
            result.extend(aList)
    else:
        self.put_code_line('%s(' % (funcId))
        for token in tokens:
            self.gen_arg(token,indent+1)
        self.put_code(')')

    return result

</t>
<t tx="ekr.20111017085134.16102">def gen_arg(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            self.put('arg block:...',[],indent,result)
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            self.put_code(''.join(aList))
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="ekr.20111017085134.16103">def gen_def(self,theId,tokens,indent):

    result = []

    if not tokens or len(tokens) &lt; 3:
        result.append('*** bad def tokens')
        return result

    defToken,idToken = tokens[0:2]
    if idToken.kind != 'id:':
        result.append('*** bad def id')
        return result

    if self.debug:
        self.put(theId,idToken.val,indent,result)
        aList = self.gen(tokens[2:],indent+1)
        result.extend(aList)
    else:
        self.put_code('def %s (' % idToken.val)
        self.gen_token(tokens[2],indent)
        self.put_code('): # end def\n')
        self.indent += 1
        self.gen(tokens[3:],indent+1)
        self.indent -= 1

    return result
</t>
<t tx="ekr.20111017085134.16104">@ if condition then-form else-forms.

If the evaluated condition is non-nil, then-form is evaluated and the result
returned. Otherwise, the else-forms are evaluated in textual order, and the
value of the last one is returned. If condition has the value nil, and no
else-forms are given, if returns nil.
@c

def gen_if (self,tokens,indent):

    # tokens[0]: id:if
    # tokens[1] cond

    for i in xrange(len(tokens)):
        g.trace('tokens[%d]: %s' % (i,self.dumpList(tokens[i])))

    # g.trace(self.dumpList(tokens))

    result = []

    if self.debug:
        self.put('if...',[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
        result.extend(aList)
    else:
        self.put_code('if ')
        self.gen(tokens[1:],indent+1)
        self.put_code(': # end if\n')

    return result
</t>
<t tx="ekr.20111017085134.16105">def gen_then (self,token):

    pass
</t>
<t tx="ekr.20111017085134.16106">def gen_expr (self,theId,aList,indent):

    binops = ('and','or',)
    result = []

    self.put(theId,[],indent,result)
    aList = self.gen(aList,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16107">@
(let ((variable value)
      (variable value)
      ...)
  body...)
@c

def gen_let (self,tokens,indent):

    if not tokens: return []
    if len(tokens) != 3:
        g.trace('unusual let')
        result = self.gen(tokens,indent+1)
        return result

    if 0:
        for i in xrange(len(tokens)):
            g.trace('token',i,tokens[i])

    letToken,bindingToken,bodyToken = tokens
    result = []
    self.put('let...',[],indent,result)
    self.put('let-bindings...',[],indent+1,result)
    aList = self.gen_let_bindings(bindingToken,indent+2)
    result.extend(aList)
    self.put('let-block...',[],indent+1,result)
    aList = self.gen_block(bodyToken,indent+2)
    result.extend(aList)
    return result</t>
<t tx="ekr.20111017085134.16108">def gen_let_bindings (self,token,indent):

    result = []

    if token.kind != 'block:':
        g.trace('unexpected let')
        return result

    for z in token.val:
        if z.kind == 'block:': # one (id,val) pair
            if z.val and len(z.val) == 2:
                token1 = z.val[0]
                token2 = z.val[1]
                self.put('let-id',token1,indent,result)
                self.put('let-val...',[],indent,result)
                if token2.kind == 'block:':
                    aList = self.gen_block(token2,indent+1)
                    result.extend(aList)
                else:
                    #g.trace('no let list')
                    self.put_token(token2,indent+1,result)
            else:
                g.trace('unexpected let 2')

    return result
</t>
<t tx="ekr.20111017085134.16109"></t>
<t tx="ekr.20111017085134.16110">def put (self,kind,val,indent,result):

    '''Append one or more lines of output to result.'''

    leading = '%2d: %s' % (indent,' ' * indent)

    if kind == 'string:':
        val = self.choose(len(val)&gt;20,val[:20]+'..."',val)

    if val:
        s = '%s%s %s' % (leading,str(kind),str(val))
    else:
        s = '%s%s' % (leading,str(kind))

    result.append(s)
</t>
<t tx="ekr.20111017085134.16111">def put_token (self,token,indent,result):

    for z in token.comments:
        self.put('comment:',z,indent,result)

    self.put(token.kind,token.val,indent,result)
</t>
<t tx="ekr.20111017085134.16112">def put_code_line (self,s):

    s2 = '%s%s' % (' '*self.indent,s)
    print s2,

def put_code (self,s):

    print s,
</t>
<t tx="ekr.20111017085134.16113">def put_code_token (self,token):

    if token.kind == 'block:':
        self.put_code('&lt;block&gt;')
    else:
        self.put_code(token.val)

</t>
<t tx="ekr.20111017085134.16114">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ekr.20121013084734.16370">'''Recursively import all python files in a directory and clean the result.'''

# Latest change: use c.recursiveImport.

c.recursiveImport(
    dir_ = r'C:\prog\pyflakes-0.6.0\pyflakes',
    one_file = False,
    safe_at_file = False,
    theTypes = None, # Same as ['.py']
    use_at_edit = False)
</t>
<t tx="ekr.20121220111212.13257">'''
&lt;&lt; about this script &gt;&gt;
'''

@others

# Change test_dir as desired: it must already exist.
test_dir = g.os_path_finalize_join(g.app.loadDir,'..','test')

if 1:
    # Writes each test to a separate file in the test directory.
    TestWriter(c,path=test_dir).run(fn=None)    
else:
    # Writes all tests to a single file: test/unit_tests.py
    TestWriter(c,path=test_dir).run(fn='unit_tests.py')
</t>
<t tx="ekr.20121220111212.13258">@language rest

This script transliterates @test nodes into .py file. The two main ways of
using this script are as follows::

    TestWriter(c,path='test').run(fn='unit_tests.py') # writes one file
    TestWriter(c,path='test').run(fn=None)            # writes separate files.
     
The first writes all tests to test/unit_tests.py; the second writes each
unit test to a separate .py file in the test directory.

The script imports each written file and reports any syntax errors.

This is a straightforward script; it should be easy to modify it to suit
individual needs.

The &lt;\&lt; file_template &gt;&gt; and &lt;\&lt; test_template &gt;&gt; sections in the TestWriter
class determines exactly what this script writes.</t>
<t tx="ekr.20121220111212.13259">class TestWriter:
    
    &lt;&lt; define file_template &gt;&gt;
    &lt;&lt; define test_template &gt;&gt;

    @others
</t>
<t tx="ekr.20121220111212.13260"># Add any other common imports here.

file_template = '''\
import unittest
'''

file_template = g.adjustTripleString(file_template,c.tab_width)</t>
<t tx="ekr.20121220111212.13261">test_template = '''
class %s (unittest.TestCase):
    def runTest(self):
%s
'''

test_template = g.adjustTripleString(test_template,c.tab_width)
</t>
<t tx="ekr.20121220111212.13262">def __init__(self,c,path=''):
    
    self.c = c
    load_dir = g.os_path_dirname(c.fileName())
    self.path = g.os_path_finalize_join(load_dir,path)
    self.nodes = []
    assert g.os_path_exists(self.path),self.path
</t>
<t tx="ekr.20121220111212.13263">def clean(self,s):
    
    '''Munge s so that it can be used as a file name.'''
    
    result,tag = [],'@test'
    if s.startswith(tag):
        s = s[len(tag):]
    for ch in s.strip():
        if ch.isalnum():
            result.append(ch)
        elif ch.isspace():
            result.append('_')
    s = ''.join(result)
    if s.endswith('.py'):
        s = s[:-3]
    return s.strip()
</t>
<t tx="ekr.20121220111212.13264">def get_body(self,p):
    
    '''Convert p.b to a valid script.'''
    
    s = g.getScript(c,p,
        useSelectedText=False,forcePythonSentinels=True,useSentinels=False)

    s = ''.join([' '*8+z for z in g.splitLines(s) if z.strip()])
    
    return s.rstrip()
</t>
<t tx="ekr.20121220111212.13265">def run(self,fn=None):
    n,p = 1,c.rootPosition()
    while p:
        if p.h.startswith('@ignore '):
            p.moveToNodeAfterTree()
        elif p.h.startswith('@test '):
            self.nodes.append(p.copy())
            if not fn:
                fn2 = self.clean(p.h)+'.py'
                self.write_file(fn2)
                self.test(fn2)
                self.nodes=[]
            n += 1
            p.moveToThreadNext()
        else:
            p.moveToThreadNext()
    if fn:
        self.write_file(fn)
        self.test(fn)
    dest = g.os_path_join(self.path,fn) if fn else self.path
    print('wrote %s tests to %s' % (n,dest))
</t>
<t tx="ekr.20121220111212.13266">def test(self,fn):
    
    '''Test the newly created file.'''
    
    import imp
    import sys

    if self.path not in sys.path:
        sys.path.append(self.path)

    assert fn.endswith('.py')
    name = fn[:-3]
    try:
        f,path,desc = imp.find_module(name,[self.path])
        imp.load_module(name,f,path,desc)
        # print('imported %s' % (name))
    except Exception:
        print('can not import: %s' % (name))
        g.es_print_exception()
</t>
<t tx="ekr.20121220111212.13267">def write_file(self,fn):

    assert g.os_path_exists(self.path),self.path
    fn = g.os_path_finalize_join(self.path,fn)
    f = open(fn,'w')
    f.write(self.file_template)
    for p in self.nodes:
        f.write(self.test_template % (self.clean(p.h),self.get_body(p)))
    f.close()
</t>
<t tx="ekr.20130810093044.16933"></t>
<t tx="ekr.20130810093044.16934"></t>
<t tx="ekr.20130810093044.16935">&gt; Moreover, support for session tracking and restoring becomes an instant
&gt; addition since just by oppening all the @path leo nodes under a "session"
&gt; node we can restore our session!

There was a thread about saving sessions some time ago.  Here's a
script from that thread which adds a @script node to your outline which
reloads the other outlines currently loaded when this outline is next
loaded.

tablist = g.findNodeAnywhere(c, '@script load tabs')
if not tablist:
    from leo.core.leoNodes import vnode
    v = vnode(c)
    v.h = '@script load tabs'
    v._linkAsNthChild(c.hiddenRootNode,
         len(c.hiddenRootNode.children))
tablist = g.findNodeAnywhere(c, '@script load tabs')
assert tablist
import time
b = ["# Generated %s\n"%time.strftime('%c')]
for oc in g.app.commanders():
    b.append("g.openWithFileName('%s', c)" % oc.fileName())
b.append("c.frame.bringToFront()")
b.append("c.setLog()")
tablist.b = '\n'.join(b)
</t>
<t tx="ekr.20130810093044.16936">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

I've found that having edits on a node in one outline simultaneously
reflected in another node in another outline works surprisingly well.

I do a lot of to-do item project managing with Leo, with lists of todo
items (managed with the todo plugin) in each projects outline.

A script rapidly assembles a global list of todo items using
the .../external/leosax.py parser to scan all the project files without
leo having to fully load them.  The script builds a tree of todo items
which uses the UNLs to make them into bookmarks which can jump to the
corresponding node in the project's outline, opening it if necessary.

Which works fine for general "what should I work on next" use, but is
still clumsy if you want to edit a lot of todo items at once, adjusting
due date or priority etc.  You have to double-click the item in the
global view to jump to its source in its project's outline, edit it
there, switch back to the main outline, etc.

So now the script which generates the global view tags the items with a
marker which, when seen by the todo plugin, causes it to apply todo
item edits in the global view to the corresponding node in the
project's file as well.  This means the first time you edit a todo item
there may be a pause while that project's outline is loaded, but
everything carries on as it should afterwards, and on-going todo item
editing is quick once the outlines are loaded.

I'll push the updated todo.py code which checks for a
v.u['annotate']['src_unl'] marker to know if a todo item is a proxy for
one in another file and propagate the edits, but unless you have a
script which assembles todo items from diverse files and tags them as
proxies it doesn't really do anything.

Really I just wanted to highlight how this approach, edits on a proxy
node causing the opening and editing of a node in another outline,
really can work in a usable way - I'm sure there are all sorts of
possible applications.
</t>
<t tx="ekr.20130810093044.16937">From: Matt Wilkie &lt;maphew@gmail.com&gt;

Kent, I echo your thoughts :)

as I was reading Terry's post I kept thinking I'd like to watch him work
sometime. A few times I've tried setting up a Todo system in Leo for
myself, but I've thus far always abandoned the project as it turned into
more work than a simpe pad and pen kept close at hand. (Albeit with
drawbacks. There's a pad at work, another at home, a 3rd in my jacket
sometimes, and content intermixed between them "on the wrong one").
</t>
<t tx="ekr.20130810093044.16938">From: "F.S." &lt;speech.free@gmail.com&gt;

It appears that the F-35 program could have benefited from your approach:
http://www.nytimes.com/2012/11/29/us/in-federal-budget-cutting-f-35-fighter-jet-is-at-risk.html?ref=us

They are still pasting paper on a wall to manage the project. Imagine if 
the project manager learned to use Leo.
</t>
<t tx="ekr.20130810093044.16939">From: Kent Tenney &lt;ktenney@gmail.com&gt;

That flow would sure make a great webcast!
</t>
<t tx="ekr.20130810093044.16940">From: Terry &lt;webtourist@gmail.com&gt;

I need to present to people who don't have leo installation, in easily 
readable format, the full content of a .leo file, not just the outline, but 
all nodes and all contents.

What do I need to do ?

===== Terry

You could run this script (below):

It only exports selected nodes, so if you want to export everything,
you have to select all the top level nodes, i.e. collapse all the nodes
so only the top level is visible, click the first one, and shift-click
the last one.

It exports to plain text... although you might be able to use the
template to describe HTML, not sure.

&gt; Terry, how do i run it ?  I'm guessing it's not at the cmdline like "python 
&gt; this_script.py" 

Right.  Paste the content into a node, then click the script-button
button to create a new button for running this script.  The button's
name will be the node's name, what it is doesn't matter but 'export'
would be an obvious choice.  Then select the node(s) you want exported
- presumably not including the node containing the script :)

Then it will ask for a file name and whether to include unexpanded
nodes.\

</t>
<t tx="ekr.20130810093044.16941">@language python

# template is everything between r""" and second """
# placeholders are H heading B body C children
# use \\n in B and C lines for conditional blank lines

template = r"""H
    B
  * C"""

lines=[]
exp_only = g.app.gui.runAskYesNoCancelDialog(
    c, 'Expanded nodes only?', 'Expanded nodes only?')
if exp_only == 'no':
    exp_only = False
    
def export_text(p, indent=''):
    
    spaces = ' '*(len(indent) - len(indent.lstrip(' ')))
    
    for line in template.split('\\n'):
        
        if 'H' in line:
            lines.append(indent + line.replace('H', p.h))
        elif 'B' in line and p.b.strip():
            prefix = line[:line.find('B')].replace('\\\\n', '\\n')
            for i in p.b.strip().split('\\n'):
                lines.append(spaces + prefix + i)
                prefix = line[:line.find('B')].replace('\\\\n', '')
            if line.endswith('\\\\n'):
                lines.append('')
        elif 'C' in line and (not exp_only or p.isExpanded()):
            prefix = line[:line.find('C')].replace('\\\\n', '\\n')
            for child in p.children():
                export_text(child, indent=spaces + prefix)
            if line.endswith('\\\\n'):
                lines.append('')
        elif 'C' not in line and 'B' not in line:
            lines.append(line)

if exp_only != 'cancel':
    for i in c.getSelectedPositions():
        export_text(i)
    
    filename = g.app.gui.runSaveFileDialog('Save to file')
    # filename = '/home/tbrown/del.txt'
    
    if filename is not None:
        open(filename,'w').write('\\n'.join(lines))
</t>
<t tx="ekr.20130810093044.16942">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Just pushed leo/external/leoftsindex.py:

Stand alone GUI free index builder for Leo's full text search system::

  python leoftsindex.py &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;...

If &lt;file&gt; does not contain '#' it's assumed to be a .leo file
to index, and is indexed.

If &lt;file&gt; does contain '#' it's assumed to be a .leo file
containing a list of .leo files to index, with the list in
the node indicated by the UNL after the #, e.g.::

   path/to/myfile.leo#Lists--&gt;List of outlines

In the latter case, if the node identified by the UNL has children,
the list of files to scan is built from the first line of the body
of each child node of the identified node (works well with bookmarks.py).
If the node identified by the UNL does not have children, the
node's body is assumed to be a simple text listing of paths to .leo files).

.. note::
    
    It may be necessary to quote the "file" on the command line,
    as the '#' may be interpreted as a comment delimiter::
        
        python leoftsindex.py "workbook.leo#Links"

</t>
<t tx="ekr.20130810093044.16943">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

Now I have basic functionality pushed to trunk.

If you want to "spawn" (posibbly several) system commands to background,
use g.procs.add(), like this ctrl+b script:

def L(*args):
    g.es("callback", args)

g.procs.add(['sleep', '4'], "que1")
g.procs.add(['sleep', '3'], "que1", L)
g.procs.add(['sleep', '2'], "que1")
g.procs.add(['sleep', '2'], "que2")

Note how que2 completes first. Idea is that commands in same queue depend
on each other, and thus need to run in sequential order.

This should make waiting for long lasting operations easier as the whole
Leo won't freeze until they are over (but you can still use the stdout /
stderr output from these calls, thanks to the optional callback)

API may change once I start using it (soon).



On Wed, Apr 17, 2013 at 2:48 PM, Ville M. Vainio &lt;vivainio@gmail.com&gt; wrote:

&gt; Often, I find myself wanting to execute system commands in serial fashion
&gt; (first in, first out), capture their output, and allow browsing it, BUT not
&gt; blocking Leo or ipython terminal.
&gt;
&gt; I'd like to show stderr and stdout in g.es, or separate log page, and
&gt; provide callback after task has been completed.
&gt;
&gt; Unless anyone has something like this already, I plan to create it "later"
&gt; with QProcess.
&gt;

</t>
<t tx="ekr.20130810093044.16944">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Wed, 17 Apr 2013 14:48:59 +0300
"Ville M. Vainio" &lt;vivainio@gmail.com&gt; wrote:

&gt; Often, I find myself wanting to execute system commands in serial fashion
&gt; (first in, first out), capture their output, and allow browsing it, BUT not
&gt; blocking Leo or ipython terminal.
&gt; 
&gt; I'd like to show stderr and stdout in g.es, or separate log page, and
&gt; provide callback after task has been completed.

There's the leoscreen stuff for integration with the GNU `screen`
terminal switcher / manager.  Push lines from the body to the terminal,
pull lines back the other way.  But more for interactive interaction
with terminal programs than batch oriented work.  Leo doesn't block.

Cheers -Terry

&gt; Unless anyone has something like this already, I plan to create it "later"
&gt; with QProcess.
&gt; 

</t>
<t tx="ekr.20130810093044.16945">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

I've added an abbreviation to my myLeoSettings.leo abbreviations:
https://gist.github.com/tbnorth/5530059

It's the abbreviation "persist;;" and when you type that you get:

---cut here---
import json

json_state_file = "cache_info_file.json"
if not os.path.exists(json_state_file):
    json.dump({'cache_items':{}}, open(json_state_file, 'w'))
cache_info = json.load(open(json_state_file))

def main():

    # do stuff with cache_info...

if __name__ == '__main__':

    try:
        main()
    except:
        json.dump(cache_info, open(json_state_file, 'w'))
---cut here---

with appropriate interaction to customize all the parts which, in the
above example, include "cache_", i.e. the filename and the variable
name.

The point is it seems silly to create a module and hence a dependency
for what is barely 4 lines of actual code, but those 4 lines give you
very handy robust persistence, so something like an editor abbreviation
is the obvious way to make the available - nothing Leo specific here,
except that only serious editors have abbreviation like that ;-).
</t>
<t tx="ekr.20130810093044.16946">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Thu, May 23, 2013 at 2:41 PM, Terry Brown &lt;terry_n_brown@yahoo.com&gt;wrote:

&gt; I've added [an abbreviation] "persist;;"

[snip]

How do you use the code inserted by the abbreviation?  I suspect I'm not
the only one who doesn't understand what you are trying to do...
</t>
<t tx="ekr.20130810093044.16947">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

p.s. the 'except:' in the code below should have been 'finally:', fixed
on the gist now.

On Thu, 23 May 2013 14:41:31 -0500
Terry Brown &lt;terry_n_brown@yahoo.com&gt; wrote:

&gt; I've added an abbreviation to my myLeoSettings.leo abbreviations:
&gt; https://gist.github.com/tbnorth/5530059
&gt; 
&gt; It's the abbreviation "persist;;" and when you type that you get:
&gt; 
&gt; ---cut here---
&gt; import json
&gt; 
&gt; json_state_file = "cache_info_file.json"
&gt; if not os.path.exists(json_state_file):
&gt;     json.dump({'cache_items':{}}, open(json_state_file, 'w'))
&gt; cache_info = json.load(open(json_state_file))
&gt; 
&gt; def main():
&gt; 
&gt;     # do stuff with cache_info...
&gt; 
&gt; if __name__ == '__main__':
&gt; 
&gt;     try:
&gt;         main()
&gt;     except:
&gt;         json.dump(cache_info, open(json_state_file, 'w'))
&gt; ---cut here---
&gt; 
&gt; with appropriate interaction to customize all the parts which, in the
&gt; above example, include "cache_", i.e. the filename and the variable
&gt; name.
&gt; 
&gt; The point is it seems silly to create a module and hence a dependency
&gt; for what is barely 4 lines of actual code, but those 4 lines give you
&gt; very handy robust persistence, so something like an editor abbreviation
&gt; is the obvious way to make the available - nothing Leo specific here,
&gt; except that only serious editors have abbreviation like that ;-).
&gt; 
&gt; Cheers -Terry
&gt; 

</t>
<t tx="ekr.20130810093044.16948">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Fri, 24 May 2013 16:35:59 -0500
"Edward K. Ream" &lt;edreamleo@gmail.com&gt; wrote:

&gt; On Thu, May 23, 2013 at 2:41 PM, Terry Brown &lt;terry_n_brown@yahoo.com&gt;wrote:
&gt; 
&gt; &gt; I've added [an abbreviation] "persist;;"
&gt; 
&gt; 
&gt; [snip]
&gt; 
&gt; How do you use the code inserted by the abbreviation?  I suspect I'm not

The corrected version is below for reference - I had `except` instead
of `finally` in the first version, so you data was only saved if
something went wrong :-)

It's just a framework for providing a dictionary the contents of which
persist between runs of the program.  I've used it for code that's
making lots of small url requests against a server, to cache the
results so that during development the crash / debug / re-run cycle is
faster because each piece of data is requested only once, ever, not once
every run.  More recently I was using it to store key value pairs of
filenames and a comment on the issue in the file, knowing that
completing the analysis of the issues in the files would take more than
one run of the program which was identifying the issues.

So in the example below, the content of the cache_info dictionary is
persistent, whatever main() does with it is seen next time the
program's run.  Nothing Leo specific except that it's really just an
import statement plus 5 lines of code and doesn't seem worth its own
file, but is more than you want to re-type all the time either, so
ideal for an abbreviation in your favorite editor.

I've added a couple of comments in the version below.

Cheers -Terry

---cut here---
import json

# name for persistent data store
json_state_file = "cache_info_file.json"   
if not os.path.exists(json_state_file):
    # create persistent data store if it doesn't exist
    json.dump({'cache_items':{}}, open(json_state_file, 'w'))
# load persistent data
cache_info = json.load(open(json_state_file))

def main():

    # do stuff with cache_info...

if __name__ == '__main__':

    try:
        main()
    finally:
        # save altered persistent data
        json.dump(cache_info, open(json_state_file, 'w'), indent=4)
---cut here---

&gt; the only one who doesn't understand what you are trying to do...
&gt; 
&gt; Edward
&gt; 

</t>
<t tx="ekr.20130810093044.16949">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

The script below is a tool for diffing two Leo files. The attached
screenshot illustrates the output for two different revisions of
LeoPyRef.leo.

``- nodename``
    indicates a node which disappeared
``+ nodename``
    a node which is new,
``!v nodename`` followed by ``!^ nodename``
    a node with an unchanged heading but changed content, the first
    linking to the old version, the second linking to the new version

If you have the bookmarks.py plugin active, you can double click nodes
to jump to the original(s).



from leo.core.leoNodes import vnode
if not hasattr(vnode, 'insertAsLastChild'):
    # add insertAsLastChild method to vnodes
    def ialc(self):
        vnode(self.context)._linkAsNthChild(self, len(self.children))
        return self.children[-1]
    vnode.insertAsLastChild = ialc

from_filename = g.app.gui.runOpenFileDialog('From (old) file', [('Leo', '*.leo')])
to_filename = g.app.gui.runOpenFileDialog('To (new) file', [('Leo', '*.leo')])

# from_filename = "/mnt/shuttle/bkup/usr1/2012-07-13/home/tbrown/.leo/.todo.leo"
# to_filename = "/mnt/shuttle/bkup/usr1/2012-07-15/home/tbrown/.leo/.todo.leo"

from_c = g.openWithFileName(from_filename, c)
to_c = g.openWithFileName(to_filename, c)

vf = from_c.hiddenRootNode
vt = to_c.hiddenRootNode

assert from_c != c
assert to_c != c
assert from_c != to_c

nd = c.rootPosition().insertAfter()
nd.copy().back().moveAfter(nd)
nd.h = 'diff @bookmarks'

def text_match(a, b):
    return (a.h == b.h, 
            a.h == b.h and a.b == b.b)
def gnx_match(a, b):
    return (a.h == b.h and a.gnx == b.gnx, 
            a.h == b.h and a.b == b.b and a.gnx == b.gnx)

def diff_trees(vf, vt, path):

    fonly = []  # nodes only in from tree
    tonly = []  # nodes only in to tree
    diffs = []  # nodes which occur in both but have different descendants

    # count number of times each headline occurs as a child of
    # each node being compared
    count_f = {}
    for cf in vf.children:
        count_f[cf.h] = count_f.get(cf.h, 0) + 1
    count_t = {}
    for ct in vt.children:
        count_t[ct.h] = count_t.get(ct.h, 0) + 1

    for cf in vf.children:
        
        for ct in vt.children:
            
            if count_f[cf.h] == 1 and count_t[ct.h] == 1:
                equal = text_match
            else:
                equal = gnx_match
            
            head_eq, body_eq = equal(cf, ct)
            
            if body_eq:
                diffs.append(diff_trees(cf, ct, path+[vf.h]))
                
                break
            elif head_eq:
                d = diff_trees(cf, ct, path+[vf.h])
                if d:
                    d.h = '!v '+d.h
                else:
                    d = vnode(nd.v.context)
                    d.h = '!v '+cf.h
                d.b = "file://%s/#%s\\n\\n%s" % (
                    from_filename, 
                    '--&gt;'.join((path+[vf.h]+[cf.h])[1:]),
                    cf.b
                )
                diffs.append(d)
                d = vnode(nd.v.context)
                d.h = '!^ '+cf.h
                d.b = "file://%s/#%s\\n\\n%s" % (
                    to_filename, 
                    '--&gt;'.join((path+[vt.h]+[ct.h])[1:]),
                    ct.b
                )
                diffs.append(d)
                break
        else:
            fonly.append(cf)
            
    for ct in vt.children:
        
        for cf in vf.children:
            
            if count_f[cf.h] == 1 and count_t[ct.h] == 1:
                equal = text_match
            else:
                equal = gnx_match
            
            head_eq, body_eq = equal(cf, ct)
            if head_eq or body_eq:
                # no need to recurse matches again
                break

        else:
            tonly.append(ct)

    if not any(diffs) and not fonly and not tonly:
        return None
        
    vd = vnode(nd.v.context)
    vd.h = vf.h
    for d in diffs:
        if d:
            vd.children.append(d)
    for f in fonly:
        n = vd.insertAsLastChild()
        n.h = '- '+f.h
        n.b = "file://%s/#%s" % (from_filename, '--&gt;'.join((path+[vf.h]+[f.h])[1:]))
    for t in tonly:
        n = vd.insertAsLastChild()
        n.h = '+ '+t.h
        n.b = "file://%s/#%s" % (to_filename, '--&gt;'.join((path+[vf.h]+[t.h])[1:]))
        
    return vd

v = diff_trees(vf, vt, [])
if v:
    nd.v.children.extend(v.children)  # snip off &lt;hidden root node&gt;

c.bringToFront()
c.redraw()

</t>
<t tx="ekr.20130810093044.16950">From: resi147 &lt;scalet@yebu.de&gt;

I tried this one and it seems to be very useful. What I would also like to 
have is a similar (or the same) script,
that does the same on two different nodes of a leo file. I admit, the 
changes should be minimal to be done by
myself, but as I'm not familiar with the internal leo api, I wanted to ask 
for how to best do this changes.

Probably somewhere here
"""
...
vf = from_c.hiddenRootNode 
vt = to_c.hiddenRootNode
...
"""
just to feed in the 2 nodes, Any quick idea how this can be done the best 
way?

Cheers,
Karl.

</t>
<t tx="ekr.20130810093044.16951"></t>
<t tx="ekr.20130810093044.16954">@language python

'''Script to create global data structures from modes/*.py files.'''

import glob
import imp

g.cls()

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
aList = glob.glob(theDir)

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes')

# print('-'*40)
known_keys = list(g.app.language_delims_dict.keys())
new_languages = {}

for z in aList:
    name = g.os_path_basename(z)
    name2 = name[:-3]
    if name2 in known_keys or name2.startswith('__'):
        if 0: print('ignore: %s' % (name2))
    else:
        try:
            theFile, pathname, description = imp.find_module(name2,[theDir])
            m = imp.load_module(name2, theFile, pathname, description)
            if hasattr(m,'properties'):
                # new_languages.append(name2)
                new_languages[name2] = m
            else:
                print('no properties: %s %s' % (name2,m))
        except Exception:
            g.es_exception()
            
print('%s new languages\n' % (len(list(new_languages.keys()))))
    
for key in sorted(new_languages.keys()):
    m = new_languages.get(key)
    aList2 = [m.properties.get(z)
        for z in ('lineComment','commentStart','commentEnd')
            if m.properties.get(z)]
    print('%-20s : "%s",' % (
        '"%s"' % (key),
        ' '.join(aList2)))
    # computed[name2] = ' '.join(aList2)
       
if 0:
    mismatches = 0
    print()
    for z in known_keys:
        val = g.app.language_delims_dict.get(z)
        val2 = computed.get(z)
        if not val:
            print('no val',z)
        elif not val2:
            print('no val2',z)
        elif val != val2:
            mismatches += 1
            print('mismatch for %s. expected %s got %s' % (z,repr(val),repr(val2)))
            print(repr(val))
            print(repr(val2))
    print('%s mismatches' % mismatches)
</t>
<t tx="ekr.20130810093044.16955">@language python

'''Slow script.'''

import glob
import imp

@others

if 0: # The other script is much faster.
    
    keys = ("lineComment","commentStart","commentEnd",)
    d = {}
        # Keys are language names.
        # Values are a list of comment delims, in keys order.
    
    paths,modes_path = get_paths()
    for path in paths:
        module_name = g.shortFileName(path)[:-3]
        module = import_module(module_name,modes_path)
        aList = []
        for key in keys:
            val = module.properties.get(key)
            if val: aList.append(val)
        d[module_name] = aList
    
    print('-'* 20)
    print('language_delims_dict')
    for key in sorted(d):
        print('%16s: "%s"' % ('"%s"' % (key),' '.join(d.get(key))))
</t>
<t tx="ekr.20130810093044.16956">def get_paths():
    
    modes_path = g.os_path_finalize_join(g.app.loadDir,'..','modes')
    pattern = g.os_path_finalize_join(modes_path,'*.py')
    paths = glob.glob(pattern)
    paths = [z for z in paths if not z.endswith('__init__.py')]
    return paths,modes_path
</t>
<t tx="ekr.20130810093044.16957">def import_module(module_name,modes_path):
    
    data = imp.find_module(module_name,[modes_path])
        # This can open the file.
    theFile,pathname,description = data
    module = imp.load_module(module_name,theFile,pathname,description)
    return module
</t>
<t tx="ekr.20130810093044.16958"></t>
<t tx="ekr.20130810093044.16959">class ImportOrgMode:
    @others

def importOrgMode (self,event):
    c = self.c
    self.ImportOrgMode(c).go(c.p)
    c.bodyWantsFocus()

if False and g.app.inScript:
    print('='*40)
    ImportOrgMode(c).test()
    print('done')
</t>
<t tx="ekr.20130810093044.16960">def __init__ (self,c):
    
    self.c = c
</t>
<t tx="ekr.20130810093044.16961">def go (self,p):
    
    '''Prompt for a file and pass the contents to scan().'''
</t>
<t tx="ekr.20130810093044.16962">def scan (self,fn,p,s):

    self.c = c
    root = p.insertAsLastChild()
    root.h = fn
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        g.trace(repr(s))
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1
                level += 1
            if level &gt; len(stack):
                g.trace('bad level',repr(s))
                last = None
            elif level == len(stack):
                last = stack[-1]
                last.b = ''.join(body)
            else:
                last = stack[-1]
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            p = parent.insertAsLastChild()
            p.h = s.strip()
            stack.append(p)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        parent = stack[-1]
        parent.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
</t>
<t tx="ekr.20130810093044.16963">def test (self):
    
    s = '''
* A1
    a1.1
    a1.2
** B11
** B12
b12.1
*** C121
c121.1
    c121.2
c121.3
* A2
a2.1
** B21
*** C211
c211.1
*** C212
** B22
    b22.1
b22.1
* A3
* A4
a4.1
* A5
** B51
*** C511
**** D5111
***** E51111
** B52
*** C521
c521.1
'''

    tag = 'test-import-org-mode'
    p = g.findNodeAnywhere(c,tag)
    s = g.adjustTripleString(s,-4)
    if p:
        try:
            self.scan('test-file',p,s)
        except Exception:
            c.redraw(p)
    else:
        print('not found: %s' % tag)
</t>
<t tx="ekr.20130810093044.16964">'''Import each file in the files list after the presently selected node.'''


files = (
    r'c:\Users\edreamleo\test\import-org-mode.txt',
    r'c:\Users\edreamleo\test\import-org-mode.txt',
)

@others

for fn in files:
    try:
        root = c.p.copy()
        f = open(fn)
        s = f.read()
        scan(c,fn,s)
        c.selectPosition(root)
    except IOError:
        print('can not open %s' % fn)
</t>
<t tx="ekr.20130810093044.16965">def scan (c,fn,s):

    last = root = c.p.insertAsLastChild()
    last.h = g.shortFileName(fn)
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1 ; level += 1
            if level &gt; len(stack):
                g.trace('bad level',repr(s))
            elif level == len(stack):
                last.b = ''.join(body)
            else:
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            last = parent.insertAsLastChild()
            last.h = s.strip()
            stack.append(last)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        last.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
</t>
<t tx="ekr.20130810093044.16966"></t>
<t tx="ekr.20130810093044.16967">Should Leo support a standard template tool?
http://groups.google.com/group/leo-editor/browse_thread/thread/dd629473f4b3c4fc

Added a jinja2 templating example.  See:
    
file://../scripts/scripts.leo#Scripts--&gt;@thin%20leoScripts.txt--&gt;Important--&gt;Prototype%20of%20jinja%20@command%20nodes
</t>
<t tx="ekr.20130810093044.16969"></t>
<t tx="ekr.20130810093044.16970">From Brian Theado

The other day I stumbled across Ville's code in scripts.leo which displays the
output of python's trace module in a leo outline. The output of the trace module
is not very friendly and I didn't find the result very usable. I was inspired to
write some code to translate the output so the tree of function calls is
displayed via Leo headlines. Thanks to Ville for sharing that code. I never
would have figure this out without that starting point.

Just copy (Ctrl-Shift-V) the child outline into a leo outline and hit ctrl-b on
the "call tree" node. The execution tree of the 'scroll-outline-up-line'
minibuffer command will be displayed to stdout and also as a tree of leo
headlines.
</t>
<t tx="ekr.20130810093044.16971">import trace

@language python
@others

# http://docs.python.org/library/trace.html for documentation
# on the trace module
tracer = trace.Trace(countcallers=1)

# Trace a minibuffer command.

# Any function call will work. Leo's minibuffer commands are easily discoverable
# via tab completion and the 'print-commands' command.

#tracer.runfunc(c.executeMinibufferCommand, 'goto-prev-node')
tracer.runfunc(c.executeMinibufferCommand, 'scroll-outline-up-line')

top = p.insertAsLastChild().copy()
top.h = 'trace session'
displayCalltree(top, tracer.results().callers.keys())
c.redraw()
</t>
<t tx="ekr.20130810093044.16972">def displayCalltree(p, callinfo):
   '''
   Converts the function call hierarchy in 'callinfo' into a tree of function
   calls.  The function call tree is displayed to stdout as indented text
   and is inserted as a tree of leo nodes rooted at the given position 'p'
   '''
   callers = [k[0] for k in callinfo]
   callees = [k[1] for k in callinfo]

   # The first set of children will be those that don't have any callers
   # listed in callinfo
   toplevels = list(set(callers) - set(callees))
   positions = {}
   path = []

   # Depth-first traversal of the call hierarchy represented by 'callinfo'
   # 'levels' is a stack which grows during descend and shrinks
   # during ascend.  Each element of 'levels' is a list of unprocessed
   # siblings of each other
   levels = [toplevels]
   while len(levels) &gt; 0:
       while len(levels[-1]) &gt; 0:
           # Process the first element in the 'deepest' (i.e. last) list of siblings
           cur = levels[-1][0]
           levels[-1] = levels[-1][1:]
           indent = " " * 4 * (len(levels)-1)
           if cur not in path:
               if cur in positions.keys():
                   # Function already seen, so make a clone
                   clone = positions[cur].clone()
                   clone.moveToLastChildOf(p)
                   print (indent + "%s %s ..." % cur[1:])
               else:
                   # Haven't seen this function, so insert a new headline
                   p = p.insertAsLastChild().copy()
                   p.h = "%s %s" % cur[1:]
                   print (indent + p.h)

                   # Remember the position so it can be cloned if seen again
                   positions[cur] = p

                   # Find all callees of this function and descend
                   levels.append([c[1] for c in callinfo if c[0] == cur])
                   path.append(cur)
           else:
               r = p.insertAsLastChild().copy()
               r.h = "(recursive call) %s %s" % (cur[1], cur[2])
               print(indent + r.h + "...")

       # Ascend back up one level
       path = path[0:-1]
       p = p.parent()
       levels = levels[0:-1]
</t>
<t tx="ekr.20130810093044.16973"></t>
<t tx="ekr.20130812034101.12556"></t>
<t tx="ekr.20130812034101.12558">@language python

@ Matt Wilkie &lt;maphew@gmail.com&gt;

Here is a recipe using the pip python installer, that adds docutils to
python 3 in about 5 minutes. Ideally the same template/process would be
extended for all of Leo, and wrapped up in a nice package.

Depends on win32 `curl.exe` being available,
http://curl.haxx.se/dlwiz/?type=bin&amp;os=Win32&amp;flav=-&amp;ver=-

There are lots of scary looking warnings and messages emitted to the
console, mostly about unicode and files looked for and not found. A couple
of places I needed to tap [enter] (with no prompt saying that was
necessary). At the "install docutils" stage there was a long pause with
nothing apparent happening, perhaps 3 minutes.

The command shell was a generic windows cmd.exe shell with no python
variables set (e.g. PYTHONPATH, PYTHONHOME, etc.)

Recipe adapted from http://trac.osgeo.org/osgeo4w/wiki/ExternalPythonPackages
@c

pushd c:\\python32

:: test for docutils
python -c "import docutils; dir(docutils)"

::Traceback (most recent call last):
::  File "&lt;string&gt;", line 1, in &lt;module&gt;
::ImportError: No module named docutils

:: install python `distribute`
curl http://python-distribute.org/distribute_setup.py | python

:: install pip
curl --insecure https://raw.github.com/pypa/pip/master/contrib/get-pip.py |
python

::install docutils
.\\scripts\\pip.exe install docutils

:: test that docutils is available
python -c "import docutils; help(docutils)"

::Help on package docutils:
::
::NAME
::    docutils - This is the Docutils (Python Documentation Utilities)
package.
::
::DESCRIPTION
::    Package Structure
::    =================
::: ...snip...
</t>
<t tx="ekr.20130816100419.23046">@language python

&lt;&lt; docstring &gt;&gt;

from PyQt4 import QtGui, QtCore
from xml.sax.saxutils import escape

def add_html(html, nd):
    """recursively add to an html list with links to nodes"""
    
    unl = nd.get_UNL()
    html.append("&lt;div class='level'&gt;"
        "&lt;div&gt;&lt;a href='%s' title='%s'&gt;%s&lt;/a&gt;&lt;/div&gt;" %
        (unl, unl, escape(nd.h)))
    html.append("&lt;pre&gt;%s&lt;/pre&gt;"%escape(nd.b))
    for child in nd.children():
        add_html(html, child)
    html.append("&lt;/div&gt;")

def make_overview(c):
    """build the overview widget"""

    te = QtGui.QTextBrowser()
    te.setReadOnly(True)
    te.setOpenLinks(False)
    
    def anchorClicked(url, c=c, te=te):
        
        url = str(url.toString())
        g.handleUrl(url,c=c,p=c.p)
        
        if te.ctrl_click:
            te.deleteLater()
        
    te.anchorClicked.connect(anchorClicked)
    
    def mousePressEvent(event, te=te, original=te.mousePressEvent):
        te.ctrl_click = bool(event.modifiers() &amp; QtCore.Qt.ControlModifier)
        original(event)
    
    te.mousePressEvent = mousePressEvent
    
    html = ["""&lt;html&gt;&lt;head&gt;&lt;style&gt;
    .level .level {margin-left: 1.5em}
    a {text-decoration: none; font-size: 120%}
    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;"""]
    
    for nd in c.getSelectedPositions():
        add_html(html, nd)

    html.append("&lt;/body&gt;&lt;/html&gt;") 
    
    html = '\\n'.join(html)
    
    te.setHtml(html)
    
    return te

class OverviewPaneProvider:
    def __init__(self, c):
        self.c = c
        # Careful: we may be unit testing.
        if hasattr(c, 'free_layout'):
            splitter = c.free_layout.get_top_splitter()
            if splitter:
                splitter.register_provider(self)
    def ns_provides(self):
        return[('Overview', '_add_overview_pane')]
    def ns_provide(self, id_):
        if id_ == '_add_overview_pane':
            w = make_overview(c)
            return w
    def ns_title(self, id_):
        if id_ == '_add_overview_pane':
            return "Leo Outline Overview"
    def ns_provider_id(self):
        # used by register_provider() to unregister previously registered
        # providers of the same service
        return "outline overview window"

OverviewPaneProvider(c)
</t>
<t tx="ekr.20130816100419.23047">''' The script sets up Leo to display all the parts of the tree (all bodies
and subheadings) as continuous text, much like a word processor outline.

By Terry Brown

1) Paste the code below into a node, then hit the "run-script" button.

2) Then select a node with some hierarchy, not too much.

3) Then right click on the panel dividers between the tree / body / log
   panes, you should see a context menu with an "Open Window" sub-menu,
   which should contain an "Overview" item.

You should get a continuous view of the hierarchy with clickable
headlines which take you to the node.

You can select multiple nodes in step 2 above, with normal list Ctrl-
or Shift- click operations.  Nodes are shown in the overview in the
order selected.  This is how you'd generate the overview for a whole
outline - i.e. contract the whole outline, click the first top level
node, shift click the last top level node, and then step 3.

You can also embed the overview in a pane in the Leo window by select
"Insert" rather than "Open window" in step 3, click the action button
and select Overview.

This was the low hanging fruit, based on code used in bookmarks.py.  A
refresh button for the outline wouldn't be too hard, but right now
you need to close the window / pane and open it again to refresh.
'''
</t>
<t tx="ekr.20130920214241.12461"># The list of all changed methods in the grand reorg at revs 6016-6020
aList = [
'color','configureBorder','configureFont',
'createBindings','createFindPanel','createFindTab','createFrame',
'createRootWindow',
'disable','enable','forceLogUpdate'
'getFont','getFontConfig','getFrame',
'headWidth','interrupt','isEnabled','isSameColorState',
'kill','killGui','killPopupMenu',
'onActivate','onActivateLog',
'recreateRootWindow','restoreAllState',
'saveAllState','setBindings','setCanvasBindings','setColorFromConfig',
'setDisabledHeadlineColors','setEditHeadlineColors','setEditLabelState',
'setFocus','setFont','setFontFromConfig',
'setMinibufferBindings','setTabBindings',
'setUnselectedHeadlineColors','setUnselectedLabelState',
'setWidgetFontFromConfig',
'widthInPixels',
]
g.cls()
seen = set()
p = g.findNodeAnywhere(c,'Plugins')
for p in p.subtree():
    for name in aList[:]:
        i = 0
        s = p.b
        while i &lt; len(s):
            progress = i
            i = p.b.find('.'+name,i)
            if i == -1: break
            if g.match_word(s,i,'.'+name):
                print('%s %s' % (name,p.h))
                seen.add(name)
                aList.remove(name)
                break
            else:
                i += 1
            assert progress &lt; i,(i,progress)
for z in sorted(seen):
    print(z)
print('**done')</t>
<t tx="ekr.20140312052111.19343"># As of Qt 4.8, the following script can be executed to set line spacing
# to 190% for the given outline for the current session.

from PyQt4 import QtGui,QtCore,QtGlobal

def hook(tag, kwds, c=c):
  if kwds['c'] != c:
      return
  bodyWidget = c.frame.body.bodyCtrl.widget
  doc = bodyWidget.document()
  for i in range(doc.blockCount()):
      block = doc.findBlockByNumber(i)
      curs = QtGui.QTextCursor(block)
      fmt = block.blockFormat()
      fmt.setLineHeight(190, QtGui.QTextBlockFormat.ProportionalHeight)
      curs.setBlockFormat(fmt)

if True: # Doesn't work: QtCore.QT_VERSION &gt;= QtGlobal.QT_VERSION_CHECK(4,8,0):
    g.registerHandler("select3", hook)
else:
    g.es('this script requires Qt 4.8 or above')</t>
<t tx="ekr.20140426052603.18106">'''Replace "g.choose(test,a,b)" by "a if test else b".'''

replace = False # True: make the actual replacements

class Controller:
    @others

if 0: # Testing convenience...
    g.cls()
    c.save()
    p = g.findNodeAnywhere(c,'Code')
    assert(p)
Controller().run(c,p,replace)
</t>
<t tx="ekr.20140426052603.18107">def run(self,c,p,replace):
    '''Main line for undoable replace g.choose with ternary operator.'''
    changed,n,found,p1 = 0,0,0,p.copy()
    dirtyVnodeList,tag,u = [],'replace g.choose',c.undoer
    u.beforeChangeGroup(p1,tag)
    for p in p.self_and_subtree():
        s,i = p.b,0
        n += 1
        while i &lt; len(s):
            progress = i
            i,j = self.find(s,i)
            if i == -1: break
            found += 1
            s,i = self.replace(s,i,j)
            assert progress &lt; i
        if replace and p.b != s:
            changed += 1 
            b = c.undoer.beforeChangeNodeContents(p)
            dirtyVnodeList2 = p.setDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            p.b = s
            c.undoer.afterChangeNodeContents(p,tag,b)
    u.afterChangeGroup(p1,tag,dirtyVnodeList=dirtyVnodeList)
    print('scanned %s nodes found %s changed: %s' % (n,found,changed))
</t>
<t tx="ekr.20140426052603.18108">def find(self,s,i):
    '''
    Return (n1,n2) such that s[n1:n2] is the next choose(cond,a,b) in s[i:].
    Return -1,-1 if there no more are found.
    '''
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch in '"\'':
            i = g.skip_python_string(s,i,verbose=False)
        elif ch == '#':
            i = g.skip_line(s,i) # This eats the comment!
        # elif ch == '(':
            # i = g.skip_matching_python_delims(s,i,'(',')')
            # if i &gt; -1: assert s[i] == ')'
        else:
            for tag in ('g.choose(',): # 'choose('):
                if s[i:].startswith(tag):
                    # g.trace(s[i:i+20].strip())
                    i1 = i
                    i += len(tag)-1
                    i = g.skip_matching_python_delims(s,i,'(',')')
                    if i &gt; -1:
                        assert s[i] == ')',repr(s[i:i+20])
                        return i1,i+1
            else:
                i += 1
        if i == -1: i = progress + 1
        assert progress &lt; i,(i,s,ch)
    return -1,-1
</t>
<t tx="ekr.20140426052603.18109">def get_arg(self,s,i):
    '''return j such that s[i:j] is the argument.'''
    assert s[i] in '(,',repr(s[i:i+10])
    i += 1
    result = []
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch in ',)':
            break
        if ch in ' \t\n':
            # Don't put leading ws, and don't duplicate ws.
            if len(result) &gt; 0 and result[-1] != ' ':
                result.append(' ')
            i += 1
        elif ch in '"\'':
            j = g.skip_python_string(s,i,verbose=False)
            if j &gt; -1:
                result.append(s[i:j])
                i = j
            else:
                i += 1
        elif ch == '#':
            i = g.skip_line(s,i) # This eats the comment.
        elif ch == '(':
            j = g.skip_matching_python_delims(s,i,'(',')')
            assert s[j] == ')',s[j:j+10]
            result.append(s[i:j+1])
            i = j+1
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i
    assert s[i] in ',)'
    s = ''.join(result)
    return s,i
</t>
<t tx="ekr.20140426052603.18110">def munge(self,s):
    '''Compute the ternary operator corresponding to s.'''
    g.trace('1:',s)
    for tag in ('g.choose',): # 'choose'):
        if s.startswith(tag):
            i = len(tag)
            break
    else: assert False
    assert s[i] == '('
    args = []
    for n in (0,1,2):
        arg,i = self.get_arg(s,i)
        assert arg
        args.append(arg)
    arg1,arg2,arg3 = args
    result = '%s if %s else %s' % (arg2,arg1,arg3)
    g.trace('2:',result)
    return result</t>
<t tx="ekr.20140426052603.18111">def replace(self,s,i,j):
    '''Replace s[i:j] containing a g.trace, with the corresponding ternaty operator.'''
    s1 = s[i:j]
    s2 = self.munge(s1)
    if s1 == s2:
        return s,j
    else:
        s3 = s[:i] + s2 + s[j:]
        j = i + len(s2)
        return s3,j
</t>
<t tx="ekr.20140704052551.17941"># https://groups.google.com/forum/?fromgroups=#!searchin/leo-editor/leo$20script/leo-editor/ANPuhuEIU9c/8lgid9MNKkAJ

@language python
@tabwidth -4

'''Tell Windows how to handle .leo files, enables double clicking on them to open.

To run: in Leo make this the active node and press [Ctrl-B] (execute-script)

It opens a command shell and uses `assoc` and `ftype` commands to inform Windows
where python.exe and the Leo launch script is. It's the equivalent of:

    assoc .leo=Leo.File
    ftype Leo.File="B:\Python27\pythonw.exe" "B:\apps\leo-editor\launchLeo.py" "%1" %*   
       
Requires elevated User Account Control (UAC) priviliges.
See http://superuser.com/questions/88491/force-cmd-exe-to-run-as-admin/
'''

pyexe = g.sys.executable
leo = g.os_path_finalize_join(g.computeLeoDir(), '../launchLeo.py')

tmp = g.os.environ['TEMP']

assoc_cmd = 'assoc .leo=Leo.File'
ftype_cmd = 'ftype Leo.File="{0}" "{1}" "%1" %*'.format(pyexe, leo)

g.es(leo)
g.es(pyexe)

g.es(tmp)
g.es(assoc_cmd)
g.es(ftype_cmd)

from subprocess import Popen
Popen('start "Shell from Leo" cmd.exe /k "{0} &amp;&amp; {1}" '.format(assoc_cmd, ftype_cmd),

    cwd=tmp, shell=True)
</t>
<t tx="ekr.20140704052551.17946">'''
This leo script _almost_ adds an icon to .leo files in Windows. I say
almost in that on my system it runs without error, the associated registry
key is created and contains the right path, but Windows still doesn't know
what to do with the file.

It's intended to be run after "create-leobat" has been run and the Leo.File
filetype is already present.

Anyone else have some ideas how to improve it?
'''

from _winreg import *
def register_leo_icon():
    '''Tell Windows what icon to use for the  Leo.File filetype (.leo)

    Resources:

http://stackoverflow.com/questions/2331690/how-to-set-a-icon-file-while-creating-file

http://stackoverflow.com/questions/771689/how-can-i-set-an-icon-for-my-own-file-extension
    '''

    icon = "%s\\Icons\\LeoDoc.ico" % g.computeLeoDir()

    g.es("\\nAttempting to register leo icon with .leo files...")

    if g.os_path_exists(icon):
        g.es("Found:", icon)
        myTestKey = OpenKey(HKEY_CLASSES_ROOT, "Leo.File")
        iconKey= CreateKey(myTestKey, "DefaultIcon")
        CloseKey(myTestKey)

        SetValue(iconKey, None, REG_SZ, icon)
        CloseKey(iconKey)
        g.es("Registered!")
    else:
        g.es("LeoDoc.ico not in expected location, can't continue.")
</t>
<t tx="ekr.20140704052551.17948">@language batch

mkdir X:\testing
pushd X:\testing

wget -O apt.exe --no-clobber http://download.osgeo.org/osgeo4w/release/apt/apt-r1193M.exe
SET OSGEO4W_ROOT=%~dp0\root
apt setup
apt update
apt install pyqt4 sip

call root\osgeo4w.bat

wget --no-check-certificate http://gist.github.com/maphew/5393935/raw/install-pip.py
python install-pip.py GO
python install-pip.py GO

pip install -i https://testpypi.python.org/pypi leo-editor

python apps\Python27\Scripts\leo
</t>
<t tx="ekr.20140729094250.19180">import glob
pattern = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
for fn in glob.glob(pattern):
    sfn = g.shortFileName(fn)
    f = open(fn)
    s = f.read()
    f.close()
    if s.find(r'regexp="\\') &gt; -1:
        g.es(sfn)

@ found: Rules indicated are dubious or broken

md.py:
    [ \t]   leadins: 8,20,24,25(?),50,51
    space   leadins: 23,46,49
    [=-]    leadins: 21,47
    [\\_]   leadins: 54,55
    #       leadins: 22
    other   leadins: 7,12,19,53

moin.py:
    [ \t]           rule 3.
    single-quote    rule 6.

erlang.py:  no obvious problem.
lilypond.py:no obvious problem.
perl.py:    no obvious problem.
pl1.py:     no obvious problm.
rest.py:    no obvious problem.
rtf.py:     no obvious problem.
scala.py:   no obvious problem.
yaml.py:    fixed</t>
<t tx="ekr.20141105055521.13">@language rest

When working with a dictionary, some times I really need to "see it", so I needed this small script.
It will transform a dictionary into an outline, so you can navigate through it.
Just in case its useful for anyone, here it goes:

@language python

def dictionary_to_outline(p,dictionary):
    '''Transform a dictionary into an outline as p's children.'''
    # g.app.gui.frameFactory.masterFrame.currentWidget().leo_c
    sorted_keys = sorted([key for key in dictionary])
    for key in sorted_keys:
        new_node = p.insertAsLastChild().copy()
        new_node.h = key
        if "dict" in str(type(dictionary[key])):
            self.dictionary_to_outline(new_node,dictionary[key])
        else:
            new_node.b = str(dictionary[key])
</t>
<t tx="ekr.20141105055521.14">https://github.com/leo-editor/snippets/blob/master/utils/led.py

</t>
<t tx="ekr.20141105055521.15">@language python
'''A script used while investigating this bug.'''
# g.cls()
d = {}
x = g.app.nodeIndices
result = []
for v in c.all_unique_nodes():
    gnx = v.fileIndex
    assert g.isUnicode(gnx),gnx
    d [gnx] = v
    result.append('%s %s' % (gnx,v))
print('%s v.fileIndex\'s...' % len(result))
print('\n'.join(sorted(result)))
if 1:
    d = c.fileCommands.gnxDict
    print('old: %s fc.gnxDict keys...' % len(list(d.keys())))
    for key in sorted(d.keys()): 
        print('%s %s' % (key,d.get(key)))
if 1:
    c.recreateGnxDict()
    d = c.fileCommands.gnxDict
    print('new: %s fc.gnxDict keys...' % len(list(d.keys())))
    for key in sorted(d.keys()): 
        print('%s %s' % (key,d.get(key)))
</t>
<t tx="ekr.20141105055521.16">@language python

'''
A script to replace body.x with body.wrapper.x for all x in the WrapperAPI.

It is *not undoable* to save massive amounts of memory.
Please run on an already-saved .leo file, and take all other
reasonable precautions.

If replace is False, it will just report the changes to be made.
'''
import leo.core.leoFrame as leoFrame
replace = False
aList = sorted([z for z in dir(leoFrame.WrapperAPI) if not z.startswith('__')])
nodes = 0
for p in c.all_unique_positions():
    s = p.b
    nodes += 1
    found = False
    for target in aList:
        i = 0
        pattern = 'body.' + target
        while True:
            i = s.find(pattern,i)
            if i == -1:
                break
            if g.match_word(s,i,pattern):
                if not found:
                    print('In node: %s' % p.h)
                    found = True
                i1,i2 = g.getLine(s,i)
                if replace:
                    j = i + len('body.')
                    s = s[:j] + 'wrapper.' + s[j:]
                    print(s[i1:i2+len('wrapper.')].rstrip())
                    i += len('wrapper.') + len(pattern)
                else:
                    print(s[i1:i2].rstrip())
                    i += len(pattern)
            else:
                i += len(pattern)
    if found and replace:
        p.b = s
</t>
<t tx="ekr.20141105055521.17">@language rest


https://groups.google.com/d/msg/leo-editor/f1ARsze-_XU/z6cqEMvybsQJ

I've found a delay timer to execute code is very useful. For example, if I
stopped typing for 5 seconds, It would execute 'Alt-X Ctrl-P' and execute
the last command which in my case is to produce my HTML (rst3) so I can
look at it. This would help editing, making it more interactive editing in
the rst3.

https://github.com/leo-editor/snippets/blob/master/on_typing_idle.py
</t>
<t tx="ekr.20141105055521.18">'''
From: Terry Brown

The script below is a tool for diffing two Leo files. The attached
screenshot illustrates the output for two different revisions of
LeoPyRef.leo.

``- nodename``
    indicates a node which disappeared
``+ nodename``
    a node which is new,
``!v nodename`` followed by ``!^ nodename``
    a node with an unchanged heading but changed content, the first
    linking to the old version, the second linking to the new version

If you have the bookmarks.py plugin active, you can double click nodes
to jump to the original(s).

'''
from leo.core.leoNodes import vnode
if not hasattr(vnode, 'insertAsLastChild'):
    # add insertAsLastChild method to vnodes
    def ialc(self):
        vnode(self.context)._linkAsNthChild(self, len(self.children))
        return self.children[-1]
    vnode.insertAsLastChild = ialc

from_filename = g.app.gui.runOpenFileDialog('From (old) file', [('Leo', '*.leo')])
to_filename = g.app.gui.runOpenFileDialog('To (new) file', [('Leo', '*.leo')])

# from_filename = "/mnt/shuttle/bkup/usr1/2012-07-13/home/tbrown/.leo/.todo.leo"
# to_filename = "/mnt/shuttle/bkup/usr1/2012-07-15/home/tbrown/.leo/.todo.leo"

from_c = g.openWithFileName(from_filename, c)
to_c = g.openWithFileName(to_filename, c)

vf = from_c.hiddenRootNode
vt = to_c.hiddenRootNode

assert from_c != c
assert to_c != c
assert from_c != to_c

nd = c.rootPosition().insertAfter()
nd.copy().back().moveAfter(nd)
nd.h = 'diff @bookmarks'

def text_match(a, b):
    return (a.h == b.h, 
            a.h == b.h and a.b == b.b)
def gnx_match(a, b):
    return (a.h == b.h and a.gnx == b.gnx, 
            a.h == b.h and a.b == b.b and a.gnx == b.gnx)

def diff_trees(vf, vt, path):

    fonly = []  # nodes only in from tree
    tonly = []  # nodes only in to tree
    diffs = []  # nodes which occur in both but have different descendants

    # count number of times each headline occurs as a child of
    # each node being compared
    count_f = {}
    for cf in vf.children:
        count_f[cf.h] = count_f.get(cf.h, 0) + 1
    count_t = {}
    for ct in vt.children:
        count_t[ct.h] = count_t.get(ct.h, 0) + 1

    for cf in vf.children:
        
        for ct in vt.children:
            
            if count_f[cf.h] == 1 and count_t[ct.h] == 1:
                equal = text_match
            else:
                equal = gnx_match
            
            head_eq, body_eq = equal(cf, ct)
            
            if body_eq:
                diffs.append(diff_trees(cf, ct, path+[vf.h]))
                
                break
            elif head_eq:
                d = diff_trees(cf, ct, path+[vf.h])
                if d:
                    d.h = '!v '+d.h
                else:
                    d = vnode(nd.v.context)
                    d.h = '!v '+cf.h
                d.b = "file://%s/#%s\\n\\n%s" % (
                    from_filename, 
                    '--&gt;'.join((path+[vf.h]+[cf.h])[1:]),
                    cf.b
                )
                diffs.append(d)
                d = vnode(nd.v.context)
                d.h = '!^ '+cf.h
                d.b = "file://%s/#%s\\n\\n%s" % (
                    to_filename, 
                    '--&gt;'.join((path+[vt.h]+[ct.h])[1:]),
                    ct.b
                )
                diffs.append(d)
                break
        else:
            fonly.append(cf)
            
    for ct in vt.children:
        
        for cf in vf.children:
            
            if count_f[cf.h] == 1 and count_t[ct.h] == 1:
                equal = text_match
            else:
                equal = gnx_match
            
            head_eq, body_eq = equal(cf, ct)
            if head_eq or body_eq:
                # no need to recurse matches again
                break

        else:
            tonly.append(ct)

    if not any(diffs) and not fonly and not tonly:
        return None
        
    vd = vnode(nd.v.context)
    vd.h = vf.h
    for d in diffs:
        if d:
            vd.children.append(d)
    for f in fonly:
        n = vd.insertAsLastChild()
        n.h = '- '+f.h
        n.b = "file://%s/#%s" % (from_filename, '--&gt;'.join((path+[vf.h]+[f.h])[1:]))
    for t in tonly:
        n = vd.insertAsLastChild()
        n.h = '+ '+t.h
        n.b = "file://%s/#%s" % (to_filename, '--&gt;'.join((path+[vf.h]+[t.h])[1:]))
        
    return vd

v = diff_trees(vf, vt, [])
if v:
    nd.v.children.extend(v.children)  # snip off &lt;hidden root node&gt;

c.bringToFront()
c.redraw()
</t>
<t tx="ekr.20141116105945.2"></t>
<t tx="ekr.20141116105945.3">gnx: maphew.20130809155103.2862
</t>
<t tx="ekr.20141116105945.4"></t>
<t tx="maphew.20130612230051.2793">Scripts only of interest when on Microsoft Windows platform.</t>
<t tx="tbrown.20141110113251.1">@g.command('x')
def add_note(args):
    """Create a global Alt-x command 'x' to quickly add a top level node
    to workbook.leo, if it's open, else the first open Leo outline, to
    quickly record a note / thought / to-do item.
    
    Marks the node as a priority 2 to-do item due today, titles the node
    with current date / time, and included date / time in body.
    """
    # search for workbook.leo
    for c in g.app.commanders():
        if c.fileName().endswith('workbook.leo'):
            break
    else:
        c = g.app.commanders()[0]  # or use first open outline
    
    # add a node a the top of the outline
    nd = c.rootPosition().insertAfter()
    nd.moveToRoot(c.rootPosition())
    
    # label the node and add to-do attributes
    import datetime, time
    nd.h = time.asctime()
    nd.b = "\n\n# %s\n\n" % nd.h 
    nd.v.u['annotate'] = {
        'duedate': datetime.date.today(),
        'created': datetime.datetime.now(),
        'nextworkdate': datetime.date.today(),
        'priority': 2,
    }

    # select the node and focus in body for immediate typing
    c.selectPosition(nd)
    c.cleo.loadIcons(nd)
    c.redraw()
    c.bringToFront()
    c.bodyWantsFocusNow()
</t>
</tnodes>
</leo_file>
