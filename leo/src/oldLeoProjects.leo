<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="120" left="340" height="630" width="909"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070626112503"><vh>@chapters</vh></v>
<v t="ekr.20070105153901"><vh>Tuple notes (revised originals)</vh>
<v t="ekr.20070105153901.1"><vh>Overview</vh></v>
<v t="ekr.20070105153901.2"><vh>Ahas</vh></v>
<v t="ekr.20070105153901.3"><vh>Block allocation</vh></v>
<v t="ekr.20070105153901.4"><vh>Stream allocation</vh></v>
<v t="ekr.20070105153901.5"><vh>Details</vh></v>
<v t="ekr.20070105153901.6"><vh>Deallocating objects</vh></v>
<v t="ekr.20070105153901.7"><vh>Debugging and production objects</vh></v>
<v t="ekr.20070105153901.8"><vh>Simplifications</vh></v>
<v t="ekr.20070105153901.9"><vh>Defining polymorphic streams</vh></v>
<v t="ekr.20070105153901.10"><vh>Using Streams</vh></v>
<v t="ekr.20070105153901.11"><vh>Lists Are Streams</vh></v>
<v t="ekr.20070105153901.12"><vh>Are any calls to calloc needed?</vh></v>
<v t="ekr.20070105153901.13"><vh>Abbreviation Macros</vh></v>
</v>
<v t="ekr.20071105090148"><vh>Old tests</vh>
<v t="ekr.20071105090148.1"><vh>print Tk bindings</vh></v>
<v t="ekr.20071105090148.2"><vh>byte-code tests</vh></v>
<v t="ekr.20071105090148.3"><vh>print .</vh></v>
<v t="ekr.20071105090148.4"><vh>Older tests</vh>
<v t="ekr.20071105090148.5"><vh>@@button Undo problem</vh></v>
<v t="ekr.20071105090148.6"><vh>@@nosent nosentTest.py</vh>
<v t="ekr.20071105090148.7"><vh>node a</vh></v>
</v>
<v t="ekr.20071105090148.8"><vh>@@thin ./newFolder4/createDirectoriestest.txt</vh></v>
<v t="ekr.20071105090148.9"><vh>@url http://webpages.charter.net/edreamleo/front.html  (Leo's home)</vh></v>
<v t="ekr.20071105090148.10"><vh>checkversion</vh></v>
<v t="ekr.20071105090148.11"><vh>code-block-regex</vh></v>
<v t="ekr.20071105090148.12"><vh>import bug</vh>
<v t="ekr.20071105090148.13"><vh>import</vh></v>
<v t="ekr.20071105090148.14"><vh>@@file C:/prog/test/import-bug.cpp</vh>
<v t="ekr.20071105090148.15"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.16"><vh>a</vh></v>
<v t="ekr.20071105090148.17"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.18"><vh>b</vh></v>
<v t="ekr.20071105090148.19"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.20"><vh>c</vh></v>
<v t="ekr.20071105090148.21"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.22"><vh>d</vh></v>
<v t="ekr.20071105090148.23"><vh>d</vh></v>
<v t="ekr.20071105090148.24"><vh>c</vh></v>
<v t="ekr.20071105090148.25"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.26"><vh>d</vh></v>
<v t="ekr.20071105090148.27"><vh>d</vh></v>
<v t="ekr.20071105090148.28"><vh>b</vh></v>
<v t="ekr.20071105090148.29"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.30"><vh>c</vh></v>
<v t="ekr.20071105090148.31"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.32"><vh>d</vh></v>
<v t="ekr.20071105090148.33"><vh>d</vh></v>
<v t="ekr.20071105090148.34"><vh>c</vh></v>
<v t="ekr.20071105090148.35"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.36"><vh>d</vh></v>
<v t="ekr.20071105090148.37"><vh>d</vh></v>
<v t="ekr.20071105090148.38"><vh>a</vh></v>
<v t="ekr.20071105090148.39"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.40"><vh>b</vh></v>
<v t="ekr.20071105090148.41"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.42"><vh>c</vh></v>
<v t="ekr.20071105090148.43"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.44"><vh>d</vh></v>
<v t="ekr.20071105090148.45"><vh>d</vh></v>
<v t="ekr.20071105090148.46"><vh>c</vh></v>
<v t="ekr.20071105090148.47"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.48"><vh>d</vh></v>
<v t="ekr.20071105090148.49"><vh>d</vh></v>
<v t="ekr.20071105090148.50"><vh>b</vh></v>
<v t="ekr.20071105090148.51"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.52"><vh>c</vh></v>
<v t="ekr.20071105090148.53"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.54"><vh>d</vh></v>
<v t="ekr.20071105090148.55"><vh>d</vh></v>
<v t="ekr.20071105090148.56"><vh>c</vh></v>
<v t="ekr.20071105090148.57"><vh>&lt;&lt; namespace arb declarations &gt;&gt;</vh></v>
<v t="ekr.20071105090148.58"><vh>d</vh></v>
<v t="ekr.20071105090148.59"><vh>d</vh></v>
</v>
</v>
<v t="ekr.20071105090148.60"><vh>subprocess test</vh></v>
<v t="ekr.20071105090148.61"><vh>test hash(fileIndex)</vh></v>
<v t="ekr.20071105090148.62"><vh>Test of clean-all-lines</vh>
<v t="ekr.20071105090148.63"><vh>a</vh></v>
<v t="ekr.20071105090148.64"><vh>b</vh></v>
</v>
<v t="ekr.20071105090148.65"><vh>test of p.archivedPosition</vh></v>
<v t="ekr.20071105090148.66"><vh>Test of wx indices</vh></v>
<v t="ekr.20071105090148.67"><vh>test dynamic abbrev</vh></v>
<v t="ekr.20071105090148.68"><vh>@@nosent refTest.html</vh>
<v t="ekr.20071105090148.69"><vh>&lt;&lt;relpath&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071105090148.70"><vh>Unicode tests</vh>
<v t="ekr.20071105090148.71"><vh>@url http://www.fileformat.info/tip/microsoft/enter_unicode.htm</vh></v>
<v t="ekr.20071105090148.72"><vh>test unicode escapes</vh></v>
<v t="ekr.20071105090148.73"><vh>@@button put utf-8</vh>
<v t="ekr.20071105090148.74"><vh>out utf-8</vh></v>
</v>
<v t="ekr.20071105090148.75"><vh>@@button get utf-8</vh>
<v t="ekr.20071105090148.76"><vh>in utf-8</vh></v>
</v>
<v t="ekr.20071105090148.77"><vh>@@button put utf-16</vh>
<v t="ekr.20071105090148.78"><vh>out utf-16</vh></v>
</v>
<v t="ekr.20071105090148.79"><vh>@@button get utf-16</vh>
<v t="ekr.20071105090148.80"><vh>in utf-16</vh></v>
</v>
<v t="ekr.20071105090148.81"><vh>Find value of character</vh></v>
<v t="ekr.20071105090148.82"><vh>test of g.isWordChar</vh></v>
<v t="ekr.20071105090148.83"><vh>Problem with unicode in body pane (but not in headline) Stéphane</vh></v>
<v t="ekr.20071105090148.84"><vh>word-forward test</vh></v>
<v t="ekr.20071105090148.85"><vh>Node containing unicode characters: Ę</vh></v>
<v t="ekr.20071105090148.86"><vh>Unicode characters in derived file names</vh>
<v t="ekr.20071105090148.87"><vh>@@thin Lasidoré.py</vh></v>
</v>
<v t="ekr.20071105090148.88"><vh>test of unicode print</vh></v>
<v t="ekr.20071105090148.89"><vh>Encoding</vh></v>
</v>
<v t="ekr.20071105090148.90"><vh>Tests of unl plugin</vh>
<v t="ekr.20071105090148.91"><vh>UNL's in @url nodes</vh>
<v t="ekr.20071105090148.92"><vh>@url 'ZODB--&gt;@button zodb-write'</vh></v>
<v t="ekr.20071105090148.93"><vh>@url 'file: ./../../plugins/leoPlugins.leo#Plugins--&gt;Icon and status areas--&gt;@thin UNL.py--&gt;To do'</vh></v>
</v>
<v t="ekr.20071105090148.94"><vh>@url -- comment test</vh></v>
<v t="ekr.20071105090148.95"><vh>@url 'file:c:/prog/tigris-cvs/leo/doc/leoDocs.leo#Users Guide'</vh></v>
<v t="ekr.20071105090148.96"><vh>@url Tests</vh></v>
<v t="ekr.20071105090148.97"><vh>@url 'file:./../doc/leoDocs.leo#Users Guide--&gt;Customizing Leo'</vh></v>
<v t="ekr.20071105090148.98"><vh>@url 'http://webpages.charter.net/edreamleo/front.html'</vh></v>
</v>
<v t="ekr.20071105090148.99"><vh>Problems with @path</vh>
<v t="ekr.20071105090148.100"><vh>@@file pathSepTest.txt</vh></v>
</v>
<v t="ekr.20071105090148.101"><vh>Up/down arrows with long lines</vh></v>
<v t="ekr.20071105090148.102"><vh>Cursor bugs</vh></v>
<v t="ekr.20071105090148.103"><vh>test of string problems</vh></v>
<v t="ekr.20071105090148.104"><vh>test of kill buffer</vh></v>
<v t="ekr.20071105090148.105"><vh>test of g.callers</vh></v>
<v t="ekr.20071105090148.106"><vh>Coloring tests</vh>
<v t="ekr.20071105090148.107"><vh>vbscript test</vh></v>
<v t="ekr.20071105090148.108"><vh>Medium coloring test</vh></v>
<v t="ekr.20071105090148.109"><vh>python colorizer bug</vh></v>
<v t="ekr.20071105090148.110"><vh>test of colored markup</vh></v>
<v t="ekr.20071105090148.111"><vh>test of @nocolor followed by @color</vh></v>
<v t="ekr.20071105090148.112"><vh>fortran test</vh>
<v t="ekr.20071105090148.113"><vh>child</vh></v>
</v>
<v t="ekr.20071105090148.114"><vh>Big coloring test</vh></v>
<v t="ekr.20071105090148.115"><vh>Test of docstring</vh></v>
<v t="ekr.20071105090148.116"><vh>Small coloring test</vh></v>
<v t="ekr.20071105090148.117"><vh>cSharpTest.c#</vh></v>
</v>
<v t="ekr.20071105090148.118"><vh>dialog</vh></v>
<v t="ekr.20071105090148.119"><vh>rst tests</vh>
<v t="ekr.20071105090148.120"><vh>@@thin rst-test.py</vh>
<v t="ekr.20071105090148.121"><vh>code part</vh>
<v t="ekr.20071105090148.122"><vh>@rst-no-head This is my rst comment</vh></v>
</v>
</v>
<v t="ekr.20071105090148.123"><vh>@@@rst rst-test.html</vh>
<v t="ekr.20071105090148.124"><vh>@rst-no-head docs</vh>
<v t="ekr.20071105090148.122"><vh>@rst-no-head This is my rst comment</vh></v>
<v t="ekr.20071105090148.125" tnodeList="ekr.20071105090148.125"><vh>@nosent nosent_file_test.py</vh></v>
</v>
</v>
<v t="ekr.20071105090148.126"><vh>@@rst rst-test.html</vh>
<v t="ekr.20071105090148.127"><vh>inner (language c)</vh></v>
</v>
</v>
<v t="ekr.20071105090148.128"><vh>color_markup test</vh></v>
<v t="ekr.20071105090148.129"><vh>@rst code-block-test.html</vh></v>
<v t="ekr.20071105090148.130"><vh>at-auto stuff</vh>
<v t="ekr.20071105090148.131"><vh>@@auto atAutoTest.py</vh>
<v t="ekr.20071105090148.132"><vh>atAutoTest declarations</vh></v>
<v t="ekr.20071105090148.133"><vh>class baseLeoImportCommands</vh>
<v t="ekr.20071105090148.134"><vh>__init__</vh></v>
<v t="ekr.20071105090148.135"><vh>convertCodePartToWeb</vh></v>
<v t="ekr.20071105090148.136"><vh>convertDocPartToWeb</vh></v>
<v t="ekr.20071105090148.137"><vh>convertVnodeToWeb</vh></v>
<v t="ekr.20071105090148.138"><vh>copyPart</vh></v>
<v t="ekr.20071105090148.139"><vh>exportHeadlines</vh></v>
<v t="ekr.20071105090148.140"><vh>flattenOutline</vh></v>
<v t="ekr.20071105090148.141"><vh>outlineToWeb</vh></v>
<v t="ekr.20071105090148.142"><vh>removeSentinelsCommand</vh></v>
<v t="ekr.20071105090148.143"><vh>removeSentinelLines</vh></v>
<v t="ekr.20071105090148.144"><vh>weave</vh></v>
<v t="ekr.20071105090148.145"><vh>createHeadline</vh></v>
<v t="ekr.20071105090148.146"><vh>error</vh></v>
<v t="ekr.20071105090148.147"><vh>getTabWidth</vh></v>
<v t="ekr.20071105090148.148"><vh>isDocStart</vh></v>
<v t="ekr.20071105090148.149"><vh>isModuleStart</vh></v>
<v t="ekr.20071105090148.150"><vh>massageComment</vh></v>
<v t="ekr.20071105090148.151"><vh>massageWebBody</vh></v>
<v t="ekr.20071105090148.152"><vh>setEncoding</vh></v>
<v t="ekr.20071105090148.153"><vh>createOutline</vh></v>
<v t="ekr.20071105090148.154"><vh>importDerivedFiles</vh></v>
<v t="ekr.20071105090148.155"><vh>forceGnxOnPosition</vh></v>
<v t="ekr.20071105090148.156"><vh>importFilesCommand</vh></v>
<v t="ekr.20071105090148.157"><vh>convertMoreStringToOutlineAfter</vh></v>
<v t="ekr.20071105090148.158"><vh>convertMoreStringsToOutlineAfter</vh></v>
<v t="ekr.20071105090148.159"><vh>importFlattenedOutline</vh></v>
<v t="ekr.20071105090148.160"><vh>moreHeadlineLevel</vh></v>
<v t="ekr.20071105090148.161"><vh>stringIsValidMoreFile</vh></v>
<v t="ekr.20071105090148.162"><vh>stringsAreValidMoreFile</vh></v>
<v t="ekr.20071105090148.163"><vh>createOutlineFromWeb</vh></v>
<v t="ekr.20071105090148.164"><vh>importWebCommand</vh></v>
<v t="ekr.20071105090148.165"><vh>findFunctionDef</vh></v>
<v t="ekr.20071105090148.166"><vh>scanBodyForHeadline</vh></v>
<v t="ekr.20071105090148.167"><vh>scanWebFile</vh></v>
<v t="ekr.20071105090148.168"><vh>cstCanonicalize</vh></v>
<v t="ekr.20071105090148.169"><vh>cstDump</vh></v>
<v t="ekr.20071105090148.170"><vh>cstEnter</vh></v>
<v t="ekr.20071105090148.171"><vh>cstLookup</vh></v>
<v t="ekr.20071105090148.172"><vh>perfectImport</vh></v>
<v t="ekr.20071105090148.173"><vh>class baseScannerClass</vh>
<v t="ekr.20071105090148.174"><vh>__init__</vh></v>
<v t="ekr.20071105090148.175"><vh>check</vh></v>
<v t="ekr.20071105090148.176"><vh>checkTabWithTabNanny</vh></v>
<v t="ekr.20071105090148.177"><vh>checkWhitespace</vh></v>
<v t="ekr.20071105090148.178"><vh>checkTrialWrite</vh></v>
<v t="ekr.20071105090148.179"><vh>compareHelper</vh></v>
<v t="ekr.20071105090148.180"><vh>addRef</vh></v>
<v t="ekr.20071105090148.181"><vh>createDeclsNode</vh></v>
<v t="ekr.20071105090148.182"><vh>createFunctionNode</vh></v>
<v t="ekr.20071105090148.183"><vh>createHeadline</vh></v>
<v t="ekr.20071105090148.184"><vh>getLeadingIndent</vh></v>
<v t="ekr.20071105090148.185"><vh>indentBody</vh></v>
<v t="ekr.20071105090148.186"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20071105090148.187"><vh>massageComment</vh></v>
<v t="ekr.20071105090148.188"><vh>putClass</vh></v>
<v t="ekr.20071105090148.189"><vh>appendRefToClassNode</vh></v>
<v t="ekr.20071105090148.190"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071105090148.191"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071105090148.192"><vh>putClassHelper</vh></v>
<v t="ekr.20071105090148.193"><vh>putFunction</vh></v>
<v t="ekr.20071105090148.194"><vh>putRootText</vh></v>
<v t="ekr.20071105090148.195"><vh>undentBody</vh></v>
<v t="ekr.20071105090148.196"><vh>underindentedComment</vh></v>
<v t="ekr.20071105090148.197"><vh>underindentedLine</vh></v>
<v t="ekr.20071105090148.198"><vh>error</vh></v>
<v t="ekr.20071105090148.199"><vh>oops</vh></v>
<v t="ekr.20071105090148.200"><vh>extendSignature</vh></v>
<v t="ekr.20071105090148.201"><vh>scan</vh></v>
<v t="ekr.20071105090148.202"><vh>skipArgs</vh></v>
<v t="ekr.20071105090148.203"><vh>skipBlock</vh></v>
<v t="ekr.20071105090148.204"><vh>skipCodeBlock</vh></v>
<v t="ekr.20071105090148.205"><vh>skipComment</vh></v>
<v t="ekr.20071105090148.206"><vh>skipBlockComment</vh></v>
<v t="ekr.20071105090148.207"><vh>skipDecls</vh></v>
<v t="ekr.20071105090148.208"><vh>adjustClassOrFunctionStart</vh></v>
<v t="ekr.20071105090148.209"><vh>skipId</vh></v>
<v t="ekr.20071105090148.210"><vh>skipNewline</vh></v>
<v t="ekr.20071105090148.211"><vh>skipParens</vh></v>
<v t="ekr.20071105090148.212"><vh>skipString</vh></v>
<v t="ekr.20071105090148.213"><vh>startsClass</vh></v>
<v t="ekr.20071105090148.214"><vh>startsFunction</vh></v>
<v t="ekr.20071105090148.215"><vh>startsHelper</vh></v>
<v t="ekr.20071105090148.216"><vh>skipSigStart</vh></v>
<v t="ekr.20071105090148.217"><vh>skipSigId</vh></v>
<v t="ekr.20071105090148.218"><vh>skipSigTail</vh></v>
<v t="ekr.20071105090148.219"><vh>startsComment</vh></v>
<v t="ekr.20071105090148.220"><vh>startsId</vh></v>
<v t="ekr.20071105090148.221"><vh>startsString</vh></v>
<v t="ekr.20071105090148.222"><vh>run</vh></v>
</v>
<v t="ekr.20071105090148.223"><vh>scanCText</vh></v>
<v t="ekr.20071105090148.224"><vh>class cScanner</vh>
<v t="ekr.20071105090148.225"><vh>__init__</vh></v>
</v>
<v t="ekr.20071105090148.226"><vh>scanElispText</vh></v>
<v t="ekr.20071105090148.227"><vh>class elispScanner</vh>
<v t="ekr.20071105090148.228"><vh>__init__</vh></v>
<v t="ekr.20071105090148.229"><vh>startsClass</vh></v>
<v t="ekr.20071105090148.230"><vh>startsFunction</vh></v>
<v t="ekr.20071105090148.231"><vh>startsString</vh></v>
</v>
<v t="ekr.20071105090148.232"><vh>scanJavaText</vh></v>
<v t="ekr.20071105090148.233"><vh>class javaScanner</vh>
<v t="ekr.20071105090148.234"><vh>__init__</vh></v>
</v>
<v t="ekr.20071105090148.235"><vh>scanPascalText</vh></v>
<v t="ekr.20071105090148.236"><vh>class pascalScanner</vh>
<v t="ekr.20071105090148.237"><vh>__init__</vh></v>
</v>
<v t="ekr.20071105090148.238"><vh>scanPHPText</vh></v>
<v t="ekr.20071105090148.239"><vh>class phpScanner</vh>
<v t="ekr.20071105090148.240"><vh>__init__</vh></v>
<v t="ekr.20071105090148.241"><vh>isPurePHP</vh></v>
<v t="ekr.20071105090148.242"><vh>startsString</vh></v>
<v t="ekr.20071105090148.243"><vh>skipString</vh></v>
</v>
<v t="ekr.20071105090148.244"><vh>scanPythonText</vh></v>
<v t="ekr.20071105090148.245"><vh>class pythonScanner</vh>
<v t="ekr.20071105090148.246"><vh>__init__</vh></v>
<v t="ekr.20071105090148.247"><vh>extendSignature</vh></v>
<v t="ekr.20071105090148.248"><vh>skipString</vh></v>
<v t="ekr.20071105090148.249"><vh>skipCodeBlock</vh></v>
<v t="ekr.20071105090148.250"><vh>pythonNewlineHelper</vh></v>
<v t="ekr.20071105090148.251"><vh>skipSigTail</vh></v>
</v>
<v t="ekr.20071105090148.252"><vh>scanUnknownFileType</vh></v>
<v t="ekr.20071105090148.253"><vh>cUnitTest</vh></v>
<v t="ekr.20071105090148.254"><vh>elispUnitTest</vh></v>
<v t="ekr.20071105090148.255"><vh>htmlUnitTest</vh></v>
<v t="ekr.20071105090148.256"><vh>javaUnitTest</vh></v>
<v t="ekr.20071105090148.257"><vh>pascalUnitTest</vh></v>
<v t="ekr.20071105090148.258"><vh>phpUnitTest</vh></v>
<v t="ekr.20071105090148.259"><vh>pythonUnitTest</vh></v>
<v t="ekr.20071105090148.260"><vh>textUnitTest</vh></v>
<v t="ekr.20071105090148.261"><vh>defaultImporterUnitTest</vh></v>
<v t="ekr.20071105090148.262"><vh>scannerUnitTest</vh></v>
</v>
<v t="ekr.20071105090148.263"><vh>class leoImportCommands</vh></v>
</v>
<v t="ekr.20071105090148.264"><vh>@@auto tclDate.c</vh>
<v t="ekr.20071105090148.265"><vh>tclDate declarations</vh></v>
<v t="ekr.20071105090148.266"><vh>TclDatelex</vh></v>
<v t="ekr.20071105090148.267"><vh>TclDateparse</vh></v>
</v>
<v t="ekr.20071105090148.268"><vh>@@auto addWhitelist.py</vh>
<v t="ekr.20071105090148.269"><vh>addWhitelist declarations</vh></v>
<v t="ekr.20071105090148.270"><vh>parseBox</vh></v>
</v>
<v t="ekr.20071105090148.271"><vh>path C:\prog\test</vh>
<v t="ekr.20071105090148.272"><vh>@@auto xyzzy</vh></v>
</v>
<v t="ekr.20071105090148.273"><vh>path c:\prog\test</vh>
<v t="ekr.20071105090148.274"><vh>@@auto atAutoTest.xxx</vh></v>
</v>
<v t="ekr.20071105090148.275"><vh>@@auto tclScan3.c</vh>
<v t="ekr.20071105090148.276"><vh>tclScan3 declarations</vh></v>
<v t="ekr.20071105090148.277"><vh>BuildCharSet</vh></v>
<v t="ekr.20071105090148.278"><vh>CharInSet</vh></v>
<v t="ekr.20071105090148.279"><vh>ReleaseCharSet</vh></v>
<v t="ekr.20071105090148.280"><vh>ValidateFormat</vh></v>
<v t="ekr.20071105090148.281"><vh>Tcl_ScanObjCmd</vh></v>
</v>
<v t="ekr.20071105090148.282"><vh>@@auto tclObj.c</vh>
<v t="ekr.20071105090148.283"><vh>tclObj declarations</vh></v>
<v t="ekr.20071105090148.284"><vh>TclInitObjSubsystem</vh></v>
<v t="ekr.20071105090148.285"><vh>TclFinalizeObjects</vh></v>
<v t="ekr.20071105090148.286"><vh>Tcl_RegisterObjType</vh></v>
<v t="ekr.20071105090148.287"><vh>Tcl_AppendAllObjTypes</vh></v>
<v t="ekr.20071105090148.288"><vh>Tcl_GetObjType</vh></v>
<v t="ekr.20071105090148.289"><vh>Tcl_ConvertToType</vh></v>
<v t="ekr.20071105090148.290"><vh>Tcl_NewObj</vh></v>
<v t="ekr.20071105090148.291"><vh>Tcl_NewObj</vh></v>
<v t="ekr.20071105090148.292"><vh>Tcl_DbNewObj</vh></v>
<v t="ekr.20071105090148.293"><vh>Tcl_DbNewObj</vh></v>
<v t="ekr.20071105090148.294"><vh>TclAllocateFreeObjects</vh></v>
<v t="ekr.20071105090148.295"><vh>TclFreeObj</vh></v>
<v t="ekr.20071105090148.296"><vh>Tcl_DuplicateObj</vh></v>
<v t="ekr.20071105090148.297"><vh>Tcl_GetString</vh></v>
<v t="ekr.20071105090148.298"><vh>Tcl_GetStringFromObj</vh></v>
<v t="ekr.20071105090148.299"><vh>Tcl_InvalidateStringRep</vh></v>
<v t="ekr.20071105090148.300"><vh>Tcl_NewBooleanObj</vh></v>
<v t="ekr.20071105090148.301"><vh>Tcl_NewBooleanObj</vh></v>
<v t="ekr.20071105090148.302"><vh>Tcl_DbNewBooleanObj</vh></v>
<v t="ekr.20071105090148.303"><vh>Tcl_DbNewBooleanObj</vh></v>
<v t="ekr.20071105090148.304"><vh>Tcl_SetBooleanObj</vh></v>
<v t="ekr.20071105090148.305"><vh>Tcl_GetBooleanFromObj</vh></v>
<v t="ekr.20071105090148.306"><vh>SetBooleanFromAny</vh></v>
<v t="ekr.20071105090148.307"><vh>UpdateStringOfBoolean</vh></v>
<v t="ekr.20071105090148.308"><vh>Tcl_NewDoubleObj</vh></v>
<v t="ekr.20071105090148.309"><vh>Tcl_NewDoubleObj</vh></v>
<v t="ekr.20071105090148.310"><vh>Tcl_DbNewDoubleObj</vh></v>
<v t="ekr.20071105090148.311"><vh>Tcl_DbNewDoubleObj</vh></v>
<v t="ekr.20071105090148.312"><vh>Tcl_SetDoubleObj</vh></v>
<v t="ekr.20071105090148.313"><vh>Tcl_GetDoubleFromObj</vh></v>
<v t="ekr.20071105090148.314"><vh>SetDoubleFromAny</vh></v>
<v t="ekr.20071105090148.315"><vh>UpdateStringOfDouble</vh></v>
<v t="ekr.20071105090148.316"><vh>Tcl_NewIntObj</vh></v>
<v t="ekr.20071105090148.317"><vh>Tcl_NewIntObj</vh></v>
<v t="ekr.20071105090148.318"><vh>Tcl_SetIntObj</vh></v>
<v t="ekr.20071105090148.319"><vh>Tcl_GetIntFromObj</vh></v>
<v t="ekr.20071105090148.320"><vh>SetIntFromAny</vh></v>
<v t="ekr.20071105090148.321"><vh>SetIntOrWideFromAny</vh></v>
<v t="ekr.20071105090148.322"><vh>UpdateStringOfInt</vh></v>
<v t="ekr.20071105090148.323"><vh>Tcl_NewLongObj</vh></v>
<v t="ekr.20071105090148.324"><vh>Tcl_NewLongObj</vh></v>
<v t="ekr.20071105090148.325"><vh>Tcl_DbNewLongObj</vh></v>
<v t="ekr.20071105090148.326"><vh>Tcl_DbNewLongObj</vh></v>
<v t="ekr.20071105090148.327"><vh>Tcl_SetLongObj</vh></v>
<v t="ekr.20071105090148.328"><vh>Tcl_GetLongFromObj</vh></v>
<v t="ekr.20071105090148.329"><vh>SetWideIntFromAny</vh></v>
<v t="ekr.20071105090148.330"><vh>UpdateStringOfWideInt</vh></v>
<v t="ekr.20071105090148.331"><vh>Tcl_NewWideIntObj</vh></v>
<v t="ekr.20071105090148.332"><vh>Tcl_NewWideIntObj</vh></v>
<v t="ekr.20071105090148.333"><vh>Tcl_DbNewWideIntObj</vh></v>
<v t="ekr.20071105090148.334"><vh>Tcl_DbNewWideIntObj</vh></v>
<v t="ekr.20071105090148.335"><vh>Tcl_SetWideIntObj</vh></v>
<v t="ekr.20071105090148.336"><vh>Tcl_GetWideIntFromObj</vh></v>
<v t="ekr.20071105090148.337"><vh>Tcl_DbIncrRefCount</vh></v>
<v t="ekr.20071105090148.338"><vh>Tcl_DbDecrRefCount</vh></v>
<v t="ekr.20071105090148.339"><vh>Tcl_DbIsShared</vh></v>
<v t="ekr.20071105090148.340"><vh>Tcl_InitObjHashTable</vh></v>
<v t="ekr.20071105090148.341"><vh>AllocObjEntry</vh></v>
<v t="ekr.20071105090148.342"><vh>CompareObjKeys</vh></v>
<v t="ekr.20071105090148.343"><vh>FreeObjEntry</vh></v>
<v t="ekr.20071105090148.344"><vh>HashObjKey</vh></v>
<v t="ekr.20071105090148.345"><vh>Tcl_GetCommandFromObj</vh></v>
<v t="ekr.20071105090148.346"><vh>TclSetCmdNameObj</vh></v>
<v t="ekr.20071105090148.347"><vh>FreeCmdNameInternalRep</vh></v>
<v t="ekr.20071105090148.348"><vh>DupCmdNameInternalRep</vh></v>
<v t="ekr.20071105090148.349"><vh>SetCmdNameFromAny</vh></v>
</v>
<v t="ekr.20071105090148.350"><vh>@@read-file-into-node C:/prog/tigris-cvs/leo/src/leoApp.py</vh></v>
<v t="ekr.20071105090148.351"><vh>@@read-file-into-node C:/prog/tigris-cvs/leo/test/ut.leo</vh></v>
<v t="ekr.20071105090148.352"><vh>Test of @auto with unicode characters (@encoding)</vh>
<v t="ekr.20071105090148.353"><vh>@@auto encoding-test.py</vh>
<v t="ekr.20071105090148.354"><vh>encoding-test declarations</vh></v>
</v>
<v t="ekr.20071105090148.355"><vh>Multi-editor test</vh></v>
</v>
</v>
</v>
<v t="ekr.20071028032929"><vh>From LeoDiary.leo</vh>
<v t="ekr.20071028032929.1"><vh>Early Milestones</vh>
<v t="ekr.20071028032929.2"><vh>02/03/02 Leo 0.08 released</vh></v>
<v t="ekr.20071028032929.3"><vh>12/17/01 ** Leo 0.05 released</vh></v>
<v t="ekr.20071028032929.4"><vh>12/16/01 Leo becomes functional</vh></v>
<v t="ekr.20071028032929.5"><vh>12/13/01 Syntax coloring works</vh></v>
<v t="ekr.20071028032929.6"><vh>12/09/01 Tree now drawn properly</vh></v>
<v t="ekr.20071028032929.7"><vh>12/05/01 Tree works with Tkinter</vh></v>
<v t="ekr.20071028032929.8"><vh>11/10/01 ** began conversion to tk</vh></v>
<v t="ekr.20071028032929.9"><vh>10/26/01 First successful read of .leo file w/ @file nodes</vh></v>
<v t="ekr.20071028032929.10"><vh>9/29/01 c2py: Totally in love with Python</vh></v>
<v t="ekr.20071028032929.11"><vh>ca. 9/1/01 began work on wxPython version of Leo</vh></v>
</v>
<v t="ekr.20071028032929.12"><vh>Diary</vh>
<v t="ekr.20071028032929.13"><vh>2004</vh>
<v t="ekr.20071028032929.14" a="E"><vh>June 2004</vh>
<v t="ekr.20071028032929.15" a="E"><vh>6/3</vh>
<v t="ekr.20071028032929.16"><vh>Dimmed selection-only radio button in Find Panel</vh></v>
</v>
</v>
<v t="ekr.20071028032929.17"><vh>May 2004</vh>
<v t="ekr.20071028032929.18"><vh>5/19</vh>
<v t="ekr.20071028032929.19"><vh>Fixed @file read bug</vh></v>
<v t="ekr.20071028032929.20"><vh>Removed leoPluginsRef.leo from manifest.in</vh></v>
</v>
<v t="ekr.20071028032929.21"><vh>5/18 Released 4.2 a2</vh></v>
<v t="ekr.20071028032929.22"><vh>5/3 Made sure file indices are always assigned when writing files.</vh></v>
</v>
<v t="ekr.20071028032929.23"><vh>March 2004</vh>
<v t="ekr.20071028032929.24"><vh>4/30</vh>
<v t="ekr.20071028032929.25"><vh>Convert all plugins to g. style</vh></v>
<v t="ekr.20071028032929.26"><vh>Modified g. conversion script so it can be run anywhere</vh></v>
</v>
<v t="ekr.20071028032929.27"><vh>4/27</vh>
<v t="ekr.20071028032929.28"><vh>Added unit tests for batch mode</vh></v>
<v t="ekr.20071028032929.29"><vh>Added useNullUndoer option to nullFrame class</vh></v>
</v>
<v t="ekr.20071028032929.30"><vh>4/26</vh>
<v t="ekr.20071028032929.31"><vh>Removed v.iterators</vh></v>
<v t="ekr.20071028032929.32"><vh>Disambiguted clones while selecting</vh></v>
<v t="ekr.20071028032929.33"><vh>Added code to restore top and current positions</vh></v>
<v t="ekr.20071028032929.34"><vh>Fixed bug in find.changeSelection</vh></v>
<v t="ekr.20071028032929.35"><vh>Converted vnodes, tnodes and positions to new-style classes</vh></v>
<v t="ekr.20071028032929.36"><vh>Removed verbose option from setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20071028032929.37"><vh>Eliminated calls to p.__cmp__(None)</vh></v>
<v t="ekr.20071028032929.38"><vh>Converted vnode,tnode,position classes to new-style classes</vh></v>
<v t="ekr.20071028032929.39"><vh>Improved the speed of isAnyAtFileNode</vh></v>
</v>
<v t="ekr.20071028032929.40"><vh>4/25 Released 4.2 a1</vh>
<v t="ekr.20071028032929.41"><vh>Fix three major performance bugs</vh></v>
<v t="ekr.20071028032929.42"><vh>Removed all  back quotes</vh></v>
</v>
<v t="ekr.20071028032929.43"><vh>3/22</vh>
<v t="ekr.20071028032929.44"><vh>Replaced joinList by vnodeList</vh></v>
</v>
<v t="ekr.20071028032929.45"><vh>3/14</vh>
<v t="ekr.20071028032929.46"><vh>Added asserts when g.app.debug is true</vh></v>
<v t="ekr.20071028032929.47"><vh>HUGE AHA: greatly simplified p.nodeAfter and p.threadNext</vh></v>
</v>
<v t="ekr.20071028032929.48"><vh>3/12</vh>
<v t="ekr.20071028032929.49"><vh>Fixed nasty bug in p.linkAsRoot</vh></v>
<v t="ekr.20071028032929.50"><vh>Fixed and tested the script to replace x by g.x</vh></v>
<v t="ekr.20071028032929.51"><vh>Added c.allNodes_iter</vh></v>
<v t="ekr.20071028032929.52"><vh>Replaced porv by p</vh></v>
<v t="ekr.20071028032929.53"><vh>Removed g.sharedNodes ivar and related code</vh></v>
</v>
<v t="ekr.20071028032929.54"><vh>3/11</vh>
<v t="ekr.20071028032929.55"><vh>Got Save To command working</vh></v>
<v t="ekr.20071028032929.56"><vh>Added new iters</vh></v>
<v t="ekr.20071028032929.57"><vh>Added copy param to all position iterators</vh></v>
</v>
<v t="ekr.20071028032929.58"><vh>3/9 All calls to tag_bind must use a copy of position</vh></v>
<v t="ekr.20071028032929.59"><vh>3/6 Realized that position proxies are now efficient</vh></v>
<v t="ekr.20071028032929.60"><vh>3/4 Realized that iterators make the position class safe</vh></v>
<v t="ekr.20071028032929.61"><vh>3/5</vh>
<v t="ekr.20071028032929.62"><vh>Replaced x by g.x for all x in leoGlobals</vh></v>
<v t="ekr.20071028032929.63"><vh>Replaced app proxy class from leoGlobals by app global var</vh></v>
<v t="ekr.20071028032929.64"><vh>Replaced true,false by True,False</vh></v>
</v>
</v>
<v t="ekr.20071028032929.65"><vh>February 2004</vh>
<v t="ekr.20071028032929.66"><vh>2/16</vh>
<v t="ekr.20071028032929.67"><vh>Restored Toggle Angle Bracket command (without shortcut)</vh></v>
<v t="ekr.20071028032929.68"><vh>Changed Undo/Redo messages</vh></v>
</v>
<v t="ekr.20071028032929.69"><vh>2/1</vh>
<v t="ekr.20071028032929.70"><vh>Fixed bugs in Script-Find/change and improved documentation</vh></v>
</v>
</v>
<v t="ekr.20071028032929.71"><vh>January 2004</vh>
<v t="ekr.20071028032929.72"><vh>1/30</vh>
<v t="ekr.20071028032929.73"><vh>Added script to look for blanks preceding tabs in leading whitespace</vh></v>
<v t="ekr.20071028032929.74"><vh>Fixed several bugs</vh></v>
</v>
<v t="ekr.20071028032929.75"><vh>1/29</vh>
<v t="ekr.20071028032929.76"><vh>Only mark ancestor @file nodes dirty when creating,moving,changing nodes</vh></v>
<v t="ekr.20071028032929.77"><vh>fixed bugs: see 4.1 rc4 projects for details</vh></v>
</v>
<v t="ekr.20071028032929.78"><vh>1/26</vh>
<v t="ekr.20071028032929.79"><vh>Properly handle exceptions in commands</vh></v>
<v t="ekr.20071028032929.80"><vh>Eliminated control-v bug on various platforms</vh></v>
<v t="ekr.20071028032929.81"><vh>Added Dave Hein's Reformat Paragraph code.</vh></v>
<v t="ekr.20071028032929.82"><vh>Fixed Move Up bug involving clones</vh></v>
</v>
<v t="ekr.20071028032929.83"><vh>1/8</vh>
<v t="ekr.20071028032929.84"><vh>Esc hides the Find panel</vh></v>
<v t="ekr.20071028032929.85"><vh>Return in Find panel simuatest the Find button</vh></v>
<v t="ekr.20071028032929.86"><vh>Fixed huge performance bug in cut/copy nodes.</vh></v>
<v t="ekr.20071028032929.87"><vh>Improved sample code for batch mode in LeoDocs.leo</vh></v>
<v t="ekr.20071028032929.88"><vh>Removed a complex assert in colorizer</vh></v>
<v t="ekr.20071028032929.89"><vh>Change file extenstion for LaTeX files from .latext to .tex</vh></v>
</v>
<v t="ekr.20071028032929.90"><vh>1/6 Enable drawing after exceptions</vh></v>
<v t="ekr.20071028032929.91"><vh>1/5</vh>
<v t="ekr.20071028032929.92"><vh>Import now creates @root-code</vh></v>
<v t="ekr.20071028032929.93"><vh>Added sys.platform to signon message in log pane</vh></v>
<v t="ekr.20071028032929.94"><vh>Added test/test.leo to all distributions</vh></v>
<v t="ekr.20071028032929.95"><vh>Added LP link to Leo's site</vh></v>
</v>
</v>
</v>
<v t="ekr.20071028032929.96"><vh>2003</vh>
<v t="ekr.20071028032929.97"><vh>December 2003</vh>
<v t="ekr.20071028032929.98"><vh>12/19</vh>
<v t="ekr.20071028032929.99"><vh>Released 4.1 rc3</vh></v>
<v t="ekr.20071028032929.100"><vh>All unittests pass (but only with tkinterGui)</vh></v>
<v t="ekr.20071028032929.101"><vh>Added nullObject class to leoGlobals.py</vh></v>
<v t="ekr.20071028032929.102"><vh>Fixed serious problem reading 3.x files</vh></v>
</v>
<v t="ekr.20071028032929.103"><vh>12/18</vh>
<v t="ekr.20071028032929.104"><vh>Fixed crasher in 3.x version of scanText</vh></v>
<v t="ekr.20071028032929.105"><vh>Released 4.1 rc2</vh></v>
<v t="ekr.20071028032929.106"><vh>Added year to timestamp</vh></v>
<v t="ekr.20071028032929.107"><vh>Fixed bug in getInsertLines</vh></v>
</v>
<v t="ekr.20071028032929.108"><vh>12/17</vh>
<v t="ekr.20071028032929.109"><vh>Unittests for import don't alter test.leo</vh></v>
</v>
<v t="ekr.20071028032929.110"><vh>12/15</vh>
<v t="ekr.20071028032929.111"><vh>Supported default font sizes for all panes</vh></v>
<v t="ekr.20071028032929.112"><vh>Changed format of timestamps</vh></v>
<v t="ekr.20071028032929.113"><vh>Changed *.* to * in dialogs</vh></v>
<v t="ekr.20071028032929.114"><vh>Released 4.1 rc1</vh></v>
<v t="ekr.20071028032929.115"><vh>All unit tests now pass (import tests leave stuff behind)</vh></v>
<v t="ekr.20071028032929.116"><vh>Don't warn about missing path when writing scripts</vh></v>
<v t="ekr.20071028032929.117"><vh>Set default font size to None in leoConfig.txt.</vh></v>
</v>
<v t="ekr.20071028032929.118"><vh>12/13</vh>
<v t="ekr.20071028032929.119"><vh>Completed move code in leoTest.py</vh></v>
<v t="ekr.20071028032929.120"><vh>Moved encoding messages so they don't appear in batch mode</vh></v>
<v t="ekr.20071028032929.121"><vh>Autoclean outline on save &amp; executeScript does not set tnodeList</vh></v>
<v t="ekr.20071028032929.122"><vh>Patched scanPythonClass to put class docstrings in class nodes</vh></v>
</v>
<v t="ekr.20071028032929.123"><vh>12/11</vh>
<v t="ekr.20071028032929.124"><vh>Fixed big performance bug in removeSentinelLines</vh></v>
<v t="ekr.20071028032929.125"><vh>Call leoTest.fail in when import/export routines can't open a file</vh></v>
<v t="ekr.20071028032929.126"><vh>created unitTestGui class</vh></v>
</v>
<v t="ekr.20071028032929.127"><vh>12/09</vh>
<v t="ekr.20071028032929.128"><vh>Leo now allows @ignore nodes and orphan nodes in @file-nosent trees</vh></v>
<v t="ekr.20071028032929.129"><vh>Looked at report of import bug</vh></v>
</v>
<v t="ekr.20071028032929.130"><vh>12/08</vh>
<v t="ekr.20071028032929.131"><vh>Investigated &amp; fixed copy/paste bugs</vh></v>
</v>
<v t="ekr.20071028032929.132"><vh>12/07</vh>
<v t="ekr.20071028032929.133"><vh>Corrected counts when replacing tabs/blanks</vh></v>
<v t="ekr.20071028032929.134"><vh>Added file open dialog to Import Derived Files command</vh></v>
<v t="ekr.20071028032929.135"><vh>Made sure that Reformat Paragraph makes the new insertion point visible</vh></v>
<v t="ekr.20071028032929.136"><vh>Changed logControl to logCtrl</vh></v>
</v>
<v t="ekr.20071028032929.137"><vh>12/06</vh>
<v t="ekr.20071028032929.138"><vh>Fixed bug when untangling html</vh></v>
<v t="ekr.20071028032929.139"><vh>Fixed clone-dragging bug</vh></v>
<v t="ekr.20071028032929.140"><vh>Load plugins dynamically using pluginsManager.txt</vh></v>
</v>
<v t="ekr.20071028032929.141"><vh>12/05</vh>
<v t="ekr.20071028032929.142"><vh>Ran pychecker</vh></v>
</v>
<v t="ekr.20071028032929.143"><vh>12/04</vh>
<v t="ekr.20071028032929.144"><vh>Created and read paths with chinese characters in folder and file names</vh></v>
<v t="ekr.20071028032929.145"><vh>Fixed all remaining bugs (except duplicate tnode index)</vh></v>
</v>
<v t="ekr.20071028032929.146"><vh>12/03</vh>
<v t="ekr.20071028032929.147"><vh>Replaced c.OpenWithFileName by global openWithFileName</vh></v>
<v t="ekr.20071028032929.148"><vh>Fixed dangerous bug in Convert Blanks command</vh></v>
<v t="ekr.20071028032929.149"><vh>Added the mod_tempfname plugin</vh></v>
</v>
<v t="ekr.20071028032929.150"><vh>12/01</vh>
<v t="ekr.20071028032929.151"><vh>Update recent files in newLeoCommanderAndFrame</vh></v>
</v>
</v>
<v t="ekr.20071028032929.152"><vh>November 2003</vh>
<v t="ekr.20071028032929.153"><vh>11/23 Released 4.1 beta 5 to cvs only</vh>
<v t="ekr.20071028032929.154"><vh>Replaced app.batchLog with app.log</vh></v>
<v t="ekr.20071028032929.155"><vh>Fixed Undo Change All (in headlines) problem</vh></v>
<v t="ekr.20071028032929.156"><vh>Added defensive code to prevent crash in colorizer</vh></v>
<v t="ekr.20071028032929.157"><vh>Removed annoying Go To Line Number "error" message.</vh></v>
<v t="ekr.20071028032929.158"><vh>Fixed duplicate shortcut message when creating a popup menu</vh></v>
<v t="ekr.20071028032929.159"><vh>Made newTnode more robust</vh></v>
<v t="ekr.20071028032929.160"><vh>Fixed crashers in extract and extract section</vh></v>
<v t="ekr.20071028032929.161"><vh>Fixed bug in putRefLine</vh></v>
<v t="ekr.20071028032929.162"><vh>Tested --script from command line</vh></v>
</v>
<v t="ekr.20071028032929.163"><vh>11/22</vh>
<v t="ekr.20071028032929.164"><vh>Moved batch plugin into Leo's core.</vh></v>
<v t="ekr.20071028032929.165"><vh>Added nullUndoer class</vh></v>
<v t="ekr.20071028032929.166"><vh>Disabled Edit Body/Headline commands in batch mode</vh></v>
<v t="ekr.20071028032929.167"><vh>Added app.batchMode ivar</vh></v>
<v t="ekr.20071028032929.168"><vh>Added enable/disable methods to nullLog</vh></v>
<v t="ekr.20071028032929.169"><vh>Created  v.scriptSetBodyString</vh></v>
</v>
<v t="ekr.20071028032929.170"><vh>11/20 released 4.1 beta 4</vh>
<v t="ekr.20071028032929.171"><vh>created null frame,log,body,tree,menu,gui classes</vh></v>
</v>
<v t="ekr.20071028032929.172"><vh>11/19</vh>
<v t="ekr.20071028032929.173"><vh>Initialize write routines properly in Execute Script command</vh></v>
<v t="ekr.20071028032929.174"><vh>Leo now generates reference properly when more than one on the same line</vh></v>
<v t="ekr.20071028032929.175"><vh>Fixed several reorg bugs in leoPlugins.leo</vh></v>
<v t="ekr.20071028032929.176"><vh>Allow all Leo constructs in Execute Script command</vh></v>
<v t="ekr.20071028032929.177"><vh>Protected all tk code in leoPlugins.leo</vh></v>
<v t="ekr.20071028032929.178"><vh>Fixed reorg problem in the nav bar</vh></v>
<v t="ekr.20071028032929.179"><vh>Wrapped all calls to os.path</vh></v>
<v t="ekr.20071028032929.180"><vh>Convert doc sections to doc strings</vh></v>
</v>
<v t="ekr.20071028032929.181"><vh>11/18 released 4.1 beta 3</vh>
<v t="ekr.20071028032929.182"><vh>Fixed bug in initScriptFind</vh></v>
<v t="ekr.20071028032929.183"><vh>released 4.1b3</vh></v>
</v>
<v t="ekr.20071028032929.184"><vh>11/17</vh>
<v t="ekr.20071028032929.185"><vh>Fixed all problems reported by Pychecker</vh></v>
<v t="ekr.20071028032929.186"><vh>Fixed new crasher in batch change commands</vh></v>
<v t="ekr.20071028032929.187"><vh>Fixed new crasher in Show Invisibles command</vh></v>
<v t="ekr.20071028032929.188"><vh>Fixed (new?) unbounded recursion in Go To Next Clone command</vh></v>
<v t="ekr.20071028032929.189"><vh>Fixed (new?) crasher in Abort Edit Headline command</vh></v>
<v t="ekr.20071028032929.190"><vh>Fixed new crashers when opening popup menu</vh></v>
<v t="ekr.20071028032929.191"><vh>Fixed new crasher in Font panel</vh></v>
<v t="ekr.20071028032929.192"><vh>Import traceback only as needed</vh></v>
<v t="ekr.20071028032929.193"><vh>Fixed bug that caused new headlines not to be selected</vh></v>
<v t="ekr.20071028032929.194"><vh>getSelectionLines now returns the insertion line if no selection</vh></v>
<v t="ekr.20071028032929.195"><vh>Replaced c.body and c.log by c.frame.body &amp; c.frame.log</vh></v>
</v>
<v t="ekr.20071028032929.196"><vh>11/16</vh>
<v t="ekr.20071028032929.197"><vh>Reorg is now complete!</vh></v>
<v t="ekr.20071028032929.198"><vh>Moved menu utilities to leoMenu class</vh></v>
<v t="ekr.20071028032929.199"><vh>Removed all redirectors from frame to body</vh></v>
<v t="ekr.20071028032929.200"><vh>Simplified menu bindings</vh></v>
<v t="ekr.20071028032929.201"><vh>Fixed Find Matching Brackets command</vh></v>
</v>
<v t="ekr.20071028032929.202"><vh>11/15</vh>
<v t="ekr.20071028032929.203"><vh>Fixed problem with whole-word searches</vh></v>
<v t="ekr.20071028032929.204"><vh>Fixed problem with attaching icons to dialogs</vh></v>
<v t="ekr.20071028032929.205"><vh>Fixed crasher in Toggle Active Pane command</vh></v>
</v>
<v t="ekr.20071028032929.206"><vh>11/13</vh>
<v t="ekr.20071028032929.207"><vh>wx gui plugin now works again</vh></v>
<v t="ekr.20071028032929.208"><vh>Finished reorg</vh></v>
</v>
<v t="ekr.20071028032929.209"><vh>11/12</vh>
<v t="ekr.20071028032929.210"><vh>Created app.gui.utils class</vh></v>
<v t="ekr.20071028032929.211"><vh>Created base classes for color, compare, find, font &amp; prefs panels</vh></v>
<v t="ekr.20071028032929.212"><vh>Fixed Recent Files regression</vh></v>
</v>
<v t="ekr.20071028032929.213"><vh>11/10</vh>
<v t="ekr.20071028032929.214"><vh>Continued major reorg</vh></v>
<v t="ekr.20071028032929.215"><vh>Added redirection routines to leoFrame class</vh></v>
</v>
<v t="ekr.20071028032929.216"><vh>11/9</vh>
<v t="ekr.20071028032929.217"><vh>Reorganized the code to use leoMenu and leoTkinterMenu classes</vh></v>
<v t="ekr.20071028032929.218"><vh>Fixed LaTeX syntax coloring bug</vh></v>
<v t="ekr.20071028032929.219"><vh>Implemented a limited form of the Selection Only find/change commands</vh></v>
<v t="ekr.20071028032929.220"><vh>Created unit tests to run Check Outline command</vh></v>
</v>
<v t="ekr.20071028032929.221"><vh>11/8</vh>
<v t="ekr.20071028032929.222"><vh>Created Page Count script</vh></v>
</v>
<v t="ekr.20071028032929.223"><vh>11/7 4.1 beta 1 released</vh>
<v t="ekr.20071028032929.224"><vh>Fixed crasher in computeLoadDir</vh></v>
<v t="ekr.20071028032929.225"><vh>Fixed a real bug in the Change, Then Find command</vh></v>
<v t="ekr.20071028032929.226"><vh>Cleaned up Pychecker complaints</vh></v>
<v t="ekr.20071028032929.227"><vh>Released 4.1 beta 1</vh></v>
</v>
<v t="ekr.20071028032929.228"><vh>11/6</vh>
<v t="ekr.20071028032929.229"><vh>Create initScriptFind</vh></v>
<v t="ekr.20071028032929.230"><vh>Added support for undo</vh></v>
<v t="ekr.20071028032929.231"><vh>Yes, a script change checkbox IS a good idea</vh></v>
</v>
<v t="ekr.20071028032929.232"><vh>11/5</vh>
<v t="ekr.20071028032929.233"><vh>Got script search/change working (!!)</vh>
<v t="ekr.20071028032929.234"><vh>find script</vh></v>
</v>
<v t="ekr.20071028032929.235"><vh>Fixed Serious Undo Change All bug</vh></v>
<v t="ekr.20071028032929.236"><vh>Leo now ignores unknown prefs and find prefs</vh></v>
<v t="ekr.20071028032929.237"><vh>Leo now writes node_only find prefs</vh></v>
<v t="ekr.20071028032929.238"><vh>Fixed first node-only find bug</vh></v>
</v>
<v t="ekr.20071028032929.239"><vh>11/4</vh>
<v t="ekr.20071028032929.240"><vh>Fixed bug involving 0x1a characters in body text.</vh></v>
<v t="ekr.20071028032929.241"><vh>Added Check Outline command</vh></v>
<v t="ekr.20071028032929.242"><vh>Added Hoist/De-Hoist commands</vh></v>
</v>
<v t="ekr.20071028032929.243"><vh>11/3</vh>
<v t="ekr.20071028032929.244"><vh>Leo now does an auto-save only if files have actually been changed.</vh></v>
<v t="ekr.20071028032929.245"><vh>Changed all .leo files to use the -ko cvs option</vh></v>
</v>
<v t="ekr.20071028032929.246"><vh>11/2</vh>
<v t="ekr.20071028032929.247"><vh>Added use_gnx config setting</vh></v>
<v t="ekr.20071028032929.248"><vh>Converted to using gnx</vh></v>
</v>
</v>
<v t="ekr.20071028032929.249"><vh>October 2003</vh>
<v t="ekr.20071028032929.250"><vh>10/31</vh>
<v t="ekr.20071028032929.251"><vh>Added bindings to app.gui.root to catch all control keys</vh></v>
<v t="ekr.20071028032929.252"><vh>Added config_encoding setting</vh></v>
</v>
<v t="ekr.20071028032929.253"><vh>10/27</vh>
<v t="ekr.20071028032929.254"><vh>Colorizer now uses c.body routines</vh></v>
<v t="ekr.20071028032929.255"><vh>Replaced frame.top by frame in call to set_focus</vh></v>
<v t="ekr.20071028032929.256"><vh>Replace calls to after and after_idle by app.gui calls.</vh></v>
<v t="ekr.20071028032929.257"><vh>Removed app.root from all non-gui code</vh></v>
</v>
<v t="ekr.20071028032929.258"><vh>10/26 code reorg</vh>
<v t="ekr.20071028032929.259"><vh>Replaced all references to leoDialog by corresponding app.gui calls</vh></v>
<v t="ekr.20071028032929.260"><vh>Moved color panels into leoTkinterColorPanels.py</vh></v>
<v t="ekr.20071028032929.261"><vh>Replaced all direct references to color panels by corresponding appl.gui calls</vh></v>
<v t="ekr.20071028032929.262"><vh>Replaced all direct references to find panel by corresponding appl.gui calls</vh></v>
</v>
<v t="ekr.20071028032929.263"><vh>10/25</vh>
<v t="ekr.20071028032929.264"><vh>Made tnode indices immutable: fixed bad copy/paste bug</vh></v>
<v t="ekr.20071028032929.265"><vh>Fixed crasher with bad pattern match patterns</vh></v>
<v t="ekr.20071028032929.266"><vh>Fixed bug in Go To Line Number command</vh></v>
<v t="ekr.20071028032929.267"><vh>Disabled startup traces</vh></v>
<v t="ekr.20071028032929.268"><vh>Fixed plugin problems (now fixed in 4.0.2 and 4.1)</vh></v>
<v t="ekr.20071028032929.269"><vh>Cleaned up the reformatParagraph code</vh></v>
<v t="ekr.20071028032929.270"><vh>Removed kludge from setSelectionAreas</vh></v>
</v>
<v t="ekr.20071028032929.271"><vh>10/24</vh>
<v t="ekr.20071028032929.272"><vh>Completed new version of reformatParagraph</vh></v>
<v t="ekr.20071028032929.273"><vh>Rewrote findBoundParagraph using splitLines</vh></v>
<v t="ekr.20071028032929.274"><vh>Rewrote getInsertLines (leoTkinterBody)</vh></v>
<v t="ekr.20071028032929.275"><vh>Wrote splitLines &amp; joinLines utilities</vh></v>
<v t="ekr.20071028032929.276"><vh>Fixed problem with indent/undent</vh></v>
</v>
<v t="ekr.20071028032929.277"><vh>10/22</vh>
<v t="ekr.20071028032929.278"><vh>Fixed crasher in onOpenWithFileName</vh></v>
</v>
<v t="ekr.20071028032929.279"><vh>10/19</vh>
<v t="ekr.20071028032929.280"><vh>Made app.forceShutdown work in "idle" hook</vh></v>
<v t="ekr.20071028032929.281"><vh>Properly enable green back arrow in nav bar</vh></v>
</v>
<v t="ekr.20071028032929.282"><vh>10/17</vh>
<v t="ekr.20071028032929.283"><vh>Renamed .body to .bodyCtrl</vh></v>
<v t="ekr.20071028032929.284"><vh>Create leoTkinterLog  &amp; leoTkinterBody classes</vh></v>
<v t="ekr.20071028032929.285"><vh>Created frame.destroySelf routine</vh></v>
<v t="ekr.20071028032929.286"><vh>Eliminated all references to frame.top outside of LeoTkinterFrame class</vh></v>
<v t="ekr.20071028032929.287"><vh>tree.drawIcon now injects v.iconx and v.iconv ivars</vh></v>
<v t="ekr.20071028032929.288"><vh>Began gui reorg</vh></v>
<v t="ekr.20071028032929.289"><vh>4.0 final released</vh></v>
</v>
<v t="ekr.20071028032929.290"><vh>10/16</vh>
<v t="ekr.20071028032929.291"><vh>Created app.forceShutdown</vh></v>
<v t="ekr.20071028032929.292"><vh>Fixed more bugs in undoReplace: all undo tests now pass</vh></v>
</v>
<v t="ekr.20071028032929.293"><vh>10/15</vh>
<v t="ekr.20071028032929.294"><vh>Added several plugins and scripts to leoPlugins.leo</vh></v>
<v t="ekr.20071028032929.295"><vh>Removed "invalid @lineending directive" warning</vh></v>
<v t="ekr.20071028032929.296"><vh>Added support so plugins can force Leo to quit during startup</vh></v>
<v t="ekr.20071028032929.297"><vh>Fixed bug in removeSentinelsCommand</vh></v>
<v t="ekr.20071028032929.298"><vh>Improved Go To Line Number command</vh></v>
<v t="ekr.20071028032929.299"><vh>Improved confusing error message from Go To Line Number command</vh></v>
</v>
<v t="ekr.20071028032929.300"><vh>10/14</vh>
<v t="ekr.20071028032929.301"><vh>Added redirect_execute_script_output_to_log_pane setting</vh></v>
<v t="ekr.20071028032929.302"><vh>Speed up clone operation by calling initAllCloneBitsInTree</vh></v>
<v t="ekr.20071028032929.303"><vh>Several undo changes &amp; bug fixes</vh></v>
</v>
<v t="ekr.20071028032929.304"><vh>10/13 Released 4.0 beta 4</vh></v>
<v t="ekr.20071028032929.305"><vh>10/10</vh>
<v t="ekr.20071028032929.306"><vh>Added var or const prefixes when importing elisp</vh></v>
<v t="ekr.20071028032929.307"><vh>Added support for elisp colorising</vh></v>
<v t="ekr.20071028032929.308"><vh>Fixed bug in c.clone</vh></v>
<v t="ekr.20071028032929.309"><vh>Created hint messages for Extract Section &amp; Extract Section Names commands</vh></v>
<v t="ekr.20071028032929.310"><vh>changed string.letters to string.ascii_letters throughout</vh></v>
<v t="ekr.20071028032929.311"><vh>Fixed bug in bracket scanner</vh></v>
</v>
<v t="ekr.20071028032929.312"><vh>10/9 Released 4.0 beta 3</vh>
<v t="ekr.20071028032929.313"><vh>Added support for importing elisp (.el) files</vh></v>
<v t="ekr.20071028032929.314"><vh>Force a complete recolor after any cut/paste or corresponding undo/redo</vh></v>
<v t="ekr.20071028032929.315"><vh>Improved 4.0 version of Go To Line Number command</vh></v>
<v t="ekr.20071028032929.316"><vh>Released 4.0 beta 3</vh></v>
</v>
<v t="ekr.20071028032929.317"><vh>10/8</vh>
<v t="ekr.20071028032929.318"><vh>Fixed long-standing clone-mark bug</vh></v>
<v t="ekr.20071028032929.319"><vh>Added support for unknown tnode and vnode attributes</vh></v>
<v t="ekr.20071028032929.320"><vh>Fixed bug in gui destroy logic</vh></v>
<v t="ekr.20071028032929.321"><vh>Changed c.frame.mFileName to c.mFileName in plugins.leo</vh></v>
</v>
<v t="ekr.20071028032929.322"><vh>10/7</vh>
<v t="ekr.20071028032929.323"><vh>Fixed crash in sentinelName</vh></v>
<v t="ekr.20071028032929.324"><vh>Added __setattr__ method to leoProxy class</vh></v>
<v t="ekr.20071028032929.325"><vh>Reenabled orphans &amp; ignored test in new write logic</vh></v>
<v t="ekr.20071028032929.326"><vh>Cleaned up version code and added build number to signon</vh></v>
</v>
<v t="ekr.20071028032929.327"><vh>10/6</vh>
<v t="ekr.20071028032929.328"><vh>Converted the code to use newLeoCommanderAndFrame</vh></v>
<v t="ekr.20071028032929.329"><vh>Added better error message in setDefaultIcon</vh></v>
</v>
<v t="ekr.20071028032929.330"><vh>10/3 Released 4.0 beta 2</vh>
<v t="ekr.20071028032929.331"><vh>Released 4.0 beta 2</vh></v>
<v t="ekr.20071028032929.332"><vh>Fixed problem setting loadDir in startup logic</vh></v>
</v>
<v t="ekr.20071028032929.333"><vh>10/2</vh>
<v t="ekr.20071028032929.334"><vh>Still problems making Read @file Nodes undoable</vh></v>
<v t="ekr.20071028032929.335"><vh>Import Derived File command is now undoable</vh></v>
<v t="ekr.20071028032929.336"><vh>Moved Clear Recent Files menu item into Recent Files menu</vh></v>
<v t="ekr.20071028032929.337"><vh>Fixed bugs involving find params</vh></v>
<v t="ekr.20071028032929.338"><vh>Fixed Python Import bug</vh></v>
</v>
<v t="ekr.20071028032929.339"><vh>10/1</vh>
<v t="ekr.20071028032929.340"><vh>Added support for two new settings affecting drags</vh></v>
<v t="ekr.20071028032929.341"><vh>Marked changed nodes &amp; make the @file node and the outline dirty.</vh></v>
<v t="ekr.20071028032929.342"><vh>Fixed Go To Outline command so it doesn't crash: More work needed.</vh></v>
<v t="ekr.20071028032929.343"><vh>Ensured newlines before all sentinels in @rawfile</vh></v>
<v t="ekr.20071028032929.344"><vh>Fixed @rawfile write problem</vh></v>
</v>
</v>
<v t="ekr.20071028032929.345"><vh>Sept 2003</vh>
<v t="ekr.20071028032929.346"><vh>9/30</vh>
<v t="ekr.20071028032929.347"><vh>Removed unused v arg from writeOld/NewDerivedFiles</vh></v>
<v t="ekr.20071028032929.348"><vh>Removed unused nosentinels arg from writeNewDerivedFiles</vh></v>
<v t="ekr.20071028032929.349"><vh>Removed putLeadingNewlineFlag arg from putSentinel</vh></v>
<v t="ekr.20071028032929.350"><vh>Renamed new scanText to scanText4</vh></v>
<v t="ekr.20071028032929.351"><vh>Removed many Pychecker warnings</vh>
<v t="ekr.20071028032929.352"><vh>Details</vh></v>
</v>
<v t="ekr.20071028032929.353"><vh>Added better log message for Convert All Tabs/Blanks commands</vh></v>
<v t="ekr.20071028032929.354"><vh>Created leoProxy class and simplified the code</vh></v>
</v>
<v t="ekr.20071028032929.355"><vh>9/29</vh>
<v t="ekr.20071028032929.356"><vh>A "gotcha" re using global app var</vh></v>
<v t="ekr.20071028032929.357"><vh>Added crucial defensive checks in v.headString() and v.bodySting()</vh></v>
<v t="ekr.20071028032929.358"><vh>Fixed several more unicode bugs</vh></v>
<v t="ekr.20071028032929.359"><vh>Removed setApp function</vh></v>
</v>
<v t="ekr.20071028032929.360"><vh>9/28</vh>
<v t="ekr.20071028032929.361"><vh>Added many calls to toUnicode.  Marked with 9/28/03</vh></v>
<v t="ekr.20071028032929.362"><vh>trace now always prints arguments.</vh></v>
<v t="ekr.20071028032929.363"><vh>Rewrote icon code so it doesn't use PIL or tkIcon in Python 2.3</vh></v>
</v>
<v t="ekr.20071028032929.364"><vh>9/27 </vh>
<v t="ekr.20071028032929.365"><vh>Defined dialog and icons routines in tkinterGui and leoGui</vh></v>
<v t="ekr.20071028032929.366"><vh>Defined focus routines in tkinterGui and leoGui</vh></v>
<v t="ekr.20071028032929.367"><vh>Replaced app.runMainLoop with app.gui.runMainLoop</vh></v>
<v t="ekr.20071028032929.368"><vh>Created leoGui base class for tkinterGui class</vh></v>
<v t="ekr.20071028032929.369"><vh>Moved all gui startup logic into tkingerGui class</vh></v>
</v>
<v t="ekr.20071028032929.370"><vh>9/26 4.0 beta 1 released</vh>
<v t="ekr.20071028032929.371"><vh>changed default for config.write_old_format_derived_files</vh></v>
</v>
<v t="ekr.20071028032929.372"><vh>9/22</vh>
<v t="ekr.20071028032929.373"><vh>Changed leoConfig.txt so we write 3.x derived files if leoConfig.txt does not exist</vh></v>
<v t="ekr.20071028032929.374"><vh>writeAll and writeMissing now return a count of the written files</vh></v>
<v t="ekr.20071028032929.375"><vh>getLeoFile computes joinLists before reading derived files</vh></v>
<v t="ekr.20071028032929.376"><vh>Fixed putCode so @raw test passes</vh></v>
<v t="ekr.20071028032929.377"><vh>4.x code passes @delims test</vh></v>
</v>
<v t="ekr.20071028032929.378"><vh>9/21</vh>
<v t="ekr.20071028032929.379"><vh>Import derived file command now works for both 3.x and 4.x files</vh></v>
<v t="ekr.20071028032929.380"><vh>Test @file-nosent</vh></v>
<v t="ekr.20071028032929.381"><vh>Enclosed top-level read/write code in try/except</vh></v>
<v t="ekr.20071028032929.382"><vh>findChild now handles bad tnodeList indices without crashing</vh></v>
<v t="ekr.20071028032929.383"><vh>Fixed bugs in @+doc and @+at sentinels.</vh></v>
<v t="ekr.20071028032929.384"><vh>Removed Write 3.x Outline command</vh></v>
<v t="ekr.20071028032929.385"><vh>Auto-save on Write 3.x derived files.</vh></v>
<v t="ekr.20071028032929.386"><vh>Put section references only if not in raw mode</vh></v>
</v>
<v t="ekr.20071028032929.387"><vh>9/20 4.0 code works &amp; integrated with LeoPy.leo !!</vh>
<v t="ekr.20071028032929.388"><vh>Started merging of plugin code with leoAtFile.py</vh></v>
<v t="ekr.20071028032929.389"><vh>Fixed problems with @doc parts</vh></v>
<v t="ekr.20071028032929.390"><vh>Write @file Nodes does auto-save if we are writing new-format files</vh></v>
<v t="ekr.20071028032929.391"><vh>Changed Wirte 3.x/4x Derived File so they write multiple files</vh></v>
<v t="ekr.20071028032929.392"><vh>Fixed @last bug by using same code as in 3.x</vh></v>
<v t="ekr.20071028032929.393"><vh>Write 4.x Derived File command auto-saves outline</vh></v>
<v t="ekr.20071028032929.394"><vh>Fixed (?) @last newline bug</vh></v>
<v t="ekr.20071028032929.395"><vh>Removed all using_gnx ivars</vh></v>
<v t="ekr.20071028032929.396"><vh>Write code now clears tnodeList attribute before writing</vh></v>
<v t="ekr.20071028032929.397"><vh>Removed "not undoable" message from Read @file Nodes command</vh></v>
<v t="ekr.20071028032929.398"><vh>Removed app.use_gnx ivar</vh></v>
<v t="ekr.20071028032929.399"><vh>Set using_gnx in top_df.write_all</vh></v>
<v t="ekr.20071028032929.400"><vh>Created top_df.oldWrite and top_df.newWrite</vh></v>
<v t="ekr.20071028032929.401"><vh>Added test for unvisited nodes in read logic</vh></v>
</v>
<v t="ekr.20071028032929.402"><vh>9/19</vh>
<v t="ekr.20071028032929.403"><vh>Major reorganization of leoAtFile.py</vh></v>
<v t="ekr.20071028032929.404"><vh>Moved code from leoPlugins.leo to LeoPy.leo</vh></v>
<v t="ekr.20071028032929.405"><vh>Tested splitting very long doc words.</vh></v>
<v t="ekr.20071028032929.406"><vh>Removed @ws stuff</vh></v>
<v t="ekr.20071028032929.407"><vh>Fixed bug related to @last</vh></v>
<v t="ekr.20071028032929.408"><vh>Added Write 3.x Format Derived File command.</vh></v>
<v t="ekr.20071028032929.409"><vh>Added Clear Recent Files command</vh></v>
<v t="ekr.20071028032929.410"><vh>Added write_old_format_derived_files option</vh></v>
<v t="ekr.20071028032929.411"><vh>Removed @ws stuff</vh></v>
</v>
<v t="ekr.20071028032929.412"><vh>9/18</vh>
<v t="ekr.20071028032929.413"><vh>Fixed some (all?) problems with tnodeList</vh></v>
<v t="ekr.20071028032929.414"><vh>All files now pass the file-compare (semantic test)</vh></v>
<v t="ekr.20071028032929.415"><vh>Fixed @others bug</vh></v>
</v>
<v t="ekr.20071028032929.416"><vh>9/17</vh>
<v t="ekr.20071028032929.417"><vh>Wrote compare script</vh></v>
<v t="ekr.20071028032929.418"><vh>Wrote Import Derived File command</vh></v>
</v>
<v t="ekr.20071028032929.419"><vh>9/16</vh>
<v t="ekr.20071028032929.420"><vh>Changed how @ws sentinel works</vh></v>
<v t="ekr.20071028032929.421"><vh>Properly indent @nl sentinels</vh></v>
<v t="ekr.20071028032929.422"><vh>Fixed bugs in putting doc parts</vh></v>
<v t="ekr.20071028032929.423"><vh>Fixed bugs in readLastDocLine</vh></v>
</v>
<v t="ekr.20071028032929.424"><vh>9/14</vh>
<v t="ekr.20071028032929.425"><vh>Added ignoreOldSentinel to warn about 3.x sentinels</vh></v>
<v t="ekr.20071028032929.426"><vh>Milestone: first successful use of hidden machinery</vh></v>
<v t="ekr.20071028032929.427"><vh>Added support for tnodeList tag in fileCommands.getVnode</vh></v>
<v t="ekr.20071028032929.428"><vh>Rewrote createChild and renamed it to findChild</vh></v>
<v t="ekr.20071028032929.429"><vh>Added check to see whether read is the same as the write.</vh></v>
<v t="ekr.20071028032929.430"><vh>Added support for tnodeList</vh></v>
</v>
<v t="ekr.20071028032929.431"><vh>9/13 work on 4.0 read code</vh></v>
</v>
<v t="ekr.20071028032929.432"><vh>August 2003</vh>
<v t="ekr.20071028032929.433"><vh>8/30 Added horizontal scrollbar in body pane when @nowrap in effect</vh></v>
<v t="ekr.20071028032929.434"><vh>8/29 Removed Open Python Window command</vh></v>
<v t="ekr.20071028032929.435"><vh>8/28</vh>
<v t="ekr.20071028032929.436"><vh>Added encoding comments to leoGlobals.py and french plugins</vh></v>
<v t="ekr.20071028032929.437"><vh>Tested with Python 2.3</vh></v>
</v>
<v t="ekr.20071028032929.438"><vh>8/27 Recycle window objects only if more than one window open</vh></v>
</v>
<v t="ekr.20071028032929.439"><vh>July 2003</vh>
<v t="ekr.20071028032929.440"><vh>7/25 Improved Leo's FAQ</vh></v>
<v t="ekr.20071028032929.441"><vh>7/24</vh>
<v t="ekr.20071028032929.442"><vh>Fixed Linux install scripts</vh></v>
<v t="ekr.20071028032929.443"><vh>Changed default new window size in leoConfig.py to match leoConfig.txt</vh></v>
<v t="ekr.20071028032929.444"><vh>Added Help Wanted section to the main todo list</vh></v>
</v>
<v t="ekr.20071028032929.445"><vh>7/22</vh>
<v t="ekr.20071028032929.446"><vh>Called setDefaultDirectoryForNewFiles from all variants of the Save command</vh></v>
<v t="ekr.20071028032929.447"><vh>Added new hook for LeoN in the startup code</vh></v>
</v>
<v t="ekr.20071028032929.448"><vh>7/19 Fixed shortcut bug</vh></v>
<v t="ekr.20071028032929.449"><vh>7/18: Released 3.12 final</vh></v>
<v t="ekr.20071028032929.450"><vh>7/18:  Added preliminary wxWindows project</vh></v>
<v t="ekr.20071028032929.451"><vh>7/16</vh>
<v t="ekr.20071028032929.452"><vh>Finished unit testing of colorizer</vh></v>
<v t="ekr.20071028032929.453"><vh>Allow minus signs in rebol keywords</vh></v>
</v>
<v t="ekr.20071028032929.454"><vh>7/13</vh>
<v t="ekr.20071028032929.455"><vh>Fixed double-click bug on startup</vh></v>
<v t="ekr.20071028032929.456"><vh>Simplified startup logic</vh></v>
<v t="ekr.20071028032929.457"><vh>Created new screen shot on Leo's web site</vh></v>
</v>
<v t="ekr.20071028032929.458"><vh>7/11</vh>
<v t="ekr.20071028032929.459"><vh>Fixed reporting bug in convertAllTabs/Blanks</vh></v>
<v t="ekr.20071028032929.460"><vh>Removed c.copyTree and v.copyNode and rewrote v.copyTree</vh></v>
<v t="ekr.20071028032929.461"><vh>Fixed bugs involving undoing entire trees.</vh></v>
</v>
<v t="ekr.20071028032929.462"><vh>7/10</vh>
<v t="ekr.20071028032929.463"><vh>Improved (I hope) dragging code</vh></v>
<v t="ekr.20071028032929.464"><vh>Added support for actionscript and rebol</vh></v>
</v>
<v t="ekr.20071028032929.465"><vh>7/7</vh>
<v t="ekr.20071028032929.466"><vh>Improved how headlines are edited</vh></v>
<v t="ekr.20071028032929.467"><vh>Created separate leoPlugins.leo</vh></v>
<v t="ekr.20071028032929.468"><vh>(Checked all code involving getTextSelection)</vh></v>
</v>
<v t="ekr.20071028032929.469"><vh>Undo/redo now restore selection and insert point</vh></v>
<v t="ekr.20071028032929.470"><vh>Fixed still more Open With problems</vh></v>
</v>
<v t="ekr.20071028032929.471"><vh>June 2003</vh>
<v t="ekr.20071028032929.472"><vh>6/30</vh>
<v t="ekr.20071028032929.473"><vh>lift dialogs when they are deiconified</vh></v>
<v t="ekr.20071028032929.474"><vh>Fixed another bug in createOpenWithTempFile</vh></v>
<v t="ekr.20071028032929.475"><vh>Fixed missing log messages bug</vh></v>
<v t="ekr.20071028032929.476"><vh>Changed destroyOpenWithFilesForFrame and createOpenWithTempFile</vh></v>
</v>
<v t="ekr.20071028032929.477"><vh>6/29</vh>
<v t="ekr.20071028032929.478"><vh>Added doc strings for most classes.</vh></v>
<v t="ekr.20071028032929.479"><vh>Redefined all major classes so they can be overridden by plugins</vh></v>
<v t="ekr.20071028032929.480"><vh>Improved spell-check plugin</vh></v>
</v>
<v t="ekr.20071028032929.481"><vh>6/28 3.12 beta 1 released</vh>
<v t="ekr.20071028032929.482"><vh>Rewrote distribution scripts to handle new directory organization</vh></v>
<v t="ekr.20071028032929.483"><vh>Fixed three bugs reported by pychecker</vh></v>
</v>
<v t="ekr.20071028032929.484"><vh>6/27 Rewrote callbacks in createMenuEntries</vh></v>
<v t="ekr.20071028032929.485"><vh>6/24 Added @wrap and @nowrap directives</vh></v>
<v t="ekr.20071028032929.486"><vh>6/22</vh>
<v t="ekr.20071028032929.487"><vh>Investigated new Open With problem</vh></v>
<v t="ekr.20071028032929.488"><vh>Added special case to idle_body_key to handle delete key</vh></v>
<v t="ekr.20071028032929.489"><vh>atFile.scanText no longer strips leading whitespace from headlines</vh></v>
<v t="ekr.20071028032929.490"><vh>Made window bigger when opening Leo from leo.py</vh></v>
</v>
<v t="ekr.20071028032929.491"><vh>6/21 Completed all gc cleanup tasks</vh></v>
<v t="ekr.20071028032929.492"><vh>6/19</vh>
<v t="ekr.20071028032929.493"><vh>Moved all window closing code into app class</vh></v>
<v t="ekr.20071028032929.494"><vh>Removed all destroy routines</vh></v>
<v t="ekr.20071028032929.495"><vh>Removed all 4.0 debris</vh></v>
</v>
<v t="ekr.20071028032929.496"><vh>6/18</vh>
<v t="ekr.20071028032929.497"><vh>Scanned for fractional height/width params.  None remain.</vh></v>
<v t="ekr.20071028032929.498"><vh>Removed unused fractional widths from leoFind ctor</vh></v>
<v t="ekr.20071028032929.499"><vh>Set initial_window_width to 150 in leoConfig</vh></v>
</v>
<v t="ekr.20071028032929.500"><vh>6/16 Fixed _huge_ leak in Tk.Canvas</vh></v>
<v t="ekr.20071028032929.501"><vh>6/10 Implemented incremental redrawing</vh></v>
<v t="ekr.20071028032929.502"><vh>6/8 Resolved copying issue</vh></v>
<v t="ekr.20071028032929.503"><vh>6/1 Removed improper clones</vh></v>
</v>
<v t="ekr.20071028032929.504"><vh>May 2003</vh>
<v t="ekr.20071028032929.505"><vh>5/31</vh>
<v t="ekr.20071028032929.506"><vh>Disabled cut/paste of outlines</vh></v>
</v>
<v t="ekr.20071028032929.507"><vh>5/23</vh>
<v t="ekr.20071028032929.508"><vh>Added "close-frame" &amp; "destroy-all-global-windows" hook code to destroy nav windows</vh></v>
<v t="ekr.20071028032929.509"><vh>Added titles to Recent and Marks dialogs.</vh></v>
<v t="ekr.20071028032929.510"><vh>Added "close-frame" and "destroy-all-global-windows" hooks</vh></v>
</v>
<v t="ekr.20071028032929.511"><vh>5/22</vh>
<v t="ekr.20071028032929.512"><vh>Rewrote the nav_buttons plugin using classes</vh></v>
<v t="ekr.20071028032929.513"><vh>Completed nav_buttons plugin</vh></v>
</v>
<v t="ekr.20071028032929.514"><vh>5/22 ** nav_buttons plugin!</vh>
<v t="ekr.20071028032929.515"><vh>Created nav_buttons plugin</vh></v>
<v t="ekr.20071028032929.516"><vh>use string.zfill instead of aString.zfill in color_markup plugin</vh></v>
</v>
<v t="ekr.20071028032929.517"><vh>5/21</vh>
<v t="ekr.20071028032929.518"><vh>Experiments with startup scripts</vh></v>
</v>
<v t="ekr.20071028032929.519"><vh>5/20 ** Added Icon &amp; Status areas</vh>
<v t="ekr.20071028032929.520"><vh>Added idle handler to update the row/col indicator in the status area</vh></v>
<v t="ekr.20071028032929.521"><vh>Added convenience routines for icon &amp; status areas</vh></v>
<v t="ekr.20071028032929.522"><vh>Disable non-functional parts of Find panel</vh></v>
<v t="ekr.20071028032929.523"><vh>Selected find text on entry to find panel</vh></v>
<v t="ekr.20071028032929.524"><vh>Added icon/status areas.  REMOVED MAJOR KLUDGE</vh></v>
</v>
<v t="ekr.20071028032929.525"><vh>5/19</vh>
<v t="ekr.20071028032929.526"><vh>Partially cleaned up leoFind class</vh></v>
<v t="ekr.20071028032929.527"><vh>TO DO: Convenience routines</vh></v>
<v t="ekr.20071028032929.528"><vh>Removed checkForLeoCustomize &amp; related logic</vh></v>
<v t="ekr.20071028032929.529"><vh>Documented new stub hooks</vh></v>
</v>
<v t="ekr.20071028032929.530"><vh>5/18</vh>
<v t="ekr.20071028032929.531"><vh>Added support for bolditalic and italicbold</vh></v>
<v t="ekr.20071028032929.532"><vh>Rewrote logic involving images.</vh></v>
</v>
<v t="ekr.20071028032929.533"><vh>5/17</vh>
<v t="ekr.20071028032929.534"><vh>Simplified startup code</vh></v>
<v t="ekr.20071028032929.535"><vh>Created the add_directives plugin</vh></v>
<v t="ekr.20071028032929.536"><vh>Created "scan-directives" hook in scanDirectives</vh></v>
<v t="ekr.20071028032929.537"><vh>Created "init-color-markup" hook</vh></v>
<v t="ekr.20071028032929.538"><vh>Fixed recent bug in colorizer</vh></v>
</v>
<v t="ekr.20071028032929.539"><vh>5/16</vh>
<v t="ekr.20071028032929.540"><vh>Improved how Leo loads plugins</vh></v>
<v t="ekr.20071028032929.541"><vh>Cleaned up some hooks</vh></v>
<v t="ekr.20071028032929.542"><vh>Created plugin to handle markup in body pane</vh></v>
<v t="ekr.20071028032929.543"><vh>Added stub hooks for cutomizing the drawing of the outline</vh></v>
<v t="ekr.20071028032929.544"><vh>Removed toggle &lt;&lt; &gt;&gt; command</vh></v>
</v>
<v t="ekr.20071028032929.545"><vh>5/15 stub hooks</vh>
<v t="ekr.20071028032929.546"><vh>Created the plugin and script menu plugins</vh></v>
<v t="ekr.20071028032929.547"><vh>Breakthough: stub hooks &amp; alphabetical order</vh></v>
</v>
<v t="ekr.20071028032929.548"><vh>5/13</vh>
<v t="ekr.20071028032929.549"><vh>Progress report 5/13/03: please read</vh></v>
<v t="ekr.20071028032929.550"><vh>Merged devel folder into main cvs folder</vh></v>
<v t="ekr.20071028032929.551"><vh>Updated version number to 4.0 alpha 1</vh></v>
<v t="ekr.20071028032929.552"><vh>Removed __init__ from files managed by LeoPy.leo</vh></v>
<v t="ekr.20071028032929.553"><vh>Use @ignore for all scripts</vh></v>
</v>
<v t="ekr.20071028032929.554"><vh>5/12</vh>
<v t="ekr.20071028032929.555"><vh>Reorganized Leo folder: big change to cvs</vh></v>
<v t="ekr.20071028032929.556"><vh>Investigated strange behavior of log pane during Open commands</vh></v>
</v>
<v t="ekr.20071028032929.557"><vh>5/4</vh>
<v t="ekr.20071028032929.558"><vh>Gathered statistics for threadNext</vh></v>
<v t="ekr.20071028032929.559"><vh>defined funcToMethod in leoGlobals.py</vh></v>
<v t="ekr.20071028032929.560"><vh>Experimented with precomputing threadNext and threadBack when linking nodes</vh></v>
<v t="ekr.20071028032929.561"><vh>Experimented with using v.mChildren to represent children</vh></v>
<v t="ekr.20071028032929.562"><vh>Changed OnIconDoubleClick to allow @url url comments</vh></v>
<v t="ekr.20071028032929.563"><vh>atFile code now use _permanent_ fileCommands.tnodesDict</vh></v>
<v t="ekr.20071028032929.564"><vh>Improved and tested checkForPossiblyBrokenLinks</vh></v>
<v t="ekr.20071028032929.565"><vh>Cleaned up atFile.read code</vh></v>
<v t="ekr.20071028032929.566"><vh>Cleaned up getVnode code</vh></v>
<v t="ekr.20071028032929.567"><vh>Added headString arg to tnode ctor</vh></v>
<v t="ekr.20071028032929.568"><vh>Moved createTopologyList to leoGlobals.py</vh></v>
</v>
<v t="ekr.20071028032929.569"><vh>5/3</vh>
<v t="ekr.20071028032929.570"><vh>Many changes to file reading code</vh></v>
<v t="ekr.20071028032929.571"><vh>Created scripts to check outline for clone &amp; joinList errors</vh></v>
<v t="ekr.20071028032929.572"><vh>Moved headlines into tnodes</vh></v>
<v t="ekr.20071028032929.573"><vh>Second rewrite of v.joinNodeTo</vh></v>
</v>
<v t="ekr.20071028032929.574"><vh>5/2</vh>
<v t="ekr.20071028032929.575"><vh>updateRecentFiles does nothing on Null filenames</vh></v>
<v t="ekr.20071028032929.576"><vh>Major change: rewrote joinList code and move joinLists to tnodes</vh></v>
</v>
<v t="ekr.20071028032929.577"><vh>5/1</vh>
<v t="ekr.20071028032929.578"><vh>Fixed bug when userID != defaultID</vh></v>
<v t="ekr.20071028032929.579"><vh>Made lines following @+t and @+v look like sentinels</vh></v>
<v t="ekr.20071028032929.580"><vh>Checked that Leo 3.11 can read new .leo files</vh></v>
<v t="ekr.20071028032929.581"><vh>Made sure leo works without leoID.txt when use_gnx is false</vh></v>
<v t="ekr.20071028032929.582"><vh>Optimized how Leo allocates t.gnx</vh></v>
</v>
</v>
<v t="ekr.20071028032929.583"><vh>April 2003</vh>
<v t="ekr.20071028032929.584"><vh>4/20</vh>
<v t="ekr.20071028032929.585"><vh>Removed vnx fields from vnodes and +v sentinels</vh></v>
<v t="ekr.20071028032929.586"><vh>Put getpreferredencoding code in try: except blocks</vh></v>
<v t="ekr.20071028032929.587"><vh>Made sure that code works on old files when a.use_gnx is true</vh></v>
<v t="ekr.20071028032929.588"><vh>Replaced fileCommands.getT by self.tnodesDict.get</vh></v>
</v>
<v t="ekr.20071028032929.589"><vh>4/29 Transition to 4.0 .leo files</vh>
<v t="ekr.20071028032929.590"><vh>Allocate gnx's only when needed (when writing files)</vh></v>
<v t="ekr.20071028032929.591"><vh>4.0 code writes tnodes even if they have no body text</vh></v>
<v t="ekr.20071028032929.592"><vh>4.0 code writes tnx="tnx" instead of t="index" in vnodes and tnodes</vh></v>
<v t="ekr.20071028032929.593"><vh>Write vnx and tnx instead of gnx in vnodes and tnodes</vh></v>
<v t="ekr.20071028032929.594"><vh>Made use_pre_4pt0_file_formats setting functional</vh></v>
</v>
<v t="ekr.20071028032929.595"><vh>4/28</vh>
<v t="ekr.20071028032929.596"><vh>Use tuples instead of dicts in nodeIndices class</vh></v>
<v t="ekr.20071028032929.597"><vh>Added code to remove gnx id if it matches default_gnx_id</vh></v>
<v t="ekr.20071028032929.598"><vh>Added code to read/write default_gnx_id field in globals section</vh></v>
<v t="ekr.20071028032929.599"><vh>Added code to write gnx attribute of tnodes and vnodes</vh></v>
<v t="ekr.20071028032929.600"><vh>Added code to read gnx attribute of tnodes and vnodes</vh></v>
<v t="ekr.20071028032929.601"><vh>Added old and new to list of valid @file options</vh></v>
<v t="ekr.20071028032929.602"><vh>Added use_pre_4pt0_file_formats config option</vh></v>
<v t="ekr.20071028032929.603"><vh>Added Write Old Format Outline command to Export menu</vh></v>
</v>
<v t="ekr.20071028032929.604"><vh>4/27</vh>
<v t="ekr.20071028032929.605"><vh>Made read-only messages red</vh></v>
<v t="ekr.20071028032929.606"><vh>4.x code always writes @+t sentinels even for empty nodes</vh></v>
<v t="ekr.20071028032929.607"><vh>Created gnx's in vnode and tnode ctors</vh></v>
</v>
<v t="ekr.20071028032929.608"><vh>4/27 3.11 final released</vh></v>
<v t="ekr.20071028032929.609"><vh>4/26</vh>
<v t="ekr.20071028032929.610"><vh>Greatly simplified Plugins menu code using list comprehensions</vh></v>
<v t="ekr.20071028032929.611"><vh>Added 4.0 code to atFile.read that deletes all children of root</vh></v>
<v t="ekr.20071028032929.612"><vh>Fixed bug that prevented email line in About Leo from working</vh></v>
<v t="ekr.20071028032929.613"><vh>Prepared for 3.11 final: updated dates and urls</vh></v>
<v t="ekr.20071028032929.614"><vh>Fixed various bugs reported by Pychecker</vh></v>
</v>
<v t="ekr.20071028032929.615"><vh>4/24</vh>
<v t="ekr.20071028032929.616"><vh>Added support for @lineending directive</vh></v>
<v t="ekr.20071028032929.617"><vh>Created utility routines for scanAllDirectives and scanDirectives</vh></v>
<v t="ekr.20071028032929.618"><vh>Fixed bug in skip_long</vh></v>
</v>
<v t="ekr.20071028032929.619"><vh>4/23 Improved dialog that gets id for leoID.txt</vh></v>
<v t="ekr.20071028032929.620"><vh>4/22 Added getpreferredencoding to leoGlobals.py</vh></v>
<v t="ekr.20071028032929.621"><vh>4/21 Added patch by Davide Salomoni to OnIconDoubleClick</vh></v>
<v t="ekr.20071028032929.622"><vh>4/20 Removed all __del__ methods</vh></v>
<v t="ekr.20071028032929.623"><vh>4/5 Removed write_clone_indices &amp; use_relative_node_indices config ivars</vh></v>
<v t="ekr.20071028032929.624"><vh>4/5 Added thin_at_file_trees &amp; load_derived_files_immediately options</vh></v>
<v t="ekr.20071028032929.625"><vh>4/4 Added call to c.redraw() in fileCommands.readAtFileNodes</vh></v>
<v t="ekr.20071028032929.626"><vh>4/4 Fixed unicode bugs when Tangling and Untangling</vh></v>
<v t="ekr.20071028032929.627"><vh>4/3 Eliminated caught exception in frame.setTabWidth</vh></v>
</v>
<v t="ekr.20071028032929.628"><vh>March 2003</vh>
<v t="ekr.20071028032929.629"><vh>3/30 Don't write gnx for ending sentinels</vh></v>
<v t="ekr.20071028032929.630"><vh>3/30 Added code to handle afterref sentinels</vh></v>
<v t="ekr.20071028032929.631"><vh>3/29 New read logic passes its first test</vh></v>
<v t="ekr.20071028032929.632"><vh>3/28 Use scanText as a base for 4.0 read logic</vh></v>
<v t="ekr.20071028032929.633"><vh>3/26</vh>
<v t="ekr.20071028032929.634"><vh>Installer now creates plugins directory</vh></v>
<v t="ekr.20071028032929.635"><vh>Improved scrolling when moving right</vh>
<v t="ekr.20071028032929.636"><vh>Test</vh>
<v t="ekr.20071028032929.637"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.638"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.639"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.640"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.641"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.642"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.643"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.644"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.645"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.646"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.647"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.648"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.649"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.650"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.651"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.652"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.653"><vh>NewHeadline</vh></v>
</v>
</v>
<v t="ekr.20071028032929.654"><vh>3/26 Removed duplicate redraws when renaming nodes</vh></v>
</v>
<v t="ekr.20071028032929.655"><vh>3/25 Created frame.setWindowTitle and associated logic</vh></v>
<v t="ekr.20071028032929.656"><vh>3/22</vh>
<v t="ekr.20071028032929.657"><vh>3/22 Added support for body/headline_gmt_time settings</vh></v>
<v t="ekr.20071028032929.658"><vh>3/22 Allow color param when queuing messages to log pane</vh></v>
<v t="ekr.20071028032929.659"><vh>3/22 Check for valid encoding when setting app().tkEncoding</vh></v>
</v>
<v t="ekr.20071028032929.660"><vh>3/18</vh>
<v t="ekr.20071028032929.661"><vh>3/18 Use app().tkEncoding to convert to unicode in log pane</vh></v>
<v t="ekr.20071028032929.662"><vh>3/18 Tangle now supports output_newline option</vh></v>
</v>
<v t="ekr.20071028032929.663"><vh>3/17 Fixed bugs in promote/demote</vh></v>
<v t="ekr.20071028032929.664"><vh>3/8</vh>
<v t="ekr.20071028032929.665"><vh>3/8 Full recolor after paste</vh></v>
<v t="ekr.20071028032929.666"><vh>3/8 Put file name first in window title</vh></v>
<v t="ekr.20071028032929.667"><vh>3/8 Added calls to toEncodedString before many calls to write</vh></v>
</v>
<v t="ekr.20071028032929.668"><vh>3/7</vh>
<v t="ekr.20071028032929.669"><vh>3/7 Fixed huge performance bug in v.unjoinNode</vh></v>
<v t="ekr.20071028032929.670"><vh>3/7 Added statistics gathering routines to leoGlobals.py</vh></v>
</v>
</v>
<v t="ekr.20071028032929.671"><vh>Feb 2003</vh>
<v t="ekr.20071028032929.672"><vh>2/26 3.11b3 released</vh></v>
<v t="ekr.20071028032929.673"><vh>2/20 Reinstated Expand All command</vh></v>
<v t="ekr.20071028032929.674"><vh>2/18 Fixed auto-indent for python</vh></v>
<v t="ekr.20071028032929.675"><vh>2/17 Fixed minor Import @root bugs</vh></v>
<v t="ekr.20071028032929.676"><vh>02/17 3.11b1 released</vh></v>
<v t="ekr.20071028032929.677"><vh>02/11</vh>
<v t="ekr.20071028032929.678"><vh>Fixed crasher in canFindMatchingBracket</vh></v>
<v t="ekr.20071028032929.679"><vh>Removed odious locks on customizeLeo.py</vh></v>
<v t="ekr.20071028032929.680"><vh>Fixed control-V bug for Linux</vh></v>
</v>
<v t="ekr.20071028032929.681"><vh>02/08</vh>
<v t="ekr.20071028032929.682"><vh>Major reorganization of hooks</vh></v>
<v t="ekr.20071028032929.683"><vh>Fixed bug: double-clicking icon set the cursor to the hand</vh></v>
<v t="ekr.20071028032929.684"><vh>Fixed bug: v.OnEndDrag fires event only if dragging</vh></v>
</v>
<v t="ekr.20071028032929.685"><vh>02/07</vh>
<v t="ekr.20071028032929.686"><vh>replaced c.contractVnode and c.expandVnode</vh></v>
</v>
<v t="ekr.20071028032929.687"><vh>02/04</vh>
<v t="ekr.20071028032929.688"><vh>Fixed "% (greenOgre)" config bug</vh></v>
</v>
<v t="ekr.20071028032929.689"><vh>02/02</vh>
<v t="ekr.20071028032929.690"><vh>Added code to scroll partially visible headlines when they are selected</vh></v>
</v>
<v t="ekr.20071028032929.691"><vh>02/01</vh>
<v t="ekr.20071028032929.692"><vh>Added code to allow sorting of top-level nodes</vh></v>
<v t="ekr.20071028032929.693"><vh>Hacked atFile.writeAll to allow multiple writes of cloned nodes</vh></v>
<v t="ekr.20071028032929.694"><vh>Removed redundant code from v.set/clearDirty routines</vh></v>
</v>
</v>
<v t="ekr.20071028032929.695"><vh>Jan 2003</vh>
<v t="ekr.20071028032929.696"><vh>01/31</vh>
<v t="ekr.20071028032929.697"><vh>Udated recent files menu when saving a new .leo file</vh></v>
<v t="ekr.20071028032929.698"><vh>Prefs dialog close button equivalent to cancel</vh></v>
<v t="ekr.20071028032929.699"><vh>Fixed about hooks typo</vh></v>
<v t="ekr.20071028032929.700"><vh>New Go To First/Last/Parent/Prev Sibling/Next Sibling commands</vh></v>
<v t="ekr.20071028032929.701"><vh>Major improvements to expand/contract commands</vh></v>
</v>
<v t="ekr.20071028032929.702"><vh>1/30</vh>
<v t="ekr.20071028032929.703"><vh>Create Toggle Angle Brackets command</vh></v>
<v t="ekr.20071028032929.704"><vh>Created Insert Body/Headline Time/Date routines</vh></v>
<v t="ekr.20071028032929.705"><vh>Added "Replace tabs with spaces" checkbox in Prefs panel</vh></v>
<v t="ekr.20071028032929.706"><vh>Made Find button the default button in the Find panel</vh></v>
<v t="ekr.20071028032929.707"><vh>Allowed @comment with @language plain</vh></v>
</v>
<v t="ekr.20071028032929.708"><vh>1/29</vh>
<v t="ekr.20071028032929.709"><vh>Added "save1" and "save2" hooks</vh></v>
<v t="ekr.20071028032929.710"><vh>Added disabled support for @folder to customizeLeo.py</vh></v>
<v t="ekr.20071028032929.711"><vh>Added support for Show Invisible color options</vh></v>
<v t="ekr.20071028032929.712"><vh>Added support for look_for_control_drag_on_mouse_down option</vh></v>
</v>
<v t="ekr.20071028032929.713"><vh>1/25</vh>
<v t="ekr.20071028032929.714"><vh>Fixed problem with block comments</vh>
<v t="ekr.20071028032929.715"><vh>Report</vh></v>
<v t="ekr.20071028032929.716"><vh>Reply</vh></v>
</v>
</v>
<v t="ekr.20071028032929.717"><vh>1/24</vh>
<v t="ekr.20071028032929.718"><vh>Fixed problem with cutting &amp; pasting nodes</vh></v>
<v t="ekr.20071028032929.719"><vh>Removed potential hang in frame.OnOpenWith</vh></v>
<v t="ekr.20071028032929.720"><vh>Added support for body_insertion_cursor_color setting</vh></v>
<v t="ekr.20071028032929.721"><vh>Fixed unicode in Tangle logic</vh></v>
</v>
<v t="ekr.20071028032929.722"><vh>1/23 Completed transition to unicode</vh></v>
<v t="ekr.20071028032929.723"><vh>1/21 Encode find/change strings as utf-8 in leoConfig.txt</vh></v>
<v t="ekr.20071028032929.724"><vh>1/20 Began conversion to unicode internally</vh></v>
<v t="ekr.20071028032929.725"><vh>1/18</vh>
<v t="ekr.20071028032929.726"><vh>Worked around True/False problems in Python 2.3 a1</vh></v>
</v>
<v t="ekr.20071028032929.727"><vh>1/7</vh>
<v t="ekr.20071028032929.728"><vh>Added colon to list of bad characters removed by sanitize_filename</vh></v>
</v>
</v>
</v>
<v t="ekr.20071028032929.729"><vh>2002</vh>
<v t="ekr.20071028032929.730"><vh>Dec 2002</vh>
<v t="ekr.20071028032929.731"><vh>12/18</vh>
<v t="ekr.20071028032929.732"><vh>Added event=event to handleLeoHook</vh></v>
<v t="ekr.20071028032929.733"><vh>Demoted up/down arrow stuff to a disabled hook for now.</vh></v>
</v>
<v t="ekr.20071028032929.734"><vh>12/17</vh>
<v t="ekr.20071028032929.735"><vh>Created tree.moveUpDown</vh></v>
</v>
<v t="ekr.20071028032929.736"><vh>112/16</vh>
<v t="ekr.20071028032929.737"><vh>Replaced string.x(s...) by s.x(...)</vh></v>
<v t="ekr.20071028032929.738"><vh>Improved es and trace, added trace_tag</vh></v>
<v t="ekr.20071028032929.739"><vh>Fixed crasher in undo logic</vh></v>
<v t="ekr.20071028032929.740"><vh>Reset the canvas cursor by brute force</vh></v>
<v t="ekr.20071028032929.741"><vh>Tried to prevent "stuck" drag cursor</vh></v>
<v t="ekr.20071028032929.742"><vh>Reviewed all calls to handleLeoHook </vh></v>
<v t="ekr.20071028032929.743"><vh>Fixed pychecker problems</vh></v>
</v>
<v t="ekr.20071028032929.744"><vh>12/14/02 3.10 released</vh></v>
<v t="ekr.20071028032929.745"><vh>12/12</vh>
<v t="ekr.20071028032929.746"><vh>Added "missing" event hooks</vh></v>
</v>
<v t="ekr.20071028032929.747"><vh>12/11</vh>
<v t="ekr.20071028032929.748"><vh>Fixed major bug in Execute Script command</vh></v>
</v>
<v t="ekr.20071028032929.749"><vh>12/10</vh>
<v t="ekr.20071028032929.750"><vh>Added convenience routines to redirect stderr and stdout</vh></v>
</v>
<v t="ekr.20071028032929.751"><vh>12/8</vh>
<v t="ekr.20071028032929.752"><vh>wrote redirectPrintToLog &amp; restorePrintFromLog</vh></v>
<v t="ekr.20071028032929.753"><vh>Fixed @nsf bug reported by Travers A. Hough</vh></v>
<v t="ekr.20071028032929.754"><vh>Discovered bugs in undoReplace logic</vh></v>
</v>
<v t="ekr.20071028032929.755"><vh>12/7</vh>
<v t="ekr.20071028032929.756"><vh>Fixed undo bug</vh></v>
</v>
<v t="ekr.20071028032929.757"><vh>12/6</vh>
<v t="ekr.20071028032929.758"><vh>Fixed reversion involving @comment &amp; @language together</vh></v>
<v t="ekr.20071028032929.759"><vh>major revision of the menu code</vh></v>
</v>
<v t="ekr.20071028032929.760"><vh>12/4</vh>
<v t="ekr.20071028032929.761"><vh>Fixed path problem in paths passed to tangle_done.py</vh></v>
<v t="ekr.20071028032929.762"><vh>Fixed Recent Files command</vh></v>
<v t="ekr.20071028032929.763"><vh>Fixed problems with Open With code in customizeLeo.py</vh></v>
<v t="ekr.20071028032929.764"><vh>Fixed crasher in colorizeAnyLanguage</vh></v>
<v t="ekr.20071028032929.765"><vh>Fixed major memory leak</vh></v>
<v t="ekr.20071028032929.766"><vh>Changed shortcut to Find Previous so Alt - F4 closes Leo</vh></v>
<v t="ekr.20071028032929.767"><vh>Changed url of help file</vh></v>
<v t="ekr.20071028032929.768"><vh>Removed backquotes from most print statements</vh></v>
<v t="ekr.20071028032929.769"><vh>Removed synonyms from leoImport.py and leoTangle.py</vh></v>
</v>
<v t="ekr.20071028032929.770"><vh>12/3</vh>
<v t="ekr.20071028032929.771"><vh>Converted leoConfig.py to use @root-code</vh></v>
<v t="ekr.20071028032929.772"><vh>Added @file &amp; @root options</vh></v>
<v t="ekr.20071028032929.773"><vh>Fixed a bug in Untangle</vh></v>
<v t="ekr.20071028032929.774"><vh>Decided not to do utils_normpath</vh></v>
</v>
</v>
<v t="ekr.20071028032929.775"><vh>Nov 2002</vh>
<v t="ekr.20071028032929.776"><vh>11/25</vh>
<v t="ekr.20071028032929.777"><vh>Improved Leo's window icon</vh></v>
<v t="ekr.20071028032929.778"><vh>cleaned up config code relating to find settings</vh></v>
<v t="ekr.20071028032929.779"><vh>Added Node only option to find menu</vh></v>
<v t="ekr.20071028032929.780"><vh>Added Export Headlines command</vh></v>
</v>
<v t="ekr.20071028032929.781"><vh>11/21</vh>
<v t="ekr.20071028032929.782"><vh>Fixed bug in colorizeAnyLine</vh></v>
<v t="ekr.20071028032929.783"><vh>Improved undo for Edit Body commands</vh></v>
</v>
<v t="ekr.20071028032929.784"><vh>11/20</vh>
<v t="ekr.20071028032929.785"><vh>Fixed unicode bugs</vh></v>
</v>
<v t="ekr.20071028032929.786"><vh>11/19</vh>
<v t="ekr.20071028032929.787"><vh>Changed use_configureLeo_dot_py to use_customizeLeo_dot_py</vh></v>
<v t="ekr.20071028032929.788"><vh>Create all non-existent directories using makeAllNonExistentDirectories</vh></v>
<v t="ekr.20071028032929.789"><vh>Made sure all open calls are in try blocks.</vh></v>
<v t="ekr.20071028032929.790"><vh>Recolor entire pane if @color or @nocolor change</vh></v>
<v t="ekr.20071028032929.791"><vh>Changed the lamda used to define the Recent Files callback</vh></v>
<v t="ekr.20071028032929.792"><vh>Added "openwith", "recentfiles" and "@url" hooks</vh></v>
<v t="ekr.20071028032929.793"><vh>Fixed big leak in undo</vh></v>
<v t="ekr.20071028032929.794"><vh>Properly save and restore selection range for undo.</vh></v>
<v t="ekr.20071028032929.795"><vh>Fixed bug that caused a backspace in an empty body text to insert a newline.</vh></v>
<v t="ekr.20071028032929.796"><vh>Made Undo bulletproof</vh></v>
<v t="ekr.20071028032929.797"><vh>Removed code in tree.select that removed trailing newlines</vh></v>
</v>
<v t="ekr.20071028032929.798"><vh>11/18</vh>
<v t="ekr.20071028032929.799"><vh>Added Open with entries to popup menus</vh></v>
<v t="ekr.20071028032929.800"><vh>Added David McNab's auto-indent patch (smart_auto_indent option)</vh></v>
</v>
<v t="ekr.20071028032929.801"><vh>11/17</vh>
<v t="ekr.20071028032929.802"><vh>Added "headkey1" and "headkey2" hooks</vh></v>
</v>
<v t="ekr.20071028032929.803"><vh>11/16</vh>
<v t="ekr.20071028032929.804"><vh>added enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler</vh></v>
<v t="ekr.20071028032929.805"><vh>Completed first draft of Go To Line Number command</vh></v>
</v>
<v t="ekr.20071028032929.806"><vh>11/15</vh>
<v t="ekr.20071028032929.807"><vh>Added Go To Line Number command</vh></v>
<v t="ekr.20071028032929.808"><vh>Rewrote syntax coloring for cweb</vh></v>
</v>
<v t="ekr.20071028032929.809"><vh>11/14</vh>
<v t="ekr.20071028032929.810"><vh>Fixed bug in atFile.scanAllDirectives involving @language</vh></v>
</v>
<v t="ekr.20071028032929.811"><vh>11/13</vh>
<v t="ekr.20071028032929.812"><vh>Added keywords parameter to customizeLeo</vh></v>
<v t="ekr.20071028032929.813"><vh>Implemented the use_configureLeo_dot_py option</vh></v>
<v t="ekr.20071028032929.814"><vh>Released first public draft of incremental undo</vh></v>
</v>
<v t="ekr.20071028032929.815"><vh>11/10</vh>
<v t="ekr.20071028032929.816"><vh>Correctly colors Pascal's "private" and "uses" keywords</vh></v>
</v>
<v t="ekr.20071028032929.817"><vh>11/9</vh>
<v t="ekr.20071028032929.818"><vh>Fixed blunder in undo/redraw code</vh></v>
<v t="ekr.20071028032929.819"><vh>Fixed Dave Hein's @language issue</vh></v>
<v t="ekr.20071028032929.820"><vh>Completed incremental syntax coloring</vh></v>
</v>
<v t="ekr.20071028032929.821"><vh>11/8</vh>
<v t="ekr.20071028032929.822"><vh>Worked on incremental syntax coloring</vh></v>
<v t="ekr.20071028032929.823"><vh>Changed leoCustomize.py to customizeLeo.py to make distribution easier.</vh></v>
<v t="ekr.20071028032929.824"><vh>Warn if @node leoCustomize.py is not @ignored</vh></v>
<v t="ekr.20071028032929.825"><vh>Execute script no longer supports @pythonscript</vh></v>
<v t="ekr.20071028032929.826"><vh>Added example of how to customize individual .leo files safely in leoCustomize.py</vh></v>
<v t="ekr.20071028032929.827"><vh>Added frame.longFileName and shortFileName methods</vh></v>
</v>
<v t="ekr.20071028032929.828"><vh>11/7</vh>
<v t="ekr.20071028032929.829"><vh>Prompt when writing leoCustomize.py</vh></v>
<v t="ekr.20071028032929.830"><vh>Disabled the "virus-word" in leCustomize.py</vh></v>
</v>
<v t="ekr.20071028032929.831"><vh>11/6</vh>
<v t="ekr.20071028032929.832"><vh>Fixed a major bug in top()</vh>
<v t="ekr.20071028032929.833"><vh>top</vh></v>
</v>
<v t="ekr.20071028032929.834"><vh>Implemented per-window hook scheme</vh></v>
</v>
<v t="ekr.20071028032929.835"><vh>11/5</vh>
<v t="ekr.20071028032929.836"><vh>Fixed bug in cweb coloring, made latex work more like cweb</vh></v>
<v t="ekr.20071028032929.837"><vh>Added app().realMenuName logic</vh></v>
<v t="ekr.20071028032929.838"><vh>Added "open1", "open2", "menu1" and "menu2" hooks</vh></v>
<v t="ekr.20071028032929.839"><vh>Completed generalization of menu code</vh></v>
</v>
<v t="ekr.20071028032929.840"><vh>11/4</vh>
<v t="ekr.20071028032929.841"><vh>Replaced all frame menu ivars with frame.menus dict</vh></v>
<v t="ekr.20071028032929.842"><vh>Generalized how commands are called</vh></v>
<v t="ekr.20071028032929.843"><vh>Added general-purpose hook handling</vh></v>
<v t="ekr.20071028032929.844"><vh>Use original leading whitespace when reformatting paragraphs</vh></v>
<v t="ekr.20071028032929.845"><vh>Use scanDirectives in Convert All Blanks/Tabs commands</vh></v>
<v t="ekr.20071028032929.846"><vh>Incorporated Dave Hein's recent changes</vh></v>
</v>
<v t="ekr.20071028032929.847"><vh>11/3</vh>
<v t="ekr.20071028032929.848"><vh>Implemented @pythonscript and Execute Script</vh></v>
</v>
<v t="ekr.20071028032929.849"><vh>11/2</vh>
<v t="ekr.20071028032929.850"><vh>Fixed bugs when importing Java files.</vh></v>
<v t="ekr.20071028032929.851"><vh>Fixed important bug in find_line_start</vh></v>
</v>
<v t="ekr.20071028032929.852"><vh>1/11</vh>
<v t="ekr.20071028032929.853"><vh>Fixed cweb hack using Jonathon Gilligan's patches</vh></v>
</v>
<v t="ekr.20071028032929.854"><vh>(reducing name polution)</vh></v>
</v>
<v t="ekr.20071028032929.855"><vh>Oct 2002</vh>
<v t="ekr.20071028032929.856"><vh>10/30</vh>
<v t="ekr.20071028032929.857"><vh>Applied cweb hack to all sentinels</vh></v>
<v t="ekr.20071028032929.858"><vh>raw cweb mode in @root trees</vh></v>
<v t="ekr.20071028032929.859"><vh>simplified Reformat Paragraph command</vh></v>
</v>
<v t="ekr.20071028032929.860"><vh>10/29 Released 3.8</vh>
<v t="ekr.20071028032929.861"><vh>10/28</vh>
<v t="ekr.20071028032929.862"><vh>Don't recognize @*, @&lt; or @( in cweb mode</vh></v>
<v t="ekr.20071028032929.863"><vh>Completed documentation for 3.8</vh></v>
</v>
<v t="ekr.20071028032929.864"><vh>10/27</vh>
<v t="ekr.20071028032929.865"><vh>Fixed problems report by Pychecker</vh></v>
<v t="ekr.20071028032929.866"><vh>Fixed path bugs in tangle.scanAllDirectives</vh></v>
<v t="ekr.20071028032929.867"><vh>Changed path_directive_creates_directories to create_nonexistent_directories</vh></v>
</v>
<v t="ekr.20071028032929.868"><vh>10/26</vh>
<v t="ekr.20071028032929.869"><vh>Fixed foo.leo bug</vh></v>
<v t="ekr.20071028032929.870"><vh>Worked around Control-T bug</vh></v>
<v t="ekr.20071028032929.871"><vh>Reset hand cursor after failed drag</vh></v>
</v>
<v t="ekr.20071028032929.872"><vh>10/25</vh>
<v t="ekr.20071028032929.873"><vh>Used dicts to speed up checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20071028032929.874"><vh>Created reloadAll in leoGlobals.py</vh></v>
<v t="ekr.20071028032929.875"><vh>Allow noweb section refs in @file cweb code</vh></v>
<v t="ekr.20071028032929.876"><vh>Added support for &lt;?xml-stylesheet...?&gt; line</vh></v>
<v t="ekr.20071028032929.877"><vh>Documented @rawfile and @silentfile</vh></v>
</v>
<v t="ekr.20071028032929.878"><vh>10/24</vh>
<v t="ekr.20071028032929.879"><vh>Fixed cweb sentinel bug</vh></v>
</v>
<v t="ekr.20071028032929.880"><vh>10/23</vh>
<v t="ekr.20071028032929.881"><vh>Completed first draft of new @rawfile and @silentfile</vh></v>
<v t="ekr.20071028032929.882"><vh>Discovered that gti's _are_ possible</vh></v>
<v t="ekr.20071028032929.883"><vh>Finished cweb hack</vh></v>
<v t="ekr.20071028032929.884"><vh>Fixed @delims "round trip" bug</vh></v>
<v t="ekr.20071028032929.885"><vh>Fixed bug involving menu pastes in headlines</vh></v>
</v>
<v t="ekr.20071028032929.886"><vh>10/19</vh>
<v t="ekr.20071028032929.887"><vh>Fixed import to @root problems</vh></v>
</v>
<v t="ekr.20071028032929.888"><vh>10/18</vh>
<v t="ekr.20071028032929.889"><vh>Completed handling of output_initial_comment option</vh></v>
<v t="ekr.20071028032929.890"><vh>Fixed block-comment bug in Java and HTML</vh></v>
<v t="ekr.20071028032929.891"><vh>Use // as single-line comment in Java</vh></v>
</v>
<v t="ekr.20071028032929.892"><vh>10/17</vh>
<v t="ekr.20071028032929.893"><vh>Allow @comment and @language to coexist</vh></v>
<v t="ekr.20071028032929.894"><vh>Match routines all return false if pattern is None or empty</vh></v>
<v t="ekr.20071028032929.895"><vh>Colorizer now recognizes comments after preprocessor directives</vh></v>
<v t="ekr.20071028032929.896"><vh>Corrected reversion in set_delims_from_string</vh></v>
</v>
<v t="ekr.20071028032929.897"><vh>10/16</vh>
<v t="ekr.20071028032929.898"><vh>Added support for forth language comments</vh></v>
<v t="ekr.20071028032929.899"><vh>Fixed another crasher in scanAllDirectives</vh></v>
<v t="ekr.20071028032929.900"><vh>Fixed assert failure in putBodyPart</vh></v>
<v t="ekr.20071028032929.901"><vh>Fixed crasher in scanAllDirectives</vh></v>
</v>
<v t="ekr.20071028032929.902"><vh>10/15</vh>
<v t="ekr.20071028032929.903"><vh>Added @raw support</vh></v>
<v t="ekr.20071028032929.904"><vh>Changed names of commands in help menu and corresponding entries in leoConfig.leo</vh></v>
<v t="ekr.20071028032929.905"><vh>Updated docs for recent features</vh></v>
</v>
<v t="ekr.20071028032929.906"><vh>10/14</vh>
<v t="ekr.20071028032929.907"><vh>All export commands now use output_newline option</vh></v>
<v t="ekr.20071028032929.908"><vh>Forced focus to body pane after ending headline edit</vh></v>
<v t="ekr.20071028032929.909"><vh>wrote "finished" after write @file nodes command</vh></v>
<v t="ekr.20071028032929.910"><vh>Use @@ sentinels only for real Leo directives</vh></v>
</v>
<v t="ekr.20071028032929.911"><vh>10/13 Rewrote colorizer using dispatch dict</vh></v>
<v t="ekr.20071028032929.912"><vh>10/12</vh>
<v t="ekr.20071028032929.913"><vh>Added Configuration Options item to help menu</vh></v>
</v>
<v t="ekr.20071028032929.914"><vh>10/11</vh>
<v t="ekr.20071028032929.915"><vh>added code to support output_newline option</vh></v>
<v t="ekr.20071028032929.916"><vh>Fixed reversion in file write code</vh></v>
<v t="ekr.20071028032929.917"><vh>Greatly simplified leoConfig.py</vh></v>
<v t="ekr.20071028032929.918"><vh>Completed support for @quiet</vh></v>
<v t="ekr.20071028032929.919"><vh>Syntax color perl's alarm function</vh></v>
</v>
<v t="ekr.20071028032929.920"><vh>10/10</vh>
<v t="ekr.20071028032929.921"><vh>Removed language bits</vh></v>
<v t="ekr.20071028032929.922"><vh>Removed directive bits</vh></v>
<v t="ekr.20071028032929.923"><vh>Used @q and @&gt; as sentinels in cweb mode</vh></v>
</v>
<v t="ekr.20071028032929.924"><vh>10/9 (after 3.7 released)</vh>
<v t="ekr.20071028032929.925"><vh>fixed Unicode bug in setBodyStringOrPane</vh></v>
<v t="ekr.20071028032929.926"><vh>Created es_exception</vh></v>
<v t="ekr.20071028032929.927"><vh>Added support for @rawfile (fixed bug in endEditLabel)</vh></v>
</v>
</v>
<v t="ekr.20071028032929.928"><vh>10/09 Released 3.7</vh>
<v t="ekr.20071028032929.929"><vh>10/8 Ran pychecker</vh></v>
<v t="ekr.20071028032929.930"><vh>10/7 Improved error messages for Unicode errors</vh></v>
<v t="ekr.20071028032929.931"><vh>10/6 leoOpen sets file name if it doesn't exist</vh></v>
<v t="ekr.20071028032929.932"><vh>10/5 Leo now closes an empty window when opening a recent file</vh></v>
<v t="ekr.20071028032929.933"><vh>10/4</vh>
<v t="ekr.20071028032929.934"><vh>Improved handling of Latin-1 encoding</vh></v>
<v t="ekr.20071028032929.935"><vh>Initialize all "config" section params to valid values</vh></v>
</v>
<v t="ekr.20071028032929.936"><vh>10/3</vh>
<v t="ekr.20071028032929.937"><vh>Removed all calls to decode</vh></v>
<v t="ekr.20071028032929.938"><vh>Got information about encode/decode</vh>
<v t="ekr.20071028032929.939"><vh>From  Martin v. Löwis (use unicode to interface with tk)</vh></v>
</v>
<v t="ekr.20071028032929.940"><vh>Fixed Find previous bug</vh></v>
<v t="ekr.20071028032929.941"><vh>Retained file modes when tangling and writing derived files</vh></v>
<v t="ekr.20071028032929.942"><vh>Added remove_sentinels_extension option</vh></v>
</v>
<v t="ekr.20071028032929.943"><vh>10/2 Changed find to findr when scanning @@ sentinels</vh></v>
</v>
</v>
<v t="ekr.20071028032929.944"><vh>Sept 2002</vh>
<v t="ekr.20071028032929.945"><vh>9/27</vh>
<v t="ekr.20071028032929.946"><vh>Removed extra newline following @+leo directive</vh></v>
</v>
<v t="ekr.20071028032929.947"><vh>9/26</vh>
<v t="ekr.20071028032929.948"><vh>"Relative" node indices aren't</vh></v>
<v t="ekr.20071028032929.949"><vh>Eliminated writing clone indices!</vh></v>
<v t="ekr.20071028032929.950"><vh>Allowed reads and writes of cloned @file nodes</vh></v>
</v>
<v t="ekr.20071028032929.951"><vh>9/25</vh>
<v t="ekr.20071028032929.952"><vh>Added perlpod hack</vh></v>
<v t="ekr.20071028032929.953"><vh>Added getBaseDirectory and used it to resolve relative paths</vh></v>
<v t="ekr.20071028032929.954"><vh>Removed bodyKeepsFocus logic in leoTree.py</vh></v>
<v t="ekr.20071028032929.955"><vh>Added code to various scanAllDirectives routines to create paths</vh></v>
<v t="ekr.20071028032929.956"><vh>Created "path_directive_creates_directories" option</vh></v>
</v>
<v t="ekr.20071028032929.957"><vh>9/24</vh>
<v t="ekr.20071028032929.958"><vh>"Mysterious" changes to files were due to setting Page Width = 80</vh></v>
<v t="ekr.20071028032929.959"><vh>Added code to configure headline colors</vh></v>
<v t="ekr.20071028032929.960"><vh>Made the About Leo dialog non-modal</vh></v>
<v t="ekr.20071028032929.961"><vh>Fixed bug that disabled all shortcuts</vh></v>
<v t="ekr.20071028032929.962"><vh>Added support for Esc in shortcuts</vh></v>
<v t="ekr.20071028032929.963"><vh>Added End Edit Headline and Abort Edit Headline commands</vh></v>
<v t="ekr.20071028032929.964"><vh>Fixed undo cloned headline bug</vh></v>
</v>
<v t="ekr.20071028032929.965"><vh>9/23 Finished user-configurable shortcuts</vh></v>
<v t="ekr.20071028032929.966"><vh>9/21</vh>
<v t="ekr.20071028032929.967"><vh>Fixed colorizing for "while" in C</vh></v>
<v t="ekr.20071028032929.968"><vh>Leo now remembers insert point always</vh></v>
</v>
<v t="ekr.20071028032929.969"><vh>9/20 Fixed tab problems</vh></v>
<v t="ekr.20071028032929.970"><vh>9/19 Removed setup.py from binary distribution</vh></v>
<v t="ekr.20071028032929.971"><vh>9/18 New file code: end of cursed newlines.</vh>
<v t="ekr.20071028032929.972"><vh>Write only \n (Linux newlines) in derived files and .leo files</vh></v>
<v t="ekr.20071028032929.973"><vh>Major change to atFile::read code</vh></v>
</v>
<v t="ekr.20071028032929.974"><vh>9/15</vh>
<v t="ekr.20071028032929.975"><vh>Added self=self to lambda definitions to keep Python 2.1 happy</vh></v>
<v t="ekr.20071028032929.976"><vh>Folded all CVS changes into this file</vh></v>
</v>
<v t="ekr.20071028032929.977"><vh>9/14 Added secondary pane ratios to leoConfig.txt</vh></v>
<v t="ekr.20071028032929.978"><vh>9/13</vh>
<v t="ekr.20071028032929.979"><vh>Folded Steven P. Schaefer's @first in @root code.</vh></v>
<v t="ekr.20071028032929.980"><vh>Fixed "Unselected Ctrl-[ four times" bug</vh></v>
<v t="ekr.20071028032929.981"><vh>Investigated reported font settings bug: works for me</vh></v>
<v t="ekr.20071028032929.982"><vh>Incorporated Dave Heins code into getBodyLines</vh></v>
</v>
<v t="ekr.20071028032929.983"><vh>9/12</vh>
<v t="ekr.20071028032929.984"><vh>Fixed bug in updateBodyPane affecting Edit Body commands</vh></v>
<v t="ekr.20071028032929.985"><vh>Suggested ISO-8859-15 instead of ISO-8859-1 in leoConfig.leo</vh></v>
<v t="ekr.20071028032929.986"><vh>Generated PKG-INFO in Version Stuff section</vh></v>
<v t="ekr.20071028032929.987"><vh>Fixed @language plain # bug.</vh></v>
<v t="ekr.20071028032929.988"><vh>Improved enabling of menu items in popup menus</vh></v>
<v t="ekr.20071028032929.989"><vh>Fixed @language plain single-quote bug</vh></v>
<v t="ekr.20071028032929.990"><vh>Incorporated Dave Hein's "wrapping in doc part" bug fix</vh></v>
<v t="ekr.20071028032929.991"><vh>Changed accelerator of Go To Next Changed to Alt-D</vh></v>
</v>
<v t="ekr.20071028032929.992"><vh>9/11 Released 3.6</vh>
<v t="ekr.20071028032929.993"><vh>9/11 Hacked colorizeAnyLanguage to support all PHP constructs</vh></v>
<v t="ekr.20071028032929.994"><vh>9/11 Implemented @last</vh></v>
</v>
<v t="ekr.20071028032929.995"><vh>9/9</vh>
<v t="ekr.20071028032929.996"><vh>Removed most error messages in atFile::read logic</vh></v>
<v t="ekr.20071028032929.997"><vh>Integrated changes in PHP changes into this file</vh></v>
</v>
<v t="ekr.20071028032929.998"><vh>9/7</vh>
<v t="ekr.20071028032929.999"><vh>9/7 and later: started to design the "Resolve CVS Conflicts command"</vh></v>
<v t="ekr.20071028032929.1000"><vh>Dave Hein: added new code to make Python window work on Linux.</vh></v>
</v>
<v t="ekr.20071028032929.1001"><vh>9/5 Fixed bugs in @path logic in tangle.scanAllDirectives</vh></v>
<v t="ekr.20071028032929.1002"><vh>9/4</vh>
<v t="ekr.20071028032929.1003"><vh>Tomaz Ficko: Added support for MouseWheel (Linux only)</vh></v>
<v t="ekr.20071028032929.1004"><vh>Steven P. Schaefer: Fixed cursed newline bug for Linux</vh></v>
</v>
<v t="ekr.20071028032929.1005"><vh>9/3</vh>
<v t="ekr.20071028032929.1006"><vh>Experimented with CVS Revision keyword in About box.</vh></v>
<v t="ekr.20071028032929.1007"><vh>Added Match Brackets command</vh></v>
<v t="ekr.20071028032929.1008"><vh>Added shortcuts for Read/Write @file Nodes commands</vh></v>
</v>
<v t="ekr.20071028032929.1009"><vh>9/2</vh>
<v t="ekr.20071028032929.1010"><vh>Steven P. Schaefer: Improved handling of directives in @root trees</vh></v>
<v t="ekr.20071028032929.1011"><vh>Dave Hein: added CheckVersion to leoUtils.py</vh></v>
<v t="ekr.20071028032929.1012"><vh>Dave Hein: fixed Tk 8.4 problem in Prefs Panel</vh></v>
<v t="ekr.20071028032929.1013"><vh>Body pane now gets focus after Go Back/Next</vh></v>
<v t="ekr.20071028032929.1014"><vh>Changed leoTangle.scanAllDirectives</vh></v>
<v t="ekr.20071028032929.1015"><vh>Leo now remembers scrollbar positions</vh></v>
<v t="ekr.20071028032929.1016"><vh>Removed windows newlines in leoConfig.update</vh></v>
<v t="ekr.20071028032929.1017"><vh>Improved call to os.path.join in leoApp.finishCreate</vh></v>
</v>
<v t="ekr.20071028032929.1018"><vh>9/1</vh>
<v t="ekr.20071028032929.1019"><vh>Saved edit position of tnodes</vh></v>
<v t="ekr.20071028032929.1020"><vh>Investigated @language for @root trees</vh></v>
<v t="ekr.20071028032929.1021"><vh>Fixed missing headline bug on startup</vh></v>
<v t="ekr.20071028032929.1022"><vh>Changed all os.rename to utils_rename</vh></v>
<v t="ekr.20071028032929.1023"><vh>Changed mode in leoConfig::update</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1024"><vh>Aug 2002</vh>
<v t="ekr.20071028032929.1025"><vh>8/24</vh>
<v t="ekr.20071028032929.1026"><vh>Added version to url for online tutorial</vh></v>
<v t="ekr.20071028032929.1027"><vh>Improved About Leo dialog</vh></v>
<v t="ekr.20071028032929.1028"><vh>Improved dowloading of sbooks.chm</vh></v>
</v>
<v t="ekr.20071028032929.1029"><vh>8/15</vh>
<v t="ekr.20071028032929.1030"><vh>prototyped window icons in Tk</vh></v>
<v t="ekr.20071028032929.1031"><vh>Attempted to make mouse wheel functional in tree pane</vh></v>
<v t="ekr.20071028032929.1032"><vh>Rewrote About Leo dialog with icon &amp; hyperlinks</vh></v>
<v t="ekr.20071028032929.1033"><vh>Improved download dialog in Help-Tutorial command</vh></v>
</v>
<v t="ekr.20071028032929.1034"><vh>8/14 Released 3.5</vh>
<v t="ekr.20071028032929.1035"><vh>Corrected wrapping in log window when horizontal scrollbar is present</vh></v>
<v t="ekr.20071028032929.1036"><vh>Released 3.5</vh></v>
<v t="ekr.20071028032929.1037"><vh>Added log_pane_wraps and outline_pane_scrolls_horizontally params</vh></v>
<v t="ekr.20071028032929.1038"><vh>Fixed Tangle logic</vh></v>
</v>
<v t="ekr.20071028032929.1039"><vh>8/13 Bugs, bugs, bugs</vh>
<v t="ekr.20071028032929.1040"><vh>called cf.flush in leoConfig.update</vh></v>
<v t="ekr.20071028032929.1041"><vh>Open url's from help menu</vh></v>
<v t="ekr.20071028032929.1042"><vh>Rewrote path logic</vh></v>
<v t="ekr.20071028032929.1043"><vh>Warn on read-only files</vh></v>
<v t="ekr.20071028032929.1044"><vh>Hacked on leoAtFile.scanAllDirectives to fix directory problem</vh></v>
<v t="ekr.20071028032929.1045"><vh>Fixed (?) cursed newline bug in leoAtFile</vh></v>
</v>
<v t="ekr.20071028032929.1046"><vh>8/11 Released 3.4</vh>
<v t="ekr.20071028032929.1047"><vh>Fixed crasher when leoConfig.txt does not exist</vh></v>
<v t="ekr.20071028032929.1048"><vh>Fixed bug in leoFileCommands.readOutlineOnly</vh></v>
<v t="ekr.20071028032929.1049"><vh>Wrote importFiles script in leoImport.leo</vh></v>
<v t="ekr.20071028032929.1050"><vh>Released 3.4</vh></v>
<v t="ekr.20071028032929.1051"><vh>Syntax colorer now honors @comment</vh></v>
</v>
<v t="ekr.20071028032929.1052"><vh>8/10</vh>
<v t="ekr.20071028032929.1053"><vh>Added save_clears_undo_buffer configuration option</vh></v>
<v t="ekr.20071028032929.1054"><vh>Improved Recent Files menu</vh></v>
</v>
<v t="ekr.20071028032929.1055"><vh>8/9 Fixed Unicode Bugs</vh></v>
<v t="ekr.20071028032929.1056"><vh>8/6</vh>
<v t="ekr.20071028032929.1057"><vh>Corrected problems with find/prefs settings</vh></v>
<v t="ekr.20071028032929.1058"><vh>created leoConfig.leo</vh></v>
<v t="ekr.20071028032929.1059"><vh>Fixed a bug in config.setDict (!) (This fixes font problems)</vh></v>
<v t="ekr.20071028032929.1060"><vh>Leo writes split direction to leoConfig.txt</vh></v>
<v t="ekr.20071028032929.1061"><vh>Leo writes prefs if leoConfig.txt is read-only</vh></v>
</v>
<v t="ekr.20071028032929.1062"><vh>8/5 Leo honors pane ratio stored in .leo files</vh></v>
<v t="ekr.20071028032929.1063"><vh>8/4</vh>
<v t="ekr.20071028032929.1064"><vh>Improved highlighting of whitespace</vh></v>
<v t="ekr.20071028032929.1065"><vh>Fixed revert problems in font panel</vh></v>
<v t="ekr.20071028032929.1066"><vh>Added @ignore to "raw" imported files</vh></v>
<v t="ekr.20071028032929.1067"><vh>Remove Sentinels command now uses .txt extension instead of .tmp</vh></v>
<v t="ekr.20071028032929.1068"><vh>Added log message for Remove Sentinels command</vh></v>
<v t="ekr.20071028032929.1069"><vh>Corrected spelling of limit_directory_search_extenstion </vh></v>
<v t="ekr.20071028032929.1070"><vh>Fixed wandering insertion point bug</vh></v>
</v>
<v t="ekr.20071028032929.1071"><vh>8/3</vh>
<v t="ekr.20071028032929.1072"><vh>looked for backticks</vh></v>
<v t="ekr.20071028032929.1073"><vh>Cleaned up files using nested compares</vh></v>
<v t="ekr.20071028032929.1074"><vh>Fixed another clone bug: created setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="ekr.20071028032929.1075"><vh>Released 3.3</vh></v>
</v>
<v t="ekr.20071028032929.1076"><vh>8/2</vh>
<v t="ekr.20071028032929.1077"><vh>Leo supports Unicode !!</vh></v>
<v t="ekr.20071028032929.1078"><vh>changed skip_long to handle negative values</vh></v>
<v t="ekr.20071028032929.1079"><vh>initialized atFile.default_directory to None</vh></v>
<v t="ekr.20071028032929.1080"><vh>eliminated both presentLanguage and targetLanguage ivars from leoAtFile</vh></v>
<v t="ekr.20071028032929.1081"><vh>Removed default param from set_language</vh></v>
</v>
<v t="ekr.20071028032929.1082"><vh>8/1</vh>
<v t="ekr.20071028032929.1083"><vh>Fixed crasher in leoTangle.putDoc</vh></v>
<v t="ekr.20071028032929.1084"><vh>Fixed problems with negative tab widths</vh></v>
<v t="ekr.20071028032929.1085"><vh>Fixed the "delims botch"</vh></v>
<v t="ekr.20071028032929.1086"><vh>Made 'additional_body_text_border' setting functional</vh></v>
<v t="ekr.20071028032929.1087"><vh>Made 'body_pane_wraps' setting functional</vh></v>
<v t="ekr.20071028032929.1088"><vh>Fixed config tables</vh></v>
<v t="ekr.20071028032929.1089"><vh>Initialized leoAtFile properly</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1090"><vh>July 2002</vh>
<v t="ekr.20071028032929.1091"><vh>7/30 Fixed many bugs in Color panel</vh></v>
<v t="ekr.20071028032929.1092"><vh>7/30 Proved that Leo handles nested @others directives properly</vh>
<v t="ekr.20071028032929.1093"><vh>Proof that nested @others directives are valid</vh></v>
</v>
<v t="ekr.20071028032929.1094"><vh>7/29</vh>
<v t="ekr.20071028032929.1095"><vh>7/29 Fixed bug in skip_pp_if and added skip_pp_part</vh></v>
<v t="ekr.20071028032929.1096"><vh>7/29 Added @ignore to the root of all imported trees</vh></v>
<v t="ekr.20071028032929.1097"><vh>7/29 Fixed bug in scanPythonDef.&lt;&lt; skip the Python def &gt;&gt;</vh></v>
<v t="ekr.20071028032929.1098"><vh>7/29 Improved import of classes</vh></v>
<v t="ekr.20071028032929.1099"><vh>7/29 Relaxed the rules for @others: allowed @others within @others tree</vh></v>
<v t="ekr.20071028032929.1100"><vh>7/29 Added glossary entries</vh></v>
<v t="ekr.20071028032929.1101"><vh>7/29 Fixed crasher in Prefs onCancel</vh></v>
<v t="ekr.20071028032929.1102"><vh>7/29 Fixed problems with Outline/Move/Select Go commands</vh></v>
<v t="ekr.20071028032929.1103"><vh>7/29 Added email address &amp; URL to About Leo dialog</vh></v>
<v t="ekr.20071028032929.1104"><vh>7/29 Fixed import bug</vh></v>
</v>
<v t="ekr.20071028032929.1105"><vh>7/27 Continued comments for lines ending in \</vh></v>
<v t="ekr.20071028032929.1106"><vh>7/24 Added @file disStats.py</vh></v>
<v t="ekr.20071028032929.1107"><vh>7/24 Added leo.profile()</vh></v>
<v t="ekr.20071028032929.1108"><vh>7/20 Released 3.1</vh>
<v t="ekr.20071028032929.1109"><vh>7/20 Finished Compare panel code, including using leoConfig.txt params</vh></v>
</v>
<v t="ekr.20071028032929.1110"><vh>7/19</vh>
<v t="ekr.20071028032929.1111"><vh>7/19 Leo now adds path to Idle automatically</vh></v>
<v t="ekr.20071028032929.1112"><vh>7/19 Fixed bug that caused leo.py not to run</vh></v>
<v t="ekr.20071028032929.1113"><vh>7/19 Completed the visual design of the Compare panel</vh></v>
</v>
<v t="ekr.20071028032929.1114"><vh>7/18</vh>
<v t="ekr.20071028032929.1115"><vh>7/18 Revised leoCompare.py</vh></v>
<v t="ekr.20071028032929.1116"><vh>7/18 Changed precedence scheme for preferences</vh></v>
<v t="ekr.20071028032929.1117"><vh>7/18 Added support for @language tcl/tk</vh></v>
<v t="ekr.20071028032929.1118"><vh>7/18 Fixed major bugs in skip_long &amp; tangle.scanAllDirectives!</vh></v>
</v>
<v t="ekr.20071028032929.1119"><vh>7/17</vh>
<v t="ekr.20071028032929.1120"><vh>7/17 v.moreBody now only escapes first non-blank character on a line</vh></v>
<v t="ekr.20071028032929.1121"><vh>7/17 Told where to download Python 2.2 and Tk 8.3 In 2.2 required dialog</vh>
<v t="ekr.20071028032929.1122"><vh>7/17 Added optional text param to leoDialog.askOk</vh></v>
<v t="ekr.20071028032929.1123"><vh>7/17 Tried closing Leo window during a long write</vh></v>
<v t="ekr.20071028032929.1124"><vh>7/17 The compare window is important!</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1125"><vh>7/16 Released 3.0</vh>
<v t="ekr.20071028032929.1126"><vh>7/16 Added leoConfig.txt to manifest</vh></v>
<v t="ekr.20071028032929.1127"><vh>7/16 Did spellcheck on LeoDocs.leo using MS Word</vh></v>
<v t="ekr.20071028032929.1128"><vh>7/16 Fixed autoscrolling so it can stop</vh></v>
<v t="ekr.20071028032929.1129"><vh>7/16 Ran pychecker</vh></v>
<v t="ekr.20071028032929.1130"><vh>7/16 Called traceback.print_exc for all serious exceptions</vh></v>
</v>
<v t="ekr.20071028032929.1131"><vh>7/15 Leo code complete</vh>
<v t="ekr.20071028032929.1132"><vh>7/15 Adjusted tree to handle larger font size</vh></v>
<v t="ekr.20071028032929.1133"><vh>7/15 Make Convert All Blanks and Convert All Tabs undoable</vh></v>
<v t="ekr.20071028032929.1134"><vh>7/15 ** Speeded up autoscrolling enough to be useful</vh></v>
<v t="ekr.20071028032929.1135"><vh>7/15 New windows now open using config params.</vh></v>
<v t="ekr.20071028032929.1136"><vh>7/15 Cleaned up how windows are opened</vh></v>
<v t="ekr.20071028032929.1137"><vh>7/15 Fixed bug that disabled window positioning!</vh></v>
<v t="ekr.20071028032929.1138"><vh>7/15 Changed config getters to get from defaults</vh></v>
<v t="ekr.20071028032929.1139"><vh>7/15 Added code to support font prefs.</vh></v>
<v t="ekr.20071028032929.1140"><vh>7/15 Added frame code to support non-modal panes</vh></v>
</v>
<v t="ekr.20071028032929.1141"><vh>Earlier</vh>
<v t="ekr.20071028032929.1142"><vh>7/14</vh>
<v t="ekr.20071028032929.1143"><vh>7/13 Added default tables to config module</vh></v>
<v t="ekr.20071028032929.1144"><vh>7/13 Added name picker to color panel</vh></v>
<v t="ekr.20071028032929.1145"><vh>7/13 Finished handlers for Font frame</vh></v>
</v>
<v t="ekr.20071028032929.1146"><vh>7/12</vh>
<v t="ekr.20071028032929.1147"><vh>7/12 Font &amp; color panels need not be modal !</vh></v>
<v t="ekr.20071028032929.1148"><vh>7/12 Finished Tk work on Font frame</vh></v>
</v>
<v t="ekr.20071028032929.1149"><vh>7/11</vh>
<v t="ekr.20071028032929.1150"><vh>7/11 Fixed syntax coloring bug</vh></v>
<v t="ekr.20071028032929.1151"><vh>7/11 Lots of work on preferences and color panel</vh></v>
</v>
<v t="ekr.20071028032929.1152"><vh>7/10 File (and clipboard) format changed!</vh>
<v t="ekr.20071028032929.1153"><vh>7/10 Allowed "ISO-8859-1" specification</vh></v>
<v t="ekr.20071028032929.1154"><vh>7/10 Warn and abort if not Python 2.2 or above</vh></v>
<v t="ekr.20071028032929.1155"><vh>7/10 app.finishCreate checks for Python 2.2 or higher</vh></v>
<v t="ekr.20071028032929.1156"><vh>7/10 Cleaned up Recent Files menu code</vh></v>
<v t="ekr.20071028032929.1157"><vh>7/10 All panels now have labeled frames and grooved borders</vh></v>
<v t="ekr.20071028032929.1158"><vh>7/10 Created leoFontPanel.py and added leoColorPanel class to leoColor.py</vh></v>
</v>
<v t="ekr.20071028032929.1159"><vh>7/9 Created create_labeled_frame and Font and Colors panels</vh></v>
<v t="ekr.20071028032929.1160"><vh>7/8</vh>
<v t="ekr.20071028032929.1161"><vh>7/8 Improved syntax coloring</vh></v>
<v t="ekr.20071028032929.1162"><vh>7/8 The REM hack &amp; fixed crasher</vh></v>
<v t="ekr.20071028032929.1163"><vh>7/8 Fixed crasher in atFile.scanAllDirectives</vh></v>
<v t="ekr.20071028032929.1164"><vh>7/8 Finished Toggle Split Direction</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1165"><vh>leo.py 2.5 and earlier</vh>
<v t="ekr.20071028032929.1166"><vh>7/7</vh>
<v t="ekr.20071028032929.1167"><vh>7/7 Fixed crashers when undoing or redoing moves</vh></v>
<v t="ekr.20071028032929.1168"><vh>7/7 Updated LeoDocs.leo and Leo's web site</vh></v>
<v t="ekr.20071028032929.1169"><vh>7/7 Released 2.5 and updated CVS</vh></v>
</v>
<v t="ekr.20071028032929.1170"><vh>7/6 version 2.5 is now code complete</vh>
<v t="ekr.20071028032929.1171"><vh>7/6 Improved Import to @root</vh></v>
<v t="ekr.20071028032929.1172"><vh>7/6 Fixed Import bug: empty classes and nested classes</vh></v>
<v t="ekr.20071028032929.1173"><vh>7/6 Fixed Import bug that caused orphan nodes</vh></v>
<v t="ekr.20071028032929.1174"><vh>7/6 Fixed Import bug that caused duplicate class lines.</vh></v>
<v t="ekr.20071028032929.1175"><vh>7/6 Renamed Font to Set Font... and Syntax Coloring... to Set Colors...</vh></v>
<v t="ekr.20071028032929.1176"><vh>7/6 Created c.initJoinedCloneBits</vh></v>
<v t="ekr.20071028032929.1177"><vh>7/6 Verified that undo works</vh></v>
</v>
<v t="ekr.20071028032929.1178"><vh>7/5</vh>
<v t="ekr.20071028032929.1179"><vh>7/5 Made extract commands undoable &amp; simplified undo.</vh></v>
<v t="ekr.20071028032929.1180"><vh>7/5 Made import commands undoable.</vh></v>
<v t="ekr.20071028032929.1181"><vh>7/5 Discovered traceback module</vh></v>
<v t="ekr.20071028032929.1182"><vh>7/5 Made Cascade command functional</vh></v>
<v t="ekr.20071028032929.1183"><vh>7/5 Enabled Minimize All command</vh></v>
<v t="ekr.20071028032929.1184"><vh>7/5 Forced syntax coloring after extract commands</vh></v>
</v>
<v t="ekr.20071028032929.1185"><vh>7/4</vh>
<v t="ekr.20071028032929.1186"><vh>7/4 Find/Change settings can be overridden by leoConfig.txt</vh></v>
<v t="ekr.20071028032929.1187"><vh>7/4 Invalid directories are no longer errors in leoAtFiles.scanAllDirectives</vh></v>
<v t="ekr.20071028032929.1188"><vh>7/4 Prefs now can be overridden by leoConfig.txt</vh></v>
</v>
<v t="ekr.20071028032929.1189"><vh>7/3</vh>
<v t="ekr.20071028032929.1190"><vh>7/3 Added Convert All Blanks and Convert All Tabs commands</vh></v>
<v t="ekr.20071028032929.1191"><vh>7/3 Added Convert Tabs command</vh></v>
<v t="ekr.20071028032929.1192"><vh>7/3 Changed tabs to blanks when tab width is negative</vh></v>
<v t="ekr.20071028032929.1193"><vh>7/3 Changed c.tab/page_width to self.tab/page_width in leoAtFile.py</vh></v>
<v t="ekr.20071028032929.1194"><vh>7/3 Added OK, Cancel, Revert buttons to Prefs panel</vh></v>
<v t="ekr.20071028032929.1195"><vh>7/3 Added window name to Prefs title</vh></v>
<v t="ekr.20071028032929.1196"><vh>7/3 Added @language python to all @file nodes</vh></v>
</v>
<v t="ekr.20071028032929.1197"><vh>7/2</vh>
<v t="ekr.20071028032929.1198"><vh>7/2 Changed defaultextension from "x" to ".x"</vh></v>
<v t="ekr.20071028032929.1199"><vh>7/2 Made prefs a modal dialog</vh></v>
<v t="ekr.20071028032929.1200"><vh>7/2 About c.defaultDirectory</vh></v>
<v t="ekr.20071028032929.1201"><vh>7/2 Changed Save and Save As...</vh></v>
<v t="ekr.20071028032929.1202"><vh>7/2 Fixed crashers in Remove Sentinels command</vh></v>
<v t="ekr.20071028032929.1203"><vh>7/2 Fixed crasher in import.scanAllDirectives)</vh></v>
<v t="ekr.20071028032929.1204"><vh>7/2 Hacked code so tab width works</vh></v>
<v t="ekr.20071028032929.1205"><vh>7/2 Fixed doc problems</vh>
<v t="ekr.20071028032929.1206"><vh>Demote docs</vh></v>
<v t="ekr.20071028032929.1207"><vh>Open/Close log window docs</vh></v>
<v t="ekr.20071028032929.1208"><vh>Insert Headline docs</vh></v>
<v t="ekr.20071028032929.1209"><vh>Extract Section docs</vh></v>
<v t="ekr.20071028032929.1210"><vh>Syntax Coloring... &amp; Font...</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1211"><vh>7/1 Cut/Paste now works properly</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1212"><vh>June 2002	</vh>
<v t="ekr.20071028032929.1213"><vh>06/22 Implemented Recent Files menu &amp; leoConfig.py</vh></v>
<v t="ekr.20071028032929.1214"><vh>06/19 Removed assert from st_enter_root_name</vh></v>
<v t="ekr.20071028032929.1215"><vh>06/18 Improved error recovery when writing .leo files</vh></v>
<v t="ekr.20071028032929.1216"><vh>06/16 Changed leo.py so Leo can open files when files are double-clicked</vh></v>
<v t="ekr.20071028032929.1217"><vh>06/16 Finished updating LeoDocs.leo to match Leo's web site</vh></v>
<v t="ekr.20071028032929.1218"><vh>06/15 Fixed the control-I and control-H bugs</vh></v>
<v t="ekr.20071028032929.1219"><vh>06/15 Double clicking in a headline now selects a word</vh></v>
<v t="ekr.20071028032929.1220"><vh>06/15 Implemented Drag and Drop</vh></v>
<v t="ekr.20071028032929.1221"><vh>06/04 Changed atFile.scanAllDirectives to use c.openDirectory as default</vh></v>
<v t="ekr.20071028032929.1222"><vh>06/03 Changed cursor to double arrow when cursor is over splitter bars</vh></v>
<v t="ekr.20071028032929.1223"><vh>06/02 Bug fix in es in leoGlobals</vh></v>
<v t="ekr.20071028032929.1224"><vh>06/02 Tried and failed to call wm_iconbitmap</vh></v>
</v>
<v t="ekr.20071028032929.1225"><vh>May 2002</vh>
<v t="ekr.20071028032929.1226"><vh>5/30/02 Move theory of operation sections back into this outline</vh></v>
<v t="ekr.20071028032929.1227"><vh>5/27/02 Undo move down doesn't always work</vh></v>
<v t="ekr.20071028032929.1228"><vh>5/27/02 Fixed bugs involving changing roots</vh></v>
<v t="ekr.20071028032929.1229"><vh>5/27/02 Handled unicode error in leoFileCommands::put</vh></v>
<v t="ekr.20071028032929.1230"><vh>5/13/02 LeoPy.leo corrupted</vh></v>
</v>
<v t="ekr.20071028032929.1231"><vh>April 2002</vh>
<v t="ekr.20071028032929.1232"><vh>4/27/02 Started Remove Sentinels command</vh></v>
<v t="ekr.20071028032929.1233"><vh>4/27/02 Changes to Export Noweb command</vh></v>
<v t="ekr.20071028032929.1234"><vh>4/25/02 Added code to os()</vh></v>
<v t="ekr.20071028032929.1235"><vh>4/7/02 Added frame.outlineToNowebDefaultFileName ivar</vh></v>
<v t="ekr.20071028032929.1236"><vh>4/7/02 Replaced &lt;&lt;*&gt;&gt;= with &lt;&lt;fileName&gt;&gt;= whenever possible</vh></v>
<v t="ekr.20071028032929.1237"><vh>4/7/02 Added code to make @ defs not start a doc part</vh></v>
<v t="ekr.20071028032929.1238"><vh>4/7/02 Added warnings for all non-undoable import commands</vh></v>
</v>
<v t="ekr.20071028032929.1239"><vh>March 2002</vh>
<v t="ekr.20071028032929.1240"><vh>3/16 Fixed moves up to root postion</vh></v>
<v t="ekr.20071028032929.1241"><vh>3/16 Simplified syntax colorer for docState</vh></v>
<v t="ekr.20071028032929.1242"><vh>3/10 Rewrote skipLeadingComments</vh></v>
<v t="ekr.20071028032929.1243"><vh>3/08 Modified colorer for CWEB</vh></v>
<v t="ekr.20071028032929.1244"><vh>3/07 Color strings green</vh></v>
<v t="ekr.20071028032929.1245"><vh>3/07 Rewrote importWebCommand and its allies</vh></v>
<v t="ekr.20071028032929.1246"><vh>3/06 Import/Export commands</vh>
<v t="ekr.20071028032929.1247"><vh>3/06 Outline To Noweb works (as well as it is going to)</vh></v>
<v t="ekr.20071028032929.1248"><vh>3/06 Flatten Outline and Import Flattened Outline work</vh></v>
<v t="ekr.20071028032929.1249"><vh>3/06 Python, C, Java and Pascal Imports now work</vh></v>
</v>
<v t="ekr.20071028032929.1250"><vh>3/05 Import commands, colorizer, clear IDLE breakpoints</vh>
<v t="ekr.20071028032929.1251"><vh>3/05 Import commands, colorizer</vh></v>
<v t="ekr.20071028032929.1252"><vh>3/05 Added ability to clear breakpoints in IDLE</vh></v>
</v>
<v t="ekr.20071028032929.1253"><vh>3/04 Released leo.py 2.0 and Borland v2.6</vh>
<v t="ekr.20071028032929.1254"><vh>3/04 Improved read error messages.</vh></v>
<v t="ekr.20071028032929.1255"><vh>3/04 Untangle calls v.trimTrailingLines only for changed nodes</vh></v>
<v t="ekr.20071028032929.1256"><vh>3/04 changed v.setBodyStringOrPane</vh></v>
<v t="ekr.20071028032929.1257"><vh>3/04 Added finished messages for Tangle/Untangle</vh></v>
</v>
<v t="ekr.20071028032929.1258"><vh>3/03 Fixed Untangle, </vh>
<v t="ekr.20071028032929.1259"><vh>3/03 Created readme files</vh></v>
<v t="ekr.20071028032929.1260"><vh>3/03 Fixed Untangle bug</vh></v>
</v>
<v t="ekr.20071028032929.1261"><vh>3/02 Finished Undo, Preparing for release</vh>
<v t="ekr.20071028032929.1262"><vh>3/02 Created distutils files to distribute Borland Leo</vh></v>
<v t="ekr.20071028032929.1263"><vh>3/02 Created release notes for Borland v2.6</vh></v>
<v t="ekr.20071028032929.1264"><vh>3/02 Documented new commands and features</vh></v>
<v t="ekr.20071028032929.1265"><vh>3/02 Fixed all pychecker complaints against leoImport.py</vh></v>
<v t="ekr.20071028032929.1266"><vh>3/02 Added @space to Utils &amp; Tangle/Untangle code in LeoCB</vh></v>
<v t="ekr.20071028032929.1267"><vh>3/02 Completed Undo Change All</vh></v>
</v>
<v t="ekr.20071028032929.1268"><vh>3/01 Finished Tangle, Finished v2.6, etc.</vh>
<v t="ekr.20071028032929.1269"><vh>3/01 Completely supress all auto-indent in @nocolor mode</vh></v>
<v t="ekr.20071028032929.1270"><vh>3/01 Tangle now works exactly like LeoCB Tangle</vh></v>
<v t="ekr.20071028032929.1271"><vh>3/01 Finished Borland version 2.6</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1272"><vh>Feb 2002</vh>
<v t="ekr.20071028032929.1273"><vh>2/28 Small fixes</vh>
<v t="ekr.20071028032929.1274"><vh>Tangle now treats @c like @code</vh></v>
<v t="ekr.20071028032929.1275"><vh>Changed is_special_bits</vh></v>
<v t="ekr.20071028032929.1276"><vh>Installed Johansson patches</vh></v>
</v>
<v t="ekr.20071028032929.1277"><vh>2/27 pychecker(!), colorizer bug</vh>
<v t="ekr.20071028032929.1278"><vh>2/27 Fixed bug in colorizer</vh></v>
<v t="ekr.20071028032929.1279"><vh>2/27 Discovered pychecker (several bug fixes)</vh>
<v t="ekr.20071028032929.1280"><vh>Fixed bug in Mark Changed Roots</vh></v>
<v t="ekr.20071028032929.1281"><vh>Fixed bug in scanText related to @delims sentinel</vh></v>
<v t="ekr.20071028032929.1282"><vh>Fixed bug in write</vh></v>
<v t="ekr.20071028032929.1283"><vh>Fixed bugs in leoFileCommands</vh></v>
<v t="ekr.20071028032929.1284"><vh>Fixed bugs in leoNodes</vh></v>
<v t="ekr.20071028032929.1285"><vh>Fixed bugs in leoTangle</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1286"><vh>2/26 LeoCB can read compressed derived files</vh></v>
<v t="ekr.20071028032929.1287"><vh>2/25 Fixed IDLE, added verbatimAfterRef sentinel</vh>
<v t="ekr.20071028032929.1288"><vh>2/25 Fixed breakpoints in IDLE</vh></v>
<v t="ekr.20071028032929.1289"><vh>2/25 Added verbatimAfterRef sentinel</vh></v>
</v>
<v t="ekr.20071028032929.1290"><vh>2/24 suppressing newlines</vh></v>
<v t="ekr.20071028032929.1291"><vh>2/23 Untangle, colorizer bug</vh>
<v t="ekr.20071028032929.1292"><vh>2/23 Debugging untangle: fixed leading single-comments bug</vh></v>
<v t="ekr.20071028032929.1293"><vh>2/23 Fixed small colorizing bug</vh></v>
</v>
<v t="ekr.20071028032929.1294"><vh>2/22 askOKCancel dialog, suppressing auto-indent.</vh>
<v t="ekr.20071028032929.1295"><vh>2/22 Created askOkCancel dialog for Read @file Nodes</vh></v>
<v t="ekr.20071028032929.1296"><vh>2/22 Supressed auto-indent in @nocolor mode.</vh></v>
</v>
<v t="ekr.20071028032929.1297"><vh>2/20 and 2/21 Debugged Untangle</vh></v>
<v t="ekr.20071028032929.1298"><vh>2/19 Improved Unlimited Undo</vh></v>
<v t="ekr.20071028032929.1299"><vh>2/18 Unlimited Undo works</vh></v>
<v t="ekr.20071028032929.1300"><vh>2/16 Syntax coloring</vh>
<v t="ekr.20071028032929.1301"><vh>2/16 Fixed bugs in colorAnyLanguage</vh></v>
<v t="ekr.20071028032929.1302"><vh>2/16 Finished adding keywords for colorAnyLanguage</vh></v>
</v>
<v t="ekr.20071028032929.1303"><vh>2/15 Syntax coloring, undo, @space bug</vh>
<v t="ekr.20071028032929.1304"><vh>02/15 Created colorAnyLanguage</vh></v>
<v t="ekr.20071028032929.1305"><vh>02/15 Fixed @space bug</vh></v>
<v t="ekr.20071028032929.1306"><vh>02/15 Bug fix: section definition lines now end coloring for doc parts</vh></v>
<v t="ekr.20071028032929.1307"><vh>02/15 Finished Limited undo.</vh></v>
<v t="ekr.20071028032929.1308"><vh>02/15 Added files to manifest</vh></v>
</v>
<v t="ekr.20071028032929.1309"><vh>02/14 CVS</vh>
<v t="ekr.20071028032929.1310"><vh>02/14 Fixed Undo problems</vh></v>
<v t="ekr.20071028032929.1311"><vh>02/14 Checked out Leo from CVS</vh></v>
<v t="ekr.20071028032929.1312"><vh>02/14 Cant mend clones, How to use CVS</vh>
<v t="ekr.20071028032929.1313"><vh>CVS: Making a virtue out of necessity</vh></v>
<v t="ekr.20071028032929.1314"><vh>Ooops: Leo can't mend clone links!</vh></v>
<v t="ekr.20071028032929.1315"><vh>Completed Mending dialog</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1316"><vh>02/13 Mending clone links, undo</vh>
<v t="ekr.20071028032929.1317"><vh>Made the undo class partly functional</vh></v>
<v t="ekr.20071028032929.1318"><vh>Created menu utilities</vh></v>
<v t="ekr.20071028032929.1319"><vh>Fixed bug in Extract and Extract Section commands</vh></v>
</v>
<v t="ekr.20071028032929.1320"><vh>02/12 Minor fixes</vh>
<v t="ekr.20071028032929.1321"><vh>Studied the DnD code</vh></v>
<v t="ekr.20071028032929.1322"><vh>Cleared tab and space tags in colorizePython</vh></v>
<v t="ekr.20071028032929.1323"><vh>Made headlines longer</vh></v>
<v t="ekr.20071028032929.1324"><vh>Cleaned code</vh></v>
</v>
<v t="ekr.20071028032929.1325"><vh>02/11 experiments</vh>
<v t="ekr.20071028032929.1326"><vh>created sortSequence utility</vh></v>
<v t="ekr.20071028032929.1327"><vh>experimented with inspect</vh></v>
</v>
<v t="ekr.20071028032929.1328"><vh>02/10 1.0 released</vh>
<v t="ekr.20071028032929.1329"><vh>Removed "from x import *" from reload_all() and OnOpenPythonWindow'</vh></v>
<v t="ekr.20071028032929.1330"><vh>Released 1.0</vh></v>
<v t="ekr.20071028032929.1331"><vh>Added Contract Parent (Alt-0)</vh></v>
<v t="ekr.20071028032929.1332"><vh>Fixed bugs in Prefs panel</vh></v>
</v>
<v t="ekr.20071028032929.1333"><vh>02/09 Preparing for release</vh>
<v t="ekr.20071028032929.1334"><vh>02/09 Got clean import of leoImport.py</vh></v>
<v t="ekr.20071028032929.1335"><vh>02/09 Created do-nothing leoUndo.py</vh></v>
<v t="ekr.20071028032929.1336"><vh>02/09 Updated current language properly in Prefs panel</vh></v>
<v t="ekr.20071028032929.1337"><vh>02/09 Re-marked @file nodes dirty on write errors</vh></v>
<v t="ekr.20071028032929.1338"><vh>02/09 Prefs Panel stick to current window</vh></v>
<v t="ekr.20071028032929.1339"><vh>02/09 Tangle passes full regression test</vh></v>
<v t="ekr.20071028032929.1340"><vh>02/09 Added Sort Siblings</vh></v>
</v>
<v t="ekr.20071028032929.1341"><vh>02/08 Regression testing</vh>
<v t="ekr.20071028032929.1342"><vh>02/08 Found Tangle problem</vh></v>
<v t="ekr.20071028032929.1343"><vh>02/08 Cleaned up leoCompare.py</vh></v>
<v t="ekr.20071028032929.1344"><vh>02/08 @c in Tangled files</vh></v>
<v t="ekr.20071028032929.1345"><vh>02/08 Testing wiped out files!</vh></v>
</v>
<v t="ekr.20071028032929.1346"><vh>02/07 New commands and bug fixes</vh>
<v t="ekr.20071028032929.1347"><vh>02/07 Possible reversion</vh></v>
<v t="ekr.20071028032929.1348"><vh>02/07 Converted Import Files code</vh></v>
<v t="ekr.20071028032929.1349"><vh>02/07 Search suboutline only now applies to Search/ChangeAll</vh></v>
<v t="ekr.20071028032929.1350"><vh>02/07 Fixed bug in search()</vh></v>
<v t="ekr.20071028032929.1351"><vh>02/07 Fixed bug: @others wasn't colored unless at left margin.</vh></v>
<v t="ekr.20071028032929.1352"><vh>02/07 * Added indent and undent commands</vh></v>
<v t="ekr.20071028032929.1353"><vh>02/07 * Improved idle_body_key</vh></v>
</v>
<v t="ekr.20071028032929.1354"><vh>02/06 Finished commands</vh>
<v t="ekr.20071028032929.1355"><vh>02/06 Rewrote and tested all Edit Body commands</vh></v>
<v t="ekr.20071028032929.1356"><vh>02/06 Rewrote and tested Convert Blanks command</vh></v>
<v t="ekr.20071028032929.1357"><vh>02/06 Removed Print and Page Setup commands</vh></v>
<v t="ekr.20071028032929.1358"><vh>02/06 * Implemented View All Characters</vh></v>
<v t="ekr.20071028032929.1359"><vh>02/06 Got the arrow binding right</vh></v>
<v t="ekr.20071028032929.1360"><vh>02/06 finished Delete command</vh></v>
<v t="ekr.20071028032929.1361"><vh>02/06 created tree.onBodyChanged</vh></v>
<v t="ekr.20071028032929.1362"><vh>02/06 rewrote and tested Revert</vh></v>
<v t="ekr.20071028032929.1363"><vh>02/06 created leoDialog.yesNo</vh></v>
</v>
<v t="ekr.20071028032929.1364"><vh>2/05 More bug fixes</vh>
<v t="ekr.20071028032929.1365"><vh>02/05 * Extended Sherlock</vh></v>
<v t="ekr.20071028032929.1366"><vh>02/05 * Properly enabled and disabled all menu items</vh></v>
<v t="ekr.20071028032929.1367"><vh>02/05 Got special accelerator keys working</vh></v>
<v t="ekr.20071028032929.1368"><vh>02/05 GoTo commands now working</vh></v>
<v t="ekr.20071028032929.1369"><vh>02/05 Got Alt-keys working</vh></v>
<v t="ekr.20071028032929.1370"><vh>02/05 Made es and trace safer during quit</vh></v>
<v t="ekr.20071028032929.1371"><vh>02/05 Fixed bugs in Search Headline and Find, Then Change</vh></v>
<v t="ekr.20071028032929.1372"><vh>02/05 Do not eliminate begin/endUpdate!</vh></v>
</v>
<v t="ekr.20071028032929.1373"><vh>02/04 Many bug fixes &amp; some big improvements</vh>
<v t="ekr.20071028032929.1374"><vh>02/04 Fixed Change command in headline</vh></v>
<v t="ekr.20071028032929.1375"><vh>02/04 A kludgy way to cut &amp; paste between Leo &amp; Leo.py</vh></v>
<v t="ekr.20071028032929.1376"><vh>02/04 Ended all event handlers with return "break"</vh></v>
<v t="ekr.20071028032929.1377"><vh>02/04 Changed Insert Node accelerator from Control-K to Control-I</vh></v>
<v t="ekr.20071028032929.1378"><vh>02/04 Implemented Toggle Active Pane</vh></v>
<v t="ekr.20071028032929.1379"><vh>02/04 ** Overrode default text keys</vh></v>
<v t="ekr.20071028032929.1380"><vh>02/04 Documented control characters used in the body pane.</vh></v>
<v t="ekr.20071028032929.1381"><vh>02/04 ** Breakthrough regarding events and accelerators</vh></v>
<v t="ekr.20071028032929.1382"><vh>02/04 Implemented Select All command</vh></v>
<v t="ekr.20071028032929.1383"><vh>02/04 created OnBodyDoubleClick and allies</vh></v>
<v t="ekr.20071028032929.1384"><vh>02/04 create setTextSelelection utility</vh></v>
<v t="ekr.20071028032929.1385"><vh>02/04 Created Sort command</vh></v>
<v t="ekr.20071028032929.1386"><vh>02/04 Fixed Tangle Marked and Tangle All commands</vh></v>
</v>
<v t="ekr.20071028032929.1387"><vh>02/03 Created shortcuts for opening LeoPy.leo</vh></v>
<v t="ekr.20071028032929.1388"><vh>02/03 Released 0.08</vh></v>
<v t="ekr.20071028032929.1389"><vh>02/02 Fixing Bugs</vh>
<v t="ekr.20071028032929.1390"><vh>02/02 Fixed bugs in outline-only and whole-word searches &amp; is_c_id</vh></v>
<v t="ekr.20071028032929.1391"><vh>02/02 ** Drawing breakthroughs</vh></v>
<v t="ekr.20071028032929.1392"><vh>02/02 Fixed control-d bug</vh></v>
<v t="ekr.20071028032929.1393"><vh>02/02 ** About redrawing</vh></v>
</v>
<v t="ekr.20071028032929.1394"><vh>02/01 Fixing bugs</vh>
<v t="ekr.20071028032929.1395"><vh>02/01 Test tangle path errors</vh></v>
<v t="ekr.20071028032929.1396"><vh>02/01 ** started tree.makeVisible &amp; tree.scrollTo</vh></v>
<v t="ekr.20071028032929.1397"><vh>02/01 ** used distutils</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1398"><vh>Jan 2002</vh>
<v t="ekr.20071028032929.1399"><vh>01/31 Preparing for release...</vh>
<v t="ekr.20071028032929.1400"><vh>** 01/31 leo.py now tangles better than LeoCB</vh></v>
<v t="ekr.20071028032929.1401"><vh>01/31 Created open script in leo.py</vh></v>
<v t="ekr.20071028032929.1402"><vh>01/31 Fixed suboutline only logic</vh></v>
<v t="ekr.20071028032929.1403"><vh>01/31 Tested directory logic</vh></v>
<v t="ekr.20071028032929.1404"><vh>01/31 replaced frame.defaultDirectory by c.tangle_directory</vh></v>
</v>
<v t="ekr.20071028032929.1405"><vh>01/30 Major improvements...</vh>
<v t="ekr.20071028032929.1406"><vh>01/30 ** May have solved the load path problem</vh></v>
<v t="ekr.20071028032929.1407"><vh>01/30 ** Rewrote path logic: removed all calls to os.chdir</vh></v>
<v t="ekr.20071028032929.1408"><vh>01/30 ** Fixed major bug causing @file read errors</vh></v>
<v t="ekr.20071028032929.1409"><vh>01/30 ** Changed how directories are handled</vh></v>
</v>
<v t="ekr.20071028032929.1410"><vh>01/29 Improved Paste Node command</vh></v>
<v t="ekr.20071028032929.1411"><vh>01/28 Generalized trace to allow function args</vh></v>
<v t="ekr.20071028032929.1412"><vh>01/28 Found source of Find performance bug</vh></v>
<v t="ekr.20071028032929.1413"><vh>01/25 Found one source of misreads</vh></v>
<v t="ekr.20071028032929.1414"><vh>01/24 Implemented Sherlock: init_trace and trace</vh></v>
<v t="ekr.20071028032929.1415"><vh>01/22 More work on leoTangle.py</vh></v>
<v t="ekr.20071028032929.1416"><vh>01/21 Started workon leoTangle.py</vh></v>
<v t="ekr.20071028032929.1417"><vh>01/20</vh>
<v t="ekr.20071028032929.1418"><vh>01/20 Lost clones into leoColor.py</vh></v>
<v t="ekr.20071028032929.1419"><vh>01/20 Implemented hyperlinks</vh></v>
</v>
<v t="ekr.20071028032929.1420"><vh>01/18 Completed Change all command</vh></v>
<v t="ekr.20071028032929.1421"><vh>01/17</vh>
<v t="ekr.20071028032929.1422"><vh>01/17 Breakthrough: tree.redraw_now</vh></v>
<v t="ekr.20071028032929.1423"><vh>01/17 much work on Find class</vh></v>
<v t="ekr.20071028032929.1424"><vh>01/17 v.edit_text defined only if v is visible</vh></v>
</v>
<v t="ekr.20071028032929.1425"><vh>01/16</vh>
<v t="ekr.20071028032929.1426"><vh>01/16 Fixed idle_headline logic</vh></v>
<v t="ekr.20071028032929.1427"><vh>01/16 Lost data in outline (not derived files)</vh></v>
<v t="ekr.20071028032929.1428"><vh>01/16 Fixed minor find/change bugs and removed batch checkbox</vh></v>
<v t="ekr.20071028032929.1429"><vh>01/16 Breakthrough re event handlers!</vh></v>
</v>
<v t="ekr.20071028032929.1430"><vh>01/15 Find/Change</vh>
<v t="ekr.20071028032929.1431"><vh>01/15 ** Completed find/change commands</vh></v>
<v t="ekr.20071028032929.1432"><vh>01/15 Converted headline from Tk.Entry to Tk.Text</vh></v>
</v>
<v t="ekr.20071028032929.1433"><vh>01/14</vh>
<v t="ekr.20071028032929.1434"><vh>01/14 Fixed bug: cancelling dialog wrote .leo</vh></v>
<v t="ekr.20071028032929.1435"><vh>01/14 Got basic Find commands to work</vh></v>
<v t="ekr.20071028032929.1436"><vh>01/14 Fixed Save To bug</vh></v>
<v t="ekr.20071028032929.1437"><vh>01/14 Added log messages for saves</vh></v>
<v t="ekr.20071028032929.1438"><vh>01/14 Always recompute file indices on saves</vh></v>
<v t="ekr.20071028032929.1439"><vh>01/14 Reduced width of log window</vh></v>
</v>
<v t="ekr.20071028032929.1440"><vh>01/13</vh>
<v t="ekr.20071028032929.1441"><vh>01/13 exec statement simplifies code</vh></v>
<v t="ekr.20071028032929.1442"><vh>01/13 Prefs/Find settings now functional</vh></v>
</v>
<v t="ekr.20071028032929.1443"><vh>01/11</vh>
<v t="ekr.20071028032929.1444"><vh>01/11 Replaced globals with app() ivars</vh></v>
<v t="ekr.20071028032929.1445"><vh>01/11 New memory management: created c/v/tree/frame destroy routines</vh></v>
<v t="ekr.20071028032929.1446"><vh>01/11 About destroy routines: eliminating circular references</vh></v>
<v t="ekr.20071028032929.1447"><vh>01/11 disabled c.setChanged while loading</vh></v>
<v t="ekr.20071028032929.1448"><vh>01/11 Eliminated ?? error message on exit</vh></v>
<v t="ekr.20071028032929.1449"><vh>01/11 created leoFrame.__del__</vh></v>
</v>
<v t="ekr.20071028032929.1450"><vh>01/10</vh>
<v t="ekr.20071028032929.1451"><vh>01/10 Worked on Quit error messages</vh></v>
<v t="ekr.20071028032929.1452"><vh>01/10 Released v 0.07</vh></v>
<v t="ekr.20071028032929.1453"><vh>01/10 Tested c2py on Borland</vh></v>
</v>
<v t="ekr.20071028032929.1454"><vh>01/09</vh>
<v t="ekr.20071028032929.1455"><vh>01/09 Wrote and debugged leo1to2 scripts !</vh></v>
<v t="ekr.20071028032929.1456"><vh>01/09 Made Python window functional !</vh></v>
<v t="ekr.20071028032929.1457"><vh>01/09 Added auto indent</vh></v>
</v>
<v t="ekr.20071028032929.1458"><vh>01/08</vh>
<v t="ekr.20071028032929.1459"><vh>01/08 bodyKeepsFocus logic</vh></v>
<v t="ekr.20071028032929.1460"><vh>01/08 Fixed bug: no doesn't abort a Quit command</vh></v>
<v t="ekr.20071028032929.1461"><vh>01/08 Fixed bug: changing clones didn't mark joined dirty.</vh></v>
<v t="ekr.20071028032929.1462"><vh>01/08 Got cut/copy/paste working</vh></v>
<v t="ekr.20071028032929.1463"><vh>01/08 Fixed reooloring problem</vh></v>
<v t="ekr.20071028032929.1464"><vh>01/08 Added Help-Leo Documentation command</vh></v>
<v t="ekr.20071028032929.1465"><vh>01/08 Save commands now ensure .leo extension</vh></v>
<v t="ekr.20071028032929.1466"><vh>01/08 Still no joy with canvas border</vh></v>
<v t="ekr.20071028032929.1467"><vh>01/08 Expermented with window icons</vh></v>
<v t="ekr.20071028032929.1468"><vh>01/08 Increased size of open windows</vh></v>
<v t="ekr.20071028032929.1469"><vh>01/08 Improved look of prefs panel</vh></v>
<v t="ekr.20071028032929.1470"><vh>01/08 Made progress towards "Show invisibles"</vh></v>
<v t="ekr.20071028032929.1471"><vh>01/08 @ignore now colored properly</vh></v>
<v t="ekr.20071028032929.1472"><vh>01/08 @color and @nocolor are now inherited</vh></v>
</v>
<v t="ekr.20071028032929.1473"><vh>01/07</vh>
<v t="ekr.20071028032929.1474"><vh>01/07 Fixed some bugs in Move Up and Move Down commands</vh></v>
<v t="ekr.20071028032929.1475"><vh>01/07 Fixed loss-of-data on insert command</vh></v>
<v t="ekr.20071028032929.1476"><vh>01/07 tab width</vh></v>
</v>
<v t="ekr.20071028032929.1477"><vh>01/06</vh>
<v t="ekr.20071028032929.1478"><vh>01/06 borders again</vh></v>
<v t="ekr.20071028032929.1479"><vh>01/06 editing and selecting</vh></v>
</v>
</v>
</v>
<v t="ekr.20071028032929.1480"><vh>2001</vh>
<v t="ekr.20071028032929.1481"><vh>Dec 2001</vh>
<v t="ekr.20071028032929.1482"><vh>12/20/01 Fixed Linux problems</vh></v>
<v t="ekr.20071028032929.1483"><vh>12/19/01 Improved LeoDocs.leo</vh></v>
<v t="ekr.20071028032929.1484"><vh>12/18/01 Improved Leo2 documentation</vh></v>
<v t="ekr.20071028032929.1485"><vh>12/17/01 ** Leo 0.05 released</vh></v>
<v t="ekr.20071028032929.1486"><vh>12/16/01 Found the source of the file mismatches</vh></v>
<v t="ekr.20071028032929.1487"><vh>12/16/01 Created directory compare routines</vh></v>
<v t="ekr.20071028032929.1488"><vh>12/15/01 Leo is operational</vh></v>
<v t="ekr.20071028032929.1489"><vh>12/15/01 Fixed bug in scanText</vh></v>
<v t="ekr.20071028032929.1490"><vh>12/15/01 Fixed bug in putBodyPart</vh></v>
<v t="ekr.20071028032929.1491"><vh>12/15/01 Fixed lookahead code in scanText, scanDoc</vh></v>
<v t="ekr.20071028032929.1492"><vh>12/14/01 Created leoCompare.py</vh></v>
<v t="ekr.20071028032929.1493"><vh>12/14/01 Create leoDialog.py</vh></v>
<v t="ekr.20071028032929.1494"><vh>12/14/01 Fixed minor problems</vh></v>
<v t="ekr.20071028032929.1495"><vh>12/13/01 Fixed several clone bugs</vh></v>
<v t="ekr.20071028032929.1496"><vh>12/13/01 Aha: we can eliminate v.setIcon !</vh></v>
<v t="ekr.20071028032929.1497"><vh>12/13/01 ** Fixed bottleneck with endupdate(flag)</vh></v>
<v t="ekr.20071028032929.1498"><vh>12/13/01 ** Syntax coloring now works</vh></v>
<v t="ekr.20071028032929.1499"><vh>12/12/01 Cut/copy/paste of nodes now done using internal clipboard</vh></v>
<v t="ekr.20071028032929.1500"><vh>12/12/01 Fixed insert, move, clone and delete commands</vh></v>
<v t="ekr.20071028032929.1501"><vh>12/12/01 Looked into Tk &amp; Python clipboard commands</vh></v>
<v t="ekr.20071028032929.1502"><vh>12/11/01 Menu accelerators</vh></v>
<v t="ekr.20071028032929.1503"><vh>12/11/01 Properly initialized the file in getLeoFile</vh></v>
<v t="ekr.20071028032929.1504"><vh>12/10/01 Got accellerators working</vh></v>
<v t="ekr.20071028032929.1505"><vh>12/10/01 Simplified icon handling, tree.redraw</vh></v>
<v t="ekr.20071028032929.1506"><vh>12/10/01 Used idle-time handler to work around event problems</vh></v>
<v t="ekr.20071028032929.1507"><vh>12/09/01 Problems with canvas border</vh></v>
<v t="ekr.20071028032929.1508"><vh>12/09/01 Tree now drawn properly</vh></v>
<v t="ekr.20071028032929.1509"><vh>12/08/01 Progress with selection</vh></v>
<v t="ekr.20071028032929.1510"><vh>12/07/01 Small improvements</vh></v>
<v t="ekr.20071028032929.1511"><vh>12/07/01 Tree now contains labels for editing</vh></v>
<v t="ekr.20071028032929.1512"><vh>12/06/01 Open/Close events now handled properly</vh></v>
<v t="ekr.20071028032929.1513"><vh>12/06/01 Tree drawn correctly, slowly</vh></v>
<v t="ekr.20071028032929.1514"><vh>12/04/01 Create .gif icons</vh></v>
<v t="ekr.20071028032929.1515"><vh>12/04/01 replaced dvnodes with vnodes!</vh></v>
<v t="ekr.20071028032929.1516"><vh>12/04/01 read code is now fast enough!</vh></v>
<v t="ekr.20071028032929.1517"><vh>12/04/01 tree starts to work</vh></v>
<v t="ekr.20071028032929.1518"><vh>12/01/01</vh></v>
</v>
<v t="ekr.20071028032929.1519"><vh>Nov 2001</vh>
<v t="ekr.20071028032929.1520"><vh>11/15/01 Created do-nothing tk app using Tkinter</vh></v>
<v t="ekr.20071028032929.1521"><vh>11/15/01 added -padx to log window</vh></v>
<v t="ekr.20071028032929.1522"><vh>11/13/01 Speeding up reads</vh></v>
<v t="ekr.20071028032929.1523"><vh>11/11/01 Design of tree class</vh></v>
<v t="ekr.20071028032929.1524"><vh>11/10/01 began conversion to tk</vh></v>
<v t="ekr.20071028032929.1525"><vh>11/10/01 es outputs newline</vh></v>
<v t="ekr.20071028032929.1526"><vh>11/10/01 fixed bug in putDocPart</vh></v>
<v t="ekr.20071028032929.1527"><vh>11/10/01 added code for @delims</vh></v>
<v t="ekr.20071028032929.1528"><vh>11/10/01 got @first working</vh></v>
<v t="ekr.20071028032929.1529"><vh>11/09/01 moved all globals into class</vh></v>
<v t="ekr.20071028032929.1530"><vh>11/09/01 fixed bugs in write logic</vh></v>
<v t="ekr.20071028032929.1531"><vh>11/09/01 fixed bugs read logic</vh></v>
<v t="ekr.20071028032929.1532"><vh>11/06/01 created Leo window using Tk</vh></v>
</v>
<v t="ekr.20071028032929.1533"><vh>Oct 2001</vh>
<v t="ekr.20071028032929.1534"><vh>11/01/01 Write code works except for comments</vh></v>
<v t="ekr.20071028032929.1535"><vh>10/31/01 Added Read/write submenu</vh></v>
<v t="ekr.20071028032929.1536"><vh>10/31/01 Fixed write code</vh></v>
<v t="ekr.20071028032929.1537"><vh>10/26/01 Read code is slow</vh></v>
<v t="ekr.20071028032929.1538"><vh>10/26/01 Read/write code now works</vh></v>
<v t="ekr.20071028032929.1539"><vh>10/11/01 Outline commands now work</vh></v>
<v t="ekr.20071028032929.1540"><vh>10/11/01 Removed redundant getters</vh></v>
<v t="ekr.20071028032929.1541"><vh>10/10/01 Debugged Commands, nodes, fileCommands</vh></v>
<v t="ekr.20071028032929.1542"><vh>10/08/01 design of leoFileCommands</vh></v>
<v t="ekr.20071028032929.1543"><vh>10/07/01 removed info and tagList classes</vh></v>
<v t="ekr.20071028032929.1544"><vh>10/05/01 c2py fixes, speedTest</vh></v>
<v t="ekr.20071028032929.1545"><vh>10/02/01 through 1/10/4</vh></v>
<v t="ekr.20071028032929.1546"><vh>10/01/01 fxed bugs in c2py</vh></v>
<v t="ekr.20071028032929.1547"><vh>10/01/01 c2py in leo</vh></v>
</v>
<v t="ekr.20071028032929.1548"><vh>Sept 2001</vh>
<v t="ekr.20071028032929.1549"><vh>9/30/01 documented c2py</vh></v>
<v t="ekr.20071028032929.1550"><vh>9/29/01 c2py.py</vh></v>
<v t="ekr.20071028032929.1551"><vh>9/25/01 Idle has trees &amp; syntax coloring</vh></v>
<v t="ekr.20071028032929.1552"><vh>9/14/01</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20061029091830"><vh>Leo 4.4.2 projects</vh>
<v t="ekr.20061029091751.1"><vh>Leo 4.4.2.1 final projects</vh>
<v t="ekr.20061029091751.2"><vh>Fixed bug reading recent files</vh>
<v t="ekr.20061029091751.3"><vh>appendToRecentFiles (g.app.config)</vh></v>
<v t="ekr.20061029091751.4"><vh>initSettingsFiles</vh></v>
<v t="ekr.20061029091751.5"><vh>g.app.config.readSettingsFiles</vh>
<v t="ekr.20061029091751.6"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
</v>
<v t="ekr.20061029091751.7"><vh>Reading and writing .leoRecentFiles.txt (g.app.config)</vh>
<v t="ekr.20061029091751.8"><vh>createRecentFiles</vh></v>
<v t="ekr.20061029091751.9"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20061029091751.10"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20061029091751.11"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20061029091811"><vh>Leo 4.4.2 final projects</vh>
<v t="ekr.20061029091811.1"><vh>Bugs</vh>
<v t="ekr.20061029091811.2"><vh>Changed leo_rst.css to pass the w3 validator</vh></v>
<v t="ekr.20061029091811.3"><vh>Fixed 'Run on string' message when typing ( with no @color in effect</vh>
<v t="ekr.20061029091811.4"><vh>skip_string</vh></v>
<v t="ekr.20061029091811.5"><vh>selfInsertCommand &amp; helpers</vh>
<v t="ekr.20061029091811.6"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20061029091811.7"><vh>test_selfInsertCommand</vh></v>
<v t="ekr.20061029091811.8"><vh>initBracketMatcher</vh></v>
<v t="ekr.20061029091811.9"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20061029091811.10"><vh>flashCharacter</vh></v>
<v t="ekr.20061029091811.11"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20061029091811.12"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20061029091811.13"><vh>updateTab</vh></v>
</v>
<v t="ekr.20061029091811.14"><vh>skip_matching_python_delims</vh></v>
</v>
<v t="ekr.20061029091811.15"><vh>Fixed problem with c++ extensions</vh>
<v t="ekr.20061029091811.16"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20061029091811.17"><vh>Move on if regexp matches an empty string</vh>
<v t="ekr.20061029091811.18"><vh>regexHelper</vh></v>
</v>
<v t="ekr.20061029091811.19"><vh>Fixed several bugs related to multiple body panes</vh>
<v t="ekr.20061029091811.20"><vh>selectEditor</vh>
<v t="ekr.20061029091811.21"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
<v t="ekr.20061029091811.22"><vh>masterClickHandler</vh></v>
<v t="ekr.20061029091811.23"><vh>onClick</vh></v>
<v t="ekr.20061029091811.24"><vh>tkBody.createTextWidget</vh></v>
</v>
<v t="ekr.20061029091811.25"><vh>Fixed multipath plugin so it works with new colorizier</vh>
<v t="ekr.20061029091811.26" a="M"><vh>directiveKind4 &amp; test</vh>
<v t="ekr.20061029091811.27"><vh>test_directiveKind4</vh></v>
</v>
<v t="ekr.20061029091811.28"><vh>&lt;&lt; define leo keywords &gt;&gt;</vh></v>
<v t="ekr.20061029091811.29"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="ekr.20061029091811.30"><vh>&lt;&lt; set theDict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20061029091811.31"><vh>&lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061029091811.32"><vh>Fixed bug in new colorizer</vh></v>
<v t="ekr.20061029091811.33"><vh>Fixed config bug</vh>
<v t="ekr.20061029091811.34"><vh>setInitialWindowGeometry</vh></v>
</v>
<v t="ekr.20061029091811.35"><vh>Investigated problems with leoRecentFiles.txt</vh>
<v t="ekr.20061029091811.36"><vh>Compute directories... (leoGlobals)</vh>
<v t="ekr.20061029091811.37"><vh>computeGlobalConfigDir</vh></v>
<v t="ekr.20061029091811.38"><vh>computeHomeDir</vh></v>
<v t="ekr.20061029091811.39"><vh>computeLeoDir</vh></v>
<v t="ekr.20061029091811.40"><vh>computeLoadDir</vh></v>
<v t="ekr.20061029091811.41"><vh>computeStandardDirectories</vh></v>
<v t="ekr.20061029091811.42"><vh>startupEncoding</vh></v>
</v>
<v t="ekr.20061029091811.43"><vh>Reading and writing .leoRecentFiles.txt (g.app.config)</vh>
<v t="ekr.20061029091811.44"><vh>createRecentFiles</vh></v>
<v t="ekr.20061029091811.45"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20061029091811.46"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20061029091811.47"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20061029091811.48"><vh>New features</vh>
<v t="ekr.20061029091811.49"><vh>Created leoPymacs.py for interaction with pymacs</vh></v>
<v t="ekr.20061029091811.50"><vh>Further improvements to leoPymacs</vh>
<v t="ekr.20061029091811.51"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20061029091811.52"><vh>app.newLeoCommanderAndFrame</vh>
<v t="ekr.20061029091811.53"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20061029091811.54"><vh>g.openWithFileName</vh></v>
<v t="ekr.20061029091811.55"><vh>run &amp; allies</vh>
<v t="ekr.20061029091811.56"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20061029091811.57"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20061029091811.58"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20061029091811.59"><vh>isValidPython</vh></v>
<v t="ekr.20061029091811.60"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20061029091811.51"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20061029091811.61"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20061029091811.62"><vh>getBatchScript</vh></v>
<v t="ekr.20061029091811.63"><vh>reportDirectories</vh></v>
</v>
</v>
<v t="ekr.20061029091811.64"><vh>Added forward-end-word/-extend-selection commands</vh>
<v t="ekr.20061029091811.65"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20061029091811.66"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20061029091811.67"><vh>words</vh></v>
<v t="ekr.20061029091811.68"><vh>moveWordHelper</vh></v>
<v t="ekr.20061029091811.69"><vh>runEditCommandTest</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014"><vh>4.4.2 b3 projects</vh>
<v t="ekr.20061021144014.1"><vh>Bugs</vh>
<v t="ekr.20061021144014.2"><vh>Fixed crash when searching for headllines containing unicode chars</vh>
<v t="ekr.20061021144014.3"><vh>&lt;&lt; init the gui-independent ivars &gt;&gt;</vh>
<v t="ekr.20061021144014.4"><vh>&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.5"><vh>findWord</vh></v>
<v t="ekr.20061021144014.6"><vh>findNextWord</vh></v>
</v>
<v t="ekr.20061021144014.7"><vh>Fixed failed unit test</vh>
<v t="ekr.20061021144014.8"><vh>k.initAbbrev</vh></v>
</v>
<v t="ekr.20061021144014.9"><vh>Fixed bugs in cycle-all-focus command</vh>
<v t="ekr.20061021144014.10"><vh>cycleFocus</vh></v>
<v t="ekr.20061021144014.11"><vh>cycleAllFocus</vh></v>
<v t="ekr.20061021144014.12"><vh>selectTab</vh></v>
<v t="ekr.20061021144014.13"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20061021144014.14"><vh>cycleTabFocus</vh></v>
<v t="ekr.20061021144014.15"><vh>callAltXFunction</vh></v>
<v t="ekr.20061021144014.16"><vh>endCommand</vh></v>
<v t="ekr.20061021144014.17"><vh>c.traceFocus</vh></v>
<v t="ekr.20061021144014.18"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20061021144014.19"><vh>masterKeyHandler</vh>
<v t="ekr.20061021144014.20"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20061021144014.21"><vh>&lt;&lt; do key traces &gt;&gt;</vh></v>
<v t="ekr.20061021144014.22"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20061021144014.23"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20061021144014.24"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20061021144014.25"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20061021144014.26"><vh>c.get/request/set_focus</vh></v>
</v>
<v t="ekr.20061021144014.27"><vh>Fixed bug: with Alt-n keys</vh>
<v t="ekr.20061021144014.28"><vh>k.registerCommand</vh></v>
<v t="ekr.20061021144014.29"><vh>makeMasterGuiBinding</vh></v>
<v t="ekr.20061021144014.30"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20061021144014.31"><vh>printBindings &amp; helper</vh>
<v t="ekr.20061021144014.32"><vh>printBindingsHelper</vh></v>
</v>
<v t="ekr.20061021144014.33"><vh>k.prettyPrintKey</vh></v>
</v>
<v t="ekr.20061021144014.34"><vh>Fix bug in ops plugin</vh></v>
<v t="ekr.20061021144014.35"><vh>Fixed crasher on script button balloons</vh></v>
<v t="ekr.20061021144014.36"><vh>Fix bug: closing a window after removing a script button can crash</vh></v>
<v t="ekr.20061021144014.37"><vh>The end-of-script message no longer yanks focus from tabs</vh>
<v t="ekr.20061021144014.38"><vh>c.executeScript</vh>
<v t="ekr.20061021144014.39"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20061021144014.40"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.41"><vh>Fixed  warning if minibuffer command does not exist when making menus</vh>
<v t="ekr.20061021144014.42"><vh>createMenuEntries</vh>
<v t="ekr.20061021144014.43"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20061021144014.44"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20061021144014.45"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.46"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.47"><vh>Fixed new unicode bug</vh>
<v t="ekr.20061021144014.48"><vh>Found: string.letters</vh>
<v t="ekr.20061021144014.5"><vh>findWord</vh></v>
<v t="ekr.20061021144014.6"><vh>findNextWord</vh></v>
<v t="ekr.20061021144014.49"><vh>insertNormalChar</vh></v>
<v t="ekr.20061021144014.50"><vh>doOp</vh></v>
<v t="ekr.20061021144014.51"><vh>appendToRegister</vh></v>
<v t="ekr.20061021144014.52"><vh>prependToRegister</vh></v>
<v t="ekr.20061021144014.53"><vh>copyRectangleToRegister</vh></v>
<v t="ekr.20061021144014.54"><vh>copyToRegister</vh></v>
<v t="ekr.20061021144014.55"><vh>incrementRegister</vh></v>
<v t="ekr.20061021144014.56"><vh>insertRegister</vh></v>
<v t="ekr.20061021144014.57"><vh>jumpToRegister</vh></v>
<v t="ekr.20061021144014.58"><vh>numberToRegister (not used)</vh></v>
<v t="ekr.20061021144014.59"><vh>pointToRegister</vh></v>
<v t="ekr.20061021144014.60"><vh>viewRegister</vh></v>
<v t="ekr.20061021144014.61"><vh>&lt;&lt; create press-buttonText-button command &gt;&gt;</vh></v>
<v t="ekr.20061021144014.62"><vh>recognizeStartOfTypingWord</vh></v>
<v t="ekr.20061021144014.63"><vh>createRecentFilesMenuItems (leoMenu)</vh></v>
</v>
<v t="ekr.20061021144014.64"><vh>Found: string.digits</vh>
<v t="ekr.20061021144014.65"><vh>zapToCharacter</vh></v>
<v t="ekr.20061021144014.66" a="M"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="ekr.20061021144014.67"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="ekr.20061021144014.68"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="ekr.20061021144014.69"><vh>skip_id</vh></v>
<v t="ekr.20061021144014.70"><vh>&lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;</vh></v>
<v t="ekr.20061021144014.71"><vh> ctor (editCommandsClass)</vh></v>
<v t="ekr.20061021144014.72"><vh>getDouble</vh></v>
<v t="ekr.20061021144014.73"><vh>getLong</vh></v>
<v t="ekr.20061021144014.74"><vh>is_c_id</vh></v>
<v t="ekr.20061021144014.75"><vh>match_word</vh></v>
<v t="ekr.20061021144014.76"><vh>skip_c_id</vh></v>
<v t="ekr.20061021144014.77"><vh>skip_id</vh></v>
<v t="ekr.20061021144014.78"><vh>skip_long</vh></v>
<v t="ekr.20061021144014.79"><vh>skipElispId</vh></v>
<v t="ekr.20061021144014.80"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20061021144014.81"><vh>universalDispatcher &amp; helpers</vh>
<v t="ekr.20061021144014.82"><vh>&lt;&lt; about repeat counts &gt;&gt;</vh></v>
<v t="ekr.20061021144014.83"><vh>executeNTimes</vh></v>
<v t="ekr.20061021144014.84"><vh>doControlU</vh></v>
</v>
<v t="ekr.20061021144014.85"><vh>scan_short_val</vh></v>
<v t="ekr.20061021144014.86"><vh>canonicalizeMenuName &amp; cononicalizeTranslatedMenuName</vh></v>
<v t="ekr.20061021144014.87"><vh>computeOldStyleShortcutKey</vh></v>
<v t="ekr.20061021144014.88"><vh>&lt;&lt; eliminate invalid characters &gt;&gt;</vh></v>
<v t="ekr.20061021144014.89"><vh>&lt;&lt; eliminate non-numbers &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.90"><vh>Found: string.</vh>
<v t="ekr.20061021144014.91" a="M"><vh>doNormalState</vh>
<v t="ekr.20061021144014.92"><vh>Valid regardless of latex mode</vh>
<v t="ekr.20061021144014.93"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="ekr.20061021144014.94"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="ekr.20061021144014.95"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="ekr.20061021144014.96"><vh>&lt;&lt; handle possible forth keyword &gt;&gt;</vh></v>
<v t="ekr.20061021144014.97"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.98"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="ekr.20061021144014.99"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
<v t="ekr.20061021144014.100"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.101"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="ekr.20061021144014.102"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="ekr.20061021144014.103"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.104"><vh>Vaid only in latex mode</vh>
<v t="ekr.20061021144014.105"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.106"><vh>Valid when not in latex_mode</vh>
<v t="ekr.20061021144014.107"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20061021144014.108"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="ekr.20061021144014.109"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20061021144014.110"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="ekr.20061021144014.111"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="ekr.20061021144014.112"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.113" a="M"><vh>getCwebWord</vh></v>
<v t="ekr.20061021144014.114" a="M"><vh>init_trace</vh></v>
<v t="ekr.20061021144014.115" a="M"><vh>sanitize_filename</vh></v>
<v t="ekr.20061021144014.116" a="M"><vh>&lt;&lt; set token_type for CWEB mode &gt;&gt;</vh></v>
<v t="ekr.20061021144014.117" a="M"><vh>&lt;&lt; define dispatch dicts &gt;&gt;</vh></v>
<v t="ekr.20061021144014.66" a="M"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="ekr.20061021144014.118" a="M"><vh>definePatterns</vh></v>
<v t="ekr.20061021144014.119" a="M"><vh>autoCompleterStateHandler</vh></v>
<v t="ekr.20061021144014.120" a="M"><vh>directiveKind4 &amp; test</vh>
<v t="ekr.20061021144014.121"><vh>test_directiveKind4</vh></v>
</v>
<v t="ekr.20061021144014.122" a="M"><vh>test_isPlainKey</vh></v>
</v>
</v>
<v t="ekr.20061021144014.123"><vh>Made 'About Plugin' dialog scrollable</vh></v>
<v t="ekr.20061021144014.124"><vh>Removed unwanted key-state message</vh></v>
<v t="ekr.20061021144014.125"><vh>Removed datenodes.ini from cvs</vh></v>
<v t="ekr.20061021144014.126"><vh>Made sure all kill commands do a full recolor</vh>
<v t="ekr.20061021144014.127"><vh>killBufferCommandsClass (add docstrings)</vh>
<v t="ekr.20061021144014.128"><vh> ctor &amp; finishCreate</vh></v>
<v t="ekr.20061021144014.129"><vh> getPublicCommands</vh></v>
<v t="ekr.20061021144014.130"><vh>addToKillBuffer</vh></v>
<v t="ekr.20061021144014.131"><vh>backwardKillSentence</vh></v>
<v t="ekr.20061021144014.132"><vh>backwardKillWord &amp; killWord</vh></v>
<v t="ekr.20061021144014.133"><vh>clearKillRing</vh></v>
<v t="ekr.20061021144014.134"><vh>getClipboard</vh></v>
<v t="ekr.20061021144014.135"><vh>iterateKillBuffer</vh></v>
<v t="ekr.20061021144014.136"><vh>kill, killLine</vh></v>
<v t="ekr.20061021144014.137"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
<v t="ekr.20061021144014.138"><vh>killSentence</vh></v>
<v t="ekr.20061021144014.139"><vh>killWs</vh></v>
<v t="ekr.20061021144014.140"><vh>yank</vh></v>
<v t="ekr.20061021144014.141"><vh>yankPop</vh></v>
<v t="ekr.20061021144014.65"><vh>zapToCharacter</vh></v>
</v>
<v t="ekr.20061021144014.142"><vh>begin/endCommand</vh>
<v t="ekr.20061021144014.143"><vh>beginCommand  &amp; beginCommandWithEvent</vh>
<v t="ekr.20061021144014.144"><vh>beingCommandHelper</vh></v>
</v>
<v t="ekr.20061021144014.145"><vh>endCommand</vh></v>
</v>
<v t="ekr.20061021144014.146"><vh>onBodyChanged (tkBody)</vh>
<v t="ekr.20061021144014.147"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20061021144014.148"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.149"><vh>Fixed bug in new colorizer</vh>
<v t="ekr.20061021144014.150"><vh>Edit Body submenu</vh>
<v t="ekr.20061021144014.151"><vh>convertAllBlanks</vh></v>
<v t="ekr.20061021144014.152"><vh>convertAllTabs</vh></v>
<v t="ekr.20061021144014.153"><vh>convertBlanks</vh></v>
<v t="ekr.20061021144014.154"><vh>convertTabs</vh></v>
<v t="ekr.20061021144014.155"><vh>createLastChildNode</vh></v>
<v t="ekr.20061021144014.156"><vh>dedentBody</vh></v>
<v t="ekr.20061021144014.157"><vh>extract</vh></v>
<v t="ekr.20061021144014.158"><vh>extractSection</vh>
<v t="ekr.20061021144014.159"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.160"><vh>extractSectionNames</vh>
<v t="ekr.20061021144014.161"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.162"><vh>findBoundParagraph</vh>
<v t="ekr.20061021144014.163"><vh>&lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.164"><vh>findMatchingBracket</vh>
<v t="ekr.20061021144014.165"><vh>findMatchingBracket</vh></v>
</v>
<v t="ekr.20061021144014.166"><vh>getBodyLines</vh></v>
<v t="ekr.20061021144014.167"><vh>indentBody</vh></v>
<v t="ekr.20061021144014.168"><vh>insertBodyTime &amp; allies</vh>
<v t="ekr.20061021144014.169"><vh>getTime &amp; test</vh></v>
</v>
<v t="ekr.20061021144014.170"><vh>insert/removeComments</vh>
<v t="ekr.20061021144014.171"><vh>addComments</vh></v>
<v t="ekr.20061021144014.172"><vh>deleteComments</vh></v>
</v>
<v t="ekr.20061021144014.173"><vh>reformatParagraph</vh>
<v t="ekr.20061021144014.174"><vh>&lt;&lt; compute vars for reformatParagraph &gt;&gt;</vh></v>
<v t="ekr.20061021144014.175"><vh>&lt;&lt; compute the leading whitespace &gt;&gt;</vh></v>
<v t="ekr.20061021144014.176"><vh>&lt;&lt; compute the result of wrapping all lines &gt;&gt;</vh></v>
<v t="ekr.20061021144014.177"><vh>&lt;&lt; update the body, selection &amp; undo state &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.178"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
</v>
<v t="ekr.20061021144014.178"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
<v t="ekr.20061021144014.146"><vh>onBodyChanged (tkBody)</vh>
<v t="ekr.20061021144014.147"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20061021144014.148"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.179"><vh>setSelection</vh></v>
</v>
<v t="ekr.20061021144014.180"><vh>Removed set-mark-command and all calls to removeRKeys</vh>
<v t="ekr.20061021144014.181"><vh>Found: removeRKeys</vh>
<v t="ekr.20061021144014.137"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
<v t="ekr.20061021144014.182"><vh>testinrange</vh></v>
<v t="ekr.20061021144014.183"><vh>indentRegion (not used: use c.indentBody instead)</vh></v>
<v t="ekr.20061021144014.184"><vh>up/downCaseRegion &amp; helper</vh></v>
</v>
</v>
<v t="ekr.20061021144014.185"><vh>Fixed body editor problems</vh>
<v t="ekr.20061021144014.186"><vh>masterClickHandler</vh></v>
<v t="ekr.20061021144014.11"><vh>cycleAllFocus</vh></v>
<v t="ekr.20061021144014.187"><vh>class leoTkinterBody</vh>
<v t="ekr.20061021144014.188"><vh> Birth &amp; death</vh>
<v t="ekr.20061021144014.189"><vh>tkBody. __init__</vh></v>
<v t="ekr.20061021144014.190"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20061021144014.191"><vh>tkBody.createControl</vh></v>
<v t="ekr.20061021144014.192"><vh>tkBody.createTextWidget</vh></v>
</v>
<v t="ekr.20061021144014.193"><vh>Editors</vh>
<v t="ekr.20061021144014.194"><vh>recolorWidget</vh></v>
<v t="ekr.20061021144014.195"><vh>create/select/unselect/Label</vh></v>
<v t="ekr.20061021144014.196"><vh>addEditor</vh>
<v t="ekr.20061021144014.197"><vh>&lt;&lt; create label and text widgets &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.198"><vh>setEditorColors</vh></v>
<v t="ekr.20061021144014.13"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20061021144014.199"><vh>deleteEditor</vh></v>
<v t="ekr.20061021144014.200"><vh>onClick</vh></v>
<v t="ekr.20061021144014.201"><vh>selectEditor</vh>
<v t="ekr.20061021144014.202"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.203"><vh>selectMainEditor</vh></v>
<v t="ekr.20061021144014.204"><vh>updateEditors</vh></v>
</v>
<v t="ekr.20061021144014.205"><vh>tkBody.setColorFromConfig</vh></v>
<v t="ekr.20061021144014.206"><vh>tkBody.setFontFromConfig</vh></v>
<v t="ekr.20061021144014.146"><vh>onBodyChanged (tkBody)</vh>
<v t="ekr.20061021144014.147"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20061021144014.148"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.207"><vh>Focus (tkBody)</vh></v>
<v t="ekr.20061021144014.208"><vh>forceRecolor</vh></v>
<v t="ekr.20061021144014.209"><vh>Tk bindings (tkBbody)</vh>
<v t="ekr.20061021144014.210"><vh>Bounding box (Tk spelling)</vh></v>
<v t="ekr.20061021144014.211"><vh>Color tags (Tk spelling)</vh></v>
<v t="ekr.20061021144014.212"><vh>Configuration (Tk spelling)</vh></v>
<v t="ekr.20061021144014.213"><vh>Height &amp; width</vh></v>
<v t="ekr.20061021144014.214"><vh>Idle time...</vh></v>
<v t="ekr.20061021144014.215"><vh>Indices (leoTkinterBody)</vh>
<v t="ekr.20061021144014.216"><vh>adjustIndex</vh></v>
<v t="ekr.20061021144014.217"><vh>compareIndices</vh></v>
<v t="ekr.20061021144014.218"><vh>convertRowColumnToIndex</vh></v>
<v t="ekr.20061021144014.219"><vh>convertIndexToRowColumn</vh></v>
<v t="ekr.20061021144014.220"><vh>getImageIndex</vh></v>
<v t="ekr.20061021144014.221"><vh>tkIndex (internal use only)</vh></v>
</v>
<v t="ekr.20061021144014.222"><vh>Insert point</vh>
<v t="ekr.20061021144014.223"><vh>get/setPythonInsertionPoint</vh></v>
<v t="ekr.20061021144014.224"><vh>getInsertionPoint &amp; getBeforeInsertionPoint</vh></v>
<v t="ekr.20061021144014.225"><vh>getCharAtInsertPoint &amp; getCharBeforeInsertPoint</vh></v>
<v t="ekr.20061021144014.226"><vh>makeInsertPointVisible</vh></v>
<v t="ekr.20061021144014.227"><vh>setInsertionPointTo...</vh></v>
</v>
<v t="ekr.20061021144014.228"><vh>Menus</vh></v>
<v t="ekr.20061021144014.229"><vh>Selection</vh>
<v t="ekr.20061021144014.230"><vh>deleteTextSelection</vh></v>
<v t="ekr.20061021144014.231"><vh>getSelectedText</vh></v>
<v t="ekr.20061021144014.232"><vh>getTextSelection</vh></v>
<v t="ekr.20061021144014.233"><vh>getPythonTextSelection</vh></v>
<v t="ekr.20061021144014.234"><vh>setPythonTextSelection</vh></v>
<v t="ekr.20061021144014.235"><vh>hasTextSelection</vh></v>
<v t="ekr.20061021144014.236"><vh>selectAllText</vh></v>
<v t="ekr.20061021144014.237"><vh>setTextSelection (tkinterBody)</vh></v>
</v>
<v t="ekr.20061021144014.238"><vh>Text</vh>
<v t="ekr.20061021144014.239"><vh>delete...</vh></v>
<v t="ekr.20061021144014.240"><vh>get...</vh>
<v t="ekr.20061021144014.241"><vh>tkBody.getAllText</vh></v>
<v t="ekr.20061021144014.242"><vh>getCharAtIndex</vh></v>
<v t="ekr.20061021144014.243"><vh>getInsertLines</vh></v>
<v t="ekr.20061021144014.244"><vh>getSelectionAreas</vh></v>
<v t="ekr.20061021144014.245"><vh>getSelectionLines (tkBody)</vh></v>
<v t="ekr.20061021144014.246"><vh>getTextRange</vh></v>
</v>
<v t="ekr.20061021144014.247"><vh>Insert...</vh>
<v t="ekr.20061021144014.248"><vh>insertAtInsertPoint</vh></v>
<v t="ekr.20061021144014.249"><vh>insertAtEnd</vh></v>
<v t="ekr.20061021144014.250"><vh>insertAtStartOfLine</vh></v>
</v>
<v t="ekr.20061021144014.251"><vh>setSelectionAreas (tkinterBody)</vh></v>
</v>
<v t="ekr.20061021144014.252"><vh>Visibility &amp; scrolling</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014.253"><vh>Fixed rst3 crash</vh></v>
<v t="ekr.20061021144014.254"><vh>Moved @import to top of doc/default.css</vh></v>
<v t="ekr.20061021144014.255"><vh>Fixed focus problem when double-clicking @url nodes</vh>
<v t="ekr.20061021144014.256"><vh>@url file:c:/prog/tigris-cvs/leo/doc/leoDocs.leo#Users Guide</vh></v>
<v t="ekr.20061021144014.257"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="ekr.20061021144014.258"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="ekr.20061021144014.259"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="ekr.20061021144014.260"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.261"><vh>onTreeClick</vh></v>
<v t="ekr.20061021144014.262"><vh>set_focus (app.gui)</vh></v>
</v>
</v>
<v t="ekr.20061021144014.263"><vh>Features</vh>
<v t="ekr.20061021144014.264"><vh>Removed .leoRecentFiles.txt from distribution and cvs</vh>
<v t="ekr.20061021144014.265"><vh>ctor (configClass)</vh></v>
<v t="ekr.20061021144014.266"><vh>g.app.config.readSettingsFiles</vh></v>
<v t="ekr.20061021144014.267"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20061021144014.268"><vh>createRecentFiles</vh></v>
<v t="ekr.20061021144014.269"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20061021144014.270"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
<v t="ekr.20061021144014.271"><vh>Added minibuffer and Settings menus</vh>
<v t="ekr.20061021144014.272"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.273"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20061021144014.274"><vh>defineCmdsMenuBodyEditorsTable</vh></v>
<v t="ekr.20061021144014.275"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20061021144014.276"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20061021144014.277"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20061021144014.278"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20061021144014.279"><vh>defineCmdsMenuMinibufferTable</vh></v>
<v t="ekr.20061021144014.280"><vh>defineCmdsMenuPanesTable</vh></v>
<v t="ekr.20061021144014.281"><vh>defineCmdsMenuPickersTable</vh></v>
<v t="ekr.20061021144014.282"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20061021144014.283"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20061021144014.284"><vh>defineCmdsMenuScrollTable</vh></v>
<v t="ekr.20061021144014.285"><vh>defineCmdsMenuSpellCheckTable</vh></v>
<v t="ekr.20061021144014.286"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20061021144014.287"><vh>defineCmdsMenuToggleTable</vh></v>
</v>
<v t="ekr.20061021144014.288" a="M"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20061021144014.289"><vh>defineHelpMenuTables</vh></v>
</v>
<v t="ekr.20061021144014.290"><vh>Created do-nothing command and tested binding to unicode character</vh>
<v t="ekr.20061021144014.291"><vh>doNothing</vh></v>
</v>
<v t="ekr.20061021144014.292"><vh>Toggling autocompleter and calltips now write to log (in red) instead of the statusLine</vh>
<v t="ekr.20061021144014.293"><vh>showAutocompleter/CalltipsStatus</vh></v>
</v>
<v t="ekr.20061021144014.294"><vh>Finished collapse-on-move-left</vh>
<v t="ekr.20061021144014.295"><vh>Move... (Commands)</vh>
<v t="ekr.20061021144014.296"><vh>demote</vh></v>
<v t="ekr.20061021144014.297"><vh>moveOutlineDown</vh>
<v t="ekr.20061021144014.298"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.299"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20061021144014.300"><vh>moveOutlineRight</vh></v>
<v t="ekr.20061021144014.301"><vh>moveOutlineUp</vh>
<v t="ekr.20061021144014.302"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.303"><vh>promote</vh></v>
</v>
</v>
<v t="ekr.20061021144014.304"><vh>Properly create Help menu on the Mac</vh>
<v t="ekr.20061021144014.305" a="M"><vh>createHelpMenuFromTable</vh></v>
<v t="ekr.20061021144014.306" a="M"><vh>getMacHelpMenu</vh></v>
</v>
<v t="ekr.20061021144014.307"><vh>'*command-name' in headline means convert '-' to blanks</vh></v>
<v t="ekr.20061021144014.308"><vh>Removed all references to commands from menu tables</vh>
<v t="ekr.20061021144014.309"><vh>regexp</vh></v>
<v t="ekr.20061021144014.310"><vh>capitalizeMinibufferMenuName</vh></v>
<v t="ekr.20061021144014.42"><vh>createMenuEntries</vh>
<v t="ekr.20061021144014.43"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20061021144014.44"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20061021144014.45"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.46"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.311"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.312"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.313"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20061021144014.314"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20061021144014.315"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20061021144014.316"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20061021144014.317"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20061021144014.318"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.319"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20061021144014.320"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20061021144014.321"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20061021144014.322"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20061021144014.323"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20061021144014.324"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20061021144014.325"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20061021144014.326"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20061021144014.327"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.328"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20061021144014.329"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20061021144014.330"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20061021144014.331"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20061021144014.332"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20061021144014.333"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20061021144014.272"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.273"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20061021144014.274"><vh>defineCmdsMenuBodyEditorsTable</vh></v>
<v t="ekr.20061021144014.275"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20061021144014.276"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20061021144014.277"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20061021144014.278"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20061021144014.279"><vh>defineCmdsMenuMinibufferTable</vh></v>
<v t="ekr.20061021144014.280"><vh>defineCmdsMenuPanesTable</vh></v>
<v t="ekr.20061021144014.281"><vh>defineCmdsMenuPickersTable</vh></v>
<v t="ekr.20061021144014.282"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20061021144014.283"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20061021144014.284"><vh>defineCmdsMenuScrollTable</vh></v>
<v t="ekr.20061021144014.285"><vh>defineCmdsMenuSpellCheckTable</vh></v>
<v t="ekr.20061021144014.286"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20061021144014.287"><vh>defineCmdsMenuToggleTable</vh></v>
</v>
<v t="ekr.20061021144014.334"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20061021144014.289"><vh>defineHelpMenuTables</vh></v>
</v>
</v>
<v t="ekr.20061021144014.335"><vh>Add Open scripts.leo to help menu</vh>
<v t="ekr.20061021144014.336"><vh>openLeoScripts</vh></v>
<v t="ekr.20061021144014.289"><vh>defineHelpMenuTables</vh></v>
</v>
<v t="ekr.20061021144014.337"><vh>The spell tab now uses ctypes for Python 2.5</vh>
<v t="ekr.20061021144014.338"><vh>Spell classes</vh>
<v t="ekr.20061021144014.339"><vh>class spellCommandsClass</vh>
<v t="ekr.20061021144014.340"><vh>ctor</vh></v>
<v t="ekr.20061021144014.341"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20061021144014.342"><vh>openSpellTab</vh></v>
<v t="ekr.20061021144014.343"><vh>commands...</vh></v>
</v>
<v t="ekr.20061021144014.344"><vh>class spellTab (leoFind.leoFind)</vh>
<v t="ekr.20061021144014.345"><vh>Birth &amp; death</vh>
<v t="ekr.20061021144014.346"><vh>spellTab.__init__</vh></v>
<v t="ekr.20061021144014.347"><vh>init_aspell</vh></v>
<v t="ekr.20061021144014.348"><vh>createSpellTab</vh>
<v t="ekr.20061021144014.349"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20061021144014.350"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20061021144014.351"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.352"><vh>createBindings (spellTab)</vh></v>
<v t="ekr.20061021144014.353"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20061021144014.354"><vh>Buttons</vh>
<v t="ekr.20061021144014.355"><vh>onAddButton</vh></v>
<v t="ekr.20061021144014.356"><vh>onIgnoreButton</vh></v>
<v t="ekr.20061021144014.357"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20061021144014.358"><vh>onFindButton</vh></v>
<v t="ekr.20061021144014.359"><vh>onHideButton</vh></v>
</v>
<v t="ekr.20061021144014.360"><vh>Commands</vh>
<v t="ekr.20061021144014.361"><vh>add</vh></v>
<v t="ekr.20061021144014.362"><vh>change</vh></v>
<v t="ekr.20061021144014.363"><vh>find</vh></v>
<v t="ekr.20061021144014.364"><vh>hide</vh></v>
<v t="ekr.20061021144014.365"><vh>ignore</vh></v>
</v>
<v t="ekr.20061021144014.366"><vh>Helpers</vh>
<v t="ekr.20061021144014.367"><vh>bringToFront</vh></v>
<v t="ekr.20061021144014.368"><vh>fillbox</vh></v>
<v t="ekr.20061021144014.369"><vh>findNextMisspelledWord</vh>
<v t="ekr.20061021144014.370"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.6"><vh>findNextWord</vh></v>
<v t="ekr.20061021144014.371"><vh>getSuggestion</vh></v>
<v t="ekr.20061021144014.372"><vh>onMap</vh></v>
<v t="ekr.20061021144014.373"><vh>onSelectListBox</vh></v>
<v t="ekr.20061021144014.374"><vh>update</vh></v>
<v t="ekr.20061021144014.375"><vh>updateButtons</vh></v>
</v>
</v>
<v t="ekr.20061021144014.376"><vh>class AspellClass</vh>
<v t="ekr.20061021144014.377"><vh>Birth &amp; death</vh>
<v t="ekr.20061021144014.378"><vh>__init__</vh></v>
<v t="ekr.20061021144014.379"><vh>getAspell</vh></v>
<v t="ekr.20061021144014.380"><vh>getAspellWithCtypes</vh>
<v t="ekr.20061021144014.381"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.382"><vh>processWord</vh></v>
<v t="ekr.20061021144014.383"><vh>suggestions</vh></v>
<v t="ekr.20061021144014.384"><vh>updateDictionary</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014.385"><vh>Simulated x-windows middle-button paste</vh>
<v t="ekr.20061021144014.386"><vh>Request</vh></v>
<v t="ekr.20061021144014.387"><vh>Fix new middle-button problem</vh></v>
<v t="ekr.20061021144014.42"><vh>createMenuEntries</vh>
<v t="ekr.20061021144014.43"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20061021144014.44"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20061021144014.45"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.46"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.190"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20061021144014.388"><vh>OnPaste (To support middle-button paste)</vh></v>
<v t="ekr.20061021144014.186"><vh>masterClickHandler</vh></v>
<v t="ekr.20061021144014.389"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20061021144014.390"><vh>copyText</vh></v>
<v t="ekr.20061021144014.391"><vh>cutText</vh></v>
<v t="ekr.20061021144014.392"><vh>pasteText</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014.393"><vh>Plugins</vh>
<v t="ekr.20061021144014.394"><vh>Fixed keyBindings plugin</vh></v>
<v t="ekr.20061021144014.395"><vh>The scripting plugin now creates a delete-x-script-button command for each script button</vh></v>
<v t="ekr.20061021144014.396"><vh>Fixed (sorta) the nodenavigator plugin</vh></v>
<v t="ekr.20061021144014.397"><vh>Rewrote the multifile plugin for the 4.x code base.</vh></v>
<v t="ekr.20061021144014.398"><vh>Replaced __name__ with __plugin_name__ in four plugins</vh></v>
<v t="ekr.20061021144014.399"><vh>Improved the scripting plugin</vh></v>
<v t="ekr.20061021144014.400"><vh>Fixed bugs in multi-file plugin</vh></v>
<v t="ekr.20061021144014.401"><vh>More work on multifile plugin</vh></v>
<v t="ekr.20061021144014.402"><vh>Fix bug in shortcut_button plugin</vh></v>
</v>
<v t="ekr.20061021144014.403"><vh>Settings</vh>
<v t="ekr.20061021144014.404"><vh>Made unlimited undo the default</vh></v>
<v t="ekr.20061021144014.405"><vh>Added @bool select_all_text_when_editing_headlines</vh>
<v t="ekr.20061021144014.406"><vh>setEditLabelState</vh></v>
<v t="ekr.20061021144014.407"><vh>editLabel</vh></v>
<v t="ekr.20061021144014.408"><vh>c.insertHeadline</vh></v>
<v t="ekr.20061021144014.409"><vh>c.editPosition</vh></v>
</v>
<v t="ekr.20061021144014.410"><vh>Added bindings to toggle-autocompleter and toggle-calltips</vh></v>
<v t="ekr.20061021144014.411"><vh>Added 'Candidates for myLeoSettings.leo' to leoSettings.leo</vh></v>
<v t="ekr.20061021144014.412"><vh>Recent changes to settings</vh></v>
<v t="ekr.20061021144014.413"><vh>Added @boo insert_new_nodes_at_end</vh>
<v t="ekr.20061021144014.408"><vh>c.insertHeadline</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070626112754.2"><vh>Leo 4.4.3 projects</vh>
<v t="ekr.20070626112754.3"><vh>Leo 4.4.3 alpha 1 projects</vh>
<v t="ekr.20070626112754.4"><vh>Bugs</vh>
<v t="ekr.20070626112754.5"><vh>Fixed an escape bug in new colorizer</vh></v>
<v t="ekr.20070626112754.6"><vh>Fixed new autocompletion bugs</vh></v>
<v t="ekr.20070626112754.7"><vh>Treat escaped characters in find patterns as a single character</vh>
<v t="ekr.20070626112754.8"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20070626112754.9"><vh>regexHelper</vh></v>
<v t="ekr.20070626112754.10"><vh>backwardsHelper</vh></v>
<v t="ekr.20070626112754.11"><vh>plainHelper</vh></v>
<v t="ekr.20070626112754.12"><vh>matchWord</vh></v>
<v t="ekr.20070626112754.13"><vh>replaceBackSlashes</vh></v>
</v>
<v t="ekr.20070626112754.14"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20070626112754.15"><vh>Fixed undo problems with yank/kill</vh>
<v t="ekr.20070626112754.16"><vh>Notes</vh></v>
<v t="ekr.20070626112754.17"><vh>How to reproduce undo bug</vh></v>
<v t="ekr.20070626112754.18"><vh>killBufferCommandsClass (add docstrings)</vh>
<v t="ekr.20070626112754.19"><vh> ctor &amp; finishCreate</vh></v>
<v t="ekr.20070626112754.20"><vh> getPublicCommands</vh></v>
<v t="ekr.20070626112754.21"><vh>addToKillBuffer</vh></v>
<v t="ekr.20070626112754.22"><vh>backwardKillSentence</vh></v>
<v t="ekr.20070626112754.23"><vh>backwardKillWord &amp; killWord</vh></v>
<v t="ekr.20070626112754.24"><vh>clearKillRing</vh></v>
<v t="ekr.20070626112754.25"><vh>getClipboard</vh></v>
<v t="ekr.20070626112754.26"><vh>iterateKillBuffer</vh></v>
<v t="ekr.20070626112754.27"><vh>kill, killLine</vh></v>
<v t="ekr.20070626112754.28"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
<v t="ekr.20070626112754.29"><vh>killSentence</vh></v>
<v t="ekr.20070626112754.30"><vh>killWs</vh></v>
<v t="ekr.20070626112754.31"><vh>yank</vh></v>
<v t="ekr.20070626112754.32"><vh>yankPop</vh></v>
<v t="ekr.20070626112754.33"><vh>zapToCharacter</vh></v>
</v>
<v t="ekr.20070626112754.34"><vh>undoTyping</vh></v>
<v t="ekr.20070626112754.35"><vh>redoTyping</vh></v>
<v t="ekr.20070626112754.36"><vh>undoRedoText (passed)</vh>
<v t="ekr.20070626112754.37"><vh>&lt;&lt; Compute the result using p's body text &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.38"><vh>Fixed clone-drag problem</vh>
<v t="ekr.20070626112754.39"><vh>createOuterFrames</vh></v>
<v t="ekr.20070626112754.40"><vh>Dragging (tkTree)</vh>
<v t="ekr.20070626112754.41"><vh>endDrag</vh>
<v t="ekr.20070626112754.42"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20070626112754.43"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.44"><vh>startDrag</vh></v>
<v t="ekr.20070626112754.45"><vh>onContinueDrag</vh>
<v t="ekr.20070626112754.46"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.47"><vh>onDrag</vh></v>
<v t="ekr.20070626112754.48"><vh>onEndDrag</vh></v>
</v>
</v>
<v t="ekr.20070626112754.49"><vh>Made sure all ancestors expanded when select a body editor with multiple body editors</vh>
<v t="ekr.20070626112754.50"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20070626112754.51"><vh>selectEditorHelper</vh>
<v t="ekr.20070626112754.52"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.53"><vh>Fixed bug in CheckVersion</vh>
<v t="ekr.20070626112754.54"><vh>CheckVersion (EKR) &amp; helper</vh>
<v t="ekr.20070626112754.55"><vh>CheckVersionToInt</vh></v>
<v t="ekr.20070626112754.56"><vh>@test CheckVersionToInt</vh></v>
</v>
</v>
<v t="ekr.20070626112754.57"><vh>Fixed bugs arising from new reorg</vh>
<v t="ekr.20070626112754.58"><vh>Fixed several unit tests that failed with bad selection</vh>
<v t="ekr.20070626112754.59"><vh>backToIndentation</vh></v>
<v t="ekr.20070626112754.60"><vh>runEditCommandTest</vh></v>
<v t="ekr.20070626112754.61"><vh>setInsertPoint</vh></v>
<v t="ekr.20070626112754.62"><vh>setSelectionRange</vh></v>
<v t="ekr.20070626112754.63"><vh>Index conversion (leoTextWidget)</vh>
<v t="ekr.20070626112754.64"><vh>w.toGuiIndex</vh></v>
<v t="ekr.20070626112754.65"><vh>w.toPythonIndex</vh></v>
<v t="ekr.20070626112754.66"><vh>w.rowColToGuiIndex</vh></v>
</v>
</v>
<v t="ekr.20070626112754.67"><vh>Fixed change bugs</vh>
<v t="ekr.20070626112754.63"><vh>Index conversion (leoTextWidget)</vh>
<v t="ekr.20070626112754.64"><vh>w.toGuiIndex</vh></v>
<v t="ekr.20070626112754.65"><vh>w.toPythonIndex</vh></v>
<v t="ekr.20070626112754.66"><vh>w.rowColToGuiIndex</vh></v>
</v>
<v t="ekr.20070626112754.68"><vh>search &amp; helpers</vh>
<v t="ekr.20070626112754.69"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20070626112754.8"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20070626112754.9"><vh>regexHelper</vh></v>
<v t="ekr.20070626112754.10"><vh>backwardsHelper</vh></v>
<v t="ekr.20070626112754.11"><vh>plainHelper</vh></v>
<v t="ekr.20070626112754.12"><vh>matchWord</vh></v>
<v t="ekr.20070626112754.13"><vh>replaceBackSlashes</vh></v>
</v>
</v>
<v t="ekr.20070626112754.62"><vh>setSelectionRange</vh></v>
<v t="ekr.20070626112754.61"><vh>setInsertPoint</vh></v>
<v t="ekr.20070626112754.70"><vh>changeSelection</vh>
<v t="ekr.20070626112754.71"><vh>makeRegexSubs</vh></v>
</v>
<v t="ekr.20070626112754.14"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20070626112754.72"><vh>(Fixed match-brackets command)</vh>
<v t="ekr.20070626112754.73"><vh>selfInsertCommand &amp; helpers</vh>
<v t="ekr.20070626112754.74"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.75"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20070626112754.76"><vh>initBracketMatcher</vh></v>
<v t="ekr.20070626112754.77"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20070626112754.78"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.79"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20070626112754.80"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20070626112754.81"><vh>updateTab</vh></v>
</v>
<v t="ekr.20070626112754.82"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.83"><vh>c.findMatchingBracket &amp; helper</vh>
<v t="ekr.20070626112754.84"><vh>findMatchingBracketHelper</vh></v>
</v>
</v>
<v t="ekr.20070626112754.85"><vh>Fixed off-by-one error in go-to-line-number command</vh></v>
<v t="ekr.20070626112754.86"><vh>Fixed crash in backwardDeleteCharacters</vh>
<v t="ekr.20070626112754.87"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20070626112754.88"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.89"><vh>(Fix autocompletion problems)</vh></v>
<v t="ekr.20070626112754.90"><vh>(Fixed index problems due to changing w.toGuiIndex)</vh>
<v t="ekr.20070626112754.91"><vh>Removed no-longer needed tests for newlines</vh>
<v t="ekr.20070626112754.92"><vh>getEditableTextRange</vh></v>
</v>
<v t="ekr.20070626112754.93"><vh> Index utilities... (leoGlobals) (passed)</vh>
<v t="ekr.20070626112754.94"><vh>g.convertPythonIndexToRowCol</vh></v>
<v t="ekr.20070626112754.95"><vh>g.convertRowColToPythonIndex</vh></v>
</v>
<v t="ekr.20070626112754.62"><vh>setSelectionRange</vh></v>
<v t="ekr.20070626112754.63"><vh>Index conversion (leoTextWidget)</vh>
<v t="ekr.20070626112754.64"><vh>w.toGuiIndex</vh></v>
<v t="ekr.20070626112754.65"><vh>w.toPythonIndex</vh></v>
<v t="ekr.20070626112754.66"><vh>w.rowColToGuiIndex</vh></v>
</v>
</v>
<v t="ekr.20070626112754.96"><vh>Fixed problems in new headlines</vh>
<v t="ekr.20070626112754.97"><vh>setEditLabelState</vh></v>
<v t="ekr.20070626112754.98"><vh>tree.setHeadlineText</vh></v>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
</v>
<v t="ekr.20070626112754.100"><vh>(Suppressed initial scroll on drag)</vh>
<v t="ekr.20070626112754.101"><vh>onIconBoxClick</vh></v>
<v t="ekr.20070626112754.40"><vh>Dragging (tkTree)</vh>
<v t="ekr.20070626112754.41"><vh>endDrag</vh>
<v t="ekr.20070626112754.42"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20070626112754.43"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.44"><vh>startDrag</vh></v>
<v t="ekr.20070626112754.45"><vh>onContinueDrag</vh>
<v t="ekr.20070626112754.46"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.47"><vh>onDrag</vh></v>
<v t="ekr.20070626112754.48"><vh>onEndDrag</vh></v>
</v>
</v>
<v t="ekr.20070626112754.102"><vh>(Made sure word search for w. works)</vh>
<v t="ekr.20070626112754.68"><vh>search &amp; helpers</vh>
<v t="ekr.20070626112754.69"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20070626112754.8"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20070626112754.9"><vh>regexHelper</vh></v>
<v t="ekr.20070626112754.10"><vh>backwardsHelper</vh></v>
<v t="ekr.20070626112754.11"><vh>plainHelper</vh></v>
<v t="ekr.20070626112754.12"><vh>matchWord</vh></v>
<v t="ekr.20070626112754.13"><vh>replaceBackSlashes</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.103"><vh>Restore selection in undo/redo</vh>
<v t="ekr.20070626112754.104"><vh>class undoer</vh>
<v t="ekr.20070626112754.105"><vh>undo.__init__ &amp; clearIvars</vh>
<v t="ekr.20070626112754.106"><vh>clearIvars</vh></v>
</v>
<v t="ekr.20070626112754.107"><vh>Internal helpers</vh>
<v t="ekr.20070626112754.108"><vh>cutStack</vh></v>
<v t="ekr.20070626112754.109"><vh>getBead</vh></v>
<v t="ekr.20070626112754.110"><vh>peekBead</vh></v>
<v t="ekr.20070626112754.111"><vh>pushBead</vh></v>
<v t="ekr.20070626112754.112"><vh>setIvarsFromBunch</vh></v>
<v t="ekr.20070626112754.113"><vh>recognizeStartOfTypingWord</vh></v>
<v t="ekr.20070626112754.114"><vh>redoMenuName, undoMenuName</vh></v>
<v t="ekr.20070626112754.115"><vh>setRedoType, setUndoType</vh></v>
<v t="ekr.20070626112754.116"><vh>setUndoTypes</vh></v>
<v t="ekr.20070626112754.117"><vh>u.restoreTree &amp; helpers</vh>
<v t="ekr.20070626112754.118"><vh>restoreVnodeUndoInfo</vh></v>
<v t="ekr.20070626112754.119"><vh>restoreTnodeUndoInfo</vh></v>
</v>
<v t="ekr.20070626112754.120"><vh>u.saveTree &amp; helpers</vh>
<v t="ekr.20070626112754.121"><vh>&lt;&lt; about u.saveTree &gt;&gt;</vh></v>
<v t="ekr.20070626112754.122"><vh>createVnodeUndoInfo</vh></v>
<v t="ekr.20070626112754.123"><vh>createTnodeUndoInfo</vh></v>
</v>
<v t="ekr.20070626112754.124"><vh>u.trace</vh></v>
<v t="ekr.20070626112754.125"><vh>updateMarks</vh></v>
</v>
<v t="ekr.20070626112754.126"><vh>Externally visible entries</vh>
<v t="ekr.20070626112754.127"><vh>afterX...</vh>
<v t="ekr.20070626112754.128"><vh>afterChangeGroup</vh></v>
<v t="ekr.20070626112754.129"><vh>afterChangeNodeContents</vh></v>
<v t="ekr.20070626112754.130"><vh>afterChangeTree</vh></v>
<v t="ekr.20070626112754.131"><vh>afterClearRecentFiles</vh></v>
<v t="ekr.20070626112754.132"><vh>afterCloneNode</vh></v>
<v t="ekr.20070626112754.133"><vh>afterDehoist</vh></v>
<v t="ekr.20070626112754.134"><vh>afterDeleteNode</vh></v>
<v t="ekr.20070626112754.135"><vh>afterHoist</vh></v>
<v t="ekr.20070626112754.136"><vh>afterInsertNode</vh></v>
<v t="ekr.20070626112754.137"><vh>afterMark</vh></v>
<v t="ekr.20070626112754.138"><vh>afterMoveNode</vh></v>
</v>
<v t="ekr.20070626112754.139"><vh>beforeX...</vh>
<v t="ekr.20070626112754.140"><vh>beforeChangeGroup</vh></v>
<v t="ekr.20070626112754.141"><vh>beforeChangeNodeContents</vh></v>
<v t="ekr.20070626112754.142"><vh>beforeChangeTree</vh></v>
<v t="ekr.20070626112754.143"><vh>beforeClearRecentFiles</vh></v>
<v t="ekr.20070626112754.144"><vh>beforeCloneNode</vh></v>
<v t="ekr.20070626112754.145"><vh>beforeDeleteNode</vh></v>
<v t="ekr.20070626112754.146"><vh>beforeInsertNode</vh></v>
<v t="ekr.20070626112754.147"><vh>beforeMark</vh></v>
<v t="ekr.20070626112754.148"><vh>beforeMoveNode</vh></v>
<v t="ekr.20070626112754.149"><vh>createCommonBunch</vh></v>
</v>
<v t="ekr.20070626112754.150"><vh>canRedo &amp; canUndo</vh></v>
<v t="ekr.20070626112754.151"><vh>clearUndoState</vh></v>
<v t="ekr.20070626112754.152"><vh>enableMenuItems</vh></v>
<v t="ekr.20070626112754.153"><vh>getMark &amp; rollbackToMark (no longer used)</vh></v>
<v t="ekr.20070626112754.154"><vh>setUndoTypingParams</vh>
<v t="ekr.20070626112754.155"><vh>&lt;&lt; return if there is nothing to do &gt;&gt;</vh></v>
<v t="ekr.20070626112754.156"><vh>&lt;&lt; init the undo params &gt;&gt;</vh></v>
<v t="ekr.20070626112754.157"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="ekr.20070626112754.158"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
<v t="ekr.20070626112754.159"><vh>&lt;&lt; save the selection and scrolling position &gt;&gt;</vh></v>
<v t="ekr.20070626112754.160"><vh>&lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;</vh>
<v t="ekr.20070626112754.161"><vh>&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;</vh>
<v t="ekr.20070626112754.162"><vh>&lt;&lt; set newBead if the change does not continue a word &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070626112754.163"><vh>redo &amp; helpers...</vh>
<v t="ekr.20070626112754.164"><vh>redoClearRecentFiles</vh></v>
<v t="ekr.20070626112754.165"><vh>redoCloneNode</vh></v>
<v t="ekr.20070626112754.166"><vh>redoDeleteNode</vh></v>
<v t="ekr.20070626112754.167"><vh>redoInsertNode</vh></v>
<v t="ekr.20070626112754.168"><vh>redoHoistNode &amp; redoDehoistNode</vh></v>
<v t="ekr.20070626112754.169"><vh>redoGroup</vh></v>
<v t="ekr.20070626112754.170"><vh>redoNodeContents</vh></v>
<v t="ekr.20070626112754.171"><vh>redoMark</vh></v>
<v t="ekr.20070626112754.172"><vh>redoMove</vh></v>
<v t="ekr.20070626112754.173"><vh>redoTree</vh></v>
<v t="ekr.20070626112754.35"><vh>redoTyping</vh></v>
</v>
<v t="ekr.20070626112754.174"><vh>undo &amp; helpers...</vh>
<v t="ekr.20070626112754.175"><vh>undoClearRecentFiles</vh></v>
<v t="ekr.20070626112754.176"><vh>undoCloneNode</vh></v>
<v t="ekr.20070626112754.177"><vh>undoDeleteNode</vh></v>
<v t="ekr.20070626112754.178"><vh>undoGroup</vh></v>
<v t="ekr.20070626112754.179"><vh>undoHoistNode &amp; undoDehoistNode</vh></v>
<v t="ekr.20070626112754.180"><vh>undoInsertNode</vh></v>
<v t="ekr.20070626112754.181"><vh>undoMark</vh></v>
<v t="ekr.20070626112754.182"><vh>undoMove</vh></v>
<v t="ekr.20070626112754.183"><vh>undoNodeContents</vh></v>
<v t="ekr.20070626112754.184"><vh>undoTree</vh></v>
<v t="ekr.20070626112754.185"><vh>undoRedoTree</vh></v>
<v t="ekr.20070626112754.34"><vh>undoTyping</vh></v>
<v t="ekr.20070626112754.36"><vh>undoRedoText (passed)</vh>
<v t="ekr.20070626112754.37"><vh>&lt;&lt; Compute the result using p's body text &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.186"><vh>c.selectPosition</vh></v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.192"><vh>c.setCurrentPosition</vh></v>
<v t="ekr.20070626112754.35"><vh>redoTyping</vh></v>
<v t="ekr.20070626112754.34"><vh>undoTyping</vh></v>
</v>
<v t="ekr.20070626112754.193"><vh>Improved selection in several commands and undo</vh>
<v t="ekr.20070626112754.194"><vh>reformatParagraph</vh>
<v t="ekr.20070626112754.195"><vh>&lt;&lt; compute vars for reformatParagraph &gt;&gt;</vh></v>
<v t="ekr.20070626112754.196"><vh>&lt;&lt; compute the leading whitespace &gt;&gt;</vh></v>
<v t="ekr.20070626112754.197"><vh>&lt;&lt; compute the result of wrapping all lines &gt;&gt;</vh></v>
<v t="ekr.20070626112754.198"><vh>&lt;&lt; update the body, selection &amp; undo state &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.199"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
<v t="ekr.20070626112754.200"><vh>setSelectionAreas</vh></v>
<v t="ekr.20070626112754.201"><vh>getBodyLines</vh></v>
<v t="ekr.20070626112754.202"><vh>getSelectionLines</vh></v>
<v t="ekr.20070626112754.203"><vh>getInsertLines</vh></v>
<v t="ekr.20070626112754.204"><vh>Found: .getBodyLines</vh>
<v t="ekr.20070626112754.205"><vh>removeBlankLines</vh></v>
<v t="ekr.20070626112754.206"><vh>convertBlanks (test)</vh></v>
<v t="ekr.20070626112754.207"><vh>convertTabs (test)</vh></v>
<v t="ekr.20070626112754.208"><vh>dedentBody (test)</vh></v>
<v t="ekr.20070626112754.209"><vh>extract (test)</vh></v>
<v t="ekr.20070626112754.210"><vh>extractSection (test)</vh>
<v t="ekr.20070626112754.211"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.212"><vh>extractSectionNames (test)</vh>
<v t="ekr.20070626112754.213"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.214"><vh>indentBody (test)</vh></v>
<v t="ekr.20070626112754.215"><vh>addComments (test)</vh></v>
<v t="ekr.20070626112754.216"><vh>deleteComments (test)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.217"><vh>Fixed bug in end-of-line commands</vh>
<v t="ekr.20070626112754.218"><vh>move cursor... (leoEditCommands)</vh>
<v t="ekr.20070626112754.219"><vh> helpers</vh>
<v t="ekr.20070626112754.220"><vh>extendHelper</vh></v>
<v t="ekr.20070626112754.221"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20070626112754.222"><vh>moveToHelper</vh></v>
<v t="ekr.20070626112754.223"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20070626112754.224"><vh>moveWordHelper</vh></v>
<v t="ekr.20070626112754.225"><vh>backSentenceHelper</vh></v>
<v t="ekr.20070626112754.226"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20070626112754.227"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.228"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.229"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20070626112754.230"><vh>buffers</vh></v>
<v t="ekr.20070626112754.231"><vh>characters</vh></v>
<v t="ekr.20070626112754.232"><vh>clear/set/ToggleExtendMode</vh></v>
<v t="ekr.20070626112754.233"><vh>exchangePointMark</vh></v>
<v t="ekr.20070626112754.234"><vh>extend-to-line</vh></v>
<v t="ekr.20070626112754.235"><vh>extend-to-sentence</vh></v>
<v t="ekr.20070626112754.236"><vh>extend-to-word</vh></v>
<v t="ekr.20070626112754.237"><vh>lines</vh></v>
<v t="ekr.20070626112754.238"><vh>movePastClose</vh></v>
<v t="ekr.20070626112754.239"><vh>paragraphs</vh></v>
<v t="ekr.20070626112754.240"><vh>sentences</vh></v>
<v t="ekr.20070626112754.241"><vh>words</vh></v>
</v>
</v>
<v t="ekr.20070626112754.242"><vh>Fixed new bug in kill-line</vh>
<v t="ekr.20070626112754.27"><vh>kill, killLine</vh></v>
</v>
<v t="ekr.20070626112754.243"><vh>Replacing selection not done properly in headline</vh>
<v t="ekr.20070626112754.244"><vh>head key handlers (leoTree)</vh>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.247"><vh>onHeadlineKey</vh></v>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
<v t="ekr.20070626112754.248"><vh>endEditLabel</vh></v>
</v>
</v>
<v t="ekr.20070626112754.249"><vh>Fixed paragraph commands</vh>
<v t="ekr.20070626112754.222"><vh>moveToHelper</vh></v>
<v t="ekr.20070626112754.250"><vh>tag_add</vh></v>
<v t="ekr.20070626112754.251"><vh>extend-to-paragraph &amp; helper</vh>
<v t="ekr.20070626112754.252"><vh>selectParagraphHelper</vh></v>
</v>
<v t="ekr.20070626112754.227"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.228"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.253"><vh>backwardKillParagraph</vh></v>
<v t="ekr.20070626112754.254"><vh>killParagraph</vh></v>
</v>
<v t="ekr.20070626112754.255"><vh>UNL's are not being shown</vh>
<v t="ekr.20070626112754.256"><vh>Status line convenience methods</vh></v>
<v t="ekr.20070626112754.257"><vh>class tkStatusLineClass</vh>
<v t="ekr.20070626112754.258"><vh> ctor</vh></v>
<v t="ekr.20070626112754.259"><vh>clear</vh></v>
<v t="ekr.20070626112754.260"><vh>enable, disable &amp; isEnabled</vh></v>
<v t="ekr.20070626112754.261"><vh>get</vh></v>
<v t="ekr.20070626112754.262"><vh>getFrame</vh></v>
<v t="ekr.20070626112754.263"><vh>onActivate</vh></v>
<v t="ekr.20070626112754.264"><vh>pack &amp; show</vh></v>
<v t="ekr.20070626112754.265"><vh>put (leoTkinterFrame:statusLineClass)</vh></v>
<v t="ekr.20070626112754.266"><vh>unpack &amp; hide</vh></v>
<v t="ekr.20070626112754.267"><vh>update (statusLine)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.268"><vh>Select-all and delete shows too much in body pane</vh>
<v t="ekr.20070626112754.73"><vh>selfInsertCommand &amp; helpers</vh>
<v t="ekr.20070626112754.74"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.75"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20070626112754.76"><vh>initBracketMatcher</vh></v>
<v t="ekr.20070626112754.77"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20070626112754.78"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.79"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20070626112754.80"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20070626112754.81"><vh>updateTab</vh></v>
</v>
<v t="ekr.20070626112754.87"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20070626112754.88"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.269"><vh>selectAllText</vh></v>
</v>
<v t="ekr.20070626112754.270"><vh>Fixed colorizer bug: section references not colored properly</vh>
<v t="ekr.20070626112754.271"><vh>doNowebSecRef (colorizer)</vh>
<v t="ekr.20070626112754.272"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.273"><vh>Fixed cursor up/down bug</vh>
<v t="ekr.20070626112754.221"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20070626112754.222"><vh>moveToHelper</vh></v>
<v t="ekr.20070626112754.220"><vh>extendHelper</vh></v>
<v t="ekr.20070626112754.229"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20070626112754.274"><vh>Fix recent crasher in about-leo command</vh>
<v t="ekr.20070626112754.275"><vh>tkinterAboutLeo.createFrame</vh></v>
</v>
<v t="ekr.20070626112754.276"><vh>Fixed bugs in headline</vh>
<v t="ekr.20070626112754.244"><vh>head key handlers (leoTree)</vh>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.247"><vh>onHeadlineKey</vh></v>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
<v t="ekr.20070626112754.248"><vh>endEditLabel</vh></v>
</v>
<v t="ekr.20070626112754.87"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20070626112754.88"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.269"><vh>selectAllText</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.277"><vh>Features</vh>
<v t="ekr.20070626112754.278"><vh>Added handleUrlInUrlNode helper for OnIconDoubleClick</vh>
<v t="ekr.20070626112754.279"><vh>Request</vh></v>
<v t="ekr.20070626112754.280"><vh>tree.OnIconDoubleClick (@url) &amp; helper</vh>
<v t="ekr.20070626112754.281"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="ekr.20070626112754.282"><vh>handleUrlInUrlNode</vh>
<v t="ekr.20070626112754.283"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="ekr.20070626112754.284"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.285"><vh>Only do one message re writing recent files</vh>
<v t="ekr.20070626112754.286"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20070626112754.287"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
<v t="ekr.20070626112754.288"><vh>Made escape in the minibuffer work like ctrl-g</vh>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.295"><vh>getArg</vh>
<v t="ekr.20070626112754.296"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.297"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20070626112754.298"><vh>callAltXFunction</vh></v>
</v>
</v>
<v t="ekr.20070626112754.299"><vh>Clear status line in repeat-complex-command</vh></v>
<v t="ekr.20070626112754.300"><vh>Added shortcuts for goto-first/last-sibling</vh></v>
<v t="ekr.20070626112754.301"><vh>Made copied nodes valid Leo files</vh></v>
<v t="ekr.20070626112754.302"><vh>Added support for chdir_to_relative_path setting</vh>
<v t="ekr.20070626112754.303"><vh>g.getBaseDirectory</vh></v>
</v>
<v t="ekr.20070626112754.304"><vh>changeAll now works like findAll</vh>
<v t="ekr.20070626112754.305"><vh>Search classes</vh>
<v t="ekr.20070626112754.306"><vh>class minibufferFind( (the findHandler)</vh>
<v t="ekr.20070626112754.307"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20070626112754.308"><vh> Options (minibufferFind)</vh>
<v t="ekr.20070626112754.309"><vh>setFindScope</vh></v>
<v t="ekr.20070626112754.310"><vh>get/set/toggleOption (minibufferFind)</vh></v>
<v t="ekr.20070626112754.311"><vh>showFindOptions</vh></v>
<v t="ekr.20070626112754.312"><vh>setupChangePattern</vh></v>
<v t="ekr.20070626112754.313"><vh>setupSearchPattern</vh></v>
</v>
<v t="ekr.20070626112754.314"><vh>addChangeStringToLabel</vh></v>
<v t="ekr.20070626112754.315"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20070626112754.316"><vh>changeAll</vh></v>
<v t="ekr.20070626112754.317"><vh>cloneFindAll</vh></v>
<v t="ekr.20070626112754.318"><vh>findAgain</vh></v>
<v t="ekr.20070626112754.319"><vh>findAll</vh></v>
<v t="ekr.20070626112754.320"><vh>generalChangeHelper</vh></v>
<v t="ekr.20070626112754.321"><vh>generalSearchHelper</vh></v>
<v t="ekr.20070626112754.322"><vh>lastStateHelper</vh></v>
<v t="ekr.20070626112754.323"><vh>replaceString</vh></v>
<v t="ekr.20070626112754.324"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20070626112754.325"><vh>seachForward/Backward</vh></v>
<v t="ekr.20070626112754.326"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20070626112754.327"><vh>setupArgs</vh></v>
<v t="ekr.20070626112754.328"><vh>stateZeroHelper</vh></v>
<v t="ekr.20070626112754.329"><vh>updateChange/FindList</vh></v>
<v t="ekr.20070626112754.330"><vh>wordSearchBackward/Forward</vh></v>
</v>
<v t="ekr.20070626112754.331"><vh>class searchCommandsClass</vh>
<v t="ekr.20070626112754.332"><vh> ctor (searchCommandsClass)</vh></v>
<v t="ekr.20070626112754.333"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20070626112754.334"><vh>Top-level methods</vh>
<v t="ekr.20070626112754.335"><vh>openFindTab</vh></v>
<v t="ekr.20070626112754.336"><vh>Find Tab commands</vh></v>
<v t="ekr.20070626112754.337"><vh>getHandler</vh></v>
<v t="ekr.20070626112754.338"><vh>Find options wrappers</vh></v>
<v t="ekr.20070626112754.339"><vh>Find wrappers</vh></v>
<v t="ekr.20070626112754.340"><vh>findAgain</vh></v>
</v>
<v t="ekr.20070626112754.341"><vh>incremental search...</vh>
<v t="ekr.20070626112754.342"><vh>iSearchBackspace</vh></v>
<v t="ekr.20070626112754.343"><vh>startIncremental</vh></v>
<v t="ekr.20070626112754.344"><vh>iSearchStateHandler</vh></v>
<v t="ekr.20070626112754.345"><vh>scolorizer LATER</vh></v>
<v t="ekr.20070626112754.346"><vh>iSearchHelper</vh></v>
<v t="ekr.20070626112754.347"><vh>endSearch</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.348"><vh>class leoFind</vh>
<v t="ekr.20070626112754.349"><vh>leoFind.__init__ &amp; helpers</vh>
<v t="ekr.20070626112754.350"><vh>&lt;&lt; compute self.title &gt;&gt;</vh></v>
<v t="ekr.20070626112754.351"><vh>&lt;&lt; init the gui-independent ivars &gt;&gt;</vh>
<v t="ekr.20070626112754.352"><vh>&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.353"><vh>Top Level Buttons</vh>
<v t="ekr.20070626112754.354"><vh>changeAllButton</vh></v>
<v t="ekr.20070626112754.355"><vh>changeButton</vh></v>
<v t="ekr.20070626112754.356"><vh>changeThenFindButton</vh></v>
<v t="ekr.20070626112754.357"><vh>findAllButton</vh></v>
<v t="ekr.20070626112754.358"><vh>findButton</vh></v>
<v t="ekr.20070626112754.359"><vh>setup_button</vh></v>
</v>
<v t="ekr.20070626112754.360"><vh>Top Level Commands</vh>
<v t="ekr.20070626112754.361"><vh>changeCommand</vh></v>
<v t="ekr.20070626112754.362"><vh>changeThenFindCommand</vh></v>
<v t="ekr.20070626112754.363"><vh>dismiss: defined in subclass class</vh></v>
<v t="ekr.20070626112754.364"><vh>findNextCommand</vh></v>
<v t="ekr.20070626112754.365"><vh>findPreviousCommand</vh></v>
<v t="ekr.20070626112754.366"><vh>handleUserClick</vh></v>
<v t="ekr.20070626112754.367"><vh>setup_command</vh></v>
</v>
<v t="ekr.20070626112754.368"><vh>Find/change utils</vh>
<v t="ekr.20070626112754.369"><vh>batchChange (sets start of change-all group)</vh>
<v t="ekr.20070626112754.370"><vh>&lt;&lt; change headline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.371"><vh>&lt;&lt; change body &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.372"><vh>change</vh></v>
<v t="ekr.20070626112754.373"><vh>changeAll (sets end of change-all group)</vh></v>
<v t="ekr.20070626112754.70"><vh>changeSelection</vh>
<v t="ekr.20070626112754.71"><vh>makeRegexSubs</vh></v>
</v>
<v t="ekr.20070626112754.374"><vh>changeThenFind</vh></v>
<v t="ekr.20070626112754.375"><vh>doChange...Script</vh></v>
<v t="ekr.20070626112754.376"><vh>doFind...Script</vh></v>
<v t="ekr.20070626112754.377"><vh>findAll</vh>
<v t="ekr.20070626112754.378"><vh>&lt;&lt; create the found node and begin the undo group &gt;&gt;</vh></v>
<v t="ekr.20070626112754.379"><vh>&lt;&lt; create a clone of p under the find node &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.380"><vh>findNext</vh></v>
<v t="ekr.20070626112754.381"><vh>findNextMatch</vh></v>
<v t="ekr.20070626112754.382"><vh>resetWrap</vh></v>
<v t="ekr.20070626112754.68"><vh>search &amp; helpers</vh>
<v t="ekr.20070626112754.69"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20070626112754.8"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20070626112754.9"><vh>regexHelper</vh></v>
<v t="ekr.20070626112754.10"><vh>backwardsHelper</vh></v>
<v t="ekr.20070626112754.11"><vh>plainHelper</vh></v>
<v t="ekr.20070626112754.12"><vh>matchWord</vh></v>
<v t="ekr.20070626112754.13"><vh>replaceBackSlashes</vh></v>
</v>
</v>
<v t="ekr.20070626112754.383"><vh>selectNextPosition</vh></v>
</v>
<v t="ekr.20070626112754.384"><vh>General utils</vh>
<v t="ekr.20070626112754.385"><vh>bringToFront (leoFind)</vh></v>
<v t="ekr.20070626112754.386"><vh>oops (leoFind)</vh></v>
<v t="ekr.20070626112754.387"><vh>selectAllFindText (leoFind)</vh></v>
</v>
<v t="ekr.20070626112754.388"><vh>Initing &amp; finalizing</vh>
<v t="ekr.20070626112754.389"><vh>checkArgs</vh></v>
<v t="ekr.20070626112754.390"><vh>init_s_ctrl</vh></v>
<v t="ekr.20070626112754.391"><vh>initBatchCommands</vh></v>
<v t="ekr.20070626112754.392"><vh>initBatchText &amp; initNextText</vh></v>
<v t="ekr.20070626112754.393"><vh>initInHeadline</vh></v>
<v t="ekr.20070626112754.394"><vh>initInteractiveCommands</vh></v>
<v t="ekr.20070626112754.395"><vh>printLine</vh></v>
<v t="ekr.20070626112754.396"><vh>restore</vh></v>
<v t="ekr.20070626112754.397"><vh>save</vh></v>
<v t="ekr.20070626112754.14"><vh>showSuccess</vh></v>
<v t="ekr.20070626112754.398"><vh>update_ivars (leoFind)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.399"><vh>class findTab (leoFind)</vh>
<v t="ekr.20070626112754.400"><vh>findTab.__init__</vh></v>
<v t="ekr.20070626112754.401"><vh>Must be defined in subclasses</vh></v>
<v t="ekr.20070626112754.402"><vh>Callbacks</vh>
<v t="ekr.20070626112754.403"><vh>findButtonCallback</vh></v>
<v t="ekr.20070626112754.404"><vh>hideTab</vh></v>
</v>
<v t="ekr.20070626112754.405"><vh> Top level</vh>
<v t="ekr.20070626112754.406"><vh>change/ThenFindCommand</vh></v>
<v t="ekr.20070626112754.407"><vh>changeAllCommand</vh></v>
<v t="ekr.20070626112754.408"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20070626112754.409"><vh>findAgainCommand</vh></v>
<v t="ekr.20070626112754.410"><vh>findAllCommand</vh></v>
<v t="ekr.20070626112754.411"><vh>findNext/PrefCommand</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.412"><vh>Added Find &amp; Spell tabs to log pane on startup</vh>
<v t="ekr.20070626112754.335"><vh>openFindTab</vh></v>
<v t="ekr.20070626112754.413"><vh>openSpellTab</vh>
<v t="ekr.20070626112754.414"><vh>commands...</vh></v>
</v>
<v t="ekr.20070626112754.415"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20070626112754.416"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20070626112754.417"><vh>tkFrame.finishCreate &amp; helpers</vh>
<v t="ekr.20070626112754.39"><vh>createOuterFrames</vh></v>
<v t="ekr.20070626112754.418"><vh>createSplitterComponents</vh></v>
<v t="ekr.20070626112754.419"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20070626112754.420"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20070626112754.421"><vh>tkLog.finishCreate</vh></v>
<v t="ekr.20070626112754.422"><vh>deleteTab</vh></v>
</v>
<v t="ekr.20070626112754.423"><vh>Created standard pluginsManager.txt only if it does not exist</vh>
<v t="ekr.20070626112754.424"><vh>loadHandlers &amp; helper</vh>
<v t="ekr.20070626112754.425"><vh>&lt;&lt; set enabled_files from pluginsManager.txt &gt;&gt;</vh></v>
<v t="ekr.20070626112754.426"><vh>getEnabledFiles</vh></v>
</v>
</v>
<v t="ekr.20070626112754.427"><vh>Executing Leo-specific scripts from winpdb</vh>
<v t="ekr.20070626112754.428"><vh>Preliminary docs</vh></v>
<v t="ekr.20070626112754.429"><vh>c.executeScript &amp; helpers</vh>
<v t="ekr.20070626112754.430"><vh>redirectScriptOutput</vh></v>
<v t="ekr.20070626112754.431"><vh>unredirectScriptOutput</vh></v>
<v t="ekr.20070626112754.432"><vh>writeScriptFile</vh></v>
</v>
<v t="ekr.20070626112754.433"><vh>debug &amp; helper</vh>
<v t="ekr.20070626112754.434"><vh>findDebugger</vh></v>
</v>
<v t="ekr.20070626112754.435"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20070626112754.436"><vh>@test g.getScript strips crlf</vh></v>
</v>
<v t="ekr.20070626112754.437"><vh>g.handleScriptException</vh>
<v t="ekr.20070626112754.438"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.439"><vh>Added \runAskOkCancelStringDialog</vh></v>
<v t="ekr.20070626112754.440"><vh>Use plain ascii characters instead of special Tk symbols</vh>
<v t="ekr.20070626112754.441"><vh>To do: define special_keys in base class</vh></v>
<v t="ekr.20070626112754.442"><vh>Found: .bind</vh>
<v t="ekr.20070626112754.443"><vh>bindHotKey</vh></v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.445"><vh>printBindings</vh></v>
<v t="ekr.20070626112754.446"><vh>bindHotKey</vh></v>
<v t="ekr.20070626112754.447"><vh>f.setMinibufferBindings</vh></v>
<v t="ekr.20070626112754.448"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20070626112754.449"><vh>Menus</vh></v>
<v t="ekr.20070626112754.450"><vh>setTabBindings</vh></v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.453"><vh>Shortcuts (keyHandler)</vh>
<v t="ekr.20070626112754.454"><vh>isPlainKey &amp; test</vh>
<v t="ekr.20070626112754.455"><vh>@test isPlainKey</vh></v>
</v>
<v t="ekr.20070626112754.456"><vh>shortcutFromSetting (uses k.guiBindNamesDict)</vh>
<v t="ekr.20070626112754.457"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20070626112754.458"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20070626112754.459"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20070626112754.460"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20070626112754.461"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.462"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20070626112754.463"><vh>k.prettyPrintKey</vh></v>
</v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.464"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20070626112754.465"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20070626112754.466"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20070626112754.467"><vh>callStateFunction</vh></v>
<v t="ekr.20070626112754.468"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20070626112754.469"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20070626112754.73"><vh>selfInsertCommand &amp; helpers</vh>
<v t="ekr.20070626112754.74"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.75"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20070626112754.76"><vh>initBracketMatcher</vh></v>
<v t="ekr.20070626112754.77"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20070626112754.78"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.79"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20070626112754.80"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20070626112754.81"><vh>updateTab</vh></v>
</v>
<v t="ekr.20070626112754.470"><vh>class leoKeyEvent (tkGui)</vh></v>
<v t="ekr.20070626112754.471"><vh>k.defineSpecialKeys</vh></v>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
</v>
<v t="ekr.20070626112754.472"><vh>Removed all calls to Tk.Text.bbox</vh>
<v t="ekr.20070626112754.221"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20070626112754.220"><vh>extendHelper</vh></v>
</v>
</v>
<v t="ekr.20070626112754.473"><vh>Menu reorgs</vh>
<v t="ekr.20070626112754.474"><vh>createMenusFromTables &amp; helpers</vh>
<v t="ekr.20070626112754.475"><vh>createFileMenuFromTable</vh>
<v t="ekr.20070626112754.476"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.477"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.478"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.479"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.480"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.481"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.482"><vh>createEditMenuFromTable</vh>
<v t="ekr.20070626112754.483"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.484"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.485"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.486"><vh>createOutlineMenuFromTable</vh>
<v t="ekr.20070626112754.487"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.488"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.489"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.490"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.491"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.492"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20070626112754.493"><vh>createWindowMenuFromTable</vh></v>
<v t="ekr.20070626112754.494"><vh>createHelpMenuFromTable</vh></v>
</v>
<v t="ekr.20070626112754.495"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20070626112754.496"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20070626112754.497"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20070626112754.498"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20070626112754.499"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20070626112754.500"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20070626112754.501"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20070626112754.502"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20070626112754.503"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20070626112754.504"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20070626112754.505"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20070626112754.506"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20070626112754.507"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20070626112754.508"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20070626112754.509"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20070626112754.510"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20070626112754.511"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20070626112754.512"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20070626112754.513"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20070626112754.514"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20070626112754.515"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20070626112754.516"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20070626112754.517"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20070626112754.518"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20070626112754.519"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20070626112754.520"><vh>defineCmdsMenuBodyEditorsTable</vh></v>
<v t="ekr.20070626112754.521"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20070626112754.522"><vh>defineCmdsMenuChaptersTable</vh></v>
<v t="ekr.20070626112754.523"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20070626112754.524"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20070626112754.525"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20070626112754.526"><vh>defineCmdsMenuMinibufferTable</vh></v>
<v t="ekr.20070626112754.527"><vh>defineCmdsMenuPickersTable</vh></v>
<v t="ekr.20070626112754.528"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20070626112754.529"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20070626112754.530"><vh>defineCmdsMenuRunTable</vh></v>
<v t="ekr.20070626112754.531"><vh>defineCmdsMenuScrollTable</vh></v>
<v t="ekr.20070626112754.532"><vh>defineCmdsMenuSpellCheckTable</vh></v>
<v t="ekr.20070626112754.533"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20070626112754.534"><vh>defineCmdsMenuToggleTable</vh></v>
</v>
<v t="ekr.20070626112754.535"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20070626112754.536"><vh>defineHelpMenuTables</vh></v>
</v>
</v>
<v t="ekr.20070626112754.537"><vh>Plugins</vh>
<v t="ekr.20070626112754.538"><vh>Changed bindings in UniversalScrolling pluing</vh></v>
<v t="ekr.20070626112754.539"><vh>Registered write-restructured-text command in rst3 plugin</vh></v>
</v>
<v t="ekr.20070626112754.540"><vh>Settings</vh>
<v t="ekr.20070626112754.541"><vh>Added @bool center_selected_tree_node</vh></v>
<v t="ekr.20070626112754.542"><vh>Added @bool invisible_outline_navigation = False</vh></v>
<v t="ekr.20070626112754.543"><vh>Added @bool show_full_tracebacks_in_scripts</vh></v>
</v>
</v>
<v t="ekr.20070626112754.544"><vh>Leo 4.4.3 alpha 2 projects</vh>
<v t="ekr.20070626112754.545"><vh>Bugs</vh>
<v t="ekr.20070626112754.546"><vh>Fixed bugs in undo/redoNodeContents</vh>
<v t="ekr.20070626112754.547"><vh>c.setBodyString</vh></v>
<v t="ekr.20070626112754.183"><vh>undoNodeContents</vh></v>
<v t="ekr.20070626112754.170"><vh>redoNodeContents</vh></v>
</v>
<v t="ekr.20070626112754.548"><vh>Fixed minor xml problem</vh>
<v t="ekr.20070626112754.549"><vh>putClipboardHeader</vh>
<v t="ekr.20070626112754.550"><vh>&lt;&lt; count the number of tnodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.551"><vh>getDummyElements</vh></v>
</v>
<v t="ekr.20070626112754.552"><vh>Fixed C++ import bug</vh>
<v t="ekr.20070626112754.553"><vh>Report</vh></v>
<v t="ekr.20070626112754.554"><vh>scanCText</vh></v>
<v t="ekr.20070626112754.555"><vh>class cScanner</vh>
<v t="ekr.20070626112754.556"><vh>cScanner.ctor</vh></v>
<v t="ekr.20070626112754.557"><vh>scan &amp; helpers</vh>
<v t="ekr.20070626112754.558"><vh>appendUnusedText</vh></v>
<v t="ekr.20070626112754.559"><vh>doId</vh></v>
<v t="ekr.20070626112754.560"><vh>doInner</vh></v>
<v t="ekr.20070626112754.561"><vh>doOuterParen</vh></v>
<v t="ekr.20070626112754.562"><vh>doSemicolon</vh></v>
<v t="ekr.20070626112754.563"><vh>skipComments</vh></v>
</v>
<v t="ekr.20070626112754.564"><vh>Utilities (should be in base class)</vh>
<v t="ekr.20070626112754.565"><vh>createHeadline</vh></v>
<v t="ekr.20070626112754.566"><vh>error</vh></v>
<v t="ekr.20070626112754.567"><vh>getLeadingIndent</vh></v>
<v t="ekr.20070626112754.568"><vh>isDocStart and isModuleStart</vh></v>
<v t="ekr.20070626112754.569"><vh>massageComment</vh></v>
<v t="ekr.20070626112754.570"><vh>setEncoding</vh></v>
<v t="ekr.20070626112754.571"><vh>skipLeadingComments</vh>
<v t="ekr.20070626112754.572"><vh>&lt;&lt; scan for C-style comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.573"><vh>&lt;&lt; scan for Lua comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.574"><vh>&lt;&lt; scan for Pascal comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.575"><vh>&lt;&lt; scan for Python comments &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.576"><vh>undentBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.577"><vh>Fixed recent bug in next-line command</vh>
<v t="ekr.20070626112754.221"><vh>moveUpOrDownHelper</vh></v>
</v>
<v t="ekr.20070626112754.578"><vh>Made standalone plugins manager work again</vh></v>
<v t="ekr.20070626112754.579"><vh>Fixed wiki markup bug</vh></v>
<v t="ekr.20070626112754.580"><vh>Fixed bugs in regular expressions</vh>
<v t="ekr.20070626112754.68"><vh>search &amp; helpers</vh>
<v t="ekr.20070626112754.69"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20070626112754.8"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20070626112754.9"><vh>regexHelper</vh></v>
<v t="ekr.20070626112754.10"><vh>backwardsHelper</vh></v>
<v t="ekr.20070626112754.11"><vh>plainHelper</vh></v>
<v t="ekr.20070626112754.12"><vh>matchWord</vh></v>
<v t="ekr.20070626112754.13"><vh>replaceBackSlashes</vh></v>
</v>
</v>
<v t="ekr.20070626112754.381"><vh>findNextMatch</vh></v>
<v t="ekr.20070626112754.380"><vh>findNext</vh></v>
</v>
<v t="ekr.20070626112754.581"><vh>Fixed memory error in leoBridge</vh>
<v t="ekr.20070626112754.582"><vh>es, enl, ecnl</vh></v>
</v>
<v t="ekr.20070626112754.583"><vh>Fixed backspace in headline bug</vh>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.87"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20070626112754.88"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.584"><vh>Make sure alt-arrow keys honor focus settings</vh>
<v t="ekr.20070626112754.585"><vh>Goto</vh>
<v t="ekr.20070626112754.586"><vh>goNextVisitedNode</vh></v>
<v t="ekr.20070626112754.587"><vh>goPrevVisitedNode</vh></v>
<v t="ekr.20070626112754.588"><vh>goToFirstNode</vh></v>
<v t="ekr.20070626112754.589"><vh>goToFirstSibling</vh></v>
<v t="ekr.20070626112754.590"><vh>goToFirstVisibleNode</vh></v>
<v t="ekr.20070626112754.591"><vh>goToLastNode</vh></v>
<v t="ekr.20070626112754.592"><vh>goToLastSibling</vh></v>
<v t="ekr.20070626112754.593"><vh>c.goToLastVisibleNode</vh></v>
<v t="ekr.20070626112754.594"><vh>goToNextClone</vh></v>
<v t="ekr.20070626112754.595"><vh>goToNextDirtyHeadline</vh></v>
<v t="ekr.20070626112754.596"><vh>goToNextMarkedHeadline</vh></v>
<v t="ekr.20070626112754.597"><vh>goToNextSibling</vh></v>
<v t="ekr.20070626112754.598"><vh>goToParent</vh></v>
<v t="ekr.20070626112754.599"><vh>goToPrevSibling</vh></v>
<v t="ekr.20070626112754.600"><vh>selectThreadBack</vh></v>
<v t="ekr.20070626112754.601"><vh>selectThreadNext</vh></v>
<v t="ekr.20070626112754.602"><vh>selectVisBack</vh></v>
<v t="ekr.20070626112754.603"><vh>selectVisNext</vh></v>
<v t="ekr.20070626112754.604"><vh>utils</vh>
<v t="ekr.20070626112754.605"><vh> treeFocusHelper (new in Leo 4.4.3)</vh></v>
<v t="ekr.20070626112754.606"><vh> treeSelectHelper (new in Leo 4.4.3)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.607"><vh>Commands (outline menu)</vh>
<v t="ekr.20070626112754.608"><vh>contractAllHeadlines</vh></v>
<v t="ekr.20070626112754.609"><vh>contractNode</vh></v>
<v t="ekr.20070626112754.610"><vh>contractNodeOrGoToParent</vh></v>
<v t="ekr.20070626112754.611"><vh>contractParent</vh></v>
<v t="ekr.20070626112754.612"><vh>expandAllHeadlines</vh></v>
<v t="ekr.20070626112754.613"><vh>expandAllSubheads</vh></v>
<v t="ekr.20070626112754.614"><vh>expandLevel1..9</vh></v>
<v t="ekr.20070626112754.615"><vh>expandNextLevel</vh></v>
<v t="ekr.20070626112754.616"><vh>expandNode</vh></v>
<v t="ekr.20070626112754.617"><vh>expandNodeAnd/OrGoToFirstChild</vh></v>
<v t="ekr.20070626112754.618"><vh>expandOnlyAncestorsOfNode</vh></v>
<v t="ekr.20070626112754.619"><vh>expandPrevLevel</vh></v>
</v>
<v t="ekr.20070626112754.620"><vh>Move... (Commands)</vh>
<v t="ekr.20070626112754.621"><vh>cantMoveMessage</vh></v>
<v t="ekr.20070626112754.622"><vh>demote</vh></v>
<v t="ekr.20070626112754.623"><vh>moveOutlineDown</vh>
<v t="ekr.20070626112754.624"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.625"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20070626112754.626"><vh>moveOutlineRight</vh></v>
<v t="ekr.20070626112754.627"><vh>moveOutlineUp</vh>
<v t="ekr.20070626112754.628"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.629"><vh>promote</vh></v>
</v>
<v t="ekr.20070626112754.630"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20070626112754.631"><vh>NewHeadline</vh></v>
<v t="ekr.20070626112754.632"><vh>c.endEditing (calls tree.endEditLabel)</vh></v>
</v>
<v t="ekr.20070626112754.633"><vh>Fixed bug in nav button plugin</vh></v>
<v t="ekr.20070626112754.634"><vh>Fixed yet another cursor down bug</vh>
<v t="ekr.20070626112754.218"><vh>move cursor... (leoEditCommands)</vh>
<v t="ekr.20070626112754.219"><vh> helpers</vh>
<v t="ekr.20070626112754.220"><vh>extendHelper</vh></v>
<v t="ekr.20070626112754.221"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20070626112754.222"><vh>moveToHelper</vh></v>
<v t="ekr.20070626112754.223"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20070626112754.224"><vh>moveWordHelper</vh></v>
<v t="ekr.20070626112754.225"><vh>backSentenceHelper</vh></v>
<v t="ekr.20070626112754.226"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20070626112754.227"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.228"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.229"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20070626112754.230"><vh>buffers</vh></v>
<v t="ekr.20070626112754.231"><vh>characters</vh></v>
<v t="ekr.20070626112754.232"><vh>clear/set/ToggleExtendMode</vh></v>
<v t="ekr.20070626112754.233"><vh>exchangePointMark</vh></v>
<v t="ekr.20070626112754.234"><vh>extend-to-line</vh></v>
<v t="ekr.20070626112754.235"><vh>extend-to-sentence</vh></v>
<v t="ekr.20070626112754.236"><vh>extend-to-word</vh></v>
<v t="ekr.20070626112754.237"><vh>lines</vh></v>
<v t="ekr.20070626112754.238"><vh>movePastClose</vh></v>
<v t="ekr.20070626112754.239"><vh>paragraphs</vh></v>
<v t="ekr.20070626112754.240"><vh>sentences</vh></v>
<v t="ekr.20070626112754.241"><vh>words</vh></v>
</v>
</v>
<v t="ekr.20070626112754.635"><vh>Improved special case in moveOutlineUp</vh>
<v t="ekr.20070626112754.627"><vh>moveOutlineUp</vh>
<v t="ekr.20070626112754.628"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.636"><vh>Fixed crasher in rclicker plugin</vh></v>
<v t="ekr.20070626112754.637"><vh>Fixed problem with settings report</vh>
<v t="ekr.20070626112754.638"><vh>g.app.config.readSettingsFiles &amp; helpers</vh>
<v t="ekr.20070626112754.639"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
<v t="ekr.20070626112754.640"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20070626112754.641"><vh>g.app.config.updateSettings</vh></v>
</v>
</v>
<v t="ekr.20070626112754.642"><vh>Investigated bugs (these work for me)</vh>
<v t="ekr.20070626112754.643"><vh>Fix bugs in @url nodes (works for me)</vh></v>
<v t="ekr.20070626112754.644"><vh>Fix slideshow/button problem (works for me)</vh>
<v t="ekr.20070626112754.645"><vh>k.registerCommand</vh></v>
</v>
<v t="ekr.20070626112754.646"><vh>Investigated @file nosent glitch (works for me)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.647"><vh>Features</vh>
<v t="ekr.20070626112754.648"><vh>Warn on dubious section brackets</vh>
<v t="ekr.20070626112754.649"><vh>hasSectionName</vh></v>
</v>
<v t="ekr.20070626112754.650"><vh>Added leoBridge module</vh>
<v t="ekr.20070626112754.651"><vh>log stuff</vh>
<v t="ekr.20070626112754.652"><vh>app.writeWaitingLog</vh></v>
<v t="ekr.20070626112754.582"><vh>es, enl, ecnl</vh></v>
<v t="ekr.20070626112754.653"><vh>put and putnl (nullLog)</vh></v>
</v>
<v t="ekr.20070626112754.654"><vh>functions</vh>
<v t="ekr.20070626112754.655"><vh>run &amp; allies</vh>
<v t="ekr.20070626112754.656"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20070626112754.657"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20070626112754.658"><vh>adjustSysPath</vh></v>
<v t="ekr.20070626112754.659"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20070626112754.660"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20070626112754.661"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20070626112754.662"><vh>getBatchScript</vh></v>
<v t="ekr.20070626112754.663"><vh>isValidPython</vh></v>
<v t="ekr.20070626112754.664"><vh>reportDirectories</vh></v>
<v t="ekr.20070626112754.665"><vh>startPsyco</vh></v>
</v>
<v t="ekr.20070626112754.666"><vh>initLeo &amp; helpers</vh>
<v t="ekr.20070626112754.667"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20070626112754.668"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20070626112754.669"><vh>adjustSysPath</vh></v>
<v t="ekr.20070626112754.670"><vh>createGui</vh></v>
<v t="ekr.20070626112754.671"><vh>isValidPython</vh></v>
<v t="ekr.20070626112754.672"><vh>getLeoID</vh>
<v t="ekr.20070626112754.673"><vh>&lt;&lt; try to get leoID from sys.leoID&gt;&gt;</vh></v>
<v t="ekr.20070626112754.674"><vh>&lt;&lt; try to get leoID from "leoID.txt" &gt;&gt;</vh></v>
<v t="ekr.20070626112754.675"><vh>&lt;&lt; try to get leoID from os.getenv('USER') &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.676"><vh>reportDirectories</vh></v>
</v>
<v t="ekr.20070626112754.244"><vh>head key handlers (leoTree)</vh>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.247"><vh>onHeadlineKey</vh></v>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
<v t="ekr.20070626112754.248"><vh>endEditLabel</vh></v>
</v>
<v t="ekr.20070626112754.677"><vh>event_generate (baseTextWidget)</vh></v>
<v t="ekr.20070626112754.456"><vh>shortcutFromSetting (uses k.guiBindNamesDict)</vh>
<v t="ekr.20070626112754.457"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20070626112754.458"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20070626112754.459"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20070626112754.460"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20070626112754.461"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.678"><vh>classes</vh>
<v t="ekr.20070626112754.679"><vh>class baseTextWidget</vh>
<v t="ekr.20070626112754.680"><vh>Birth &amp; special methods (baseText)</vh></v>
<v t="ekr.20070626112754.681"><vh>baseTextWidget.onChar</vh></v>
<v t="ekr.20070626112754.682"><vh>Do-nothing</vh></v>
<v t="ekr.20070626112754.683"><vh>bindings (must be overridden in subclasses)</vh></v>
<v t="ekr.20070626112754.684"><vh>oops</vh></v>
<v t="ekr.20070626112754.685"><vh>Index conversion</vh>
<v t="ekr.20070626112754.686"><vh>w.toGuiIndex &amp; toPythonIndex</vh></v>
<v t="ekr.20070626112754.687"><vh>w.rowColToGuiIndex</vh></v>
</v>
<v t="ekr.20070626112754.688"><vh>Wrapper methods (widget-independent)</vh>
<v t="ekr.20070626112754.689"><vh>appendText</vh></v>
<v t="ekr.20070626112754.690"><vh>bind</vh></v>
<v t="ekr.20070626112754.691"><vh>clipboard_clear &amp; clipboard_append</vh></v>
<v t="ekr.20070626112754.692"><vh>delete</vh></v>
<v t="ekr.20070626112754.693"><vh>deleteTextSelection</vh></v>
<v t="ekr.20070626112754.677"><vh>event_generate (baseTextWidget)</vh></v>
<v t="ekr.20070626112754.694"><vh>flashCharacter (to do)</vh></v>
<v t="ekr.20070626112754.695"><vh>getFocus (baseText)</vh></v>
<v t="ekr.20070626112754.696"><vh>get</vh></v>
<v t="ekr.20070626112754.697"><vh>getAllText</vh></v>
<v t="ekr.20070626112754.698"><vh>getInsertPoint (baseText)</vh></v>
<v t="ekr.20070626112754.699"><vh>getName &amp; GetName</vh></v>
<v t="ekr.20070626112754.700"><vh>getSelectedText</vh></v>
<v t="ekr.20070626112754.701"><vh>getSelectionRange (baseText)</vh></v>
<v t="ekr.20070626112754.702"><vh>getYScrollPosition</vh></v>
<v t="ekr.20070626112754.703"><vh>getWidth</vh></v>
<v t="ekr.20070626112754.704"><vh>hasSelection</vh></v>
<v t="ekr.20070626112754.705"><vh>insert</vh></v>
<v t="ekr.20070626112754.706"><vh>indexIsVisible</vh></v>
<v t="ekr.20070626112754.707"><vh>replace</vh></v>
<v t="ekr.20070626112754.708"><vh>scrollLines</vh></v>
<v t="ekr.20070626112754.709"><vh>see &amp; seeInsertPoint</vh></v>
<v t="ekr.20070626112754.710"><vh>selectAllText</vh></v>
<v t="ekr.20070626112754.711"><vh>setAllText</vh></v>
<v t="ekr.20070626112754.712"><vh>setBackgroundColor &amp; SetBackgroundColour</vh></v>
<v t="ekr.20070626112754.713"><vh>setFocus (baseText)</vh></v>
<v t="ekr.20070626112754.714"><vh>setInsertPoint (baseText)</vh></v>
<v t="ekr.20070626112754.715"><vh>setSelectionRange (baseText)</vh></v>
<v t="ekr.20070626112754.716"><vh>setWidth</vh></v>
<v t="ekr.20070626112754.717"><vh>setYScrollPosition</vh></v>
<v t="ekr.20070626112754.718"><vh>tags (to-do)</vh>
<v t="ekr.20070626112754.719"><vh>mark_set (to be removed)</vh></v>
<v t="ekr.20070626112754.720"><vh>tag_add</vh></v>
<v t="ekr.20070626112754.721"><vh>tag_configure &amp; helper</vh>
<v t="ekr.20070626112754.722"><vh>tkColorToWxColor</vh></v>
</v>
<v t="ekr.20070626112754.723"><vh>tag_delete (NEW)</vh></v>
<v t="ekr.20070626112754.724"><vh>tag_names</vh></v>
<v t="ekr.20070626112754.725"><vh>tag_ranges</vh></v>
<v t="ekr.20070626112754.726"><vh>tag_remove</vh></v>
<v t="ekr.20070626112754.727"><vh>yview</vh></v>
</v>
<v t="ekr.20070626112754.728"><vh>xyToGui/PythonIndex</vh></v>
</v>
</v>
<v t="ekr.20070626112754.399"><vh>class findTab (leoFind)</vh>
<v t="ekr.20070626112754.400"><vh>findTab.__init__</vh></v>
<v t="ekr.20070626112754.401"><vh>Must be defined in subclasses</vh></v>
<v t="ekr.20070626112754.402"><vh>Callbacks</vh>
<v t="ekr.20070626112754.403"><vh>findButtonCallback</vh></v>
<v t="ekr.20070626112754.404"><vh>hideTab</vh></v>
</v>
<v t="ekr.20070626112754.405"><vh> Top level</vh>
<v t="ekr.20070626112754.406"><vh>change/ThenFindCommand</vh></v>
<v t="ekr.20070626112754.407"><vh>changeAllCommand</vh></v>
<v t="ekr.20070626112754.408"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20070626112754.409"><vh>findAgainCommand</vh></v>
<v t="ekr.20070626112754.410"><vh>findAllCommand</vh></v>
<v t="ekr.20070626112754.411"><vh>findNext/PrefCommand</vh></v>
</v>
</v>
<v t="ekr.20070626112754.729"><vh>class leoBody</vh>
<v t="ekr.20070626112754.730"><vh>leoBody.__init__</vh>
<v t="ekr.20070626112754.731"><vh>leoBody.mustBeDefinedInSubclasses</vh></v>
<v t="ekr.20070626112754.732"><vh>define leoBody.mustBeDefinedOnlyInBaseClass</vh></v>
</v>
<v t="ekr.20070626112754.733"><vh>leoBody: must be defined in subclasses</vh></v>
<v t="ekr.20070626112754.734"><vh>leoBody: must be defined in the base class</vh>
<v t="ekr.20070626112754.735"><vh>Coloring</vh></v>
<v t="ekr.20070626112754.736"><vh>Editors (leoBody)</vh>
<v t="ekr.20070626112754.737"><vh>entries</vh>
<v t="ekr.20070626112754.738"><vh>addEditor</vh>
<v t="ekr.20070626112754.739"><vh>&lt;&lt; create text widget w &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.740"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20070626112754.741"><vh>deleteEditor</vh></v>
<v t="ekr.20070626112754.742"><vh>findEditorForChapter (leoBody)</vh></v>
<v t="ekr.20070626112754.743"><vh>select/unselectLabel</vh></v>
<v t="ekr.20070626112754.50"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20070626112754.51"><vh>selectEditorHelper</vh>
<v t="ekr.20070626112754.52"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.744"><vh>assignPositionToEditor</vh></v>
<v t="ekr.20070626112754.745"><vh>updateEditors</vh></v>
</v>
<v t="ekr.20070626112754.746"><vh>utils</vh>
<v t="ekr.20070626112754.747"><vh>computeLabel</vh></v>
<v t="ekr.20070626112754.748"><vh>createChapterIvar</vh></v>
<v t="ekr.20070626112754.749"><vh>ensurePositionExists</vh></v>
<v t="ekr.20070626112754.750"><vh>inactivateActiveEditor</vh></v>
<v t="ekr.20070626112754.751"><vh>recolorWidget</vh></v>
<v t="ekr.20070626112754.752"><vh>switchToChapter (leoBody)</vh></v>
<v t="ekr.20070626112754.753"><vh>updateInjectedIvars</vh></v>
</v>
</v>
<v t="ekr.20070626112754.754"><vh>onBodyChanged (leoBody)</vh>
<v t="ekr.20070626112754.755"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20070626112754.756"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.757"><vh>onClick</vh></v>
<v t="ekr.20070626112754.758"><vh>oops</vh></v>
<v t="ekr.20070626112754.759"><vh>Text (leoBody)</vh>
<v t="ekr.20070626112754.203"><vh>getInsertLines</vh></v>
<v t="ekr.20070626112754.760"><vh>getSelectionAreas</vh></v>
<v t="ekr.20070626112754.202"><vh>getSelectionLines</vh></v>
<v t="ekr.20070626112754.200"><vh>setSelectionAreas</vh></v>
<v t="ekr.20070626112754.761"><vh>get/setYScrollPosition</vh></v>
</v>
<v t="ekr.20070626112754.762"><vh>Text Wrappers (base class)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.763"><vh>class leoGui</vh>
<v t="ekr.20070626112754.764"><vh>&lt;&lt; define leoGui file types &gt;&gt; (not used yet)</vh></v>
<v t="ekr.20070626112754.765"><vh>app.gui Birth &amp; death</vh>
<v t="ekr.20070626112754.766"><vh> leoGui.__init__</vh></v>
<v t="ekr.20070626112754.767"><vh>leoGui.mustBeDefinedOnlyInBaseClass</vh></v>
<v t="ekr.20070626112754.768"><vh>leoGui.mustBeDefinedInSubclasses</vh></v>
</v>
<v t="ekr.20070626112754.769"><vh>Must be defined only in base class</vh>
<v t="ekr.20070626112754.770"><vh>guiName</vh></v>
<v t="ekr.20070626112754.771"><vh>setScript</vh></v>
</v>
<v t="ekr.20070626112754.772"><vh>Must be defined in subclasses</vh>
<v t="ekr.20070626112754.773"><vh>app.gui create &amp; destroy</vh>
<v t="ekr.20070626112754.774"><vh>createRootWindow</vh></v>
<v t="ekr.20070626112754.775"><vh>destroySelf</vh></v>
<v t="ekr.20070626112754.776"><vh>killGui</vh></v>
<v t="ekr.20070626112754.777"><vh>recreateRootWindow</vh></v>
<v t="ekr.20070626112754.778"><vh>runMainLoop</vh></v>
</v>
<v t="ekr.20070626112754.779"><vh>app.gui dialogs</vh></v>
<v t="ekr.20070626112754.780"><vh>app.gui.createKeyHandlerClass</vh></v>
<v t="ekr.20070626112754.781"><vh>app.gui file dialogs</vh></v>
<v t="ekr.20070626112754.782"><vh>app.gui panels</vh></v>
<v t="ekr.20070626112754.783"><vh>app.gui utils</vh>
<v t="ekr.20070626112754.784"><vh>Clipboard (leoGui)</vh></v>
<v t="ekr.20070626112754.785"><vh>color</vh></v>
<v t="ekr.20070626112754.786"><vh>Dialog utils</vh></v>
<v t="ekr.20070626112754.787"><vh>Events (leoGui)</vh></v>
<v t="ekr.20070626112754.788"><vh>getFullVersion</vh></v>
<v t="ekr.20070626112754.789"><vh>Focus</vh></v>
<v t="ekr.20070626112754.790"><vh>Font (leoGui)</vh></v>
<v t="ekr.20070626112754.791"><vh>Idle time</vh></v>
<v t="ekr.20070626112754.792"><vh>makeScriptButton</vh></v>
</v>
</v>
<v t="ekr.20070626112754.793"><vh>May be defined in subclasses</vh>
<v t="ekr.20070626112754.794"><vh>finishCreate (may be overridden in subclasses)</vh></v>
<v t="ekr.20070626112754.795"><vh>oops</vh></v>
<v t="ekr.20070626112754.796"><vh>widget_name (leoGui)</vh></v>
<v t="ekr.20070626112754.797"><vh>class leoKeyEvent (leoGui)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.798"><vh>class leoLog</vh>
<v t="ekr.20070626112754.799"><vh> ctor (leoLog)</vh></v>
<v t="ekr.20070626112754.800"><vh>Must be defined in the base class</vh></v>
<v t="ekr.20070626112754.801"><vh>May be overridden</vh>
<v t="ekr.20070626112754.802"><vh>clearTab</vh></v>
<v t="ekr.20070626112754.803"><vh>createTab</vh></v>
<v t="ekr.20070626112754.804"><vh>cycleTabFocus</vh></v>
<v t="ekr.20070626112754.805"><vh>deleteTab</vh></v>
<v t="ekr.20070626112754.806"><vh>hideTab</vh></v>
<v t="ekr.20070626112754.807"><vh>getSelectedTab</vh></v>
<v t="ekr.20070626112754.808"><vh>lower/raiseTab</vh></v>
<v t="ekr.20070626112754.809"><vh>numberOfVisibleTabs</vh></v>
<v t="ekr.20070626112754.810"><vh>renameTab</vh></v>
<v t="ekr.20070626112754.811"><vh>selectTab</vh></v>
</v>
<v t="ekr.20070626112754.812"><vh>Must be overridden</vh></v>
<v t="ekr.20070626112754.813"><vh>leoLog.oops</vh></v>
</v>
<v t="ekr.20070626112754.814"><vh>class leoTkinterLog</vh>
<v t="ekr.20070626112754.815"><vh>tkLog Birth</vh>
<v t="ekr.20070626112754.816"><vh>tkLog.__init__</vh></v>
<v t="ekr.20070626112754.817"><vh>tkLog.createControl</vh></v>
<v t="ekr.20070626112754.421"><vh>tkLog.finishCreate</vh></v>
<v t="ekr.20070626112754.818"><vh>tkLog.createTextWidget</vh></v>
<v t="ekr.20070626112754.819"><vh>tkLog.makeTabMenu</vh></v>
</v>
<v t="ekr.20070626112754.820"><vh>Config &amp; get/saveState</vh>
<v t="ekr.20070626112754.821"><vh>tkLog.configureBorder &amp; configureFont</vh></v>
<v t="ekr.20070626112754.822"><vh>tkLog.getFontConfig</vh></v>
<v t="ekr.20070626112754.823"><vh>tkLog.restoreAllState</vh></v>
<v t="ekr.20070626112754.824"><vh>tkLog.saveAllState</vh></v>
<v t="ekr.20070626112754.825"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20070626112754.826"><vh>tkLog.setFontFromConfig</vh></v>
</v>
<v t="ekr.20070626112754.827"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20070626112754.828"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20070626112754.829"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20070626112754.830"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20070626112754.831"><vh>put &amp; putnl (tkLog)</vh>
<v t="ekr.20070626112754.832"><vh>put</vh>
<v t="ekr.20070626112754.833"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20070626112754.834"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.835"><vh>putnl</vh></v>
</v>
<v t="ekr.20070626112754.836"><vh>Tab (TkLog)</vh>
<v t="ekr.20070626112754.837"><vh>clearTab</vh></v>
<v t="ekr.20070626112754.838"><vh>createTab</vh>
<v t="ekr.20070626112754.839"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.840"><vh>cycleTabFocus</vh></v>
<v t="ekr.20070626112754.422"><vh>deleteTab</vh></v>
<v t="ekr.20070626112754.841"><vh>hideTab</vh></v>
<v t="ekr.20070626112754.842"><vh>getSelectedTab</vh></v>
<v t="ekr.20070626112754.843"><vh>lower/raiseTab</vh></v>
<v t="ekr.20070626112754.844"><vh>numberOfVisibleTabs</vh></v>
<v t="ekr.20070626112754.845"><vh>renameTab</vh></v>
<v t="ekr.20070626112754.846"><vh>selectTab</vh></v>
<v t="ekr.20070626112754.450"><vh>setTabBindings</vh></v>
<v t="ekr.20070626112754.847"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20070626112754.848"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20070626112754.849"><vh>newTabFromMenu</vh></v>
<v t="ekr.20070626112754.850"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20070626112754.851"><vh>getTabName</vh></v>
</v>
</v>
<v t="ekr.20070626112754.852"><vh>tkLog color tab stuff</vh>
<v t="ekr.20070626112754.853"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20070626112754.854"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
<v t="ekr.20070626112754.855"><vh>&lt;&lt; define colors &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.856"><vh>tkLog font tab stuff</vh>
<v t="ekr.20070626112754.857"><vh>createFontPicker</vh>
<v t="ekr.20070626112754.858"><vh>&lt;&lt; create the frames &gt;&gt;</vh></v>
<v t="ekr.20070626112754.859"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20070626112754.860"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20070626112754.861"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20070626112754.862"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20070626112754.863"><vh>&lt;&lt; create the sample text widget &gt;&gt;</vh></v>
<v t="ekr.20070626112754.864"><vh>&lt;&lt; create and bind the callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.865"><vh>createBindings (fontPicker)</vh></v>
<v t="ekr.20070626112754.866"><vh>getFont</vh></v>
<v t="ekr.20070626112754.867"><vh>setFont</vh></v>
<v t="ekr.20070626112754.868"><vh>hideFontTab</vh></v>
</v>
</v>
<v t="ekr.20070626112754.869"><vh>class nullBody (leoBody)</vh>
<v t="ekr.20070626112754.870"><vh> nullBody.__init__</vh></v>
<v t="ekr.20070626112754.871"><vh>Utils (internal use)</vh>
<v t="ekr.20070626112754.872"><vh>findStartOfLine</vh></v>
<v t="ekr.20070626112754.873"><vh>scanToStartOfLine</vh></v>
<v t="ekr.20070626112754.874"><vh>scanToEndOfLine</vh></v>
</v>
<v t="ekr.20070626112754.875"><vh>nullBody: leoBody interface</vh></v>
</v>
<v t="ekr.20070626112754.876"><vh>class nullFindTab class (findTab)</vh>
<v t="ekr.20070626112754.877"><vh>Birth (nullFindTab)</vh>
<v t="ekr.20070626112754.878"><vh> ctor (nullFindTab)</vh></v>
<v t="ekr.20070626112754.879"><vh>initGui</vh></v>
<v t="ekr.20070626112754.880"><vh>init</vh>
<v t="ekr.20070626112754.881"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20070626112754.882"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.883"><vh>&lt;&lt; set checkboxes from ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.884"><vh>createBindings</vh></v>
<v t="ekr.20070626112754.885"><vh>createFrame</vh>
<v t="ekr.20070626112754.886"><vh>createFindChangeAreas</vh></v>
<v t="ekr.20070626112754.887"><vh>createBoxes</vh></v>
<v t="ekr.20070626112754.888"><vh>createButtons (not used)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.889"><vh>class svar (nullFindTab)</vh></v>
<v t="ekr.20070626112754.890"><vh>class buttonWidget (nullFindTab)</vh></v>
<v t="ekr.20070626112754.891"><vh>Options</vh>
<v t="ekr.20070626112754.892"><vh>getOption</vh></v>
<v t="ekr.20070626112754.893"><vh>setOption</vh></v>
<v t="ekr.20070626112754.894"><vh>toggleOption</vh></v>
</v>
</v>
<v t="ekr.20070626112754.895"><vh>class nullFrame</vh>
<v t="ekr.20070626112754.896"><vh> ctor</vh></v>
<v t="ekr.20070626112754.897"><vh>destroySelf</vh></v>
<v t="ekr.20070626112754.898"><vh>finishCreate</vh></v>
<v t="ekr.20070626112754.899"><vh>Overrides</vh>
<v t="ekr.20070626112754.900"><vh>Config...</vh>
<v t="ekr.20070626112754.901"><vh>setTopGeometry</vh></v>
</v>
<v t="ekr.20070626112754.902"><vh>Gui-dependent commands</vh></v>
<v t="ekr.20070626112754.903"><vh>Window...</vh></v>
</v>
</v>
<v t="ekr.20070626112754.904"><vh>class nullGui (leoGui)</vh>
<v t="ekr.20070626112754.905"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.906"><vh> nullGui.__init__</vh></v>
<v t="ekr.20070626112754.907"><vh>nullGui.createKeyHandlerClass</vh></v>
<v t="ekr.20070626112754.908"><vh>runMainLoop</vh></v>
</v>
<v t="ekr.20070626112754.909"><vh>isTextWidget</vh></v>
<v t="ekr.20070626112754.910"><vh>oops</vh></v>
<v t="ekr.20070626112754.911"><vh>do nothings</vh></v>
<v t="ekr.20070626112754.912"><vh>app.gui panels</vh></v>
<v t="ekr.20070626112754.913"><vh>dialogs (nullGui)</vh></v>
<v t="ekr.20070626112754.914"><vh>simulateDialog</vh></v>
</v>
<v t="ekr.20070626112754.915"><vh>class nullLog</vh>
<v t="ekr.20070626112754.916"><vh>Birth</vh>
<v t="ekr.20070626112754.917"><vh>nullLog.__init__</vh></v>
<v t="ekr.20070626112754.918"><vh>createControl</vh></v>
<v t="ekr.20070626112754.919"><vh>createTextWidget</vh></v>
</v>
<v t="ekr.20070626112754.920"><vh>oops</vh></v>
<v t="ekr.20070626112754.653"><vh>put and putnl (nullLog)</vh></v>
<v t="ekr.20070626112754.921"><vh>tabs</vh></v>
</v>
<v t="ekr.20070626112754.922"><vh>class nullStatusLineClass</vh>
<v t="ekr.20070626112754.923"><vh> nullStatusLineClass.ctor</vh></v>
<v t="ekr.20070626112754.924"><vh>methods</vh></v>
</v>
<v t="ekr.20070626112754.925"><vh>class nullTree</vh>
<v t="ekr.20070626112754.926"><vh> nullTree.__init__</vh></v>
<v t="ekr.20070626112754.927"><vh>printWidgets</vh></v>
<v t="ekr.20070626112754.928"><vh>Overrides</vh>
<v t="ekr.20070626112754.929"><vh>Colors &amp; fonts</vh></v>
<v t="ekr.20070626112754.930"><vh>Drawing &amp; scrolling</vh></v>
<v t="ekr.20070626112754.931"><vh>Headlines</vh>
<v t="ekr.20070626112754.932"><vh>editLabel (nullTree) same as tkTree)</vh></v>
<v t="ekr.20070626112754.933"><vh>setHeadline (nullTree)</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.934"><vh>class stringTextWidget (stringTextWidget)</vh>
<v t="ekr.20070626112754.935"><vh>ctor</vh></v>
<v t="ekr.20070626112754.936"><vh>Overrides</vh></v>
<v t="ekr.20070626112754.937"><vh>setSelectionRange (stringText)</vh></v>
</v>
<v t="ekr.20070626112754.938"><vh>class unitTestGui (nullGui)</vh>
<v t="ekr.20070626112754.939"><vh> ctor (unitTestGui)</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.940"><vh>Added new search path for pluginsManager.txt</vh>
<v t="ekr.20070626112754.941"><vh>Request</vh></v>
<v t="ekr.20070626112754.424"><vh>loadHandlers &amp; helper</vh>
<v t="ekr.20070626112754.425"><vh>&lt;&lt; set enabled_files from pluginsManager.txt &gt;&gt;</vh></v>
<v t="ekr.20070626112754.426"><vh>getEnabledFiles</vh></v>
</v>
</v>
<v t="ekr.20070626112754.942"><vh>Added support for @enabled-plugins in settings files</vh>
<v t="ekr.20070626112754.943"><vh>Getters</vh></v>
<v t="ekr.20070626112754.944"><vh>Getters... (g.app.config)</vh>
<v t="ekr.20070626112754.945"><vh>canonicalizeSettingName (munge)</vh></v>
<v t="ekr.20070626112754.946"><vh>config.findSettingsPosition</vh></v>
<v t="ekr.20070626112754.947"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20070626112754.948"><vh>getValFromDict</vh></v>
<v t="ekr.20070626112754.949"><vh>typesMatch</vh></v>
</v>
<v t="ekr.20070626112754.950"><vh>exists (g.app.config)</vh></v>
<v t="ekr.20070626112754.951"><vh>getAbbrevDict</vh></v>
<v t="ekr.20070626112754.952"><vh>getBool</vh></v>
<v t="ekr.20070626112754.953"><vh>getColor</vh></v>
<v t="ekr.20070626112754.954"><vh>getDirectory</vh></v>
<v t="ekr.20070626112754.955"><vh>getEnabledPlugins</vh></v>
<v t="ekr.20070626112754.956"><vh>getFloat</vh></v>
<v t="ekr.20070626112754.957"><vh>getFontFromParams (config)</vh></v>
<v t="ekr.20070626112754.958"><vh>getInt</vh></v>
<v t="ekr.20070626112754.959"><vh>getLanguage</vh></v>
<v t="ekr.20070626112754.960"><vh>getOpenWith</vh></v>
<v t="ekr.20070626112754.961"><vh>getRatio</vh></v>
<v t="ekr.20070626112754.962"><vh>getRecentFiles</vh></v>
<v t="ekr.20070626112754.963"><vh>getShortcut (config)</vh></v>
<v t="ekr.20070626112754.964"><vh>getString</vh></v>
<v t="ekr.20070626112754.965"><vh>setCommandsIvars</vh></v>
<v t="ekr.20070626112754.966"><vh>settingsRoot</vh></v>
</v>
<v t="ekr.20070626112754.967"><vh>kind handlers (parserBaseClass)</vh>
<v t="ekr.20070626112754.968"><vh>doAbbrev</vh></v>
<v t="ekr.20070626112754.969"><vh>doBool</vh></v>
<v t="ekr.20070626112754.970"><vh>doColor</vh></v>
<v t="ekr.20070626112754.971"><vh>doDirectory &amp; doPath</vh></v>
<v t="ekr.20070626112754.972"><vh>doEnabledPlugins</vh></v>
<v t="ekr.20070626112754.973"><vh>doFloat</vh></v>
<v t="ekr.20070626112754.974"><vh>doFont</vh></v>
<v t="ekr.20070626112754.975"><vh>doIf</vh></v>
<v t="ekr.20070626112754.976"><vh>doIfGui</vh></v>
<v t="ekr.20070626112754.977"><vh>doIfPlatform</vh></v>
<v t="ekr.20070626112754.978"><vh>doIgnore</vh></v>
<v t="ekr.20070626112754.979"><vh>doInt</vh></v>
<v t="ekr.20070626112754.980"><vh>doInts</vh></v>
<v t="ekr.20070626112754.981"><vh>doMode (ParserBaseClass)</vh>
<v t="ekr.20070626112754.982"><vh>&lt;&lt; Compute modeName &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.983"><vh>doOpenWith (ParserBaseClass)</vh></v>
<v t="ekr.20070626112754.984"><vh>doPage</vh></v>
<v t="ekr.20070626112754.985"><vh>doRatio</vh></v>
<v t="ekr.20070626112754.986"><vh>doShortcuts (ParserBaseClass)</vh></v>
<v t="ekr.20070626112754.987"><vh>doString</vh></v>
<v t="ekr.20070626112754.988"><vh>doStrings</vh></v>
</v>
<v t="ekr.20070626112754.638"><vh>g.app.config.readSettingsFiles &amp; helpers</vh>
<v t="ekr.20070626112754.639"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
<v t="ekr.20070626112754.640"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20070626112754.641"><vh>g.app.config.updateSettings</vh></v>
</v>
<v t="ekr.20070626112754.989"><vh>loadOnePlugin</vh></v>
<v t="ekr.20070626112754.655"><vh>run &amp; allies</vh>
<v t="ekr.20070626112754.656"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20070626112754.657"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20070626112754.658"><vh>adjustSysPath</vh></v>
<v t="ekr.20070626112754.659"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20070626112754.660"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20070626112754.661"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20070626112754.662"><vh>getBatchScript</vh></v>
<v t="ekr.20070626112754.663"><vh>isValidPython</vh></v>
<v t="ekr.20070626112754.664"><vh>reportDirectories</vh></v>
<v t="ekr.20070626112754.665"><vh>startPsyco</vh></v>
</v>
<v t="ekr.20070626112754.972"><vh>doEnabledPlugins</vh></v>
<v t="ekr.20070626112754.990"><vh>g.openWithFileName</vh></v>
<v t="ekr.20070626112754.991"><vh>doPlugins</vh></v>
<v t="ekr.20070626112754.424"><vh>loadHandlers &amp; helper</vh>
<v t="ekr.20070626112754.425"><vh>&lt;&lt; set enabled_files from pluginsManager.txt &gt;&gt;</vh></v>
<v t="ekr.20070626112754.426"><vh>getEnabledFiles</vh></v>
</v>
</v>
<v t="ekr.20070626112754.992"><vh>Made Leo's core gui-indenpendent)</vh>
<v t="ekr.20070626112754.993"><vh> Calls to w.xxx</vh>
<v t="ekr.20070626112754.994"><vh>find w.xxx script</vh></v>
<v t="ekr.20070626112754.995"><vh>Script results</vh></v>
</v>
<v t="ekr.20070626112754.996"><vh>What I did</vh>
<v t="ekr.20070626112754.997"><vh>Moved cut/copy/pasteText into base leoFrame class</vh>
<v t="ekr.20070626112754.998"><vh>Cut/Copy/Paste (leoFrame)</vh>
<v t="ekr.20070626112754.999"><vh>copyText</vh></v>
<v t="ekr.20070626112754.1000"><vh>leoFrame.cutText</vh></v>
<v t="ekr.20070626112754.1001"><vh>leoFrame.pasteText</vh></v>
<v t="ekr.20070626112754.1002"><vh>OnPaste (To support middle-button paste)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1003"><vh>Replaced leoTextWidgetClass by plainTextWidget or bodyTextWidget</vh></v>
<v t="ekr.20070626112754.1004"><vh>Removed w.configure &amp; w.cget from Leo's core</vh>
<v t="ekr.20070626112754.1001"><vh>leoFrame.pasteText</vh></v>
<v t="ekr.20070626112754.1000"><vh>leoFrame.cutText</vh></v>
<v t="ekr.20070626112754.1005"><vh>c.setHeadString</vh></v>
</v>
<v t="ekr.20070626112754.1006"><vh>Removed Tk code from minibufferFind class</vh>
<v t="ekr.20070626112754.306"><vh>class minibufferFind( (the findHandler)</vh>
<v t="ekr.20070626112754.307"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20070626112754.308"><vh> Options (minibufferFind)</vh>
<v t="ekr.20070626112754.309"><vh>setFindScope</vh></v>
<v t="ekr.20070626112754.310"><vh>get/set/toggleOption (minibufferFind)</vh></v>
<v t="ekr.20070626112754.311"><vh>showFindOptions</vh></v>
<v t="ekr.20070626112754.312"><vh>setupChangePattern</vh></v>
<v t="ekr.20070626112754.313"><vh>setupSearchPattern</vh></v>
</v>
<v t="ekr.20070626112754.314"><vh>addChangeStringToLabel</vh></v>
<v t="ekr.20070626112754.315"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20070626112754.316"><vh>changeAll</vh></v>
<v t="ekr.20070626112754.317"><vh>cloneFindAll</vh></v>
<v t="ekr.20070626112754.318"><vh>findAgain</vh></v>
<v t="ekr.20070626112754.319"><vh>findAll</vh></v>
<v t="ekr.20070626112754.320"><vh>generalChangeHelper</vh></v>
<v t="ekr.20070626112754.321"><vh>generalSearchHelper</vh></v>
<v t="ekr.20070626112754.322"><vh>lastStateHelper</vh></v>
<v t="ekr.20070626112754.323"><vh>replaceString</vh></v>
<v t="ekr.20070626112754.324"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20070626112754.325"><vh>seachForward/Backward</vh></v>
<v t="ekr.20070626112754.326"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20070626112754.327"><vh>setupArgs</vh></v>
<v t="ekr.20070626112754.328"><vh>stateZeroHelper</vh></v>
<v t="ekr.20070626112754.329"><vh>updateChange/FindList</vh></v>
<v t="ekr.20070626112754.330"><vh>wordSearchBackward/Forward</vh></v>
</v>
<v t="ekr.20070626112754.1007"><vh>Support for minibufferFind class (tkFindTab)</vh>
<v t="ekr.20070626112754.1008"><vh>getOption</vh></v>
<v t="ekr.20070626112754.1009"><vh>setOption</vh></v>
<v t="ekr.20070626112754.1010"><vh>toggleOption</vh></v>
</v>
<v t="ekr.20070626112754.308"><vh> Options (minibufferFind)</vh>
<v t="ekr.20070626112754.309"><vh>setFindScope</vh></v>
<v t="ekr.20070626112754.310"><vh>get/set/toggleOption (minibufferFind)</vh></v>
<v t="ekr.20070626112754.311"><vh>showFindOptions</vh></v>
<v t="ekr.20070626112754.312"><vh>setupChangePattern</vh></v>
<v t="ekr.20070626112754.313"><vh>setupSearchPattern</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1011"><vh>Moved Tk color code into tkLog</vh>
<v t="ekr.20070626112754.1012"><vh>show-colors</vh></v>
<v t="ekr.20070626112754.852"><vh>tkLog color tab stuff</vh>
<v t="ekr.20070626112754.853"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20070626112754.854"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
<v t="ekr.20070626112754.855"><vh>&lt;&lt; define colors &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1013"><vh>Moved Tk font code into tkLog</vh>
<v t="ekr.20070626112754.1014"><vh>editCommands.show-fonts &amp; helpers</vh></v>
<v t="ekr.20070626112754.856"><vh>tkLog font tab stuff</vh>
<v t="ekr.20070626112754.857"><vh>createFontPicker</vh>
<v t="ekr.20070626112754.858"><vh>&lt;&lt; create the frames &gt;&gt;</vh></v>
<v t="ekr.20070626112754.859"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20070626112754.860"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20070626112754.861"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20070626112754.862"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20070626112754.863"><vh>&lt;&lt; create the sample text widget &gt;&gt;</vh></v>
<v t="ekr.20070626112754.864"><vh>&lt;&lt; create and bind the callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.865"><vh>createBindings (fontPicker)</vh></v>
<v t="ekr.20070626112754.866"><vh>getFont</vh></v>
<v t="ekr.20070626112754.867"><vh>setFont</vh></v>
<v t="ekr.20070626112754.868"><vh>hideFontTab</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1015"><vh>Refactored tk spell code tkSpellTab</vh>
<v t="ekr.20070626112754.1016"><vh>tkGui.createSpellTab</vh></v>
<v t="ekr.20070626112754.413"><vh>openSpellTab</vh>
<v t="ekr.20070626112754.414"><vh>commands...</vh></v>
</v>
<v t="ekr.20070626112754.1017"><vh>class spellTabHandler (leoFind.leoFind)</vh>
<v t="ekr.20070626112754.1018"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.1019"><vh>spellTabHandler.__init__</vh></v>
<v t="ekr.20070626112754.1020"><vh>init_aspell</vh></v>
<v t="ekr.20070626112754.1021"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20070626112754.1022"><vh>Commands</vh>
<v t="ekr.20070626112754.1023"><vh>add</vh></v>
<v t="ekr.20070626112754.1024"><vh>change (spellTab)</vh></v>
<v t="ekr.20070626112754.1025"><vh>find &amp; helpers</vh>
<v t="ekr.20070626112754.1026"><vh>findNextMisspelledWord</vh>
<v t="ekr.20070626112754.1027"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1028"><vh>findNextWord</vh></v>
</v>
<v t="ekr.20070626112754.1029"><vh>hide</vh></v>
<v t="ekr.20070626112754.1030"><vh>ignore</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1031"><vh>class tkSpellTab</vh>
<v t="ekr.20070626112754.1032"><vh>tkSpellTab.__init__</vh></v>
<v t="ekr.20070626112754.1033"><vh>createBindings</vh></v>
<v t="ekr.20070626112754.1034"><vh>createFrame</vh>
<v t="ekr.20070626112754.1035"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1036"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1037"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1038"><vh>Event handlers</vh>
<v t="ekr.20070626112754.1039"><vh>onAddButton</vh></v>
<v t="ekr.20070626112754.1040"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20070626112754.1041"><vh>onFindButton</vh></v>
<v t="ekr.20070626112754.1042"><vh>onHideButton</vh></v>
<v t="ekr.20070626112754.1043"><vh>onIgnoreButton</vh></v>
<v t="ekr.20070626112754.1044"><vh>onMap</vh></v>
<v t="ekr.20070626112754.1045"><vh>onSelectListBox</vh></v>
</v>
<v t="ekr.20070626112754.1046"><vh>Helpers</vh>
<v t="ekr.20070626112754.1047"><vh>bringToFront</vh></v>
<v t="ekr.20070626112754.1048"><vh>fillbox</vh></v>
<v t="ekr.20070626112754.1049"><vh>getSuggestion</vh></v>
<v t="ekr.20070626112754.1050"><vh>update</vh></v>
<v t="ekr.20070626112754.1051"><vh>updateButtons (spellTab)</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1052"><vh>Replaced w.clipboard* by gui methods</vh>
<v t="ekr.20070626112754.784"><vh>Clipboard (leoGui)</vh></v>
<v t="ekr.20070626112754.1053"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20070626112754.1054"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20070626112754.1055"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20070626112754.27"><vh>kill, killLine</vh></v>
<v t="ekr.20070626112754.28"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
</v>
<v t="ekr.20070626112754.1056"><vh>Replaced tkFileDialog by gui.runOpenFileDialog</vh>
<v t="ekr.20070626112754.1057"><vh>readAbbreviations</vh></v>
<v t="ekr.20070626112754.1058"><vh>writeAbbreviations</vh></v>
<v t="ekr.20070626112754.1059"><vh>getReadableTextFile</vh></v>
<v t="ekr.20070626112754.1060"><vh>loadFile &amp; helpers</vh>
<v t="ekr.20070626112754.1061"><vh>_loadMacros</vh></v>
</v>
<v t="ekr.20070626112754.1062"><vh>saveFile</vh></v>
<v t="ekr.20070626112754.1063"><vh>saveMacros &amp; helper</vh>
<v t="ekr.20070626112754.1064"><vh>_saveMacros</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1065"><vh>Removed references to Tk and  Pmw from Leo's core</vh>
<v t="ekr.20070626112754.1066"><vh>_executeMacro (test)</vh></v>
<v t="ekr.20070626112754.1067"><vh>c.signOnWithVersion</vh></v>
<v t="ekr.20070626112754.1068"><vh>getFullVersion</vh></v>
<v t="ekr.20070626112754.1069"><vh>g.createStandAloneTkApp</vh></v>
<v t="ekr.20070626112754.1070"><vh>cantImportDialog &amp; helpers</vh>
<v t="ekr.20070626112754.1071"><vh>createDialogFrame</vh></v>
<v t="ekr.20070626112754.1072"><vh>createDialogButtons</vh></v>
<v t="ekr.20070626112754.1073"><vh>center</vh></v>
<v t="ekr.20070626112754.1074"><vh>get_window_info</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1075"><vh>class leoTkTextWidget (Tk.Text)</vh>
<v t="ekr.20070626112754.1076"><vh>plainTextWidget.__init__</vh></v>
<v t="ekr.20070626112754.1077"><vh>bindings (not used)</vh></v>
<v t="ekr.20070626112754.63"><vh>Index conversion (leoTextWidget)</vh>
<v t="ekr.20070626112754.64"><vh>w.toGuiIndex</vh></v>
<v t="ekr.20070626112754.65"><vh>w.toPythonIndex</vh></v>
<v t="ekr.20070626112754.66"><vh>w.rowColToGuiIndex</vh></v>
</v>
<v t="ekr.20070626112754.1078"><vh>getName (Tk.Text)</vh></v>
<v t="ekr.20070626112754.1079"><vh>_setSelectionRange</vh></v>
<v t="ekr.20070626112754.1080"><vh>Wrapper methods (leoTextWidget)</vh>
<v t="ekr.20070626112754.1081"><vh>delete</vh></v>
<v t="ekr.20070626112754.82"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.1082"><vh>get</vh></v>
<v t="ekr.20070626112754.1083"><vh>getAllText</vh></v>
<v t="ekr.20070626112754.1084"><vh>getInsertPoint</vh></v>
<v t="ekr.20070626112754.1085"><vh>getSelectedText</vh></v>
<v t="ekr.20070626112754.1086"><vh>getSelectionRange</vh></v>
<v t="ekr.20070626112754.1087"><vh>getYScrollPosition</vh></v>
<v t="ekr.20070626112754.1088"><vh>getWidth</vh></v>
<v t="ekr.20070626112754.1089"><vh>hasSelection</vh></v>
<v t="ekr.20070626112754.1090"><vh>insert</vh></v>
<v t="ekr.20070626112754.1091"><vh>indexIsVisible</vh></v>
<v t="ekr.20070626112754.1092"><vh>mark_set NO LONGER USED</vh></v>
<v t="ekr.20070626112754.1093"><vh>replace</vh></v>
<v t="ekr.20070626112754.1094"><vh>see</vh></v>
<v t="ekr.20070626112754.1095"><vh>seeInsertPoint</vh></v>
<v t="ekr.20070626112754.269"><vh>selectAllText</vh></v>
<v t="ekr.20070626112754.1096"><vh>setAllText</vh></v>
<v t="ekr.20070626112754.1097"><vh>setBackgroundColor</vh></v>
<v t="ekr.20070626112754.61"><vh>setInsertPoint</vh></v>
<v t="ekr.20070626112754.62"><vh>setSelectionRange</vh></v>
<v t="ekr.20070626112754.1098"><vh>setYScrollPosition</vh></v>
<v t="ekr.20070626112754.1099"><vh>setWidth</vh></v>
<v t="ekr.20070626112754.250"><vh>tag_add</vh></v>
<v t="ekr.20070626112754.1100"><vh>tag_ranges</vh></v>
<v t="ekr.20070626112754.1101"><vh>tag_remove</vh></v>
<v t="ekr.20070626112754.1102"><vh>w.deleteTextSelection</vh></v>
<v t="ekr.20070626112754.1103"><vh>xyToGui/PythonIndex</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1104"><vh>Next</vh>
<v t="ekr.20070626112754.1105"><vh> Create unit tests 17</vh>
<v t="ekr.20070626112754.1106"><vh>moveLinesUp</vh></v>
<v t="ekr.20070626112754.1107"><vh>moveLinesDown</vh></v>
<v t="ekr.20070626112754.1108"><vh>fillRegion</vh></v>
<v t="ekr.20070626112754.1109"><vh>fillRegionAsParagraph</vh></v>
<v t="ekr.20070626112754.1025"><vh>find &amp; helpers</vh>
<v t="ekr.20070626112754.1026"><vh>findNextMisspelledWord</vh>
<v t="ekr.20070626112754.1027"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1028"><vh>findNextWord</vh></v>
</v>
<v t="ekr.20070626112754.1110"><vh>findCharacterHelper</vh></v>
<v t="ekr.20070626112754.1111"><vh>getRectanglePoints</vh></v>
<v t="ekr.20070626112754.1112"><vh>lineNumber</vh></v>
<v t="ekr.20070626112754.1113"><vh>measure</vh></v>
<v t="ekr.20070626112754.1114"><vh>setCommentColumn</vh></v>
<v t="ekr.20070626112754.1115"><vh>shellCommandOnRegion</vh></v>
<v t="ekr.20070626112754.1116"><vh>sortFields</vh></v>
<v t="ekr.20070626112754.1117"><vh>swapWords</vh></v>
<v t="ekr.20070626112754.1118"><vh>whatLine</vh></v>
<v t="ekr.20070626112754.761"><vh>get/setYScrollPosition</vh></v>
<v t="ekr.20070626112754.50"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20070626112754.51"><vh>selectEditorHelper</vh>
<v t="ekr.20070626112754.52"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1119"><vh>Unit tests for menu enablers</vh></v>
</v>
<v t="ekr.20070626112754.1120"><vh>Remove Tk code from commands (later)</vh>
<v t="ekr.20070626112754.1121"><vh>class autoCompleterClass</vh>
<v t="ekr.20070626112754.1122"><vh> ctor (autocompleter)</vh>
<v t="ekr.20070626112754.1123"><vh>defineClassesDict</vh></v>
<v t="ekr.20070626112754.1124"><vh>defineObjectDict</vh></v>
</v>
<v t="ekr.20070626112754.1125"><vh>Top level</vh>
<v t="ekr.20070626112754.1126"><vh>autoComplete</vh></v>
<v t="ekr.20070626112754.1127"><vh>autoCompleteForce</vh></v>
<v t="ekr.20070626112754.1128"><vh>autoCompleterStateHandler</vh></v>
<v t="ekr.20070626112754.1129"><vh>enable/disable/toggleAutocompleter/Calltips</vh></v>
<v t="ekr.20070626112754.1130"><vh>showCalltips</vh></v>
<v t="ekr.20070626112754.1131"><vh>showCalltipsForce</vh></v>
<v t="ekr.20070626112754.1132"><vh>showAutocompleter/CalltipsStatus</vh></v>
</v>
<v t="ekr.20070626112754.1133"><vh>Helpers</vh>
<v t="ekr.20070626112754.1134"><vh>.abort &amp; exit (autocompleter) (test)</vh></v>
<v t="ekr.20070626112754.1135"><vh>append/begin/popTabName</vh></v>
<v t="ekr.20070626112754.1136"><vh>appendToKnownObjects</vh></v>
<v t="ekr.20070626112754.1137"><vh>calltip</vh>
<v t="ekr.20070626112754.1138"><vh>&lt;&lt; try to set s from a Python global function &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1139"><vh>&lt;&lt; get s using inspect &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1140"><vh>&lt;&lt; remove 'self' from s, but not from args &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1141"><vh>&lt;&lt; remove 's' from s *and* args &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1142"><vh>&lt;&lt; insert the text and set j1 and j2 &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1143"><vh>&lt;&lt; put the status line &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1144"><vh>chain</vh></v>
<v t="ekr.20070626112754.1145"><vh>computeCompletionList</vh></v>
<v t="ekr.20070626112754.1146"><vh>doBackSpace (autocompleter)</vh></v>
<v t="ekr.20070626112754.1147"><vh>doTabCompletion (autocompleter)</vh></v>
<v t="ekr.20070626112754.1148"><vh>extendSelection</vh></v>
<v t="ekr.20070626112754.1149"><vh>findAnchor</vh></v>
<v t="ekr.20070626112754.1150"><vh>findCalltipWord</vh></v>
<v t="ekr.20070626112754.1151"><vh>finish</vh></v>
<v t="ekr.20070626112754.1152"><vh>getAttr and hasAttr</vh></v>
<v t="ekr.20070626112754.1153"><vh>getLeadinWord</vh></v>
<v t="ekr.20070626112754.1154"><vh>getMembersList</vh></v>
<v t="ekr.20070626112754.1155"><vh>info</vh></v>
<v t="ekr.20070626112754.1156"><vh>insertNormalChar</vh></v>
<v t="ekr.20070626112754.1157"><vh>push, pop, clear, stackNames</vh></v>
<v t="ekr.20070626112754.1158"><vh>setObjectAndMembersList &amp; helpers</vh>
<v t="ekr.20070626112754.1159"><vh>getObjectFromAttribute</vh></v>
<v t="ekr.20070626112754.1160"><vh>completeSelf</vh></v>
<v t="ekr.20070626112754.1161"><vh>completeFromObject</vh></v>
</v>
<v t="ekr.20070626112754.1162"><vh>setSelection</vh></v>
<v t="ekr.20070626112754.1163"><vh>start</vh></v>
</v>
<v t="ekr.20070626112754.1164"><vh>Scanning</vh>
<v t="ekr.20070626112754.1165"><vh>initialScan</vh></v>
<v t="ekr.20070626112754.1166"><vh>scan</vh></v>
<v t="ekr.20070626112754.1167"><vh>definePatterns</vh></v>
<v t="ekr.20070626112754.1168"><vh>scanOutline</vh></v>
<v t="ekr.20070626112754.1169"><vh>scanForCallTip</vh></v>
<v t="ekr.20070626112754.1170"><vh>scanForAutoCompleter</vh>
<v t="ekr.20070626112754.1171"><vh>makeAutocompletionList</vh>
<v t="ekr.20070626112754.1172"><vh>reverseFindWhitespace</vh></v>
<v t="ekr.20070626112754.1173"><vh>getCleanString</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1174"><vh>Proxy classes and objects</vh>
<v t="ekr.20070626112754.1175"><vh>createProxyObjectFromClass</vh></v>
<v t="ekr.20070626112754.1176"><vh>createClassObjectFromString</vh></v>
</v>
<v t="ekr.20070626112754.1177"><vh>class forgivingParserClass</vh>
<v t="ekr.20070626112754.1178"><vh>ctor (forgivingParserClass)</vh></v>
<v t="ekr.20070626112754.1179"><vh>parse</vh></v>
<v t="ekr.20070626112754.1180"><vh>forgivingParser</vh></v>
<v t="ekr.20070626112754.1181"><vh>computeErrorNode</vh></v>
<v t="ekr.20070626112754.1182"><vh>newPutBody</vh></v>
</v>
<v t="ekr.20070626112754.1183"><vh>class classScannerClass</vh>
<v t="ekr.20070626112754.1184"><vh>ctor</vh></v>
<v t="ekr.20070626112754.1185"><vh>scan</vh></v>
<v t="ekr.20070626112754.1186"><vh>findParentClass</vh></v>
<v t="ekr.20070626112754.1187"><vh>findClass &amp; helpers</vh>
<v t="ekr.20070626112754.1188"><vh>endsDoc</vh></v>
<v t="ekr.20070626112754.1189"><vh>startsClass</vh></v>
<v t="ekr.20070626112754.1190"><vh>startsDoc</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1191"><vh>dynamicExpansion</vh>
<v t="ekr.20070626112754.1192"><vh>dynamicExpandHelper</vh></v>
</v>
<v t="ekr.20070626112754.1193"><vh>dynamicCompletion</vh></v>
<v t="ekr.20070626112754.1194"><vh>executeSubprocess</vh></v>
<v t="ekr.20070626112754.1195"><vh>insertRegister</vh></v>
<v t="ekr.20070626112754.1196"><vh>insertToBuffer</vh></v>
<v t="ekr.20070626112754.1197"><vh>prependToBuffer</vh></v>
<v t="ekr.20070626112754.1198"><vh>doOneReplace</vh></v>
<v t="ekr.20070626112754.1199"><vh>findNextMatch (query-replace)</vh>
<v t="ekr.20070626112754.1200"><vh>&lt;&lt; handle regexp &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1201"><vh>&lt;&lt; handle plain search &gt;&gt; (tag_add &amp; tag_config) LATER</vh></v>
</v>
<v t="ekr.20070626112754.1202"><vh>regionalExpandAbbrev (TK code)</vh>
<v t="ekr.20070626112754.1203"><vh>&lt;&lt; define a new generator searchXR &gt;&gt; LATER</vh></v>
</v>
<v t="ekr.20070626112754.345"><vh>scolorizer LATER</vh></v>
<v t="ekr.20070626112754.1204"><vh>sort...</vh>
<v t="ekr.20070626112754.1205"><vh>sortLines</vh></v>
<v t="ekr.20070626112754.1206"><vh>sortColumns</vh></v>
<v t="ekr.20070626112754.1116"><vh>sortFields</vh></v>
</v>
<v t="ekr.20070626112754.32"><vh>yankPop</vh></v>
<v t="ekr.20070626112754.754"><vh>onBodyChanged (leoBody)</vh>
<v t="ekr.20070626112754.755"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20070626112754.756"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1207"><vh>Maybe never</vh>
<v t="ekr.20070626112754.1208"><vh>Font stuff in colorizer (maybe never)</vh>
<v t="ekr.20070626112754.1209"><vh>setFontFromConfig (colorizer)</vh></v>
</v>
<v t="ekr.20070626112754.1210"><vh>removeAllImages (leoColor)</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1211"><vh>Testing key code in wxGui plugin</vh>
<v t="ekr.20070626112754.1212"><vh>createMenuEntries</vh>
<v t="ekr.20070626112754.1213"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1214"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20070626112754.1215"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1216"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1217"><vh>Dispatching (keyHandler)</vh>
<v t="ekr.20070626112754.464"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20070626112754.465"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20070626112754.466"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20070626112754.467"><vh>callStateFunction</vh></v>
<v t="ekr.20070626112754.468"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20070626112754.469"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20070626112754.297"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20070626112754.298"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20070626112754.1218"><vh>endCommand</vh></v>
</v>
<v t="ekr.20070626112754.295"><vh>getArg</vh>
<v t="ekr.20070626112754.296"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.244"><vh>head key handlers (leoTree)</vh>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.247"><vh>onHeadlineKey</vh></v>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
<v t="ekr.20070626112754.248"><vh>endEditLabel</vh></v>
</v>
<v t="ekr.20070626112754.1219"><vh>Events (tkGui)</vh></v>
<v t="ekr.20070626112754.1220"><vh>manufactureKeyPressForCommandName</vh></v>
<v t="ekr.20070626112754.73"><vh>selfInsertCommand &amp; helpers</vh>
<v t="ekr.20070626112754.74"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.75"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20070626112754.76"><vh>initBracketMatcher</vh></v>
<v t="ekr.20070626112754.77"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20070626112754.78"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.79"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20070626112754.80"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20070626112754.81"><vh>updateTab</vh></v>
</v>
<v t="ekr.20070626112754.1001"><vh>leoFrame.pasteText</vh></v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.630"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20070626112754.1221"><vh>Master event handlers (keyHandler)</vh>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.1222"><vh>masterClickHandler</vh></v>
<v t="ekr.20070626112754.1223"><vh>masterDoubleClickHandler</vh></v>
<v t="ekr.20070626112754.1224"><vh>masterMenuHandler</vh></v>
</v>
<v t="ekr.20070626112754.1225"><vh>OnBodyClick, OnBodyRClick (Events)</vh></v>
<v t="ekr.20070626112754.1226"><vh>tree.editLabel</vh></v>
<v t="ekr.20070626112754.97"><vh>setEditLabelState</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1227"><vh>Leo 4.4.3 b1 projects</vh>
<v t="ekr.20070626112754.1228"><vh>New features</vh>
<v t="ekr.20070626112754.1229"><vh>Added @bool force_newlines_in_at_nosent_bodies setting</vh>
<v t="ekr.20070626112754.1230"><vh>putBody</vh>
<v t="ekr.20070626112754.1231"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1232"><vh>&lt;&lt; handle line at s[i]  &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1233"><vh>putCodeLine</vh></v>
</v>
<v t="ekr.20070626112754.1234"><vh>Added apropos-debugging-commands command</vh></v>
<v t="ekr.20070626112754.1235"><vh>Added print-plugins &amp; print-plugin-handlers commands</vh>
<v t="ekr.20070626112754.1236"><vh>printPlugins</vh></v>
</v>
<v t="ekr.20070626112754.1237"><vh>Added print-settings command</vh>
<v t="ekr.20070626112754.1238"><vh>g.app.config.printSettings &amp; helper</vh>
<v t="ekr.20070626112754.1239"><vh>printSettingsHelper</vh>
<v t="ekr.20070626112754.1240"><vh>&lt;&lt; set letter &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1241"><vh>Added support for @openwith nodes</vh>
<v t="ekr.20070626112754.1242"><vh>request</vh></v>
<v t="ekr.20070626112754.1243"><vh>Config stuff</vh>
<v t="ekr.20070626112754.947"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20070626112754.948"><vh>getValFromDict</vh></v>
<v t="ekr.20070626112754.949"><vh>typesMatch</vh></v>
</v>
<v t="ekr.20070626112754.1244"><vh>set (parseBaseClass)</vh></v>
<v t="ekr.20070626112754.960"><vh>getOpenWith</vh></v>
<v t="ekr.20070626112754.983"><vh>doOpenWith (ParserBaseClass)</vh></v>
<v t="ekr.20070626112754.1245"><vh>parseOpenWith &amp; helper</vh>
<v t="ekr.20070626112754.1246"><vh>parseOpenWithLine</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1247"><vh>openWith and allies</vh>
<v t="ekr.20070626112754.1248"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1249"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20070626112754.1250"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1251"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20070626112754.1252"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1253"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1254"><vh>createOpenWithTempFile</vh>
<v t="ekr.20070626112754.1255"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1256"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20070626112754.1257"><vh>createOpenWithMenuFromTable &amp; helper</vh>
<v t="ekr.20070626112754.1258"><vh>createOpenWithMenuItemsFromTable</vh>
<v t="ekr.20070626112754.1259"><vh>&lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1260"><vh>bindOpenWith</vh></v>
</v>
<v t="ekr.20070626112754.1261"><vh>Created clean-all-lines command</vh>
<v t="ekr.20070626112754.1262"><vh>cleanAllLines</vh></v>
<v t="ekr.20070626112754.1263"><vh>cleanLines</vh></v>
</v>
<v t="ekr.20070626112754.1264"><vh>Support for compressed .leo files</vh>
<v t="ekr.20070626112754.1265"><vh>What I did</vh></v>
<v t="ekr.20070626112754.1266"><vh>Request 1</vh></v>
<v t="ekr.20070626112754.1267"><vh>Request 2</vh></v>
<v t="ekr.20070626112754.1268"><vh>open (leoFileCommands)</vh>
<v t="ekr.20070626112754.1269"><vh>&lt;&lt; read the entire file into the buffer &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1270"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.990"><vh>g.openWithFileName</vh></v>
<v t="ekr.20070626112754.640"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20070626112754.1271"><vh>g.openLeoOrZipFile</vh></v>
<v t="ekr.20070626112754.1272"><vh>top level (file menu)</vh>
<v t="ekr.20070626112754.1273"><vh>new</vh></v>
<v t="ekr.20070626112754.1274"><vh>open</vh>
<v t="ekr.20070626112754.1275"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1247"><vh>openWith and allies</vh>
<v t="ekr.20070626112754.1248"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1249"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20070626112754.1250"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1251"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20070626112754.1252"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1253"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1254"><vh>createOpenWithTempFile</vh>
<v t="ekr.20070626112754.1255"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1256"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20070626112754.1276"><vh>close</vh></v>
<v t="ekr.20070626112754.1277"><vh>save (commands)</vh></v>
<v t="ekr.20070626112754.1278"><vh>saveAs</vh></v>
<v t="ekr.20070626112754.1279"><vh>saveAsUnzipped &amp; saveAsZipped</vh></v>
<v t="ekr.20070626112754.1280"><vh>saveTo</vh></v>
<v t="ekr.20070626112754.1281"><vh>revert</vh></v>
</v>
<v t="ekr.20070626112754.1282"><vh>Top-level  (leoFileCommands)</vh>
<v t="ekr.20070626112754.1283"><vh>save (fileCommands)</vh></v>
<v t="ekr.20070626112754.1284"><vh>saveAs</vh></v>
<v t="ekr.20070626112754.1285"><vh>saveTo</vh></v>
<v t="ekr.20070626112754.1286"><vh>putSavedMessage</vh></v>
</v>
<v t="ekr.20070626112754.1287"><vh>write_Leo_file</vh>
<v t="ekr.20070626112754.1288"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1289"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1290"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1291"><vh>&lt;&lt; ensure that filename ends with .opml &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1292"><vh>&lt;&lt; create theActualFile &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1293"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1294"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1295"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1296"><vh>writeZipFile</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1297"><vh>Fixed bugs</vh>
<v t="ekr.20070626112754.1298"><vh>Fixed bug: new-file doesn't allow edit of initial headline</vh>
<v t="ekr.20070626112754.1273"><vh>new</vh></v>
<v t="ekr.20070626112754.1226"><vh>tree.editLabel</vh></v>
</v>
<v t="ekr.20070626112754.1299"><vh>Removed all returns from finally clauses</vh>
<v t="ekr.20070626112754.662"><vh>getBatchScript</vh></v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.464"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20070626112754.465"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20070626112754.466"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20070626112754.467"><vh>callStateFunction</vh></v>
<v t="ekr.20070626112754.468"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20070626112754.469"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20070626112754.1179"><vh>parse</vh></v>
<v t="ekr.20070626112754.50"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20070626112754.51"><vh>selectEditorHelper</vh>
<v t="ekr.20070626112754.52"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1300"><vh>Fixed crashes when trying to import aspell</vh>
<v t="ekr.20070626112754.1301"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.1302"><vh>__init__</vh></v>
<v t="ekr.20070626112754.1303"><vh>getAspell</vh></v>
<v t="ekr.20070626112754.1304"><vh>getAspellWithCtypes</vh>
<v t="ekr.20070626112754.1305"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1306"><vh>Fixed repeatComplexCommand weirdness</vh>
<v t="ekr.20070626112754.1307"><vh>repeatComplexCommand &amp; helper</vh></v>
<v t="ekr.20070626112754.1308"><vh>keyboardQuit</vh></v>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.295"><vh>getArg</vh>
<v t="ekr.20070626112754.296"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1309"><vh>setState</vh></v>
<v t="ekr.20070626112754.797"><vh>class leoKeyEvent (leoGui)</vh></v>
</v>
<v t="ekr.20070626112754.1310"><vh>Improved widget allocation in trees</vh>
<v t="ekr.20070626112754.418"><vh>createSplitterComponents</vh></v>
<v t="ekr.20070626112754.1311"><vh>tt.createTab</vh></v>
<v t="ekr.20070626112754.1312"><vh>chapterSelectHelper</vh></v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1313"><vh>tt.selectTab</vh></v>
<v t="ekr.20070626112754.1314"><vh>destroyAllObjects</vh>
<v t="ekr.20070626112754.1315"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1316"><vh>initing g.app.ivars</vh>
<v t="ekr.20070626112754.1317"><vh>setIvarsFromSettings (g.app.config)</vh></v>
<v t="ekr.20070626112754.638"><vh>g.app.config.readSettingsFiles &amp; helpers</vh>
<v t="ekr.20070626112754.639"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
<v t="ekr.20070626112754.640"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20070626112754.641"><vh>g.app.config.updateSettings</vh></v>
</v>
<v t="ekr.20070626112754.303"><vh>g.getBaseDirectory</vh></v>
<v t="ekr.20070626112754.1318"><vh>g.makeAllNonExistentDirectories</vh></v>
<v t="ekr.20070626112754.1319"><vh>Found: makeAllNonExistentDirectories</vh>
<v t="ekr.20070626112754.1320"><vh>atFile.rename &amp; test</vh>
<v t="ekr.20070626112754.1321"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1322"><vh>@tesst atFile_rename</vh></v>
</v>
<v t="ekr.20070626112754.1323"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20070626112754.1324"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1325"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20070626112754.1326"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20070626112754.1327"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1328"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1329"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1330"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1331"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1332"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1333"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1334"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1335"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1336"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1337"><vh>atFile.scanDefaultDirectory</vh>
<v t="ekr.20070626112754.1338"><vh>&lt;&lt; Set path from @file node &gt;&gt;  in df.scanDeafaultDirectory in leoAtFile.py</vh></v>
<v t="ekr.20070626112754.1339"><vh>&lt;&lt; handle @path &gt;&gt; in df.scanDeafaultDirectory in leoAtFile.py</vh>
<v t="ekr.20070626112754.1340"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1341"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1342"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1343"><vh>g.utils_rename &amp; test</vh>
<v t="ekr.20070626112754.1344"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1345"><vh>@test g.utils_rename</vh></v>
</v>
<v t="ekr.20070626112754.1346"><vh>tangle.scanAllDirectives</vh>
<v t="ekr.20070626112754.1347"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1348"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1349"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1350"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1351"><vh>&lt;&lt; Test for print modes directives &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1352"><vh>&lt;&lt; Test for @path &gt;&gt; in tangleScanAllDirectives</vh>
<v t="ekr.20070626112754.1353"><vh>&lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1354"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1355"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1356"><vh>&lt;&lt; Test for @root &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1357"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1358"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1359"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh>
<v t="ekr.20070626112754.1360"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1361"><vh>Found: utils_rename</vh>
<v t="ekr.20070626112754.1287"><vh>write_Leo_file</vh>
<v t="ekr.20070626112754.1288"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1289"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1290"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1291"><vh>&lt;&lt; ensure that filename ends with .opml &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1292"><vh>&lt;&lt; create theActualFile &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1293"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1294"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1295"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1296"><vh>writeZipFile</vh></v>
</v>
<v t="ekr.20070626112754.1362"><vh>g.update_file_if_changed</vh></v>
<v t="ekr.20070626112754.1343"><vh>g.utils_rename &amp; test</vh>
<v t="ekr.20070626112754.1344"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1345"><vh>@test g.utils_rename</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1363"><vh>Fixed crash when deleting a chapter</vh>
<v t="ekr.20070626112754.1364"><vh>f.createTkTreeCanvas &amp; callbacks</vh>
<v t="ekr.20070626112754.1365"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1366"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1367"><vh>Scrolling callbacks (tkFrame)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1368"><vh>Fixed minor chapter hoist bug</vh>
<v t="ekr.20070626112754.1369"><vh>canCutOutline &amp; canDeleteHeadline</vh></v>
</v>
<v t="ekr.20070626112754.1370"><vh>Fixed crasher in plugins_menu.py</vh></v>
<v t="ekr.20070626112754.1371"><vh>error writing file with newly-created @chapters node</vh>
<v t="ekr.20070626112754.1372"><vh>putVnodes &amp; helpers</vh>
<v t="ekr.20070626112754.1373"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20070626112754.1374"><vh>&lt;&lt; Set gnx = tnode index &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1375"><vh>&lt;&lt; Append attribute bits to attrs &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1376"><vh>&lt;&lt; Append tnodeList and unKnownAttributes to attrs&gt;&gt;</vh></v>
<v t="ekr.20070626112754.1377"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1378"><vh>putTnodeList (4.0,4.2)</vh></v>
<v t="ekr.20070626112754.1379"><vh>putDescendentAttributes</vh></v>
<v t="ekr.20070626112754.1380"><vh>putDescendentUnknownAttributes</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1381"><vh>Fixed chapter-save code when clicking on window's close box</vh>
<v t="ekr.20070626112754.1382"><vh>app.closeLeoWindow</vh></v>
<v t="ekr.20070626112754.1383"><vh>promptForSave</vh>
<v t="ekr.20070626112754.1384"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1385"><vh>Made sure starting from leo.py inits chapters properly</vh>
<v t="ekr.20070626112754.660"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20070626112754.990"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20070626112754.1386"><vh>Fixed focus problem in headline</vh>
<v t="ekr.20070626112754.97"><vh>setEditLabelState</vh></v>
<v t="ekr.20070626112754.1387"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20070626112754.1388"><vh>tk.Gui.set_focus</vh></v>
<v t="ekr.20070626112754.851"><vh>getTabName</vh></v>
<v t="ekr.20070626112754.1389"><vh>Calls to x.bringToFront</vh>
<v t="ekr.20070626112754.1390"><vh>c.bringToFront</vh></v>
<v t="ekr.20070626112754.1391"><vh>Tk bindings...</vh></v>
<v t="ekr.20070626112754.385"><vh>bringToFront (leoFind)</vh></v>
</v>
<v t="ekr.20070626112754.1222"><vh>masterClickHandler</vh></v>
<v t="ekr.20070626112754.1392"><vh>onHeadlineClick</vh></v>
<v t="ekr.20070626112754.1226"><vh>tree.editLabel</vh></v>
<v t="ekr.20070626112754.1393"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20070626112754.1394"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1395"><vh>Fixed bindings in new chapters</vh>
<v t="ekr.20070626112754.1396"><vh>tt.renameChapterHelper</vh></v>
<v t="ekr.20070626112754.1397"><vh>cc.createChapter</vh></v>
<v t="ekr.20070626112754.1398"><vh>tt.createTopLevelMenuItems</vh></v>
<v t="ekr.20070626112754.1399"><vh> Birth... (tkTree)</vh>
<v t="ekr.20070626112754.1400"><vh>__init__ (tkTree)</vh>
<v t="ekr.20070626112754.1401"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1402"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1403"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1404"><vh>tkTree.setCanvasBindings</vh>
<v t="ekr.20070626112754.1405"><vh>&lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1406"><vh>&lt;&lt; create baloon bindings for tagged items on the canvas &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1407"><vh>newText (tkTree) and helper</vh>
<v t="ekr.20070626112754.1408"><vh>&lt;&lt; patch by Maciej Kalisiak  to handle scroll-wheel events &gt;&gt;</vh></v>
<v t="ekr.20070626112754.98"><vh>tree.setHeadlineText</vh></v>
</v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.1409"><vh>Found: makeMasterGuiBinding</vh>
<v t="ekr.20070626112754.1410"><vh>k.completeAllBindingsForWidget</vh></v>
<v t="ekr.20070626112754.1411"><vh>k.completeAllBindings</vh></v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.645"><vh>k.registerCommand</vh></v>
<v t="ekr.20070626112754.1412"><vh>createModeBindings</vh></v>
</v>
<v t="ekr.20070626112754.1413"><vh>cc.finishCreate</vh></v>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1414"><vh>Fixed memory leaks</vh>
<v t="ekr.20070626112754.1415"><vh>Destroying the tkFrame</vh>
<v t="ekr.20070626112754.1314"><vh>destroyAllObjects</vh>
<v t="ekr.20070626112754.1315"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1416"><vh>destroyAllPanels</vh></v>
<v t="ekr.20070626112754.1417"><vh>destroySelf (tkFrame)</vh></v>
</v>
<v t="ekr.20070626112754.1418"><vh>Interesting methods</vh>
<v t="ekr.20070626112754.754"><vh>onBodyChanged (leoBody)</vh>
<v t="ekr.20070626112754.755"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20070626112754.756"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1419"><vh>idle time functions (leoGlobals)</vh>
<v t="ekr.20070626112754.1420"><vh>enableIdleTimeHook</vh></v>
<v t="ekr.20070626112754.1421"><vh>disableIdleTimeHook</vh></v>
<v t="ekr.20070626112754.1422"><vh>idleTimeHookHandler</vh></v>
</v>
<v t="ekr.20070626112754.1423"><vh>g.doHook</vh></v>
<v t="ekr.20070626112754.464"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20070626112754.465"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20070626112754.466"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20070626112754.467"><vh>callStateFunction</vh></v>
<v t="ekr.20070626112754.468"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20070626112754.469"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.1424"><vh> ctor (keyHandler)</vh>
<v t="ekr.20070626112754.1425"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1426"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1427"><vh>Garbage Collection</vh>
<v t="ekr.20070626112754.1428"><vh>clearAllIvars</vh></v>
<v t="ekr.20070626112754.1429"><vh>collectGarbage</vh></v>
<v t="ekr.20070626112754.1430"><vh>enable_gc_debug</vh></v>
<v t="ekr.20070626112754.1431"><vh>printGc</vh>
<v t="ekr.20070626112754.1432"><vh>printGcRefs</vh></v>
</v>
<v t="ekr.20070626112754.1433"><vh>printGcAll</vh></v>
<v t="ekr.20070626112754.1434"><vh>printGcObjects   (printNewObjects=pno)</vh>
<v t="ekr.20070626112754.1435"><vh>&lt;&lt; print number of each type of object &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1436"><vh>&lt;&lt; print added functions &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1437"><vh>printGcSummary</vh></v>
<v t="ekr.20070626112754.1438"><vh>printGcVerbose</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1439"><vh>Fixed bug: Key bindings were not set in @command nodes</vh>
<v t="ekr.20070626112754.645"><vh>k.registerCommand</vh></v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.1413"><vh>cc.finishCreate</vh></v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1410"><vh>k.completeAllBindingsForWidget</vh></v>
<v t="ekr.20070626112754.460"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1440"><vh>Leo 4.4.3 b2 projects</vh>
<v t="ekr.20070626112754.1441"><vh>Fixed bugs</vh>
<v t="ekr.20070626112754.1442"><vh>Fixed noweb hangs</vh>
<v t="ekr.20070626112754.1443"><vh>Reports</vh></v>
<v t="ekr.20070626112754.1444"><vh>Bill Page</vh></v>
<v t="ekr.20070626112754.1445"><vh>Import</vh>
<v t="ekr.20070626112754.1446"><vh>createOutline</vh>
<v t="ekr.20070626112754.1447"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1448"><vh>getTabWidth</vh></v>
<v t="ekr.20070626112754.1449"><vh>importDerivedFiles</vh>
<v t="ekr.20070626112754.1450"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1451"><vh>forceGnxOnPosition</vh></v>
</v>
<v t="ekr.20070626112754.1452"><vh>importFilesCommand</vh>
<v t="ekr.20070626112754.1453"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1454"><vh>importFlattenedOutline &amp; allies</vh>
<v t="ekr.20070626112754.1455"><vh>convertMoreString/StringsToOutlineAfter</vh>
<v t="ekr.20070626112754.1456"><vh>&lt;&lt; Link a new vnode v into the outline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1457"><vh>&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1458"><vh>&lt;&lt; Count the number of following body lines &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1459"><vh>&lt;&lt; Add the lines to the body text of v &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1460"><vh>importFlattenedOutline</vh>
<v t="ekr.20070626112754.1461"><vh>&lt;&lt; Read the file into array &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1462"><vh>moreHeadlineLevel</vh></v>
<v t="ekr.20070626112754.1463"><vh>stringIs/stringsAreValidMoreFile</vh></v>
</v>
<v t="ekr.20070626112754.1464"><vh>importWebCommand &amp; allies</vh>
<v t="ekr.20070626112754.1465"><vh>createOutlineFromWeb</vh></v>
<v t="ekr.20070626112754.1466"><vh>importWebCommand</vh></v>
<v t="ekr.20070626112754.1467"><vh>findFunctionDef</vh></v>
<v t="ekr.20070626112754.1468"><vh>scanBodyForHeadline</vh>
<v t="ekr.20070626112754.1469"><vh>&lt;&lt; scan cweb body for headline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1470"><vh>&lt;&lt; scan noweb body for headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1471"><vh>scanWebFile (handles limbo)</vh>
<v t="ekr.20070626112754.1472"><vh>&lt;&lt; Create a symbol table of all section names &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1473"><vh>&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1474"><vh>&lt;&lt; Create a node for the next module &gt;&gt;</vh>
<v t="ekr.20070626112754.1475"><vh>&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1476"><vh>Symbol table</vh>
<v t="ekr.20070626112754.1477"><vh>cstCanonicalize</vh></v>
<v t="ekr.20070626112754.1478"><vh>cstDump</vh></v>
<v t="ekr.20070626112754.1479"><vh>cstEnter</vh></v>
<v t="ekr.20070626112754.1480"><vh>cstLookup</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1481"><vh>perfectImport</vh>
<v t="ekr.20070626112754.1482"><vh>&lt;&lt; about this algorithm &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1483"><vh>&lt;&lt; clear all dirty bits &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1484"><vh>&lt;&lt; Assign file indices  &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1485"><vh>&lt;&lt; Write root's tree to to string s &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1486"><vh>&lt;&lt; put the corrected fat lines in a new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1487"><vh>&lt;&lt; correct root's tree using write_lines &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1488"><vh>&lt;&lt; verify that writing the tree would produce the original file &gt;&gt;</vh>
<v t="ekr.20070626112754.1489"><vh>&lt;&lt; dump the files &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1490"><vh>Scanners for createOutline</vh>
<v t="ekr.20070626112754.1491"><vh>Python scanners &amp; tests</vh>
<v t="ekr.20070626112754.1492"><vh>scanPythonClass &amp; helpers</vh>
<v t="ekr.20070626112754.1493"><vh>&lt;&lt; set class_name and headline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1494"><vh>scanPythonClassHelper</vh></v>
<v t="ekr.20070626112754.1495"><vh>createParentText</vh></v>
<v t="ekr.20070626112754.1496"><vh>createClassNodeText</vh></v>
</v>
<v t="ekr.20070626112754.1497"><vh>scanPythonDef</vh>
<v t="ekr.20070626112754.1498"><vh>&lt;&lt; set headline or return i &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1499"><vh>&lt;&lt; Create def node &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1500"><vh>scanPythonDecls</vh>
<v t="ekr.20070626112754.1501"><vh>&lt;&lt; break on def or class &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1502"><vh>&lt;&lt; Create a child node for declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1503"><vh>scanPythonText</vh>
<v t="ekr.20070626112754.1504"><vh>&lt;&lt; handle possible Python function or class &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1505"><vh>&lt;&lt; Append a reference to the methods of this file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1506"><vh>&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1507"><vh>skipPythonDef</vh>
<v t="ekr.20070626112754.1508"><vh>&lt;&lt; skip the entire signature &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1509"><vh>@test skipPythonDef</vh>
<v t="ekr.20070626112754.1510"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1511"><vh>@test skipPythonDef (long lines)</vh>
<v t="ekr.20070626112754.1512"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1513"><vh>@test scanPythonClass</vh>
<v t="ekr.20070626112754.1514"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.554"><vh>scanCText</vh></v>
<v t="ekr.20070626112754.1515"><vh>scanElispText &amp; allies</vh>
<v t="ekr.20070626112754.1516"><vh>skipElispParens</vh></v>
<v t="ekr.20070626112754.1517"><vh>skipElispId</vh></v>
<v t="ekr.20070626112754.1518"><vh>createElispFunction</vh></v>
<v t="ekr.20070626112754.1519"><vh>createElispDataNode</vh></v>
</v>
<v t="ekr.20070626112754.1520"><vh>scanForthText</vh></v>
<v t="ekr.20070626112754.1521"><vh>scanJavaText</vh>
<v t="ekr.20070626112754.1522"><vh>&lt;&lt; define scanJavaText vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1523"><vh>&lt;&lt; handle possible Java comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1524"><vh>&lt;&lt; handle equal sign in Java &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1525"><vh>&lt;&lt; handle open paren in Java &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1526"><vh>&lt;&lt; handle semicolon in Java &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1527"><vh>&lt;&lt; handle open curly bracket in Java &gt;&gt;</vh>
<v t="ekr.20070626112754.1528"><vh>&lt;&lt; create a Java declaration node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1529"><vh>&lt;&lt; append Java method reference to parent node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1530"><vh>&lt;&lt; recursively scan the text &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1531"><vh>&lt;&lt; skip and remember the Java id &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1532"><vh>&lt;&lt; append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1533"><vh>scanLuaText</vh></v>
<v t="ekr.20070626112754.1534"><vh>scanPascalText</vh>
<v t="ekr.20070626112754.1535"><vh>&lt;&lt; handle possible Pascal function &gt;&gt;</vh>
<v t="ekr.20070626112754.1536"><vh>&lt;&lt; remember the function name, or continue &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1537"><vh>&lt;&lt; skip the function definition, or continue &gt;&gt;</vh>
<v t="ekr.20070626112754.1538"><vh>&lt;&lt; skip past the semicolon &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1539"><vh>&lt;&lt; create a child node for leading declarations &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1540"><vh>&lt;&lt; append noweb method reference to the parent node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1541"><vh>&lt;&lt; create a child node for the function &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1532"><vh>&lt;&lt; append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1542"><vh>scanPHPText (Dave Hein)</vh>
<v t="ekr.20070626112754.1543"><vh>&lt;&lt; define scanPHPText vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1544"><vh>&lt;&lt; Append file if not pure PHP &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1545"><vh>&lt;&lt; handle possible PHP comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1546"><vh>&lt;&lt; handle possible heredoc string &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1547"><vh>&lt;&lt; handle possible class or function &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1548"><vh>&lt;&lt; handle end of class &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1549"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.555"><vh>class cScanner</vh>
<v t="ekr.20070626112754.556"><vh>cScanner.ctor</vh></v>
<v t="ekr.20070626112754.557"><vh>scan &amp; helpers</vh>
<v t="ekr.20070626112754.558"><vh>appendUnusedText</vh></v>
<v t="ekr.20070626112754.559"><vh>doId</vh></v>
<v t="ekr.20070626112754.560"><vh>doInner</vh></v>
<v t="ekr.20070626112754.561"><vh>doOuterParen</vh></v>
<v t="ekr.20070626112754.562"><vh>doSemicolon</vh></v>
<v t="ekr.20070626112754.563"><vh>skipComments</vh></v>
</v>
<v t="ekr.20070626112754.564"><vh>Utilities (should be in base class)</vh>
<v t="ekr.20070626112754.565"><vh>createHeadline</vh></v>
<v t="ekr.20070626112754.566"><vh>error</vh></v>
<v t="ekr.20070626112754.567"><vh>getLeadingIndent</vh></v>
<v t="ekr.20070626112754.568"><vh>isDocStart and isModuleStart</vh></v>
<v t="ekr.20070626112754.569"><vh>massageComment</vh></v>
<v t="ekr.20070626112754.570"><vh>setEncoding</vh></v>
<v t="ekr.20070626112754.571"><vh>skipLeadingComments</vh>
<v t="ekr.20070626112754.572"><vh>&lt;&lt; scan for C-style comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.573"><vh>&lt;&lt; scan for Lua comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.574"><vh>&lt;&lt; scan for Pascal comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.575"><vh>&lt;&lt; scan for Python comments &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.576"><vh>undentBody</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1464"><vh>importWebCommand &amp; allies</vh>
<v t="ekr.20070626112754.1465"><vh>createOutlineFromWeb</vh></v>
<v t="ekr.20070626112754.1466"><vh>importWebCommand</vh></v>
<v t="ekr.20070626112754.1467"><vh>findFunctionDef</vh></v>
<v t="ekr.20070626112754.1468"><vh>scanBodyForHeadline</vh>
<v t="ekr.20070626112754.1469"><vh>&lt;&lt; scan cweb body for headline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1470"><vh>&lt;&lt; scan noweb body for headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1471"><vh>scanWebFile (handles limbo)</vh>
<v t="ekr.20070626112754.1472"><vh>&lt;&lt; Create a symbol table of all section names &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1473"><vh>&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1474"><vh>&lt;&lt; Create a node for the next module &gt;&gt;</vh>
<v t="ekr.20070626112754.1475"><vh>&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1476"><vh>Symbol table</vh>
<v t="ekr.20070626112754.1477"><vh>cstCanonicalize</vh></v>
<v t="ekr.20070626112754.1478"><vh>cstDump</vh></v>
<v t="ekr.20070626112754.1479"><vh>cstEnter</vh></v>
<v t="ekr.20070626112754.1480"><vh>cstLookup</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1550"><vh>Utilities</vh>
<v t="ekr.20070626112754.1551"><vh>createHeadline</vh></v>
<v t="ekr.20070626112754.1552"><vh>error</vh></v>
<v t="ekr.20070626112754.1553"><vh>getLeadingIndent</vh></v>
<v t="ekr.20070626112754.1554"><vh>isDocStart and isModuleStart</vh></v>
<v t="ekr.20070626112754.1555"><vh>massageBody</vh></v>
<v t="ekr.20070626112754.1556"><vh>massageComment</vh></v>
<v t="ekr.20070626112754.1557"><vh>massageWebBody</vh>
<v t="ekr.20070626112754.1558"><vh>&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1559"><vh>&lt;&lt; Replace abbreviated names with full names &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1560"><vh>setEncoding</vh></v>
<v t="ekr.20070626112754.1561"><vh>skipLeadingComments</vh>
<v t="ekr.20070626112754.1562"><vh>&lt;&lt; scan for C-style comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1563"><vh>&lt;&lt; scan for Lua comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1564"><vh>&lt;&lt; scan for Pascal comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1565"><vh>&lt;&lt; scan for Python comments &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1566"><vh>undentBody</vh></v>
</v>
<v t="ekr.20070626112754.1567"><vh>skip_line, skip_to_start/end_of_line</vh></v>
</v>
<v t="ekr.20070626112754.1568"><vh>Fixed bug: Alt-4 did not work in tree pane in unitTest.leo</vh>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.645"><vh>k.registerCommand</vh></v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1569"><vh>k.makeAllBindings</vh></v>
</v>
<v t="ekr.20070626112754.1570"><vh>Investigated problem with subprocess (works for me)</vh></v>
<v t="ekr.20070626112754.1571"><vh>Fixed crashers in leoupate plugin</vh></v>
<v t="ekr.20070626112754.1572"><vh>Fixed automatic directory creation</vh>
<v t="ekr.20070626112754.1318"><vh>g.makeAllNonExistentDirectories</vh></v>
<v t="ekr.20070626112754.1573"><vh>openFileForWritingHelper</vh></v>
</v>
<v t="ekr.20070626112754.1574"><vh>Fixed bug: shift-arrow keys not bound properly when node is clicked</vh>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.1393"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20070626112754.1394"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1575"><vh>Made sure the new outlines aren't marked dirty</vh>
<v t="ekr.20070626112754.1576"><vh>Report</vh></v>
<v t="ekr.20070626112754.660"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20070626112754.1273"><vh>new</vh></v>
</v>
<v t="ekr.20070626112754.1577"><vh>Fix crasher in maximizeNewWindows</vh></v>
<v t="ekr.20070626112754.1578"><vh>Fixed lost data when deleting the root</vh>
<v t="ekr.20070626112754.1579"><vh>Third report</vh></v>
<v t="ekr.20070626112754.1580"><vh>c.deleteOutline</vh></v>
<v t="ekr.20070626112754.1581"><vh>c.positionExists</vh></v>
<v t="ekr.20070626112754.186"><vh>c.selectPosition</vh></v>
<v t="ekr.20070626112754.192"><vh>c.setCurrentPosition</vh></v>
<v t="ekr.20070626112754.1582"><vh>c.setRootPosition</vh></v>
<v t="ekr.20070626112754.1583"><vh>Cut &amp; Paste Outlines</vh>
<v t="ekr.20070626112754.1584"><vh>cutOutline</vh></v>
<v t="ekr.20070626112754.1585"><vh>copyOutline</vh></v>
<v t="ekr.20070626112754.1586"><vh>pasteOutline</vh>
<v t="ekr.20070626112754.1587"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1588"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1589"><vh>pasteOutlineRetainingClones</vh></v>
</v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1590"><vh>p.doDelete</vh></v>
<v t="ekr.20070626112754.1591"><vh>Report</vh></v>
</v>
<v t="ekr.20070626112754.1592"><vh>Fixed recent bug: the Leo window is *always* dirty</vh>
<v t="ekr.20070626112754.1593"><vh>c.setChanged</vh></v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.186"><vh>c.selectPosition</vh></v>
<v t="ekr.20070626112754.192"><vh>c.setCurrentPosition</vh></v>
<v t="ekr.20070626112754.1277"><vh>save (commands)</vh></v>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1594"><vh>Fixed bug that caused the wrong clone to be selected.</vh>
<v t="ekr.20070626112754.1595"><vh>setPositionsFromStacks (silly)</vh></v>
<v t="ekr.20070626112754.1596"><vh>cc.selectChapterByName</vh></v>
<v t="ekr.20070626112754.1312"><vh>chapterSelectHelper</vh></v>
<v t="ekr.20070626112754.1597"><vh>chapter.findPositionInChapter</vh></v>
<v t="ekr.20070626112754.1581"><vh>c.positionExists</vh></v>
</v>
<v t="ekr.20070626112754.1598"><vh>Don't change focus in the save command</vh>
<v t="ekr.20070626112754.1277"><vh>save (commands)</vh></v>
<v t="ekr.20070626112754.1278"><vh>saveAs</vh></v>
<v t="ekr.20070626112754.1280"><vh>saveTo</vh></v>
</v>
<v t="ekr.20070626112754.1599"><vh>downcase-region and upcase-region didn't color body text.</vh>
<v t="ekr.20070626112754.1600"><vh>up/downCaseRegion &amp; helper</vh></v>
<v t="ekr.20070626112754.1601"><vh>begin/endCommand (baseEditCommands)</vh>
<v t="ekr.20070626112754.1602"><vh>beginCommand  &amp; beginCommandWithEvent</vh>
<v t="ekr.20070626112754.1603"><vh>beingCommandHelper</vh></v>
</v>
<v t="ekr.20070626112754.1604"><vh>endCommand</vh></v>
</v>
<v t="ekr.20070626112754.754"><vh>onBodyChanged (leoBody)</vh>
<v t="ekr.20070626112754.755"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20070626112754.756"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1605"><vh>capitalization &amp; case</vh>
<v t="ekr.20070626112754.1606"><vh>capitalizeWord &amp; up/downCaseWord</vh></v>
<v t="ekr.20070626112754.1607"><vh>changePreviousWord (not used)</vh></v>
<v t="ekr.20070626112754.1608"><vh>capitalizeHelper</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1609"><vh>Fixed bug involving moving up/down out of hoists</vh>
<v t="ekr.20070626112754.593"><vh>c.goToLastVisibleNode</vh></v>
<v t="ekr.20070626112754.1610"><vh>c.lastVisible</vh></v>
<v t="ekr.20070626112754.1611"><vh>c.visLimit</vh></v>
<v t="ekr.20070626112754.1612"><vh>canMoveOutlineDown</vh></v>
<v t="ekr.20070626112754.1613"><vh>canMoveOutlineUp</vh></v>
<v t="ekr.20070626112754.1614"><vh>canSelect....</vh></v>
<v t="ekr.20070626112754.607"><vh>Commands (outline menu)</vh>
<v t="ekr.20070626112754.608"><vh>contractAllHeadlines</vh></v>
<v t="ekr.20070626112754.609"><vh>contractNode</vh></v>
<v t="ekr.20070626112754.610"><vh>contractNodeOrGoToParent</vh></v>
<v t="ekr.20070626112754.611"><vh>contractParent</vh></v>
<v t="ekr.20070626112754.612"><vh>expandAllHeadlines</vh></v>
<v t="ekr.20070626112754.613"><vh>expandAllSubheads</vh></v>
<v t="ekr.20070626112754.614"><vh>expandLevel1..9</vh></v>
<v t="ekr.20070626112754.615"><vh>expandNextLevel</vh></v>
<v t="ekr.20070626112754.616"><vh>expandNode</vh></v>
<v t="ekr.20070626112754.617"><vh>expandNodeAnd/OrGoToFirstChild</vh></v>
<v t="ekr.20070626112754.618"><vh>expandOnlyAncestorsOfNode</vh></v>
<v t="ekr.20070626112754.619"><vh>expandPrevLevel</vh></v>
</v>
<v t="ekr.20070626112754.620"><vh>Move... (Commands)</vh>
<v t="ekr.20070626112754.621"><vh>cantMoveMessage</vh></v>
<v t="ekr.20070626112754.622"><vh>demote</vh></v>
<v t="ekr.20070626112754.623"><vh>moveOutlineDown</vh>
<v t="ekr.20070626112754.624"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.625"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20070626112754.626"><vh>moveOutlineRight</vh></v>
<v t="ekr.20070626112754.627"><vh>moveOutlineUp</vh>
<v t="ekr.20070626112754.628"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.629"><vh>promote</vh></v>
</v>
<v t="ekr.20070626112754.1615"><vh>p.isVisible</vh></v>
<v t="ekr.20070626112754.1616"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20070626112754.1617"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20070626112754.1618"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20070626112754.1619"><vh>p.moveToVisNext</vh></v>
<v t="ekr.20070626112754.602"><vh>selectVisBack</vh></v>
<v t="ekr.20070626112754.603"><vh>selectVisNext</vh></v>
</v>
<v t="ekr.20070626112754.1620"><vh>Improved speed of visNext/Back</vh>
<v t="ekr.20070626112754.1621"><vh>drawTopTree</vh></v>
<v t="ekr.20070626112754.41"><vh>endDrag</vh>
<v t="ekr.20070626112754.42"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20070626112754.43"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1618"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20070626112754.1619"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20070626112754.1622"><vh>Fixed moveToVisBack/Next bugs</vh>
<v t="ekr.20070626112754.1615"><vh>p.isVisible</vh></v>
<v t="ekr.20070626112754.1618"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20070626112754.1619"><vh>p.moveToVisNext</vh></v>
<v t="ekr.20070626112754.627"><vh>moveOutlineUp</vh>
<v t="ekr.20070626112754.628"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1613"><vh>canMoveOutlineUp</vh></v>
</v>
<v t="ekr.20070626112754.1623"><vh>Fixed *major* demote bug</vh>
<v t="ekr.20070626112754.1624"><vh>canDemote</vh></v>
<v t="ekr.20070626112754.1625"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20070626112754.622"><vh>demote</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1626"><vh>Features</vh>
<v t="ekr.20070626112754.1627"><vh>Supported write_strips_blank_lines option</vh>
<v t="ekr.20070626112754.1628"><vh>norefWrite</vh>
<v t="ekr.20070626112754.1629"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="ekr.20070626112754.1630"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1631"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1632"><vh>&lt;&lt; Write p's node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1633"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1634"><vh>asisWrite</vh>
<v t="ekr.20070626112754.1635"><vh>&lt;&lt; Write p's headline if it starts with @@ &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1636"><vh>&lt;&lt; Write p's body &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1233"><vh>putCodeLine</vh></v>
<v t="ekr.20070626112754.1230"><vh>putBody</vh>
<v t="ekr.20070626112754.1231"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1232"><vh>&lt;&lt; handle line at s[i]  &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1637"><vh>cleanLines</vh></v>
</v>
<v t="ekr.20070626112754.1638"><vh>Improved uinit testing</vh>
<v t="ekr.20070626112754.1639"><vh>@@button at-test-nodes</vh></v>
<v t="ekr.20070626112754.1640"><vh>@@button run-test-nodes</vh>
<v t="ekr.20070626112754.1641"><vh>__init__</vh></v>
<v t="ekr.20070626112754.1642"><vh> fail</vh></v>
<v t="ekr.20070626112754.1643"><vh>runTest</vh></v>
<v t="ekr.20070626112754.1644"><vh>isMethod</vh></v>
<v t="ekr.20070626112754.1645"><vh>shortDescription</vh></v>
<v t="ekr.20070626112754.1646"><vh>removeLeadingWs</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1647"><vh>Completed chapters</vh>
<v t="ekr.20070626112754.1648"><vh> getPublicCommands (chapterCommandsClass)</vh></v>
</v>
<v t="ekr.20070626112754.1649"><vh>Aspell now works on Linux, but only using Python 2.5</vh>
<v t="ekr.20070626112754.1304"><vh>getAspellWithCtypes</vh>
<v t="ekr.20070626112754.1305"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1650"><vh>Spell classes</vh>
<v t="ekr.20070626112754.1651"><vh>class spellCommandsClass</vh>
<v t="ekr.20070626112754.1652"><vh>ctor</vh></v>
<v t="ekr.20070626112754.1653"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20070626112754.413"><vh>openSpellTab</vh>
<v t="ekr.20070626112754.414"><vh>commands...</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1017"><vh>class spellTabHandler (leoFind.leoFind)</vh>
<v t="ekr.20070626112754.1018"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.1019"><vh>spellTabHandler.__init__</vh></v>
<v t="ekr.20070626112754.1020"><vh>init_aspell</vh></v>
<v t="ekr.20070626112754.1021"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20070626112754.1022"><vh>Commands</vh>
<v t="ekr.20070626112754.1023"><vh>add</vh></v>
<v t="ekr.20070626112754.1024"><vh>change (spellTab)</vh></v>
<v t="ekr.20070626112754.1025"><vh>find &amp; helpers</vh>
<v t="ekr.20070626112754.1026"><vh>findNextMisspelledWord</vh>
<v t="ekr.20070626112754.1027"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1028"><vh>findNextWord</vh></v>
</v>
<v t="ekr.20070626112754.1029"><vh>hide</vh></v>
<v t="ekr.20070626112754.1030"><vh>ignore</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1654"><vh>class AspellClass</vh>
<v t="ekr.20070626112754.1301"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.1302"><vh>__init__</vh></v>
<v t="ekr.20070626112754.1303"><vh>getAspell</vh></v>
<v t="ekr.20070626112754.1304"><vh>getAspellWithCtypes</vh>
<v t="ekr.20070626112754.1305"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1655"><vh>processWord</vh></v>
<v t="ekr.20070626112754.1656"><vh>suggestions</vh></v>
<v t="ekr.20070626112754.1657"><vh>updateDictionary</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1658"><vh>Improved dynamic abbreviations</vh>
<v t="ekr.20070626112754.1659"><vh>Report</vh></v>
<v t="ekr.20070626112754.1660"><vh>Emacs docs</vh></v>
<v t="ekr.20070626112754.1661"><vh>dynamic abbreviation...</vh>
<v t="ekr.20070626112754.1193"><vh>dynamicCompletion</vh></v>
<v t="ekr.20070626112754.1191"><vh>dynamicExpansion</vh>
<v t="ekr.20070626112754.1192"><vh>dynamicExpandHelper</vh></v>
</v>
<v t="ekr.20070626112754.1662"><vh>getDynamicList (helper)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1663"><vh>Added tab completion for dabbrev-expand</vh>
<v t="ekr.20070626112754.295"><vh>getArg</vh>
<v t="ekr.20070626112754.296"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1191"><vh>dynamicExpansion</vh>
<v t="ekr.20070626112754.1192"><vh>dynamicExpandHelper</vh></v>
</v>
<v t="ekr.20070626112754.1193"><vh>dynamicCompletion</vh></v>
</v>
<v t="ekr.20070626112754.1664"><vh>Created hoist/de-hoist hooks for hoist plugin</vh>
<v t="ekr.20070626112754.1665"><vh>Hoist &amp; dehoist</vh></v>
<v t="ekr.20070626112754.1312"><vh>chapterSelectHelper</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1666"><vh>Enabled more plugins by default</vh></v>
<v t="ekr.20070626112754.1667"><vh>Finished chapters</vh>
<v t="ekr.20070626112754.1668"><vh>Rewrote chapters code</vh>
<v t="ekr.20070626112754.1669"><vh>What I did</vh></v>
<v t="ekr.20070626112754.1670"><vh>Birth...</vh>
<v t="ekr.20070626112754.415"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20070626112754.416"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20070626112754.1273"><vh>new</vh></v>
<v t="ekr.20070626112754.417"><vh>tkFrame.finishCreate &amp; helpers</vh>
<v t="ekr.20070626112754.39"><vh>createOuterFrames</vh></v>
<v t="ekr.20070626112754.418"><vh>createSplitterComponents</vh></v>
<v t="ekr.20070626112754.419"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20070626112754.420"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20070626112754.1413"><vh>cc.finishCreate</vh></v>
<v t="ekr.20070626112754.990"><vh>g.openWithFileName</vh></v>
<v t="ekr.20070626112754.1404"><vh>tkTree.setCanvasBindings</vh>
<v t="ekr.20070626112754.1405"><vh>&lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1406"><vh>&lt;&lt; create baloon bindings for tagged items on the canvas &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1671"><vh>Drawing stuff</vh>
<v t="ekr.20070626112754.1621"><vh>drawTopTree</vh></v>
<v t="ekr.20070626112754.1672"><vh>drawTree</vh></v>
<v t="ekr.20070626112754.1673"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="ekr.20070626112754.1674"><vh>tree.expandAllAncestors</vh></v>
</v>
<v t="ekr.20070626112754.1675"><vh>Creating a new chapter</vh>
<v t="ekr.20070626112754.1397"><vh>cc.createChapter</vh></v>
<v t="ekr.20070626112754.1676"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="ekr.20070626112754.1625"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20070626112754.1580"><vh>c.deleteOutline</vh></v>
<v t="ekr.20070626112754.1677"><vh>c.insertHeadline</vh></v>
<v t="ekr.20070626112754.1678"><vh>c.clone</vh></v>
<v t="ekr.20070626112754.1679"><vh>c.validateOutline</vh></v>
</v>
<v t="ekr.20070626112754.1680"><vh>cc.createChild</vh></v>
</v>
<v t="ekr.20070626112754.1681"><vh>currentPosition &amp; rootPosition stuff</vh>
<v t="ekr.20070626112754.1682"><vh>c.findRootPosition New in 4.4.2</vh></v>
<v t="ekr.20070626112754.192"><vh>c.setCurrentPosition</vh></v>
<v t="ekr.20070626112754.1582"><vh>c.setRootPosition</vh></v>
</v>
<v t="ekr.20070626112754.1683"><vh>Selection stuff</vh>
<v t="ekr.20070626112754.1597"><vh>chapter.findPositionInChapter</vh></v>
<v t="ekr.20070626112754.752"><vh>switchToChapter (leoBody)</vh></v>
<v t="ekr.20070626112754.186"><vh>c.selectPosition</vh></v>
<v t="ekr.20070626112754.1684"><vh>chapter.select &amp; helpers</vh>
<v t="ekr.20070626112754.1312"><vh>chapterSelectHelper</vh></v>
<v t="ekr.20070626112754.1597"><vh>chapter.findPositionInChapter</vh></v>
<v t="ekr.20070626112754.1685"><vh>chapter.findEditorInChapter</vh></v>
<v t="ekr.20070626112754.1686"><vh>chapter.positionIsInChapter</vh></v>
<v t="ekr.20070626112754.1687"><vh>chapter.rename (not used)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1688"><vh>class leoTkinterTreeTab</vh>
<v t="ekr.20070626112754.1689"><vh> Birth &amp; death</vh>
<v t="ekr.20070626112754.1690"><vh> ctor (leoTreeTab)</vh></v>
<v t="ekr.20070626112754.1691"><vh>tt.createControl</vh></v>
</v>
<v t="ekr.20070626112754.1692"><vh>Tabs...</vh>
<v t="ekr.20070626112754.1311"><vh>tt.createTab</vh></v>
<v t="ekr.20070626112754.1693"><vh>tt.destroyTab</vh></v>
<v t="ekr.20070626112754.1313"><vh>tt.selectTab</vh></v>
<v t="ekr.20070626112754.1694"><vh>tt.setTabLabel</vh></v>
<v t="ekr.20070626112754.1695"><vh>tt.setNames</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1696"><vh>Minibuffer commands and Cmds menu</vh>
<v t="ekr.20070626112754.1697"><vh>chapterCommandsClass</vh>
<v t="ekr.20070626112754.1698"><vh> ctor</vh></v>
<v t="ekr.20070626112754.1648"><vh> getPublicCommands (chapterCommandsClass)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1699"><vh>canHoist &amp; canDehoist</vh></v>
<v t="ekr.20070626112754.295"><vh>getArg</vh>
<v t="ekr.20070626112754.296"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1700"><vh>Deleting an @chapter node is equivalent to remove-chapter</vh>
<v t="ekr.20070626112754.1580"><vh>c.deleteOutline</vh></v>
<v t="ekr.20070626112754.1584"><vh>cutOutline</vh></v>
</v>
<v t="ekr.20070626112754.1701"><vh>Removed no-inverse message when loading .leo files from LeoPy.leo.</vh>
<v t="ekr.20070626112754.1702"><vh> ctor: chapterController</vh></v>
<v t="ekr.20070626112754.1212"><vh>createMenuEntries</vh>
<v t="ekr.20070626112754.1213"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1214"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20070626112754.1215"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1216"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1697"><vh>chapterCommandsClass</vh>
<v t="ekr.20070626112754.1698"><vh> ctor</vh></v>
<v t="ekr.20070626112754.1648"><vh> getPublicCommands (chapterCommandsClass)</vh></v>
</v>
<v t="ekr.20070626112754.1703"><vh>app.newLeoCommanderAndFrame</vh>
<v t="ekr.20070626112754.1704"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.415"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20070626112754.416"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20070626112754.474"><vh>createMenusFromTables &amp; helpers</vh>
<v t="ekr.20070626112754.475"><vh>createFileMenuFromTable</vh>
<v t="ekr.20070626112754.476"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.477"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.478"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.479"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.480"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.481"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.482"><vh>createEditMenuFromTable</vh>
<v t="ekr.20070626112754.483"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.484"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.485"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.486"><vh>createOutlineMenuFromTable</vh>
<v t="ekr.20070626112754.487"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.488"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.489"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.490"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.491"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.492"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20070626112754.493"><vh>createWindowMenuFromTable</vh></v>
<v t="ekr.20070626112754.494"><vh>createHelpMenuFromTable</vh></v>
</v>
<v t="ekr.20070626112754.990"><vh>g.openWithFileName</vh></v>
<v t="ekr.20070626112754.640"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20070626112754.417"><vh>tkFrame.finishCreate &amp; helpers</vh>
<v t="ekr.20070626112754.39"><vh>createOuterFrames</vh></v>
<v t="ekr.20070626112754.418"><vh>createSplitterComponents</vh></v>
<v t="ekr.20070626112754.419"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20070626112754.420"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20070626112754.492"><vh>createCmndsMenuFromTable</vh></v>
</v>
<v t="ekr.20070626112754.1705"><vh>Made chapter ops undoable</vh>
<v t="ekr.20070626112754.1676"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="ekr.20070626112754.1625"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20070626112754.1580"><vh>c.deleteOutline</vh></v>
<v t="ekr.20070626112754.1677"><vh>c.insertHeadline</vh></v>
<v t="ekr.20070626112754.1678"><vh>c.clone</vh></v>
<v t="ekr.20070626112754.1679"><vh>c.validateOutline</vh></v>
</v>
<v t="ekr.20070626112754.1706"><vh>Outline menu...</vh>
<v t="ekr.20070626112754.1707"><vh> Top Level... (Commands)</vh>
<v t="ekr.20070626112754.1583"><vh>Cut &amp; Paste Outlines</vh>
<v t="ekr.20070626112754.1584"><vh>cutOutline</vh></v>
<v t="ekr.20070626112754.1585"><vh>copyOutline</vh></v>
<v t="ekr.20070626112754.1586"><vh>pasteOutline</vh>
<v t="ekr.20070626112754.1587"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1588"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1589"><vh>pasteOutlineRetainingClones</vh></v>
</v>
<v t="ekr.20070626112754.1665"><vh>Hoist &amp; dehoist</vh></v>
<v t="ekr.20070626112754.1676"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="ekr.20070626112754.1625"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20070626112754.1580"><vh>c.deleteOutline</vh></v>
<v t="ekr.20070626112754.1677"><vh>c.insertHeadline</vh></v>
<v t="ekr.20070626112754.1678"><vh>c.clone</vh></v>
<v t="ekr.20070626112754.1679"><vh>c.validateOutline</vh></v>
</v>
<v t="ekr.20070626112754.1708"><vh>c.sortChildren</vh></v>
<v t="ekr.20070626112754.1709"><vh>c.sortChildrenHelper</vh></v>
<v t="ekr.20070626112754.1710"><vh>c.sortSiblings</vh></v>
<v t="ekr.20070626112754.1711"><vh>c.sortTopLevel</vh></v>
</v>
<v t="ekr.20070626112754.1712"><vh>Check Outline submenu...</vh>
<v t="ekr.20070626112754.1713"><vh>c.checkOutline</vh>
<v t="ekr.20070626112754.1714"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1715"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20070626112754.1716"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20070626112754.1717"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20070626112754.1718"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20070626112754.1719"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20070626112754.1720"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20070626112754.1721"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20070626112754.1722"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20070626112754.1723"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20070626112754.1724"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1725"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1726"><vh>Check Outline commands &amp; allies</vh>
<v t="ekr.20070626112754.1727"><vh>checkAllPythonCode</vh>
<v t="ekr.20070626112754.1728"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1729"><vh>checkPythonCode</vh>
<v t="ekr.20070626112754.1730"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1731"><vh>checkPythonNode</vh></v>
<v t="ekr.20070626112754.1732"><vh>tabNannyNode</vh></v>
</v>
<v t="ekr.20070626112754.1733"><vh>c.dumpOutline</vh></v>
<v t="ekr.20070626112754.1734"><vh>Pretty Print commands</vh>
<v t="ekr.20070626112754.1735"><vh>prettyPrintAllPythonCode</vh></v>
<v t="ekr.20070626112754.1736"><vh>prettyPrintPythonCode</vh></v>
<v t="ekr.20070626112754.1737"><vh>prettyPrintPythonNode</vh></v>
<v t="ekr.20070626112754.1738"><vh>class prettyPrinter</vh>
<v t="ekr.20070626112754.1739"><vh>__init__</vh>
<v t="ekr.20070626112754.1740"><vh>&lt;&lt; define dispatch dict &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1741"><vh>clear</vh></v>
<v t="ekr.20070626112754.1742"><vh>dumpLines</vh></v>
<v t="ekr.20070626112754.1743"><vh>dumpToken</vh></v>
<v t="ekr.20070626112754.1744"><vh>endUndo</vh></v>
<v t="ekr.20070626112754.1745"><vh>get</vh></v>
<v t="ekr.20070626112754.1746"><vh>prettyPrintNode</vh></v>
<v t="ekr.20070626112754.1747"><vh>put</vh></v>
<v t="ekr.20070626112754.1748"><vh>putArray</vh></v>
<v t="ekr.20070626112754.1749"><vh>putNormalToken &amp; allies</vh>
<v t="ekr.20070626112754.1750"><vh>doEndMarker</vh></v>
<v t="ekr.20070626112754.1751"><vh>doErrorToken</vh></v>
<v t="ekr.20070626112754.1752"><vh>doIndent &amp; doDedent</vh></v>
<v t="ekr.20070626112754.1753"><vh>doMultiLine (strings, etc).</vh></v>
<v t="ekr.20070626112754.1754"><vh>doName</vh></v>
<v t="ekr.20070626112754.1755"><vh>doNewline</vh></v>
<v t="ekr.20070626112754.1756"><vh>doNumber</vh></v>
<v t="ekr.20070626112754.1757"><vh>doOp</vh></v>
<v t="ekr.20070626112754.1758"><vh>doStartLine</vh></v>
<v t="ekr.20070626112754.1759"><vh>oops</vh></v>
<v t="ekr.20070626112754.1760"><vh>trace</vh></v>
</v>
<v t="ekr.20070626112754.1761"><vh>putToken</vh></v>
<v t="ekr.20070626112754.1762"><vh>replaceBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1763"><vh>Expand &amp; Contract...</vh>
<v t="ekr.20070626112754.607"><vh>Commands (outline menu)</vh>
<v t="ekr.20070626112754.608"><vh>contractAllHeadlines</vh></v>
<v t="ekr.20070626112754.609"><vh>contractNode</vh></v>
<v t="ekr.20070626112754.610"><vh>contractNodeOrGoToParent</vh></v>
<v t="ekr.20070626112754.611"><vh>contractParent</vh></v>
<v t="ekr.20070626112754.612"><vh>expandAllHeadlines</vh></v>
<v t="ekr.20070626112754.613"><vh>expandAllSubheads</vh></v>
<v t="ekr.20070626112754.614"><vh>expandLevel1..9</vh></v>
<v t="ekr.20070626112754.615"><vh>expandNextLevel</vh></v>
<v t="ekr.20070626112754.616"><vh>expandNode</vh></v>
<v t="ekr.20070626112754.617"><vh>expandNodeAnd/OrGoToFirstChild</vh></v>
<v t="ekr.20070626112754.618"><vh>expandOnlyAncestorsOfNode</vh></v>
<v t="ekr.20070626112754.619"><vh>expandPrevLevel</vh></v>
</v>
<v t="ekr.20070626112754.1764"><vh>Utilities</vh>
<v t="ekr.20070626112754.1765"><vh>contractSubtree</vh></v>
<v t="ekr.20070626112754.1766"><vh>expandSubtree</vh></v>
<v t="ekr.20070626112754.1767"><vh>expandToLevel (rewritten in 4.4)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1768"><vh>Mark...</vh>
<v t="ekr.20070626112754.1769"><vh>markChangedHeadlines</vh></v>
<v t="ekr.20070626112754.1770"><vh>markChangedRoots</vh></v>
<v t="ekr.20070626112754.1771"><vh>markAllAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20070626112754.1772"><vh>markAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20070626112754.1773"><vh>markClones</vh></v>
<v t="ekr.20070626112754.1774"><vh>markHeadline</vh></v>
<v t="ekr.20070626112754.1775"><vh>markSubheads</vh></v>
<v t="ekr.20070626112754.1776"><vh>unmarkAll</vh></v>
</v>
<v t="ekr.20070626112754.620"><vh>Move... (Commands)</vh>
<v t="ekr.20070626112754.621"><vh>cantMoveMessage</vh></v>
<v t="ekr.20070626112754.622"><vh>demote</vh></v>
<v t="ekr.20070626112754.623"><vh>moveOutlineDown</vh>
<v t="ekr.20070626112754.624"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.625"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20070626112754.626"><vh>moveOutlineRight</vh></v>
<v t="ekr.20070626112754.627"><vh>moveOutlineUp</vh>
<v t="ekr.20070626112754.628"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.629"><vh>promote</vh></v>
</v>
<v t="ekr.20070626112754.585"><vh>Goto</vh>
<v t="ekr.20070626112754.586"><vh>goNextVisitedNode</vh></v>
<v t="ekr.20070626112754.587"><vh>goPrevVisitedNode</vh></v>
<v t="ekr.20070626112754.588"><vh>goToFirstNode</vh></v>
<v t="ekr.20070626112754.589"><vh>goToFirstSibling</vh></v>
<v t="ekr.20070626112754.590"><vh>goToFirstVisibleNode</vh></v>
<v t="ekr.20070626112754.591"><vh>goToLastNode</vh></v>
<v t="ekr.20070626112754.592"><vh>goToLastSibling</vh></v>
<v t="ekr.20070626112754.593"><vh>c.goToLastVisibleNode</vh></v>
<v t="ekr.20070626112754.594"><vh>goToNextClone</vh></v>
<v t="ekr.20070626112754.595"><vh>goToNextDirtyHeadline</vh></v>
<v t="ekr.20070626112754.596"><vh>goToNextMarkedHeadline</vh></v>
<v t="ekr.20070626112754.597"><vh>goToNextSibling</vh></v>
<v t="ekr.20070626112754.598"><vh>goToParent</vh></v>
<v t="ekr.20070626112754.599"><vh>goToPrevSibling</vh></v>
<v t="ekr.20070626112754.600"><vh>selectThreadBack</vh></v>
<v t="ekr.20070626112754.601"><vh>selectThreadNext</vh></v>
<v t="ekr.20070626112754.602"><vh>selectVisBack</vh></v>
<v t="ekr.20070626112754.603"><vh>selectVisNext</vh></v>
<v t="ekr.20070626112754.604"><vh>utils</vh>
<v t="ekr.20070626112754.605"><vh> treeFocusHelper (new in Leo 4.4.3)</vh></v>
<v t="ekr.20070626112754.606"><vh> treeSelectHelper (new in Leo 4.4.3)</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1777"><vh>Dragging (commands)</vh>
<v t="ekr.20070626112754.1778"><vh>c.dragAfter</vh></v>
<v t="ekr.20070626112754.1779"><vh>c.dragCloneToNthChildOf</vh></v>
<v t="ekr.20070626112754.1780"><vh>c.dragToNthChildOf</vh></v>
<v t="ekr.20070626112754.1781"><vh>c.dragCloneAfter</vh></v>
</v>
<v t="ekr.20070626112754.1782"><vh>Commands (chapters)</vh>
<v t="ekr.20070626112754.1783"><vh>cc.cloneNodeToChapter &amp; helper</vh>
<v t="ekr.20070626112754.1784"><vh>cc.cloneToChapterHelper</vh></v>
</v>
<v t="ekr.20070626112754.1785"><vh>cc.convertNodeToChapter</vh></v>
<v t="ekr.20070626112754.1786"><vh>cc.copyNodeToChapter &amp; helper</vh>
<v t="ekr.20070626112754.1787"><vh>cc.copyNodeToChapterHelper</vh></v>
</v>
<v t="ekr.20070626112754.1397"><vh>cc.createChapter</vh></v>
<v t="ekr.20070626112754.1788"><vh>cc.createChapterByName</vh></v>
<v t="ekr.20070626112754.1789"><vh>cc.createChapterFromNode</vh></v>
<v t="ekr.20070626112754.1790"><vh>cc.moveNodeToChapter &amp; helper</vh>
<v t="ekr.20070626112754.1791"><vh>cc.moveNodeToChapterHelper</vh></v>
</v>
<v t="ekr.20070626112754.1792"><vh>cc.removeChapter</vh></v>
<v t="ekr.20070626112754.1793"><vh>cc.removeChapterByName</vh></v>
<v t="ekr.20070626112754.1794"><vh>cc.renameChapter &amp; testHelper</vh></v>
<v t="ekr.20070626112754.1795"><vh>cc.selectChapter</vh></v>
<v t="ekr.20070626112754.1596"><vh>cc.selectChapterByName</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1796"><vh>Leo 4.4.3 b3 projects</vh>
<v t="ekr.20070626112754.1797"><vh>Fixed bugs</vh>
<v t="ekr.20070626112754.1798"><vh>Allow aspell on Linux provided that ctypes exists</vh>
<v t="ekr.20070626112754.1301"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.1302"><vh>__init__</vh></v>
<v t="ekr.20070626112754.1303"><vh>getAspell</vh></v>
<v t="ekr.20070626112754.1304"><vh>getAspellWithCtypes</vh>
<v t="ekr.20070626112754.1305"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1799"><vh>Fixed a bug that disabled icon button colors on Linux</vh></v>
<v t="ekr.20070626112754.1800"><vh>Made alt menu keys work</vh>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.464"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20070626112754.465"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20070626112754.466"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20070626112754.467"><vh>callStateFunction</vh></v>
<v t="ekr.20070626112754.468"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20070626112754.469"><vh>handleDefaultChar</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1801"><vh>Switch chapters if new position isn't in current chapter</vh>
<v t="ekr.20070626112754.1802"><vh>Report</vh></v>
<v t="ekr.20070626112754.606"><vh> treeSelectHelper (new in Leo 4.4.3)</vh></v>
<v t="ekr.20070626112754.51"><vh>selectEditorHelper</vh>
<v t="ekr.20070626112754.52"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1686"><vh>chapter.positionIsInChapter</vh></v>
<v t="ekr.20070626112754.1686"><vh>chapter.positionIsInChapter</vh></v>
<v t="ekr.20070626112754.1610"><vh>c.lastVisible</vh></v>
<v t="ekr.20070626112754.1803"><vh>c.firstVisible</vh></v>
<v t="ekr.20070626112754.1619"><vh>p.moveToVisNext</vh></v>
<v t="ekr.20070626112754.590"><vh>goToFirstVisibleNode</vh></v>
<v t="ekr.20070626112754.517"><vh>defineOutlineMenuGoToMenuTable</vh></v>
<v t="ekr.20070626112754.1804"><vh>cc.selectChapterForPosition</vh></v>
<v t="ekr.20070626112754.1597"><vh>chapter.findPositionInChapter</vh></v>
<v t="ekr.20070626112754.186"><vh>c.selectPosition</vh></v>
<v t="ekr.20070626112754.1674"><vh>tree.expandAllAncestors</vh></v>
</v>
<v t="ekr.20070626112754.1805"><vh>Improved goto-next/prev-node commands</vh>
<v t="ekr.20070626112754.1806"><vh>class nodeHistory</vh>
<v t="ekr.20070626112754.1807"><vh>canGoToNext/Prev</vh></v>
<v t="ekr.20070626112754.1808"><vh>clear</vh></v>
<v t="ekr.20070626112754.1809"><vh>goNext/Prev</vh></v>
<v t="ekr.20070626112754.1810"><vh>nodeHistory.ctor</vh></v>
<v t="ekr.20070626112754.1811"><vh>remove</vh></v>
<v t="ekr.20070626112754.1812"><vh>selectChapter</vh></v>
<v t="ekr.20070626112754.1813"><vh>update &amp; helpers</vh>
<v t="ekr.20070626112754.1814"><vh>updatePositionList</vh></v>
<v t="ekr.20070626112754.1815"><vh>updateVisitedList</vh></v>
</v>
<v t="ekr.20070626112754.1816"><vh>visitedPositions</vh></v>
</v>
<v t="ekr.20070626112754.587"><vh>goPrevVisitedNode</vh></v>
<v t="ekr.20070626112754.586"><vh>goNextVisitedNode</vh></v>
<v t="ekr.20070626112754.606"><vh> treeSelectHelper (new in Leo 4.4.3)</vh></v>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1817"><vh>&lt;&lt; enable go to submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1818"><vh>Fixed failing bridge unit test</vh>
<v t="ekr.20070626112754.1637"><vh>cleanLines</vh></v>
</v>
<v t="ekr.20070626112754.1819"><vh>Applied patch for cleo coloring problem</vh></v>
<v t="ekr.20070626112754.1820"><vh>Fixed php coloring problems</vh>
<v t="ekr.20070626112754.1821"><vh>Report</vh></v>
<v t="ekr.20070626112754.1822"><vh>&lt;&lt; define dispatch dicts &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1823"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
<v t="ekr.20070626112754.1824"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1825"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1826"><vh>doNormalState</vh>
<v t="ekr.20070626112754.1827"><vh>Valid regardless of latex mode</vh>
<v t="ekr.20070626112754.1828"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="ekr.20070626112754.1829"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1830"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1831"><vh>&lt;&lt; handle possible forth keyword &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1824"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1832"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="ekr.20070626112754.1833"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1834"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1835"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1836"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1837"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1838"><vh>Vaid only in latex mode</vh>
<v t="ekr.20070626112754.1839"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1840"><vh>Valid when not in latex_mode</vh>
<v t="ekr.20070626112754.1841"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1842"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1825"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1843"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1844"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1845"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1846"><vh>New features &amp; settings</vh>
<v t="ekr.20070626112754.1847"><vh>Added @bool contractVisitedNodes setting</vh></v>
<v t="ekr.20070626112754.1848"><vh>Added goto-first-visible-node command</vh></v>
<v t="ekr.20070626112754.1849"><vh>Changed binding of Alt-Home</vh></v>
<v t="ekr.20070626112754.1850"><vh>leoDist.leo now creates a python egg</vh></v>
<v t="ekr.20070626112754.1851"><vh>Removed Linux install/uninstall scripts</vh></v>
<v t="ekr.20070626112754.1852"><vh>Added @button dynamic-tests.</vh></v>
<v t="ekr.20070626112754.1853"><vh>created g.getTestVars</vh></v>
<v t="ekr.20070626112754.1854"><vh>Clean up unit tests in this file</vh></v>
<v t="ekr.20070626112754.1855"><vh>Added a section in this file called How to make Leo commands undoable</vh>
<v t="ekr.20070626112754.1856"><vh>How to make Leo commands undoable</vh>
<v t="ekr.20070626112754.1857"><vh>Undo</vh>
<v t="ekr.20070626112754.1858"><vh>afterCreateChapter</vh></v>
<v t="ekr.20070626112754.1859"><vh>afterRemoveChapter</vh></v>
<v t="ekr.20070626112754.1860"><vh>beforeCreateChapter</vh></v>
<v t="ekr.20070626112754.1861"><vh>beforeRemoveChapter</vh></v>
<v t="ekr.20070626112754.1862"><vh>redoInsertChapter</vh></v>
<v t="ekr.20070626112754.1863"><vh>redoRemoveChapter</vh></v>
<v t="ekr.20070626112754.1864"><vh>undoInsertChapter</vh></v>
<v t="ekr.20070626112754.1865"><vh>undoRemoveChapter</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20070703172620"><vh>Leo 4.4.3.1 projects</vh>
<v t="ekr.20070703172620.1" a="E"><vh>Bugs</vh>
<v t="ekr.20070703172620.2"><vh>Fixed improper can not open myLeoSettings message</vh>
<v t="ekr.20070703172620.3"><vh>openLeoSettings and openMyLeoSettings</vh></v>
<v t="ekr.20070703172620.4"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20070703172620.5"><vh>Fixed import problem in leoDynamicTest.py</vh>
<v t="ekr.20070703172620.6"><vh>debugCommandsClass</vh>
<v t="ekr.20070703172620.7"><vh> ctor</vh></v>
<v t="ekr.20070703172620.8"><vh> getPublicCommands</vh></v>
<v t="ekr.20070703172620.9"><vh>collectGarbage</vh></v>
<v t="ekr.20070703172620.10"><vh>debug &amp; helper</vh>
<v t="ekr.20070703172620.11"><vh>findDebugger</vh></v>
</v>
<v t="ekr.20070703172620.12"><vh>dumpAll/New/VerboseObjects</vh></v>
<v t="ekr.20070703172620.13"><vh>enable/disableGcTrace</vh></v>
<v t="ekr.20070703172620.14"><vh>freeTreeWidgets</vh></v>
<v t="ekr.20070703172620.15"><vh>printFocus</vh></v>
<v t="ekr.20070703172620.16"><vh>printGcSummary</vh></v>
<v t="ekr.20070703172620.17"><vh>printStats</vh></v>
<v t="ekr.20070703172620.18"><vh>runUnitTest commands</vh></v>
</v>
<v t="ekr.20070703172620.19"><vh>Compute directories... (leoGlobals)</vh>
<v t="ekr.20070703172620.20"><vh>computeGlobalConfigDir</vh></v>
<v t="ekr.20070703172620.21"><vh>computeHomeDir</vh></v>
<v t="ekr.20070703172620.22"><vh>computeLeoDir</vh></v>
<v t="ekr.20070703172620.23"><vh>computeLoadDir</vh></v>
<v t="ekr.20070703172620.24"><vh>computeStandardDirectories</vh></v>
<v t="ekr.20070703172620.25"><vh>startupEncoding</vh></v>
</v>
<v t="ekr.20070703172620.26"><vh>runTestsExternally &amp; helper class</vh>
<v t="ekr.20070703172620.27"><vh>class runTestHelperClass</vh>
<v t="ekr.20070703172620.28"><vh> ctor: runTestHelperClass</vh></v>
<v t="ekr.20070703172620.29"><vh>createFileFromOutline</vh></v>
<v t="ekr.20070703172620.30"><vh>createOutline</vh></v>
<v t="ekr.20070703172620.31"><vh>runTests</vh></v>
<v t="ekr.20070703172620.32"><vh>runLeoDynamicTest</vh></v>
<v t="ekr.20070703172620.33"><vh>searchOutline</vh></v>
</v>
</v>
</v>
<v t="ekr.20070703172620.34"><vh>Fixed cleo crasher</vh></v>
<v t="ekr.20070703172620.35"><vh>Fixed spell-check bug</vh>
<v t="ekr.20070703172620.36"><vh>find &amp; helpers</vh>
<v t="ekr.20070703172620.37"><vh>findNextMisspelledWord</vh>
<v t="ekr.20070703172620.38"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070703172620.39"><vh>findNextWord</vh></v>
</v>
</v>
<v t="ekr.20070703172620.40"><vh>Fixed several crashers in the group operations plugin</vh></v>
<v t="ekr.20070703172620.41"><vh>Fixed chapters bug</vh>
<v t="ekr.20070703172620.42"><vh>cc.selectChapterForPosition</vh></v>
</v>
<v t="ekr.20070703172620.43"><vh>Fixed problems in groupOperations plugin</vh>
<v t="ekr.20070703172620.44"><vh>getLeoOutlineFromClipboard &amp; helpers</vh>
<v t="ekr.20070703172620.45"><vh>finishPaste</vh>
<v t="ekr.20070703172620.46"><vh>&lt;&lt; reassign tnode indices &gt;&gt;</vh></v>
</v>
<v t="ekr.20070703172620.47"><vh>getLeoOutlineHelper</vh>
<v t="ekr.20070703172620.48"><vh>&lt;&lt; recreate tnodesDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20070703172620.49"><vh>getClipboardHeader</vh></v>
</v>
</v>
<v t="ekr.20070703172620.50"><vh>Fixed pychecker complaints</vh></v>
<v t="ekr.20070703172620.51"><vh>Fixed bug: deleting an editor does select the proper body pane</vh>
<v t="ekr.20070703172620.52"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20070703172620.53"><vh>selectEditorHelper</vh>
<v t="ekr.20070703172620.54"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070703172620.55"><vh>Features</vh>
<v t="ekr.20070703172620.56"><vh>g.es and g.es_print print only to console during unit tests</vh>
<v t="ekr.20070703172620.57"><vh>es_print &amp; test</vh>
<v t="ekr.20070703172620.58"><vh>@test g.es_print</vh></v>
</v>
<v t="ekr.20070703172620.59"><vh>es</vh></v>
</v>
<v t="ekr.20070703172620.60"><vh>Suppressed status messages during unit testing</vh></v>
<v t="ekr.20070703172620.61"><vh>Run unit tests in a separate process</vh>
<v t="ekr.20070703172620.6"><vh>debugCommandsClass</vh>
<v t="ekr.20070703172620.7"><vh> ctor</vh></v>
<v t="ekr.20070703172620.8"><vh> getPublicCommands</vh></v>
<v t="ekr.20070703172620.9"><vh>collectGarbage</vh></v>
<v t="ekr.20070703172620.10"><vh>debug &amp; helper</vh>
<v t="ekr.20070703172620.11"><vh>findDebugger</vh></v>
</v>
<v t="ekr.20070703172620.12"><vh>dumpAll/New/VerboseObjects</vh></v>
<v t="ekr.20070703172620.13"><vh>enable/disableGcTrace</vh></v>
<v t="ekr.20070703172620.14"><vh>freeTreeWidgets</vh></v>
<v t="ekr.20070703172620.15"><vh>printFocus</vh></v>
<v t="ekr.20070703172620.16"><vh>printGcSummary</vh></v>
<v t="ekr.20070703172620.17"><vh>printStats</vh></v>
<v t="ekr.20070703172620.18"><vh>runUnitTest commands</vh></v>
</v>
<v t="ekr.20070703172620.62"><vh>doTests...</vh>
<v t="ekr.20070703172620.63"><vh>class generalTestCase</vh>
<v t="ekr.20070703172620.64"><vh>__init__</vh></v>
<v t="ekr.20070703172620.65"><vh> fail</vh></v>
<v t="ekr.20070703172620.66"><vh>setUp</vh></v>
<v t="ekr.20070703172620.67"><vh>tearDown</vh></v>
<v t="ekr.20070703172620.68"><vh>runTest</vh></v>
<v t="ekr.20070703172620.69"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20070703172620.70"><vh>makeTestSuite</vh></v>
<v t="ekr.20070703172620.71"><vh>makeTestCase</vh></v>
</v>
<v t="ekr.20070703172620.26"><vh>runTestsExternally &amp; helper class</vh>
<v t="ekr.20070703172620.27"><vh>class runTestHelperClass</vh>
<v t="ekr.20070703172620.28"><vh> ctor: runTestHelperClass</vh></v>
<v t="ekr.20070703172620.29"><vh>createFileFromOutline</vh></v>
<v t="ekr.20070703172620.30"><vh>createOutline</vh></v>
<v t="ekr.20070703172620.31"><vh>runTests</vh></v>
<v t="ekr.20070703172620.32"><vh>runLeoDynamicTest</vh></v>
<v t="ekr.20070703172620.33"><vh>searchOutline</vh></v>
</v>
</v>
</v>
<v t="ekr.20070703172620.72"><vh>Move most unit tests into derived files</vh></v>
<v t="ekr.20070703172620.73"><vh>Send can not import aspell message only to the log</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910"><vh>Leo 4.4.4 projects</vh>
<v t="ekr.20071102162910.1"><vh>4.4.4 b2</vh>
<v t="ekr.20071102162910.2"><vh>Bugs</vh>
<v t="ekr.20071102162910.3"><vh>removed leoKeywords from colorizer</vh></v>
<v t="ekr.20071102162910.4"><vh>Fixed UNL bug1</vh>
<v t="ekr.20071102162910.5"><vh>g.findNode... &amp;,findTopLevelNode</vh></v>
</v>
<v t="ekr.20071102162910.6"><vh>Fixed how @auto handles paths</vh>
<v t="ekr.20071102162910.7"><vh>atFile.scanDefaultDirectory</vh>
<v t="ekr.20071102162910.8"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="ekr.20071102162910.9"><vh>&lt;&lt; handle @path &gt;&gt;</vh>
<v t="ekr.20071102162910.10"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20071102162910.11"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.12"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.13"><vh>createOutline</vh>
<v t="ekr.20071102162910.14"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.15"><vh>Fixed another path bug</vh>
<v t="ekr.20071102162910.7"><vh>atFile.scanDefaultDirectory</vh>
<v t="ekr.20071102162910.8"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="ekr.20071102162910.9"><vh>&lt;&lt; handle @path &gt;&gt;</vh>
<v t="ekr.20071102162910.10"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20071102162910.11"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.12"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.16"><vh>fixed c parser so it handles non-ascii declaratsions</vh></v>
<v t="ekr.20071102162910.17"><vh>Fixed colorizing bug and moved calls to w.toGuiIndex out of some loops</vh></v>
<v t="ekr.20071102162910.18"><vh>Fixed unicode bug in http plugin</vh></v>
<v t="ekr.20071102162910.19"><vh>Fixed new @path problem</vh>
<v t="ekr.20071102162910.20"><vh>g.makeAllNonExistentDirectories</vh></v>
<v t="ekr.20071102162910.7"><vh>atFile.scanDefaultDirectory</vh>
<v t="ekr.20071102162910.8"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="ekr.20071102162910.9"><vh>&lt;&lt; handle @path &gt;&gt;</vh>
<v t="ekr.20071102162910.10"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20071102162910.11"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.12"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.21"><vh>read</vh>
<v t="ekr.20071102162910.22"><vh>&lt;&lt; set fileName &gt;&gt;</vh></v>
<v t="ekr.20071102162910.23"><vh>&lt;&lt; warn about non-empty unvisited nodes &gt;&gt;</vh></v>
<v t="ekr.20071102162910.24"><vh>&lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;</vh></v>
<v t="ekr.20071102162910.25"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.26"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20071102162910.27"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20071102162910.28"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20071102162910.29"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20071102162910.30"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20071102162910.31"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.32"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20071102162910.33"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20071102162910.34"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20071102162910.35"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20071102162910.36"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20071102162910.37"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20071102162910.38"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20071102162910.39"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.40"><vh>Fixed @auto path bug</vh>
<v t="ekr.20071102162910.41"><vh>writeAtAutoNodes &amp; writeDirtyAtFileNodes (atFile) &amp; helpers</vh>
<v t="ekr.20071102162910.42"><vh>writeAtAutoNodesHelper</vh></v>
<v t="ekr.20071102162910.43"><vh>writeOneAtAutoNode &amp; helpers</vh>
<v t="ekr.20071102162910.44"><vh>shouldWriteAtAutoNode</vh></v>
<v t="ekr.20071102162910.45"><vh>isSignificantAtAutoTree &amp; test</vh>
<v t="ekr.20071102162910.46"><vh>@test test isSignificantAtAutoTree</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20071102162910.47"><vh>Improved messages on @import failure</vh>
<v t="ekr.20071102162910.48"><vh>checkTrialWrite &amp; tests</vh>
<v t="ekr.20071102162910.49"><vh>@test checkTriailWrite</vh></v>
</v>
</v>
<v t="ekr.20071102162910.50"><vh>Fixed problem with space in path names in runLeoDynamicTest</vh>
<v t="ekr.20071102162910.51"><vh>runLeoDynamicTest</vh></v>
</v>
<v t="ekr.20071102162910.52"><vh>Fixed bad drag &amp; drop bug</vh>
<v t="ekr.20071102162910.53"><vh>Dragging (tkTree)</vh>
<v t="ekr.20071102162910.54"><vh>endDrag</vh>
<v t="ekr.20071102162910.55"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20071102162910.56"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.57"><vh>startDrag</vh></v>
<v t="ekr.20071102162910.58"><vh>onContinueDrag</vh>
<v t="ekr.20071102162910.59"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.60"><vh>onDrag</vh></v>
<v t="ekr.20071102162910.61"><vh>onEndDrag</vh></v>
</v>
<v t="ekr.20071102162910.62"><vh>Dragging (commands)</vh>
<v t="ekr.20071102162910.63"><vh>c.dragAfter</vh></v>
<v t="ekr.20071102162910.64"><vh>c.dragToNthChildOf</vh></v>
<v t="ekr.20071102162910.65"><vh>c.dragCloneToNthChildOf</vh></v>
<v t="ekr.20071102162910.66"><vh>c.dragCloneAfter</vh></v>
</v>
<v t="ekr.20071102162910.67"><vh>c.checkMoveWithParentWithWarning &amp; c.checkDrag</vh>
<v t="ekr.20071102162910.68"><vh>checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20071102162910.69"><vh>checkDrag</vh></v>
</v>
<v t="ekr.20071102162910.70"><vh>moveOutlineUp</vh>
<v t="ekr.20071102162910.71"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.72"><vh>Fixed bug 'node note selected' bug</vh>
<v t="ekr.20071102162910.73"><vh>expandAllHeadlines</vh></v>
<v t="ekr.20071102162910.74"><vh>setMoveCol &amp; test</vh>
<v t="ekr.20071102162910.75"><vh>@test setMoveCol</vh></v>
</v>
<v t="ekr.20071102162910.76"><vh>onClick</vh>
<v t="ekr.20071102162910.77"><vh>@test onClick</vh></v>
</v>
</v>
<v t="ekr.20071102162910.78"><vh>Fixed recent crasher involving pr and es_print</vh>
<v t="ekr.20071102162910.79"><vh>es_print</vh>
<v t="ekr.20071102162910.80"><vh>@@test g.es_print</vh></v>
</v>
<v t="ekr.20071102162910.81"><vh>reportMismatch &amp; test</vh>
<v t="ekr.20071102162910.82"><vh>minitest of pr</vh></v>
</v>
</v>
<v t="ekr.20071102162910.83"><vh>Retain dirty bit after write @auto fails</vh>
<v t="ekr.20071102162910.43"><vh>writeOneAtAutoNode &amp; helpers</vh>
<v t="ekr.20071102162910.44"><vh>shouldWriteAtAutoNode</vh></v>
<v t="ekr.20071102162910.45"><vh>isSignificantAtAutoTree &amp; test</vh>
<v t="ekr.20071102162910.46"><vh>@test test isSignificantAtAutoTree</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20071102162910.84"><vh>Features</vh>
<v t="ekr.20071102162910.85"><vh>Added support for @mark-for-unit-tests node</vh>
<v t="ekr.20071102162910.86"><vh>runTestsExternally &amp; helper class</vh>
<v t="ekr.20071102162910.87"><vh>class runTestHelperClass</vh>
<v t="ekr.20071102162910.88"><vh> ctor: runTestHelperClass</vh></v>
<v t="ekr.20071102162910.89"><vh>createFileFromOutline</vh></v>
<v t="ekr.20071102162910.90"><vh>createOutline &amp; helpers</vh>
<v t="ekr.20071102162910.91"><vh>&lt;&lt; set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 &gt;&gt;</vh></v>
<v t="ekr.20071102162910.92"><vh>addMarkTree</vh></v>
<v t="ekr.20071102162910.93"><vh>addNode</vh></v>
<v t="ekr.20071102162910.94"><vh>isUnitTestNode</vh></v>
</v>
<v t="ekr.20071102162910.95"><vh>runTests</vh></v>
<v t="ekr.20071102162910.51"><vh>runLeoDynamicTest</vh></v>
<v t="ekr.20071102162910.96"><vh>searchOutline</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.97"><vh>Created threading_colorizer</vh></v>
<v t="ekr.20071102162910.98"><vh>Added @auto</vh>
<v t="ekr.20071102162910.99"><vh>read/write-at-auto-nodes commands</vh>
<v t="ekr.20071102162910.100"><vh>Reading...</vh>
<v t="ekr.20071102162910.13"><vh>createOutline</vh>
<v t="ekr.20071102162910.14"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.101"><vh>run (baseScannerClass)</vh>
<v t="ekr.20071102162910.102"><vh>regularizeWhitespace</vh>
<v t="ekr.20071102162910.103"><vh>regularizeError</vh></v>
</v>
</v>
<v t="ekr.20071102162910.104"><vh>readAtAutoNodes (commands)</vh></v>
<v t="ekr.20071102162910.105"><vh>readAtAutoNodes (importCommands) &amp; helper</vh>
<v t="ekr.20071102162910.106"><vh>readOneAtAutoNode</vh></v>
</v>
</v>
<v t="ekr.20071102162910.107"><vh>Writing...</vh>
<v t="ekr.20071102162910.108"><vh>closeWriteFile</vh></v>
<v t="ekr.20071102162910.109"><vh>openFileForWriting &amp; openFileForWritingHelper</vh>
<v t="ekr.20071102162910.110"><vh>openFileForWritingHelper</vh></v>
</v>
<v t="ekr.20071102162910.111"><vh>writeAll (atFile)</vh>
<v t="ekr.20071102162910.112"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="ekr.20071102162910.113"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="ekr.20071102162910.114"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.115"><vh>write</vh>
<v t="ekr.20071102162910.116"><vh>&lt;&lt; set at.targetFileName &gt;&gt;</vh></v>
<v t="ekr.20071102162910.117"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.118"><vh>writeOpenFile</vh></v>
<v t="ekr.20071102162910.41"><vh>writeAtAutoNodes &amp; writeDirtyAtFileNodes (atFile) &amp; helpers</vh>
<v t="ekr.20071102162910.42"><vh>writeAtAutoNodesHelper</vh></v>
<v t="ekr.20071102162910.43"><vh>writeOneAtAutoNode &amp; helpers</vh>
<v t="ekr.20071102162910.44"><vh>shouldWriteAtAutoNode</vh></v>
<v t="ekr.20071102162910.45"><vh>isSignificantAtAutoTree &amp; test</vh>
<v t="ekr.20071102162910.46"><vh>@test test isSignificantAtAutoTree</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20071102162910.119"><vh>scannerUnitTest</vh></v>
<v t="ekr.20071102162910.120"><vh> class baseScannerClass</vh>
<v t="ekr.20071102162910.121"><vh>baseScannerClass.__init__</vh></v>
<v t="ekr.20071102162910.122"><vh>Checking</vh>
<v t="ekr.20071102162910.123"><vh>check</vh></v>
<v t="ekr.20071102162910.48"><vh>checkTrialWrite &amp; tests</vh>
<v t="ekr.20071102162910.49"><vh>@test checkTriailWrite</vh></v>
</v>
<v t="ekr.20071102162910.124"><vh>compareHelper &amp; tests</vh>
<v t="ekr.20071102162910.125"><vh>@test compareHelper</vh></v>
<v t="ekr.20071102162910.126"><vh>@test compareHelper-warning</vh></v>
</v>
<v t="ekr.20071102162910.81"><vh>reportMismatch &amp; test</vh>
<v t="ekr.20071102162910.82"><vh>minitest of pr</vh></v>
</v>
</v>
<v t="ekr.20071102162910.127"><vh>Code generation</vh>
<v t="ekr.20071102162910.128"><vh>addRef</vh></v>
<v t="ekr.20071102162910.129"><vh>createDeclsNode</vh></v>
<v t="ekr.20071102162910.130"><vh>createFunctionNode</vh></v>
<v t="ekr.20071102162910.131"><vh>createHeadline</vh></v>
<v t="ekr.20071102162910.132"><vh>getLeadingIndent</vh></v>
<v t="ekr.20071102162910.133"><vh>indentBody</vh></v>
<v t="ekr.20071102162910.134"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20071102162910.135"><vh>massageComment</vh></v>
<v t="ekr.20071102162910.136"><vh>putClass &amp; helpers</vh>
<v t="ekr.20071102162910.137"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071102162910.138"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071102162910.139"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20071102162910.141"><vh>putFunction</vh></v>
<v t="ekr.20071102162910.142"><vh>putRootText</vh></v>
<v t="ekr.20071102162910.143"><vh>undentBody &amp; undentBy</vh></v>
<v t="ekr.20071102162910.144"><vh>underindentedComment &amp; underindentedLine</vh></v>
</v>
<v t="ekr.20071102162910.145"><vh>error &amp; oops</vh></v>
<v t="ekr.20071102162910.146"><vh>Parsing</vh>
<v t="ekr.20071102162910.147"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.148"><vh>getIndent</vh></v>
<v t="ekr.20071102162910.149"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071102162910.150"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20071102162910.151"><vh>skipArgs</vh></v>
<v t="ekr.20071102162910.152"><vh>skipBlock</vh></v>
<v t="ekr.20071102162910.153"><vh>skipCodeBlock</vh></v>
<v t="ekr.20071102162910.154"><vh>skipComment &amp; helper</vh>
<v t="ekr.20071102162910.155"><vh>skipBlockComment</vh></v>
</v>
<v t="ekr.20071102162910.156"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20071102162910.157"><vh>adjustClassOrFunctionStart</vh></v>
</v>
<v t="ekr.20071102162910.158"><vh>skipId</vh></v>
<v t="ekr.20071102162910.159"><vh>skipNewline</vh></v>
<v t="ekr.20071102162910.160"><vh>skipParens</vh></v>
<v t="ekr.20071102162910.161"><vh>skipString</vh></v>
<v t="ekr.20071102162910.162"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.164"><vh>skipSigStart</vh></v>
<v t="ekr.20071102162910.165"><vh>skipSigTail</vh></v>
<v t="ekr.20071102162910.166"><vh>skipSigId</vh></v>
</v>
<v t="ekr.20071102162910.167"><vh>startsComment</vh></v>
<v t="ekr.20071102162910.168"><vh>startsId</vh></v>
<v t="ekr.20071102162910.169"><vh>startsString</vh></v>
</v>
<v t="ekr.20071102162910.101"><vh>run (baseScannerClass)</vh>
<v t="ekr.20071102162910.102"><vh>regularizeWhitespace</vh>
<v t="ekr.20071102162910.103"><vh>regularizeError</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.170"><vh>Regularize whitespace</vh>
<v t="ekr.20071102162910.171"><vh>convertBlanks</vh></v>
<v t="ekr.20071102162910.172"><vh>convertTabs</vh></v>
<v t="ekr.20071102162910.101"><vh>run (baseScannerClass)</vh>
<v t="ekr.20071102162910.102"><vh>regularizeWhitespace</vh>
<v t="ekr.20071102162910.103"><vh>regularizeError</vh></v>
</v>
</v>
<v t="ekr.20071102162910.123"><vh>check</vh></v>
<v t="ekr.20071102162910.102"><vh>regularizeWhitespace</vh>
<v t="ekr.20071102162910.103"><vh>regularizeError</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.173"><vh>Read @auto nodes during saves if the node has not been read previously</vh>
<v t="ekr.20071102162910.174"><vh>What I did</vh></v>
<v t="ekr.20071102162910.175"><vh>Notes</vh></v>
<v t="ekr.20071102162910.176"><vh>at...FileNodeName</vh></v>
<v t="ekr.20071102162910.177"><vh>v.findAtFileName (new in 4.2 b3)</vh></v>
<v t="ekr.20071102162910.13"><vh>createOutline</vh>
<v t="ekr.20071102162910.14"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.178"><vh>readAll (atFile)</vh></v>
<v t="ekr.20071102162910.111"><vh>writeAll (atFile)</vh>
<v t="ekr.20071102162910.112"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="ekr.20071102162910.113"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="ekr.20071102162910.114"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.179"><vh>readOneAtAutoNode (atFile)</vh></v>
<v t="ekr.20071102162910.43"><vh>writeOneAtAutoNode &amp; helpers</vh>
<v t="ekr.20071102162910.44"><vh>shouldWriteAtAutoNode</vh></v>
<v t="ekr.20071102162910.45"><vh>isSignificantAtAutoTree &amp; test</vh>
<v t="ekr.20071102162910.46"><vh>@test test isSignificantAtAutoTree</vh></v>
</v>
</v>
<v t="ekr.20071102162910.180"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20071102162910.181"><vh>&lt;&lt; Set gnx = tnode index &gt;&gt;</vh></v>
<v t="ekr.20071102162910.182"><vh>&lt;&lt; Append attribute bits to attrs &gt;&gt;</vh></v>
<v t="ekr.20071102162910.183"><vh>&lt;&lt; Append tnodeList and unKnownAttributes to attrs&gt;&gt;</vh></v>
<v t="ekr.20071102162910.184"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.185"><vh>Added read-file-into-node and write-file-from-node commands</vh></v>
</v>
</v>
<v t="ekr.20071102162910.186"><vh>4.4.4 b3</vh>
<v t="ekr.20071102162910.187"><vh>Bugs</vh>
<v t="ekr.20071102162910.188"><vh>Fixed yet another new @auto bug</vh>
<v t="ekr.20071102162910.179"><vh>readOneAtAutoNode (atFile)</vh></v>
<v t="ekr.20071102162910.41"><vh>writeAtAutoNodes &amp; writeDirtyAtFileNodes (atFile) &amp; helpers</vh>
<v t="ekr.20071102162910.42"><vh>writeAtAutoNodesHelper</vh></v>
<v t="ekr.20071102162910.43"><vh>writeOneAtAutoNode &amp; helpers</vh>
<v t="ekr.20071102162910.44"><vh>shouldWriteAtAutoNode</vh></v>
<v t="ekr.20071102162910.45"><vh>isSignificantAtAutoTree &amp; test</vh>
<v t="ekr.20071102162910.46"><vh>@test test isSignificantAtAutoTree</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20071102162910.189"><vh>Greatly improved speed of unmark-all</vh>
<v t="ekr.20071102162910.190"><vh>unmarkAll</vh>
<v t="ekr.20071102162910.191"><vh>@test unmarkAll</vh></v>
</v>
<v t="ekr.20071102162910.192"><vh>print all nodes</vh></v>
<v t="ekr.20071102162910.193"><vh>c.clearMarked</vh></v>
<v t="ekr.20071102162910.194"><vh>setDirty</vh></v>
<v t="ekr.20071102162910.195"><vh>v.clearMarked</vh></v>
</v>
<v t="ekr.20071102162910.196"><vh>Fixed string problems in new colorizer</vh></v>
<v t="ekr.20071102162910.197"><vh>Made sure dirty bits get updated in xemacs plugin</vh>
<v t="ekr.20071102162910.198"><vh>c.setBodyString</vh></v>
</v>
<v t="ekr.20071102162910.199"><vh>Fixed backward find bug</vh>
<v t="ekr.20071102162910.200"><vh>class leoFind</vh>
<v t="ekr.20071102162910.201"><vh>leoFind.__init__ &amp; helpers</vh>
<v t="ekr.20071102162910.202"><vh>&lt;&lt; compute self.title &gt;&gt;</vh></v>
<v t="ekr.20071102162910.203"><vh>&lt;&lt; init the gui-independent ivars &gt;&gt;</vh>
<v t="ekr.20071102162910.204"><vh>&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.205"><vh>Top Level Buttons</vh>
<v t="ekr.20071102162910.206"><vh>changeAllButton</vh></v>
<v t="ekr.20071102162910.207"><vh>changeButton</vh></v>
<v t="ekr.20071102162910.208"><vh>changeThenFindButton</vh></v>
<v t="ekr.20071102162910.209"><vh>findAllButton</vh></v>
<v t="ekr.20071102162910.210"><vh>findButton</vh></v>
<v t="ekr.20071102162910.211"><vh>setup_button</vh></v>
</v>
<v t="ekr.20071102162910.212"><vh>Top Level Commands</vh>
<v t="ekr.20071102162910.213"><vh>changeCommand</vh></v>
<v t="ekr.20071102162910.214"><vh>changeThenFindCommand</vh></v>
<v t="ekr.20071102162910.215"><vh>dismiss: defined in subclass class</vh></v>
<v t="ekr.20071102162910.216"><vh>findNextCommand</vh></v>
<v t="ekr.20071102162910.217"><vh>findPreviousCommand</vh></v>
<v t="ekr.20071102162910.218"><vh>handleUserClick</vh></v>
<v t="ekr.20071102162910.219"><vh>setup_command</vh></v>
</v>
<v t="ekr.20071102162910.220"><vh>Find/change utils</vh>
<v t="ekr.20071102162910.221"><vh>batchChange (sets start of change-all group)</vh>
<v t="ekr.20071102162910.222"><vh>&lt;&lt; change headline &gt;&gt;</vh></v>
<v t="ekr.20071102162910.223"><vh>&lt;&lt; change body &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.224"><vh>change</vh></v>
<v t="ekr.20071102162910.225"><vh>changeAll</vh></v>
<v t="ekr.20071102162910.226"><vh>changeSelection (changed)</vh>
<v t="ekr.20071102162910.227"><vh>makeRegexSubs</vh></v>
</v>
<v t="ekr.20071102162910.228"><vh>changeThenFind</vh></v>
<v t="ekr.20071102162910.229"><vh>doChange...Script</vh></v>
<v t="ekr.20071102162910.230"><vh>doFind...Script</vh></v>
<v t="ekr.20071102162910.231"><vh>findAll</vh>
<v t="ekr.20071102162910.232"><vh>&lt;&lt; create the found node and begin the undo group &gt;&gt;</vh></v>
<v t="ekr.20071102162910.233"><vh>&lt;&lt; create a clone of p under the find node &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.234"><vh>findNext</vh></v>
<v t="ekr.20071102162910.235"><vh>findNextMatch</vh></v>
<v t="ekr.20071102162910.236"><vh>resetWrap</vh></v>
<v t="ekr.20071102162910.237"><vh>search &amp; helpers</vh>
<v t="ekr.20071102162910.238"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20071102162910.239"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20071102162910.240"><vh>regexHelper</vh></v>
<v t="ekr.20071102162910.241"><vh>backwardsHelper</vh></v>
<v t="ekr.20071102162910.242"><vh>plainHelper</vh></v>
<v t="ekr.20071102162910.243"><vh>matchWord</vh></v>
<v t="ekr.20071102162910.244"><vh>replaceBackSlashes</vh></v>
</v>
</v>
<v t="ekr.20071102162910.245"><vh>selectNextPosition</vh></v>
</v>
<v t="ekr.20071102162910.246"><vh>General utils</vh>
<v t="ekr.20071102162910.247"><vh>bringToFront (leoFind)</vh></v>
<v t="ekr.20071102162910.248"><vh>oops (leoFind)</vh></v>
<v t="ekr.20071102162910.249"><vh>selectAllFindText (leoFind)</vh></v>
</v>
<v t="ekr.20071102162910.250"><vh>Initing &amp; finalizing</vh>
<v t="ekr.20071102162910.251"><vh>checkArgs</vh></v>
<v t="ekr.20071102162910.252"><vh>initBatchCommands</vh></v>
<v t="ekr.20071102162910.253"><vh>initBatchText, initNextText &amp; init_s_ctrl</vh></v>
<v t="ekr.20071102162910.254"><vh>initInHeadline</vh></v>
<v t="ekr.20071102162910.255"><vh>initInteractiveCommands</vh></v>
<v t="ekr.20071102162910.256"><vh>printLine</vh></v>
<v t="ekr.20071102162910.257"><vh>restore</vh></v>
<v t="ekr.20071102162910.258"><vh>save</vh></v>
<v t="ekr.20071102162910.259"><vh>showSuccess</vh></v>
<v t="ekr.20071102162910.260"><vh>update_ivars (leoFind)</vh></v>
</v>
</v>
<v t="ekr.20071102162910.234"><vh>findNext</vh></v>
<v t="ekr.20071102162910.235"><vh>findNextMatch</vh></v>
<v t="ekr.20071102162910.245"><vh>selectNextPosition</vh></v>
<v t="ekr.20071102162910.237"><vh>search &amp; helpers</vh>
<v t="ekr.20071102162910.238"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20071102162910.239"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20071102162910.240"><vh>regexHelper</vh></v>
<v t="ekr.20071102162910.241"><vh>backwardsHelper</vh></v>
<v t="ekr.20071102162910.242"><vh>plainHelper</vh></v>
<v t="ekr.20071102162910.243"><vh>matchWord</vh></v>
<v t="ekr.20071102162910.244"><vh>replaceBackSlashes</vh></v>
</v>
</v>
<v t="ekr.20071102162910.253"><vh>initBatchText, initNextText &amp; init_s_ctrl</vh></v>
<v t="ekr.20071102162910.261"><vh>getSelectionRange (baseText)</vh></v>
<v t="ekr.20071102162910.255"><vh>initInteractiveCommands</vh></v>
<v t="ekr.20071102162910.241"><vh>backwardsHelper</vh></v>
</v>
<v t="ekr.20071102162910.262"><vh>Fixed cursor up/down problem</vh>
<v t="ekr.20071102162910.263"><vh>Example of problems</vh></v>
<v t="ekr.20071102162910.264"><vh>g.getWord &amp; getLine &amp; tests</vh>
<v t="ekr.20071102162910.265"><vh>@test g.getLine</vh></v>
<v t="ekr.20071102162910.266"><vh>@test g.getWord</vh></v>
</v>
<v t="ekr.20071102162910.267"><vh>move cursor... (leoEditCommands)</vh>
<v t="ekr.20071102162910.268"><vh> helpers</vh>
<v t="ekr.20071102162910.269"><vh>extendHelper &amp; test</vh>
<v t="ekr.20071102162910.270"><vh>@test extendHelper</vh></v>
</v>
<v t="ekr.20071102162910.271"><vh>moveUpOrDownHelper &amp; test</vh>
<v t="ekr.20071102162910.272"><vh>@test moveUpOrDownHelper</vh></v>
</v>
<v t="ekr.20071102162910.273"><vh>moveToHelper &amp; test</vh>
<v t="ekr.20071102162910.274"><vh>@test moveToHelper</vh></v>
</v>
<v t="ekr.20071102162910.275"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20071102162910.276"><vh>moveWordHelper</vh></v>
<v t="ekr.20071102162910.277"><vh>backSentenceHelper</vh></v>
<v t="ekr.20071102162910.278"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20071102162910.279"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20071102162910.280"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20071102162910.74"><vh>setMoveCol &amp; test</vh>
<v t="ekr.20071102162910.75"><vh>@test setMoveCol</vh></v>
</v>
</v>
<v t="ekr.20071102162910.281"><vh>buffers</vh></v>
<v t="ekr.20071102162910.282"><vh>characters</vh></v>
<v t="ekr.20071102162910.283"><vh>clear/set/ToggleExtendMode</vh></v>
<v t="ekr.20071102162910.284"><vh>exchangePointMark</vh></v>
<v t="ekr.20071102162910.285"><vh>extend-to-line</vh></v>
<v t="ekr.20071102162910.286"><vh>extend-to-sentence</vh></v>
<v t="ekr.20071102162910.287"><vh>extend-to-word</vh></v>
<v t="ekr.20071102162910.288"><vh>lines</vh></v>
<v t="ekr.20071102162910.289"><vh>movePastClose</vh></v>
<v t="ekr.20071102162910.290"><vh>paragraphs</vh></v>
<v t="ekr.20071102162910.291"><vh>sentences</vh></v>
<v t="ekr.20071102162910.292"><vh>words</vh></v>
</v>
</v>
<v t="ekr.20071102162910.293"><vh>Created new unit tests</vh>
<v t="ekr.20071102162910.294"><vh>fillRegion</vh></v>
<v t="ekr.20071102162910.295"><vh>indentToCommentColumn</vh></v>
<v t="ekr.20071102162910.296"><vh>setFillPrefix</vh></v>
</v>
<v t="ekr.20071102162910.297"><vh>Fixed doc bug</vh></v>
<v t="ekr.20071102162910.298"><vh>Regularize newlines in @auto compare</vh>
<v t="ekr.20071102162910.48"><vh>checkTrialWrite &amp; tests</vh>
<v t="ekr.20071102162910.49"><vh>@test checkTriailWrite</vh></v>
</v>
</v>
<v t="ekr.20071102162910.299"><vh>Fixed unicode bug in trace</vh>
<v t="ekr.20071102162910.300"><vh>trace</vh></v>
</v>
<v t="ekr.20071102162910.301"><vh>Fixed chapter typo</vh></v>
<v t="ekr.20071102162910.302"><vh>Fixed chapter crasher</vh>
<v t="ekr.20071102162910.303"><vh>cc.moveNodeToChapterHelper</vh></v>
</v>
<v t="ekr.20071102162910.304"><vh>Fixed several @auto bugs</vh>
<v t="ekr.20071102162910.305"><vh>Fixed new @auto bug</vh>
<v t="ekr.20071102162910.306"><vh>c.executeScript &amp; helpers</vh>
<v t="ekr.20071102162910.307"><vh>redirectScriptOutput</vh></v>
<v t="ekr.20071102162910.308"><vh>unredirectScriptOutput</vh></v>
<v t="ekr.20071102162910.309"><vh>writeScriptFile</vh></v>
<v t="ekr.20071102162910.310"><vh>@test pre-definition of g in scripts</vh></v>
</v>
<v t="ekr.20071102162910.311"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20071102162910.312"><vh>@test g.getScript strips crlf</vh></v>
</v>
<v t="ekr.20071102162910.313"><vh>debug &amp; helper</vh>
<v t="ekr.20071102162910.314"><vh>findDebugger</vh></v>
</v>
</v>
<v t="ekr.20071102162910.315"><vh>fixed new @auto crasher</vh></v>
<v t="ekr.20071102162910.316"><vh>Handle over-indented defs</vh>
<v t="ekr.20071102162910.137"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.317"><vh>skipCodeBlock (python) &amp; helper</vh>
<v t="ekr.20071102162910.318"><vh>pythonNewlineHelper</vh></v>
</v>
</v>
<v t="ekr.20071102162910.319"><vh>Made sure don't see any [nl] at start of line</vh>
<v t="ekr.20071102162910.317"><vh>skipCodeBlock (python) &amp; helper</vh>
<v t="ekr.20071102162910.318"><vh>pythonNewlineHelper</vh></v>
</v>
</v>
<v t="ekr.20071102162910.320"><vh>Made sure java scanner works with java interfaces</vh></v>
<v t="ekr.20071102162910.321"><vh>Fixed bugs in Java parser</vh></v>
<v t="ekr.20071102162910.322"><vh>Suppressed "invalid @+leo sentinel" when importing java</vh>
<v t="ekr.20071102162910.323"><vh>removeSentinelsCommand</vh>
<v t="ekr.20071102162910.324"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="ekr.20071102162910.325"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="ekr.20071102162910.326"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.327"><vh>Handled nested classes, interface and namespaces properly</vh>
<v t="ekr.20071102162910.328"><vh>Scanners for createOutline</vh>
<v t="ekr.20071102162910.120"><vh> class baseScannerClass</vh>
<v t="ekr.20071102162910.121"><vh>baseScannerClass.__init__</vh></v>
<v t="ekr.20071102162910.122"><vh>Checking</vh>
<v t="ekr.20071102162910.123"><vh>check</vh></v>
<v t="ekr.20071102162910.48"><vh>checkTrialWrite &amp; tests</vh>
<v t="ekr.20071102162910.49"><vh>@test checkTriailWrite</vh></v>
</v>
<v t="ekr.20071102162910.124"><vh>compareHelper &amp; tests</vh>
<v t="ekr.20071102162910.125"><vh>@test compareHelper</vh></v>
<v t="ekr.20071102162910.126"><vh>@test compareHelper-warning</vh></v>
</v>
<v t="ekr.20071102162910.81"><vh>reportMismatch &amp; test</vh>
<v t="ekr.20071102162910.82"><vh>minitest of pr</vh></v>
</v>
</v>
<v t="ekr.20071102162910.127"><vh>Code generation</vh>
<v t="ekr.20071102162910.128"><vh>addRef</vh></v>
<v t="ekr.20071102162910.129"><vh>createDeclsNode</vh></v>
<v t="ekr.20071102162910.130"><vh>createFunctionNode</vh></v>
<v t="ekr.20071102162910.131"><vh>createHeadline</vh></v>
<v t="ekr.20071102162910.132"><vh>getLeadingIndent</vh></v>
<v t="ekr.20071102162910.133"><vh>indentBody</vh></v>
<v t="ekr.20071102162910.134"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20071102162910.135"><vh>massageComment</vh></v>
<v t="ekr.20071102162910.136"><vh>putClass &amp; helpers</vh>
<v t="ekr.20071102162910.137"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071102162910.138"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071102162910.139"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20071102162910.141"><vh>putFunction</vh></v>
<v t="ekr.20071102162910.142"><vh>putRootText</vh></v>
<v t="ekr.20071102162910.143"><vh>undentBody &amp; undentBy</vh></v>
<v t="ekr.20071102162910.144"><vh>underindentedComment &amp; underindentedLine</vh></v>
</v>
<v t="ekr.20071102162910.145"><vh>error &amp; oops</vh></v>
<v t="ekr.20071102162910.146"><vh>Parsing</vh>
<v t="ekr.20071102162910.147"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.148"><vh>getIndent</vh></v>
<v t="ekr.20071102162910.149"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071102162910.150"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20071102162910.151"><vh>skipArgs</vh></v>
<v t="ekr.20071102162910.152"><vh>skipBlock</vh></v>
<v t="ekr.20071102162910.153"><vh>skipCodeBlock</vh></v>
<v t="ekr.20071102162910.154"><vh>skipComment &amp; helper</vh>
<v t="ekr.20071102162910.155"><vh>skipBlockComment</vh></v>
</v>
<v t="ekr.20071102162910.156"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20071102162910.157"><vh>adjustClassOrFunctionStart</vh></v>
</v>
<v t="ekr.20071102162910.158"><vh>skipId</vh></v>
<v t="ekr.20071102162910.159"><vh>skipNewline</vh></v>
<v t="ekr.20071102162910.160"><vh>skipParens</vh></v>
<v t="ekr.20071102162910.161"><vh>skipString</vh></v>
<v t="ekr.20071102162910.162"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.164"><vh>skipSigStart</vh></v>
<v t="ekr.20071102162910.165"><vh>skipSigTail</vh></v>
<v t="ekr.20071102162910.166"><vh>skipSigId</vh></v>
</v>
<v t="ekr.20071102162910.167"><vh>startsComment</vh></v>
<v t="ekr.20071102162910.168"><vh>startsId</vh></v>
<v t="ekr.20071102162910.169"><vh>startsString</vh></v>
</v>
<v t="ekr.20071102162910.101"><vh>run (baseScannerClass)</vh>
<v t="ekr.20071102162910.102"><vh>regularizeWhitespace</vh>
<v t="ekr.20071102162910.103"><vh>regularizeError</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.329"><vh>C scanner</vh>
<v t="ekr.20071102162910.330"><vh>scanCText</vh></v>
<v t="ekr.20071102162910.331"><vh>class cScanner (baseScannerClass)</vh></v>
</v>
<v t="ekr.20071102162910.332"><vh>C# scanner</vh>
<v t="ekr.20071102162910.333"><vh>scanCSharpText</vh></v>
<v t="ekr.20071102162910.334"><vh>class cSharpScanner (baseScannerClass)</vh></v>
</v>
<v t="ekr.20071102162910.335"><vh>Elisp scanner</vh>
<v t="ekr.20071102162910.336"><vh>scanElispText</vh></v>
<v t="ekr.20071102162910.337"><vh>class elispScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.338"><vh> __init__</vh></v>
<v t="ekr.20071102162910.339"><vh>Overrides</vh>
<v t="ekr.20071102162910.340"><vh>startsClass/Function &amp; skipSignature</vh></v>
<v t="ekr.20071102162910.341"><vh>startsString</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.342"><vh>Java scanner</vh>
<v t="ekr.20071102162910.343"><vh>scanJavaText</vh></v>
<v t="ekr.20071102162910.344"><vh>class javaScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.345"><vh>javaScanner.__init__</vh></v>
<v t="ekr.20071102162910.346"><vh>javaScanner.skipSigId</vh></v>
</v>
</v>
<v t="ekr.20071102162910.347"><vh>JavaScript scanner (not ready yet)</vh>
<v t="ekr.20071102162910.348"><vh>scanJavaScriptText</vh></v>
<v t="ekr.20071102162910.349"><vh>class javaScriptScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.350"><vh>javaScriptScanner.__init__</vh></v>
<v t="ekr.20071102162910.351"><vh>startsString</vh></v>
<v t="ekr.20071102162910.352"><vh>skipString</vh></v>
</v>
</v>
<v t="ekr.20071102162910.353"><vh>Pascal scanner</vh>
<v t="ekr.20071102162910.354"><vh>scanPascalText</vh></v>
<v t="ekr.20071102162910.355"><vh>class pascalScanner (baseScannerClass)</vh></v>
</v>
<v t="ekr.20071102162910.356"><vh>PHP scanner</vh>
<v t="ekr.20071102162910.357"><vh>scanPHPText</vh></v>
<v t="ekr.20071102162910.358"><vh>class phpScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.359"><vh> __init__</vh></v>
<v t="ekr.20071102162910.360"><vh>isPurePHP</vh></v>
<v t="ekr.20071102162910.361"><vh>Overrides</vh>
<v t="ekr.20071102162910.362"><vh>startsString skipString</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.363"><vh>Python scanner</vh>
<v t="ekr.20071102162910.364"><vh>scanPythonText</vh></v>
<v t="ekr.20071102162910.365"><vh>class pythonScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.366"><vh> __init__</vh></v>
<v t="ekr.20071102162910.367"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.368"><vh>skipString</vh></v>
<v t="ekr.20071102162910.317"><vh>skipCodeBlock (python) &amp; helper</vh>
<v t="ekr.20071102162910.318"><vh>pythonNewlineHelper</vh></v>
</v>
<v t="ekr.20071102162910.369"><vh>skipSigTail</vh></v>
</v>
</v>
<v t="ekr.20071102162910.370"><vh>Default scanner</vh></v>
</v>
<v t="ekr.20071102162910.120"><vh> class baseScannerClass</vh>
<v t="ekr.20071102162910.121"><vh>baseScannerClass.__init__</vh></v>
<v t="ekr.20071102162910.122"><vh>Checking</vh>
<v t="ekr.20071102162910.123"><vh>check</vh></v>
<v t="ekr.20071102162910.48"><vh>checkTrialWrite &amp; tests</vh>
<v t="ekr.20071102162910.49"><vh>@test checkTriailWrite</vh></v>
</v>
<v t="ekr.20071102162910.124"><vh>compareHelper &amp; tests</vh>
<v t="ekr.20071102162910.125"><vh>@test compareHelper</vh></v>
<v t="ekr.20071102162910.126"><vh>@test compareHelper-warning</vh></v>
</v>
<v t="ekr.20071102162910.81"><vh>reportMismatch &amp; test</vh>
<v t="ekr.20071102162910.82"><vh>minitest of pr</vh></v>
</v>
</v>
<v t="ekr.20071102162910.127"><vh>Code generation</vh>
<v t="ekr.20071102162910.128"><vh>addRef</vh></v>
<v t="ekr.20071102162910.129"><vh>createDeclsNode</vh></v>
<v t="ekr.20071102162910.130"><vh>createFunctionNode</vh></v>
<v t="ekr.20071102162910.131"><vh>createHeadline</vh></v>
<v t="ekr.20071102162910.132"><vh>getLeadingIndent</vh></v>
<v t="ekr.20071102162910.133"><vh>indentBody</vh></v>
<v t="ekr.20071102162910.134"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20071102162910.135"><vh>massageComment</vh></v>
<v t="ekr.20071102162910.136"><vh>putClass &amp; helpers</vh>
<v t="ekr.20071102162910.137"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071102162910.138"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071102162910.139"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20071102162910.141"><vh>putFunction</vh></v>
<v t="ekr.20071102162910.142"><vh>putRootText</vh></v>
<v t="ekr.20071102162910.143"><vh>undentBody &amp; undentBy</vh></v>
<v t="ekr.20071102162910.144"><vh>underindentedComment &amp; underindentedLine</vh></v>
</v>
<v t="ekr.20071102162910.145"><vh>error &amp; oops</vh></v>
<v t="ekr.20071102162910.146"><vh>Parsing</vh>
<v t="ekr.20071102162910.147"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.148"><vh>getIndent</vh></v>
<v t="ekr.20071102162910.149"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071102162910.150"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20071102162910.151"><vh>skipArgs</vh></v>
<v t="ekr.20071102162910.152"><vh>skipBlock</vh></v>
<v t="ekr.20071102162910.153"><vh>skipCodeBlock</vh></v>
<v t="ekr.20071102162910.154"><vh>skipComment &amp; helper</vh>
<v t="ekr.20071102162910.155"><vh>skipBlockComment</vh></v>
</v>
<v t="ekr.20071102162910.156"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20071102162910.157"><vh>adjustClassOrFunctionStart</vh></v>
</v>
<v t="ekr.20071102162910.158"><vh>skipId</vh></v>
<v t="ekr.20071102162910.159"><vh>skipNewline</vh></v>
<v t="ekr.20071102162910.160"><vh>skipParens</vh></v>
<v t="ekr.20071102162910.161"><vh>skipString</vh></v>
<v t="ekr.20071102162910.162"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.164"><vh>skipSigStart</vh></v>
<v t="ekr.20071102162910.165"><vh>skipSigTail</vh></v>
<v t="ekr.20071102162910.166"><vh>skipSigId</vh></v>
</v>
<v t="ekr.20071102162910.167"><vh>startsComment</vh></v>
<v t="ekr.20071102162910.168"><vh>startsId</vh></v>
<v t="ekr.20071102162910.169"><vh>startsString</vh></v>
</v>
<v t="ekr.20071102162910.101"><vh>run (baseScannerClass)</vh>
<v t="ekr.20071102162910.102"><vh>regularizeWhitespace</vh>
<v t="ekr.20071102162910.103"><vh>regularizeError</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.153"><vh>skipCodeBlock</vh></v>
<v t="ekr.20071102162910.143"><vh>undentBody &amp; undentBy</vh></v>
<v t="ekr.20071102162910.149"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071102162910.150"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20071102162910.136"><vh>putClass &amp; helpers</vh>
<v t="ekr.20071102162910.137"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071102162910.138"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071102162910.139"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20071102162910.156"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20071102162910.157"><vh>adjustClassOrFunctionStart</vh></v>
</v>
<v t="ekr.20071102162910.151"><vh>skipArgs</vh></v>
<v t="ekr.20071102162910.344"><vh>class javaScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.345"><vh>javaScanner.__init__</vh></v>
<v t="ekr.20071102162910.346"><vh>javaScanner.skipSigId</vh></v>
</v>
<v t="ekr.20071102162910.162"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.164"><vh>skipSigStart</vh></v>
<v t="ekr.20071102162910.165"><vh>skipSigTail</vh></v>
<v t="ekr.20071102162910.166"><vh>skipSigId</vh></v>
</v>
</v>
<v t="ekr.20071102162910.371"><vh>Fixed problem with @auto files w/o extension</vh>
<v t="ekr.20071102162910.111"><vh>writeAll (atFile)</vh>
<v t="ekr.20071102162910.112"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="ekr.20071102162910.113"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="ekr.20071102162910.114"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.41"><vh>writeAtAutoNodes &amp; writeDirtyAtFileNodes (atFile) &amp; helpers</vh>
<v t="ekr.20071102162910.42"><vh>writeAtAutoNodesHelper</vh></v>
<v t="ekr.20071102162910.43"><vh>writeOneAtAutoNode &amp; helpers</vh>
<v t="ekr.20071102162910.44"><vh>shouldWriteAtAutoNode</vh></v>
<v t="ekr.20071102162910.45"><vh>isSignificantAtAutoTree &amp; test</vh>
<v t="ekr.20071102162910.46"><vh>@test test isSignificantAtAutoTree</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20071102162910.372"><vh>Better c# tests</vh>
<v t="ekr.20071102162910.373"><vh>c# syntax ref card</vh></v>
<v t="ekr.20071102162910.328"><vh>Scanners for createOutline</vh>
<v t="ekr.20071102162910.120"><vh> class baseScannerClass</vh>
<v t="ekr.20071102162910.121"><vh>baseScannerClass.__init__</vh></v>
<v t="ekr.20071102162910.122"><vh>Checking</vh>
<v t="ekr.20071102162910.123"><vh>check</vh></v>
<v t="ekr.20071102162910.48"><vh>checkTrialWrite &amp; tests</vh>
<v t="ekr.20071102162910.49"><vh>@test checkTriailWrite</vh></v>
</v>
<v t="ekr.20071102162910.124"><vh>compareHelper &amp; tests</vh>
<v t="ekr.20071102162910.125"><vh>@test compareHelper</vh></v>
<v t="ekr.20071102162910.126"><vh>@test compareHelper-warning</vh></v>
</v>
<v t="ekr.20071102162910.81"><vh>reportMismatch &amp; test</vh>
<v t="ekr.20071102162910.82"><vh>minitest of pr</vh></v>
</v>
</v>
<v t="ekr.20071102162910.127"><vh>Code generation</vh>
<v t="ekr.20071102162910.128"><vh>addRef</vh></v>
<v t="ekr.20071102162910.129"><vh>createDeclsNode</vh></v>
<v t="ekr.20071102162910.130"><vh>createFunctionNode</vh></v>
<v t="ekr.20071102162910.131"><vh>createHeadline</vh></v>
<v t="ekr.20071102162910.132"><vh>getLeadingIndent</vh></v>
<v t="ekr.20071102162910.133"><vh>indentBody</vh></v>
<v t="ekr.20071102162910.134"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20071102162910.135"><vh>massageComment</vh></v>
<v t="ekr.20071102162910.136"><vh>putClass &amp; helpers</vh>
<v t="ekr.20071102162910.137"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071102162910.138"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071102162910.139"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20071102162910.141"><vh>putFunction</vh></v>
<v t="ekr.20071102162910.142"><vh>putRootText</vh></v>
<v t="ekr.20071102162910.143"><vh>undentBody &amp; undentBy</vh></v>
<v t="ekr.20071102162910.144"><vh>underindentedComment &amp; underindentedLine</vh></v>
</v>
<v t="ekr.20071102162910.145"><vh>error &amp; oops</vh></v>
<v t="ekr.20071102162910.146"><vh>Parsing</vh>
<v t="ekr.20071102162910.147"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.148"><vh>getIndent</vh></v>
<v t="ekr.20071102162910.149"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071102162910.150"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20071102162910.151"><vh>skipArgs</vh></v>
<v t="ekr.20071102162910.152"><vh>skipBlock</vh></v>
<v t="ekr.20071102162910.153"><vh>skipCodeBlock</vh></v>
<v t="ekr.20071102162910.154"><vh>skipComment &amp; helper</vh>
<v t="ekr.20071102162910.155"><vh>skipBlockComment</vh></v>
</v>
<v t="ekr.20071102162910.156"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20071102162910.157"><vh>adjustClassOrFunctionStart</vh></v>
</v>
<v t="ekr.20071102162910.158"><vh>skipId</vh></v>
<v t="ekr.20071102162910.159"><vh>skipNewline</vh></v>
<v t="ekr.20071102162910.160"><vh>skipParens</vh></v>
<v t="ekr.20071102162910.161"><vh>skipString</vh></v>
<v t="ekr.20071102162910.162"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.164"><vh>skipSigStart</vh></v>
<v t="ekr.20071102162910.165"><vh>skipSigTail</vh></v>
<v t="ekr.20071102162910.166"><vh>skipSigId</vh></v>
</v>
<v t="ekr.20071102162910.167"><vh>startsComment</vh></v>
<v t="ekr.20071102162910.168"><vh>startsId</vh></v>
<v t="ekr.20071102162910.169"><vh>startsString</vh></v>
</v>
<v t="ekr.20071102162910.101"><vh>run (baseScannerClass)</vh>
<v t="ekr.20071102162910.102"><vh>regularizeWhitespace</vh>
<v t="ekr.20071102162910.103"><vh>regularizeError</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.329"><vh>C scanner</vh>
<v t="ekr.20071102162910.330"><vh>scanCText</vh></v>
<v t="ekr.20071102162910.331"><vh>class cScanner (baseScannerClass)</vh></v>
</v>
<v t="ekr.20071102162910.332"><vh>C# scanner</vh>
<v t="ekr.20071102162910.333"><vh>scanCSharpText</vh></v>
<v t="ekr.20071102162910.334"><vh>class cSharpScanner (baseScannerClass)</vh></v>
</v>
<v t="ekr.20071102162910.335"><vh>Elisp scanner</vh>
<v t="ekr.20071102162910.336"><vh>scanElispText</vh></v>
<v t="ekr.20071102162910.337"><vh>class elispScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.338"><vh> __init__</vh></v>
<v t="ekr.20071102162910.339"><vh>Overrides</vh>
<v t="ekr.20071102162910.340"><vh>startsClass/Function &amp; skipSignature</vh></v>
<v t="ekr.20071102162910.341"><vh>startsString</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.342"><vh>Java scanner</vh>
<v t="ekr.20071102162910.343"><vh>scanJavaText</vh></v>
<v t="ekr.20071102162910.344"><vh>class javaScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.345"><vh>javaScanner.__init__</vh></v>
<v t="ekr.20071102162910.346"><vh>javaScanner.skipSigId</vh></v>
</v>
</v>
<v t="ekr.20071102162910.347"><vh>JavaScript scanner (not ready yet)</vh>
<v t="ekr.20071102162910.348"><vh>scanJavaScriptText</vh></v>
<v t="ekr.20071102162910.349"><vh>class javaScriptScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.350"><vh>javaScriptScanner.__init__</vh></v>
<v t="ekr.20071102162910.351"><vh>startsString</vh></v>
<v t="ekr.20071102162910.352"><vh>skipString</vh></v>
</v>
</v>
<v t="ekr.20071102162910.353"><vh>Pascal scanner</vh>
<v t="ekr.20071102162910.354"><vh>scanPascalText</vh></v>
<v t="ekr.20071102162910.355"><vh>class pascalScanner (baseScannerClass)</vh></v>
</v>
<v t="ekr.20071102162910.356"><vh>PHP scanner</vh>
<v t="ekr.20071102162910.357"><vh>scanPHPText</vh></v>
<v t="ekr.20071102162910.358"><vh>class phpScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.359"><vh> __init__</vh></v>
<v t="ekr.20071102162910.360"><vh>isPurePHP</vh></v>
<v t="ekr.20071102162910.361"><vh>Overrides</vh>
<v t="ekr.20071102162910.362"><vh>startsString skipString</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.363"><vh>Python scanner</vh>
<v t="ekr.20071102162910.364"><vh>scanPythonText</vh></v>
<v t="ekr.20071102162910.365"><vh>class pythonScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.366"><vh> __init__</vh></v>
<v t="ekr.20071102162910.367"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.368"><vh>skipString</vh></v>
<v t="ekr.20071102162910.317"><vh>skipCodeBlock (python) &amp; helper</vh>
<v t="ekr.20071102162910.318"><vh>pythonNewlineHelper</vh></v>
</v>
<v t="ekr.20071102162910.369"><vh>skipSigTail</vh></v>
</v>
</v>
<v t="ekr.20071102162910.370"><vh>Default scanner</vh></v>
</v>
<v t="ekr.20071102162910.146"><vh>Parsing</vh>
<v t="ekr.20071102162910.147"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.148"><vh>getIndent</vh></v>
<v t="ekr.20071102162910.149"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071102162910.150"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20071102162910.151"><vh>skipArgs</vh></v>
<v t="ekr.20071102162910.152"><vh>skipBlock</vh></v>
<v t="ekr.20071102162910.153"><vh>skipCodeBlock</vh></v>
<v t="ekr.20071102162910.154"><vh>skipComment &amp; helper</vh>
<v t="ekr.20071102162910.155"><vh>skipBlockComment</vh></v>
</v>
<v t="ekr.20071102162910.156"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20071102162910.157"><vh>adjustClassOrFunctionStart</vh></v>
</v>
<v t="ekr.20071102162910.158"><vh>skipId</vh></v>
<v t="ekr.20071102162910.159"><vh>skipNewline</vh></v>
<v t="ekr.20071102162910.160"><vh>skipParens</vh></v>
<v t="ekr.20071102162910.161"><vh>skipString</vh></v>
<v t="ekr.20071102162910.162"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.164"><vh>skipSigStart</vh></v>
<v t="ekr.20071102162910.165"><vh>skipSigTail</vh></v>
<v t="ekr.20071102162910.166"><vh>skipSigId</vh></v>
</v>
<v t="ekr.20071102162910.167"><vh>startsComment</vh></v>
<v t="ekr.20071102162910.168"><vh>startsId</vh></v>
<v t="ekr.20071102162910.169"><vh>startsString</vh></v>
</v>
<v t="ekr.20071102162910.127"><vh>Code generation</vh>
<v t="ekr.20071102162910.128"><vh>addRef</vh></v>
<v t="ekr.20071102162910.129"><vh>createDeclsNode</vh></v>
<v t="ekr.20071102162910.130"><vh>createFunctionNode</vh></v>
<v t="ekr.20071102162910.131"><vh>createHeadline</vh></v>
<v t="ekr.20071102162910.132"><vh>getLeadingIndent</vh></v>
<v t="ekr.20071102162910.133"><vh>indentBody</vh></v>
<v t="ekr.20071102162910.134"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20071102162910.135"><vh>massageComment</vh></v>
<v t="ekr.20071102162910.136"><vh>putClass &amp; helpers</vh>
<v t="ekr.20071102162910.137"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071102162910.138"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071102162910.139"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20071102162910.141"><vh>putFunction</vh></v>
<v t="ekr.20071102162910.142"><vh>putRootText</vh></v>
<v t="ekr.20071102162910.143"><vh>undentBody &amp; undentBy</vh></v>
<v t="ekr.20071102162910.144"><vh>underindentedComment &amp; underindentedLine</vh></v>
</v>
</v>
<v t="ekr.20071102162910.374"><vh>Don't include leo directives in count of significant characters</vh>
<v t="ekr.20071102162910.43"><vh>writeOneAtAutoNode &amp; helpers</vh>
<v t="ekr.20071102162910.44"><vh>shouldWriteAtAutoNode</vh></v>
<v t="ekr.20071102162910.45"><vh>isSignificantAtAutoTree &amp; test</vh>
<v t="ekr.20071102162910.46"><vh>@test test isSignificantAtAutoTree</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.375"><vh>Made sure @auto import failure does result in writing the file</vh>
<v t="ekr.20071102162910.179"><vh>readOneAtAutoNode (atFile)</vh></v>
</v>
</v>
<v t="ekr.20071102162910.376"><vh>Installed patch to fix Fedora Tk.Text bug</vh>
<v t="ekr.20071102162910.377"><vh>setAllText</vh></v>
</v>
<v t="ekr.20071102162910.378"><vh>Fixed new rst3 problem</vh></v>
<v t="ekr.20071102162910.379"><vh>Fixed bugs when running unit tests externally</vh>
<v t="ekr.20071102162910.380"><vh>run</vh>
<v t="ekr.20071102162910.381"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20071102162910.382"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.86"><vh>runTestsExternally &amp; helper class</vh>
<v t="ekr.20071102162910.87"><vh>class runTestHelperClass</vh>
<v t="ekr.20071102162910.88"><vh> ctor: runTestHelperClass</vh></v>
<v t="ekr.20071102162910.89"><vh>createFileFromOutline</vh></v>
<v t="ekr.20071102162910.90"><vh>createOutline &amp; helpers</vh>
<v t="ekr.20071102162910.91"><vh>&lt;&lt; set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 &gt;&gt;</vh></v>
<v t="ekr.20071102162910.92"><vh>addMarkTree</vh></v>
<v t="ekr.20071102162910.93"><vh>addNode</vh></v>
<v t="ekr.20071102162910.94"><vh>isUnitTestNode</vh></v>
</v>
<v t="ekr.20071102162910.95"><vh>runTests</vh></v>
<v t="ekr.20071102162910.51"><vh>runLeoDynamicTest</vh></v>
<v t="ekr.20071102162910.96"><vh>searchOutline</vh></v>
</v>
</v>
<v t="ekr.20071102162910.311"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20071102162910.312"><vh>@test g.getScript strips crlf</vh></v>
</v>
<v t="ekr.20071102162910.383"><vh>getBatchScript</vh></v>
<v t="ekr.20071102162910.384"><vh>doTests...</vh>
<v t="ekr.20071102162910.385"><vh>class generalTestCase</vh>
<v t="ekr.20071102162910.386"><vh>__init__</vh></v>
<v t="ekr.20071102162910.387"><vh> fail</vh></v>
<v t="ekr.20071102162910.388"><vh>setUp</vh></v>
<v t="ekr.20071102162910.389"><vh>tearDown</vh></v>
<v t="ekr.20071102162910.390"><vh>runTest</vh></v>
<v t="ekr.20071102162910.391"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20071102162910.392"><vh>makeTestSuite</vh></v>
<v t="ekr.20071102162910.393"><vh>makeTestCase</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.394"><vh>Features</vh>
<v t="ekr.20071102162910.395"><vh>Added button-font params</vh>
<v t="ekr.20071102162910.396"><vh>add</vh>
<v t="ekr.20071102162910.397"><vh>&lt;&lt; create a picture &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.398"><vh>Added resolve-cvs-conflicts and write-resolved-conflicts commands</vh>
<v t="ekr.20071102162910.399"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20071102162910.231"><vh>findAll</vh>
<v t="ekr.20071102162910.232"><vh>&lt;&lt; create the found node and begin the undo group &gt;&gt;</vh></v>
<v t="ekr.20071102162910.233"><vh>&lt;&lt; create a clone of p under the find node &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.400"><vh>Part 1: derived files: read-file-into-node &amp; write-file-from-node</vh>
<v t="ekr.20071102162910.401"><vh>readFileIntoFile</vh></v>
<v t="ekr.20071102162910.402"><vh>writeFileFromNode</vh></v>
</v>
<v t="ekr.20071102162910.403"><vh>Part 2: check-derived-file and check-leo-file commands</vh>
<v t="ekr.20071102162910.404"><vh>checkDerivedFile (atFile)</vh></v>
<v t="ekr.20071102162910.405"><vh>checkLeoFile (fileCommands)</vh></v>
</v>
<v t="ekr.20071102162910.406"><vh>Part 3: .leo files: compare-leo-files</vh>
<v t="ekr.20071102162910.407"><vh>compareLeoFiles</vh>
<v t="ekr.20071102162910.408"><vh>computeChangeDicts</vh></v>
<v t="ekr.20071102162910.409"><vh>createAllCompareClones &amp; helper</vh>
<v t="ekr.20071102162910.410"><vh>createCompareClones</vh></v>
</v>
<v t="ekr.20071102162910.411"><vh>createHiddenCommander</vh></v>
<v t="ekr.20071102162910.412"><vh>createFileDict</vh></v>
<v t="ekr.20071102162910.413"><vh>dumpCompareNodes</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.414"><vh>Added @buttons trees in @settings trees</vh>
<v t="ekr.20071102162910.415"><vh>configSettings.__init__</vh>
<v t="ekr.20071102162910.416"><vh>initIvar</vh></v>
<v t="ekr.20071102162910.417"><vh>initEncoding</vh></v>
</v>
<v t="ekr.20071102162910.418"><vh>visitNode (settingsTreeParser)</vh></v>
<v t="ekr.20071102162910.419"><vh>Getters (c.configSettings)</vh></v>
<v t="ekr.20071102162910.420"><vh>doButtons</vh></v>
<v t="ekr.20071102162910.421"><vh>&lt;&lt; class parserBaseClass &gt;&gt;</vh>
<v t="ekr.20071102162910.422"><vh>&lt;&lt; parserBaseClass data &gt;&gt;</vh></v>
<v t="ekr.20071102162910.423"><vh> ctor (parserBaseClass)</vh></v>
<v t="ekr.20071102162910.424"><vh>createModeCommand</vh></v>
<v t="ekr.20071102162910.425"><vh>error</vh></v>
<v t="ekr.20071102162910.426"><vh>kind handlers (parserBaseClass)</vh>
<v t="ekr.20071102162910.427"><vh>doAbbrev</vh></v>
<v t="ekr.20071102162910.428"><vh>doBool</vh></v>
<v t="ekr.20071102162910.420"><vh>doButtons</vh></v>
<v t="ekr.20071102162910.429"><vh>doColor</vh></v>
<v t="ekr.20071102162910.430"><vh>doDirectory &amp; doPath</vh></v>
<v t="ekr.20071102162910.431"><vh>doEnabledPlugins</vh></v>
<v t="ekr.20071102162910.432"><vh>doFloat</vh></v>
<v t="ekr.20071102162910.433"><vh>doFont</vh></v>
<v t="ekr.20071102162910.434"><vh>doIf</vh></v>
<v t="ekr.20071102162910.435"><vh>doIfGui</vh></v>
<v t="ekr.20071102162910.436"><vh>doIfPlatform</vh></v>
<v t="ekr.20071102162910.437"><vh>doIgnore</vh></v>
<v t="ekr.20071102162910.438"><vh>doInt</vh></v>
<v t="ekr.20071102162910.439"><vh>doInts</vh></v>
<v t="ekr.20071102162910.440"><vh>doMenus &amp; helper</vh>
<v t="ekr.20071102162910.441"><vh>doItems</vh></v>
<v t="ekr.20071102162910.442"><vh>dumpMenuList</vh></v>
</v>
<v t="ekr.20071102162910.443"><vh>doMode (ParserBaseClass)</vh>
<v t="ekr.20071102162910.444"><vh>&lt;&lt; Compute modeName &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.445"><vh>doOpenWith (ParserBaseClass)</vh></v>
<v t="ekr.20071102162910.446"><vh>doPage</vh></v>
<v t="ekr.20071102162910.447"><vh>doRatio</vh></v>
<v t="ekr.20071102162910.448"><vh>doShortcuts (ParserBaseClass)</vh></v>
<v t="ekr.20071102162910.449"><vh>doString</vh></v>
<v t="ekr.20071102162910.450"><vh>doStrings</vh></v>
</v>
<v t="ekr.20071102162910.451"><vh>munge</vh></v>
<v t="ekr.20071102162910.452"><vh>oops</vh></v>
<v t="ekr.20071102162910.453"><vh>parsers</vh>
<v t="ekr.20071102162910.454"><vh>fontSettingNameToFontKind</vh></v>
<v t="ekr.20071102162910.455"><vh>parseFont &amp; helper</vh>
<v t="ekr.20071102162910.456"><vh>parseFontLine</vh></v>
</v>
<v t="ekr.20071102162910.457"><vh>parseHeadline</vh></v>
<v t="ekr.20071102162910.458"><vh>parseOpenWith &amp; helper</vh>
<v t="ekr.20071102162910.459"><vh>parseOpenWithLine</vh></v>
</v>
<v t="ekr.20071102162910.460"><vh>parseShortcutLine (g.app.config)</vh></v>
<v t="ekr.20071102162910.461"><vh>parseAbbrevLine (g.app.config)</vh></v>
</v>
<v t="ekr.20071102162910.462"><vh>set (parseBaseClass)</vh></v>
<v t="ekr.20071102162910.463"><vh>setShortcut (ParserBaseClass)</vh></v>
<v t="ekr.20071102162910.464"><vh>traverse (parserBaseClass)</vh></v>
<v t="ekr.20071102162910.465"><vh>valueError</vh></v>
<v t="ekr.20071102162910.466"><vh>visitNode (must be overwritten in subclasses)</vh></v>
</v>
</v>
<v t="ekr.20071102162910.467"><vh>Added @menus trees in @settings trees</vh>
<v t="ekr.20071102162910.468"><vh> leoMenu.__init__</vh></v>
<v t="ekr.20071102162910.469"><vh>createMenuEntries</vh>
<v t="ekr.20071102162910.470"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20071102162910.471"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20071102162910.472"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.473"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.440"><vh>doMenus &amp; helper</vh>
<v t="ekr.20071102162910.441"><vh>doItems</vh></v>
<v t="ekr.20071102162910.442"><vh>dumpMenuList</vh></v>
</v>
<v t="ekr.20071102162910.474"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20071102162910.475"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20071102162910.476"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20071102162910.477"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20071102162910.478"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20071102162910.479"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20071102162910.480"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20071102162910.481"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20071102162910.482"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20071102162910.483"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20071102162910.399"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20071102162910.484"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20071102162910.485"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20071102162910.486"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20071102162910.487"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20071102162910.488"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20071102162910.489"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20071102162910.490"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20071102162910.491"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20071102162910.492"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20071102162910.493"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20071102162910.494"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20071102162910.495"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20071102162910.496"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20071102162910.497"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20071102162910.498"><vh>defineCmdsMenuBodyEditorsTable</vh></v>
<v t="ekr.20071102162910.499"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20071102162910.500"><vh>defineCmdsMenuChaptersTable</vh></v>
<v t="ekr.20071102162910.501"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20071102162910.502"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20071102162910.503"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20071102162910.504"><vh>defineCmdsMenuMinibufferTable</vh></v>
<v t="ekr.20071102162910.505"><vh>defineCmdsMenuPickersTable</vh></v>
<v t="ekr.20071102162910.506"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20071102162910.507"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20071102162910.508"><vh>defineCmdsMenuRunTable</vh></v>
<v t="ekr.20071102162910.509"><vh>defineCmdsMenuScrollTable</vh></v>
<v t="ekr.20071102162910.510"><vh>defineCmdsMenuSpellCheckTable</vh></v>
<v t="ekr.20071102162910.511"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20071102162910.512"><vh>defineCmdsMenuToggleTable</vh></v>
</v>
<v t="ekr.20071102162910.513"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20071102162910.514"><vh>defineHelpMenuTables</vh></v>
</v>
<v t="ekr.20071102162910.515"><vh>createMenusFromTables &amp; helpers</vh>
<v t="ekr.20071102162910.516"><vh>createFileMenuFromTable</vh>
<v t="ekr.20071102162910.517"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20071102162910.518"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20071102162910.519"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20071102162910.520"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20071102162910.521"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20071102162910.522"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.523"><vh>createEditMenuFromTable</vh>
<v t="ekr.20071102162910.524"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20071102162910.525"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20071102162910.526"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.527"><vh>createOutlineMenuFromTable</vh>
<v t="ekr.20071102162910.528"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20071102162910.529"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20071102162910.530"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20071102162910.531"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20071102162910.532"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.533"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20071102162910.534"><vh>createWindowMenuFromTable</vh></v>
<v t="ekr.20071102162910.535"><vh>createHelpMenuFromTable</vh></v>
<v t="ekr.20071102162910.536"><vh>createMenusFromConfigList &amp; helpers</vh>
<v t="ekr.20071102162910.537" a="M"><vh>createMenuFromConfigList</vh></v>
<v t="ekr.20071102162910.538"><vh>handleSpecialMenus</vh></v>
</v>
</v>
<v t="ekr.20071102162910.536"><vh>createMenusFromConfigList &amp; helpers</vh>
<v t="ekr.20071102162910.537" a="M"><vh>createMenuFromConfigList</vh></v>
<v t="ekr.20071102162910.538"><vh>handleSpecialMenus</vh></v>
</v>
<v t="ekr.20071102162910.539"><vh>createRecentFilesMenuItems (leoMenu)</vh></v>
</v>
<v t="ekr.20071102162910.540"><vh>Added convenience methods to a canvas log</vh>
<v t="ekr.20071102162910.541"><vh>tkLog.createCanvasWidget</vh></v>
<v t="ekr.20071102162910.542"><vh>createCanvas</vh></v>
<v t="ekr.20071102162910.543"><vh>tkLog.makeTabMenu</vh></v>
<v t="ekr.20071102162910.544"><vh>newTabFromMenu &amp; newCanvasTabFromMenu</vh></v>
<v t="ekr.20071102162910.545"><vh>setTabBindings</vh></v>
<v t="ekr.20071102162910.546"><vh>setCanvasTabBindings</vh></v>
</v>
<v t="ekr.20071102162910.547"><vh>Installed graphed.py plugin</vh></v>
<v t="ekr.20071102162910.548"><vh>Added insert-child command</vh>
<v t="ekr.20071102162910.549"><vh>c.insertChild</vh></v>
<v t="ekr.20071102162910.550"><vh>c.insertHeadline</vh></v>
</v>
<v t="ekr.20071102162910.551"><vh>Improved yank and yank-pop commands</vh>
<v t="ekr.20071102162910.552"><vh>killBufferCommandsClass</vh>
<v t="ekr.20071102162910.553"><vh> ctor &amp; finishCreate</vh></v>
<v t="ekr.20071102162910.554"><vh> getPublicCommands</vh></v>
<v t="ekr.20071102162910.555"><vh>addToKillBuffer</vh></v>
<v t="ekr.20071102162910.556"><vh>backwardKillSentence</vh></v>
<v t="ekr.20071102162910.557"><vh>backwardKillWord &amp; killWord</vh></v>
<v t="ekr.20071102162910.558"><vh>clearKillRing</vh></v>
<v t="ekr.20071102162910.559"><vh>getClipboard</vh></v>
<v t="ekr.20071102162910.560"><vh>iterateKillBuffer</vh>
<v t="ekr.20071102162910.561"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20071102162910.562"><vh>next</vh></v>
</v>
<v t="ekr.20071102162910.563"><vh>kill</vh></v>
<v t="ekr.20071102162910.564"><vh>KillLine</vh></v>
<v t="ekr.20071102162910.565"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
<v t="ekr.20071102162910.566"><vh>killSentence</vh></v>
<v t="ekr.20071102162910.567"><vh>killWs</vh></v>
<v t="ekr.20071102162910.568"><vh>yank</vh></v>
<v t="ekr.20071102162910.569"><vh>yankPop</vh></v>
<v t="ekr.20071102162910.570"><vh>zapToCharacter</vh></v>
</v>
<v t="ekr.20071102162910.560"><vh>iterateKillBuffer</vh>
<v t="ekr.20071102162910.561"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20071102162910.562"><vh>next</vh></v>
</v>
<v t="ekr.20071102162910.555"><vh>addToKillBuffer</vh></v>
<v t="ekr.20071102162910.568"><vh>yank</vh></v>
<v t="ekr.20071102162910.569"><vh>yankPop</vh></v>
</v>
<v t="ekr.20071102162910.571"><vh>Disabled unnecessary recolors</vh>
<v t="ekr.20071102162910.572"><vh>treeSelectHelper</vh>
<v t="ekr.20071102162910.573"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20071102162910.574"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20071102162910.575"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.576"><vh>Improved (I hope) the rst3 plugin</vh></v>
<v t="ekr.20071102162910.577"><vh>Allow chinese characters work in @menus trees</vh>
<v t="ekr.20071102162910.537" a="M"><vh>createMenuFromConfigList</vh></v>
<v t="ekr.20071102162910.578"><vh>get/setRealMenuName &amp; setRealMenuNamesFromTable</vh></v>
<v t="ekr.20071102162910.579"><vh>createNewMenu</vh></v>
<v t="ekr.20071102162910.469"><vh>createMenuEntries</vh>
<v t="ekr.20071102162910.470"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20071102162910.471"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20071102162910.472"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.473"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.580"><vh>Rewrote threading colorizer: hurray!</vh>
<v t="ekr.20071102162910.581"><vh>Not used in new colorizer</vh>
<v t="ekr.20071102162910.582"><vh>findMarkAtIndex</vh></v>
<v t="ekr.20071102162910.583"><vh>finishColoring</vh></v>
<v t="ekr.20071102162910.584"><vh>partialColor (in helper thread)</vh>
<v t="ekr.20071102162910.585"><vh>&lt;&lt; finish if no item in endList covers i &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.586"><vh>adjustMarksDict</vh></v>
<v t="ekr.20071102162910.587"><vh>removeTagsFromRange</vh></v>
<v t="ekr.20071102162910.588"><vh>computeIndices</vh></v>
</v>
<v t="ekr.20071102162910.589"><vh>Related to new colorizer</vh>
<v t="ekr.20071102162910.590"><vh>tag_ranges</vh></v>
<v t="ekr.20071102162910.591"><vh>w.toPythonIndex</vh></v>
<v t="ekr.20071102162910.592"><vh>g.convertRowColToPythonIndex &amp; test</vh>
<v t="ekr.20071102162910.593"><vh>@test g.convertRowColToPythonIndex</vh></v>
</v>
<v t="ekr.20071102162910.594"><vh>g.convertPythonIndexToRowCol &amp; test</vh>
<v t="ekr.20071102162910.595"><vh>@test g.convertPythonIndexToRowCol</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.596"><vh>Optimized yank, by using yanked leading whitespace if it exists</vh>
<v t="ekr.20071102162910.568"><vh>yank</vh></v>
</v>
<v t="ekr.20071102162910.597"><vh>Added doctest patch to debug command</vh>
<v t="ekr.20071102162910.313"><vh>debug &amp; helper</vh>
<v t="ekr.20071102162910.314"><vh>findDebugger</vh></v>
</v>
</v>
<v t="ekr.20071102162910.598"><vh>Added rst3 strip_at_file_prefixes option</vh></v>
<v t="ekr.20071102162910.599"><vh>Added c# importer</vh>
<v t="ekr.20071102162910.373"><vh>c# syntax ref card</vh></v>
</v>
<v t="ekr.20071102162910.600"><vh>Allow unicode characters in Leo file names</vh>
<v t="ekr.20071102162910.601"><vh>app.newLeoCommanderAndFrame</vh>
<v t="ekr.20071102162910.602"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.603"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20071102162910.604"><vh>g.app.config.readSettingsFiles &amp; helpers</vh>
<v t="ekr.20071102162910.605"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
<v t="ekr.20071102162910.606"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20071102162910.607"><vh>g.app.config.updateSettings</vh></v>
</v>
<v t="ekr.20071102162910.608"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20071102162910.609"><vh>Report</vh></v>
<v t="ekr.20071102162910.610"><vh>Tests of file names</vh></v>
<v t="ekr.20071102162910.611"><vh>toUnicode</vh></v>
</v>
<v t="ekr.20071102162910.612"><vh>Simplified how @auto works</vh>
<v t="ekr.20071102162910.13"><vh>createOutline</vh>
<v t="ekr.20071102162910.14"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.111"><vh>writeAll (atFile)</vh>
<v t="ekr.20071102162910.112"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="ekr.20071102162910.113"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="ekr.20071102162910.114"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.42"><vh>writeAtAutoNodesHelper</vh></v>
<v t="ekr.20071102162910.43"><vh>writeOneAtAutoNode &amp; helpers</vh>
<v t="ekr.20071102162910.44"><vh>shouldWriteAtAutoNode</vh></v>
<v t="ekr.20071102162910.45"><vh>isSignificantAtAutoTree &amp; test</vh>
<v t="ekr.20071102162910.46"><vh>@test test isSignificantAtAutoTree</vh></v>
</v>
</v>
<v t="ekr.20071102162910.179"><vh>readOneAtAutoNode (atFile)</vh></v>
</v>
<v t="ekr.20071102162910.613"><vh>Added g.app.inBridge ivar</vh></v>
<v t="ekr.20071102162910.614"><vh>Improved the scripting and plugins chapters of Leo's Users Guide</vh></v>
<v t="ekr.20071102162910.615"><vh>Added rst3 strip_at_file_prefixes option</vh></v>
</v>
</v>
<v t="ekr.20071102162910.616"><vh>4.4.4 b4</vh>
<v t="ekr.20071102162910.617"><vh>Fixed bugs</vh>
<v t="ekr.20071102162910.618"><vh>Fixed aspell problem</vh>
<v t="ekr.20071102162910.619"><vh>Report</vh></v>
<v t="ekr.20071102162910.620"><vh>class AspellClass</vh>
<v t="ekr.20071102162910.621"><vh>Birth &amp; death</vh>
<v t="ekr.20071102162910.622"><vh>__init__</vh></v>
<v t="ekr.20071102162910.623"><vh>getAspell</vh></v>
<v t="ekr.20071102162910.624"><vh>getAspellWithCtypes</vh>
<v t="ekr.20071102162910.625"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.626"><vh>processWord</vh></v>
<v t="ekr.20071102162910.627"><vh>suggestions</vh></v>
<v t="ekr.20071102162910.628"><vh>updateDictionary</vh></v>
</v>
<v t="ekr.20071102162910.624"><vh>getAspellWithCtypes</vh>
<v t="ekr.20071102162910.625"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.629"><vh>Fixed bug: utf-8 files now get imported properly</vh>
<v t="ekr.20071102162910.179"><vh>readOneAtAutoNode (atFile)</vh></v>
<v t="ekr.20071102162910.43"><vh>writeOneAtAutoNode &amp; helpers</vh>
<v t="ekr.20071102162910.44"><vh>shouldWriteAtAutoNode</vh></v>
<v t="ekr.20071102162910.45"><vh>isSignificantAtAutoTree &amp; test</vh>
<v t="ekr.20071102162910.46"><vh>@test test isSignificantAtAutoTree</vh></v>
</v>
</v>
<v t="ekr.20071102162910.630"><vh>setEncoding</vh></v>
<v t="ekr.20071102162910.631"><vh>Import</vh>
<v t="ekr.20071102162910.13"><vh>createOutline</vh>
<v t="ekr.20071102162910.14"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.105"><vh>readAtAutoNodes (importCommands) &amp; helper</vh>
<v t="ekr.20071102162910.106"><vh>readOneAtAutoNode</vh></v>
</v>
<v t="ekr.20071102162910.632"><vh>importDerivedFiles</vh>
<v t="ekr.20071102162910.633"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20071102162910.634"><vh>forceGnxOnPosition</vh></v>
</v>
<v t="ekr.20071102162910.635"><vh>importFilesCommand</vh>
<v t="ekr.20071102162910.636"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.637"><vh>importFlattenedOutline &amp; allies</vh>
<v t="ekr.20071102162910.638"><vh>convertMoreString/StringsToOutlineAfter</vh>
<v t="ekr.20071102162910.639"><vh>&lt;&lt; Link a new vnode v into the outline &gt;&gt;</vh></v>
<v t="ekr.20071102162910.640"><vh>&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;</vh></v>
<v t="ekr.20071102162910.641"><vh>&lt;&lt; Count the number of following body lines &gt;&gt;</vh></v>
<v t="ekr.20071102162910.642"><vh>&lt;&lt; Add the lines to the body text of v &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.643"><vh>importFlattenedOutline</vh>
<v t="ekr.20071102162910.644"><vh>&lt;&lt; Read the file into array &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.645"><vh>moreHeadlineLevel</vh></v>
<v t="ekr.20071102162910.646"><vh>stringIs/stringsAreValidMoreFile</vh></v>
</v>
<v t="ekr.20071102162910.647"><vh>importWebCommand &amp; allies</vh>
<v t="ekr.20071102162910.648"><vh>createOutlineFromWeb</vh></v>
<v t="ekr.20071102162910.649"><vh>importWebCommand</vh></v>
<v t="ekr.20071102162910.650"><vh>findFunctionDef</vh></v>
<v t="ekr.20071102162910.651"><vh>scanBodyForHeadline</vh>
<v t="ekr.20071102162910.652"><vh>&lt;&lt; scan cweb body for headline &gt;&gt;</vh></v>
<v t="ekr.20071102162910.653"><vh>&lt;&lt; scan noweb body for headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.654"><vh>scanWebFile (handles limbo)</vh>
<v t="ekr.20071102162910.655"><vh>&lt;&lt; Create a symbol table of all section names &gt;&gt;</vh></v>
<v t="ekr.20071102162910.656"><vh>&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;</vh></v>
<v t="ekr.20071102162910.657"><vh>&lt;&lt; Create a node for the next module &gt;&gt;</vh>
<v t="ekr.20071102162910.658"><vh>&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.659"><vh>Symbol table</vh>
<v t="ekr.20071102162910.660"><vh>cstCanonicalize</vh></v>
<v t="ekr.20071102162910.661"><vh>cstDump</vh></v>
<v t="ekr.20071102162910.662"><vh>cstEnter</vh></v>
<v t="ekr.20071102162910.663"><vh>cstLookup</vh></v>
</v>
</v>
<v t="ekr.20071102162910.328"><vh>Scanners for createOutline</vh>
<v t="ekr.20071102162910.120"><vh> class baseScannerClass</vh>
<v t="ekr.20071102162910.121"><vh>baseScannerClass.__init__</vh></v>
<v t="ekr.20071102162910.122"><vh>Checking</vh>
<v t="ekr.20071102162910.123"><vh>check</vh></v>
<v t="ekr.20071102162910.48"><vh>checkTrialWrite &amp; tests</vh>
<v t="ekr.20071102162910.49"><vh>@test checkTriailWrite</vh></v>
</v>
<v t="ekr.20071102162910.124"><vh>compareHelper &amp; tests</vh>
<v t="ekr.20071102162910.125"><vh>@test compareHelper</vh></v>
<v t="ekr.20071102162910.126"><vh>@test compareHelper-warning</vh></v>
</v>
<v t="ekr.20071102162910.81"><vh>reportMismatch &amp; test</vh>
<v t="ekr.20071102162910.82"><vh>minitest of pr</vh></v>
</v>
</v>
<v t="ekr.20071102162910.127"><vh>Code generation</vh>
<v t="ekr.20071102162910.128"><vh>addRef</vh></v>
<v t="ekr.20071102162910.129"><vh>createDeclsNode</vh></v>
<v t="ekr.20071102162910.130"><vh>createFunctionNode</vh></v>
<v t="ekr.20071102162910.131"><vh>createHeadline</vh></v>
<v t="ekr.20071102162910.132"><vh>getLeadingIndent</vh></v>
<v t="ekr.20071102162910.133"><vh>indentBody</vh></v>
<v t="ekr.20071102162910.134"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20071102162910.135"><vh>massageComment</vh></v>
<v t="ekr.20071102162910.136"><vh>putClass &amp; helpers</vh>
<v t="ekr.20071102162910.137"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071102162910.138"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071102162910.139"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20071102162910.141"><vh>putFunction</vh></v>
<v t="ekr.20071102162910.142"><vh>putRootText</vh></v>
<v t="ekr.20071102162910.143"><vh>undentBody &amp; undentBy</vh></v>
<v t="ekr.20071102162910.144"><vh>underindentedComment &amp; underindentedLine</vh></v>
</v>
<v t="ekr.20071102162910.145"><vh>error &amp; oops</vh></v>
<v t="ekr.20071102162910.146"><vh>Parsing</vh>
<v t="ekr.20071102162910.147"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.148"><vh>getIndent</vh></v>
<v t="ekr.20071102162910.149"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071102162910.150"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20071102162910.151"><vh>skipArgs</vh></v>
<v t="ekr.20071102162910.152"><vh>skipBlock</vh></v>
<v t="ekr.20071102162910.153"><vh>skipCodeBlock</vh></v>
<v t="ekr.20071102162910.154"><vh>skipComment &amp; helper</vh>
<v t="ekr.20071102162910.155"><vh>skipBlockComment</vh></v>
</v>
<v t="ekr.20071102162910.156"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20071102162910.157"><vh>adjustClassOrFunctionStart</vh></v>
</v>
<v t="ekr.20071102162910.158"><vh>skipId</vh></v>
<v t="ekr.20071102162910.159"><vh>skipNewline</vh></v>
<v t="ekr.20071102162910.160"><vh>skipParens</vh></v>
<v t="ekr.20071102162910.161"><vh>skipString</vh></v>
<v t="ekr.20071102162910.162"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.164"><vh>skipSigStart</vh></v>
<v t="ekr.20071102162910.165"><vh>skipSigTail</vh></v>
<v t="ekr.20071102162910.166"><vh>skipSigId</vh></v>
</v>
<v t="ekr.20071102162910.167"><vh>startsComment</vh></v>
<v t="ekr.20071102162910.168"><vh>startsId</vh></v>
<v t="ekr.20071102162910.169"><vh>startsString</vh></v>
</v>
<v t="ekr.20071102162910.101"><vh>run (baseScannerClass)</vh>
<v t="ekr.20071102162910.102"><vh>regularizeWhitespace</vh>
<v t="ekr.20071102162910.103"><vh>regularizeError</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.329"><vh>C scanner</vh>
<v t="ekr.20071102162910.330"><vh>scanCText</vh></v>
<v t="ekr.20071102162910.331"><vh>class cScanner (baseScannerClass)</vh></v>
</v>
<v t="ekr.20071102162910.332"><vh>C# scanner</vh>
<v t="ekr.20071102162910.333"><vh>scanCSharpText</vh></v>
<v t="ekr.20071102162910.334"><vh>class cSharpScanner (baseScannerClass)</vh></v>
</v>
<v t="ekr.20071102162910.335"><vh>Elisp scanner</vh>
<v t="ekr.20071102162910.336"><vh>scanElispText</vh></v>
<v t="ekr.20071102162910.337"><vh>class elispScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.338"><vh> __init__</vh></v>
<v t="ekr.20071102162910.339"><vh>Overrides</vh>
<v t="ekr.20071102162910.340"><vh>startsClass/Function &amp; skipSignature</vh></v>
<v t="ekr.20071102162910.341"><vh>startsString</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.342"><vh>Java scanner</vh>
<v t="ekr.20071102162910.343"><vh>scanJavaText</vh></v>
<v t="ekr.20071102162910.344"><vh>class javaScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.345"><vh>javaScanner.__init__</vh></v>
<v t="ekr.20071102162910.346"><vh>javaScanner.skipSigId</vh></v>
</v>
</v>
<v t="ekr.20071102162910.347"><vh>JavaScript scanner (not ready yet)</vh>
<v t="ekr.20071102162910.348"><vh>scanJavaScriptText</vh></v>
<v t="ekr.20071102162910.349"><vh>class javaScriptScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.350"><vh>javaScriptScanner.__init__</vh></v>
<v t="ekr.20071102162910.351"><vh>startsString</vh></v>
<v t="ekr.20071102162910.352"><vh>skipString</vh></v>
</v>
</v>
<v t="ekr.20071102162910.353"><vh>Pascal scanner</vh>
<v t="ekr.20071102162910.354"><vh>scanPascalText</vh></v>
<v t="ekr.20071102162910.355"><vh>class pascalScanner (baseScannerClass)</vh></v>
</v>
<v t="ekr.20071102162910.356"><vh>PHP scanner</vh>
<v t="ekr.20071102162910.357"><vh>scanPHPText</vh></v>
<v t="ekr.20071102162910.358"><vh>class phpScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.359"><vh> __init__</vh></v>
<v t="ekr.20071102162910.360"><vh>isPurePHP</vh></v>
<v t="ekr.20071102162910.361"><vh>Overrides</vh>
<v t="ekr.20071102162910.362"><vh>startsString skipString</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.363"><vh>Python scanner</vh>
<v t="ekr.20071102162910.364"><vh>scanPythonText</vh></v>
<v t="ekr.20071102162910.365"><vh>class pythonScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.366"><vh> __init__</vh></v>
<v t="ekr.20071102162910.367"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.368"><vh>skipString</vh></v>
<v t="ekr.20071102162910.317"><vh>skipCodeBlock (python) &amp; helper</vh>
<v t="ekr.20071102162910.318"><vh>pythonNewlineHelper</vh></v>
</v>
<v t="ekr.20071102162910.369"><vh>skipSigTail</vh></v>
</v>
</v>
<v t="ekr.20071102162910.370"><vh>Default scanner</vh></v>
</v>
<v t="ekr.20071102162910.664"><vh>Unit tests</vh>
<v t="ekr.20071102162910.119"><vh>scannerUnitTest</vh></v>
</v>
</v>
<v t="ekr.20071102162910.13"><vh>createOutline</vh>
<v t="ekr.20071102162910.14"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.122"><vh>Checking</vh>
<v t="ekr.20071102162910.123"><vh>check</vh></v>
<v t="ekr.20071102162910.48"><vh>checkTrialWrite &amp; tests</vh>
<v t="ekr.20071102162910.49"><vh>@test checkTriailWrite</vh></v>
</v>
<v t="ekr.20071102162910.124"><vh>compareHelper &amp; tests</vh>
<v t="ekr.20071102162910.125"><vh>@test compareHelper</vh></v>
<v t="ekr.20071102162910.126"><vh>@test compareHelper-warning</vh></v>
</v>
<v t="ekr.20071102162910.81"><vh>reportMismatch &amp; test</vh>
<v t="ekr.20071102162910.82"><vh>minitest of pr</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.665"><vh>Added defensive code to leoFind.save</vh>
<v t="ekr.20071102162910.258"><vh>save</vh></v>
</v>
<v t="ekr.20071102162910.666"><vh>Replaced c.frame.body with c.frame.body.bodyCtrl</vh></v>
<v t="ekr.20071102162910.667"><vh>Fixed (maybe) multi-editor bug</vh>
<v t="ekr.20071102162910.668"><vh>Report</vh></v>
<v t="ekr.20071102162910.669"><vh>onBodyChanged (leoBody)</vh>
<v t="ekr.20071102162910.670"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20071102162910.671"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.672"><vh>Editors (tkBody)</vh>
<v t="ekr.20071102162910.673"><vh>createEditorFrame</vh></v>
<v t="ekr.20071102162910.674"><vh>packEditorLabelWidget</vh></v>
<v t="ekr.20071102162910.675"><vh>setEditorColors</vh></v>
</v>
<v t="ekr.20071102162910.676"><vh>Editors (leoBody)</vh>
<v t="ekr.20071102162910.677"><vh>entries</vh>
<v t="ekr.20071102162910.678"><vh>addEditor</vh>
<v t="ekr.20071102162910.679"><vh>&lt;&lt; create text widget w &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.680"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20071102162910.681"><vh>deleteEditor</vh></v>
<v t="ekr.20071102162910.682"><vh>findEditorForChapter (leoBody)</vh></v>
<v t="ekr.20071102162910.683"><vh>select/unselectLabel</vh></v>
<v t="ekr.20071102162910.684"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20071102162910.685"><vh>selectEditorHelper</vh>
<v t="ekr.20071102162910.686"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.687"><vh>assignPositionToEditor</vh></v>
<v t="ekr.20071102162910.688"><vh>updateEditors</vh></v>
</v>
<v t="ekr.20071102162910.689"><vh>utils</vh>
<v t="ekr.20071102162910.690"><vh>computeLabel</vh></v>
<v t="ekr.20071102162910.691"><vh>createChapterIvar</vh></v>
<v t="ekr.20071102162910.692"><vh>ensurePositionExists</vh></v>
<v t="ekr.20071102162910.693"><vh>inactivateActiveEditor</vh></v>
<v t="ekr.20071102162910.694"><vh>recolorWidget</vh></v>
<v t="ekr.20071102162910.695"><vh>switchToChapter (leoBody)</vh></v>
<v t="ekr.20071102162910.696"><vh>updateInjectedIvars</vh></v>
</v>
<v t="ekr.20071102162910.697"><vh>unit tests</vh>
<v t="ekr.20071102162910.698"><vh>@test Add &amp; Delete editor</vh></v>
<v t="ekr.20071102162910.699"><vh>@test Add editor, Delete leftmost editor</vh></v>
</v>
</v>
<v t="ekr.20071102162910.684"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20071102162910.685"><vh>selectEditorHelper</vh>
<v t="ekr.20071102162910.686"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.700"><vh>Found: bodyCtrl</vh>
<v t="ekr.20071102162910.701"><vh>Non-editor stuff</vh>
<v t="ekr.20071102162910.226"><vh>changeSelection (changed)</vh>
<v t="ekr.20071102162910.227"><vh>makeRegexSubs</vh></v>
</v>
<v t="ekr.20071102162910.702"><vh>getSelectionAreas (changed)</vh>
<v t="ekr.20071102162910.703"><vh>@test leoBody.getSelectionAreas &amp; test</vh></v>
</v>
<v t="ekr.20071102162910.704"><vh>getInsertLines &amp; test (changed)</vh>
<v t="ekr.20071102162910.705"><vh>@test leoBody.getInsertLines</vh></v>
</v>
<v t="ekr.20071102162910.706"><vh>getSelectionLines (changed)</vh></v>
<v t="ekr.20071102162910.707"><vh>setSelectionAreas (changed)</vh></v>
<v t="ekr.20071102162910.708"><vh>OnHyperLinkControlClick (changed)</vh></v>
<v t="ekr.20071102162910.709"><vh>OnHyperLinkEnter (changed)</vh></v>
<v t="ekr.20071102162910.710"><vh>OnHyperLinkLeave (changed)</vh></v>
<v t="ekr.20071102162910.572"><vh>treeSelectHelper</vh>
<v t="ekr.20071102162910.573"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20071102162910.574"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20071102162910.575"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.711"><vh>finishCreate  (Removed nullFrame.bodyCtrl)</vh></v>
<v t="ekr.20071102162910.712"><vh>createSplitterComponents (removed frame.bodyCtrl ivar)</vh></v>
<v t="ekr.20071102162910.713"><vh>toggleActivePane (changed)</vh></v>
<v t="ekr.20071102162910.714"><vh>&lt;&lt; set the leoTkinterFrame ivars &gt;&gt; (removed frame.bodyCtrl ivar)</vh></v>
<v t="ekr.20071102162910.715"><vh>createSplitterComponents (tkFrame) (removed frame.bodyCtrl ivar)</vh></v>
<v t="ekr.20071102162910.716"><vh>setTabWidth (tkFrame) (changed)</vh></v>
<v t="ekr.20071102162910.717"><vh>setWrap (tkFrame)</vh></v>
<v t="ekr.20071102162910.718"><vh>reconfigurePanes (use config bar_width) (tkFrame) (changed)</vh></v>
<v t="ekr.20071102162910.719"><vh>OnActivateBody (tkFrame)</vh></v>
<v t="ekr.20071102162910.720"><vh>toggleActivePane (tkFrame) (changed)</vh></v>
<v t="ekr.20071102162910.721"><vh>Tk bindings... (tkFrame) (changed)</vh></v>
</v>
<v t="ekr.20071102162910.722"><vh>Editor stuff</vh>
<v t="ekr.20071102162910.678"><vh>addEditor</vh>
<v t="ekr.20071102162910.679"><vh>&lt;&lt; create text widget w &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.680"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20071102162910.681"><vh>deleteEditor</vh></v>
<v t="ekr.20071102162910.682"><vh>findEditorForChapter (leoBody)</vh></v>
<v t="ekr.20071102162910.684"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20071102162910.685"><vh>selectEditorHelper</vh>
<v t="ekr.20071102162910.686"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.685"><vh>selectEditorHelper</vh>
<v t="ekr.20071102162910.686"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.687"><vh>assignPositionToEditor</vh></v>
<v t="ekr.20071102162910.688"><vh>updateEditors</vh></v>
<v t="ekr.20071102162910.694"><vh>recolorWidget</vh></v>
<v t="ekr.20071102162910.699"><vh>@test Add editor, Delete leftmost editor</vh></v>
</v>
<v t="ekr.20071102162910.676"><vh>Editors (leoBody)</vh>
<v t="ekr.20071102162910.677"><vh>entries</vh>
<v t="ekr.20071102162910.678"><vh>addEditor</vh>
<v t="ekr.20071102162910.679"><vh>&lt;&lt; create text widget w &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.680"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20071102162910.681"><vh>deleteEditor</vh></v>
<v t="ekr.20071102162910.682"><vh>findEditorForChapter (leoBody)</vh></v>
<v t="ekr.20071102162910.683"><vh>select/unselectLabel</vh></v>
<v t="ekr.20071102162910.684"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20071102162910.685"><vh>selectEditorHelper</vh>
<v t="ekr.20071102162910.686"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.687"><vh>assignPositionToEditor</vh></v>
<v t="ekr.20071102162910.688"><vh>updateEditors</vh></v>
</v>
<v t="ekr.20071102162910.689"><vh>utils</vh>
<v t="ekr.20071102162910.690"><vh>computeLabel</vh></v>
<v t="ekr.20071102162910.691"><vh>createChapterIvar</vh></v>
<v t="ekr.20071102162910.692"><vh>ensurePositionExists</vh></v>
<v t="ekr.20071102162910.693"><vh>inactivateActiveEditor</vh></v>
<v t="ekr.20071102162910.694"><vh>recolorWidget</vh></v>
<v t="ekr.20071102162910.695"><vh>switchToChapter (leoBody)</vh></v>
<v t="ekr.20071102162910.696"><vh>updateInjectedIvars</vh></v>
</v>
<v t="ekr.20071102162910.697"><vh>unit tests</vh>
<v t="ekr.20071102162910.698"><vh>@test Add &amp; Delete editor</vh></v>
<v t="ekr.20071102162910.699"><vh>@test Add editor, Delete leftmost editor</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20071102162910.723"><vh>Made sure proper node is visible when deleting a body editor</vh>
<v t="ekr.20071102162910.684"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20071102162910.685"><vh>selectEditorHelper</vh>
<v t="ekr.20071102162910.686"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.724"><vh>Fixed colorizer end-of-text bug</vh></v>
<v t="ekr.20071102162910.725"><vh>Added support for fastGotoNode plugin to leoKeyEvent classes</vh>
<v t="ekr.20071102162910.726"><vh>class leoKeyEvent (leoGui)</vh></v>
<v t="ekr.20071102162910.727"><vh>class leoKeyEvent (tkGui)</vh></v>
<v t="ekr.20071102162910.728"><vh>class leoKeyEvent (swingGui)</vh></v>
</v>
<v t="ekr.20071102162910.729"><vh>Fixed bug that disabled multiple occurances of the same icon</vh>
<v t="ekr.20071102162910.730"><vh>drawUserIcon</vh>
<v t="ekr.20071102162910.731"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20071102162910.732"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20071102162910.733"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20071102162910.734"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.735"><vh>New features</vh>
<v t="ekr.20071102162910.736"><vh>Added support for @bool big_outline_pane</vh>
<v t="ekr.20071102162910.737"><vh>The patch</vh></v>
<v t="ekr.20071102162910.738"><vh>tkFrame.finishCreate &amp; helpers</vh>
<v t="ekr.20071102162910.739"><vh>createOuterFrames</vh></v>
<v t="ekr.20071102162910.715"><vh>createSplitterComponents (tkFrame) (removed frame.bodyCtrl ivar)</vh></v>
<v t="ekr.20071102162910.740"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20071102162910.741"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20071102162910.715"><vh>createSplitterComponents (tkFrame) (removed frame.bodyCtrl ivar)</vh></v>
<v t="ekr.20071102162910.742"><vh>tkFrame.createLeoSplitters &amp; helpers</vh>
<v t="ekr.20071102162910.743"><vh>createLeoTkSplitter</vh></v>
<v t="ekr.20071102162910.744"><vh>bindBar</vh></v>
<v t="ekr.20071102162910.745"><vh>divideAnySplitter</vh></v>
<v t="ekr.20071102162910.746"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20071102162910.747"><vh>onDrag...</vh></v>
<v t="ekr.20071102162910.748"><vh>placeSplitter</vh></v>
</v>
</v>
<v t="ekr.20071102162910.749"><vh>OMG: Can print *can* handle unicode</vh>
<v t="ekr.20071102162910.750"><vh>Posting</vh></v>
<v t="ekr.20071102162910.79"><vh>es_print</vh>
<v t="ekr.20071102162910.80"><vh>@@test g.es_print</vh></v>
</v>
</v>
<v t="ekr.20071102162910.751"><vh>Greatly improved the 'Prototype of user icons' in test.leo</vh></v>
<v t="ekr.20071102162910.752"><vh>Improved icon handling in Leo's tree widget</vh>
<v t="ekr.20071102162910.730"><vh>drawUserIcon</vh>
<v t="ekr.20071102162910.731"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20071102162910.732"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20071102162910.733"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20071102162910.734"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20071102162910.753"><vh>4.4.4 final</vh>
<v t="ekr.20071102162910.754"><vh>Fixed bug that caused rClick plugin to crash</vh>
<v t="ekr.20071102162910.755"><vh>event handlers (leoFrame)</vh></v>
</v>
<v t="ekr.20071102162910.756"><vh>Fixed scrolling problem with chapters</vh>
<v t="ekr.20071102162910.757"><vh>chapter.select &amp; helpers</vh>
<v t="ekr.20071102162910.758"><vh>chapterSelectHelper</vh></v>
<v t="ekr.20071102162910.759"><vh>chapter.findPositionInChapter</vh></v>
<v t="ekr.20071102162910.760"><vh>chapter.findEditorInChapter</vh></v>
<v t="ekr.20071102162910.761"><vh>chapter.positionIsInChapter</vh></v>
<v t="ekr.20071102162910.762"><vh>chapter.rename (not used)</vh></v>
</v>
<v t="ekr.20071102162910.763"><vh>tree.redraw_now &amp; helper</vh>
<v t="ekr.20071102162910.764"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20071102162910.765"><vh>Hoist &amp; dehoist</vh></v>
<v t="ekr.20071102162910.766"><vh>scrollTo</vh>
<v t="ekr.20071102162910.767"><vh>&lt;&lt; compute frac0 &gt;&gt;</vh></v>
<v t="ekr.20071102162910.768"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20071102162910.769"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.770"><vh>yoffset</vh></v>
</v>
<v t="ekr.20071102162910.771"><vh>Fixed bug: select a chapter containing the initially selected node</vh>
<v t="ekr.20071102162910.772"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20071102162910.773"><vh>cc.selectChapterForPosition</vh></v>
<v t="ekr.20071102162910.774"><vh>cc.findChapterForPosition (New in Leo 4.4.4)</vh></v>
<v t="ekr.20071102162910.572"><vh>treeSelectHelper</vh>
<v t="ekr.20071102162910.573"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20071102162910.574"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20071102162910.575"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.775"><vh>cc.finishCreate</vh></v>
</v>
<v t="ekr.20071102162910.776"><vh>Fixed Apple help menu reversion</vh>
<v t="ekr.20071102162910.537" a="M"><vh>createMenuFromConfigList</vh></v>
<v t="ekr.20071102162910.535"><vh>createHelpMenuFromTable</vh></v>
<v t="ekr.20071102162910.777" a="M"><vh>getMacHelpMenu</vh></v>
</v>
<v t="ekr.20071102162910.778"><vh>Disabled the plugins manage plugin</vh></v>
<v t="ekr.20071102162910.779"><vh>Made sure plugins work if frame.iconFrame is None</vh></v>
<v t="ekr.20071102162910.780"><vh>Fixed victor's @auto java bug</vh>
<v t="ekr.20071102162910.342"><vh>Java scanner</vh>
<v t="ekr.20071102162910.343"><vh>scanJavaText</vh></v>
<v t="ekr.20071102162910.344"><vh>class javaScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.345"><vh>javaScanner.__init__</vh></v>
<v t="ekr.20071102162910.346"><vh>javaScanner.skipSigId</vh></v>
</v>
</v>
<v t="ekr.20071102162910.120"><vh> class baseScannerClass</vh>
<v t="ekr.20071102162910.121"><vh>baseScannerClass.__init__</vh></v>
<v t="ekr.20071102162910.122"><vh>Checking</vh>
<v t="ekr.20071102162910.123"><vh>check</vh></v>
<v t="ekr.20071102162910.48"><vh>checkTrialWrite &amp; tests</vh>
<v t="ekr.20071102162910.49"><vh>@test checkTriailWrite</vh></v>
</v>
<v t="ekr.20071102162910.124"><vh>compareHelper &amp; tests</vh>
<v t="ekr.20071102162910.125"><vh>@test compareHelper</vh></v>
<v t="ekr.20071102162910.126"><vh>@test compareHelper-warning</vh></v>
</v>
<v t="ekr.20071102162910.81"><vh>reportMismatch &amp; test</vh>
<v t="ekr.20071102162910.82"><vh>minitest of pr</vh></v>
</v>
</v>
<v t="ekr.20071102162910.127"><vh>Code generation</vh>
<v t="ekr.20071102162910.128"><vh>addRef</vh></v>
<v t="ekr.20071102162910.129"><vh>createDeclsNode</vh></v>
<v t="ekr.20071102162910.130"><vh>createFunctionNode</vh></v>
<v t="ekr.20071102162910.131"><vh>createHeadline</vh></v>
<v t="ekr.20071102162910.132"><vh>getLeadingIndent</vh></v>
<v t="ekr.20071102162910.133"><vh>indentBody</vh></v>
<v t="ekr.20071102162910.134"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20071102162910.135"><vh>massageComment</vh></v>
<v t="ekr.20071102162910.136"><vh>putClass &amp; helpers</vh>
<v t="ekr.20071102162910.137"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071102162910.138"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071102162910.139"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20071102162910.141"><vh>putFunction</vh></v>
<v t="ekr.20071102162910.142"><vh>putRootText</vh></v>
<v t="ekr.20071102162910.143"><vh>undentBody &amp; undentBy</vh></v>
<v t="ekr.20071102162910.144"><vh>underindentedComment &amp; underindentedLine</vh></v>
</v>
<v t="ekr.20071102162910.145"><vh>error &amp; oops</vh></v>
<v t="ekr.20071102162910.146"><vh>Parsing</vh>
<v t="ekr.20071102162910.147"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.148"><vh>getIndent</vh></v>
<v t="ekr.20071102162910.149"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071102162910.150"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20071102162910.151"><vh>skipArgs</vh></v>
<v t="ekr.20071102162910.152"><vh>skipBlock</vh></v>
<v t="ekr.20071102162910.153"><vh>skipCodeBlock</vh></v>
<v t="ekr.20071102162910.154"><vh>skipComment &amp; helper</vh>
<v t="ekr.20071102162910.155"><vh>skipBlockComment</vh></v>
</v>
<v t="ekr.20071102162910.156"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20071102162910.157"><vh>adjustClassOrFunctionStart</vh></v>
</v>
<v t="ekr.20071102162910.158"><vh>skipId</vh></v>
<v t="ekr.20071102162910.159"><vh>skipNewline</vh></v>
<v t="ekr.20071102162910.160"><vh>skipParens</vh></v>
<v t="ekr.20071102162910.161"><vh>skipString</vh></v>
<v t="ekr.20071102162910.162"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.164"><vh>skipSigStart</vh></v>
<v t="ekr.20071102162910.165"><vh>skipSigTail</vh></v>
<v t="ekr.20071102162910.166"><vh>skipSigId</vh></v>
</v>
<v t="ekr.20071102162910.167"><vh>startsComment</vh></v>
<v t="ekr.20071102162910.168"><vh>startsId</vh></v>
<v t="ekr.20071102162910.169"><vh>startsString</vh></v>
</v>
<v t="ekr.20071102162910.101"><vh>run (baseScannerClass)</vh>
<v t="ekr.20071102162910.102"><vh>regularizeWhitespace</vh>
<v t="ekr.20071102162910.103"><vh>regularizeError</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.162"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.164"><vh>skipSigStart</vh></v>
<v t="ekr.20071102162910.165"><vh>skipSigTail</vh></v>
<v t="ekr.20071102162910.166"><vh>skipSigId</vh></v>
</v>
<v t="ekr.20071102162910.156"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20071102162910.157"><vh>adjustClassOrFunctionStart</vh></v>
</v>
<v t="ekr.20071102162910.143"><vh>undentBody &amp; undentBy</vh></v>
<v t="ekr.20071102162910.150"><vh>scanHelper</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
<v t="ekr.20071102162910.141"><vh>putFunction</vh></v>
<v t="ekr.20071102162910.122"><vh>Checking</vh>
<v t="ekr.20071102162910.123"><vh>check</vh></v>
<v t="ekr.20071102162910.48"><vh>checkTrialWrite &amp; tests</vh>
<v t="ekr.20071102162910.49"><vh>@test checkTriailWrite</vh></v>
</v>
<v t="ekr.20071102162910.124"><vh>compareHelper &amp; tests</vh>
<v t="ekr.20071102162910.125"><vh>@test compareHelper</vh></v>
<v t="ekr.20071102162910.126"><vh>@test compareHelper-warning</vh></v>
</v>
<v t="ekr.20071102162910.81"><vh>reportMismatch &amp; test</vh>
<v t="ekr.20071102162910.82"><vh>minitest of pr</vh></v>
</v>
</v>
<v t="ekr.20071102162910.136"><vh>putClass &amp; helpers</vh>
<v t="ekr.20071102162910.137"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071102162910.138"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071102162910.139"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
</v>
</v>
<v t="ekr.20071102162910.781"><vh>Fixed spell-check problem on Linux</vh>
<v t="ekr.20071102162910.782"><vh>Spell classes</vh>
<v t="ekr.20071102162910.783"><vh>class spellCommandsClass</vh>
<v t="ekr.20071102162910.784"><vh>ctor</vh></v>
<v t="ekr.20071102162910.785"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20071102162910.786"><vh>openSpellTab</vh>
<v t="ekr.20071102162910.787"><vh>commands...</vh></v>
</v>
</v>
<v t="ekr.20071102162910.788"><vh>class spellTabHandler (leoFind.leoFind)</vh>
<v t="ekr.20071102162910.789"><vh>Birth &amp; death</vh>
<v t="ekr.20071102162910.790"><vh>spellTabHandler.__init__</vh></v>
<v t="ekr.20071102162910.791"><vh>init_aspell</vh></v>
<v t="ekr.20071102162910.792"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20071102162910.793"><vh>Commands</vh>
<v t="ekr.20071102162910.794"><vh>add</vh></v>
<v t="ekr.20071102162910.795"><vh>change (spellTab)</vh></v>
<v t="ekr.20071102162910.796"><vh>find &amp; helpers</vh>
<v t="ekr.20071102162910.797"><vh>findNextMisspelledWord</vh>
<v t="ekr.20071102162910.798"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.799"><vh>findNextWord (tkSpell)</vh></v>
</v>
<v t="ekr.20071102162910.800"><vh>hide</vh></v>
<v t="ekr.20071102162910.801"><vh>ignore</vh></v>
</v>
</v>
<v t="ekr.20071102162910.620"><vh>class AspellClass</vh>
<v t="ekr.20071102162910.621"><vh>Birth &amp; death</vh>
<v t="ekr.20071102162910.622"><vh>__init__</vh></v>
<v t="ekr.20071102162910.623"><vh>getAspell</vh></v>
<v t="ekr.20071102162910.624"><vh>getAspellWithCtypes</vh>
<v t="ekr.20071102162910.625"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.626"><vh>processWord</vh></v>
<v t="ekr.20071102162910.627"><vh>suggestions</vh></v>
<v t="ekr.20071102162910.628"><vh>updateDictionary</vh></v>
</v>
</v>
<v t="ekr.20071102162910.796"><vh>find &amp; helpers</vh>
<v t="ekr.20071102162910.797"><vh>findNextMisspelledWord</vh>
<v t="ekr.20071102162910.798"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.799"><vh>findNextWord (tkSpell)</vh></v>
</v>
<v t="ekr.20071102162910.802"><vh>class tkSpellTab</vh>
<v t="ekr.20071102162910.803"><vh>tkSpellTab.__init__</vh></v>
<v t="ekr.20071102162910.804"><vh>createBindings</vh></v>
<v t="ekr.20071102162910.805"><vh>createFrame</vh>
<v t="ekr.20071102162910.806"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20071102162910.807"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20071102162910.808"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.809"><vh>Event handlers</vh>
<v t="ekr.20071102162910.810"><vh>onAddButton</vh></v>
<v t="ekr.20071102162910.811"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20071102162910.812"><vh>onFindButton</vh></v>
<v t="ekr.20071102162910.813"><vh>onHideButton</vh></v>
<v t="ekr.20071102162910.814"><vh>onIgnoreButton</vh></v>
<v t="ekr.20071102162910.815"><vh>onMap</vh></v>
<v t="ekr.20071102162910.816"><vh>onSelectListBox</vh></v>
</v>
<v t="ekr.20071102162910.817"><vh>Helpers</vh>
<v t="ekr.20071102162910.818"><vh>bringToFront</vh></v>
<v t="ekr.20071102162910.819"><vh>fillbox</vh></v>
<v t="ekr.20071102162910.820"><vh>getSuggestion</vh></v>
<v t="ekr.20071102162910.821"><vh>update (no longer used)</vh></v>
<v t="ekr.20071102162910.822"><vh>updateButtons (spellTab)</vh></v>
</v>
</v>
<v t="ekr.20071102162910.823"><vh>The actual changes</vh>
<v t="ekr.20071102162910.795"><vh>change (spellTab)</vh></v>
<v t="ekr.20071102162910.816"><vh>onSelectListBox</vh></v>
</v>
</v>
<v t="ekr.20071102162910.824"><vh>Use same font in spell tab as in  find tab</vh></v>
<v t="ekr.20071102162910.825"><vh>Fixed (old) body editor bug</vh>
<v t="ekr.20071102162910.826"><vh>Report</vh></v>
<v t="ekr.20071102162910.676"><vh>Editors (leoBody)</vh>
<v t="ekr.20071102162910.677"><vh>entries</vh>
<v t="ekr.20071102162910.678"><vh>addEditor</vh>
<v t="ekr.20071102162910.679"><vh>&lt;&lt; create text widget w &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102162910.680"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20071102162910.681"><vh>deleteEditor</vh></v>
<v t="ekr.20071102162910.682"><vh>findEditorForChapter (leoBody)</vh></v>
<v t="ekr.20071102162910.683"><vh>select/unselectLabel</vh></v>
<v t="ekr.20071102162910.684"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20071102162910.685"><vh>selectEditorHelper</vh>
<v t="ekr.20071102162910.686"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.687"><vh>assignPositionToEditor</vh></v>
<v t="ekr.20071102162910.688"><vh>updateEditors</vh></v>
</v>
<v t="ekr.20071102162910.689"><vh>utils</vh>
<v t="ekr.20071102162910.690"><vh>computeLabel</vh></v>
<v t="ekr.20071102162910.691"><vh>createChapterIvar</vh></v>
<v t="ekr.20071102162910.692"><vh>ensurePositionExists</vh></v>
<v t="ekr.20071102162910.693"><vh>inactivateActiveEditor</vh></v>
<v t="ekr.20071102162910.694"><vh>recolorWidget</vh></v>
<v t="ekr.20071102162910.695"><vh>switchToChapter (leoBody)</vh></v>
<v t="ekr.20071102162910.696"><vh>updateInjectedIvars</vh></v>
</v>
<v t="ekr.20071102162910.697"><vh>unit tests</vh>
<v t="ekr.20071102162910.698"><vh>@test Add &amp; Delete editor</vh></v>
<v t="ekr.20071102162910.699"><vh>@test Add editor, Delete leftmost editor</vh></v>
</v>
</v>
<v t="ekr.20071102162910.717"><vh>setWrap (tkFrame)</vh></v>
<v t="ekr.20071102162910.827"><vh>tkBody.createTextWidget</vh></v>
</v>
<v t="ekr.20071102162910.828"><vh>Never write non-ignored @auto trees</vh>
<v t="ekr.20071102162910.180"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20071102162910.181"><vh>&lt;&lt; Set gnx = tnode index &gt;&gt;</vh></v>
<v t="ekr.20071102162910.182"><vh>&lt;&lt; Append attribute bits to attrs &gt;&gt;</vh></v>
<v t="ekr.20071102162910.183"><vh>&lt;&lt; Append tnodeList and unKnownAttributes to attrs&gt;&gt;</vh></v>
<v t="ekr.20071102162910.184"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102162910.829"><vh>Fixed bug that cause the import of PyParse.py to fail</vh>
<v t="ekr.20071102162910.120"><vh> class baseScannerClass</vh>
<v t="ekr.20071102162910.121"><vh>baseScannerClass.__init__</vh></v>
<v t="ekr.20071102162910.122"><vh>Checking</vh>
<v t="ekr.20071102162910.123"><vh>check</vh></v>
<v t="ekr.20071102162910.48"><vh>checkTrialWrite &amp; tests</vh>
<v t="ekr.20071102162910.49"><vh>@test checkTriailWrite</vh></v>
</v>
<v t="ekr.20071102162910.124"><vh>compareHelper &amp; tests</vh>
<v t="ekr.20071102162910.125"><vh>@test compareHelper</vh></v>
<v t="ekr.20071102162910.126"><vh>@test compareHelper-warning</vh></v>
</v>
<v t="ekr.20071102162910.81"><vh>reportMismatch &amp; test</vh>
<v t="ekr.20071102162910.82"><vh>minitest of pr</vh></v>
</v>
</v>
<v t="ekr.20071102162910.127"><vh>Code generation</vh>
<v t="ekr.20071102162910.128"><vh>addRef</vh></v>
<v t="ekr.20071102162910.129"><vh>createDeclsNode</vh></v>
<v t="ekr.20071102162910.130"><vh>createFunctionNode</vh></v>
<v t="ekr.20071102162910.131"><vh>createHeadline</vh></v>
<v t="ekr.20071102162910.132"><vh>getLeadingIndent</vh></v>
<v t="ekr.20071102162910.133"><vh>indentBody</vh></v>
<v t="ekr.20071102162910.134"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20071102162910.135"><vh>massageComment</vh></v>
<v t="ekr.20071102162910.136"><vh>putClass &amp; helpers</vh>
<v t="ekr.20071102162910.137"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071102162910.138"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071102162910.139"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071102162910.140"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20071102162910.141"><vh>putFunction</vh></v>
<v t="ekr.20071102162910.142"><vh>putRootText</vh></v>
<v t="ekr.20071102162910.143"><vh>undentBody &amp; undentBy</vh></v>
<v t="ekr.20071102162910.144"><vh>underindentedComment &amp; underindentedLine</vh></v>
</v>
<v t="ekr.20071102162910.145"><vh>error &amp; oops</vh></v>
<v t="ekr.20071102162910.146"><vh>Parsing</vh>
<v t="ekr.20071102162910.147"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.148"><vh>getIndent</vh></v>
<v t="ekr.20071102162910.149"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071102162910.150"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20071102162910.151"><vh>skipArgs</vh></v>
<v t="ekr.20071102162910.152"><vh>skipBlock</vh></v>
<v t="ekr.20071102162910.153"><vh>skipCodeBlock</vh></v>
<v t="ekr.20071102162910.154"><vh>skipComment &amp; helper</vh>
<v t="ekr.20071102162910.155"><vh>skipBlockComment</vh></v>
</v>
<v t="ekr.20071102162910.156"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20071102162910.157"><vh>adjustClassOrFunctionStart</vh></v>
</v>
<v t="ekr.20071102162910.158"><vh>skipId</vh></v>
<v t="ekr.20071102162910.159"><vh>skipNewline</vh></v>
<v t="ekr.20071102162910.160"><vh>skipParens</vh></v>
<v t="ekr.20071102162910.161"><vh>skipString</vh></v>
<v t="ekr.20071102162910.162"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.164"><vh>skipSigStart</vh></v>
<v t="ekr.20071102162910.165"><vh>skipSigTail</vh></v>
<v t="ekr.20071102162910.166"><vh>skipSigId</vh></v>
</v>
<v t="ekr.20071102162910.167"><vh>startsComment</vh></v>
<v t="ekr.20071102162910.168"><vh>startsId</vh></v>
<v t="ekr.20071102162910.169"><vh>startsString</vh></v>
</v>
<v t="ekr.20071102162910.101"><vh>run (baseScannerClass)</vh>
<v t="ekr.20071102162910.102"><vh>regularizeWhitespace</vh>
<v t="ekr.20071102162910.103"><vh>regularizeError</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102162910.363"><vh>Python scanner</vh>
<v t="ekr.20071102162910.364"><vh>scanPythonText</vh></v>
<v t="ekr.20071102162910.365"><vh>class pythonScanner (baseScannerClass)</vh>
<v t="ekr.20071102162910.366"><vh> __init__</vh></v>
<v t="ekr.20071102162910.367"><vh>extendSignature</vh></v>
<v t="ekr.20071102162910.368"><vh>skipString</vh></v>
<v t="ekr.20071102162910.317"><vh>skipCodeBlock (python) &amp; helper</vh>
<v t="ekr.20071102162910.318"><vh>pythonNewlineHelper</vh></v>
</v>
<v t="ekr.20071102162910.369"><vh>skipSigTail</vh></v>
</v>
</v>
<v t="ekr.20071102162910.162"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20071102162910.163"><vh>startsHelper</vh></v>
<v t="ekr.20071102162910.164"><vh>skipSigStart</vh></v>
<v t="ekr.20071102162910.165"><vh>skipSigTail</vh></v>
<v t="ekr.20071102162910.166"><vh>skipSigId</vh></v>
</v>
<v t="ekr.20071102162910.152"><vh>skipBlock</vh></v>
<v t="ekr.20071102162910.318"><vh>pythonNewlineHelper</vh></v>
</v>
</v>
<v t="ekr.20071102163001"><vh>( jyLeo )</vh>
<v t="ekr.20071102163001.1"><vh>Debugging in jython</vh>
<v t="ekr.20071102163001.2"><vh>trace</vh></v>
<v t="ekr.20071102163001.3"><vh>callers &amp; _callerName</vh>
<v t="ekr.20071102163001.4"><vh>_callerName</vh></v>
</v>
<v t="ekr.20071102163001.5"><vh>__init__ (swingFrame)</vh>
<v t="ekr.20071102163001.6"><vh>&lt;&lt; set the leoSwingFrame ivars &gt;&gt; (removed frame.bodyCtrl ivar)</vh></v>
</v>
</v>
<v t="ekr.20071102163001.7"><vh>from original swingGui plugin</vh>
<v t="ekr.20071102163001.8"><vh>&lt;&lt; imports &gt;&gt;</vh>
<v t="ekr.20071102163001.9"><vh>imports from leoSwingFrame</vh></v>
<v t="ekr.20071102163001.10"><vh>imports from leoSwingGui (all comments)</vh></v>
<v t="ekr.20071102163001.11"><vh>imports from leoSwingFrame</vh></v>
<v t="ekr.20071102163001.12"><vh>imports from leoSwingMenu (all comments)</vh></v>
</v>
<v t="ekr.20071102163001.13"><vh> init</vh></v>
<v t="ekr.20071102163001.14"><vh>class leoSwingBody</vh>
<v t="ekr.20071102163001.15"><vh>leoSwingBody.__init__</vh></v>
<v t="ekr.20071102163001.16"><vh>oops</vh></v>
<v t="ekr.20071102163001.17"><vh>leoBody.setFontFromConfig</vh></v>
<v t="ekr.20071102163001.18"><vh>DocumentListener</vh></v>
<v t="ekr.20071102163001.19"><vh>Must be overriden in subclasses</vh>
<v t="ekr.20071102163001.20"><vh>Bounding box (Tk spelling)</vh></v>
<v t="ekr.20071102163001.21"><vh>Color tags (Tk spelling)</vh></v>
<v t="ekr.20071102163001.22"><vh>Configuration (Tk spelling)</vh></v>
<v t="ekr.20071102163001.23"><vh>Focus</vh></v>
<v t="ekr.20071102163001.24"><vh>Height &amp; width</vh></v>
<v t="ekr.20071102163001.25"><vh>Idle time...</vh></v>
<v t="ekr.20071102163001.26"><vh>Indices</vh></v>
<v t="ekr.20071102163001.27"><vh>Insert point</vh></v>
<v t="ekr.20071102163001.28"><vh>Menus</vh></v>
<v t="ekr.20071102163001.29"><vh>Selection</vh></v>
<v t="ekr.20071102163001.30"><vh>Text</vh>
<v t="ekr.20071102163001.31"><vh>delete...</vh>
<v t="ekr.20071102163001.32"><vh>deleteAllText</vh></v>
<v t="ekr.20071102163001.33"><vh>deleteCharacter</vh></v>
<v t="ekr.20071102163001.34"><vh>deleteLastChar</vh></v>
<v t="ekr.20071102163001.35"><vh>deleteLine</vh></v>
<v t="ekr.20071102163001.36"><vh>deleteLines</vh></v>
<v t="ekr.20071102163001.37"><vh>deleteRange</vh></v>
</v>
<v t="ekr.20071102163001.38"><vh>get...</vh>
<v t="ekr.20071102163001.39"><vh>getAllText</vh></v>
<v t="ekr.20071102163001.40"><vh>getCharAtIndex</vh></v>
<v t="ekr.20071102163001.41"><vh>getInsertLines</vh></v>
<v t="ekr.20071102163001.42"><vh>getSelectionAreas</vh></v>
<v t="ekr.20071102163001.43"><vh>getSelectionLines</vh></v>
<v t="ekr.20071102163001.44"><vh>getTextRange</vh></v>
</v>
<v t="ekr.20071102163001.45"><vh>Insert...</vh>
<v t="ekr.20071102163001.46"><vh>insertAtInsertPoint</vh></v>
<v t="ekr.20071102163001.47"><vh>insertAtEnd</vh></v>
<v t="ekr.20071102163001.48"><vh>insertAtStartOfLine</vh></v>
</v>
<v t="ekr.20071102163001.49"><vh>setSelectionAreas</vh></v>
</v>
<v t="ekr.20071102163001.50"><vh>Visibility &amp; scrolling</vh></v>
</v>
<v t="ekr.20071102163001.51"><vh>Coloring</vh></v>
<v t="ekr.20071102163001.52"><vh>class Editor</vh>
<v t="ekr.20071102163001.53"><vh>class insTx</vh></v>
<v t="ekr.20071102163001.54"><vh>colorizer callback</vh>
<v t="ekr.20071102163001.55"><vh>__init__</vh></v>
<v t="ekr.20071102163001.56"><vh>changedUpdate</vh></v>
<v t="ekr.20071102163001.57"><vh>checkForLanguageChange</vh></v>
<v t="ekr.20071102163001.58"><vh>drawrectangle</vh></v>
<v t="ekr.20071102163001.59"><vh>getColoredTokens</vh></v>
<v t="ekr.20071102163001.60"><vh>getCommentColor</vh></v>
<v t="ekr.20071102163001.61"><vh>getCommentTokens</vh></v>
<v t="ekr.20071102163001.62"><vh>getCurrentLineNumberForeground</vh></v>
<v t="ekr.20071102163001.63"><vh>getDocColor</vh></v>
<v t="ekr.20071102163001.64"><vh>getFoldedBackgroundColor</vh></v>
<v t="ekr.20071102163001.65"><vh>getFoldedForegroundColor</vh></v>
<v t="ekr.20071102163001.66"><vh>getFootNodeBackgroundColor</vh></v>
<v t="ekr.20071102163001.67"><vh>getFootNodeForegroundColor</vh></v>
<v t="ekr.20071102163001.68"><vh>getFootNodes</vh></v>
<v t="ekr.20071102163001.69"><vh>getInvisiblesBlock</vh></v>
<v t="ekr.20071102163001.70"><vh>getInvisiblesDot</vh></v>
<v t="ekr.20071102163001.71"><vh>getLineNumberBackground</vh></v>
<v t="ekr.20071102163001.72"><vh>getLineNumberColors</vh></v>
<v t="ekr.20071102163001.73"><vh>getLineNumberForeground</vh></v>
<v t="ekr.20071102163001.74"><vh>getNumericColor</vh></v>
<v t="ekr.20071102163001.75"><vh>getOperators</vh></v>
<v t="ekr.20071102163001.76"><vh>getPunctuationColor</vh></v>
<v t="ekr.20071102163001.77"><vh>getRectangleColor</vh></v>
<v t="ekr.20071102163001.78"><vh>getSectionReferenceColor</vh></v>
<v t="ekr.20071102163001.79"><vh>getStringColor</vh></v>
<v t="ekr.20071102163001.80"><vh>getUndefinedSectionReferenceColor</vh></v>
<v t="ekr.20071102163001.81"><vh>hasFootNodes</vh></v>
<v t="ekr.20071102163001.82"><vh>insertUpdate</vh></v>
<v t="ekr.20071102163001.83"><vh>notify</vh></v>
<v t="ekr.20071102163001.84"><vh>removeUpdate</vh></v>
<v t="ekr.20071102163001.85"><vh>setEditor</vh></v>
<v t="ekr.20071102163001.86"><vh>showInvisibles</vh></v>
<v t="ekr.20071102163001.87"><vh>underline</vh></v>
<v t="ekr.20071102163001.88"><vh>useLineNumbers</vh></v>
<v t="ekr.20071102163001.89"><vh>whichInvisible</vh></v>
</v>
<v t="ekr.20071102163001.90"><vh>RecentVisitsMenuListener</vh></v>
<v t="ekr.20071102163001.91"><vh>Note on Editor design</vh></v>
<v t="ekr.20071102163001.92"><vh>__init__ (Editor)</vh>
<v t="ekr.20071102163001.93"><vh>&lt;&lt; add EditorKit &gt;&gt;</vh></v>
<v t="ekr.20071102163001.94"><vh>&lt;&lt; add autocompleter &gt;&gt;</vh></v>
<v t="ekr.20071102163001.95"><vh>&lt;&lt; add scrollpane &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.96"><vh>helper methods and classes</vh>
<v t="ekr.20071102163001.97"><vh>constuctor methods</vh>
<v t="ekr.20071102163001.98"><vh>addMenus</vh></v>
<v t="ekr.20071102163001.99"><vh>addMinibuffer</vh></v>
<v t="ekr.20071102163001.100"><vh>addCompleters</vh></v>
<v t="ekr.20071102163001.101"><vh>initializeEditor</vh></v>
<v t="ekr.20071102163001.102"><vh>initializeEditorColors</vh></v>
<v t="ekr.20071102163001.103"><vh>initializeFont</vh></v>
<v t="ekr.20071102163001.104"><vh>initializeCaret</vh></v>
<v t="ekr.20071102163001.105"><vh>initializeLineNumbering</vh></v>
<v t="ekr.20071102163001.106"><vh>createCommanderCommander</vh></v>
</v>
<v t="ekr.20071102163001.107"><vh>config methods</vh>
<v t="ekr.20071102163001.108"><vh>configureMedia</vh></v>
<v t="ekr.20071102163001.109"><vh>setBackgroundImage</vh></v>
<v t="ekr.20071102163001.110"><vh>useAutocompleter</vh></v>
<v t="ekr.20071102163001.111"><vh>setCaret</vh></v>
<v t="ekr.20071102163001.112"><vh>setFont</vh></v>
<v t="ekr.20071102163001.113"><vh>setEditorColors</vh></v>
<v t="ekr.20071102163001.114"><vh>setLineNumberColors</vh></v>
</v>
<v t="ekr.20071102163001.115"><vh>methods</vh>
<v t="ekr.20071102163001.116"><vh>sync</vh></v>
<v t="ekr.20071102163001.117"><vh>nowShowing</vh></v>
<v t="ekr.20071102163001.118"><vh>menu methods</vh>
<v t="ekr.20071102163001.119"><vh>configureGotoMenu</vh></v>
<v t="ekr.20071102163001.120"><vh>directiveMenu</vh></v>
<v t="ekr.20071102163001.121"><vh>headlineMenu</vh></v>
<v t="ekr.20071102163001.122"><vh>insertSR</vh></v>
<v t="ekr.20071102163001.123"><vh>addSR</vh></v>
<v t="ekr.20071102163001.124"><vh>addLanguageMenu</vh></v>
<v t="ekr.20071102163001.125"><vh>addInsertPath</vh></v>
<v t="ekr.20071102163001.126"><vh>addCompositeView</vh></v>
<v t="ekr.20071102163001.127"><vh>addFlashCardView</vh></v>
<v t="ekr.20071102163001.128"><vh>addFootNodeMenu</vh></v>
</v>
<v t="ekr.20071102163001.129"><vh>implementation of FocusListener interface</vh></v>
<v t="ekr.20071102163001.130"><vh>detach and retach</vh></v>
<v t="ekr.20071102163001.131"><vh>turnSelectionIntoNode</vh></v>
<v t="ekr.20071102163001.132"><vh>insertTextIntoBody</vh></v>
<v t="ekr.20071102163001.133"><vh>splitNode</vh></v>
<v t="ekr.20071102163001.134"><vh>sectionReferenceToWidget</vh></v>
<v t="ekr.20071102163001.135"><vh>chapterChanged</vh></v>
<v t="ekr.20071102163001.136"><vh>headlineChanged</vh></v>
<v t="ekr.20071102163001.137"><vh>splitting the editor</vh>
<v t="ekr.20071102163001.138"><vh>splitVertically</vh></v>
<v t="ekr.20071102163001.139"><vh>createEditor</vh></v>
</v>
</v>
<v t="ekr.20071102163001.140"><vh>helper classes</vh>
<v t="ekr.20071102163001.90"><vh>RecentVisitsMenuListener</vh></v>
<v t="ekr.20071102163001.54"><vh>colorizer callback</vh>
<v t="ekr.20071102163001.55"><vh>__init__</vh></v>
<v t="ekr.20071102163001.56"><vh>changedUpdate</vh></v>
<v t="ekr.20071102163001.57"><vh>checkForLanguageChange</vh></v>
<v t="ekr.20071102163001.58"><vh>drawrectangle</vh></v>
<v t="ekr.20071102163001.59"><vh>getColoredTokens</vh></v>
<v t="ekr.20071102163001.60"><vh>getCommentColor</vh></v>
<v t="ekr.20071102163001.61"><vh>getCommentTokens</vh></v>
<v t="ekr.20071102163001.62"><vh>getCurrentLineNumberForeground</vh></v>
<v t="ekr.20071102163001.63"><vh>getDocColor</vh></v>
<v t="ekr.20071102163001.64"><vh>getFoldedBackgroundColor</vh></v>
<v t="ekr.20071102163001.65"><vh>getFoldedForegroundColor</vh></v>
<v t="ekr.20071102163001.66"><vh>getFootNodeBackgroundColor</vh></v>
<v t="ekr.20071102163001.67"><vh>getFootNodeForegroundColor</vh></v>
<v t="ekr.20071102163001.68"><vh>getFootNodes</vh></v>
<v t="ekr.20071102163001.69"><vh>getInvisiblesBlock</vh></v>
<v t="ekr.20071102163001.70"><vh>getInvisiblesDot</vh></v>
<v t="ekr.20071102163001.71"><vh>getLineNumberBackground</vh></v>
<v t="ekr.20071102163001.72"><vh>getLineNumberColors</vh></v>
<v t="ekr.20071102163001.73"><vh>getLineNumberForeground</vh></v>
<v t="ekr.20071102163001.74"><vh>getNumericColor</vh></v>
<v t="ekr.20071102163001.75"><vh>getOperators</vh></v>
<v t="ekr.20071102163001.76"><vh>getPunctuationColor</vh></v>
<v t="ekr.20071102163001.77"><vh>getRectangleColor</vh></v>
<v t="ekr.20071102163001.78"><vh>getSectionReferenceColor</vh></v>
<v t="ekr.20071102163001.79"><vh>getStringColor</vh></v>
<v t="ekr.20071102163001.80"><vh>getUndefinedSectionReferenceColor</vh></v>
<v t="ekr.20071102163001.81"><vh>hasFootNodes</vh></v>
<v t="ekr.20071102163001.82"><vh>insertUpdate</vh></v>
<v t="ekr.20071102163001.83"><vh>notify</vh></v>
<v t="ekr.20071102163001.84"><vh>removeUpdate</vh></v>
<v t="ekr.20071102163001.85"><vh>setEditor</vh></v>
<v t="ekr.20071102163001.86"><vh>showInvisibles</vh></v>
<v t="ekr.20071102163001.87"><vh>underline</vh></v>
<v t="ekr.20071102163001.88"><vh>useLineNumbers</vh></v>
<v t="ekr.20071102163001.89"><vh>whichInvisible</vh></v>
</v>
<v t="ekr.20071102163001.53"><vh>class insTx</vh></v>
<v t="ekr.20071102163001.141"><vh>resizer --keeps components sized right</vh></v>
<v t="ekr.20071102163001.142"><vh>resizer2</vh></v>
<v t="ekr.20071102163001.143"><vh>gonode -- actionPerformed takes user to node</vh></v>
<v t="ekr.20071102163001.144"><vh>outlinetraveler --allows the user to traverse the tree quickly</vh></v>
<v t="ekr.20071102163001.145"><vh>footnoderemover</vh></v>
<v t="ekr.20071102163001.146"><vh>keywordInserter -- allows the user to insert language keywords</vh></v>
<v t="ekr.20071102163001.147"><vh>swingmacs help</vh></v>
<v t="ekr.20071102163001.148"><vh>autocompleter help</vh></v>
<v t="ekr.20071102163001.149"><vh>class FoldProtector</vh>
<v t="ekr.20071102163001.150"><vh>DocumentFilter interface</vh></v>
<v t="ekr.20071102163001.151"><vh>moveSelectionUp</vh>
<v t="ekr.20071102163001.152"><vh>&lt;&lt;move partial selection&gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.153"><vh>moveSelectionDown</vh>
<v t="ekr.20071102163001.154"><vh>&lt;&lt;move partial selection&gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.155"><vh>class Fold</vh></v>
<v t="ekr.20071102163001.156"><vh>class Defolder</vh></v>
</v>
<v t="ekr.20071102163001.157"><vh>CommanderCommander</vh>
<v t="ekr.20071102163001.158"><vh>setupCommands</vh></v>
<v t="ekr.20071102163001.159"><vh>gotoNode1</vh></v>
<v t="ekr.20071102163001.160"><vh>gotoNode2</vh></v>
</v>
<v t="ekr.20071102163001.161"><vh>BracketHighlighter</vh>
<v t="ekr.20071102163001.162"><vh>__init__</vh></v>
<v t="ekr.20071102163001.163"><vh>DocumentListener interface</vh></v>
<v t="ekr.20071102163001.164"><vh>ChangeListener interface</vh></v>
<v t="ekr.20071102163001.165"><vh>findBracket</vh></v>
<v t="ekr.20071102163001.166"><vh>forwardFind</vh></v>
<v t="ekr.20071102163001.167"><vh>backwardFind</vh></v>
<v t="ekr.20071102163001.168"><vh>setBracketMatch</vh></v>
</v>
</v>
<v t="ekr.20071102163001.169"><vh>component classes</vh>
<v t="ekr.20071102163001.170"><vh>autolistener --does autocompleter work</vh>
<v t="ekr.20071102163001.171"><vh>helper classes</vh>
<v t="ekr.20071102163001.172"><vh>hider and boxListener</vh></v>
</v>
<v t="ekr.20071102163001.173"><vh>constructAutobox</vh></v>
<v t="ekr.20071102163001.174"><vh>processKeyStroke/keyPressed</vh></v>
<v t="ekr.20071102163001.175"><vh>processAutoBox</vh></v>
<v t="ekr.20071102163001.176"><vh>moveUpDown</vh></v>
<v t="ekr.20071102163001.177"><vh>testForUnbind</vh></v>
<v t="ekr.20071102163001.178"><vh>DocumentListener implementation</vh>
<v t="ekr.20071102163001.179"><vh>changedUpdate</vh></v>
<v t="ekr.20071102163001.180"><vh>insertUpdate</vh></v>
<v t="ekr.20071102163001.181"><vh>removeUpdate</vh></v>
</v>
<v t="ekr.20071102163001.182"><vh>watcher</vh></v>
<v t="ekr.20071102163001.183"><vh>scanText</vh></v>
<v t="ekr.20071102163001.184"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20071102163001.185"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20071102163001.186"><vh>_getCleanString</vh></v>
<v t="ekr.20071102163001.187"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20071102163001.188"><vh>reducer</vh></v>
<v t="ekr.20071102163001.189"><vh>determineToShow</vh></v>
<v t="ekr.20071102163001.190"><vh>startup time scanning</vh>
<v t="ekr.20071102163001.191"><vh>initialScan</vh></v>
<v t="ekr.20071102163001.192"><vh>readOutline</vh></v>
</v>
<v t="ekr.20071102163001.193"><vh>get, hide and insert AutoBox</vh>
<v t="ekr.20071102163001.194"><vh>getAutoBox</vh></v>
<v t="ekr.20071102163001.195"><vh>hideAutoBox</vh></v>
<v t="ekr.20071102163001.196"><vh>insertFromAutobox</vh></v>
</v>
</v>
<v t="ekr.20071102163001.197"><vh>Carets</vh>
<v t="ekr.20071102163001.198"><vh>UnderlinerCaret</vh></v>
<v t="ekr.20071102163001.199"><vh>SeeThroughBoxCaret</vh></v>
<v t="ekr.20071102163001.200"><vh>GhostlyLeoCaret</vh></v>
<v t="ekr.20071102163001.201"><vh>ImageCaret</vh></v>
</v>
<v t="ekr.20071102163001.202"><vh>leoJTextPane</vh></v>
<v t="ekr.20071102163001.203"><vh>leoImageJPanel</vh></v>
<v t="ekr.20071102163001.204"><vh>leoLayoutManager</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102163001.205"><vh>MouseAdapter</vh>
<v t="ekr.20071102163001.206"><vh>mousePressed</vh></v>
</v>
<v t="ekr.20071102163001.207"><vh>tabs</vh></v>
<v t="ekr.20071102163001.208"><vh>nextEditor previousEditor</vh></v>
<v t="ekr.20071102163001.209"><vh>classes: Editor and a multitude of helpers</vh>
<v t="ekr.20071102163001.52"><vh>class Editor</vh>
<v t="ekr.20071102163001.53"><vh>class insTx</vh></v>
<v t="ekr.20071102163001.54"><vh>colorizer callback</vh>
<v t="ekr.20071102163001.55"><vh>__init__</vh></v>
<v t="ekr.20071102163001.56"><vh>changedUpdate</vh></v>
<v t="ekr.20071102163001.57"><vh>checkForLanguageChange</vh></v>
<v t="ekr.20071102163001.58"><vh>drawrectangle</vh></v>
<v t="ekr.20071102163001.59"><vh>getColoredTokens</vh></v>
<v t="ekr.20071102163001.60"><vh>getCommentColor</vh></v>
<v t="ekr.20071102163001.61"><vh>getCommentTokens</vh></v>
<v t="ekr.20071102163001.62"><vh>getCurrentLineNumberForeground</vh></v>
<v t="ekr.20071102163001.63"><vh>getDocColor</vh></v>
<v t="ekr.20071102163001.64"><vh>getFoldedBackgroundColor</vh></v>
<v t="ekr.20071102163001.65"><vh>getFoldedForegroundColor</vh></v>
<v t="ekr.20071102163001.66"><vh>getFootNodeBackgroundColor</vh></v>
<v t="ekr.20071102163001.67"><vh>getFootNodeForegroundColor</vh></v>
<v t="ekr.20071102163001.68"><vh>getFootNodes</vh></v>
<v t="ekr.20071102163001.69"><vh>getInvisiblesBlock</vh></v>
<v t="ekr.20071102163001.70"><vh>getInvisiblesDot</vh></v>
<v t="ekr.20071102163001.71"><vh>getLineNumberBackground</vh></v>
<v t="ekr.20071102163001.72"><vh>getLineNumberColors</vh></v>
<v t="ekr.20071102163001.73"><vh>getLineNumberForeground</vh></v>
<v t="ekr.20071102163001.74"><vh>getNumericColor</vh></v>
<v t="ekr.20071102163001.75"><vh>getOperators</vh></v>
<v t="ekr.20071102163001.76"><vh>getPunctuationColor</vh></v>
<v t="ekr.20071102163001.77"><vh>getRectangleColor</vh></v>
<v t="ekr.20071102163001.78"><vh>getSectionReferenceColor</vh></v>
<v t="ekr.20071102163001.79"><vh>getStringColor</vh></v>
<v t="ekr.20071102163001.80"><vh>getUndefinedSectionReferenceColor</vh></v>
<v t="ekr.20071102163001.81"><vh>hasFootNodes</vh></v>
<v t="ekr.20071102163001.82"><vh>insertUpdate</vh></v>
<v t="ekr.20071102163001.83"><vh>notify</vh></v>
<v t="ekr.20071102163001.84"><vh>removeUpdate</vh></v>
<v t="ekr.20071102163001.85"><vh>setEditor</vh></v>
<v t="ekr.20071102163001.86"><vh>showInvisibles</vh></v>
<v t="ekr.20071102163001.87"><vh>underline</vh></v>
<v t="ekr.20071102163001.88"><vh>useLineNumbers</vh></v>
<v t="ekr.20071102163001.89"><vh>whichInvisible</vh></v>
</v>
<v t="ekr.20071102163001.90"><vh>RecentVisitsMenuListener</vh></v>
<v t="ekr.20071102163001.91"><vh>Note on Editor design</vh></v>
<v t="ekr.20071102163001.92"><vh>__init__ (Editor)</vh>
<v t="ekr.20071102163001.93"><vh>&lt;&lt; add EditorKit &gt;&gt;</vh></v>
<v t="ekr.20071102163001.94"><vh>&lt;&lt; add autocompleter &gt;&gt;</vh></v>
<v t="ekr.20071102163001.95"><vh>&lt;&lt; add scrollpane &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.96"><vh>helper methods and classes</vh>
<v t="ekr.20071102163001.97"><vh>constuctor methods</vh>
<v t="ekr.20071102163001.98"><vh>addMenus</vh></v>
<v t="ekr.20071102163001.99"><vh>addMinibuffer</vh></v>
<v t="ekr.20071102163001.100"><vh>addCompleters</vh></v>
<v t="ekr.20071102163001.101"><vh>initializeEditor</vh></v>
<v t="ekr.20071102163001.102"><vh>initializeEditorColors</vh></v>
<v t="ekr.20071102163001.103"><vh>initializeFont</vh></v>
<v t="ekr.20071102163001.104"><vh>initializeCaret</vh></v>
<v t="ekr.20071102163001.105"><vh>initializeLineNumbering</vh></v>
<v t="ekr.20071102163001.106"><vh>createCommanderCommander</vh></v>
</v>
<v t="ekr.20071102163001.107"><vh>config methods</vh>
<v t="ekr.20071102163001.108"><vh>configureMedia</vh></v>
<v t="ekr.20071102163001.109"><vh>setBackgroundImage</vh></v>
<v t="ekr.20071102163001.110"><vh>useAutocompleter</vh></v>
<v t="ekr.20071102163001.111"><vh>setCaret</vh></v>
<v t="ekr.20071102163001.112"><vh>setFont</vh></v>
<v t="ekr.20071102163001.113"><vh>setEditorColors</vh></v>
<v t="ekr.20071102163001.114"><vh>setLineNumberColors</vh></v>
</v>
<v t="ekr.20071102163001.115"><vh>methods</vh>
<v t="ekr.20071102163001.116"><vh>sync</vh></v>
<v t="ekr.20071102163001.117"><vh>nowShowing</vh></v>
<v t="ekr.20071102163001.118"><vh>menu methods</vh>
<v t="ekr.20071102163001.119"><vh>configureGotoMenu</vh></v>
<v t="ekr.20071102163001.120"><vh>directiveMenu</vh></v>
<v t="ekr.20071102163001.121"><vh>headlineMenu</vh></v>
<v t="ekr.20071102163001.122"><vh>insertSR</vh></v>
<v t="ekr.20071102163001.123"><vh>addSR</vh></v>
<v t="ekr.20071102163001.124"><vh>addLanguageMenu</vh></v>
<v t="ekr.20071102163001.125"><vh>addInsertPath</vh></v>
<v t="ekr.20071102163001.126"><vh>addCompositeView</vh></v>
<v t="ekr.20071102163001.127"><vh>addFlashCardView</vh></v>
<v t="ekr.20071102163001.128"><vh>addFootNodeMenu</vh></v>
</v>
<v t="ekr.20071102163001.129"><vh>implementation of FocusListener interface</vh></v>
<v t="ekr.20071102163001.130"><vh>detach and retach</vh></v>
<v t="ekr.20071102163001.131"><vh>turnSelectionIntoNode</vh></v>
<v t="ekr.20071102163001.132"><vh>insertTextIntoBody</vh></v>
<v t="ekr.20071102163001.133"><vh>splitNode</vh></v>
<v t="ekr.20071102163001.134"><vh>sectionReferenceToWidget</vh></v>
<v t="ekr.20071102163001.135"><vh>chapterChanged</vh></v>
<v t="ekr.20071102163001.136"><vh>headlineChanged</vh></v>
<v t="ekr.20071102163001.137"><vh>splitting the editor</vh>
<v t="ekr.20071102163001.138"><vh>splitVertically</vh></v>
<v t="ekr.20071102163001.139"><vh>createEditor</vh></v>
</v>
</v>
<v t="ekr.20071102163001.140"><vh>helper classes</vh>
<v t="ekr.20071102163001.90"><vh>RecentVisitsMenuListener</vh></v>
<v t="ekr.20071102163001.54"><vh>colorizer callback</vh>
<v t="ekr.20071102163001.55"><vh>__init__</vh></v>
<v t="ekr.20071102163001.56"><vh>changedUpdate</vh></v>
<v t="ekr.20071102163001.57"><vh>checkForLanguageChange</vh></v>
<v t="ekr.20071102163001.58"><vh>drawrectangle</vh></v>
<v t="ekr.20071102163001.59"><vh>getColoredTokens</vh></v>
<v t="ekr.20071102163001.60"><vh>getCommentColor</vh></v>
<v t="ekr.20071102163001.61"><vh>getCommentTokens</vh></v>
<v t="ekr.20071102163001.62"><vh>getCurrentLineNumberForeground</vh></v>
<v t="ekr.20071102163001.63"><vh>getDocColor</vh></v>
<v t="ekr.20071102163001.64"><vh>getFoldedBackgroundColor</vh></v>
<v t="ekr.20071102163001.65"><vh>getFoldedForegroundColor</vh></v>
<v t="ekr.20071102163001.66"><vh>getFootNodeBackgroundColor</vh></v>
<v t="ekr.20071102163001.67"><vh>getFootNodeForegroundColor</vh></v>
<v t="ekr.20071102163001.68"><vh>getFootNodes</vh></v>
<v t="ekr.20071102163001.69"><vh>getInvisiblesBlock</vh></v>
<v t="ekr.20071102163001.70"><vh>getInvisiblesDot</vh></v>
<v t="ekr.20071102163001.71"><vh>getLineNumberBackground</vh></v>
<v t="ekr.20071102163001.72"><vh>getLineNumberColors</vh></v>
<v t="ekr.20071102163001.73"><vh>getLineNumberForeground</vh></v>
<v t="ekr.20071102163001.74"><vh>getNumericColor</vh></v>
<v t="ekr.20071102163001.75"><vh>getOperators</vh></v>
<v t="ekr.20071102163001.76"><vh>getPunctuationColor</vh></v>
<v t="ekr.20071102163001.77"><vh>getRectangleColor</vh></v>
<v t="ekr.20071102163001.78"><vh>getSectionReferenceColor</vh></v>
<v t="ekr.20071102163001.79"><vh>getStringColor</vh></v>
<v t="ekr.20071102163001.80"><vh>getUndefinedSectionReferenceColor</vh></v>
<v t="ekr.20071102163001.81"><vh>hasFootNodes</vh></v>
<v t="ekr.20071102163001.82"><vh>insertUpdate</vh></v>
<v t="ekr.20071102163001.83"><vh>notify</vh></v>
<v t="ekr.20071102163001.84"><vh>removeUpdate</vh></v>
<v t="ekr.20071102163001.85"><vh>setEditor</vh></v>
<v t="ekr.20071102163001.86"><vh>showInvisibles</vh></v>
<v t="ekr.20071102163001.87"><vh>underline</vh></v>
<v t="ekr.20071102163001.88"><vh>useLineNumbers</vh></v>
<v t="ekr.20071102163001.89"><vh>whichInvisible</vh></v>
</v>
<v t="ekr.20071102163001.53"><vh>class insTx</vh></v>
<v t="ekr.20071102163001.141"><vh>resizer --keeps components sized right</vh></v>
<v t="ekr.20071102163001.142"><vh>resizer2</vh></v>
<v t="ekr.20071102163001.143"><vh>gonode -- actionPerformed takes user to node</vh></v>
<v t="ekr.20071102163001.144"><vh>outlinetraveler --allows the user to traverse the tree quickly</vh></v>
<v t="ekr.20071102163001.145"><vh>footnoderemover</vh></v>
<v t="ekr.20071102163001.146"><vh>keywordInserter -- allows the user to insert language keywords</vh></v>
<v t="ekr.20071102163001.147"><vh>swingmacs help</vh></v>
<v t="ekr.20071102163001.148"><vh>autocompleter help</vh></v>
<v t="ekr.20071102163001.149"><vh>class FoldProtector</vh>
<v t="ekr.20071102163001.150"><vh>DocumentFilter interface</vh></v>
<v t="ekr.20071102163001.151"><vh>moveSelectionUp</vh>
<v t="ekr.20071102163001.152"><vh>&lt;&lt;move partial selection&gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.153"><vh>moveSelectionDown</vh>
<v t="ekr.20071102163001.154"><vh>&lt;&lt;move partial selection&gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.155"><vh>class Fold</vh></v>
<v t="ekr.20071102163001.156"><vh>class Defolder</vh></v>
</v>
<v t="ekr.20071102163001.157"><vh>CommanderCommander</vh>
<v t="ekr.20071102163001.158"><vh>setupCommands</vh></v>
<v t="ekr.20071102163001.159"><vh>gotoNode1</vh></v>
<v t="ekr.20071102163001.160"><vh>gotoNode2</vh></v>
</v>
<v t="ekr.20071102163001.161"><vh>BracketHighlighter</vh>
<v t="ekr.20071102163001.162"><vh>__init__</vh></v>
<v t="ekr.20071102163001.163"><vh>DocumentListener interface</vh></v>
<v t="ekr.20071102163001.164"><vh>ChangeListener interface</vh></v>
<v t="ekr.20071102163001.165"><vh>findBracket</vh></v>
<v t="ekr.20071102163001.166"><vh>forwardFind</vh></v>
<v t="ekr.20071102163001.167"><vh>backwardFind</vh></v>
<v t="ekr.20071102163001.168"><vh>setBracketMatch</vh></v>
</v>
</v>
<v t="ekr.20071102163001.169"><vh>component classes</vh>
<v t="ekr.20071102163001.170"><vh>autolistener --does autocompleter work</vh>
<v t="ekr.20071102163001.171"><vh>helper classes</vh>
<v t="ekr.20071102163001.172"><vh>hider and boxListener</vh></v>
</v>
<v t="ekr.20071102163001.173"><vh>constructAutobox</vh></v>
<v t="ekr.20071102163001.174"><vh>processKeyStroke/keyPressed</vh></v>
<v t="ekr.20071102163001.175"><vh>processAutoBox</vh></v>
<v t="ekr.20071102163001.176"><vh>moveUpDown</vh></v>
<v t="ekr.20071102163001.177"><vh>testForUnbind</vh></v>
<v t="ekr.20071102163001.178"><vh>DocumentListener implementation</vh>
<v t="ekr.20071102163001.179"><vh>changedUpdate</vh></v>
<v t="ekr.20071102163001.180"><vh>insertUpdate</vh></v>
<v t="ekr.20071102163001.181"><vh>removeUpdate</vh></v>
</v>
<v t="ekr.20071102163001.182"><vh>watcher</vh></v>
<v t="ekr.20071102163001.183"><vh>scanText</vh></v>
<v t="ekr.20071102163001.184"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20071102163001.185"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20071102163001.186"><vh>_getCleanString</vh></v>
<v t="ekr.20071102163001.187"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20071102163001.188"><vh>reducer</vh></v>
<v t="ekr.20071102163001.189"><vh>determineToShow</vh></v>
<v t="ekr.20071102163001.190"><vh>startup time scanning</vh>
<v t="ekr.20071102163001.191"><vh>initialScan</vh></v>
<v t="ekr.20071102163001.192"><vh>readOutline</vh></v>
</v>
<v t="ekr.20071102163001.193"><vh>get, hide and insert AutoBox</vh>
<v t="ekr.20071102163001.194"><vh>getAutoBox</vh></v>
<v t="ekr.20071102163001.195"><vh>hideAutoBox</vh></v>
<v t="ekr.20071102163001.196"><vh>insertFromAutobox</vh></v>
</v>
</v>
<v t="ekr.20071102163001.197"><vh>Carets</vh>
<v t="ekr.20071102163001.198"><vh>UnderlinerCaret</vh></v>
<v t="ekr.20071102163001.199"><vh>SeeThroughBoxCaret</vh></v>
<v t="ekr.20071102163001.200"><vh>GhostlyLeoCaret</vh></v>
<v t="ekr.20071102163001.201"><vh>ImageCaret</vh></v>
</v>
<v t="ekr.20071102163001.202"><vh>leoJTextPane</vh></v>
<v t="ekr.20071102163001.203"><vh>leoImageJPanel</vh></v>
<v t="ekr.20071102163001.204"><vh>leoLayoutManager</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102163001.205"><vh>MouseAdapter</vh>
<v t="ekr.20071102163001.206"><vh>mousePressed</vh></v>
</v>
<v t="ekr.20071102163001.210"><vh>SimplifiedUtilityRightClick -- for adding an Editor</vh>
<v t="ekr.20071102163001.211"><vh>mousePressed</vh></v>
</v>
<v t="ekr.20071102163001.212"><vh>class AddEditor</vh></v>
<v t="ekr.20071102163001.213"><vh>class UtilityAction</vh></v>
<v t="ekr.20071102163001.214"><vh>class InsertNode</vh></v>
</v>
<v t="ekr.20071102163001.215"><vh>UndoableEditListener</vh></v>
<v t="ekr.20071102163001.216"><vh>KeyAdapter -- for preparing undoer</vh></v>
<v t="ekr.20071102163001.217"><vh>getAllText --had to be added</vh></v>
</v>
<v t="ekr.20071102163001.218"><vh>class leoSwingFrame</vh>
<v t="ekr.20071102163001.219"><vh>  leoSwingFrame.__init__</vh></v>
<v t="ekr.20071102163001.220"><vh>finishCreate</vh>
<v t="ekr.20071102163001.221"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.222"><vh> Must be defined in subclasses</vh>
<v t="ekr.20071102163001.223"><vh> gui-dependent commands</vh>
<v t="ekr.20071102163001.224"><vh>cut/copy/paste</vh></v>
</v>
<v t="ekr.20071102163001.225"><vh>bringToFront, deiconify, lift &amp; update</vh></v>
<v t="ekr.20071102163001.226"><vh>config stuff...</vh>
<v t="ekr.20071102163001.227"><vh>resizePanesToRatio</vh></v>
<v t="ekr.20071102163001.228"><vh>setInitialWindowGeometry</vh></v>
<v t="ekr.20071102163001.229"><vh>setTopGeometry</vh></v>
<v t="ekr.20071102163001.230"><vh>get_window_info</vh></v>
</v>
</v>
<v t="ekr.20071102163001.231"><vh>Unchanged from base class</vh>
<v t="ekr.20071102163001.232"><vh>setTabWidth</vh></v>
<v t="ekr.20071102163001.233"><vh>getTitle &amp; setTitle</vh></v>
<v t="ekr.20071102163001.234"><vh>initialRatios</vh></v>
<v t="ekr.20071102163001.235"><vh>longFileName &amp; shortFileName</vh></v>
<v t="ekr.20071102163001.236"><vh>oops</vh></v>
<v t="ekr.20071102163001.237"><vh>promptForSave</vh>
<v t="ekr.20071102163001.238"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.239"><vh>scanForTabWidth</vh>
<v t="ekr.20071102163001.240"><vh>&lt;&lt; set w and break on @tabwidth &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102163001.241"><vh>New methods</vh>
<v t="ekr.20071102163001.242"><vh>destroySelf --had to be added</vh></v>
<v t="ekr.20071102163001.243"><vh>clearStatusLine -- had to be added</vh></v>
<v t="ekr.20071102163001.244"><vh>finishCreateForSettings</vh>
<v t="ekr.20071102163001.245"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.246"><vh>setSkin</vh></v>
<v t="ekr.20071102163001.247"><vh>addIconButton -- had to be added</vh></v>
<v t="ekr.20071102163001.248"><vh>toggleActivePane</vh></v>
<v t="ekr.20071102163001.249"><vh>isMenuInitialized</vh></v>
<v t="ekr.20071102163001.250"><vh>startReceiver</vh></v>
</v>
<v t="ekr.20071102163001.251"><vh>helper classes</vh>
<v t="ekr.20071102163001.252"><vh>class leoFocusTraversalPolicy</vh>
<v t="ekr.20071102163001.253"><vh>getComponentAfter</vh></v>
<v t="ekr.20071102163001.254"><vh>getComponentBefore</vh></v>
<v t="ekr.20071102163001.255"><vh>getDefaultComponent</vh></v>
<v t="ekr.20071102163001.256"><vh>getFirstComponent</vh></v>
<v t="ekr.20071102163001.257"><vh>getInitialComponent</vh></v>
<v t="ekr.20071102163001.258"><vh>getLastComponent</vh></v>
</v>
<v t="ekr.20071102163001.259"><vh>class Receiver</vh>
<v t="ekr.20071102163001.260"><vh>run</vh></v>
</v>
<v t="ekr.20071102163001.261"><vh>class GlassPane2</vh>
<v t="ekr.20071102163001.262"><vh>__init__</vh></v>
<v t="ekr.20071102163001.263"><vh>setImage</vh></v>
<v t="ekr.20071102163001.264"><vh>phaseIn</vh></v>
<v t="ekr.20071102163001.265"><vh>class Phaser</vh></v>
<v t="ekr.20071102163001.266"><vh>paintComponent2</vh></v>
</v>
<v t="ekr.20071102163001.267"><vh>class NodeBar</vh>
<v t="ekr.20071102163001.268"><vh> __init__</vh></v>
<v t="ekr.20071102163001.269"><vh>createButton</vh></v>
<v t="ekr.20071102163001.270"><vh>endUpdate</vh></v>
<v t="ekr.20071102163001.271"><vh>flavorsChanged</vh></v>
<v t="ekr.20071102163001.272"><vh>goto enablers</vh></v>
<v t="ekr.20071102163001.273"><vh>gotoChild</vh></v>
<v t="ekr.20071102163001.274"><vh>images</vh></v>
<v t="ekr.20071102163001.275"><vh>run</vh></v>
</v>
<v t="ekr.20071102163001.276"><vh>class WindowClosingWatcher</vh></v>
<v t="ekr.20071102163001.277"><vh>class LeoMetalTheme</vh>
<v t="ekr.20071102163001.278"><vh>getName</vh></v>
<v t="ekr.20071102163001.279"><vh>getControlTextFont2</vh></v>
<v t="ekr.20071102163001.280"><vh>getMenuTextFont2</vh></v>
<v t="ekr.20071102163001.281"><vh>getPrimary1</vh></v>
<v t="ekr.20071102163001.282"><vh>getPrimary2</vh></v>
<v t="ekr.20071102163001.283"><vh>getPrimary3</vh></v>
<v t="ekr.20071102163001.284"><vh>getSecondary1</vh></v>
<v t="ekr.20071102163001.285"><vh>getSecondary2</vh></v>
<v t="ekr.20071102163001.286"><vh>getSecondary3</vh></v>
<v t="ekr.20071102163001.287"><vh>getBlack2</vh></v>
<v t="ekr.20071102163001.288"><vh>getMenuBackground</vh></v>
<v t="ekr.20071102163001.289"><vh>getMenuForeground</vh></v>
<v t="ekr.20071102163001.290"><vh>getMenuSelectedForeground</vh></v>
<v t="ekr.20071102163001.291"><vh>getMenuSelectedBackground</vh></v>
<v t="ekr.20071102163001.292"><vh>getPrimaryControl</vh></v>
<v t="ekr.20071102163001.293"><vh>getControl</vh></v>
<v t="ekr.20071102163001.294"><vh>getControlHighlight</vh></v>
<v t="ekr.20071102163001.295"><vh>getPrimaryControlHighlight</vh></v>
<v t="ekr.20071102163001.296"><vh>getSystemTextColor</vh></v>
<v t="ekr.20071102163001.297"><vh>getSubTextFont2</vh></v>
<v t="ekr.20071102163001.298"><vh>getSystemTextFont2</vh></v>
<v t="ekr.20071102163001.299"><vh>getUserTextFont2</vh></v>
<v t="ekr.20071102163001.300"><vh>getWindowTitleFont2</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102163001.301"><vh>class leoSwingGui</vh>
<v t="ekr.20071102163001.302"><vh>app.gui Birth &amp; death</vh>
<v t="ekr.20071102163001.303"><vh> leoGui.__init__</vh></v>
<v t="ekr.20071102163001.304"><vh>newLeoCommanderAndFrame (gui-independent)</vh>
<v t="ekr.20071102163001.305"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.306"><vh>stubs</vh>
<v t="ekr.20071102163001.307"><vh>createRootWindow</vh></v>
<v t="ekr.20071102163001.308"><vh>destroySelf</vh></v>
<v t="ekr.20071102163001.309"><vh>finishCreate</vh></v>
<v t="ekr.20071102163001.310"><vh>killGui</vh></v>
<v t="ekr.20071102163001.311"><vh>recreateRootWindow</vh></v>
<v t="ekr.20071102163001.312"><vh>runMainLoop</vh></v>
</v>
</v>
<v t="ekr.20071102163001.313"><vh>app.gui dialogs</vh></v>
<v t="ekr.20071102163001.314"><vh>app.gui file dialogs</vh></v>
<v t="ekr.20071102163001.315"><vh>app.gui panels</vh></v>
<v t="ekr.20071102163001.316"><vh>app.gui utils</vh>
<v t="ekr.20071102163001.317"><vh>Clipboard</vh></v>
<v t="ekr.20071102163001.318"><vh>Dialog utils</vh></v>
<v t="ekr.20071102163001.319"><vh>Font</vh></v>
<v t="ekr.20071102163001.320"><vh>Focus</vh></v>
<v t="ekr.20071102163001.321"><vh>Index</vh></v>
<v t="ekr.20071102163001.322"><vh>Idle time</vh></v>
</v>
<v t="ekr.20071102163001.323"><vh>guiName</vh></v>
<v t="ekr.20071102163001.324"><vh>oops</vh></v>
<v t="ekr.20071102163001.325"><vh>insertPoints --had to be added</vh></v>
<v t="ekr.20071102163001.326"><vh>makeIndexVisible --had to be added</vh></v>
<v t="ekr.20071102163001.327"><vh>moveIndexForward &amp; moveIndexToNextLine -- had to be added</vh></v>
<v t="ekr.20071102163001.328"><vh>addStartupTask</vh></v>
<v t="ekr.20071102163001.329"><vh>getFontFromParams</vh></v>
<v t="ekr.20071102163001.330"><vh>Look And Feel Changes</vh>
<v t="ekr.20071102163001.331"><vh>addLAFListener</vh></v>
<v t="ekr.20071102163001.332"><vh>class LAFChangeListener</vh></v>
</v>
<v t="ekr.20071102163001.333"><vh>had to be added</vh>
<v t="ekr.20071102163001.334"><vh>replaceSelectionRangeWithText</vh></v>
<v t="ekr.20071102163001.335"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20071102163001.336"><vh>compareIndices</vh></v>
<v t="ekr.20071102163001.337"><vh>getAllText</vh></v>
</v>
</v>
<v t="ekr.20071102163001.338"><vh>class leoSwingLog</vh>
<v t="ekr.20071102163001.339"><vh>leoLog.__init__</vh></v>
<v t="ekr.20071102163001.340"><vh>leoLog.configure</vh></v>
<v t="ekr.20071102163001.341"><vh>leoLog.configureBorder</vh></v>
<v t="ekr.20071102163001.342"><vh>leoLog.createControl</vh></v>
<v t="ekr.20071102163001.343"><vh>leoLog.enable &amp; disable</vh></v>
<v t="ekr.20071102163001.344"><vh>leoLog.oops</vh></v>
<v t="ekr.20071102163001.345"><vh>leoLog.setFontFromConfig</vh></v>
<v t="ekr.20071102163001.346"><vh>leoLog.onActivateLog</vh></v>
<v t="ekr.20071102163001.347"><vh>leoLog.put &amp; putnl</vh></v>
<v t="ekr.20071102163001.348"><vh>class LogControl</vh></v>
<v t="ekr.20071102163001.349"><vh>setBackgroundImage</vh></v>
<v t="ekr.20071102163001.350"><vh>leoLog setColorFromConfig</vh></v>
<v t="ekr.20071102163001.351"><vh>addTab</vh></v>
</v>
<v t="ekr.20071102163001.352"><vh>class leoSwingMenu</vh>
<v t="ekr.20071102163001.353"><vh> leoSwingMenu.__init__</vh></v>
<v t="ekr.20071102163001.354"><vh>class MenuChanger</vh></v>
<v t="ekr.20071102163001.355"><vh>print menu stuff...</vh>
<v t="ekr.20071102163001.356"><vh>defineLeoSwingPrintTable</vh></v>
<v t="ekr.20071102163001.357"><vh>createLeoSwingPrintMenu</vh></v>
<v t="ekr.20071102163001.358"><vh>createLeoSwingPrint</vh></v>
</v>
<v t="ekr.20071102163001.359"><vh>plugin menu stuff...</vh>
<v t="ekr.20071102163001.360"><vh>createPluginMenu</vh></v>
<v t="ekr.20071102163001.361"><vh>createPluginManager</vh></v>
<v t="ekr.20071102163001.362"><vh>getPluginMenu</vh></v>
</v>
<v t="ekr.20071102163001.363"><vh>JythonShell stuff</vh>
<v t="ekr.20071102163001.364"><vh>openJythonShell</vh></v>
<v t="ekr.20071102163001.365"><vh>addMenuToJythonShell</vh></v>
<v t="ekr.20071102163001.366"><vh>getInsertNodeIntoShell</vh></v>
<v t="ekr.20071102163001.367"><vh>getInsertReferenceIntoLeo</vh></v>
<v t="ekr.20071102163001.368"><vh>getRunNodeInPdb</vh></v>
<v t="ekr.20071102163001.369"><vh>fireNodeAsScript</vh></v>
<v t="ekr.20071102163001.370"><vh>class _GetReferenceName</vh></v>
</v>
<v t="ekr.20071102163001.371"><vh>addUserGuide</vh></v>
<v t="ekr.20071102163001.372"><vh>createRecentFilesMenuItems (leoMenu)</vh></v>
<v t="ekr.20071102163001.373"><vh>oops</vh></v>
<v t="ekr.20071102163001.374"><vh>Must be overridden in menu subclasses</vh>
<v t="ekr.20071102163001.375"><vh>9 Routines with Tk spellings</vh></v>
<v t="ekr.20071102163001.376"><vh>7 Routines with new spellings</vh></v>
<v t="ekr.20071102163001.377"><vh>class MenuRunnable</vh></v>
<v t="ekr.20071102163001.378"><vh>class MenuExecuteOnSelect</vh></v>
<v t="ekr.20071102163001.379"><vh>class LeoMenu</vh></v>
</v>
</v>
<v t="ekr.20071102163001.380"><vh>class leoSwingTree</vh>
<v t="ekr.20071102163001.381"><vh>  tree.__init__ (base class)</vh></v>
<v t="ekr.20071102163001.382"><vh>class posTreeModel</vh></v>
<v t="ekr.20071102163001.383"><vh>doneLoading</vh></v>
<v t="ekr.20071102163001.384"><vh>valueChanged --tree selection Event</vh></v>
<v t="ekr.20071102163001.385"><vh> Must be defined in subclasses</vh>
<v t="ekr.20071102163001.386"><vh>Drawing</vh></v>
<v t="ekr.20071102163001.387"><vh>Edit label</vh></v>
<v t="ekr.20071102163001.388"><vh>Notifications</vh></v>
<v t="ekr.20071102163001.389"><vh>Scrolling</vh></v>
<v t="ekr.20071102163001.390"><vh>Selecting</vh></v>
<v t="ekr.20071102163001.391"><vh>Tree operations</vh></v>
</v>
<v t="ekr.20071102163001.392"><vh>beginUpdate</vh></v>
<v t="ekr.20071102163001.393"><vh>endUpdate</vh></v>
<v t="ekr.20071102163001.394"><vh>Getters/Setters (tree)</vh></v>
<v t="ekr.20071102163001.395"><vh>oops</vh></v>
<v t="ekr.20071102163001.396"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="ekr.20071102163001.397"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="ekr.20071102163001.398"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="ekr.20071102163001.399"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.400"><vh>tree.enableDrawingAfterException</vh></v>
<v t="ekr.20071102163001.401"><vh>class tcellEditor</vh></v>
<v t="ekr.20071102163001.402"><vh>class cellEditorListener</vh></v>
<v t="ekr.20071102163001.403"><vh>edit_text --had to be added</vh></v>
<v t="ekr.20071102163001.404"><vh>createAuxilaryWidgets</vh></v>
<v t="ekr.20071102163001.405"><vh>getWidget</vh></v>
<v t="ekr.20071102163001.406"><vh>configureMedia</vh></v>
<v t="ekr.20071102163001.407"><vh>setBackgroundImage</vh></v>
<v t="ekr.20071102163001.408"><vh>helper classes</vh>
<v t="ekr.20071102163001.409"><vh>class JTree2</vh></v>
<v t="ekr.20071102163001.382"><vh>class posTreeModel</vh></v>
<v t="ekr.20071102163001.401"><vh>class tcellEditor</vh></v>
<v t="ekr.20071102163001.402"><vh>class cellEditorListener</vh></v>
<v t="ekr.20071102163001.410"><vh>class EditLabelEnabler</vh></v>
<v t="ekr.20071102163001.411"><vh>class ViewControls</vh></v>
<v t="ekr.20071102163001.412"><vh>class PopupEnabler</vh></v>
<v t="ekr.20071102163001.413"><vh>class ImageSetter</vh></v>
<v t="ekr.20071102163001.414"><vh>class TreeTransferHandler</vh>
<v t="ekr.20071102163001.415"><vh>canImport</vh></v>
<v t="ekr.20071102163001.416"><vh>importData</vh></v>
<v t="ekr.20071102163001.417"><vh>importFile</vh></v>
<v t="ekr.20071102163001.418"><vh>getVisualRepresentation</vh></v>
<v t="ekr.20071102163001.419"><vh>class TreeTransferable</vh>
<v t="ekr.20071102163001.420"><vh>getTransferData</vh></v>
<v t="ekr.20071102163001.421"><vh>writeNodeToFile</vh></v>
</v>
<v t="ekr.20071102163001.422"><vh>class ImportUrls</vh></v>
<v t="ekr.20071102163001.423"><vh>class ImportFiles</vh></v>
</v>
</v>
<v t="ekr.20071102163001.424"><vh>focuslistener interface</vh></v>
<v t="ekr.20071102163001.425"><vh>image creation</vh></v>
<v t="ekr.20071102163001.426"><vh>tree.getFont,setFont,setFontFromConfig</vh></v>
<v t="ekr.20071102163001.427"><vh>setBackgroundColor</vh></v>
</v>
<v t="ekr.20071102163001.428"><vh>Utils</vh>
<v t="ekr.20071102163001.429"><vh>getColorInstance</vh></v>
<v t="ekr.20071102163001.430"><vh>class leoJSPFocusListener</vh></v>
<v t="ekr.20071102163001.431"><vh>class VisibleInformer</vh></v>
</v>
<v t="ekr.20071102163001.432"><vh>from leoSwingFind.py</vh>
<v t="ekr.20071102163001.433"><vh>Birth &amp; death</vh>
<v t="ekr.20071102163001.434"><vh>__init__</vh>
<v t="ekr.20071102163001.435"><vh>&lt;&lt; init the tkinter ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.436"><vh>fake TkVars --classes that look like Tk variables</vh></v>
<v t="ekr.20071102163001.437"><vh>destroySelf</vh></v>
<v t="ekr.20071102163001.438"><vh>find.createFrame</vh>
<v t="ekr.20071102163001.439"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="ekr.20071102163001.440"><vh>&lt;&lt; Create four columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20071102163001.441"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.442"><vh>createNodeSearchFrame</vh></v>
<v t="ekr.20071102163001.443"><vh>addAsSearchOrExclude</vh></v>
<v t="ekr.20071102163001.444"><vh>find.init</vh>
<v t="ekr.20071102163001.445"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20071102163001.446"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.447"><vh>find.set_ivars</vh></v>
<v t="ekr.20071102163001.448"><vh>find.update_ivars</vh></v>
</v>
<v t="ekr.20071102163001.449"><vh>onCloseWindow</vh></v>
<v t="ekr.20071102163001.450"><vh>bringToFront</vh></v>
<v t="ekr.20071102163001.451"><vh>selectAll</vh></v>
<v t="ekr.20071102163001.452"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
<v t="ekr.20071102163001.453"><vh>search</vh></v>
<v t="ekr.20071102163001.454"><vh>findButton --had to change</vh></v>
<v t="ekr.20071102163001.455"><vh>executeSearch</vh></v>
<v t="ekr.20071102163001.456"><vh>findNextCommand</vh></v>
<v t="ekr.20071102163001.457"><vh>changeAll</vh></v>
<v t="ekr.20071102163001.458"><vh>clone and copy searching</vh>
<v t="ekr.20071102163001.459"><vh>nodeSearch</vh></v>
<v t="ekr.20071102163001.460"><vh>createContainerNode</vh></v>
</v>
<v t="ekr.20071102163001.461"><vh>class CutCopyPaste</vh></v>
<v t="ekr.20071102163001.462"><vh>class _LeoTableCellEditor</vh></v>
<v t="ekr.20071102163001.463"><vh>class _LeoTableCellRenderer</vh></v>
</v>
<v t="ekr.20071102163001.464"><vh>from leoSwingComparePanel</vh>
<v t="ekr.20071102163001.465"><vh>Birth...</vh>
<v t="ekr.20071102163001.466"><vh> tkinterComparePanel.__init__</vh>
<v t="ekr.20071102163001.467"><vh>&lt;&lt; init tkinter compare ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.468"><vh>fake Tk vars</vh></v>
<v t="ekr.20071102163001.469"><vh>class _DTM</vh></v>
<v t="ekr.20071102163001.470"><vh>finishCreate</vh></v>
<v t="ekr.20071102163001.471"><vh>createTopFrame</vh></v>
<v t="ekr.20071102163001.472"><vh>createFrame</vh>
<v t="ekr.20071102163001.473"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="ekr.20071102163001.474"><vh>&lt;&lt; create the browser rows &gt;&gt;</vh></v>
<v t="ekr.20071102163001.475"><vh>&lt;&lt; create the extension row &gt;&gt;</vh></v>
<v t="ekr.20071102163001.476"><vh>&lt;&lt; create the whitespace options frame &gt;&gt;</vh></v>
<v t="ekr.20071102163001.477"><vh>&lt;&lt; create the print options frame &gt;&gt;</vh></v>
<v t="ekr.20071102163001.478"><vh>&lt;&lt; create the compare buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20071102163001.479"><vh>setIvarsFromWidgets</vh></v>
</v>
<v t="ekr.20071102163001.480"><vh>bringToFront</vh></v>
<v t="ekr.20071102163001.481"><vh>browser</vh></v>
<v t="ekr.20071102163001.482"><vh>compare_directories (entry)</vh></v>
<v t="ekr.20071102163001.483"><vh>filecmp</vh></v>
<v t="ekr.20071102163001.484"><vh>class brwsfilter</vh></v>
<v t="ekr.20071102163001.485"><vh>Event handlers...</vh>
<v t="ekr.20071102163001.486"><vh>onBrowse...</vh></v>
<v t="ekr.20071102163001.487"><vh>onClose</vh></v>
<v t="ekr.20071102163001.488"><vh>onCompare...</vh></v>
<v t="ekr.20071102163001.489"><vh>onPrintMatchedLines</vh></v>
</v>
<v t="ekr.20071102163001.490"><vh>utils</vh>
<v t="ekr.20071102163001.491"><vh>show</vh></v>
<v t="ekr.20071102163001.492"><vh>showMismatchTable</vh></v>
</v>
</v>
</v>
<v t="ekr.20071102163001.493"><vh>class baseTextWidget</vh>
<v t="ekr.20071102163001.494"><vh>Birth &amp; special methods (baseText)</vh></v>
<v t="ekr.20071102163001.495"><vh>baseTextWidget.onChar</vh></v>
<v t="ekr.20071102163001.496"><vh>Do-nothing</vh></v>
<v t="ekr.20071102163001.497"><vh>bindings (must be overridden in subclasses)</vh></v>
<v t="ekr.20071102163001.498"><vh>oops</vh></v>
<v t="ekr.20071102163001.499"><vh>Index conversion</vh>
<v t="ekr.20071102163001.500"><vh>w.toGuiIndex &amp; toPythonIndex</vh></v>
<v t="ekr.20071102163001.501"><vh>w.rowColToGuiIndex</vh></v>
</v>
<v t="ekr.20071102163001.502"><vh>Wrapper methods (widget-independent)</vh>
<v t="ekr.20071102163001.503"><vh>appendText</vh></v>
<v t="ekr.20071102163001.504"><vh>bind</vh></v>
<v t="ekr.20071102163001.505"><vh>clipboard_clear &amp; clipboard_append</vh></v>
<v t="ekr.20071102163001.506"><vh>delete</vh></v>
<v t="ekr.20071102163001.507"><vh>deleteTextSelection</vh></v>
<v t="ekr.20071102163001.508"><vh>event_generate (baseTextWidget)</vh></v>
<v t="ekr.20071102163001.509"><vh>flashCharacter (to do)</vh></v>
<v t="ekr.20071102163001.510"><vh>getFocus (baseText)</vh></v>
<v t="ekr.20071102163001.511"><vh>get</vh></v>
<v t="ekr.20071102163001.512"><vh>getAllText</vh></v>
<v t="ekr.20071102163001.513"><vh>getInsertPoint (baseText)</vh></v>
<v t="ekr.20071102163001.514"><vh>getName &amp; GetName</vh></v>
<v t="ekr.20071102163001.515"><vh>getSelectedText</vh></v>
<v t="ekr.20071102163001.516"><vh>getSelectionRange (baseText)</vh></v>
<v t="ekr.20071102163001.517"><vh>getYScrollPosition</vh></v>
<v t="ekr.20071102163001.518"><vh>getWidth</vh></v>
<v t="ekr.20071102163001.519"><vh>hasSelection</vh></v>
<v t="ekr.20071102163001.520"><vh>insert</vh></v>
<v t="ekr.20071102163001.521"><vh>indexIsVisible</vh></v>
<v t="ekr.20071102163001.522"><vh>replace</vh></v>
<v t="ekr.20071102163001.523"><vh>scrollLines</vh></v>
<v t="ekr.20071102163001.524"><vh>see &amp; seeInsertPoint</vh></v>
<v t="ekr.20071102163001.525"><vh>selectAllText</vh></v>
<v t="ekr.20071102163001.526"><vh>setAllText</vh></v>
<v t="ekr.20071102163001.527"><vh>setBackgroundColor &amp; SetBackgroundColour</vh></v>
<v t="ekr.20071102163001.528"><vh>setFocus (baseText)</vh></v>
<v t="ekr.20071102163001.529"><vh>setInsertPoint (baseText)</vh></v>
<v t="ekr.20071102163001.530"><vh>setSelectionRange (baseText)</vh></v>
<v t="ekr.20071102163001.531"><vh>setWidth</vh></v>
<v t="ekr.20071102163001.532"><vh>setYScrollPosition</vh></v>
<v t="ekr.20071102163001.533"><vh>tags (to-do)</vh>
<v t="ekr.20071102163001.534"><vh>mark_set (to be removed)</vh></v>
<v t="ekr.20071102163001.535"><vh>tag_add</vh></v>
<v t="ekr.20071102163001.536"><vh>tag_configure &amp; helper</vh>
<v t="ekr.20071102163001.537"><vh>tkColorToWxColor</vh></v>
</v>
<v t="ekr.20071102163001.538"><vh>tag_delete (NEW)</vh></v>
<v t="ekr.20071102163001.539"><vh>tag_names</vh></v>
<v t="ekr.20071102163001.540"><vh>tag_ranges</vh></v>
<v t="ekr.20071102163001.541"><vh>tag_remove</vh></v>
<v t="ekr.20071102163001.542"><vh>yview</vh></v>
</v>
<v t="ekr.20071102163001.543"><vh>xyToGui/PythonIndex</vh></v>
</v>
</v>
<v t="ekr.20071102163001.544"><vh>What I did</vh>
<v t="ekr.20071102163001.545"><vh>Changes to support jython</vh></v>
<v t="ekr.20071102163001.546"><vh>Rewrote iterators that use yield</vh>
<v t="ekr.20071102163001.547"><vh>c.iterators</vh>
<v t="ekr.20071102163001.548"><vh>c.all_positions_iter == allNodes_iter</vh>
<v t="ekr.20071102163001.549"><vh>__init__ &amp; __iter__ (c.all_positions_iter)</vh></v>
<v t="ekr.20071102163001.550"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.551"><vh>c.all_tnodes_iter</vh>
<v t="ekr.20071102163001.552"><vh>__init__ &amp; __iter__ (c.all_tnodes_iter)</vh></v>
<v t="ekr.20071102163001.553"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.554"><vh>c.all_unique_tnodes_iter</vh>
<v t="ekr.20071102163001.555"><vh>__init__ &amp; __iter__ (c.all_unique_tnodes_iter)</vh></v>
<v t="ekr.20071102163001.556"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.557"><vh>c.all_vnodes_iter</vh>
<v t="ekr.20071102163001.558"><vh>__init__ &amp; __iter__ (c.all_vnodes_iter)</vh></v>
<v t="ekr.20071102163001.559"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.560"><vh>c.all_unique_vnodes_iter</vh>
<v t="ekr.20071102163001.561"><vh>__init__ &amp; __iter__ (c.all_unique_nodes_iter)</vh></v>
<v t="ekr.20071102163001.562"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.563"><vh>@test c iters</vh>
<v t="ekr.20071102163001.564"><vh>&lt;&lt; coverage tests &gt;&gt;</vh></v>
<v t="ekr.20071102163001.565"><vh>&lt;&lt; duplicate tests &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071102163001.566"><vh>p.Iterators</vh>
<v t="ekr.20071102163001.567"><vh>p.tnodes_iter</vh>
<v t="ekr.20071102163001.568"><vh>__init__ &amp; __iter__ (p.tnodes_iter)</vh></v>
<v t="ekr.20071102163001.569"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.570"><vh>p.unique_tnodes_iter</vh>
<v t="ekr.20071102163001.571"><vh>__init__ &amp; __iter__ (p.unique_tnodes_iter)</vh></v>
<v t="ekr.20071102163001.572"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.573"><vh>p.vnodes_iter</vh>
<v t="ekr.20071102163001.574"><vh>__init__ &amp; __iter__ (p.tnodes_iter)</vh></v>
<v t="ekr.20071102163001.575"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.576"><vh>p.unique_vnodes_iter</vh>
<v t="ekr.20071102163001.577"><vh>__init__ &amp; __iter__ (p.unique_vnodes_iter)</vh></v>
<v t="ekr.20071102163001.578"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.579"><vh>p.subtree_iter</vh>
<v t="ekr.20071102163001.580"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20071102163001.581"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.582"><vh>p.children_iter</vh>
<v t="ekr.20071102163001.583"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20071102163001.584"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.585"><vh>p.parents_iter</vh>
<v t="ekr.20071102163001.586"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20071102163001.587"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.588"><vh>p.siblings_iter</vh>
<v t="ekr.20071102163001.589"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20071102163001.590"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20071102163001.591"><vh>Not converted yet</vh>
<v t="ekr.20071102163001.592"><vh>iterateKillBuffer</vh>
<v t="ekr.20071102163001.593"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20071102163001.594"><vh>next</vh></v>
</v>
<v t="ekr.20071102163001.595"><vh>&lt;&lt; define a new generator searchXR &gt;&gt; LATER</vh></v>
</v>
</v>
<v t="ekr.20071102163001.596"><vh>toUnicodeFileEncoding</vh></v>
</v>
<v t="ekr.20071102163001.597"><vh>Notes</vh></v>
<v t="ekr.20071102163001.598"><vh>debugging</vh>
<v t="ekr.20071102163001.599"><vh>Dumps</vh>
<v t="ekr.20071102163001.600"><vh>dump</vh></v>
<v t="ekr.20071102163001.601"><vh>es_dump</vh></v>
<v t="ekr.20071102163001.602"><vh>es_error</vh></v>
<v t="ekr.20071102163001.603"><vh>es_event_exception</vh></v>
<v t="ekr.20071102163001.604"><vh>es_exception &amp; test</vh>
<v t="ekr.20071102163001.605"><vh>@test g.es_exception</vh></v>
</v>
<v t="ekr.20071102163001.606"><vh>es_exception_type</vh></v>
<v t="ekr.20071102163001.607"><vh>getLastTracebackFileAndLineNumber</vh></v>
<v t="ekr.20071102163001.608"><vh>printBindings</vh></v>
<v t="ekr.20071102163001.609"><vh>printGlobals</vh></v>
<v t="ekr.20071102163001.610"><vh>g.printEntireTree</vh></v>
<v t="ekr.20071102163001.611"><vh>printLeoModules</vh></v>
</v>
<v t="ekr.20071102163001.3"><vh>callers &amp; _callerName</vh>
<v t="ekr.20071102163001.4"><vh>_callerName</vh></v>
</v>
</v>
<v t="ekr.20071102163001.612"><vh>startup code</vh>
<v t="ekr.20071102163001.613"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20071102163001.614"><vh>startJyleo (leo.py)</vh></v>
<v t="ekr.20071102163001.615"><vh>class leoSplash (java.lang.Runnable)</vh>
<v t="ekr.20071102163001.616"><vh>run (leoSplash)</vh></v>
<v t="ekr.20071102163001.617"><vh>utils</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20071211113237" a="TV"><vh>Leo 4.4.5 projects</vh>
<v t="ekr.20071211113302.2"><vh>Leo 4.4.5 b1</vh>
<v t="ekr.20071211113302.3"><vh>Distribution</vh>
<v t="ekr.20071211113302.4"><vh>Removed all references to pluginsManager.txt</vh>
<v t="ekr.20071211113302.5"><vh>loadHandlers &amp; helper</vh>
<v t="ekr.20071211113302.6"><vh>getEnabledFiles</vh></v>
</v>
</v>
</v>
<v t="ekr.20071211113302.7"><vh>Fixed bugs</vh>
<v t="ekr.20071211113302.8"><vh>Fixed hung windows</vh>
<v t="ekr.20071211113302.9"><vh> doCommand</vh></v>
<v t="ekr.20071211113302.10"><vh>tkGui file dialogs</vh>
<v t="ekr.20071211113302.11"><vh>runOpenFileDialog</vh></v>
<v t="ekr.20071211113302.12"><vh>runSaveFileDialog</vh></v>
</v>
</v>
<v t="ekr.20071211113302.13"><vh>Warn on resurrected (vampire) nodes</vh>
<v t="ekr.20071211113302.14"><vh>original post (long)</vh></v>
<v t="ekr.20071211113302.15"><vh>short summary</vh></v>
<v t="ekr.20071211113302.16"><vh>what I did</vh></v>
<v t="ekr.20071211113302.17"><vh>read</vh>
<v t="ekr.20071211113302.18"><vh>&lt;&lt; set fileName &gt;&gt;</vh></v>
<v t="ekr.20071211113302.19"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
<v t="ekr.20071211113302.20"><vh>&lt;&lt; advise user to delete all unvisited nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.21"><vh>createThinChild4</vh></v>
<v t="ekr.20071211113302.22"><vh>findChild4</vh></v>
</v>
<v t="ekr.20071211113302.23"><vh>Fixed new @auto bug (python)</vh>
<v t="ekr.20071211113302.24"><vh>Failing code</vh></v>
<v t="ekr.20071211113302.25" a="M"><vh>readOneAtAutoNode (atFile)</vh></v>
<v t="ekr.20071211113302.26"><vh>putClass &amp; helpers</vh>
<v t="ekr.20071211113302.27"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20071211113302.28"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20071211113302.29"><vh>getClassNodeRef</vh></v>
<v t="ekr.20071211113302.30"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20071211113302.31"><vh>scanHelper</vh></v>
<v t="ekr.20071211113302.32"><vh>skipDecls</vh></v>
</v>
<v t="ekr.20071211113302.33"><vh>Fixed new @auto bug: c++</vh>
<v t="ekr.20071211113302.34"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071211113302.31"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20071211113302.35"><vh>skipBlock</vh></v>
<v t="ekr.20071211113302.32"><vh>skipDecls</vh></v>
</v>
<v t="ekr.20071211113302.36"><vh>Fixed various @auto comparison problems</vh></v>
<v t="ekr.20071211113302.37"><vh>Fixed remaining relative path problems</vh>
<v t="ekr.20071211113302.38"><vh>Retain relative paths in recent files menu</vh>
<v t="ekr.20071211113302.39"><vh>Report</vh></v>
<v t="ekr.20071211113302.40"><vh>Report 2</vh></v>
<v t="ekr.20071211113302.41"><vh>What I did</vh></v>
<v t="ekr.20071211113302.42"><vh>open</vh>
<v t="ekr.20071211113302.43"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.44"><vh>g.openWithFileName</vh></v>
<v t="ekr.20071211113302.45"><vh>c.updateRecentFiles</vh></v>
<v t="ekr.20071211113302.46"><vh>run</vh>
<v t="ekr.20071211113302.47"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20071211113302.48"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.49"><vh>Found: newLeoCommanderAndFrame</vh>
<v t="ekr.20071211113302.50"><vh>app.newLeoCommanderAndFrame</vh>
<v t="ekr.20071211113302.51"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.52"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20071211113302.53"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20071211113302.54"><vh>createFrame (leoBridge)</vh></v>
<v t="ekr.20071211113302.55"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20071211113302.44"><vh>g.openWithFileName</vh></v>
<v t="ekr.20071211113302.56"><vh>new</vh></v>
<v t="ekr.20071211113302.57"><vh>readOutlineOnly</vh></v>
<v t="ekr.20071211113302.58"><vh>run-script</vh></v>
</v>
<v t="ekr.20071211113302.59"><vh>Found: openWithFileName</vh>
<v t="ekr.20071211113302.44"><vh>g.openWithFileName</vh></v>
<v t="ekr.20071211113302.53"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20071211113302.54"><vh>createFrame (leoBridge)</vh></v>
<v t="ekr.20071211113302.42"><vh>open</vh>
<v t="ekr.20071211113302.43"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.60"><vh>revert</vh></v>
<v t="ekr.20071211113302.61"><vh>openRecentFile</vh>
<v t="ekr.20071211113302.62"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.63"><vh>openLeoSettings and openMyLeoSettings</vh></v>
<v t="ekr.20071211113302.64"><vh>openLeoScripts</vh></v>
<v t="ekr.20071211113302.65"><vh>leoDocumentation</vh></v>
<v t="ekr.20071211113302.66"><vh>leoPlugins</vh></v>
<v t="ekr.20071211113302.67"><vh>open-outline-by-name</vh></v>
<v t="ekr.20071211113302.68"><vh>open</vh></v>
<v t="ekr.20071211113302.69"><vh>runLeoTest</vh></v>
<v t="ekr.20071211113302.70"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.71"><vh>clear-recent-files must write immediately</vh>
<v t="ekr.20071211113302.72"><vh>Reading and writing .leoRecentFiles.txt (g.app.config)</vh>
<v t="ekr.20071211113302.73"><vh>readRecentFiles &amp; helpers</vh>
<v t="ekr.20071211113302.74"><vh>createRecentFiles</vh></v>
<v t="ekr.20071211113302.75"><vh>readRecentFilesFile</vh></v>
</v>
<v t="ekr.20071211113302.76"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20071211113302.77"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
<v t="ekr.20071211113302.78"><vh>Recent Files submenu &amp; allies</vh>
<v t="ekr.20071211113302.79"><vh>clearRecentFiles</vh></v>
<v t="ekr.20071211113302.61"><vh>openRecentFile</vh>
<v t="ekr.20071211113302.62"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.45"><vh>c.updateRecentFiles</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20071211113302.80"><vh>Fixed windows registry problem</vh></v>
<v t="ekr.20071211113302.81"><vh>Fixed paste node as clone crasher</vh>
<v t="ekr.20071211113302.82"><vh>Report</vh></v>
<v t="ekr.20071211113302.83"><vh>getLeoOutlineFromClipboard &amp; helpers</vh>
<v t="ekr.20071211113302.84"><vh>finishPaste</vh>
<v t="ekr.20071211113302.85"><vh>&lt;&lt; reassign tnode indices &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.86"><vh>getLeoOutlineHelper</vh>
<v t="ekr.20071211113302.87"><vh>&lt;&lt; recreate tnodesDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.88"><vh>getClipboardHeader</vh></v>
</v>
</v>
<v t="ekr.20071211113302.89"><vh>Fixed new crasher involving directory scanning</vh>
<v t="ekr.20071211113302.90"><vh>Found: pluginsList (in leoPlugins.leo)</vh>
<v t="ekr.20071211113302.91"><vh>initAnyMarkup</vh></v>
<v t="ekr.20071211113302.92"><vh>colorWikiMarkup &amp; helper</vh>
<v t="ekr.20071211113302.93"><vh>doWikiText</vh>
<v t="ekr.20071211113302.94"><vh>&lt;&lt; set first to a tuple describing the first tag to be handled &gt;&gt;</vh></v>
<v t="ekr.20071211113302.95"><vh>&lt;&lt; handle the tag using n1,n2,delim1,delim2 &gt;&gt;</vh>
<v t="ekr.20071211113302.96"><vh>&lt;&lt; parse and handle color field &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20071211113302.97"><vh>scanPluginDirectives</vh></v>
</v>
</v>
<v t="ekr.20071211113302.98"><vh>Fixed hoist crasher</vh>
<v t="ekr.20071211113302.99"><vh>p.siblings_iter</vh>
<v t="ekr.20071211113302.100"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20071211113302.101"><vh>next</vh></v>
</v>
<v t="ekr.20071211113302.102"><vh>yoffset (tkTree)</vh></v>
</v>
<v t="ekr.20071211113302.103"><vh>Ignore unpickling problems in getUa</vh>
<v t="ekr.20071211113302.104"><vh>getUa (non-sax)</vh></v>
</v>
</v>
<v t="ekr.20071211113302.105"><vh>New features</vh>
<v t="ekr.20071211113302.106"><vh>Support directives in headlines</vh>
<v t="ekr.20071211113302.107"><vh>What I did</vh></v>
<v t="ekr.20071211113302.108"><vh>g.get_directives_dict</vh>
<v t="ekr.20071211113302.109"><vh>&lt;&lt; set theDict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20071211113302.110"><vh>&lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.111"><vh>g.computeRelativePath</vh></v>
<v t="ekr.20071211113302.112"><vh>Directive utils...</vh>
<v t="ekr.20071211113302.113"><vh>@language and @comment directives (leoUtils)</vh>
<v t="ekr.20071211113302.114"><vh>set_delims_from_language</vh></v>
<v t="ekr.20071211113302.115"><vh>set_delims_from_string</vh></v>
<v t="ekr.20071211113302.116"><vh>set_language</vh></v>
</v>
<v t="ekr.20071211113302.117"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20071211113302.111"><vh>g.computeRelativePath</vh></v>
<v t="ekr.20071211113302.118"><vh>g.findReference</vh></v>
<v t="ekr.20071211113302.108"><vh>g.get_directives_dict</vh>
<v t="ekr.20071211113302.109"><vh>&lt;&lt; set theDict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20071211113302.110"><vh>&lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.119"><vh>g.scanAtEncodingDirective</vh></v>
<v t="ekr.20071211113302.120"><vh>g.scanAtLineendingDirective</vh></v>
<v t="ekr.20071211113302.121"><vh>g.scanAtPagewidthDirective</vh></v>
<v t="ekr.20071211113302.122"><vh>g.scanAtRootOptions</vh>
<v t="ekr.20071211113302.123"><vh>&lt;&lt; scan another @root option &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.124"><vh>g.scanAtTabwidthDirective</vh></v>
<v t="ekr.20071211113302.125"><vh>g.scanColorDirectives</vh></v>
<v t="ekr.20071211113302.126"><vh>g.scanDirectives</vh>
<v t="ekr.20071211113302.127"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20071211113302.128"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20071211113302.129"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20071211113302.130"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20071211113302.131"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20071211113302.132"><vh>&lt;&lt; Test for @path &gt;&gt; (g.scanDirectives)</vh></v>
<v t="ekr.20071211113302.133"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20071211113302.134"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.135"><vh>g.scanForAtIgnore</vh></v>
<v t="ekr.20071211113302.136"><vh>g.scanForAtLanguage</vh></v>
<v t="ekr.20071211113302.137"><vh>g.scanForAtSettings</vh></v>
<v t="ekr.20071211113302.138"><vh>getOutputNewline</vh></v>
</v>
<v t="ekr.20071211113302.139"><vh>Found: get_directives_dict</vh>
<v t="ekr.20071211113302.140"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20071211113302.141"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20071211113302.142"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20071211113302.143"><vh>&lt;&lt; Test for @path &gt;&gt; (atFile.scanAllDirectives)</vh>
<v t="ekr.20071211113302.144"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.145"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20071211113302.146"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20071211113302.147"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20071211113302.148"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20071211113302.149"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20071211113302.150"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20071211113302.151"><vh>&lt;&lt; Set current directory &gt;&gt; (atFile.scanAllDirectives)</vh></v>
<v t="ekr.20071211113302.152"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.153"><vh>atFile.scanDefaultDirectory</vh>
<v t="ekr.20071211113302.154"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="ekr.20071211113302.155"><vh>&lt;&lt; handle @path &gt;&gt;</vh>
<v t="ekr.20071211113302.156"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.157"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.125"><vh>g.scanColorDirectives</vh></v>
<v t="ekr.20071211113302.126"><vh>g.scanDirectives</vh>
<v t="ekr.20071211113302.127"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20071211113302.128"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20071211113302.129"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20071211113302.130"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20071211113302.131"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20071211113302.132"><vh>&lt;&lt; Test for @path &gt;&gt; (g.scanDirectives)</vh></v>
<v t="ekr.20071211113302.133"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20071211113302.134"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.135"><vh>g.scanForAtIgnore</vh></v>
<v t="ekr.20071211113302.136"><vh>g.scanForAtLanguage</vh></v>
<v t="ekr.20071211113302.158"><vh>scanColorDirectives (leoColor)</vh>
<v t="ekr.20071211113302.159"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="ekr.20071211113302.160"><vh>&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.161"><vh>scanForTabWidth</vh>
<v t="ekr.20071211113302.162"><vh>&lt;&lt; set w and break on @tabwidth &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.163"><vh>tangle</vh></v>
<v t="ekr.20071211113302.164"><vh>tangle.scanAllDirectives</vh>
<v t="ekr.20071211113302.165"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
<v t="ekr.20071211113302.166"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20071211113302.167"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20071211113302.168"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20071211113302.169"><vh>&lt;&lt; Test for print modes directives &gt;&gt;</vh></v>
<v t="ekr.20071211113302.170"><vh>&lt;&lt; Test for @path &gt;&gt; (tangle.scanAllDirectives)</vh>
<v t="ekr.20071211113302.171"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.172"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20071211113302.173"><vh>&lt;&lt; Test for @root &gt;&gt;</vh></v>
<v t="ekr.20071211113302.174"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20071211113302.175"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20071211113302.176"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh>
<v t="ekr.20071211113302.177"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071211113302.178"><vh>tanglePass1</vh></v>
<v t="ekr.20071211113302.179"><vh>tangleTree (calls cleanup)</vh></v>
<v t="ekr.20071211113302.180"><vh>untangleTree</vh>
<v t="ekr.20071211113302.181"><vh>&lt;&lt; set end to the next root in the unit &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.182"><vh>useSyntaxColoring</vh></v>
</v>
<v t="ekr.20071211113302.183"><vh>selfInsertCommand, helpers</vh>
<v t="ekr.20071211113302.184"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20071211113302.185"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20071211113302.186"><vh>initBracketMatcher</vh></v>
<v t="ekr.20071211113302.187"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20071211113302.188"><vh>flashCharacter</vh></v>
<v t="ekr.20071211113302.189"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20071211113302.190"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20071211113302.191"><vh>updateTab</vh></v>
</v>
<v t="ekr.20071211113302.192"><vh>onHeadChanged</vh>
<v t="ekr.20071211113302.193"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.194"><vh>Will not refactor @path logic</vh>
<v t="ekr.20071211113302.151"><vh>&lt;&lt; Set current directory &gt;&gt; (atFile.scanAllDirectives)</vh></v>
<v t="ekr.20071211113302.143"><vh>&lt;&lt; Test for @path &gt;&gt; (atFile.scanAllDirectives)</vh>
<v t="ekr.20071211113302.144"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.132"><vh>&lt;&lt; Test for @path &gt;&gt; (g.scanDirectives)</vh></v>
<v t="ekr.20071211113302.170"><vh>&lt;&lt; Test for @path &gt;&gt; (tangle.scanAllDirectives)</vh>
<v t="ekr.20071211113302.171"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071211113302.195"><vh>New unit tests</vh></v>
</v>
<v t="ekr.20071211113302.196"><vh>Added @bool at_auto_warns_about_leading_whitespace setting</vh></v>
<v t="ekr.20071211113302.197"><vh>Added command: toggle-collapse_nodes_during_finds</vh>
<v t="ekr.20071211113302.198"><vh>class searchCommandsClass</vh>
<v t="ekr.20071211113302.199"><vh> ctor (searchCommandsClass)</vh></v>
<v t="ekr.20071211113302.200"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20071211113302.201"><vh>Top-level methods</vh>
<v t="ekr.20071211113302.202"><vh>openFindTab</vh></v>
<v t="ekr.20071211113302.203"><vh>Find Tab commands</vh></v>
<v t="ekr.20071211113302.204"><vh>getHandler</vh></v>
<v t="ekr.20071211113302.205"><vh>Find options wrappers</vh></v>
<v t="ekr.20071211113302.206"><vh>Find wrappers</vh></v>
<v t="ekr.20071211113302.207"><vh>findAgain</vh></v>
</v>
<v t="ekr.20071211113302.208"><vh>incremental search...</vh>
<v t="ekr.20071211113302.209"><vh>iSearchBackspace</vh></v>
<v t="ekr.20071211113302.210"><vh>startIncremental</vh></v>
<v t="ekr.20071211113302.211"><vh>iSearchStateHandler</vh></v>
<v t="ekr.20071211113302.212"><vh>scolorizer LATER</vh></v>
<v t="ekr.20071211113302.213"><vh>iSearchHelper</vh></v>
<v t="ekr.20071211113302.214"><vh>endSearch</vh></v>
</v>
</v>
</v>
<v t="ekr.20071211113302.215"><vh>Added 3 new sort-lines commands</vh>
<v t="ekr.20071211113302.216"><vh>sortLines commands</vh></v>
</v>
<v t="ekr.20071211113302.217"><vh>Added support for @bool diagnose-aspell-installation</vh>
<v t="ekr.20071211113302.218"><vh>Spell classes</vh>
<v t="ekr.20071211113302.219"><vh>class spellCommandsClass</vh>
<v t="ekr.20071211113302.220"><vh>ctor</vh></v>
<v t="ekr.20071211113302.221"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20071211113302.222"><vh>openSpellTab</vh>
<v t="ekr.20071211113302.223"><vh>commands...</vh></v>
</v>
</v>
<v t="ekr.20071211113302.224"><vh>class spellTabHandler (leoFind.leoFind)</vh>
<v t="ekr.20071211113302.225"><vh>Birth &amp; death</vh>
<v t="ekr.20071211113302.226"><vh>spellTabHandler.__init__</vh></v>
<v t="ekr.20071211113302.227"><vh>init_aspell</vh></v>
<v t="ekr.20071211113302.228"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20071211113302.229"><vh>Commands</vh>
<v t="ekr.20071211113302.230"><vh>add</vh></v>
<v t="ekr.20071211113302.231"><vh>change (spellTab)</vh></v>
<v t="ekr.20071211113302.232"><vh>find &amp; helpers</vh>
<v t="ekr.20071211113302.233"><vh>findNextMisspelledWord</vh>
<v t="ekr.20071211113302.234"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.235"><vh>findNextWord (tkSpell)</vh></v>
</v>
<v t="ekr.20071211113302.236"><vh>hide</vh></v>
<v t="ekr.20071211113302.237"><vh>ignore</vh></v>
</v>
</v>
<v t="ekr.20071211113302.238"><vh>class AspellClass</vh>
<v t="ekr.20071211113302.239"><vh>Birth &amp; death</vh>
<v t="ekr.20071211113302.240"><vh>__init__</vh></v>
<v t="ekr.20071211113302.241"><vh>getAspell</vh></v>
<v t="ekr.20071211113302.242"><vh>getAspellWithCtypes</vh>
<v t="ekr.20071211113302.243"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.244"><vh>report</vh></v>
</v>
<v t="ekr.20071211113302.245"><vh>processWord</vh></v>
<v t="ekr.20071211113302.246"><vh>suggestions</vh></v>
<v t="ekr.20071211113302.247"><vh>updateDictionary</vh></v>
</v>
</v>
</v>
<v t="ekr.20071211113302.248"><vh>Added @bool warn_when_plugins_fail_to_load setting</vh>
<v t="ekr.20071211113302.249"><vh>loadOnePlugin</vh></v>
<v t="ekr.20071211113302.250"><vh>import wrappers</vh>
<v t="ekr.20071211113302.251"><vh>g.cantImport</vh></v>
<v t="ekr.20071211113302.252"><vh>g.importModule</vh></v>
<v t="ekr.20071211113302.253"><vh>g.importExtension &amp; helpers</vh>
<v t="ekr.20071211113302.254"><vh>cantImportDialog &amp; helpers</vh>
<v t="ekr.20071211113302.255"><vh>createDialogFrame</vh></v>
<v t="ekr.20071211113302.256"><vh>createDialogButtons</vh></v>
<v t="ekr.20071211113302.257"><vh>center</vh></v>
<v t="ekr.20071211113302.258"><vh>get_window_info</vh></v>
</v>
</v>
<v t="ekr.20071211113302.259"><vh>g.importFromPath</vh></v>
</v>
</v>
<v t="ekr.20071211113302.260"><vh>Moved all unit tests to unitTest.leo</vh></v>
<v t="ekr.20071211113302.261"><vh>vim plugin now supports @bool vim_plugin_opens_url_nodes setting</vh></v>
<v t="ekr.20071211113302.262"><vh>Added Cmd:Icons menu and commands</vh>
<v t="ekr.20071211113302.263"><vh>g.makePathRelativeTo</vh></v>
<v t="ekr.20071211113302.264"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20071211113302.265"><vh>drawUserIcons &amp; helper</vh>
<v t="ekr.20071211113302.266"><vh>drawUserIcon</vh>
<v t="ekr.20071211113302.267"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20071211113302.268"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20071211113302.269"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20071211113302.270"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071211113302.271"><vh>icons...</vh>
<v t="ekr.20071211113302.272"><vh>deleteAllIcons</vh></v>
<v t="ekr.20071211113302.273"><vh>deleteFirstIcon</vh></v>
<v t="ekr.20071211113302.274"><vh>deleteIconByName</vh></v>
<v t="ekr.20071211113302.275"><vh>deleteLastIcon</vh></v>
<v t="ekr.20071211113302.276"><vh>deleteNodeIcons</vh></v>
<v t="ekr.20071211113302.277"><vh>insertIcon &amp; helper</vh>
<v t="ekr.20071211113302.278"><vh>getImage</vh></v>
</v>
</v>
</v>
<v t="ekr.20071211113302.279"><vh>Added @rst-preformat</vh></v>
<v t="ekr.20071211113302.280"><vh>Installed small icon set from Tango library</vh></v>
</v>
</v>
<v t="ekr.20071211113302.281"><vh>Leo 4.4.5 b2</vh>
<v t="ekr.20071211113302.282"><vh>Fixed bugs</vh>
<v t="ekr.20071211113302.283"><vh>Fixed two crashers in the @noref logic</vh></v>
<v t="ekr.20071211113302.284"><vh>Fixed crasher in regularizeWhitespace</vh></v>
<v t="ekr.20071211113302.285"><vh>Fixed paste-node-as-clone</vh>
<v t="ekr.20071211113302.286"><vh>report</vh></v>
<v t="ekr.20071211113302.287"><vh>c.iterators</vh>
<v t="ekr.20071211113302.288"><vh>c.all_positions_iter == allNodes_iter</vh>
<v t="ekr.20071211113302.289"><vh>__init__ &amp; __iter__ (c.all_positions_iter)</vh></v>
<v t="ekr.20071211113302.290"><vh>next</vh></v>
</v>
<v t="ekr.20071211113302.291"><vh>c.all_tnodes_iter</vh>
<v t="ekr.20071211113302.292"><vh>__init__ &amp; __iter__ (c.all_tnodes_iter)</vh></v>
<v t="ekr.20071211113302.293"><vh>next</vh></v>
</v>
<v t="ekr.20071211113302.294"><vh>c.all_unique_tnodes_iter</vh>
<v t="ekr.20071211113302.295"><vh>__init__ &amp; __iter__ (c.all_unique_tnodes_iter)</vh></v>
<v t="ekr.20071211113302.296"><vh>next</vh></v>
</v>
<v t="ekr.20071211113302.297"><vh>c.all_vnodes_iter</vh>
<v t="ekr.20071211113302.298"><vh>__init__ &amp; __iter__ (c.all_vnodes_iter)</vh></v>
<v t="ekr.20071211113302.299"><vh>next</vh></v>
</v>
<v t="ekr.20071211113302.300"><vh>c.all_unique_vnodes_iter</vh>
<v t="ekr.20071211113302.301"><vh>__init__ &amp; __iter__ (c.all_unique_nodes_iter)</vh></v>
<v t="ekr.20071211113302.302"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20071211113302.303"><vh>Cut &amp; Paste Outlines</vh>
<v t="ekr.20071211113302.304"><vh>cutOutline</vh></v>
<v t="ekr.20071211113302.305"><vh>copyOutline</vh></v>
<v t="ekr.20071211113302.306"><vh>pasteOutline</vh>
<v t="ekr.20071211113302.307"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20071211113302.308"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.309"><vh>pasteOutlineRetainingClones</vh></v>
</v>
</v>
<v t="ekr.20071211113302.310"><vh>Fixed threading colorizer hang with perl</vh></v>
<v t="ekr.20071211113302.311"><vh>Fixed C++ importer crash</vh></v>
<v t="ekr.20071211113302.312"><vh>Reorganized leoImport.py</vh></v>
<v t="ekr.20071211113302.313"><vh>Fixed crasher when tangling @root</vh>
<v t="ekr.20071211113302.164"><vh>tangle.scanAllDirectives</vh>
<v t="ekr.20071211113302.165"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
<v t="ekr.20071211113302.166"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20071211113302.167"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20071211113302.168"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20071211113302.169"><vh>&lt;&lt; Test for print modes directives &gt;&gt;</vh></v>
<v t="ekr.20071211113302.170"><vh>&lt;&lt; Test for @path &gt;&gt; (tangle.scanAllDirectives)</vh>
<v t="ekr.20071211113302.171"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.172"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20071211113302.173"><vh>&lt;&lt; Test for @root &gt;&gt;</vh></v>
<v t="ekr.20071211113302.174"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20071211113302.175"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20071211113302.176"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh>
<v t="ekr.20071211113302.177"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071211113302.314"><vh>setRootFromText</vh></v>
<v t="ekr.20071211113302.122"><vh>g.scanAtRootOptions</vh>
<v t="ekr.20071211113302.123"><vh>&lt;&lt; scan another @root option &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.315"><vh>at-File test code (leoTest.py)</vh>
<v t="ekr.20071211113302.316"><vh>&lt;&lt; dump result and expected &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.163"><vh>tangle</vh></v>
<v t="ekr.20071211113302.179"><vh>tangleTree (calls cleanup)</vh></v>
<v t="ekr.20071211113302.317"><vh>tangle.put_all_roots</vh>
<v t="ekr.20071211113302.318"><vh>&lt;&lt;Get root specific attributes&gt;&gt;</vh></v>
<v t="ekr.20071211113302.319"><vh>&lt;&lt;Put @first lines&gt;&gt;</vh></v>
<v t="ekr.20071211113302.320"><vh>&lt;&lt;Write a banner at the start of the output file&gt;&gt;</vh></v>
<v t="ekr.20071211113302.321"><vh>&lt;&lt; Erase the temporary file &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071211113302.322"><vh>Fixed command lockout problem</vh>
<v t="ekr.20071211113302.9"><vh> doCommand</vh></v>
<v t="ekr.20071211113302.323"><vh>c.executeScript &amp; helpers</vh>
<v t="ekr.20071211113302.324"><vh>redirectScriptOutput</vh></v>
<v t="ekr.20071211113302.325"><vh>unredirectScriptOutput</vh></v>
<v t="ekr.20071211113302.326"><vh>writeScriptFile</vh></v>
</v>
<v t="ekr.20071211113302.327"><vh>endCommand</vh></v>
<v t="ekr.20071211113302.328"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20071211113302.329"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20071211113302.330"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20071211113302.331"><vh>callStateFunction</vh></v>
<v t="ekr.20071211113302.332"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20071211113302.333"><vh>handleDefaultChar</vh></v>
</v>
</v>
<v t="ekr.20071211113302.334"><vh>Improved @auto code</vh>
<v t="ekr.20071211113302.335"><vh>checkTrialWrite</vh></v>
<v t="ekr.20071211113302.336"><vh>compareHelper</vh></v>
<v t="ekr.20071211113302.337"><vh>underindentedComment &amp; underindentedLine</vh></v>
</v>
<v t="ekr.20071211113302.338"><vh>Simplified perl colorizer and added progress checks</vh></v>
<v t="ekr.20071211113302.339"><vh>Fixed crasher in aspell logic</vh>
<v t="ekr.20071211113302.340"><vh>Report</vh></v>
<v t="ekr.20071211113302.341"><vh>What I did</vh></v>
</v>
<v t="ekr.20071211113302.342"><vh>Fixed problem with decorators</vh>
<v t="ekr.20071211113302.343"><vh>Report</vh></v>
<v t="ekr.20071211113302.344"><vh>Changed code</vh>
<v t="ekr.20071211113302.345"><vh>find_line_start</vh></v>
<v t="ekr.20071211113302.32"><vh>skipDecls</vh></v>
<v t="ekr.20071211113302.346"><vh>startsHelper</vh></v>
<v t="ekr.20071211113302.347"><vh>adjustDefStart (python)</vh></v>
</v>
</v>
<v t="ekr.20071211113302.348"><vh>Fixed @auto bug</vh>
<v t="ekr.20071211113302.349"><vh>write</vh>
<v t="ekr.20071211113302.350"><vh>&lt;&lt; set at.targetFileName &gt;&gt;</vh></v>
<v t="ekr.20071211113302.351"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.352"><vh>writeOneAtAutoNode &amp; helpers</vh>
<v t="ekr.20071211113302.353"><vh>shouldWriteAtAutoNode</vh></v>
<v t="ekr.20071211113302.354"><vh>isSignificantAtAutoTree</vh></v>
</v>
<v t="ekr.20071211113302.355"><vh>writeOpenFile</vh></v>
<v t="ekr.20071211113302.356"><vh>warnAboutOrpanAndIgnoredNodes</vh></v>
</v>
<v t="ekr.20071211113302.357"><vh>Fixed chapter bug</vh>
<v t="ekr.20071211113302.358"><vh>goToNextClone</vh></v>
<v t="ekr.20071211113302.359"><vh> treeSelectHelper</vh></v>
<v t="ekr.20071211113302.360"><vh> treeFocusHelper</vh></v>
<v t="ekr.20071211113302.360"><vh> treeFocusHelper</vh></v>
<v t="ekr.20071211113302.361"><vh>c.selectPosition</vh></v>
<v t="ekr.20071211113302.362"><vh>cc.selectChapterForPosition</vh></v>
<v t="ekr.20071211113302.363"><vh>cc.findChapterNameForPosition</vh></v>
<v t="ekr.20071211113302.364"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20071211113302.365"><vh>treeSelectHelper</vh>
<v t="ekr.20071211113302.366"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20071211113302.367"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20071211113302.368"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20071211113302.369"><vh>findEditWidget (tkTree)</vh></v>
<v t="ekr.20071211113302.370"><vh>p.key</vh></v>
</v>
<v t="ekr.20071211113302.371"><vh>Fixed bug in g.openWithFileName</vh>
<v t="ekr.20071211113302.44"><vh>g.openWithFileName</vh></v>
</v>
</v>
<v t="ekr.20071211113302.372"><vh>New features</vh>
<v t="ekr.20071211113302.373"><vh>test.leo now contains a node showing all icons in the Icons/Tango directory</vh></v>
<v t="ekr.20071211113302.374"><vh>Improved error reporting for aspell on Linux</vh>
<v t="ekr.20071211113302.241"><vh>getAspell</vh></v>
<v t="ekr.20071211113302.218"><vh>Spell classes</vh>
<v t="ekr.20071211113302.219"><vh>class spellCommandsClass</vh>
<v t="ekr.20071211113302.220"><vh>ctor</vh></v>
<v t="ekr.20071211113302.221"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20071211113302.222"><vh>openSpellTab</vh>
<v t="ekr.20071211113302.223"><vh>commands...</vh></v>
</v>
</v>
<v t="ekr.20071211113302.224"><vh>class spellTabHandler (leoFind.leoFind)</vh>
<v t="ekr.20071211113302.225"><vh>Birth &amp; death</vh>
<v t="ekr.20071211113302.226"><vh>spellTabHandler.__init__</vh></v>
<v t="ekr.20071211113302.227"><vh>init_aspell</vh></v>
<v t="ekr.20071211113302.228"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20071211113302.229"><vh>Commands</vh>
<v t="ekr.20071211113302.230"><vh>add</vh></v>
<v t="ekr.20071211113302.231"><vh>change (spellTab)</vh></v>
<v t="ekr.20071211113302.232"><vh>find &amp; helpers</vh>
<v t="ekr.20071211113302.233"><vh>findNextMisspelledWord</vh>
<v t="ekr.20071211113302.234"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.235"><vh>findNextWord (tkSpell)</vh></v>
</v>
<v t="ekr.20071211113302.236"><vh>hide</vh></v>
<v t="ekr.20071211113302.237"><vh>ignore</vh></v>
</v>
</v>
<v t="ekr.20071211113302.238"><vh>class AspellClass</vh>
<v t="ekr.20071211113302.239"><vh>Birth &amp; death</vh>
<v t="ekr.20071211113302.240"><vh>__init__</vh></v>
<v t="ekr.20071211113302.241"><vh>getAspell</vh></v>
<v t="ekr.20071211113302.242"><vh>getAspellWithCtypes</vh>
<v t="ekr.20071211113302.243"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
<v t="ekr.20071211113302.244"><vh>report</vh></v>
</v>
<v t="ekr.20071211113302.245"><vh>processWord</vh></v>
<v t="ekr.20071211113302.246"><vh>suggestions</vh></v>
<v t="ekr.20071211113302.247"><vh>updateDictionary</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20061021144014"></t>
<t tx="ekr.20061021144014.1"></t>
<t tx="ekr.20061021144014.2">leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\tigris-cvs\leo\config\leoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\config\myLeoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\test\unitTest.leo
FAILED (failures=1)
UnicodeDecodeError Exception in Tk callback
  Function: &lt;function masterBindKeyCallback at 0x018BD970&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x02B0B5F8&gt;,)
  Event type: KeyPress (type num: 2)
  
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2118, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 3133, in masterKeyHandler
    return k.getArg(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2755, in getArg
    if handler: handler(event)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7191, in searchWithPresentOptions
    self.generalSearchHelper(k.arg)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7066, in generalSearchHelper
    self.finder.findNextCommand()
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7676, in findNextCommand
    self.findNext()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 684, in findNext
    pos, newpos = self.findNextMatch()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 711, in findNextMatch
    pos, newpos = self.search()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 746, in search
    regexp=self.pattern_match,word=self.whole_word)
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 780, in searchHelper
    pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 856, in plainHelper
    elif self.matchWord(s,k,pattern):
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 871, in matchWord
    s[i-1] not in self.word_chars or
UnicodeDecodeError: 'ascii' codec can't decode byte 0x83 in position 52: ordinal not in range(128)

================================================
  Event contents:
    char:
    delta: 13
    height: ??
    keycode: 13
    keysym: Return
    keysym_num: 65293
    num: ??
    serial: 49425
    state: 0
    time: 17007655
    type: 2
    widget: .21619056.21619656.24867464.minibuffer
    width: ??
    x: 526
    x_root: 782
    y: -648
    y_root: 240

</t>
<t tx="ekr.20061021144014.3">self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated (in the subclass by update_ivars) just before doing any find.
@c

&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = None # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos &gt;= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
self.selStart = self.selEnd = None # For selection-only searches.
</t>
<t tx="ekr.20061021144014.4">if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.selection_only = None
    self.wrap = None
    self.whole_word = None
</t>
<t tx="ekr.20061021144014.5">def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.w ; c = k.c
        if word:
            i = w.index('insert')
            s = g.app.gui.getAllText(w)
            i = g.app.gui.toPythonIndex(s,w,i)
            j = s.find('\n',i) # Limit to this line.
            s = s[:j]
            while i &lt; len(s):
                if i == -1: break
                ok = g.match_word(s,i,word) and (i == 0 or not g.isWordChar(s[i-1]))
                # g.trace(ok,repr(word),i,repr(s))
                if ok:
                    i1 = g.app.gui.toGuiIndex(s,w,i)
                    i2 = g.app.gui.toGuiIndex(s,w,i+len(word))
                    g.app.gui.setSelectionRange(w,i1,i2)
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()

</t>
<t tx="ekr.20061021144014.6"># Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # Start the word at the first letter.
        i = 0
        while i &lt; len(line) and not g.isWordChar1(line[i]):
            i += 1
        if i &lt; len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j &lt; len(line) and g.isWordChar(line[j]):
                j += 1
            word = line[i:j]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert","&gt;=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
                
    __pychecker__ = '--no-implicitreturns' # This is not really an implicit return.</t>
<t tx="ekr.20061021144014.7">@nocolor

FAIL: @test k.inverseCommandsDict is inverse of c.commandsDict
AssertionError: cl not in inverseCommandsDict.values()

I just hacked the unit test not to complain about abbreviations.
Another solution would be to allow the values of k.inverseCommandsDict to be lists.</t>
<t tx="ekr.20061021144014.8">def initAbbrev (self):
    
    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d.keys():
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

def initOneAbbrev (self,commandName,key):
    k = self ; c = k.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.es_print('bad abbrev: %s: unknown command name: %s' %
                (key,commandName),color='blue')
</t>
<t tx="ekr.20061021144014.9">@

The logic in cycleAllFocus is now much cleaner.
The cycle focus commands work in the minibuffer *only* if not tab-completion is done.
I think this is the old, horrible problems with Pmw focus: it's a very small nit.</t>
<t tx="ekr.20061021144014.10">def cycleFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline, body and log panes.'''

    c = self.c ;  w = event.widget
   
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas
    panes = [body,log,tree]

    if w in panes:
        i = panes.index(w) + 1
        if i &gt;= len(panes): i = 0
        pane = panes[i]
    else:
        pane = body
    
    # Warning: traces mess up the focus
    # print g.app.gui.widget_name(w),g.app.gui.widget_name(pane)
    
    # This works from the minibuffer *only* if there is no typing completion.
    c.widgetWantsFocusNow(pane)
    c.k.newMinibufferWidget = pane</t>
<t tx="ekr.20061021144014.11">editWidgetCount = 0
logWidgetCount = 0

def cycleAllFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline,
    all body editors and all tabs in the log pane.'''

    c = self.c ; k = c.k
    w = event and event.widget # Does **not** require a text widget.

    pane = None ; w_name = g.app.gui.widget_name
    trace = False
    if trace: print (
        '---- w',w_name(w),id(w),
        '#tabs',c.frame.log.numberOfVisibleTabs(),
        'bodyCtrl',w_name(c.frame.body.bodyCtrl),id(c.frame.body.bodyCtrl))

    # w may not be the present body widget, so test its name, not its id.
    if w_name(w).startswith('body'):
        n = c.frame.body.numberOfEditors
        # g.trace(self.editWidgetCount,n)
        if n &gt; 1:
            self.editWidgetCount += 1
            if self.editWidgetCount == 1:
                pane = c.frame.body.bodyCtrl
            elif self.editWidgetCount &gt; n:
                self.editWidgetCount = 0 ; self.logWidgetCount = 1
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            else:
                c.frame.body.cycleEditorFocus(event) ; pane = None
        else:
            self.editWidgetCount = 0 ; self.logWidgetCount = 1
            c.frame.log.selectTab('Log')
            pane = c.frame.log.logCtrl
    elif w_name(w).startswith('log'):
        n = c.frame.log.numberOfVisibleTabs()
        if n &gt; 1:
            self.logWidgetCount += 1
            if self.logWidgetCount == 1:
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            elif self.logWidgetCount &gt; n:
                self.logWidgetCount = 0
                pane = c.frame.tree.canvas
            else:
                c.frame.log.cycleTabFocus()
                pane = c.frame.log.logCtrl
        else:
            self.logWidgetCount = 0
            pane = c.frame.tree.canvas
    else:
        pane = c.frame.body.bodyCtrl
        self.editWidgetCount = 1 ; self.logWidgetCount = 0
        
    if trace: print 'old: %10s new: %10s' % (w_name(w),w_name(pane))

    if pane:
        k.newMinibufferWidget = pane
        c.widgetWantsFocusNow(pane)</t>
<t tx="ekr.20061021144014.12">def selectTab (self,tabName,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName,wrap=wrap)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0: # Absolutely do not do this here!  It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)
    return tabFrame
</t>
<t tx="ekr.20061021144014.13">def cycleEditorFocus (self,event=None):
    
    '''Cycle keyboard focus between the body text editors.'''
    
    c = self.c ; d = self.editorWidgets ; w = self.bodyCtrl
    values = d.values()
    if len(values) &gt; 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.selectEditor(w2)
        self.bodyCtrl = self.frame.bodyCtrl = w2
        # print '***',g.app.gui.widget_name(w2),id(w2)

    return 'break'
</t>
<t tx="ekr.20061021144014.14">def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)
    values = d.values()
    if self.numberOfVisibleTabs() &gt; 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return </t>
<t tx="ekr.20061021144014.15">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    
    # print 'callAltXFunc',func

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.16">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # print 'endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers()
            k.newMinibufferWidget = None
</t>
<t tx="ekr.20061021144014.17">trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        print '%4d' % (c.trace_focus_count),c.widget_name(w),g.callers(8)
</t>
<t tx="ekr.20061021144014.18">def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if trace: print \
        'requested',c.widget_name(c.requestedFocusWidget),\
        'present',c.widget_name(c.hasFocusWidget)
    
    if c.hasFocusWidget and (
        not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget):
        if trace: print 'no change.',c.widget_name(w)
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        # This is not an error: it can arise because of a call to k.invalidateFocus.
        if trace: print '*'*20,'oops: moving to body pane.'
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler
</t>
<t tx="ekr.20061021144014.19">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''

    &lt;&lt; define vars &gt;&gt;

    if keysym in special_keys:
        return None

    &lt;&lt; do key traces &gt;&gt;

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        &lt;&lt; handle mode bindings &gt;&gt;
        
    &lt;&lt; handle per-pane bindings &gt;&gt;
    &lt;&lt; handle keys without bindings &gt;&gt;
</t>
<t tx="ekr.20061021144014.20">k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
    
trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
</t>
<t tx="ekr.20061021144014.21">self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace(
        # 'keysym',repr(event.keysym or ''),
        'stroke',repr(stroke),
        'state',state,
        'unboundKeyAction',k.unboundKeyAction)
</t>
<t tx="ekr.20061021144014.22"># First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
</t>
<t tx="ekr.20061021144014.23">key_states = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in key_states and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(g.app.gui.isTextWidget(w),w_name,key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
</t>
<t tx="ekr.20061021144014.24">if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in ('insert','overwrite'):
    # insert/overwrite normal character.  &lt;Return&gt; is *not* a normal character.
    if trace: g.trace('plain key in insert mode',stroke)
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(event.char) &gt; 1:
    # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
    
elif event and event.keysym.find('Escape') != -1:
    # Never insert escape characters.
    return 'break'

else:
    # g.trace(stroke,event.char,event.keysym)
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
</t>
<t tx="ekr.20061021144014.25">def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
</t>
<t tx="ekr.20061021144014.26">def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w,force=False):
    
    c = self
    
    if force: # New in Leo 4.4.2: safer.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
        c.traceFocus(w)
    else: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
</t>
<t tx="ekr.20061021144014.27">@

@command whaterver @key Alt-1 didn't work
Actually, no Alt-n keys worked for n in (1,2,3,4,5) in any context.

Happily, the problem was a confusion about what Alt-1 means.
Apparently it means Alt-Button-1 rather than Alt-Key-1.

The solution was to insert an explicit Key- prefix in k.tkBindingFromStroke.
I also made a minor mod to printBindings.</t>
<t tx="ekr.20061021144014.28">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    f = c.commandsDict.get(commandName)
    verbose = verbose and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))
    
    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None
  
    if stroke:
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok:
             g.es_print('@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
    elif verbose:
        g.es_print('@command: %s' % (commandName),color='blue')
                
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in d.values():
            for key in d.keys():
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break</t>
<t tx="ekr.20061021144014.29">def makeMasterGuiBinding (self,stroke,w=None):
    
    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''
    
    k = self ; c = k.c ; f = c.frame
   
    bindStroke = k.tkbindingFromStroke(stroke)
    # g.trace('stroke',stroke,'bindStroke',bindStroke)
    
    if w:
        widgets = [w]
    else:
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        widgets=(c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)
    
    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke)
        return k.masterKeyHandler(event,stroke=stroke)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                w.bind(bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding %s to %s' % (
                    bindStroke, c.widget_name(w)), color = 'blue')
                if g.app.unitTesting: raise
</t>
<t tx="ekr.20061021144014.30">def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = g.stripBrackets(stroke)
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    # g.trace('&lt;%s&gt;' % stroke)
    return '&lt;%s&gt;' % stroke
</t>
<t tx="ekr.20061021144014.31">def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)
            
    # Print keys by type:
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        g.es('%s %s' % (sep, prefix),tabName=tabName)
        self.printBindingsHelper(data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    g.es('%s %s' % (sep, 'Plain Keys',),tabName=tabName)
    self.printBindingsHelper(data,n1,n2,prefix=None)
    state = k.unboundKeyAction 
    k.showStateAndMode()
</t>
<t tx="ekr.20061021144014.32">def printBindingsHelper (self,data,n1,n2,prefix):
        
    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.
    
    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) &gt;  1]
        # The list of all other items.
                
    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(lambda x,y: cmp(x[1],y[1]))
        for s1,s2,s3 in data:
            g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
</t>
<t tx="ekr.20061021144014.33">def prettyPrintKey (self,stroke,brief=False):
    
    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.tkBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    return g.choose(brief,s,'&lt;%s&gt;' % s)
</t>
<t tx="ekr.20061021144014.34">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3956836

p.clone(p) -&gt; p.clone() in the big reorg.
</t>
<t tx="ekr.20061021144014.35">http://sourceforge.net/forum/message.php?msg_id=3958333
By: mstarzyk

I get the following exception while opening a leo file:

Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoGlobals.py", line 2441, in doHook
    return f(tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 91, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 69, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 48, in callTagHandler
    result = handler(tag,keywords)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 193, in onCreate
    sc.createAllButtons()
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 249,
in createAllButtons
    self.createAtButtonButton(p)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 316,
in createAtButtonButton
    b = self.createAtButtonIconButton(p,buttonText,statusLine,shortcut)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 588,
in createAtButtonIconButton
    b = self.createIconButton(text=buttonText,statusLine=statusLine,bg=bg)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 431,
in createIconButton
    self.createBalloon(b,statusLine)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 459,
in createBalloon
    balloon.bind(w,label)
  File "C:\Program Files\Leo\extensions\Pmw\Pmw_1_2\lib\PmwBalloon.py", line
76, in bind
    enterId = widget.bind('&lt;Enter&gt;',
AttributeError: 'NoneType' object has no attribute 'bind'

@nocolor

This is strange: I never have a problem with it.
The fix: don't call balloon.bind if balloon is None.</t>
<t tx="ekr.20061021144014.36"></t>
<t tx="ekr.20061021144014.37">@nocolor

Do *not* bother with trying to preserve the focus.
Instead, the 'end of script' message should just go to whatever log pane is on top.

@color</t>
<t tx="ekr.20061021144014.38">def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    &lt;&lt; redirect output &gt;&gt;
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                # g.trace(script)
                exec script in d
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally: # New in 4.3 beta 2: unredirect output last.
        &lt;&lt; unredirect output &gt;&gt;
</t>
<t tx="ekr.20061021144014.39">if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
</t>
<t tx="ekr.20061021144014.40">if c.exists and c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
</t>
<t tx="ekr.20061021144014.41">@ The warning was disabled due to a programming error (not not)
Enabling this found two errors: view-lossage (missing comma) and
find-with-present-options --&gt; search-with-present-options.</t>
<t tx="ekr.20061021144014.42">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        if sys.platform == 'darwin':
            &lt;&lt; clear accelerator if it is a plain key &gt;&gt;
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
</t>
<t tx="ekr.20061021144014.43">if type(data) == type(''):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&amp;','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data
            
        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data</t>
<t tx="ekr.20061021144014.44"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
</t>
<t tx="ekr.20061021144014.45">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
</t>
<t tx="ekr.20061021144014.46">for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
</t>
<t tx="ekr.20061021144014.47">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3957980
By: dcbbcd

This was a major effort.

What I did:
    
- Defined g.isWordChar in terms of ch.isalnum()

- Replace almost all instances of string.letters and string.digits by calls to
  ch.isalnum(), ch.isalpha(), ch.isdigit(), etc.
  
- Similarly, replaced word_chars.

- The new code uses string literals only for

a) small constants like '+-' and
b) constants in a very limited context, as in the input to regexp.

To do: look for string.printable

@color</t>
<t tx="ekr.20061021144014.48"># most uses of these should be converted to g.isWordChar.</t>
<t tx="ekr.20061021144014.49">def insertNormalChar (self,ch,keysym):
    
    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = g.app.gui.getSelectedText(w) + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = g.app.gui.getSelectedText(w)
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = g.app.gui.getSelectedText(w)
        if keysym == 'parenleft':
            # Similar to chain logic.
            obj = self.object
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.object)
                self.object = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
</t>
<t tx="ekr.20061021144014.50">def doOp (self):
    
    val = self.val
    outer = self.lineParenLevel &lt;= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','&lt;=','&gt;=','&lt;','&gt;','&lt;&gt;','*','**','+','&amp;','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '&gt;&gt;':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '&lt;&lt;':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and not g.isWordChar(prev[-1]):
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
</t>
<t tx="ekr.20061021144014.51">def appendToRegister (self,event):
    
    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('append-to-reg')
    
    if state == 0:
        k.setLabelBlue('Append to register: ',protect=True)
        k.setState('append-to-reg',1,self.appendToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = val + w.get('sel.first','sel.last')
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.52">def prependToRegister (self,event):
    
    '''Prompt for a register name and prepend the selected text to the register's contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('prepend-to-reg')
    
    if state == 0:
        k.setLabelBlue('Prepend to register: ',protect=True)
        k.setState('prepend-to-reg',1,self.prependToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = w.get('sel.first','sel.last') + val
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.53">def copyRectangleToRegister (self,event):
    
    '''Prompt for a register name and append the rectangle defined by selected
    text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-rect-to-reg')

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        k.commandName = 'copy-rectangle-to-register'
        k.setLabelBlue('Copy Rectangle To Register: ',protect=True)
        k.setState('copy-rect-to-reg',1,self.copyRectangleToRegister)
    elif self.checkBodySelection('No rectangle selected'):
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            w = self.w
            c.widgetWantsFocusNow(w)
            r1, r2, r3, r4 = self.getRectanglePoints(w)
            rect = []
            while r1 &lt;= r3:
                txt = w.get('%s.%s' % (r1,r2),'%s.%s' % (r1,r4))
                rect.append(txt)
                r1 = r1 + 1
            self.registers [key] = rect
            k.setLabelGrey('Register %s = %s' % (key,repr(rect)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.54">def copyToRegister (self,event):
    
    '''Prompt for a register name and append the selected text to the register's contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('copy-to-reg')
    
    if state == 0:
        k.commandName = 'copy-to-register'
        k.setLabelBlue('Copy to register: ',protect=True)
        k.setState('copy-to-reg',1,self.copyToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                key = event.keysym.lower()
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                try:
                    val = w.get('sel.first','sel.last')
                except Exception:
                    g.es_exception()
                    val = ''
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.55">def incrementRegister (self,event):
    
    '''Prompt for a register name and increment its value if it has a numeric value.'''
    
    c = self.c ; k = self.k ; state = k.getState('increment-reg')
    
    if state == 0:
        k.setLabelBlue('Increment register: ',protect=True)
        k.setState('increment-reg',1,self.incrementRegister)
    else:
        k.clearState()
        if self._checkIfRectangle(event):
            pass # Error message is in the label.
        elif event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key,0)
            try:
                val = str(int(val)+1)
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            except ValueError:
                k.setLabelGrey("Can't increment register %s = %s" % (key,val))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.56">def insertRegister (self,event):
    
    '''Prompt for a register name and and insert the value of another register into its contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('insert-reg')
    
    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ',protect=True)
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.rectangleCommands.yankRectangle(val)
                else:
                    w.insert('insert',val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.57">def jumpToRegister (self,event):
    
    '''Prompt for a register name and set the insert point to the value in its register.'''

    c = self.c ; k = self.k ; state = k.getState('jump-to-reg')

    if state == 0:
        k.setLabelBlue('Jump to register: ',protect=True)
        k.setState('jump-to-reg',1,self.jumpToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            if self._checkIfRectangle(event): return
            key = event.keysym.lower()
            val = self.registers.get(key)
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            if val:
                try:
                    w.mark_set('insert',val)
                    k.setLabelGrey('At %s' % repr(val))
                except Exception:
                    k.setLabelGrey('Register %s is not a valid location' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.58">@
C-u number C-x r n reg
    Store number into register reg (number-to-register).
C-u number C-x r + reg
    Increment the number in register reg by number (increment-register).
C-x r g reg
    Insert the number from register reg into the buffer.
@c

def numberToRegister (self,event):
    
    k = self.k ; state = k.getState('number-to-reg')
    
    if state == 0:
        k.commandName = 'number-to-register'
        k.setLabelBlue('Number to register: ',protect=True)
        k.setState('number-to-reg',1,self.numberToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            # self.registers[event.keysym.lower()] = str(0)
            k.setLabelGrey('number-to-register not ready yet.')
        else:
            k.setLabelGrey('Register must be a letter')
</t>
<t tx="ekr.20061021144014.59">def pointToRegister (self,event):
    
    '''Prompt for a register name and put a value indicating the insert point in the register.'''
    
    c = self.c ; k = self.k ; state = k.getState('point-to-reg')
    
    if state == 0:
        k.commandName = 'point-to-register'
        k.setLabelBlue('Point to register: ',protect=True)
        k.setState('point-to-reg',1,self.pointToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = w.index('insert')
            self.registers[key] = val
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.60">def viewRegister (self,event):
    
    '''Prompt for a register name and print its contents.'''

    c = self.c ; k = self.k ; state = k.getState('view-reg')
    
    if state == 0:
        k.commandName = 'view-register'
        k.setLabelBlue('View register: ',protect=True)
        k.setState('view-reg',1,self.viewRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key)
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.61">aList = [g.choose(ch.isalnum(),ch,'-') for ch in buttonText]

buttonCommandName = ''.join(aList)
buttonCommandName = buttonCommandName.replace('--','-')
buttonCommandName = 'press-%s-button' % buttonCommandName.lower()

# This will use any shortcut defined in an @shortcuts node.
k.registerCommand(buttonCommandName,None,executeScriptCallback,pane='button',verbose=False)
</t>
<t tx="ekr.20061021144014.62">def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    __pychecker__ = '--no-argsused' # Ignore all unused arguments here.
        
    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.
    
    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.
    
    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.
    
    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''
    
    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
</t>
<t tx="ekr.20061021144014.63">def createRecentFilesMenuItems (self):
    
    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")
    
    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
    
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table)
    
    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def recentFilesCallback (event=None,c=c,name=name):
            __pychecker__ = '--no-argsused' # event not used, but must be present.
            c.openRecentFile(name)
        accel_ch = (string.digits + string.letters.upper()) # Not a unicode problem.
        label = "%s %s" % (accel_ch[i-2],g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=recentFilesCallback,underline=0)
        i += 1
</t>
<t tx="ekr.20061021144014.64"></t>
<t tx="ekr.20061021144014.65">def zapToCharacter (self,event):
    
    '''Kill characters from the insertion point to a given character.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        c = k.c
        ch = event and event.char
        k.resetLabel()
        k.clearState()
        if len(event.char) != 0 and not ch.isspace():
            i = w.search(ch,'insert',stopindex='end')
            if i != -1:
                s = w.get('insert','%s' % i)
                self.addToKillBuffer(s)
                w.delete('insert','%s' % i)
</t>
<t tx="ekr.20061021144014.66">i = g.skip_ws(s,i) ; j = i
while i &lt; len(s) and s[i].isdigit():
    i += 1

if j == i:
    at.readError("Implicit child index in @+node")
    childIndex = 0
else:
    childIndex = int(s[j:i])

if g.match(s,i,':'):
    i += 1 # Skip the ":".
else:
    at.readError("Bad child index in @+node")
</t>
<t tx="ekr.20061021144014.67">while i &lt; len(s) and s[i] != ':' and not g.is_nl(s,i):
    if g.match(s,i,"C="):
        # set cloneIndex from the C=nnn, field
        i += 2 ; j = i
        while i &lt; len(s) and s[i].isdigit():
            i += 1
        if j &lt; i:
            cloneIndex = int(s[j:i])
    else: i += 1 # Ignore unknown status bits.

if g.match(s,i,":"):
    i += 1
else:
    at.readError("Bad attribute field in @+node")
</t>
<t tx="ekr.20061021144014.68">new_df = g.match(s,i,version_tag)

if new_df:
    # Pre Leo 4.4.1: Skip to the next minus sign or end-of-line.
    # Leo 4.4.1 +:   Skip to next minus sign, end-of-line, or non numeric character.
    # This is required to handle trailing comment delims properly.
    i += len(version_tag)
    j = i
    while i &lt; len(s) and (s[i] == '.' or s[i].isdigit()):
        i += 1

    if j &lt; i:
        pass
    else:
        valid = False
</t>
<t tx="ekr.20061021144014.69">def skip_id(self,s,i,chars=None):

    n = len(s)
    chars = chars and g.toUnicode(chars,encoding='ascii') or u''
    while i &lt; n and (g.isWordChar(s[i]) or s[i] in chars):
            i += 1
    return i
</t>
<t tx="ekr.20061021144014.70">if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i &gt; -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i &gt; 0:
            i += 1
            j = s.find(':',i)
            if j &gt; 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i &gt; -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i &lt; len(s) and colons &lt; 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 &lt; len(s) and s[i+1].isdigit():
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
</t>
<t tx="ekr.20061021144014.71">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # Not a unicode problem.
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.
    
    # Settings...
    self.autocompleteBrackets   = c.config.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = c.config.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = c.config.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = c.config.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = c.config.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = c.config.getBool('flash-matching-brackets')
    self.smartAutoIndent        = c.config.getBool('smart_auto_indent')
    
    self.initBracketMatcher(c)
</t>
<t tx="ekr.20061021144014.72">def getDouble (self):

    self.skipWs()
    i = self.fileIndex ; buf = self.fileBuffer
    floatChars = 'eE.+-'
    n = len(buf)
    while i &lt; n and (buf[i].isdigit() or buf[i] in floatChars):
        i += 1
    if i == self.fileIndex:
        raise BadLeoFile("expecting float constant")
    val = float(buf[self.fileIndex:i])
    self.fileIndex = i
    return val
</t>
<t tx="ekr.20061021144014.73">def getLong (self):

    self.skipWs() # guarantees at least one more character.
    i = self.fileIndex
    if self.fileBuffer[i] == u'-':
        i += 1
    n = len(self.fileBuffer)
    while i &lt; n and self.fileBuffer[i].isdigit():
        i += 1
    if i == self.fileIndex:
        raise BadLeoFile("expecting int constant")
    val = int(self.fileBuffer[self.fileIndex:i])
    self.fileIndex = i
    return val
</t>
<t tx="ekr.20061021144014.74">def is_c_id(ch):

    return g.isWordChar(ch)

</t>
<t tx="ekr.20061021144014.75">def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s.find(pattern,i,i+j) != i:
        return False
    if i+j &gt;= len(s):
        return True
    ch = s[i+j]
    return not g.isWordChar(ch)
</t>
<t tx="ekr.20061021144014.76">def skip_c_id(s,i):

    n = len(s)
    while i &lt; n and g.isWordChar(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20061021144014.77">def skip_id(s,i,chars=None):

    chars = chars and g.toUnicode(chars,encoding='ascii') or ''
    n = len(s)
    while i &lt; n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i</t>
<t tx="ekr.20061021144014.78">def skip_long(s,i):
    
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i &gt;= n or (not s[i].isdigit() and s[i] not in u'+-'):
        return i, None
    j = i
    if s[i] in u'+-': # Allow sign before the first digit
        i +=1
    while i &lt; n and s[i].isdigit():
        i += 1
    try: # There may be no digits.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
</t>
<t tx="ekr.20061021144014.79">def skipElispId (self,s,i):

    n = len(s)
    while i &lt; n and g.isWordChar(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20061021144014.80">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    # g.trace(last,last2)
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
            
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)
</t>
<t tx="ekr.20061021144014.81">def universalDispatcher (self,event):
    
    '''Handle accumulation of universal argument.'''
    
    &lt;&lt; about repeat counts &gt;&gt;

    k = self ; state = k.getState('u-arg')

    if state == 0:
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        stroke = k.stroke ; keysym = event.keysym
            # Stroke is &lt;Key&gt; for plain keys, &lt;Control-u&gt; (k.universalArgKey)
        # g.trace(state,stroke)
        if stroke == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif stroke == '&lt;Key&gt;' and (keysym.isdigit() or keysym == u'-'):
            k.updateLabel(event)
        elif stroke == '&lt;Key&gt;' and keysym in (
            'Alt_L','Alt_R','Shift_L','Shift_R','Control_L','Control_R'):
             # g.trace('stroke',k.stroke,'keysym',keysym)
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            # g.trace('stroke',k.stroke,'keysym',keysym)
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            # g.trace('val',repr(val),'n',n,'k.repeatCount',k.repeatCount)
            k.clearState()
            k.executeNTimes(event,n)
            k.clearState()
            k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '&lt;Control-x&gt;':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return 'break'
</t>
<t tx="ekr.20061021144014.82">@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
</t>
<t tx="ekr.20061021144014.83">def executeNTimes (self,event,n):
    
    __pychecker__ = '--no-local' # z is used just for a repeat count.
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'&lt;%s&gt;' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('&lt;Key&gt;',keycode=event.keycode,keysym=event.keysym)
</t>
<t tx="ekr.20061021144014.84">def doControlU (self,event,stroke):
    
    k = self ; c = k.c

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if event.keysym == 'parenleft': # Execute the macro.

        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
</t>
<t tx="ekr.20061021144014.85"># This function scans a positive integer.
# returns (i,val), where val == -1 if there is an error.

def scan_short_val (self,s,i):
    
    
    if i &gt;= len(s) or not s[i].isdigit():
        return i, -1
    j = i
    while i &lt; len(s) and s[i].isdigit():
        i += 1
    val = int(s[j:i])
    # g.trace(s[j:i],val)
    return i, val</t>
<t tx="ekr.20061021144014.86">def canonicalizeMenuName (self,name):
    
    return ''.join([ch for ch in name.lower() if ch.isalnum()])
    
def canonicalizeTranslatedMenuName (self,name):
    
    return ''.join([ch for ch in name.lower() if ch not in u'&amp; \t\n\r'])

</t>
<t tx="ekr.20061021144014.87">def computeOldStyleShortcutKey (self,s):
    
    '''Compute the old-style shortcut key for @shortcuts entries.'''
    
    return ''.join([ch for ch in s.strip().lower() if ch.isalnum()])
</t>
<t tx="ekr.20061021144014.88">e = self.id_entry
s = e.get().strip()
i = 0 ; ok = True
while i &lt; len(s):
    ch = s[i]
    if not ch.isalnum():
        e.delete(str(i))
        s = e.get()
        ok = False
    else:
        i += 1
if not ok: return
</t>
<t tx="ekr.20061021144014.89">e = self.number_entry
s = e.get().strip()

i = 0
while i &lt; len(s):
    ch = s[i]
    if not ch.isdigit():
        e.delete(str(i))
        s = e.get()
    else:
        i += 1
</t>
<t tx="ekr.20061021144014.90"></t>
<t tx="ekr.20061021144014.91">def doNormalState (self,s,i):
    
    __pychecker__ = 'maxlines=500'

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&amp;&lt;&gt;' and self.language=="html") or
        (ch == '$' and self.language=="rapidq") or
        (self.language == 'forth' and ch in "`~!@#$%^&amp;*()_+-={}|[];':\",./&lt;&gt;?")
    ):
        &lt;&lt; handle possible keyword &gt;&gt;
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        &lt;&lt; handle at keyword &gt;&gt;
    elif g.match(s,i,self.single_comment_start):
        &lt;&lt; handle single-line comment &gt;&gt;
    elif g.match(s,i,self.block_comment_start):
        &lt;&lt; start block comment &gt;&gt;
    elif ch == '%' and self.language=="cweb":
        &lt;&lt; handle latex line &gt;&gt;
    elif self.language=="latex":
        &lt;&lt; handle latex normal character &gt;&gt;
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        &lt;&lt; handle string &gt;&gt;
    elif ch == '#' and self.has_pp_directives:
        &lt;&lt; handle C preprocessor line &gt;&gt;
    elif self.language == "php" and (g.match(s,i,"&lt;") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        &lt;&lt; handle special php keywords &gt;&gt;
    elif ch == ' ':
        &lt;&lt; handle blank &gt;&gt;
    elif ch == '\t':
        &lt;&lt; handle tab &gt;&gt;
    else:
        &lt;&lt; handle normal character &gt;&gt;

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress &lt; i)
    return i,state
</t>
<t tx="ekr.20061021144014.92"></t>
<t tx="ekr.20061021144014.93">if self.language == "latex":
    &lt;&lt; handle possible latex keyword &gt;&gt;
elif self.language == "html":
    &lt;&lt; handle possible html keyword &gt;&gt;
elif self.language == "forth":
    &lt;&lt; handle possible forth keyword &gt;&gt;
else:
    &lt;&lt; handle general keyword &gt;&gt;
i = j
</t>
<t tx="ekr.20061021144014.94">if g.match(s,i,"\\"):
    if i + 1 &lt; len(s) and s[i+1] in self.latex_special_keyword_characters:
        j = i + 2 # A special 2-character LaTex keyword.
    else:
        j = self.skip_id(s,i+1)
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
</t>
<t tx="ekr.20061021144014.95">if g.match(s,i,"&lt;!---") or g.match(s,i,"&lt;!--"):
    if g.match(s,i,"&lt;!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"&lt;"):
    if g.match(s,i,"&lt;/"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&amp;"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/&gt;"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,"&gt;"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
</t>
<t tx="ekr.20061021144014.96">j = self.skip_id(s,i+1,chars="`~!@#$%^&amp;*()-_=+[]{};:'\\\",./&lt;&gt;?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True
    
    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)
</t>
<t tx="ekr.20061021144014.97">if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2
</t>
<t tx="ekr.20061021144014.98">if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@&lt;"):
        &lt;&lt; handle cweb ref or def &gt;&gt;
    else:
        word = self.getCwebWord(s,i)
        if word:
            &lt;&lt; Handle cweb control word &gt;&gt;
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)
</t>
<t tx="ekr.20061021144014.99">self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@&gt;=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@&gt;",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
</t>
<t tx="ekr.20061021144014.100"># Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@&lt;","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@&gt;"
    j = s.find("@&gt;",i)
    if j &gt; -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2
</t>
<t tx="ekr.20061021144014.101"># print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i&gt;0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j
</t>
<t tx="ekr.20061021144014.102">k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"
</t>
<t tx="ekr.20061021144014.103">self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
</t>
<t tx="ekr.20061021144014.104"></t>
<t tx="ekr.20061021144014.105">if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.106"></t>
<t tx="ekr.20061021144014.107"># g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
</t>
<t tx="ekr.20061021144014.108"># 10/17/02: recognize comments in preprocessor lines.
j = i
while i &lt; len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)
</t>
<t tx="ekr.20061021144014.109">if g.match(s.lower(),i,"&lt;?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?&gt;"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1
</t>
<t tx="ekr.20061021144014.110">if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.111">if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.112"># self.tag("normal",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.113">def getCwebWord (self,s,i):
    
    # g.trace(g.get_line(s,i))
    if not g.match(s,i,"@"):
        return None
    
    ch1 = ch2 = word = None
    if i + 1 &lt; len(s): ch1 = s[i+1]
    if i + 2 &lt; len(s): ch2 = s[i+2]

    if g.match(s,i,"@**"):
        word = "@**"
    elif not ch1:
        word = "@"
    elif not ch2:
        word = s[i:i+2]
    elif (
        (ch1 in string.ascii_letters and not ch2 in string.ascii_letters) or # single-letter control code
        ch1 not in string.ascii_letters # non-letter control code
    ):
        word = s[i:i+2]

    # if word: g.trace(word)
        
    return word
</t>
<t tx="ekr.20061021144014.114">def init_trace(args,echo=1):

    t = app.trace_list
    args = g.get_Sherlock_args(args)

    for arg in args:
        if arg[0] in string.ascii_letters: prefix = '+'
        else: prefix = arg[0] ; arg = arg[1:]
        
        if prefix == '?':
            print "trace list:", t
        elif prefix == '+' and not arg in t:
            t.append(string.lower(arg))
            if echo:
                print "enabling:", arg
        elif prefix == '-' and arg in t:
            t.remove(string.lower(arg))
            if echo:
                print "disabling:", arg
        else:
            print "ignoring:", prefix + arg
</t>
<t tx="ekr.20061021144014.115">def sanitize_filename(s):

    """Prepares string s to be a valid file name:
    
    - substitute '_' whitespace and characters used special path characters.
    - eliminate all other non-alphabetic characters.
    - strip leading and trailing whitespace.
    - return at most 128 characters."""

    result = ""
    for ch in s.strip():
        if ch in string.ascii_letters:
            result += ch
        elif ch in string.whitespace: # Translate whitespace.
            result += '_'
        elif ch in ('.','\\','/',':'): # Translate special path characters.
            result += '_'
    while 1:
        n = len(result)
        result = result.replace('__','_')
        if len(result) == n:
            break
    result = result.strip()
    return result [:128]
</t>
<t tx="ekr.20061021144014.116">i = g.skip_ws(s,i)
if g.match(s,i,"@*") or g.match(s,i,"@ "): kind = at_doc
elif g.match(s,i,"@&lt;"): i, kind, end = self.skip_section_name(s,i)
elif g.match(s,i,"@@"): kind = at_at
elif g.match_word(s,i,"@c") or g.match_word(s,i,"@p"): kind = at_code
elif i &lt; len(s) and s[i] == '@':
    if   i + 1 &gt;= len(s): kind = at_doc
    elif i + 1 &lt; len(s) and s[i+1] not in string.ascii_letters:
        kind = at_web
    else: kind = at_other # Set kind later
else: kind = plain_line
</t>
<t tx="ekr.20061021144014.117">self.state_dict = {
    "blockComment" : self.continueBlockComment,
    "doubleString" : self.continueDoubleString, # 1/25/03
    "nocolor"      : self.continueNocolor,
    "normal"       : self.doNormalState,
    "singleString" : self.continueSingleString,  # 1/25/03
    "string3s"     : self.continueSinglePythonString,
    "string3d"     : self.continueDoublePythonString,
    "doc"          : self.continueDocPart,
    "unknown"      : self.doNormalState, # 8/25/05
}
    
# Eventually all entries in these dicts will be entered dynamically
# under the control of the XML description of the present language.

if 0: # not ready yet.

    self.dict1 = { # 1-character patterns.
        '"' : self.doString,
        "'" : self.doString,
        '@' : self.doPossibleLeoKeyword,
        ' ' : self.doBlank,
        '\t': self.doTab }

    self.dict2 = {} # 2-character patterns
    
    # Searching this list might be very slow!
    mutli_list = [] # Multiple character patterns.
    
    # Enter single-character patterns...
    if self.has_pp_directives:
        dict1 ["#"] = self.doPPDirective
                
    for ch in string.ascii_letters:
        dict1 [ch] = self.doPossibleKeyword
    dict1 ['_'] = self.doPossibleKeyword
    
    if self.language == "latex":
        dict1 ['\\'] = self.doPossibleKeyword
        
    if self.language == "php":
        dict1 ['&lt;'] = self.doSpecialPHPKeyword
        dict1 ['?'] = self.doSpecialPHPKeyword
    
    # Enter potentially multi-character patterns.  (or should this be just 2-character patterns)
    if self.language == "cweb":
        dict2 ["@("] = self.doPossibleSectionRefOrDef
    else:
        dict2 ["&lt;&lt;"] = self.doPossibleSectionRefOrDef
        
    if self.single_comment_start:
        n = len(self.single_comment_start)
        if n == 1:
            dict1 [self.single_comment_start] = self.doSingleCommentLine
        elif n == 2:
            dict2 [self.single_comment_start] = self.doSingleCommentLine
        else:
            mutli_list.append((self.single_comment_start,self.doSingleCommentLine),)
    
    if self.block_comment_start:
        n = len(self.block_comment_start)
        if n == 1:
            dict1 [self.block_comment_start] = self.doBlockComment
        elif n == 2:
            ddict2 [self.block_comment_start] = self.doBlockComment
        else:
            mutli_list.append((self.block_comment_start,self.doBlockComment),)
</t>
<t tx="ekr.20061021144014.118">def definePatterns (self):
    
    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))
    
    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars </t>
<t tx="ekr.20061021144014.119">def autoCompleterStateHandler (self,event):
    
    c = self.c ; k = self.k
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = event and event.keysym
    ch = event and event.char or ''
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in ('space','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == 'period':
        self.chain()
    elif keysym == 'question':
        self.info()
    elif keysym == 'exclam':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.object) == types.DictType:
            self.membersList = self.object.keys()
        elif type(self.object) in (types.ListType,types.TupleType):
            self.membersList = self.object
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
</t>
<t tx="ekr.20061021144014.120">def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))
        
    # Rewritten 6/8/2005.
    if i+1 &gt;= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if s[i+1] not in string.ascii_letters:
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective
    
    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
</t>
<t tx="ekr.20061021144014.121">def test_directiveKind4 (self):
    
    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))
</t>
<t tx="ekr.20061021144014.122">def test_isPlainKey (self):
    
    import string
    
    k = c.k # self is a dummy argument
    
    for ch in (string.printable):
        if ch == '\n': continue # A special case.
        assert k.isPlainKey(ch), 'wrong: not plain: %s' % (ch)
        
    special = (
        'Return', # A special case.
        'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
        'KP_F1','KP_F2','KP_F3','KP_F4',
        'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
        'Home','Left','Linefeed','Next','Num_Lock',
        'PageDn','PageUp','Pause','Prior','Right','Up',
        'Sys_Req',
    )

    for ch in special:
        assert not k.isPlainKey(ch), 'wrong: is plain: %s' % (ch)
</t>
<t tx="ekr.20061021144014.123">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3960993

I happen to select Plugins-&gt;Scripting and the "About Scripting" window opened...a
huge, long, "about" window with no scroll-bars that was taller than my screen.

Can the "About" info be put into a resizable window (with scroll-bars) instead,
with a reasonable initial size?

Kam-Yung

</t>
<t tx="ekr.20061021144014.124">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3961623
By: vpe

Leo periodically prints 'Key state: Insert' message in the status area even
though I never change insert mode. It does not seem to be necessary and it destroys
UNL info. I get this message when I open new file, insert new node, type (,
type . in Python nodes, and probably on other events.

To get rid of it, I added one line to showStateAndMode(self) in
Code--&gt;@thin leoKeys.py--&gt;class keyHandlerClass--&gt;Input
State--&gt;showStateAndMode

....if hasattr(frame,'clearStatusLine'):
........if not state.capitalize()=='Insert': # &lt;---- added
............frame.clearStatusLine()
............put = frame.putStatusLine
............put('Key state: ',color='blue')
............put('%s' % state.capitalize())

There should be a more intelligent solution. 


Also, command set-overwrite-state works but generates a Tk error.

specs:
Leo 4.4.2 beta 2, build  1.69 , October 9, 2006
Python 2.5.0, Tk 8.4.12, Pmw 1.2
Windows 5, 0, 2195, 2, Service Pack 4
</t>
<t tx="ekr.20061021144014.125">@nocolor

No longer needed now that the datenodes plugins gets settings from cvs.</t>
<t tx="ekr.20061021144014.126">@ To force a recolor there must be a non-None undoType passed to kill.
or an explicit call to self.c.frame.body.forceFullRecolor() before calling endCommand.
</t>
<t tx="ekr.20061021144014.127">class killBufferCommandsClass (baseEditCommandsClass):
    
    '''A class to manage the kill buffer.'''

    @others
</t>
<t tx="ekr.20061021144014.128">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.reset = False

def finishCreate (self):
    
    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k
    
    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
</t>
<t tx="ekr.20061021144014.129">def getPublicCommands (self):
    
    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
</t>
<t tx="ekr.20061021144014.130">def addToKillBuffer (self,text):
    
    killKeys =(
        '&lt;Control-k&gt;', '&lt;Control-w&gt;',
        '&lt;Alt-d&gt;', '&lt;Alt-Delete', '&lt;Alt-z&gt;', '&lt;Delete&gt;',
        '&lt;Control-Alt-w&gt;')

    k = self.k
    self.reset = True

    # g.trace(repr(text))

    if self.killBuffer and k.stroke in killKeys:
        self.killBuffer [0] = self.killBuffer [0] + text
    else:
        self.killBuffer.insert(0,text)
</t>
<t tx="ekr.20061021144014.131">def backwardKillSentence (self,event):
    
    '''Kill the previous sentence.'''
    
    w = self.editWidget(event)
    if not w: return

    i = w.search('.','insert',backwards=True,stopindex='1.0')

    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='backward-kill-sentence')
</t>
<t tx="ekr.20061021144014.132">def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

</t>
<t tx="ekr.20061021144014.133">def clearKillRing (self,event=None):
    
    '''Clear the kill ring.'''
    
    self.killBuffer = []
</t>
<t tx="ekr.20061021144014.134">def getClipboard (self,w):

    try:
        ctxt = w.selection_get(selection='CLIPBOARD')
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except: pass

    return None
</t>
<t tx="ekr.20061021144014.135">def iterateKillBuffer (self):

    while 1:
        if self.killBuffer:
            self.last_clipboard = None
            for z in self.killBuffer:
                if self.reset:
                    self.reset = False
                    break
                yield z
</t>
<t tx="ekr.20061021144014.136">def kill (self,event,frm,to,undoType=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    w.delete(frm,to)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    self.kill(event,'insert linestart','insert lineend+1c',undoType='kill-line')</t>
<t tx="ekr.20061021144014.137">def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)
    
def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return
    
    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    # self.removeRKeys(w)
</t>
<t tx="ekr.20061021144014.138">def killSentence (self,event):
    
    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return

    i  = w.search('.','insert',stopindex='end')
    if i:
        self.beginCommand(undoType='kill-sentence')
        i2 = w.search('.','insert',backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='kill-sentence')
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20061021144014.139">def killWs (self,event,undoType=None):
    
    ws = ''
    w = self.editWidget(event)
    if not w: return

    while 1:
        s = w.get('insert')
        if s in (' ','\t'):
            w.delete('insert')
            ws = ws + s
        else:
            break
   
    if ws:
        if undoType: self.beginCommand(undoType=undoType)
        self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20061021144014.140">def yank (self,event):
    
    '''Insert the next entry in the kill ring at the insert point.'''

    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert')
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        self.beginCommand(undoType='yank')
        self.reset = True
        s = clip_text or self.kbiterator.next()
        w.tag_delete('kb')
        w.insert('insert',s,('kb'))
        w.mark_set('insert',i)
        c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20061021144014.141">def yankPop (self,event):
    
    '''Replaces the just-yanked kill buffer with the contents of the previous kill buffer.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert') ; t, t1 = i.split('.')
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        if clip_text: s = clip_text
        else:         s = self.kbiterator.next()
        t1 = str(int(t1)+len(s))
        r = w.tag_ranges('kb')
        if r and r [0] == i:
            w.delete(r[0],r[-1])
        w.tag_delete('kb')
        w.insert('insert',s,('kb'))
        w.mark_set('insert',i)
</t>
<t tx="ekr.20061021144014.142"></t>
<t tx="ekr.20061021144014.143">def beginCommand (self,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''
    
    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
</t>
<t tx="ekr.20061021144014.144"># New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  g.app.gui.getTextSelection(w)
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
    else:
        self.undoData = None

    return w
</t>
<t tx="ekr.20061021144014.145"># New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):
    
    '''Do the common processing at the end of each command.'''
    
    c = self.c ; b = self.undoData ; k = self.k

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)
        
    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()
    
    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
</t>
<t tx="ekr.20061021144014.146"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    trace = self.trace_onBodyChanged
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = g.app.gui.getAllText(bodyCtrl) # Note: getAllText converts to unicode.
    # g.trace('newText',repr(newText))
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    changed = oldText != newText
    if trace:
        g.trace(repr(ch),'changed:',changed)
        g.trace('newText:',repr(newText))
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        &lt;&lt; recolor the body &gt;&gt;
        if not c.changed: c.setChanged(True)
        self.updateEditors()
        &lt;&lt; redraw the screen if necessary &gt;&gt;
</t>
<t tx="ekr.20061021144014.147">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
</t>
<t tx="ekr.20061021144014.148">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
</t>
<t tx="ekr.20061021144014.149"># Did not restore selection after indent/undent commands.
</t>
<t tx="ekr.20061021144014.150"></t>
<t tx="ekr.20061021144014.151">def convertAllBlanks (self,event=None):
    
    '''Convert all blanks to tabs in the selected outline.'''
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    try: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    finally:
        c.endUpdate(count &gt; 0)
</t>
<t tx="ekr.20061021144014.152">def convertAllTabs (self,event=None):
    
    '''Convert all tabs to blanks in the selected outline.'''

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    try: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    finally:
        c.endUpdate(count &gt; 0)
</t>
<t tx="ekr.20061021144014.153">def convertBlanks (self,event=None):
    
    '''Convert all blanks to tabs in the selected node.'''

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList
</t>
<t tx="ekr.20061021144014.154">def convertTabs (self,event=None):
    
    '''Convert all tabs to blanks in the selected node.'''

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False,None

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList
</t>
<t tx="ekr.20061021144014.155">def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) &gt; 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p
</t>
<t tx="ekr.20061021144014.156">def dedentBody (self,event=None):
    
    '''Remove one tab's worth of indentation from all presently selected lines.'''
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.157">def extract (self,event=None):
    
    '''Create child node from the elected body text, deleting all selected text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20061021144014.158">def extractSection (self,event=None):
    
    '''Create a section definition node from the selected body text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    &lt;&lt; Set headline for extractSection &gt;&gt;
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20061021144014.159">if len(headline) &lt; 5:
    oops = True
else:
    head1 = headline[0:2] == '&lt;&lt;'
    head2 = headline[0:2] == '@&lt;'
    tail1 = headline[-2:] == '&gt;&gt;'
    tail2 = headline[-2:] == '@&gt;'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
</t>
<t tx="ekr.20061021144014.160">def extractSectionNames(self,event=None):
    
    '''Create child nodes for every section reference in the selected text.
    The headline of each new child node is the section reference.
    The body of each child node is empty.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                &lt;&lt; Find the next section name &gt;&gt;
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()
</t>
<t tx="ekr.20061021144014.161">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
    head2 = string.find(s,"&gt;&gt;",head1)
else:
    head1 = string.find(s,"@&lt;")
    if head1 &gt; -1:
        head2 = string.find(s,"@&gt;",head1)
        
if head1 == -1 or head2 == -1 or head1 &gt; head2:
    name = None
else:
    name = s[head1:head2+2]
</t>
<t tx="ekr.20061021144014.162">def findBoundParagraph (self,event=None):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        &lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;

    # Scan backwards.
    i = len(head_lines)
    while i &gt; 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i &lt; len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#   para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool
</t>
<t tx="ekr.20061021144014.163">if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)
</t>
<t tx="ekr.20061021144014.164">def findMatchingBracket (self,event=None):
    
    '''Selecte the text between matching brackets.'''
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}&lt;&gt;"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"&lt;=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)
</t>
<t tx="ekr.20061021144014.165"># To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{&lt;" ; close_brackets = ")]}&gt;"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,"&gt;=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level &lt;= 0:
                return index
        if not forward and body.compareIndices(index,"&lt;=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
</t>
<t tx="ekr.20061021144014.166">def getBodyLines (self,expandSelection=False):
    
    """Return head,lines,tail where:
        
    before is string containg all the lines before the selected text
    (or the text before the insert point if no selection)
    lines is a list of lines containing the selected text (or the line containing the insert point if no selection)
    after is a string all lines after the selected text
    (or the text after the insert point if no selection)"""

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use g.splitLines.

    return head,lines,tail,oldSel,oldVview
</t>
<t tx="ekr.20061021144014.167">def indentBody (self,event=None):
    
    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; undoType = 'Indent Region' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.168">def insertBodyTime (self,event=None):
    
    '''Insert a time/date stamp at the cursor.'''
    
    c = self ; undoType = 'Insert Body Time'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(undoType,oldSel=oldSel)
</t>
<t tx="ekr.20061021144014.169">def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getBool("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt    = c.config.getBool("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoSettings.leo.
        s = time.strftime(default_format,time.gmtime())
    return s
</t>
<t tx="ekr.20061021144014.170"></t>
<t tx="ekr.20061021144014.171">def addComments (self,event=None):
    
    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.172">def deleteComments (self,event=None):
    
    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.173">def reformatParagraph (self,event=None):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    &lt;&lt; compute vars for reformatParagraph &gt;&gt;
    if lines:
        &lt;&lt; compute the leading whitespace &gt;&gt;
        &lt;&lt; compute the result of wrapping all lines &gt;&gt;
        &lt;&lt; update the body, selection &amp; undo state &gt;&gt;
</t>
<t tx="ekr.20061021144014.174">theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL
</t>
<t tx="ekr.20061021144014.175">indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i &lt; len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
</t>
<t tx="ekr.20061021144014.176"># Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
</t>
<t tx="ekr.20061021144014.177">sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()
</t>
<t tx="ekr.20061021144014.178">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    # g.trace(undoType)

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
</t>
<t tx="ekr.20061021144014.179">def setSelection (self,s):
    
    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)
    
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = g.app.gui.getInsertPoint(w)
        
    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n &gt; -1: s = s[:n]
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    # g.trace(i,j)
    g.app.gui.setSelectionRange(w,i,j,insert=j)
    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
</t>
<t tx="ekr.20061021144014.180">@
The 'hang' was due to removeRKeys, which removes the bindings create by
setRegion (set-mark-command) by *also* cleared all the other bindings!
For now I have simply disabled the set-mark-command and commented out all
calls to removeRKeys.

Note that toggle-extend-mode (Alt-3) is a good way to define regions.</t>
<t tx="ekr.20061021144014.181"></t>
<t tx="ekr.20061021144014.182">def testinrange (self,w):

    if not self.inRange(w,'sel') or not self.contRanges(w,'sel'):
        # self.removeRKeys(w)
        return False
    else:
        return True
</t>
<t tx="ekr.20061021144014.183">def indentRegion (self,event):
    w = self.editWidget(event)
    if not w: return

    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
    # self.removeRKeys(w)
</t>
<t tx="ekr.20061021144014.184">def downCaseRegion (self,event):
    '''Convert all characters in the selected text to lower case.'''
    self.caseHelper(event,'low','downcase-region')
    
def upCaseRegion (self,event):
    '''Convert all characters in the selected text to UPPER CASE.'''
    self.caseHelper(event,'up','upcase-region')
    
def caseHelper (self,event,way,undoType):

    w = self.editWidget(event)
    if not w: return

    trange = w.tag_ranges('sel')
    if len(trange) != 0:
        self.beginCommand(undoType=undoType)
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)
        self.endCommand(changed=True,setLabel=True)

    # self.removeRKeys(w)
</t>
<t tx="ekr.20061021144014.185">@nocolor
@

onFocusIn and its associated binding were a very bad idea.  It is not needed:
k.masterClickHandler simply calls the new onClick method.

What I did:
    
- Eliminating onFocusIn and its associated binding.
  Hurray: this also fixed the Find problem.
- Fixed problem with deleting nodes when multiple editors are present.
- Fixed minor problem with cycle-all-focus.
- Removed title bar when penultimate editor is deleted.

@color</t>
<t tx="ekr.20061021144014.186">def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        # g.trace(event.x,event.y)
        # A hack to support middle-button pastes: remember the previous selection.
        k.previousSelection = g.app.gui.getSelectionRange(w)
        i = w.index('@%s,%s' % (event.x,event.y))
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
        c.frame.body.onClick(w) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol &lt;= xcol &lt;= jcol)
        if icol &lt;= xcol &lt;= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        if trace: g.trace('val:',val)
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
</t>
<t tx="ekr.20061021144014.187">class leoTkinterBody (leoFrame.leoBody):
    
    """A class that represents the body pane of a Tkinter window."""

    @others
</t>
<t tx="ekr.20061021144014.188"></t>
<t tx="ekr.20061021144014.189">def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterBody")
    
    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)
    
    c = self.c ; p = c.currentPosition()
    self.editor_name = None
    self.editor_v = None
    self.editorWidgets = {} # keys are pane names, values are Tk.Text widgets

    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    self.bodyCtrl = self.createControl(frame,parentFrame,p)
    self.colorizer = leoColor.colorizer(c)
</t>
<t tx="ekr.20061021144014.190">def createBindings (self,w=None):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''
    
    frame = self.frame ; c = self.c ; k = c.k
    if not w: w = self.bodyCtrl
    
    w.bind('&lt;Key&gt;', k.masterKeyHandler)

    for kind,func,handler in (
        ('&lt;Button-1&gt;',  frame.OnBodyClick,          k.masterClickHandler),
        ('&lt;Button-3&gt;',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('&lt;Double-1&gt;',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',  None,                       k.masterDoubleClick3Handler),
        ('&lt;Button-2&gt;',  frame.OnPaste,              k.masterClickHandler),
    ):
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        w.bind(kind,bodyClickCallback)</t>
<t tx="ekr.20061021144014.191">def createControl (self,frame,parentFrame,p):
    
    c = self.c
    
    # New in 4.4.1: make the parent frame a Pmw.PanedWidget.
    self.numberOfEditors = 1 ; name = '1'
    self.totalNumberOfEditors = 1
    
    orient = c.config.getString('editor_orientation') or 'horizontal'
    if orient not in ('horizontal','vertical'): orient = 'horizontal'
   
    self.pb = pb = Pmw.PanedWidget(parentFrame,orient=orient)
    parentFrame = pb.add(name)
    pb.pack(expand=1,fill='both') # Must be done after the first page created.
   
    w = self.createTextWidget(frame,parentFrame,p,name)
    self.editorWidgets[name] = w

    return w
</t>
<t tx="ekr.20061021144014.192">def createTextWidget (self,frame,parentFrame,p,name):
    
    c = self.c
    
    parentFrame.configure(bg='LightSteelBlue1')

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = w = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
        
    # g.trace(id(w))
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    body['yscrollcommand'] = bodyBar.set
    bodyBar['command'] = body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = body.leo_p.v
    w.leo_active = True
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w</t>
<t tx="ekr.20061021144014.193">@ **Important**: body.bodyCtrl and body.frame.bodyCtrl must always be the same.
</t>
<t tx="ekr.20061021144014.194">def recolorWidget (self,w):

    c = self.c ; old_w = self.bodyCtrl
    
    # g.trace(id(w),c.currentPosition().headString())
    
    # Save.
    self.bodyCtrl = self.frame.bodyCtrl = w
    
    c.recolor_now(interruptable=False) # Force a complete recoloring.
    
    # Restore.
    self.bodyCtrl = self.frame.bodyCtrl = old_w</t>
<t tx="ekr.20061021144014.195">def unselectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    if not w.leo_label: self.createLabel(w)
    w.leo_label.configure(text=w.leo_label_s,bg='LightSteelBlue1')
        
def selectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    # g.trace(self.numberOfEditors)
    if self.numberOfEditors &gt; 1:
        if not w.leo_label: self.createLabel(w)
        w.leo_label.configure(text=w.leo_label_s,bg='white')
    elif w.leo_label:
        w.leo_label.pack_forget()
        w.leo_label = None

def createLabel (self,w):

    w.leo_label = Tk.Label(w.leo_frame)
    w.pack_forget()
    w.leo_label.pack(side='top')
    w.pack(expand=1,fill='both')
</t>
<t tx="ekr.20061021144014.196">def addEditor (self,event=None):
    
    '''Add another editor to the body pane.'''
    
    c = self.c ; p = c.currentPosition()
     
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1
    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        w = self.editorWidgets.get('1')
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v
        w.leo_label_s = p.headString()
        self.selectLabel(w) # Immediately create the label in the old editor.
   
    name = '%d' % self.totalNumberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    &lt;&lt; create label and text widgets &gt;&gt;
    self.editorWidgets[name] = w

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
    
    self.pb.updatelayout()
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.selectEditor(w)
    self.updateEditors()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20061021144014.197">f = Tk.Frame(pane)
f.pack(side='top',expand=1,fill='both')

w = self.createTextWidget(self.frame,f,name=name,p=p)

w.delete('1.0','end')
w.insert('end',p.bodyString())
w.see('1.0')
self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(w)
</t>
<t tx="ekr.20061021144014.198">def setEditorColors (self,bg,fg):
    
    c = self.c ; d = self.editorWidgets

    for key in d.keys():
        w2 = d.get(key)
        # g.trace(id(w2),bg,fg)
        try:
            w2.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
            pass
</t>
<t tx="ekr.20061021144014.199">def deleteEditor (self,event=None):
    
    '''Delete the presently selected body text editor.'''
    
    w = self.bodyCtrl ; d = self.editorWidgets
    
    if len(d.keys()) == 1: return
    
    name = w.leo_name
    
    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
        
    # Select another editor.
    w = d.values()[0]
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.numberOfEditors -= 1
    self.selectEditor(w)
</t>
<t tx="ekr.20061021144014.200">def onClick (self,w):
    
    wname = g.app.gui.widget_name(w)
    
    if not wname.startswith('body'):
        g.trace('can not happen')
        return

    self.selectEditor(w)</t>
<t tx="ekr.20061021144014.201">def selectEditor(self,w):
    
    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.app.gui.widget_name(w),id(w),g.callers())
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
        # Inactivate the previously active editor.
        # Don't capture ivars here! selectMainEditor keeps them up-to-date.
        for key in d.keys():
            w2 = d.get(key)
            if w2 != w and w2.leo_active:
                w2.leo_active = False
                self.unselectLabel(w2)
                w2.leo_scrollBarSpot = w2.yview()
                w2.leo_insertSpot = g.app.gui.getInsertPoint(w2)
                w2.leo_selection = g.app.gui.getSelectionRange(w2)
                break
        else:
            if trace: g.trace('no active editor!')
    
    # Careful, leo_p may not exist.
    if not c.positionExists(w.leo_p):
        if trace: g.trace('does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v == w.leo_v:
                w.leo_p = p2.copy()
                break
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            if trace: g.trace('previously deleted node')
            return 'break'

    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
    c.recolor_now()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'</t>
<t tx="ekr.20061021144014.202">if w.leo_insertSpot:
    g.app.gui.setInsertPoint(w,w.leo_insertSpot)
    w.see(w.leo_insertSpot)
else:
    g.app.gui.setInsertPoint(w,'1.0')
    
if w.leo_scrollBarSpot:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)

if w.leo_selection:
    try:
        start,end = w.leo_selection
        g.app.gui.setSelectionRange(w,start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20061021144014.203">def selectMainEditor (self,p):
    
    
    '''Called from tree.select to select the present body editor.'''

    c = self.c ; p = c.currentPosition() ; w = self.bodyCtrl

    # Don't inject ivars if there is only one editor.
    if w.leo_p is not None:
        # Keep w's ivars up-to-date.
        w.leo_p = p.copy()
        w.leo_v = p.v
        w.leo_label_s = p.headString()
        self.selectLabel(w)
        # g.trace(w.leo_name,p.headString())
</t>
<t tx="ekr.20061021144014.204">def updateEditors (self):
    
    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) &lt; 2: return # There is only the main widget.

    for key in d.keys():
        w = d.get(key)
        v = w.leo_v
        if v and v == p.v and w != self.bodyCtrl:
            w.delete('1.0','end')
            w.insert('end',p.bodyString())
            # g.trace('update',w,v)
            self.recolorWidget(w)
    c.frame.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.205">def setColorFromConfig (self,w=None):
    
    c = self.c
    if not w: w = self.bodyCtrl
    
    bg = c.config.getColor("body_text_background_color") or 'white'
    # g.trace(id(w),bg)
    
    try: w.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: w.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: w.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try: w.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try: w.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()
  
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: w.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20061021144014.206">def setFontFromConfig (self,w=None):

    c = self.c
    
    if not w: w = self.bodyCtrl
    
    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)
    
    self.fontRef = font # ESSENTIAL: retain a link to font.
    w.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
</t>
<t tx="ekr.20061021144014.207">def hasFocus (self):
    
    return self.bodyCtrl == self.frame.top.focus_displayof()
    
def setFocus (self):
    
    self.c.widgetWantsFocus(self.bodyCtrl)
</t>
<t tx="ekr.20061021144014.208">def forceFullRecolor (self):
    
    self.forceFullRecolorFlag = True
</t>
<t tx="ekr.20061021144014.209">@
I could have used this to redirect all calls from the body class and the bodyCtrl to Tk. OTOH:

1. Most of the wrappers do more than the old Tk routines now and
2. The wrapper names are more discriptive than the Tk names.

Still, using the Tk names would have had its own appeal.  If I had prefixed the tk routine with tk_ the __getatt__ routine could have stripped it off!
@c

if 0: # This works.
    def __getattr__(self,attr):
        return getattr(self.bodyCtrl,attr)
        
if 0: # This would work if all tk wrapper routines were prefixed with tk_
    def __getattr__(self,attr):
        if attr[0:2] == "tk_":
            return getattr(self.bodyCtrl,attr[3:])
</t>
<t tx="ekr.20061021144014.210">def bbox(self,index):

    return self.bodyCtrl.bbox(index)
</t>
<t tx="ekr.20061021144014.211"># Could have been replaced by the __getattr__ routine above...
# 12/19/03: no: that would cause more problems.

def tag_add (self,tagName,index1,index2):
    self.bodyCtrl.tag_add(tagName,index1,index2)

def tag_bind (self,tagName,event,callback):
    self.bodyCtrl.tag_bind(tagName,event,callback)

def tag_configure (self,colorName,**keys):
    self.bodyCtrl.tag_configure(colorName,keys)

def tag_delete(self,tagName):
    self.bodyCtrl.tag_delete(tagName)
    
def tag_names(self,*args): # New in Leo 4.4.1.
    return self.bodyCtrl.tag_names(*args)

def tag_remove (self,tagName,index1,index2):
    return self.bodyCtrl.tag_remove(tagName,index1,index2)
</t>
<t tx="ekr.20061021144014.212">def cget(self,*args,**keys):
    
    val = self.bodyCtrl.cget(*args,**keys)
    
    if g.app.trace:
        g.trace(val,args,keys)

    return val
    
def configure (self,*args,**keys):
    
    # g.trace(args,keys)
    
    return self.bodyCtrl.configure(*args,**keys)
</t>
<t tx="ekr.20061021144014.213">def getBodyPaneHeight (self):
    
    return self.bodyCtrl.winfo_height()

def getBodyPaneWidth (self):
    
    return self.bodyCtrl.winfo_width()
</t>
<t tx="ekr.20061021144014.214">def scheduleIdleTimeRoutine (self,function,*args,**keys):

    self.bodyCtrl.after_idle(function,*args,**keys)
</t>
<t tx="ekr.20061021144014.215"></t>
<t tx="ekr.20061021144014.216">def adjustIndex (self,index,offset):
    
    t = self.bodyCtrl
    return t.index("%s + %dc" % (t.index(index),offset))
</t>
<t tx="ekr.20061021144014.217">def compareIndices(self,i,rel,j):

    return self.bodyCtrl.compare(i,rel,j)
</t>
<t tx="ekr.20061021144014.218">def convertRowColumnToIndex (self,row,column):
    
    return self.bodyCtrl.index("%s.%s" % (row,column))
</t>
<t tx="ekr.20061021144014.219">def convertIndexToRowColumn (self,index):
    
    index = self.bodyCtrl.index(index)
    start, end = string.split(index,'.')
    return int(start),int(end)
</t>
<t tx="ekr.20061021144014.220">def getImageIndex (self,image):
    
    return self.bodyCtrl.index(image)
</t>
<t tx="ekr.20061021144014.221">def tkIndex(self,index):
    
    """Returns the canonicalized Tk index."""
    
    if index == "start": index = "1.0"
    
    return self.bodyCtrl.index(index)
</t>
<t tx="ekr.20061021144014.222"></t>
<t tx="ekr.20061021144014.223">def getPythonInsertionPoint (self,t=None,s=None):
    
    b = self
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    i = t.index("insert")
    row,col = b.convertIndexToRowColumn(i)
    
    return g.convertRowColToPythonIndex(s,row-1,col)
    
def setPythonInsertionPoint (self,i,t=None,s=None):
    
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    t.mark_set( 'insert','%d.%d' % (row+1,col))
</t>
<t tx="ekr.20061021144014.224">def getBeforeInsertionPoint (self):
    
    return self.bodyCtrl.index("insert-1c")

def getInsertionPoint (self):
    
    return self.bodyCtrl.index("insert")
</t>
<t tx="ekr.20061021144014.225">def getCharAtInsertPoint (self):
    
    s = self.bodyCtrl.get("insert")
    return g.toUnicode(s,g.app.tkEncoding)

def getCharBeforeInsertPoint (self):

    s = self.bodyCtrl.get("insert -1c")
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20061021144014.226">def makeInsertPointVisible (self):
    
    self.bodyCtrl.see("insert") # -5l")
</t>
<t tx="ekr.20061021144014.227">def setInsertionPoint (self,index):
    self.bodyCtrl.mark_set("insert",index)

def setInsertionPointToEnd (self):
    self.bodyCtrl.mark_set("insert","end")
    
def setInsertPointToStartOfLine (self,lineNumber): # zero-based line number
    self.bodyCtrl.mark_set("insert",str(1+lineNumber)+".0 linestart")
</t>
<t tx="ekr.20061021144014.228">def bind (self,*args,**keys):
    
    return self.bodyCtrl.bind(*args,**keys)
</t>
<t tx="ekr.20061021144014.229"></t>
<t tx="ekr.20061021144014.230">def deleteTextSelection (self):
    
    t = self.bodyCtrl
    sel = t.tag_ranges("sel")
    if len(sel) == 2:
        start,end = sel
        if t.compare(start,"!=",end):
            t.delete(start,end)
</t>
<t tx="ekr.20061021144014.231">def getSelectedText (self):
    
    """Return the selected text of the body frame, converted to unicode."""

    start, end = self.getTextSelection()
    if start and end and start != end:
        s = self.bodyCtrl.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u'' # Bug fix: 1/8/06
</t>
<t tx="ekr.20061021144014.232">def getTextSelection (self,sort=True):
    
    """Return a tuple representing the selected range of body text.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    w = self.bodyCtrl
    
    sel = w.tag_ranges("sel")

    if len(sel) == 2:
        # New in 4.4a5: match behavior of g.app.gui.getTextSelection.
        if sort:
            i,j = sel
            if w.compare(i, "&gt;", j):
                i,j = j,i
        return sel
    else:
        # Return the insertion point if there is no selected text.
        insert = w.index("insert")
        return insert,insert
</t>
<t tx="ekr.20061021144014.233">def getPythonTextSelection (self):
    
    """Return a tuple representing the selected range of body text.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    b = self ; t = self.bodyCtrl
    sel = t.tag_ranges("sel")

    if len(sel) == 2:
        s = t.get('1.0','end')
        i,j = sel
        row,col = b.convertIndexToRowColumn(i)
        i1 = g.convertRowColToPythonIndex(s,row-1,col)
        row,col = b.convertIndexToRowColumn(j)
        i2 = g.convertRowColToPythonIndex(s,row-1,col)
        return i1,i2
    else:
        # Return the insertion point if there is no selected text.
        i = self.getPythonTextSelection()
        return i,i
</t>
<t tx="ekr.20061021144014.234">def setPythonTextSelection(self,i,j):

    t = self.bodyCtrl
    s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    i1 = '%d.%d' % (row+1,col)
    row,col = g.convertPythonIndexToRowCol(s,j)
    i2 = '%d.%d' % (row+1,col)
    g.app.gui.setTextSelection(self.bodyCtrl,i1,i2)
</t>
<t tx="ekr.20061021144014.235">def hasTextSelection (self):

    sel = self.bodyCtrl.tag_ranges("sel")
    return sel and len(sel) == 2
</t>
<t tx="ekr.20061021144014.236">def selectAllText (self,event=None):
    
    '''Select all text in the presently selected pane.'''
    
    c = self.c ; k = c.k

    try:
        w = c.get_focus() ; wname = c.widget_name(w)
        n = 0
        if wname.startswith('head'):
            s = w.get('1.0','end')
            while s.endswith('\n') or s.endswith('\r'):
                s = s[:-1] ; n += 1
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
        elif wname.startswith('mini'):
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j)
        else:
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
    except:
        # g.es_exception()
        pass
</t>
<t tx="ekr.20061021144014.237">def setTextSelection (self,i,j=None,insert='sel.end'):
    
    # Allow the user to pass either a 2-tuple or two separate args.
    if i is None:
        i,j = "1.0","1.0"
    elif len(i) == 2:
        i,j = i

    g.app.gui.setTextSelection(self.bodyCtrl,i,j,insert)
</t>
<t tx="ekr.20061021144014.238"></t>
<t tx="ekr.20061021144014.239">def deleteAllText(self):
    self.bodyCtrl.delete("1.0","end")

def deleteCharacter (self,index):
    t = self.bodyCtrl
    t.delete(t.index(index))
    
def deleteLastChar (self):
    self.bodyCtrl.delete("end-1c")
    
def deleteLine (self,lineNumber): # zero based line number.
    self.bodyCtrl.delete(str(1+lineNumber)+".0","end")
    
def deleteLines (self,line1,numberOfLines): # zero based line numbers.
    self.bodyCtrl.delete(str(1+line1)+".0",str(1+line1+numberOfLines-1)+".0 lineend")
    
def deleteRange (self,index1,index2):
    t = self.bodyCtrl
    t.delete(t.index(index1),t.index(index2))
</t>
<t tx="ekr.20061021144014.240"></t>
<t tx="ekr.20061021144014.241">def getAllText (self):
    
    """Return all the body text, converted to unicode."""
    
    s = self.bodyCtrl.get("1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20061021144014.242">def getCharAtIndex (self,index):
    
    """Return all the body text, converted to unicode."""
    
    s = self.bodyCtrl.get(index)
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20061021144014.243">def getInsertLines (self):
    
    """Return before,after where:
        
    before is all the lines before the line containing the insert point.
    sel is the line containing the insert point.
    after is all the lines after the line containing the insert point.
    
    All lines end in a newline, except possibly the last line."""
    
    t = self.bodyCtrl

    before = t.get("1.0","insert linestart")
    ins    = t.get("insert linestart","insert lineend + 1c")
    after  = t.get("insert lineend + 1c","end")

    before = g.toUnicode(before,g.app.tkEncoding)
    ins    = g.toUnicode(ins,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)

    return before,ins,after
</t>
<t tx="ekr.20061021144014.244">def getSelectionAreas (self):
    
    """Return before,sel,after where:
        
    before is the text before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is the text after the selected text
    (or the text after the insert point if no selection)"""

    t = self.bodyCtrl
    
    sel_index = t.getTextSelection()
    if len(sel_index) == 2:
        i,j = sel_index
        sel = t.get(i,j)
    else:
        i = j = t.index("insert")
        sel = ""

    before = t.get("1.0",i)
    after  = t.get(j,"end")
    
    before = g.toUnicode(before,g.app.tkEncoding)
    sel    = g.toUnicode(sel,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)
    return before,sel,after
</t>
<t tx="ekr.20061021144014.245">def getSelectionLines (self):
    
    """Return before,sel,after where:
        
    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)"""
    
    # At present, called only by c.getBodyLines.

    t = self.bodyCtrl
    sel_index = t.tag_ranges("sel") 
    if len(sel_index) != 2:
        if 1: # Choose the insert line.
            index = t.index("insert")
            sel_index = index,index
        else:
            return "","","" # Choose everything.

    i,j = sel_index
    i = t.index(i + "linestart")
    j = t.index(j + "lineend") # 10/24/03: -1c  # 11/4/03: no -1c.
    before = g.toUnicode(t.get("1.0",i),g.app.tkEncoding)
    sel    = g.toUnicode(t.get(i,j),    g.app.tkEncoding)
    after  = g.toUnicode(t.get(j,"end-1c"),g.app.tkEncoding)
    
    # g.trace(i,j)
    return before,sel,after
</t>
<t tx="ekr.20061021144014.246">def getTextRange (self,index1,index2):
    
    t = self.bodyCtrl
    return t.get(t.index(index1),t.index(index2))
</t>
<t tx="ekr.20061021144014.247"></t>
<t tx="ekr.20061021144014.248">def insertAtInsertPoint (self,s):
    
    self.bodyCtrl.insert("insert",s)
</t>
<t tx="ekr.20061021144014.249">def insertAtEnd (self,s):
    
    self.bodyCtrl.insert("end",s)
</t>
<t tx="ekr.20061021144014.250">def insertAtStartOfLine (self,lineNumber,s):
    
    self.bodyCtrl.insert(str(1+lineNumber)+".0",s)
</t>
<t tx="ekr.20061021144014.251">def setSelectionAreas (self,before,sel,after):
    
    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    t = self.bodyCtrl ; gui = g.app.gui
    t.delete("1.0","end")

    if before: t.insert("1.0",before)
    sel_start = t.index("end-1c") # 10/24/03: -1c

    if sel: t.insert("end",sel)
    sel_end = t.index("end")

    if after:
        # A horrible Tk kludge.  Remove a trailing newline so we don't keep extending the text.
        if after[-1] == '\n':
            after = after[:-1]
        t.insert("end",after)

    gui.setTextSelection(t,sel_start,sel_end)
    # g.trace(sel_start,sel_end)
    
    return t.index(sel_start), t.index(sel_end)
</t>
<t tx="ekr.20061021144014.252">def makeIndexVisible (self,index):
    
    self.bodyCtrl.see(index)
    
def setFirstVisibleIndex (self,index):
    
    self.bodyCtrl.yview("moveto",index)
    
def getYScrollPosition (self):
    
    return self.bodyCtrl.yview()
    
def setYScrollPosition (self,scrollPosition):

    if len(scrollPosition) == 2:
        first,last = scrollPosition
    else:
        first = scrollPosition
    self.bodyCtrl.yview("moveto",first)
    
def scrollUp (self):
    
    self.bodyCtrl.yview("scroll",-1,"units")
    
def scrollDown (self):

    self.bodyCtrl.yview("scroll",1,"units")
</t>
<t tx="ekr.20061021144014.253">@nocolor

I hate to constantly be the bearer of bad news, but:

exception executing command
Traceback (most recent call last):
   File 
"/mnt/usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoCommands.py", 
line 263, in doCommand
     val = command(event)
   File 
"/mnt/usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/plugins/rst3.py", 
line 677, in rst3PluginCallback
     self.processTopTree(c.currentPosition())
TypeError: processTopTree() takes exactly 3 arguments (2 given)

Cheers -Terry

</t>
<t tx="ekr.20061021144014.254">@nocolor

&gt;&gt; Sorry, the css in the .html doesn't include leo_rst.css 
&gt;&gt; silver_city.css, that's just in the default.css it's looking in 
&gt;&gt; the wrong place for.

&gt; Coming in in the middle of a conversation like this, I have no 
&gt; idea what you are talking about.

Hmmm, my second email amending my first email must have reached you 
before my first email... not helpful.  My first email is repeated 
below, the second email was just saying I mispoke about where those
include statements were.

But maybe you should just address these two points, as they 
represent the current state of my understanding of rst3 css 
problems.

1) On 'Write restructured text' I get "stylesheet does not exist: 
/mnt/proj/ItascaLegacy/default.css" - leo seems to be looking one 
directory too high, the .html file being written and the .css 
files are in /mnt/proj/ItascaLegacy/app/

2) http://www.w3.org/TR/REC-CSS2/cascade.html#at-import 
unfortunately says "Any @import rules must precede all rule sets in 
a style sheet." and Firefox at least ignores them otherwise, so your 
default.css, which has them at the end, needs looking at on this 
point.

Cheers -Terry

---------- Forwarded message ----------
From: Terry Brown &lt;tbrown@nrri.umn.edu&gt;
To: Edward K. Ream &lt;edreamleo@charter.net&gt;
Date: Wed, 18 Oct 2006 14:03:02 -0500 (CDT)
Subject: rst3...


Some problems with rst3

     ignoring unknown option: doc_mode_only

no problem, but it was in the example on Leo's homepage

     stylesheet does not exist: /mnt/proj/ItascaLegacy/default.css

This is true, but /mnt/proj/ItascaLegacy/app/default.css does
exist, and /mnt/proj/ItascaLegacy/app/ is where Leo's writing
the .html file to.  The @rst node just says
'@rst itascatooldoc.html', and the .leo file's in /mnt/proj/ItascaLegacy/app/.

I.e. it seems to be looking one directory higher than it should for 
default.css.

The .html file includes a default rst3 style sheet within it that
includes leo_rst.css  silver_city.css, but the .html file never
refers to default.css.  But maybe this is just a flow on effect
of looking for it in the wrong place.

Cheers -Terry
</t>
<t tx="ekr.20061021144014.255">@

Double-clicking  @url &lt;leo-fille&gt; did not bring Leo file to top

onTreeClick was being called after the double-click handling.
The fix was the c.doubleClickFlag logic.</t>
<t tx="ekr.20061021144014.256"></t>
<t tx="ekr.20061021144014.257">def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.bodyString().split('\n')
            url = lines and lines[0] or ''
        else:
            &lt;&lt; stop the url after any whitespace &gt;&gt;
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            # Note: the UNL plugin has its own notion of what a good url is.
            &lt;&lt; check the url; return if bad &gt;&gt;
            &lt;&lt; pass the url to the web browser &gt;&gt;
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06</t>
<t tx="ekr.20061021144014.258"># For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i &gt; -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i &gt; -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
</t>
<t tx="ekr.20061021144014.259">if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
</t>
<t tx="ekr.20061021144014.260">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)
    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()</t>
<t tx="ekr.20061021144014.261">def onTreeClick (self,event=None):
    
    '''Handle an event in the tree canvas, outside of any tree widget.'''
    
    c = self.c
    
    # New in Leo 4.4.2: a kludge: disable later event handling after a double-click.
    # This allows focus to stick in newly-opened files opened by double-clicking an @url node.
    if c.doubleClickFlag:
        c.doubleClickFlag = False
    else:
        c.treeWantsFocusNow()
    
    return 'break'
</t>
<t tx="ekr.20061021144014.262">set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""

                
    if not g.app.unitTesting and c and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        # Do not call trace here: that might affect focus!
        print 'gui.set_focus: %4d %10s %s' % (
            self.set_focus_count,c and c.shortFileName(),
            c and c.widget_name(w)), g.callers(5)
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
</t>
<t tx="ekr.20061021144014.263"></t>
<t tx="ekr.20061021144014.264">@nocolor

- @bool write_recent_files_as_needed = True

People who don't want Leo to update .leoRecentFiles.txt can set this to False.

- Remove .leoRecentFiles from cvs
- Remove .leoRecentFiles from distribution list.

@color</t>
<t tx="ekr.20061021144014.265">def __init__ (self):
    
    self.configsExist = False # True when we successfully open a setting file.
    self.defaultFont = None # Set in gui.getDefaultConfigFont.
    self.defaultFontFamily = None # Set in gui.getDefaultConfigFont.
    self.globalConfigFile = None # Set in initSettingsFiles
    self.homeFile = None # Set in initSettingsFiles
    self.inited = False
    self.modeCommandsDict = {} # For use by @mode logic. Keys are command names, values are g.Bunches.
    self.myGlobalConfigFile = None
    self.myHomeConfigFile = None
    self.recentFilesFiles = [] # List of g.Bunches describing .leoRecentFiles.txt files.
    self.write_recent_files_as_needed = False # Will be set later.
    
    # Inited later...
    self.panes = None
    self.sc = None
    self.tree = None

    self.initDicts()
    self.initIvarsFromSettings()
    self.initSettingsFiles()
    self.initRecentFiles()
</t>
<t tx="ekr.20061021144014.266">def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []

    # This can't be done in initSettingsFiles because the local directory does not exits.
    localDirectory = g.os_path_dirname(fileName)
    
    #  Set the local leoSettings.leo file.
    localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
    if not g.os_path_exists(localConfigFile): localConfigFile = None
    
    # Set the local myLeoSetting.leo file.
    myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
    if not g.os_path_exists(myLocalConfigFile): myLocalConfigFile = None
    
    self.write_recent_files_as_needed = False # Will be set later.
    
    # Init settings from leoSettings.leo files, including myLeoSettings.leo.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
            if c and localFlag:
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
            self.readRecentFilesFile(c,path)
    if self.write_recent_files_as_needed:
        self.createRecentFiles(fileName)

    self.inited = True
    self.setIvarsFromSettings(None)
</t>
<t tx="ekr.20061021144014.267">def readRecentFilesFile (self,c,path):
    
    # Set the kind of file for later.
    for path2,kind in (
        (self.globalConfigFile,'global'),
        (self.homeFile,'home'),
    ):
        if path2 and path2 == path: break
    else:
        kind = 'local'
    
    path,junk = g.os_path_split(path)
    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    if not g.os_path_exists(fileName):
        # g.trace('does not exist',fileName)
        return
        
    for bunch in self.recentFilesFiles:
        if bunch.fileName == fileName:
            # g.trace('-----already read',kind,fileName)
            return

    # g.trace('-----',kind,fileName)
    self.recentFilesFiles.append(
        g.Bunch(fileName=fileName,kind=kind))

    lines = file(fileName).readlines()
    if lines and self.munge(lines[0])=='readonly':
        lines = lines[1:]
    if lines:
        lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
        self.appendToRecentFiles(lines)</t>
<t tx="ekr.20061021144014.268">def createRecentFiles (self,fileName):
    
    localPath,junk = g.os_path_split(fileName)

    for path in (g.app.homeDir,g.app.globalConfigDir,localPath):
        fileName = g.os_path_join(path,'.leoRecentFiles.txt')
        if g.os_path_exists(fileName):
            # g.es_print('found %s' % fileName)
            return

    # Create the file in the home directory.
    try:
        fileName = g.os_path_join(g.app.homeDir,'.leoRecentFiles.txt')
        f = file(fileName,'w')
        f.close()
        g.es_print('Created %s' % (fileName),color='red')
        return
    except Exception:
        g.es_print('Exception creating %s' % (fileName),color='red')
        g.es_exception()</t>
<t tx="ekr.20061021144014.269">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,'.leoRecentFiles.txt')
            if g.os_path_exists(fileName):
                # g.es_print('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        g.trace('----- not found:',localFileName)
        return
</t>
<t tx="ekr.20061021144014.270">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
</t>
<t tx="ekr.20061021144014.271">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3588148
By: vpe

One way to make Leo more newbie friendly is to add menu items for key features
that are likely to cause confusion in the beginning.

What I did:
    
- Added minibuffer submenu.
- Renamed help to help-for-minibuffer
- Added Pickers submenu
- Added help-for-settings command

@color</t>
<t tx="ekr.20061021144014.272">def defineCmdsMenuTables (self):
    
    if 0: # Replaced by minibuffer submenu.
        self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPanesTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()</t>
<t tx="ekr.20061021144014.273">def defineCmdsMenuAbbrevTable (self):
    
    self.cmdsMenuAbbrevTable = [
        # &amp;: a,e,i,k,l,r,w,v
        'abbre&amp;v-mode',
        '-',
        '&amp;list-abbrevs',
        '&amp;read-abbrev-file',
        '&amp;write-abbrev-file',
        '-',
        '&amp;add-global-abbrev',
        '&amp;inverse-add-global-abbrev',
        '&amp;kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&amp;expand-region-abbrevs',
    ]
</t>
<t tx="ekr.20061021144014.274">def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &amp;: a,c,d
        '&amp;add-editor',
        '&amp;cycle-editor-focus',
        '&amp;delete-editor',
    ]</t>
<t tx="ekr.20061021144014.275">def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&amp;append-to-buffer',
        '&amp;kill-buffer',
        'list-&amp;buffers',
        '&amp;list-buffers-alphabetically',
        '&amp;prepend-to-buffer',
        '&amp;rename-buffer',
        '&amp;switch-to-buffer',
    ]
</t>
<t tx="ekr.20061021144014.276">def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char',
        'back-&amp;paragraph',
        'back-&amp;sentence',
        'back-&amp;word',
        '-',
        'beginning-of-&amp;buffer',
        'beginning-of-&amp;line',
        '-',
        'pre&amp;vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char-extend-selection',
        'back-&amp;paragraph-extend-selection',
        'back-&amp;sentence-extend-selection',
        'back-&amp;word-extend-selection',
        '-',
        'beginning-of-&amp;buffer-extend-selection',
        'beginning-of-&amp;line-extend-selection',
        '-',
        'pre&amp;vious-line-extend-selection',
    ]
    
    self.cursorMenuExtendTable = [
        # &amp;: l,p,s,w
        'extend-to-&amp;line',
        'extend-to-&amp;paragraph',
        'extend-to-&amp;sentence',
        'extend-to-&amp;word',
    ]
    
    self.cursorMenuForwardTable = [
        # &amp;: b,c,l,n,p,s,w
        'end-of-&amp;buffer',
        'end-of-&amp;line',
        '-',
        'forward-&amp;char',
        'forward-&amp;paragraph',
        'forward-&amp;sentence',
        'forward-&amp;word',
        '-',
        '&amp;next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &amp;: b,c,l,n,p,s,w
        'end-of-&amp;buffer-extend-selection',
        'end-of-&amp;line-extend-selection',
        '-',
        'forward-&amp;char-extend-selection',
        'forward-&amp;paragraph-extend-selection',
        'forward-&amp;sentence-extend-selection',
        'forward-&amp;word-extend-selection',#
        '-',
        '&amp;next-line-extend-selection',    
    ]</t>
<t tx="ekr.20061021144014.277">def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&amp;cycle-all-focus',
        'focus-to-&amp;body',          
        'focus-to-&amp;log',             
        'focus-to-&amp;minibuffer',     
        'focus-to-&amp;tree',             
    ]
</t>
<t tx="ekr.20061021144014.278">def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&amp;load-file',
        '-',
        '&amp;start-kbd-macro',
        '&amp;end-kbd-macro',
        '&amp;name-last-kbd-macro',
        '-',
        '&amp;call-last-keyboard-macro',
        '&amp;insert-keyboard-macro',
    ]
</t>
<t tx="ekr.20061021144014.279">def defineCmdsMenuMinibufferTable (self):
    
    self.cmdsMenuMinibufferTable = [
        # &amp;: f,h,i,q,r,s,v
        '&amp;full-command',
        'keyboard-&amp;quit',
        '&amp;repeat-complex-command',
        '&amp;view-lossage',
        '-',
        '&amp;show-mini-buffer',
        'h&amp;ide-mini-buffer',
        '-',
        '&amp;help-for-minibuffer',
    ]
</t>
<t tx="ekr.20061021144014.280">def defineCmdsMenuPanesTable (self):

    self.cmdsMenuPanesTable = [
        # &amp;: a,b,d,f,l,n,o,p,u,x,y
        'contract-&amp;body-pane',
        'contract-&amp;log-pane',
        'contract-&amp;outline-pane',
        'contract-&amp;pane',
        '-',
        'expand-bo&amp;dy-pane',
        'expand-lo&amp;g-pane',
        'expand-o&amp;utline-pane',
        'expand-pa&amp;ne',
        '-',
        '&amp;fully-expand-body-pane',
        'full&amp;y-expand-log-pane',
        'fully-e&amp;xpand-outline-pane',
        'fully-exp&amp;and-pane',
    ]
    </t>
<t tx="ekr.20061021144014.281">def defineCmdsMenuPickersTable (self):
    
    self. cmdsMenuPickersTable = [
        'show-&amp;colors',
        'show-find-&amp;options',
        'show-&amp;fonts',
    ]</t>
<t tx="ekr.20061021144014.282">def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&amp;clear-rectangle',
        'c&amp;lose-rectangle',
        '&amp;delete-rectangle',
        '&amp;kill-rectangle',
        '&amp;open-rectangle',
        '&amp;string-rectangle',
        '&amp;yank-rectangle',
    ]
</t>
<t tx="ekr.20061021144014.283">def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &amp;: a,c,e,i,j,n,p,r,v
        '&amp;append-to-register',
        'copy-r&amp;ectangle-to-register',
        '&amp;copy-to-register',
        'i&amp;ncrement-register',
        '&amp;insert-register',
        '&amp;jump-to-register',
        # 'number-to-register',
        '&amp;point-to-register',
        'p&amp;repend-to-register',
        '&amp;view-register',
    ]
</t>
<t tx="ekr.20061021144014.284">def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &amp;: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&amp;line',
        'scroll-outline-down-&amp;page',
        'scroll-outline-le&amp;ft',
        'scroll-outline-&amp;right',
        's&amp;croll-outline-up-line',
        'scr&amp;oll-outline-up-page',
        '-',
        'scroll-&amp;down',
        'scroll-&amp;up',
        '-',
        'scroll-down-&amp;extend-selection',
        'scroll-up-e&amp;xtend-selection',
    ]</t>
<t tx="ekr.20061021144014.285">def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&amp;open-spell-tab',
        'spell-&amp;change',
        'spell-change-&amp;then-find',
        'spell-&amp;find',
        'spell-&amp;ignore',
    ]
</t>
<t tx="ekr.20061021144014.286">def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &amp;: a,b,c,d,e,f,g,i,l,m,n,o,p,r,s,u
        '&amp;beautify',
        'beautify-&amp;all',
        '-',
        'center-&amp;line',
        'center-&amp;region',
        '-',
        '&amp;capitalize-word',
        '&amp;downcase-word',
        '&amp;upcase-word',
        '-',
        'd&amp;owncase-region',
        'u&amp;pcase-region',
        '-',
        '&amp;indent-region',
        'indent-r&amp;elative',
        'indent-ri&amp;gidly',
        'u&amp;nindent-region',
        '-',
        'sort-colu&amp;mns',
        'sort-&amp;fields',
        '&amp;sort-lines',
    ]</t>
<t tx="ekr.20061021144014.287">def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &amp;: d,e,m,s,t,u,v
        'toggle-a&amp;utocompleter',
        'toggle-call&amp;tips',
        'toggle-&amp;extend-mode',
        'toggle-input-&amp;state',
        'toggle-in&amp;visibles',
        'toggle-&amp;mini-buffer',
        'toggle-split-&amp;direction',
        '-',
        # &amp;: a,b,c,f,h,i,r,w,x
        'toggle-find-&amp;ignore-case-option',
        'toggle-find-in-&amp;body-option',
        'toggle-find-in-&amp;headline-option',
        'toggle-find-mark-&amp;changes-option',
        'toggle-find-mark-&amp;finds-option',
        'toggle-find-rege&amp;x-option',
        'toggle-find-&amp;reverse-option',
        'toggle-find-&amp;word-option',
        'toggle-find-wrap-&amp;around-option',
    ]
</t>
<t tx="ekr.20061021144014.288">def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('&amp;Cmds')
    
    if 0: # Now in the minibuffer table.
        # Used in top table: q,u,x
        self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &amp;: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t
        ('&amp;Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&amp;ditors',       self.cmdsMenuBodyEditorsTable),
        ('&amp;Buffers...',         self.cmdsMenuBuffersTable),
        ('&amp;Cursor/Selection...',[]),
        ('&amp;Focus...',           self.cmdsMenuFocusTable),
        ('&amp;Macro...',           self.cmdsMenuMacroTable),
        ('M&amp;inibuffer',         self.cmdsMenuMinibufferTable),
        ('&amp;Panes...',           self.cmdsMenuPanesTable),
        ('Pic&amp;kers...',         self.cmdsMenuPickersTable),
        ('&amp;Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&amp;gisters...',       self.cmdsMenuRegistersTable),
        ('Scr&amp;olling...',       self.cmdsMenuScrollTable),
        ('Spell C&amp;heck...',     self.cmdsMenuSpellCheckTable),
        ('&amp;Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&amp;ngs',     self.cmdsMenuToggleTable),
    ):
        menu = self.createNewMenu(name,'&amp;Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &amp;: b,e,f,s,t,x
        ('Cursor &amp;Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &amp;Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &amp;To...',                self.cursorMenuExtendTable),
        ('Cursor &amp;Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&amp;xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&amp;ursor/Selection...')
        self.createMenuEntries(menu,table)</t>
<t tx="ekr.20061021144014.289">def defineHelpMenuTables (self):
    
    self.helpMenuTable = [
        # &amp;: a,b,c,d,f,h,l,m,n,o,p,r,s,t,u
        ('&amp;About Leo...',           'about-leo'),
        ('Online &amp;Home Page',       'open-online-home'),
        '*open-online-&amp;tutorial',
        '*open-&amp;users-guide',
        '-',
        ('Open Leo&amp;Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&amp;Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&amp;Settings.leo',   'open-leoSettings-leo'),
        ('Open &amp;myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&amp;ipts.leo',       'open-scripts-leo'),
        '-',
        '*he&amp;lp-for-minibuffer',
        '*help-for-&amp;command',
        '-',
        '*&amp;apropos-autocompletion',
        '*apropos-&amp;bindings',
        '*apropos-&amp;find-commands',
        '-',
        '*pri&amp;nt-bindings',
        '*print-c&amp;ommands',
    ]
</t>
<t tx="ekr.20061021144014.290"># It's not clear how to specify a setting for unicode characters.
# Leo crashes on do-nothing = ц</t>
<t tx="ekr.20061021144014.291">def doNothing (self,event):
    
    '''A placeholder command, useful for testing bindings.'''

    g.trace()</t>
<t tx="ekr.20061021144014.292"># This is much more visible.</t>
<t tx="ekr.20061021144014.293">def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''
    
    k = self.k
    
    if 1:
        g.es('Autocompleter %s' % (g.choose(k.enable_autocompleter,'On','Off')),color='red')
    else:
        frame = k.c.frame
        frame.clearStatusLine()
        frame.putStatusLine('Autocompleter ',color='blue')
        frame.putStatusLine(g.choose(k.enable_autocompleter,'On','Off'))
    
def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    if 1:
        g.es('Calltips %s' % (g.choose(k.enable_calltips,'On','Off')),color='red')
    else:
        frame = k.c.frame
        frame.clearStatusLine()
        frame.putStatusLine('Calltips ',color='blue')
        frame.putStatusLine(g.choose(k.enable_calltips,'On','Off'))</t>
<t tx="ekr.20061021144014.294">@nocolor

Added support for @bool sparse_move_outline_left

When True, Leo collapses the (former) parent of a node when moving that node left.
Takes getting used to, but I like it.

Note that the move-outline-up/down commands can have the effect of moving an outline left.

@color</t>
<t tx="ekr.20061021144014.295"></t>
<t tx="ekr.20061021144014.296">def demote (self,event=None):
    
    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    command = 'Demote'
    if not current or not current.hasNext():
        c.treeWantsFocusNow()
        return

    # Make sure all the moves will be valid.
    for child in current.children_iter():
        if not c.checkMoveWithParentWithWarning(child,current,True):
            c.treeWantsFocusNow()
            return
    c.beginUpdate()
    try: # update...
        c.endEditing()
        u.beforeChangeGroup(current,command)
        p = current.copy()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            undoData = u.beforeMoveNode(child)
            child.moveToNthChildOf(p,p.numberOfChildren())
            u.afterMoveNode(child,command,undoData)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = current.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(current,command,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(current)  # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(current) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.297">@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):
    
    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
        
    inAtIgnoreRange = p.inAtIgnoreRange()
    # Set next to the node after which p will be moved.
    next = p.visNext()
    while next and p.isAncestorOf(next):
        next = next.visNext()
    if not next:
        c.treeWantsFocusNow()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        &lt;&lt; Move p down &amp; set moved if successful &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.298">parent = p.parent()

if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)
        
else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)
        
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20061021144014.299">def moveOutlineLeft (self,event=None):
    
    '''Move the selected node left if possible.'''
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    if not p.hasParent():
        c.treeWantsFocusNow()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        if sparseMove: # New in Leo 4.4.2
            parent.contract()
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20061021144014.300">def moveOutlineRight (self,event=None):
    
    '''Move the selected node right if possible.'''
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    if not p.hasBack:
        c.treeWantsFocusNow()
        return
    back = p.back()
    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeWantsFocusNow()
        return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # g.trace(p,p.parent())
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.301">def moveOutlineUp (self,event=None):
    
    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    back = p.visBack()
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack()
    if back2 and p.v in back2.v.t.vnodeList:
        # A weird special case: just select back2.
        c.selectPosition(back2)
        c.treeWantsFocusNow()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        &lt;&lt; Move p up &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
            
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.302">if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())
    
parent = p.parent()

if not back2:
    # p will be the new root node
    moved = True
    p.moveToRoot(oldRoot=c.rootPosition())

elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)

else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)

if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20061021144014.303">def promote (self,event=None):
    
    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren():
        c.treeWantsFocusNow()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        u.beforeChangeGroup(p,command)
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            undoData = u.beforeMoveNode(child)
            child.moveAfter(after)
            after = child
            u.afterMoveNode(child,command,undoData)
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterChangeGroup(p,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.304"># At long last Leo creates a proper help menu on the Mac.</t>
<t tx="ekr.20061021144014.305">def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        self.getMacHelpMenu()
    else:
        helpMenu = self.createNewMenu("&amp;Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)</t>
<t tx="ekr.20061021144014.306">def getMacHelpMenu (self):
    
    try:
        topMenu = self.getMenu('top')
        # Use the name argument to create the special Macintosh Help menu.
        helpMenu = Tk.Menu(topMenu,name='help',tearoff=0)
        self.add_cascade(topMenu,label='Help',menu=helpMenu,underline=0)
        self.createMenuEntries(helpMenu,self.helpMenuTable)
        return helpMenu

    except Exception:
        g.trace('Can not get MacOS Help menu')
        g.es_exception()
        return None</t>
<t tx="ekr.20061021144014.307">This would greatly simplify menu entries.</t>
<t tx="ekr.20061021144014.308"># This is an important step towards making all menus configurable.</t>
<t tx="ekr.20061021144014.309"># \(\"(.*)\",.*\),  --&gt; '\1',</t>
<t tx="ekr.20061021144014.310">def capitalizeMinibufferMenuName (self,s,removeHyphens):
    
    result = []
    for i in xrange(len(s)):
        ch = s[i]
        prev = i &gt; 0 and s[i-1] or ''
        prevprev = i &gt; 1 and s[i-2] or ''
        if (
            i == 0 or
            i == 1 and prev == '&amp;' or
            prev == '-' or
            prev == '&amp;' and prevprev == '-'
        ):
            result.append(ch.capitalize())
        elif removeHyphens and ch == '-':
            result.append(' ')
        else:
            result.append(ch)
    return ''.join(result)</t>
<t tx="ekr.20061021144014.311">def defineMenuTables (self):
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

</t>
<t tx="ekr.20061021144014.312">def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
</t>
<t tx="ekr.20061021144014.313">def defineEditMenuTopTable (self):
    
    self.editMenuTopTable = [
        # &amp;: u,r reserved for undo/redo: a,d,p,t,y.
        # &amp; (later): e,g,n,v.
        ("Can't Undo",'undo'),
        ("Can't Redo",'redo'), 
        '-',
        ('Cu&amp;t','cut-text'),
        ('Cop&amp;y','copy-text'),
        ('&amp;Paste','paste-text'),
        ('&amp;Delete','backward-delete-char'),
        ('Select &amp;All','select-all'),
        '-',
    ]
</t>
<t tx="ekr.20061021144014.314">def defineEditMenuEditBodyTable (self):
    
    self.editMenuEditBodyTable = [
        # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
        '*extract-&amp;section',
        '*extract-&amp;names',
        '*&amp;extract',
        '-',
        '*convert-all-b&amp;lanks',
        '*convert-all-t&amp;abs',
        '*convert-&amp;blanks',
        '*convert-&amp;tabs',
        '*insert-body-&amp;time',
        '*&amp;reformat-paragraph',
        '-',
        '*&amp;indent-region',
        '*&amp;unindent-region',
        '*&amp;match-brackets',
        '*add-comments',
        '*delete-comments',
    ]
</t>
<t tx="ekr.20061021144014.315">def defineEditMenuEditHeadlineTable (self):
    
    self.editMenuEditHeadlineTable = [
        '*edit-&amp;headline',
        '*&amp;end-edit-headline',
        '*&amp;abort-edit-headline',
        '*insert-headline-&amp;time',
        '*toggle-&amp;angle-brackets',
    ]
</t>
<t tx="ekr.20061021144014.316">def defineEditMenuFindMenuTable (self):
    
    self.editMenuFindMenuTable = [
        # &amp;: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,u,w,x
        '*&amp;open-find-tab',
        '*&amp;hide-find-tab',
        '*search-&amp;with-present-options',
        '-',
        '*find-tab-find-&amp;next',
        '*find-tab-find-&amp;prev',
        '*find-tab-&amp;change',
        '*find-tab-find-&amp;all',
        '*clone-fi&amp;nd-all',
        '*find-tab-change-a&amp;ll',
        '-',
        '*&amp;find-character',
        '*find-character-extend-&amp;selection',
        '*&amp;backward-find-character',
        '*backward-find-character-&amp;extend-selection',
        '-',
        '*&amp;isearch-forward',
        '*isea&amp;rch-backward',
        '*isearch-forward-rege&amp;xp',
        '*isearch-backward-regex&amp;p',
        '-',
        '*&amp;query-replace',
        '*q&amp;uery-replace-regex',
    ]
</t>
<t tx="ekr.20061021144014.317">def defineEditMenuTop2Table (self):
    
    c = self.c

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
        
    self.editMenuTop2Table = [
        '*&amp;goto-global-line',
        '*&amp;execute-script',
        (label,'toggle-invisibles'),
        ("Setti&amp;ngs",'open-leoSettings-leo'),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
</t>
<t tx="ekr.20061021144014.318">def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
</t>
<t tx="ekr.20061021144014.319">def defineFileMenuTopTable (self):
    
    self.fileMenuTopTable = [
        '*&amp;new',
        ('&amp;Open...','open-outline'),
    ]
</t>
<t tx="ekr.20061021144014.320">def defineFileMenuTop2Table (self):
    
    self.fileMenuTop2Table = [
        '-',
        ('&amp;Close','close-window'),
        ('&amp;Save','save-file'),
        ('Save &amp;As','save-file-as'),
        ('Save &amp;To','save-file-to'),
        ('Re&amp;vert To Saved','revert'),
    ]
</t>
<t tx="ekr.20061021144014.321">def defineFileMenuReadWriteMenuTable (self):
    
    self.fileMenuReadWriteMenuTable = [
        '*&amp;read-outline-only',
        ('Read @file &amp;Nodes','read-at-file-nodes'),
        ('Write &amp;Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &amp;Missing @file Nodes','write-missing-at-file-nodes'),
        '*write-&amp;outline-only',
        ('&amp;Write @file Nodes','write-at-file-nodes'),
    ]
</t>
<t tx="ekr.20061021144014.322">def defineFileMenuTangleMenuTable (self):
    
    self.fileMenuTangleMenuTable = [
        '*tangle-&amp;all',
        '*tangle-&amp;marked',
        '*&amp;tangle',
    ]
</t>
<t tx="ekr.20061021144014.323">def defineFileMenuUntangleMenuTable (self):
    
    self.fileMenuUntangleMenuTable = [
        '*untangle-&amp;all',
        '*untangle-&amp;marked',
        '*&amp;untangle',
    ]
</t>
<t tx="ekr.20061021144014.324">def defineFileMenuImportMenuTable (self):
    
    self.fileMenuImportMenuTable = [
        #&amp;: c,d,f,n,o,r,
        '*import-&amp;derived-file',
        ('Import To @&amp;file','import-at-file'),
        ('Import To @&amp;root','import-at-root'),
        '*import-&amp;cweb-files',
        '*import-&amp;noweb-files',
        '*import-flattened-&amp;outline',
    ]
</t>
<t tx="ekr.20061021144014.325">def defineFileMenuExportMenuTable (self):
    
    self.fileMenuExportMenuTable = [
        '*export-&amp;headlines',
        '*outline-to-&amp;cweb',
        '*outline-to-&amp;noweb',
        '*&amp;flatten-outline',
        '*&amp;remove-sentinels',
        '*&amp;weave',
    ]
</t>
<t tx="ekr.20061021144014.326">def defineFileMenuTop3MenuTable (self):
    
    self.fileMenuTop3MenuTable = [
        ('E&amp;xit','exit-leo'),
    ]
</t>
<t tx="ekr.20061021144014.327">def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
</t>
<t tx="ekr.20061021144014.328">def defineOutlineMenuTopMenuTable (self):

    self.outlineMenuTopMenuTable = [
        '*c&amp;ut-node',
        '*c&amp;opy-node',
        '*&amp;paste-node',
        ('Pas&amp;te Node As Clone','paste-retaining-clones'),
        '*&amp;delete-node',
        '-',
        '*&amp;insert-node',
        '*&amp;clone-node',
        '*sort-childre&amp;n',
        '*&amp;sort-siblings',
        '-',
        '*&amp;hoist',
        ('D&amp;e-Hoist','de-hoist'), # To preserve the '-' in De-Hoist.
        '-',
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
</t>
<t tx="ekr.20061021144014.329">def defineOutlineMenuCheckOutlineMenuTable (self):
    
    self.outlineMenuCheckOutlineMenuTable = [
        # &amp;: a,c,d,o
        '*check-&amp;outline',
        '*&amp;dump-outline',
        '-',
        '*check-&amp;all-python-code',
        '*&amp;check-python-code',
    ]
</t>
<t tx="ekr.20061021144014.330">def defineOutlineMenuExpandContractMenuTable (self):
    
    self.outlineMenuExpandContractMenuTable = [
        '*&amp;contract-all',
        '*contract-&amp;node',
        '*contract-&amp;parent',
        '*contract-or-go-&amp;left',
        '-',
        '*expand-p&amp;rev-level',
        '*expand-n&amp;ext-level',
        '*expand-and-go-right',
        '*expand-or-go-right',
        '-',
        '*expand-to-level-&amp;1',
        '*expand-to-level-&amp;2',
        '*expand-to-level-&amp;3',
        '*expand-to-level-&amp;4',
        '*expand-to-level-&amp;5',
        '*expand-to-level-&amp;6',
        '*expand-to-level-&amp;7',
        '*expand-to-level-&amp;8',
        '-',
        '*expand-&amp;all',
        '*expand-n&amp;ode',
    ]
</t>
<t tx="ekr.20061021144014.331">def defineOutlineMenuMoveMenuTable (self):
    
    self.outlineMenuMoveMenuTable = [
        ('Move &amp;Down','move-outline-down'),
        ('Move &amp;Left','move-outline-left'),
        ('Move &amp;Right','move-outline-right'),
        ('Move &amp;Up','move-outline-up'),
        '-',
        '*&amp;promote',
        '*&amp;demote',
    ]
</t>
<t tx="ekr.20061021144014.332">def defineOutlineMenuMarkMenuTable (self):
    
    self.outlineMenuMarkMenuTable = [
        '*&amp;mark',
        '*mark-&amp;subheads',
        '*mark-changed-&amp;items',
        '*mark-changed-&amp;roots',
        '*mark-&amp;clones',
        '*&amp;unmark-all',
    ]
</t>
<t tx="ekr.20061021144014.333">def defineOutlineMenuGoToMenuTable (self):

    self.outlineMenuGoToMenuTable = [
        # &amp;: a,c,d,e,g,i,l,m,n,o,p,r,s,t,v,x
        ('Go Prev Visite&amp;d','go-back'),
        ('Go Next Visited','go-forward'),
        ('Go To P&amp;rev Node','goto-prev-node'),
        ('Go To N&amp;ext Node','goto-next-node'),
        '-',
        ('Go To Next &amp;Marked','goto-next-marked'),
        ('Go To Next &amp;Changed','goto-next-changed'),
        ('Go To Next &amp;Clone','goto-next-clone'),
        '-',
        ('&amp;Go To First Node','goto-first-node'),
        ('G&amp;o To Prev Visible','goto-prev-visible'),
        ('Go To Ne&amp;xt Visible','goto-next-visible'),
        ('Go To L&amp;ast Node','goto-last-node'),
        ('Go To Last &amp;Visible','goto-last-visible'),
        '-',
        ('Go To &amp;Parent','goto-parent'),
        ('Go To First &amp;Sibling','goto-first-sibling'),
        ('Go To Last S&amp;ibling','goto-last-sibling'),
        ('Go To Prev Sibli&amp;ng','goto-prev-sibling'),
        ('Go To Next Siblin&amp;g','goto-next-sibling'),
    ]
</t>
<t tx="ekr.20061021144014.334">def defineWindowMenuTables (self):
    
    self.windowMenuTopTable = [
        # &amp;: a,c,e,m,o,p,r,s
        '*&amp;equal-sized-panes',
        '*toggle-&amp;active-pane',
        '*toggle-&amp;split-direction',
        '-',
        '*&amp;resize-to-screen',
        '*&amp;cascade-windows',
        '*&amp;minimize-all',
        '-',
        '*&amp;open-compare-window',
        '*open-&amp;python-window',
    ]
</t>
<t tx="ekr.20061021144014.335"># The open-scripts-leo command.</t>
<t tx="ekr.20061021144014.336">def openLeoScripts (self,event=None):
    
    c = self
    fileName = g.os_path_join(g.app.loadDir,'..','scripts','scripts.leo')

    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es('not found: %s' % fileName)
</t>
<t tx="ekr.20061021144014.337"></t>
<t tx="ekr.20061021144014.338">@others
</t>
<t tx="ekr.20061021144014.339">class spellCommandsClass (baseEditCommandsClass):
    
    '''Commands to support the Spell Tab.'''

    @others
</t>
<t tx="ekr.20061021144014.340">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.handler = None
    
    # All the work happens when we first open the frame.
</t>
<t tx="ekr.20061021144014.341">def getPublicCommands (self):
    
    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
</t>
<t tx="ekr.20061021144014.342">def openSpellTab (self,event=None):
    
    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.handler = spellTab(c,f)
        
    self.handler.bringToFront()
</t>
<t tx="ekr.20061021144014.343"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()
        
def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
</t>
<t tx="ekr.20061021144014.344">class spellTab(leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""
    
    @others
</t>
<t tx="ekr.20061021144014.345"></t>
<t tx="ekr.20061021144014.346">def __init__(self,c,parentFrame):
    
    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = Tk.Text(None) # A text widget for scanning.
    
    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.createSpellTab(parentFrame)
        self.createBindings()
</t>
<t tx="ekr.20061021144014.347">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"../","plugins",'spellpyx.txt'))
    
    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)
    
    # if not self.aspell.aspell:
    if not self.aspell:
        g.es_print('Can not open Aspell',color='red')
        return False
        
    self.dictionary = self.readDictionary(dictionaryFileName)
    return True
</t>
<t tx="ekr.20061021144014.348">def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;
    
    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
    
    self.fillbox([])
    self.listBox.bind("&lt;Double-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)
</t>
<t tx="ekr.20061021144014.349">self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)
</t>
<t tx="ekr.20061021144014.350">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
</t>
<t tx="ekr.20061021144014.351"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
</t>
<t tx="ekr.20061021144014.352">def createBindings (self):
    
    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
</t>
<t tx="ekr.20061021144014.353">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""
    
    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
</t>
<t tx="ekr.20061021144014.354"></t>
<t tx="ekr.20061021144014.355">def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.add()
</t>
<t tx="ekr.20061021144014.356">def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.ignore()
</t>
<t tx="ekr.20061021144014.357">def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.change()
    self.updateButtons()
    

def onChangeThenFindButton(self,event=None):
    
    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.change():
        self.find()
    self.updateButtons()
</t>
<t tx="ekr.20061021144014.358">def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    c = self.c
    self.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20061021144014.359">def onHideButton(self):
    
    """Handle a click in the Hide button in the Spell tab."""
    
    self.hide()
</t>
<t tx="ekr.20061021144014.360"></t>
<t tx="ekr.20061021144014.361">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()
</t>
<t tx="ekr.20061021144014.362">def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; t = body.bodyCtrl
    
    selection = self.getSuggestion()
    if selection:
        start,end = oldSel = g.app.gui.getTextSelection(t)
        if start:
            if t.compare(start, "&gt;", end):
                start,end = end,start
            t.delete(start,end)
            t.insert(start,selection)
            g.app.gui.setTextSelection(t,start,start + "+%dc" % (len(selection)))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20061021144014.363">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; bodyCtrl = body.bodyCtrl

    # Reload the work pane from the present node.
    s = bodyCtrl.get("1.0","end").rstrip()
    self.workCtrl.delete("1.0","end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = bodyCtrl.index("insert")
    self.workCtrl.mark_set("insert",ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Copy the working selection range to the body pane
        start, end = g.app.gui.getTextSelection(self.workCtrl)
        g.app.gui.setTextSelection(bodyCtrl,start,end)
        bodyCtrl.see(start)
    else:
        g.es("no more misspellings")
        self.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20061021144014.364">def hide (self,event=None):
    
    self.c.frame.log.selectTab('Log')
    
    for message in self.messages:
        g.es(message,color='blue')
        
    self.messages = []
</t>
<t tx="ekr.20061021144014.365">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""
    
    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()
</t>
<t tx="ekr.20061021144014.366"></t>
<t tx="ekr.20061021144014.367">def bringToFront (self):
    
    self.c.frame.log.selectTab('Spell')
</t>
<t tx="ekr.20061021144014.368">def fillbox(self, alts, word=None):
    """Update the suggestions listbox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])
    
    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1)
</t>
<t tx="ekr.20061021144014.369">def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None
   
    try:
        while 1:
            p, word = self.findNextWord(p) 
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if alts:
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                break
    except:
        g.es_exception()
    return alts, word
</t>
<t tx="ekr.20061021144014.370">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
</t>
<t tx="ekr.20061021144014.371">def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None
</t>
<t tx="ekr.20061021144014.372">def onMap (self, event=None):
    """Respond to a Tk &lt;Map&gt; event."""
    
    self.update(show= False, fill= False)
</t>
<t tx="ekr.20061021144014.373">def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    
    c = self.c
    self.updateButtons()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.374">def update(self,show=True,fill=False):
    
    """Update the Spell Check dialog."""
    
    c = self.c
    
    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.375">def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c

    start, end = g.app.gui.getTextSelection(c.frame.body.bodyCtrl)
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
</t>
<t tx="ekr.20061021144014.376">class AspellClass:
    
    """A wrapper class for Aspell spell checker"""
    
    @others
</t>
<t tx="ekr.20061021144014.377"></t>
<t tx="ekr.20061021144014.378">def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = g.os_path_abspath(c.config.getString('aspell_dir'))
    self.aspell_bin_dir = g.os_path_abspath(c.config.getString('aspell_bin_dir'))
    
    self.local_language_code = local_language_code or 'en'
    self.local_dictionary_file = g.os_path_abspath(local_dictionary_file)
    self.local_dictionary = "%s.wl" % os.path.splitext(self.local_dictionary_file) [0]
    
    # g.trace('code',self.local_language_code,'dict',self.local_dictionary_file)
    # g.trace('dir',self.aspell_dir,'bin_dir',self.aspell_bin_dir)
    
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    self.use_ctypes = g.CheckVersion(version,'2.5')
    self.aspell = self.sc = None
    
    if self.use_ctypes:
        self.getAspellWithCtypes()
    else:
        self.getAspell()
</t>
<t tx="ekr.20061021144014.379">def getAspell (self):

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=__name__,verbose=True)

    self.aspell = aspell
    self.sc = aspell and aspell.spell_checker(prefix=self.aspell_dir,lang=self.local_language_code)</t>
<t tx="ekr.20061021144014.380">def getAspellWithCtypes (self):
    
    import ctypes
    c_int, c_char_p = ctypes.c_int, ctypes.c_char_p

    aspell = ctypes.CDLL(g.os_path_join(self.aspell_bin_dir, "aspell-15.dll"))

    &lt;&lt; define and configure aspell entry points &gt;&gt;

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
</t>
<t tx="ekr.20061021144014.381"># new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p] 

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_int, c_char_p] 

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p  

sc = new_aspell_config()
if 0:
    print sc 
    print aspell_config_replace(sc, "prefix", aspell_dir) #1/0 
    print 'prefix', aspell_dir, `aspell_config_retrieve(sc, "prefix")`
    print aspell_config_retrieve(sc, "lang")
    print aspell_config_replace(sc, "lang",self.local_language_code)
    print aspell_config_retrieve(sc, "lang")

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))

# Rudimentary error checking, needs more.  
if aspell.aspell_error_number(possible_err) != 0:
    print 'err', aspell_error_message(possible_err)
    spell_checker = None
else: 
    spell_checker = aspell.to_aspell_speller(possible_err)

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_int
word_list_size.argtypes = [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_int
word_list_elements.argtypes = [c_int,]

# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_int 
suggest.argtypes = [c_int, c_char_p, c_int]</t>
<t tx="ekr.20061021144014.382">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; «original» «count» «offset»: «miss», «miss», ... 
    None: 
    # «original» «offset» 
    simplifyed to not create the string then make a list from it 
    """
    
    if self.use_ctypes:
        if self.check(self.spell_checker,word,len(word)):
            return None
        else:
            return self.suggestions(word)
    else:
        if self.sc.check(word):
            return None
        else:
            return self.sc.suggest(word)
</t>
<t tx="ekr.20061021144014.383">def suggestions(self,word):

    "return list of words found"
    
    aList = []
    sw = self.suggest(self.spell_checker, word, len(word))

    if self.word_list_size(sw):
        ewords = self.word_list_elements(sw)
        while 1: 
            x = self.string_enumeration_next(ewords)
            if x is None: break
            aList.append(x)
    return aList</t>
<t tx="ekr.20061021144014.384">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.
    
    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es_print("Unable to update local aspell dictionary: %s" % err)
        return False
</t>
<t tx="ekr.20061021144014.385"></t>
<t tx="ekr.20061021144014.386">@nocolor

I think to make it as X-windowish as possible it should paste the 
selection, rather than the contents of the clipboard, when there is 
a selection.

Perhaps paste is the wrong word. In X-windows, when you middle-button-click in a
text frame, and there is a selection somewhere in the text frame, the contents
of that selection is inserted at the point you clicked - even if the insertion
cursor is elsewhere (e.g. at the end of the selection).
</t>
<t tx="ekr.20061021144014.387">@nocolor

If the selection is in a different frame, e.g. the log frame, middle 
button click in the body frame first pastes the clipboard text, then 
pastes the selected text in the middle of it :-} It should just 
paste the selected text.
</t>
<t tx="ekr.20061021144014.388">def OnPaste (self,event=None):
    
    return self.pasteText(event=event,middleButton=True)</t>
<t tx="ekr.20061021144014.389"></t>
<t tx="ekr.20061021144014.390">def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
</t>
<t tx="ekr.20061021144014.391">def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = g.app.gui.getAllText(w)
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s=g.app.gui.getAllText(w)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
</t>
<t tx="ekr.20061021144014.392">def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = g.app.gui.getTextSelection(w)  # Returns insert point if no selection.
    oldText = w.get('1.0','end')
    
    # print 'pasteText',i,j,middleButton,wname,repr(c.k.previousSelection)
    
    if middleButton and c.k.previousSelection:
        start,end = c.k.previousSelection
        s = w.get(start,end)
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.get('1.0','end')
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20061021144014.393"></t>
<t tx="ekr.20061021144014.394">http://sourceforge.net/forum/message.php?msg_id=3958380
By: paulpaterson

Printing from the KeyBindings plugin is broken. The fix is,

Change (line 306, printKeys()): 

fname = os.path.abspath(g.os_path_join("..", "plugins", "keyreport.html"))

To:

fname = os.path.abspath(g.os_path_join("..", "..", "plugins",
"keyreport.html"))


(Note the additional "..")

It appears that the current directory in use when running Leo has changed to
/Leo/test/plugins ?!</t>
<t tx="ekr.20061021144014.395">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3423121
By: nobody

Hi! I need help removing script buttons. It says I should right click the ofending
button. I have a mac and Ctl-click, Command-click, etc doesn't work. What should
I do?</t>
<t tx="ekr.20061021144014.396">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3959003
By: nobody

The node navigator plugin does not show up in the plugins menu (also happens
in Leo4.4.1.1)

The quick fix was to revert to the default module-level __name__ attribute.
Presumably a better fix involves the plugins manager plugin.

The use of this plugin decreases when moving through the outline without the
mouse. Maybe some setting could be introduced to only include a node to the
'Recent' list when it has had focus for more than, say, 5 seconds? Or being
edited, of course.

Another suggestion might be to set _named_ marks for a (line in a?) node a la
vim (where its shortcut is m&lt;markname&gt;). I can remember about 3 or 4 marks when
analyzing code, and switching by only using the keyboard (shortcuts '&lt;markname&gt;
or `&lt;markname&gt;) works very good (for me) in vim. Switching between the two most
recent marks is done in vim using the shortcut '' or ``.
</t>
<t tx="ekr.20061021144014.397">@nocolor

(via email) Terry Brown</t>
<t tx="ekr.20061021144014.398">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3962632
By: paulpaterson

This isn't a problem in the manager or plugins menu as such - the plugins_menu
uses the __name__ attribute of a module to identify what to display. This shouldn't
be changed or the plugin wont display in the menu.

If you want to display a nice name in the plugins menu then you set the
__plugin_name__ attribute of a plugin.

There are four current plugins that break this rule,

nodenavigator
wordexport
newbuttons
rowcol

(ironically I had a hand in a few of those!)

All these plugins should have the line,

__name__ = "ldaldjalks"

replaced with

__plugin_name__ = "kjldldasd"


Regards,

Paul

</t>
<t tx="ekr.20061021144014.399">- Every button created by the plugin creates a corresponding command.  The command name is the 'cleaned' version of the button name.

- Every button created by the plugin also creates a delete-x-button command, where x is the command name as just discussed.  So now you can delete script buttons without right-clicking.

- I took the time to revise, refactor, clean up, reorganize and better document the code.  This was overdue: the previous code had grown difficult to understand through multiple small accretions.  I can actually understand the new code.

- This *might* have fixed the following crasher:

http://sourceforge.net/forum/message.php?msg_id=3962483
By: ktenney

right click on icon bar @button results in TK exception

TclError Exception in Tk callback
  Function: &lt;bound method Balloon._destroy of &lt;_Pmw.Pmw_1_2.lib.PmwBalloon.Balloon
instance at 0x020B2EB8&gt;&gt; (type: &lt;type 'instancemethod'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x01FB93C8&gt;,)
  Event type: DestroyNotify (type num: 17)
Traceback (innermost last):
  File "c:\python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747,
in __call__
    return apply(self.func, args)
  File "c:\python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBalloon.py", line 283,
in _destroy
    self.withdraw()
  File "&lt;string&gt;", line 1, in withdraw
    None
  File "c:\python24\lib\lib-tk\Tkinter.py", line 1541, in wm_withdraw
    return self.tk.call('wm', 'withdraw', self._w)
TclError: bad window path name ".20325440.23282432.23282712.34285688.33264144"
</t>
<t tx="ekr.20061021144014.400"></t>
<t tx="ekr.20061021144014.401">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3963935
By: terry_n_brown

Not working for me, with

@multipath /mnt/120/usr1/home/tbrown

or

@multipath /home/tbrown

the former being the symbolic link free form of the latter, but both fail the
same way, so I don't think  it's a symbolic link problem.

If /home/tbrown/itaseval.py doesn't exist I get:

multifile:  
Cant write itaseval.py to /mnt/120/usr1/home/tbrown
IOError, [Errno 2] No such file or directory: u'itaseval.py'

If I make it a zero length file I get

multifile:
Cant write itaseval.py to /mnt/120/usr1/home/tbrown
Error, `itaseval.py` and `/mnt/120/usr1/home/tbrown/itaseval.py` are the same
file

As I said /mnt/120/usr1/home/tbrown and /home/tbrown are equivalent, I was just
trying both to see if it's a symbolic link problem, but it doesn't seem to be.
</t>
<t tx="ekr.20061021144014.402">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3963657

This crash was due to the recent changes in the mod_scripting plugin, which the
shortcut_button plugin uses. The new code is much simpler than the old, and does
more.</t>
<t tx="ekr.20061021144014.403"></t>
<t tx="ekr.20061021144014.404">@nocolor

As always, you can set max_undo_stack_size in myLeoSettings.leo.</t>
<t tx="ekr.20061021144014.405">A highly useful option.
However, creating a new node always selects the entire text, regardless of this options.
</t>
<t tx="ekr.20061021144014.406">def setEditLabelState (self,p,selectAll=False): # selected, editing

    c = self.c ; w = c.edit_widget(p)

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        w.tag_remove('sel','1.0','end')
        selectAll = selectAll or c.config.getBool('select_all_text_when_editing_headlines')
        start = g.choose(selectAll,'1.0','end')
        w.tag_add('sel',start,'end')
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.
</t>
<t tx="ekr.20061021144014.407">def editLabel (self,p,selectAll=False):
    
    """Start editing p's headline."""

    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p
    
    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

    if p and c.edit_widget(p):
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
</t>
<t tx="ekr.20061021144014.408">def insertHeadline (self,event=None,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if (
            (current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)
        ):
            if c.config.getBool('insert_new_nodes_at_end'):
                p = current.insertAsLastChild()
            else:
                p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.beginUpdate()
    try:
        c.editPosition(p,selectAll=True)
    finally:
        c.endUpdate(False)

    return p # for mod_labels plugin.
</t>
<t tx="ekr.20061021144014.409"># Selects v: sets the focus to p and edits p.

def editPosition(self,p,selectAll=False):

    c = self ; k = c.k

    if p:
        c.selectPosition(p)
        c.frame.tree.editLabel(p,selectAll=selectAll)
        
        if k:
            k.setDefaultUnboundKeyAction()
            k.showStateAndMode()
</t>
<t tx="ekr.20061021144014.410">@nocolor

- Added bindings for toggle-autocompleter (Alt-1) and toggle-calltips (Alt-2)

- Ctrl-. and ctrl-( do not seem to do anything.

** Mystery solved: there was a trace in the calltip logic!

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off. It's been added to a 'later'
section of the to-do list.</t>
<t tx="ekr.20061021144014.411">@nocolor

Added the node: Candidates for settings in myLeoSettings.leo. This lists the
most 'controversial' settings in leoSetting.leo, and is a quick-start to
creating myLeoSettings.leo."
</t>
<t tx="ekr.20061021144014.412">- Added shift-ctrl keys to extend the selection.
focus-to-body = Alt-D
focus-to-tree = Alt-T
toggle-extend-mode = Alt-3</t>
<t tx="ekr.20061021144014.413">@nocolor

By: tibi ( Thiébaut Champenier ) 
 inserting a new node   
2004-02-13 13:23  

 Hi,

When doing ctrl+i I on the node that has children I would prefer Leo to insert the new node as the last children instead of the first. It just makes more sense to me, for exemple when you take a big file and cut it in subnodes you typically start at the top and create new nodes while paging down the file.
What do you think ?
To try it just make this little change:
RCS file: /cvsroot/leo/leo/src/leoCommands.py,v
retrieving revision 1.76
diff -r1.76 leoCommands.py
2516c2516
&lt; v = current.insertAsNthChild(0)
---
&gt; v = current.insertAsLastChild()

What I did:
    
Added @bool insert_new_nodes_at_end

@color</t>
<t tx="ekr.20061029091751.1"></t>
<t tx="ekr.20061029091751.2"></t>
<t tx="ekr.20061029091751.3">def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
</t>
<t tx="ekr.20061029091751.4">def initSettingsFiles (self):
    
    """Set self.globalConfigFile, self.homeFile and self.myConfigFile."""
    
    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    
    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        else:
            setattr(self,ivar,None)
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)</t>
<t tx="ekr.20061029091751.5">def readSettingsFiles (self,fileName,verbose=True):
        
    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    &lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
    # Read all .leoRecentFiles.txt files.
    # The order of files in this list affects the order of the recent files list.
    seen = []
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()

    self.inited = True
    self.setIvarsFromSettings(None)</t>
<t tx="ekr.20061029091751.6"># This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None</t>
<t tx="ekr.20061029091751.7"></t>
<t tx="ekr.20061029091751.8">def createRecentFiles (self):
    
    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created %s' % (fileName),color='red')
                return
            except Exception:
                g.es_print('can not create %s' % (fileName),color='red')
                g.es_exception()</t>
<t tx="ekr.20061029091751.9">def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
    
        print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)
            
    return ok</t>
<t tx="ekr.20061029091751.10">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                print ('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
</t>
<t tx="ekr.20061029091751.11">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
</t>
<t tx="ekr.20061029091811"></t>
<t tx="ekr.20061029091811.1"></t>
<t tx="ekr.20061029091811.2"></t>
<t tx="ekr.20061029091811.3">Typing in leoDocs.leo will show the problem.</t>
<t tx="ekr.20061029091811.4">def skip_string(s,i,verbose=True):
    
    '''Scan forward to the end of a string.
    New in Leo 4.4.2 final: give error only if verbose is True'''
    
    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')
    
    n = len(s)
    while i &lt; n and s[i] != delim:
        if s[i] == '\\' : i += 2
        else: i += 1

    if i &gt;= n:
        if verbose:
            g.scanError("Run on string: " + s[j:i])
    elif s[i] == delim:
        i += 1

    # g.trace(s[j:i])
    return i
</t>
<t tx="ekr.20061029091811.5">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = self.editWidget(event)
    if not w: return 'break'

    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w) or (None,None)
    oldText = name.startswith('body') and p.bodyString() or ''
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    brackets = self.openBracketsList + self.closeBracketsList
    inBrackets = g.toUnicode(ch,g.app.tkEncoding) in brackets
    
    if trace: g.trace(name,repr(ch),ch in brackets)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)
        if inBrackets and self.flashMatchingBrackets: # New in 4.4.1.
           self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'
        
    # New in 4.4.1: Set the column for up and down keys.
    spot = w.index('insert')
    c.editCommands.setMoveCol(spot)

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20061029091811.6">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    if (
        (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
        undoType != "Change"
    ):
        # No auto-indent if in @nocolor mode or after a Change command.
        self.updateAutoIndent(p,w)
</t>
<t tx="ekr.20061029091811.7">def test_selfInsertCommand(self):
    
    self = c.editCommands
    event = g.Bunch(char='É',keysym=None,widget=c.frame.body.bodyCtrl)
    self.selfInsertCommand(event)</t>
<t tx="ekr.20061029091811.8">def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
</t>
<t tx="ekr.20061029091811.9">def flashMatchingBracketsHelper (self,w,index,ch):

    s = g.app.gui.getAllText(w)
    i = g.app.gui.toPythonIndex(s,w,index)
    
    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        j = g.app.gui.toGuiIndex(s,w,j)
        self.flashCharacter(w,j)
</t>
<t tx="ekr.20061029091811.10">def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    def addFlashCallback(w,count,index):
        w.tag_add('flash',index,'%s+1c' % (index))
        w.after(delay,removeFlashCallback,w,count-1,index)
    
    def removeFlashCallback(w,count,index):
        w.tag_remove('flash','1.0','end')
        if count &gt; 0:
            w.after(delay,addFlashCallback,w,count,index)

    try:
        w.tag_configure('flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass
</t>
<t tx="ekr.20061029091811.11">def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
</t>
<t tx="ekr.20061029091811.12"># By David McNab:
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = w.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        w.insert("insert",ws)
</t>
<t tx="ekr.20061029091811.13">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
</t>
<t tx="ekr.20061029091811.14">def skip_matching_python_delims(s,i,delim1,delim2,reverse=False):
    
    '''Skip from the opening delim to the matching delim2.
    
    Return the index of the matching ')', or -1'''
    
    level = 0 ; n = len(s)
    assert(g.match(s,i,delim1))
    if reverse:
         while i &gt;= 0:
            ch = s[i]
            if ch == delim1:
                level += 1 ; i -= 1
            elif ch == delim2:
                level -= 1
                if level &lt;= 0:  return i
                i -= 1
            # Doesn't handle strings and comments properly...
            else: i -= 1
    else:
        while i &lt; n:
            progress = i
            ch = s[i]
            if ch == delim1:
                level += 1 ; i += 1
            elif ch == delim2:
                level -= 1
                if level &lt;= 0:  return i
                i += 1
            elif ch == '\'' or ch == '"': i = g.skip_string(s,i,verbose=False)
            elif g.match(s,i,'#'):  i = g.skip_to_end_of_line(s,i)
            else: i += 1
            if i == progress: return -1
    return -1
</t>
<t tx="ekr.20061029091811.15">@nocolor
@language python

http://sourceforge.net/forum/message.php?msg_id=3971242
By: nobody

I just tried to use mod_shadow plugin the first time and it took me sometime
to figure out that I immediately triggered a bug.

The problem is, that I use c++ as programming language, but leo only provides an
\@language c directive. This is OK for colorizing, but it prevents the mod_shadow
plugin to derive the correct file name extension from the language directive (at
least that´s what I guessed from the error messages). To fix it I simply copied
all c language entries in leoApp.py to create cpp new similar cpp language
entries. I have not tried to understand the code that triggers this error in
detail, so I don´t know if this fixes all issues, but at least it seems to work
at the moment.

@color</t>
<t tx="ekr.20061029091811.16"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "cpp" : "// /* */",# C++.
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "cpp" : "cpp",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
</t>
<t tx="ekr.20061029091811.17"></t>
<t tx="ekr.20061029091811.18">def regexHelper (self,s,i,j,pattern,backwards,nocase):
   
    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1
        
    if backwards: # Scan to the last match.
        last_mo = None
        while 1:
            mo = re_obj.search(s,i,j)
            if mo is None: break
            i = mo.end()
            last_mo = mo
        self.match_obj = mo = last_mo
    else:
        self.match_obj = mo = re_obj.search(s,i,j)
        
    if mo is None:
        return -1, -1
    else:
        k  = mo.start()
        k2 = mo.end()
        if 0:
            g.trace('i: %d, j: %d k: %d, k2: %d, s[k:k2]: %s, len(s): %d, s[-1]: %s,' % (
                i,j,k,k2,repr(s[k:k2]),len(s),repr(s[-1])))
        # g.trace('groups',mo.groups())
        if k == k2:
            return -1, -1 # A non-empty pattern can match an empty string.  Move on!
        else:
            return k, k2
</t>
<t tx="ekr.20061029091811.19">@nocolor

Two body editors open looking at the same node, so you can write 
code at the bottom of the body based on something close to the top. 
Let's say the top pane's showing a data structure defined a page or 
so down from the start of the body, and the bottom pane's showing a
method you're writing at the bottom on the body.

As soon as you enter a character in the bottom pane the point of 
view of the top pane snaps back to the first line of the body, no 
damage caused but now you can't see the datastructure definition you 
were using for reference.

This probably indicates that the body should be split into more than 
one node... but thought I'd let you know it was doing that anyway.

--------------

Still something funky I'm afraid.  Two body panes one above the 
other looking at the same body text.

Say each one is displaying 10 lines.

In one I scroll down to view lines 80-90 by dragging the scroll bar 
on the right, but when I click line 85 to position the cursor it 
jumps to line 5.

@color</t>
<t tx="ekr.20061029091811.20">def selectEditor(self,w):
    
    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.app.gui.widget_name(w),id(w),g.callers())
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
    # Inactivate the previously active editor.
    # Don't capture ivars here! selectMainEditor keeps them up-to-date.
    for key in d.keys():
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = g.app.gui.getInsertPoint(w2)
            w2.leo_selection = g.app.gui.getSelectionRange(w2)
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            break
    else:
        if trace: g.trace('no active editor!')
    
    # Careful, leo_p may not exist.
    if not c.positionExists(w.leo_p):
        if trace: g.trace('does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v == w.leo_v:
                w.leo_p = p2.copy()
                break
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            if trace: g.trace('previously deleted node')
            return 'break'

    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
    c.recolor_now()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'</t>
<t tx="ekr.20061029091811.21"># g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    g.app.gui.setInsertPoint(w,w.leo_insertSpot)
    w.see(w.leo_insertSpot)
else:
    g.app.gui.setInsertPoint(w,'1.0')
    
if w.leo_scrollBarSpot:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)

if w.leo_selection:
    try:
        start,end = w.leo_selection
        g.app.gui.setSelectionRange(w,start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20061029091811.22">def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        c.frame.body.onClick(event) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol &lt;= xcol &lt;= jcol)
        if icol &lt;= xcol &lt;= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        if trace: g.trace('val:',val)
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
</t>
<t tx="ekr.20061029091811.23">def onClick (self,event):
    
    c = self.c ; k = c.k
    w = event and event.widget
    wname = c.widget_name(w)
    
    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        x, y = event.x, event.y
        k.previousSelection = g.app.gui.getSelectionRange(w)
        i = w.index('@%s,%s' % (x,y))
        # g.trace(x,y,i)
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')</t>
<t tx="ekr.20061029091811.24">def createTextWidget (self,frame,parentFrame,p,name):
    
    c = self.c
    
    parentFrame.configure(bg='LightSteelBlue1')

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = w = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    
    def yscrollCallback(x,y,bodyBar=bodyBar,w=w):
        # g.trace(x,y)
        if hasattr(w,'leo_scrollBarSpot'):
            w.leo_scrollBarSpot = (x,y)
        return bodyBar.set(x,y)
   
    body['yscrollcommand'] = yscrollCallback # bodyBar.set

    bodyBar['command'] =  body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = body.leo_p.v
    w.leo_active = True
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w</t>
<t tx="ekr.20061029091811.25">@nocolor

The new colorizer was innocent: the problem is that at.directiveKind4 uses leoColor.leoKeywords,
so multipath must add entroes to leoColor.leoColors.

This should be changed, but it is too late in the development cycle to do more than put a band-aid on the problem.

@color</t>
<t tx="ekr.20061029091811.26">def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))
        
    # Rewritten 6/8/2005.
    if i+1 &gt;= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if not s[i+1].isalpha():
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective
    
    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
</t>
<t tx="ekr.20061029091811.27">def test_directiveKind4 (self):
    
    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))
</t>
<t tx="ekr.20061029091811.28"># leoKeywords is used by directivesKind, so it should be a module-level symbol.

# leoKeywords must be a list so that plugins may alter it.

leoKeywords = [
    "@","@all","@c","@code","@color","@comment",
    "@delims","@doc","@encoding","@end_raw",
    "@first","@header","@ignore",
    "@killcolor",
    "@language","@last","@lineending",
    "@nocolor","@noheader","@nowrap","@others",
    "@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
    "@silent","@tabwidth","@terse",
    "@unit","@verbose","@wrap" ]
</t>
<t tx="ekr.20061029091811.29"># The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i &lt; n:
        if s[i] == '@' and i+1 &lt; n:
            &lt;&lt; set theDict for @ directives &gt;&gt;
        elif root and g.match(s,i,"&lt;&lt;"):
            &lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;
        i = g.skip_line(s,i)
    return theDict
</t>
<t tx="ekr.20061029091811.30">j = g.skip_c_id(s,i+1)
word = s[i+1:j]

global globalDirectiveList

if word in globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
</t>
<t tx="ekr.20061029091811.31">@ The following looks for chunk definitions of the form &lt; &lt; * &gt; &gt; =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i &lt; n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,"&gt;&gt;="):
        # &lt; &lt; * &gt; &gt; = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
</t>
<t tx="ekr.20061029091811.32">@ 

New colorizer did not handle @&lt;newline&gt; properly.
(It required a space after the '@').</t>
<t tx="ekr.20061029091811.33">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3975898

If the setting "@int initial_window_left" has a value of 0 (zero), leo starts
up without showing a single pane.

@color</t>
<t tx="ekr.20061029091811.34">def setInitialWindowGeometry(self):
    
    """Set the position and size of the frame to config params."""
    
    c = self.c

    h = c.config.getInt("initial_window_height") or 500
    w = c.config.getInt("initial_window_width") or 600
    x = c.config.getInt("initial_window_left") or 10
    y = c.config.getInt("initial_window_top") or 10
    
    if h and w and x and y:
        self.setTopGeometry(w,h,x,y)
</t>
<t tx="ekr.20061029091811.35">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3978307
By: johnmwhite

The auto-creation of .leoRecentFiles.txt doesn't seem to work. Everything is
fine if myLeoSettings.leo is in the home directory along with .leoRecentFiles.txt,
but strange things happen if .leoRecentFiles.txt does not exist.

----

I simply removed a very misleading message in writeRecentFiles.</t>
<t tx="ekr.20061029091811.36"></t>
<t tx="ekr.20061029091811.37">def computeGlobalConfigDir():
    
    # None of these suppresses warning about sys.leo_config_directory
    # __pychecker__ = '--no-objattrs --no-modulo1 --no-moddefvalue'
    
    import leoGlobals as g
    
    encoding = g.startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")
        
    if theDir:
        theDir = g.os_path_abspath(theDir)
        
    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None
    
    return theDir
</t>
<t tx="ekr.20061029091811.38">def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) &gt; 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
</t>
<t tx="ekr.20061029091811.39">def computeLeoDir ():
    
    loadDir = g.app.loadDir
    
    g.app.leoDir = theDir = g.os_path_dirname(loadDir)
    
    if theDir not in sys.path:
        sys.path.append(theDir)
        
    if 0: # This is required so we can do import leo (as a package)
        theParentDir = g.os_path_dirname(theDir)
        if theParentDir not in sys.path:
            sys.path.append(theParentDir)
</t>
<t tx="ekr.20061029091811.40">def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        ### import leo
        import sys
        
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__ # was leo.__file__
        if sys.platform=='win32':
            if len(path) &gt; 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_abspath(path,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
</t>
<t tx="ekr.20061029091811.41">def computeStandardDirectories():
    
    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''
    
    if 0:
        import sys
        for s in sys.path: g.trace(s)
    
    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.
        
    g.app.leoDir = g.computeLeoDir()
    
    g.app.homeDir = g.computeHomeDir()
    
    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))
    
    g.app.globalConfigDir = g.computeGlobalConfigDir()
    
    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))
        
    g.app.user_xresources_path = g.os_path_join(g.app.homeDir,'.leo_xresources')
</t>
<t tx="ekr.20061029091811.42">def startupEncoding ():
    
    import leoGlobals as g
    import sys
    
    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding
        
    return encoding
</t>
<t tx="ekr.20061029091811.43"></t>
<t tx="ekr.20061029091811.44">def createRecentFiles (self):
    
    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created %s' % (fileName),color='red')
                return
            except Exception:
                g.es_print('can not create %s' % (fileName),color='red')
                g.es_exception()</t>
<t tx="ekr.20061029091811.45">def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
    
        print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)
            
    return ok</t>
<t tx="ekr.20061029091811.46">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                print ('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
</t>
<t tx="ekr.20061029091811.47">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
</t>
<t tx="ekr.20061029091811.48"></t>
<t tx="ekr.20061029091811.49">@nocolor

See the node Users Guide--&gt;Chapter 18: Emacs and Leo in LeoDocs.leo for full details.</t>
<t tx="ekr.20061029091811.50"># It is set by tkFrame.finishCreate</t>
<t tx="ekr.20061029091811.51">def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame</t>
<t tx="ekr.20061029091811.52">def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    app = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    &lt;&lt; compute the window title &gt;&gt;

    # Create an unfinished frame to pass to the commanders.
    frame = app.gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.
        
    frame.finishCreate(c)
    c.finishCreate()
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
</t>
<t tx="ekr.20061029091811.53"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
</t>
<t tx="ekr.20061029091811.54">def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            k = c.k
            k and k.setInputState(k.unboundKeyAction)
            if c.config.getBool('outline_pane_has_initial_focus'):
                c.treeWantsFocusNow()
            else:
                c.bodyWantsFocusNow()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20061029091811.55">def run(fileName=None,pymacs=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    if pymacs:
        script = windowFlag = False
    else:
        script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    &lt;&lt; start psycho &gt;&gt;
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
</t>
<t tx="ekr.20061029091811.56"># Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
</t>
<t tx="ekr.20061029091811.57">try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20061029091811.58">if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        g.app.use_psyco = False
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
        g.app.use_psyco = False
</t>
<t tx="ekr.20061029091811.59">def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0</t>
<t tx="ekr.20061029091811.60">def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
</t>
<t tx="ekr.20061029091811.61">def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
</t>
<t tx="ekr.20061029091811.62">def getBatchScript ():
    
    import leoGlobals as g
    windowFlag = False
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script, windowFlag
</t>
<t tx="ekr.20061029091811.63">def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
</t>
<t tx="ekr.20061029091811.64">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3980193

What I'm needing is 2 commands:

1) move cursor to the end of the current word (if cursor is in a word) or end
of next word (if cursor is not in a word), WITHOUT SELECTING - the functionality
of Ctrl-RtArrow in normal editors

2) extend selection from current cursor position to the end of the current or
next word - the functionality of Shift-Ctrl-RtArrow in normal editors.

EKR: The term 'normal' editor is misleading.  There are two different ways of moving forward:
forward-word and forward-end-word.

@color</t>
<t tx="ekr.20061029091811.65">def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char',
        'back-&amp;paragraph',
        'back-&amp;sentence',
        'back-&amp;word',
        '-',
        'beginning-of-&amp;buffer',
        'beginning-of-&amp;line',
        '-',
        'pre&amp;vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char-extend-selection',
        'back-&amp;paragraph-extend-selection',
        'back-&amp;sentence-extend-selection',
        'back-&amp;word-extend-selection',
        '-',
        'beginning-of-&amp;buffer-extend-selection',
        'beginning-of-&amp;line-extend-selection',
        '-',
        'pre&amp;vious-line-extend-selection',
    ]
    
    self.cursorMenuExtendTable = [
        # &amp;: l,p,s,w
        'extend-to-&amp;line',
        'extend-to-&amp;paragraph',
        'extend-to-&amp;sentence',
        'extend-to-&amp;word',
    ]
    
    self.cursorMenuForwardTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer',
        'end-of-&amp;line',
        '-',
        'forward-&amp;char',
        'forward-&amp;paragraph',
        'forward-&amp;sentence',
        'forward-&amp;end-word',
        'forward-&amp;word',
        '-',
        '&amp;next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer-extend-selection',
        'end-of-&amp;line-extend-selection',
        '-',
        'forward-&amp;char-extend-selection',
        'forward-&amp;paragraph-extend-selection',
        'forward-&amp;sentence-extend-selection',
        'forward-&amp;end-word-extend-selection',
        'forward-&amp;word-extend-selection',#
        '-',
        '&amp;next-line-extend-selection',    
    ]</t>
<t tx="ekr.20061029091811.66">def getPublicCommands (self):        

    c = self.c ; k = self.k 

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-lines':                          self.cleanLines,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'cycle-all-focus':                      self.cycleAllFocus,
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20061029091811.67">def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)
    
def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)
        
def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20061029091811.68">def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return
    
    c.widgetWantsFocusNow(w)
    s = w.get('1.0','end') ; n = len(s)

    def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
    def toPython (i): return g.app.gui.toPythonIndex(s,w,i)

    i = toPython(w.index('insert'))
    
    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
            i -= 1
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i -= 1
        i += 1
    
    self.moveToHelper(event,toGui(i),extend)</t>
<t tx="ekr.20061029091811.69">def runEditCommandTest (c,p):
    
    u = testUtils(c) ; atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.headString()
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)
    
    work,before,after = u.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.headString()
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.headString()[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    
    c.beginUpdate()
    try:
        c.selectPosition(work)
        c.setBodyString(work,before.bodyString())
        g.app.gui.setTextSelection(w,sel1[0],sel1[1])
        c.k.simulateCommand(commandName)
        s1 = work.bodyString() ; s2 = after.bodyString()
        assert s1 == s2, 'expected body: %s, got: %s' % (repr(s1),repr(s2))
        sel3 = g.app.gui.getTextSelection(w)
        assert sel2 == sel3, 'expected sel: %s, got: %s' % (sel2,sel3)
        c.selectPosition(atTest)
        atTest.contract()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20061029091830"></t>
<t tx="ekr.20070105153901">@language c
@nocolor</t>
<t tx="ekr.20070105153901.1">Storage allocation is crucial to any compiler because of the number, size and
complexity of data which must be allocated. You would not be far off to say that
a compiler consists of storage allocation and everything else. Indeed, the
design of CC2 was driven by the goal of creating the token list quickly, and
that goal has far-reaching implications for how memory is allocated.

CC2 allocates objects one-at-a-time (simple allocation), in blocks of
fixed-sized objects (block allocation) or in blocks of variable-sized objects
(stream allocation). Simple allocation requires just a single macro call, but
results in a call to calloc for each object allocated. It is appropriate only
for infrequently allocated data structures. Block allocation and stream
allocation are optimizations which reduce calls to calloc by more than an order
of magnitude.
</t>
<t tx="ekr.20070105153901.2">I have recently made some discoveries concerning storage allocation and register
allocation that promise to significantly improve CC2. These discoveries were
surprising because they seemed to contradict either common sense or conclusions
based on performance measurements. Happily, the new code is significantly
smaller and measurably faster than the old code!

These discoveries can be summarized as follows:

- There is no speed penalty for having the stream reservation macros use a
  subroutine to allocate a new stream block. This came as a shock, though the
  reason is clear in retrospect.

- Streams are polymorphic: they may contain items of varying types.

- Streams are defined primarily by their lifetime and only secondarily by their type.

- Lists are special-purpose streams.

- Abbreviation macros highlight relationships among source text, while removing
  the actual source text from view.
</t>
<t tx="ekr.20070105153901.3">Block allocation allocates an array of items all of the same size and kind from
a area of memory obtained from calloc. In the front end, hash table nodes and
some kinds of tokens are allocated using block allocation. Block allocation will
be used extensively in the parser and code generator to allocate nodes for
parsing, semantic analysis and code generation.
</t>
<t tx="ekr.20070105153901.4">Stream allocation allocates a stream block, then adds variable-sized items to
the block until the stream block is nearly full, at which time another stream
block is allocated. Steam blocks contain a stream avail count to keep track of
what is in the stream. The first unused portion of the stream block is
calculated from the stream avail count.

The definition of "nearly full" depends on the individual stream. Because stream
allocation is tricky, the details are hidden by two sets of macros. **Stream
reservation macros** allocate another stream block when the current block is
nearly full. **Stream put macros** add an element to the stream without checking
to see if the stream block is big enough to hold it. I shall speak of stream put
macros being protected by stream reservation macros. Because of differences
between streams, there are separate reservation and put macros for each distinct
stream. While tokenize uses stream allocation for both tokens and streams, the
details of stream allocation for tokens and streams differ substantially.

Tokens form a packed list--tokens usually follow one right after another.
Packing the list eliminates the need for a next token pointer and saves a lot of
space. At the end of a token block a HIDDEN_END_BLOCK_TOK is inserted so that
the next token in the token list can be found. Therefore, a token block is
"almost full" when there is no longer room for an arbitrary token and a
HIDDEN_END_BLOCK_TOK. Tokens have a maximum size, BIG_TOKEN_SIZE. Since
HIDDEN_END_BLOCK_TOK is a big token, a token block is "almost full" when less
than 2 * BIG_TOKEN_SIZE bytes remain.

Strings are handled differently from tokens because strings may be arbitrarily
large but are not part of a list. sreserve_macro is the stream reservation macro
for the string stream. scopy_macro and big_scopy_macro are the put macros for
the string stream.

Huge strings are strings larger than the size of the string space in a string
block. big_scopy_macro allocates string space for huge tokens, creating a block
just big enough to hold the huge string. Such a block does not contain avail or
used counts. big_scopy_macro need not be protected since it always creates its
own string block. By the way, huge strings are seldom allocated now that
multi-line comments are split into one COMMENT_TOK per line.

Normal strings, i.e., strings smaller than the size of a stream block, are
allocated by the scopy_macro. A string block is "almost full" when the next
string to be allocated will not fit in the current block. This wastes some space
if the string to be allocated is large and the current block is almost empty but
not empty enough. Fortunately, large strings are rare so I have ignored this
waste.

The extra work involved in using stream reserve and put macros produces a
spectacular increase in speed of tokenize. Among the benefits:

- Crucial pointers may be allocated in registers throughout the lifetime of
  tokenize. These registers are never unloaded because there are no function calls
  inside tokenize!

- The compiler is able to generate perfect code without doing any global
  optimization. Local code optimization is sufficient to produce code as good as
  would be produced by an excellent assembly language coder.

- There are no get-next-character or put_next_token routines. Earlier versions
  of tokenize, using such routines, ran more than 5 times slower than the present
  version.

- Storage is allocated in uniformly sized blocks, not in small pieces. This
  keeps calloc happy.
</t>
<t tx="ekr.20070105153901.5">tokenize is called in a variety of contexts: to tokenize the main file, header
files, pasted strings, and command-line #define's and #undef's. Many calls to
tokenize create short token lists so it would be very wasteful for tokenize to
create new token and string blocks each time it was called. Also, the hash table
must be retained between calls so that all variables with the same spelling have
the same pointer to the spelling table. The global variables tok_block_list,
str_block_list and sym_hash_list are used to keep track of the current token,
string and hash blocks, respectively.

The compiler allocates strings for several purposes outside of tokenize. Such
strings could often be allocated in a string block, but that would be clumsy.
The str_alloc macros allocate a list object big enough to hold the list pointer
and the actual string.  We put strings on a list so they can be deallocated easily...
</t>
<t tx="ekr.20070105153901.6">**The proper time to specify when an object will be deallocated is when the object
if created**. This simple rule was a big Aha.

All object allocation macros take a parameter specifying a deallocation list. If
the parameter is non-NULL, the allocation macro places the newly created object
on the list. Objects on deallocation lists are freed in the following places:

- At the end of cpp. All preprocessing objects not part of the token list are
  freed here.

- In comp_free_all. Objects which are logically part of the token list may only
  be freed when the entire source file has been compiled. comp_free_all is
  called at the start of compile in the production version of the compiler, and
  it is called at the end of compile in the debugging version. In the debugging
  version we want to make sure that all objects are eventually freed. In the
  production version, the objects used by the last compiled file need never be
  freed, a small time gain.

Objects are placed on no deallocation list in the following situations:
		
- When object are deallocated in the routine in which they are allocated. This
  is seldom used, since most such objects can be allocated on the stack.
  Variable-length objects could be freed in this way.
		
- The ap_first and ap_last arrays are allocated in mac_get_actuals but freed in
  mac_expand.
</t>
<t tx="ekr.20070105153901.7">Debugging objects and production objects are allocated, used and freed in
exactly the same way. However, debugging objects provide increased statistics
and error-checking capabilities. Debugging objects are created by the object
macros when the OBJ_DEBUG compile-time constant is defined. Otherwise,
production objects are created.

Debugging objects contain several fields not found in production objects:

- Lists fields: All debugging objects are placed on lists. These lists ensure
  that obj_free frees only objects. These lists are also used to check the
  integrity of all objects.

- Statistics fields.

- Header and trailer protection fields. These fields are filled with a fixed bit
  pattern when the object is allocated. The fields are checked on request, and
  certainly when the object is freed. This provides an excellent, though not
  foolproof, test for over-writing a buffer allocated by calloc. Using these
  protection fields has found some bugs that otherwise would have been really
  tough to find.
</t>
<t tx="ekr.20070105153901.8">The original treserve_macro was too large to include in each call to put_id_tok,
put_small_tok, etc. The macro was large because I wanted to avoid a
function call here. Similar kinds of function calls had grossly slowed down
previous versions of tokenize. However, I was surprised when measurements showed
that a function call here does not matter at all. So the new version of
treserve_macro, called tok_protect_macro, is::

	#define tok_protect_macro(tp, tavail)\
	if (tavail &lt; MAX_TOKEN_SIZE) {\
		tp = tok_new_block(tp, tavail);\
		tavail = tok_avail;\
	}

The tok_new_block allocates a new token block, sets two global variables,
tok_ptr and tok_avail and returns tok_ptr.

In retrospect, it is clear why a function call is acceptable here. tok_new_block
is called when a new block of tokens is required. An average token comprises
almost exactly 4 characters and there are about 200 tokens per block so
tok_new_block is called only about once every 800 input characters. The function
that had previously slowed down tokenize so much was called once every input
character. Clearly, the overhead of calling tok_new_block is 3 orders of
magnitude smaller.

Because tok_protect_macro is so much smaller than treserve_macro,
tok_protect_macro can be made part of the various stream put macros, such as
put_small_tok.  This ensures that tok_protect_macro is called as needed.

Using function calls in allocation macros creates opportunities for more
simplifications. The put_comment_string_macro no longer exists--tokenize simply
calls str_copy2block, which handles all the details::

	/* Output a comment string token */
	put_ptr(WS_COMMENT_TOK,str_copy2block(string_start, string_length), comments);
 
Simplifying the code to allocate strings created more opportunities to simplify
the code...
</t>
<t tx="ekr.20070105153901.9">Global variables [nowadays we would use ivars of stream classes] drastically
simplify defining a stream. Especially in the back end, streams are used across
numerous functions so there is no possibility of keeping important stream
variables in registers anyway. This was an Aha--defining a stream involves
defining a complex of global variables. [Nowadays we would make each stream a
class.] For instance, the globals [ivars] needed to define the string stream
are::

	string_block * str_block_list = NULL; /* List of string blocks. */
	long	 str_avail = 0;	  /* Available bytes in current block. */
	char * str_ptr = NULL;	/* Pointer to first free byte. */

These variables are all controlled by str_copy2block, so they are benign. In
addition to these essential stream variables, it is useful to define global
stream statistics::

	long	str_blocks; /* Total allocated string blocks. */
	long	str_bytes;		/* Total bytes in strings. */
	long	str_number;	/* Number of strings. */
	long	str_waste;		/* Total wasted bytes. */

Previous schemes required a different kind of block for every kind of allocated
item. Actually allocating an item from such a block was clumsy. There is a much
better way. If global variables are used to keep track of streams, it became
clear that streams themselves have a global nature. [Nowadays we would have
global instances of stream objects.] In addition, both the token stream and the
string stream deals with variable size items, so streams may be composed of a
variety of different **kinds** of items.

If streams may contain different kinds of items, what determines which items go
in which streams? The answer is so simple: a stream is defined by its lifetime,
i.e., when the whole stream is deallocated.

Looking back at the documentation on storage allocation, I am struck by the
section called Deallocating Objects. My subconscious was apparently telling me
that when objects were deallocated was more important than I consciously
realized at the time. This section is not just describing how to free objects;
it tells us how to define streams! In short::

    Streams may contain items of varying sizes and types
    as long as all items of a stream are deallocated at the same time,
    i.e., if all items have the same lifetime.

In practice, it may be convenient to have several streams that are deallocated
at the same time.
</t>
<t tx="ekr.20070105153901.10">The CC2 compiler uses a separate stream (the cs stream) for all items to be in
comp_free_all at the end of compile phase. The cs_ptr and cs_avail global
variables are just like the str_ptr and str_avail variables. The cs_put,
cs_protect and cs_new_block macros suffice to allocate any kind of item that
share this lifetime.

Let's look ahead to the parser and code generator. There will be a parser stream
that contains all parse nodes and other nodes that will be freed at the same
time as the parse tree. The code stream will contain all code nodes. Defining
and using these streams will be trivial and will comprise essentially all the
storage allocation for the back end.

The new storage allocation scheme also guarantees absolute highest storage
allocation speed. Indeed, allocating a new parse or code node will require only
one function call per about 200 nodes, so the call-return overhead in calling
cs_new_block can be ignored. It is also clear that the other processing done by
the cs_put macro can not be reduced further, even if written in assembly
language. These discoveries drastically reduce the design, coding and testing
required to allocated and free objects.
</t>
<t tx="ekr.20070105153901.11">Objects in the front end are on only one list, their deallocation list.
Sometimes the deallocation list does double duty, but the fact remains that each
object appears on only one list.

Objects in the back end, however, may be on several lists simultaneously. For
instance, nodes in a parse tree may be threaded. Many overlapping lists of
symbols may need to be maintained. To maintain these lists separate list nodes
will be required. These will be called cons nodes after LISP terminology. The
definition of a cons node will be something like::

	typedef struct cons_struct cons_node;
	struct const_struct {
		void * cons_next;
		void * cons_item;
	}
	
Thousands of such nodes will be needed throughout the back end. Clearly, cons
nodes should be allocated in list blocks to speed the storage allocation
process. When should list blocks be deallocated? The surprising answer is:
usually never. In other words, cons nodes have permanent lifetime. Cons nodes
will be allocated in a special purpose stream, the cons stream.

The cons_new_block macro allocates a new block of cons_nodes and puts them on
an avail list. When an individual cons node is freed, it is simply added to a
list of free cons nodes. Thus, in general list blocks will contain both free and
used cons nodes. cons_new_block is called only when no free cons nodes exist.
List blocks need never be deallocated because free cons nodes will eventually be
reused--unless the number of cons nodes grows truly enormous, there should never
be a need for garbage collection.

There may be some instances when it would save time to deallocate all the cons
nodes of a specialized stream at once. In that case, the cons nodes would be
allocated using a specialized version of the new_cons_node macro.
</t>
<t tx="ekr.20070105153901.12">We could, in fact, allocate *all* items using streams, but this would be going
too far. The object routines provide detailed statistics about objects which are
lost when items are allocated from blocks. Also, the object routines provide
important error checking for the stream blocks themselves. Finally, it would be
silly to have to allocate an entire stream when allocating an object once or
twice is all that is needed. Having said that, it seems to me that streams are a
more fundamental implementation concept than objects. All the fancy object
macros seem to be overshadowed by the elegantly simple stream allocation macros.

Whatever the theoretical relationship between objects and streams, this storage
allocation scheme seems perfect:

- Items may be allocated simply and flexibly with minimal time or space overhead.
- Streams can be created easily for special purposes.
- Blocks can be of uniform size so that minimal stress is put on calloc.
- Objects can be used instead of stream items during development for greater error
  detection and greater resolution of statistics.
</t>
<t tx="ekr.20070105153901.13">One final Aha simplifies the tokenize code considerably. Abbreviation macros
formalize a relationship between source text that could not be efficiently
expressed as a function call. For instance, consider the macro::

	#define put_small(a,b) put_small_tok(tp, tavail, a, b)

This macro shows clearly that all calls to put_small_tok in tokenize
will have tp and tavail as parameters. This relationship could be expressed as a
function call, but not efficiently.

Once I saw how to use put_small to hide the constant details of the calls to
put_small_tok, I was able to generalize the concept of abbreviation macros to
similar situations.</t>
<t tx="ekr.20070626112503"></t>
<t tx="ekr.20070626112754.2"></t>
<t tx="ekr.20070626112754.3"></t>
<t tx="ekr.20070626112754.4"></t>
<t tx="ekr.20070626112754.5">Example:

print "\\" + " this is a test"

The escape mechanism must treat an even number of trailing escapes as not an escape.</t>
<t tx="ekr.20070626112754.6">@nocolor

- (fixed) Backspace not handled correcly.
- (fixed) Autocompletion eats one too many characters

@color</t>
<t tx="ekr.20070626112754.7"></t>
<t tx="ekr.20070626112754.8">def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):

    if swapij and backwards: i,j = j,i

    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # g.trace('empty',i,j)
        return -1,-1

    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    return pos,newpos
</t>
<t tx="ekr.20070626112754.9">def regexHelper (self,s,i,j,pattern,backwards,nocase):

    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1

    if backwards: # Scan to the last match.  We must use search here.
        last_mo = None ; i = 0
        while i &lt; len(s):
            mo = re_obj.search(s,i,j)
            if not mo: break
            i += 1 ; last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s,i,j)

    if 0:
        g.trace('i',i,'j',j,'s[i:j]',repr(s[i:j]),
            'mo.start',mo and mo.start(),'mo.end',mo and mo.end())

    while mo and 0 &lt;= i &lt; len(s):
        if mo.start() == mo.end():
            if backwards:
                # Search backward using match instead of search.
                i -= 1
                while 0 &lt;= i &lt; len(s):
                    mo = re_obj.match(s,i,j)
                    if mo: break
                    i -= 1
            else:
                i += 1 ; mo = re_obj.search(s,i,j)
        else:
            self.match_obj = mo
            return mo.start(),mo.end()
    self.match_obj = None
    return -1,-1
</t>
<t tx="ekr.20070626112754.10">def backwardsHelper (self,s,i,j,pattern,nocase,word):

    if nocase:
        s = s.lower() ; pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)

    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            # g.trace(i,j,k)
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        # g.trace(i,j,k)
        if k == -1:
            return -1, -1
        else:
            return k,k+n
</t>
<t tx="ekr.20070626112754.11">@tabwidth 4

def plainHelper (self,s,i,j,pattern,nocase,word):

    # g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
	pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n
</t>
<t tx="ekr.20070626112754.12">def matchWord(self,s,i,pattern):

    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 &lt;= i-1 &lt; len(s) and s[i-1] or '.'
    ch2 = 0 &lt;= i+n &lt; len(s) and s[i+n] or '.'

    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)

    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))

    if isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2:
        return False
    else:
        return True
</t>
<t tx="ekr.20070626112754.13">def replaceBackSlashes (self,s):

    '''Carefully replace backslashes in a search pattern.'''

    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.

    i = 0
    while i + 1 &lt; len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                 s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
</t>
<t tx="ekr.20070626112754.14">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible(c)
    c.beginUpdate()
    try:
        if sparseFind:
            # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
            for p in c.allNodes_iter():
                if not p.isAncestorOf(self.p):
                    p.contract()
                    redraw = True
            for p in self.p.parents_iter():
                if not p.isExpanded():
                    p.expand()
                    redraw = True
        p = self.p
        c.selectPosition(p)
    finally:
        c.endUpdate(redraw)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    c.widgetWantsFocusNow(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20070626112754.15">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3924236

Added unit tests for yank and all kill commands.

@color</t>
<t tx="ekr.20070626112754.16">@nocolor

Several things became clearer after a short walk in the woods:

- It's a little late in the release cycle to mess with undo, so I'm going to put
off work until Leo 4.4.3. The present code is complex, and should be simplified
if possible. However, the potential for harm is too great to make substantial
change now. Given the complexity of the code, *any* change is a substantial
change :-)

- Some problems with undo may actually be just unexpected results. In
particular, undo typing should 'coalesce', only for actual typing: all other
commands that affect body text (cut, copy, yank and kill in particular) should
be independently undoable regardless of undo granularity. Thus, if you cut,
copy, yank or kill text an immediate undo command should restore the text to
what it was before those commands. This probably doesn't happen now, and that
could be the source of some (all??) undo problems.

Edward

P.S. I recently uncovered some more hard bindings in the yank command. Such
bindings must somehow be removed, and certainly are a symptom that yank does not
yet work as in Emacs. This is a separate issue from undo, so discovering this
problem actually simplifies the undo task to come.
</t>
<t tx="ekr.20070626112754.17">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3972170
By: oculog

Step 1 - add some lines...
line 1
line 2
line 3

Step 2 - cut and paste first line to the end
line 2
line 3
line 1

Step 3 - *Copy* and paste first line to the end x2
line 2
line 3
line 1
line 2
line 2

That's it!  The fourth undo doesn't work right.
</t>
<t tx="ekr.20070626112754.18">class killBufferCommandsClass (baseEditCommandsClass):

    '''A class to manage the kill buffer.'''

    @others
</t>
<t tx="ekr.20070626112754.19">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.reset = False

def finishCreate (self):

    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k

    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
</t>
<t tx="ekr.20070626112754.20">def getPublicCommands (self):

    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
</t>
<t tx="ekr.20070626112754.21">def addToKillBuffer (self,text):

    killKeys =(
        '&lt;Control-k&gt;', '&lt;Control-w&gt;',
        '&lt;Alt-d&gt;', '&lt;Alt-Delete', '&lt;Alt-z&gt;', '&lt;Delete&gt;',
        '&lt;Control-Alt-w&gt;')

    k = self.k
    self.reset = True

    # g.trace(repr(text))

    if self.killBuffer and k.stroke in killKeys:
        self.killBuffer [0] = self.killBuffer [0] + text
    else:
        self.killBuffer.insert(0,text)
</t>
<t tx="ekr.20070626112754.22">def backwardKillSentence (self,event):

    '''Kill the previous sentence.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.rfind('.',ins)
    if i == -1: return

    undoType='backward-kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,i) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.23">def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

</t>
<t tx="ekr.20070626112754.24">def clearKillRing (self,event=None):

    '''Clear the kill ring.'''

    self.killBuffer = []
</t>
<t tx="ekr.20070626112754.25">def getClipboard (self,w):

    __pychecker__ = '--no-argsused' # w not used.

    try:
        ctxt = g.app.gui.getTextFromClipboard()
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except:
        g.es_exception()

    return None
</t>
<t tx="ekr.20070626112754.26">def iterateKillBuffer (self):

    while 1:
        if self.killBuffer:
            self.last_clipboard = None
            for z in self.killBuffer:
                if self.reset:
                    self.reset = False
                    break
                yield z
</t>
<t tx="ekr.20070626112754.27">def kill (self,event,frm,to,undoType=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    w.delete(frm,to)
    w.setInsertPoint(frm)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    # g.trace(i,j,ins,len(s),repr(s[i:j]))
    if ins &gt;= len(s) and g.match(s,j-1,'\n'): # Kill the trailing newline.
        i = max(0,len(s)-1)
        j = len(s)
    elif j &gt; i+1 and g.match(s,j-1,'\n'): # Kill the line, but not the newline.
        j -= 1
    else: # Kill the newline.
        pass
    self.kill(event,i,j,undoType='kill-line')
</t>
<t tx="ekr.20070626112754.28">def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)

def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return

    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    # self.removeRKeys(w)
</t>
<t tx="ekr.20070626112754.29">def killSentence (self,event):

    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins)
    if i == -1: return

    undoType='kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,ins) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.30">def killWs (self,event,undoType=None):

    ws = ''
    w = self.editWidget(event)
    if not w: return

    while 1:
        s = w.get('insert')
        if s in (' ','\t'):
            w.delete('insert')
            ws = ws + s
        else:
            break

    if ws:
        if undoType: self.beginCommand(undoType=undoType)
        self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.31">def yank (self,event):

    '''Insert the next entry in the kill ring at the insert point.'''

    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    i = w.getInsertPoint()
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        self.beginCommand(undoType='yank')
        self.reset = True
        s = clip_text or self.kbiterator.next()
        w.tag_delete('kb')
        w.insert(i,s) # Insert the text, marked with the 'kb' tag.
        w.tag_add('kb',w.toGuiIndex(i),w.toGuiIndex(i+len(s)))
        w.setInsertPoint(i+len(s))
        c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.32">def yankPop (self,event):

    '''Replaces the just-yanked kill buffer with the contents of the previous kill buffer.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    t,t1 = g.convertPythonIndexToRowCol(s,ins)
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        s = clip_text or self.kbiterator.next()
        r = w.tag_ranges('kb') ###
        if r:
            r1,r2 = r
            r1,r2 = w.toPythonIndex(r1),w.toPythonIndex(r2)
            if r1 == ins:
                w.delete(r1,r2)
        w.tag_delete('kb') ###
        w.insert('insert',s,('kb')) ###
        w.setInsertPoint(ins)
</t>
<t tx="ekr.20070626112754.33">def zapToCharacter (self,event):

    '''Kill characters from the insertion point to a given character.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        ch = event and event.char or ' '
        k.resetLabel()
        k.clearState()
        if ch.isspace(): return
        s = w.getAllText()
        ins = w.getInsertPoint()
        i = s.find(ch,ins)
        if i == -1: return
        self.beginCommand(undoType='zap-to-char')
        self.addToKillBuffer(s[ins:i])
        w.setAllText(s[:ins] + s[i:])
        w.setInsertPoint(ins)
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.34">def undoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
</t>
<t tx="ekr.20070626112754.35">def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
</t>
<t tx="ekr.20070626112754.36">def undoRedoText (self,p,
    leading,trailing, # Number of matching leading &amp; trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    &lt;&lt; Compute the result using p's body text &gt;&gt;
    p.setTnodeText(result)
    w.setAllText(result)
    c.frame.body.recolor(p,incremental=False)
</t>
<t tx="ekr.20070626112754.37"># Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading &gt; 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
    s.extend(oldMidLines)
if trailing &gt; 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result
</t>
<t tx="ekr.20070626112754.38">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3991369

The bindings to f.f.OnControlKeyDown/Up were mistakenly deleted in createOuterFrames.

@color</t>
<t tx="ekr.20070626112754.39">def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.

    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)

    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("&lt;Button-1&gt;", f.OnActivateLeoEvent)

    f.top.bind("&lt;Control-KeyPress&gt;",f.OnControlKeyDown)
    f.top.bind("&lt;Control-KeyRelease&gt;",f.OnControlKeyUp)

    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    # f.top.bind("&lt;Activate&gt;",f.OnActivateLeoEvent)
    # f.top.bind("&lt;Deactivate&gt;",f.OnDeactivateLeoEvent)

    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")</t>
<t tx="ekr.20070626112754.40"></t>
<t tx="ekr.20070626112754.41">def endDrag (self,event):

    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        &lt;&lt; set vdrag, childFlag &gt;&gt;
        if self.allow_clone_drags:
            if not self.look_for_control_drag_on_mouse_down:
                self.controlDrag = c.frame.controlKeyIsDown

        redrawFlag = vdrag and vdrag.v.t != p.v.t
        if redrawFlag: # Disallow drag to joined node.
            &lt;&lt; drag p to vdrag &gt;&gt;
        elif self.trace and self.verbose:
            g.trace("Cancel drag")

        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate(redrawFlag)
        c.recolor_now() # Dragging can affect coloring.
</t>
<t tx="ekr.20070626112754.42">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
</t>
<t tx="ekr.20070626112754.43"># g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
</t>
<t tx="ekr.20070626112754.44"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):

    """The official helper of the onDrag event handler."""

    c = self.c ; canvas = self.canvas

    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    # g.trace('self.controlDrag',self.controlDrag)
    if self.allow_clone_drags:
        self.controlDrag = c.frame.controlKeyIsDown
        if self.look_for_control_drag_on_mouse_down:
            if self.enable_drag_messages:
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
</t>
<t tx="ekr.20070626112754.45">def onContinueDrag(self,event):

    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            &lt;&lt; scroll the canvas as needed &gt;&gt;
    except:
        g.es_event_exception("continue drag")
</t>
<t tx="ekr.20070626112754.46"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y &lt; 0 or y &gt; h:
    lo, hi = frame.canvas.leo_treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)

    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.canvas.leo_treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
</t>
<t tx="ekr.20070626112754.47">def onDrag(self,event):

    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()

    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)

    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
</t>
<t tx="ekr.20070626112754.48">def onEndDrag(self,event):

    """Tree end-of-drag handler called from vnode event handler."""

    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()

    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
</t>
<t tx="ekr.20070626112754.49"></t>
<t tx="ekr.20070626112754.50">selectEditorLockout = False

def selectEditor(self,w):

    '''Select editor w and node w.leo_p.'''

    #  Called by body.onClick and whenever w must be selected.

    if self.selectEditorLockout or w and self.bodyCtrl == w: return

    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(w)
    finally:
        self.selectEditorLockout = False

    return val # Don't put a return in a finally clause.

</t>
<t tx="ekr.20070626112754.51">def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    if 0:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    self.inactivateActiveEditor(w)

    # The actual switch.
    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return 'break'

    if 0:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    c.frame.tree.expandAllAncestors(w.leo_p)
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls assignPositionToEditor.
    c.recolor_now()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'</t>
<t tx="ekr.20070626112754.52"># g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)

if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20070626112754.53">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4112347
By: niccl

I've just found two places where Tk 8.5 breaks Leo:
Two calls to CheckVersion, with tk_patchlevel as a parameter, in leoTkInterGui.py.

Since Tk 8.5 isn't formally released, the patch level is 8.5a5 (at least in
the version I'm using). CheckVersion expects everything to be a digit, and so
barfs on the 5a5. I solved it very crudely by scanning the string returned when
getting the tk_patchlevel and stopping if there's any non-digit and non '.'.
That way I end up with '8.5' as the string to go to check version, and it works
fine.

@color</t>
<t tx="ekr.20070626112754.54"># Simplified version by EKR: stringCompare not used.

def CheckVersion (s1,s2,condition="&gt;=",stringCompare=None,delimiter='.',trace=False):

    vals1 = [g.CheckVersionToInt(s) for s in s1.split(delimiter)] ; n1 = len(vals1)
    vals2 = [g.CheckVersionToInt(s) for s in s2.split(delimiter)] ; n2 = len(vals2)
    n = max(n1,n2)
    if n1 &lt; n: vals1.extend([0 for i in xrange(n - n1)])
    if n2 &lt; n: vals2.extend([0 for i in xrange(n - n2)])
    for cond,val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('&lt;',  vals1 &lt;  vals2), ('&lt;=', vals1 &lt;= vals2),
        ('&gt;',  vals1 &gt;  vals2), ('&gt;=', vals1 &gt;= vals2),
    ):
        if condition == cond:
            result = val ; break
    else:
        raise EnvironmentError,"condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='."

    if trace:
        # print '%10s' % (repr(vals1)),'%2s' % (condition),'%10s' % (repr(vals2)),result
        print '%7s' % (s1),'%2s' % (condition),'%7s' % (s2),result
    return result</t>
<t tx="ekr.20070626112754.55">def CheckVersionToInt (s):

    try:
        return int(s)
    except ValueError:
        aList = []
        for ch in s:
            if ch.isdigit(): aList.append(ch)
            else: break
        if aList:
            s = string.join(aList)
            return int(s)
        else:
            return 0</t>
<t tx="ekr.20070626112754.56">if g.unitTesting:

    assert g.CheckVersionToInt('12') == 12,'fail 1'
    assert g.CheckVersionToInt('2a5') == 2, 'fail 2'
    assert g.CheckVersionToInt('b2') == 0, 'fail 3'</t>
<t tx="ekr.20070626112754.57"></t>
<t tx="ekr.20070626112754.58"># The problem was that the unit test code must now specify the initial insert point.</t>
<t tx="ekr.20070626112754.59">def backToIndentation (self,event):

    '''Position the point at the first non-blank character on the line.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='back-to-indentation')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    while i &lt; j and s[i] in (' \t'):
        i += 1
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.60">def runEditCommandTest (c,p):

    u = testUtils(c) ; atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.headString()
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)

    work,before,after = u.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.headString()
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.headString()[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    #g.trace(repr(sels))

    c.beginUpdate()
    try:
        c.selectPosition(work)
        c.setBodyString(work,before.bodyString())
        #g.trace(repr(sel1[0]),repr(sel1[1]))
        w.setSelectionRange(sel1[0],sel1[1],insert=sel1[1])
        c.k.simulateCommand(commandName)
        s1 = work.bodyString() ; s2 = after.bodyString()
        assert s1 == s2, 'mismatch in body\nexpected: %s\n     got: %s' % (repr(s2),repr(s1))
        sel3 = w.getSelectionRange()
        ins = w.toGuiIndex(w.getInsertPoint())
        #g.trace('ins',ins,'s1[j:...]',repr(s1[j:j+10]))
        # Convert both selection ranges to gui indices.
        sel2_orig = sel2
        # g.trace(w)
        i,j = sel2 ; sel2 = w.toGuiIndex(i),w.toGuiIndex(j)
        i,j = sel3 ; sel3 = w.toGuiIndex(i),w.toGuiIndex(j)
        assert sel2 == sel3, 'mismatch in sel\nexpected: %s = %s, got: %s' % (sel2_orig,sel2,sel3)
        c.selectPosition(atTest)
        atTest.contract()
    finally:
        c.endUpdate(False) # Don't redraw.</t>
<t tx="ekr.20070626112754.61">def setInsertPoint (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    # g.trace(i,g.callers())
    Tk.Text.mark_set(w,'insert',i)
</t>
<t tx="ekr.20070626112754.62">def setSelectionRange (self,i,j,insert=None): # tkTextWidget

    w = self

    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())

    # g.trace('i,j,insert',i,j,repr(insert))
    if Tk.Text.compare(w,i, "&gt;", j): i,j = j,i
    Tk.Text.tag_remove(w,"sel","1.0",i)
    Tk.Text.tag_add(w,"sel",i,j)
    Tk.Text.tag_remove(w,"sel",j,"end")

    if insert is not None:
        w.setInsertPoint(insert)
</t>
<t tx="ekr.20070626112754.63"></t>
<t tx="ekr.20070626112754.64">def toGuiIndex (self,i):
    '''Convert a Python index to a Tk index as needed.'''
    w = self
    if i is None:
        g.trace('can not happen: i is None',g.callers())
        return '1.0'
    elif type(i) == type(99):
        # This *must* be 'end-1c', even if other code must change.
        s = Tk.Text.get(w,'1.0','end-1c')
        row,col = g.convertPythonIndexToRowCol(s,i)
        i = '%s.%s' % (row+1,col)
        # g.trace(len(s),i,repr(s))
    else:
        try:
            i = Tk.Text.index(w,i)
        except Exception:
            # g.es_exception()
            g.trace('Tk.Text.index failed:',repr(i),g.callers())
            i = '1.0'
    return i</t>
<t tx="ekr.20070626112754.65">def toPythonIndex (self,i):
    '''Convert a Tk index to a Python index as needed.'''
    w =self
    if i is None:
        g.trace('can not happen: i is None')
        return 0
    elif type(i) in (type('a'),type(u'a')):
        s = Tk.Text.get(w,'1.0','end') # end-1c does not work.
        i = Tk.Text.index(w,i) # Convert to row/column form.
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(s,row,col)
        #g.es_print(i)
    return i
</t>
<t tx="ekr.20070626112754.66"># This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):

    return '%s.%s' % (row+1,col)</t>
<t tx="ekr.20070626112754.67">@nocolor

- There was a call to t.setSelectionRanget(t,...)
- No progress is being made in change, then find.

@color</t>
<t tx="ekr.20070626112754.68">def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.

    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()

    s = w.getAllText()
    # g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)
    # g.trace('pos,newpos',pos,newpos)
    if pos == -1: return None,None
    &lt;&lt; fail if we are passed the wrap point &gt;&gt;
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)
    return pos,newpos
</t>
<t tx="ekr.20070626112754.69">if self.wrapping and self.wrapPos is not None and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos &lt; self.wrapPos:
        # g.trace("wrap done")
        return None, None

    if not self.reverse and newpos &gt; self.wrapPos:
        return None, None
</t>
<t tx="ekr.20070626112754.70"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    oldSel = sel = w.getSelectionRange()
    start,end = sel
    if start &gt; end: start,end = end,start
    if start == end:
        g.es("No text selected") ; return False

    # g.trace(start,end)

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text

    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)

    for w2 in (w,self.s_ctrl):
        if start != end: w2.delete(start,end)
        w2.insert(start,change_text)
        w2.setInsertPoint(g.choose(self.reverse,start,start+len(change_text)))

    # Update the selection for the next match.
    w.setSelectionRange(start,start+len(change_text))
    c.widgetWantsFocus(w)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
        if self.mark_changes:
            p.setMarked()
        if self.in_headline:
            c.frame.tree.onHeadChanged(p,'Change')
        else:
            c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.

    return True
</t>
<t tx="ekr.20070626112754.71">def makeRegexSubs(self,s,groups):

    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''

    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j &lt; n:
        k = s.find('\\',j)
        if k == -1 or k + 1 &gt;= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn &lt; len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
</t>
<t tx="ekr.20070626112754.72"></t>
<t tx="ekr.20070626112754.73">def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    w = self.editWidget(event)
    if not w: return 'break'
    &lt;&lt; set local vars &gt;&gt;
    #g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i &gt; j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:

            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
</t>
<t tx="ekr.20070626112754.74">c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch and ch in brackets)</t>
<t tx="ekr.20070626112754.75">def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()</t>
<t tx="ekr.20070626112754.76">def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'

    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
</t>
<t tx="ekr.20070626112754.77">def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
</t>
<t tx="ekr.20070626112754.78">def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
</t>
<t tx="ekr.20070626112754.79">def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins&lt;len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
</t>
<t tx="ekr.20070626112754.80">def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.scanColorDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
</t>
<t tx="ekr.20070626112754.81">def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i &lt;= j.

    if i != j:
        w.delete(i,j)

    if tab_width &gt; 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]

        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)</t>
<t tx="ekr.20070626112754.82">def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75): # tkTextWidget.

    w = self

    def addFlashCallback(w,count,index):
        # g.trace(count,index)
        i,j = w.toGuiIndex(index),w.toGuiIndex(index+1)
        Tk.Text.tag_add(w,'flash',i,j)
        Tk.Text.after(w,delay,removeFlashCallback,w,count-1,index)

    def removeFlashCallback(w,count,index):
        # g.trace(count,index)
        Tk.Text.tag_remove(w,'flash','1.0','end')
        if count &gt; 0:
            Tk.Text.after(w,delay,addFlashCallback,w,count,index)

    try:
        Tk.Text.tag_configure(w,'flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass ; g.es_exception()</t>
<t tx="ekr.20070626112754.83">def findMatchingBracket (self,event=None):

    '''Select the text between matching brackets.'''

    c = self ; w = c.frame.body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}&lt;&gt;"
    s = w.getAllText()
    ins = w.getInsertPoint()
    ch1 = 0 &lt;= ins-1 &lt; len(s) and s[ins-1] or ''
    ch2 = 0 &lt;= ins   &lt; len(s) and s[ins] or ''
    # g.trace(repr(ch1),repr(ch2),ins)

    # Prefer to match the character to the left of the cursor.
    if ch1 and ch1 in brackets:
        ch = ch1 ; index = max(0,ins-1)
    elif ch2 and ch2 in brackets:
        ch = ch2 ; index = ins
    else:
        return

    index2 = self.findMatchingBracketHelper(s,ch,index)
    # g.trace('index,index2',index,index2)
    if index2 is not None:
        if index2 &lt; index:
            w.setSelectionRange(index2,index+1,insert=index2) # was insert=index2+1
            # g.trace('case 1',s[index2:index+1])
        else:
            w.setSelectionRange(index,index2+1,insert=min(len(s),index2+1))
            # g.trace('case2',s[index:index2+1])
        w.see(index2)
    else:
        g.es("unmatched %s" % repr(ch))</t>
<t tx="ekr.20070626112754.84"># To do: replace comments with blanks before scanning.
# Test  unmatched())
def findMatchingBracketHelper(self,s,ch,index):

    c = self
    open_brackets  = "([{&lt;" ; close_brackets = ")]}&gt;"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    # g.trace('index',index,'ch',repr(ch),'brackets',brackets)
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    else:
        return None
    # g.trace('index',index,'ch',repr(ch),'match_ch',repr(match_ch))
    level = 0
    while 1:
        if forward and index &gt;= len(s):
            # g.trace("not found")
            return None
        ch2 = 0 &lt;= index &lt; len(s) and s[index] or ''
        # g.trace('forward',forward,'ch2',repr(ch2),'index',index)
        if ch2 == ch:
            level += 1
        if ch2 == match_ch:
            level -= 1
            if level &lt;= 0:
                return index
        if not forward and index &lt;= 0:
            # g.trace("not found")
            return None
        index += g.choose(forward,1,-1)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
</t>
<t tx="ekr.20070626112754.85"></t>
<t tx="ekr.20070626112754.86"></t>
<t tx="ekr.20070626112754.87">def backwardDeleteCharacter (self,event=None):

    '''Delete the character to the left of the cursor.'''

    c = self.c ; p = c.currentPosition()
    w = self.editWidget(event)
    if not w: return

    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = g.scanDirectives(c,p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width &gt; 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                &lt;&lt; backspace with negative tab_width &gt;&gt;
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
</t>
<t tx="ekr.20070626112754.88">s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
</t>
<t tx="ekr.20070626112754.89">@nocolor

- Typing return in calltips should work as in autocompletion:
  Don't wipe out the suggested text.

- (done) Suppress scrolling of body pane!
  The problem was the call to c.setBodyString().

- (done) Make sure to recolor text at end.

@color
</t>
<t tx="ekr.20070626112754.90"># The problem was in a special case (for only one line) in g.convertPythonIndexToRowCol
# This special case is now covered in the unit test.</t>
<t tx="ekr.20070626112754.91"></t>
<t tx="ekr.20070626112754.92">def getEditableTextRange (self):

    k = self ; w = self.widget
    s = w.getAllText()
    # g.trace(len(s),repr(s))

    i = len(k.mb_prefix)
    j = len(s)
    return i,j</t>
<t tx="ekr.20070626112754.93"></t>
<t tx="ekr.20070626112754.94">def convertPythonIndexToRowCol (s,i):

    '''Convert index i into string s into zero-based row/col indices.'''

    if not s or i &lt;= 0:
        return 0,0

    i = min(i,len(s))

    # works regardless of what s[i] is
    row = s.count('\n',0,i) # Don't include i
    if row == 0:
        return row,i
    else:
        prevNL = s.rfind('\n',0,i) # Don't include i
        # g.trace('prevNL',prevNL,'i',i,g.callers())
        return row,i-prevNL-1
</t>
<t tx="ekr.20070626112754.95">def convertRowColToPythonIndex (s,row,col):

    '''Convert zero-based row/col indices into a python index into string s.'''

    if row &lt; 0: return 0

    lines = g.splitLines(s)

    if row &gt;= len(lines):
        return len(s)

    col = min(col, len(lines[row]))

    prev = 0
    for line in lines[:row]:
        prev += len(line)

    return prev + col
</t>
<t tx="ekr.20070626112754.96"></t>
<t tx="ekr.20070626112754.97">def setEditLabelState (self,p,selectAll=False): # selected, editing

    c = self.c ; w = c.edit_widget(p)

    if p and w:
        # g.trace('*****',g.callers())
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        selectAll = selectAll or self.select_all_text_when_editing_headlines
        if selectAll:
            w.setSelectionRange(0,'end',insert='end')
        else:
            w.setInsertPoint('end') # Clears insert point.
    else:
        g.trace('no edit_widget')

setNormalLabelState = setEditLabelState # For compatibility.
</t>
<t tx="ekr.20070626112754.98">def setHeadlineText (self,theId,w,s):

    """All changes to text widgets should come here."""

    __pychecker__ = '--no-argsused' # theId not used.

    # if self.trace_alloc: g.trace('%4d %6s %s' % (theId,self.textAddr(w),s),align=-20)

    state = w.cget("state")
    if state != "normal":
        w.configure(state="normal")
    w.delete(0,"end")
    # Important: do not allow newlines in headlines.
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    w.insert("end",s)
    # g.trace(repr(s))
    if state != "normal":
        w.configure(state=state)
</t>
<t tx="ekr.20070626112754.99">def updateHead (self,event,w):

    '''Update a headline from an event.

    The headline officially changes only when editing ends.'''

    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i

    # g.trace('w',w,'ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i-1,i-1,insert=i-1)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20070626112754.100"></t>
<t tx="ekr.20070626112754.101">def onIconBoxClick (self,event,p=None):

    c = self.c ; tree = self

    if not p: p = self.eventToPosition(event)
    if not p: return

    c.setLog()

    if self.trace and self.verbose: g.trace()

    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel()
        tree.select(p,scroll=False)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)

    return "break" # disable expanded box handling.
</t>
<t tx="ekr.20070626112754.102"></t>
<t tx="ekr.20070626112754.103">@nocolor
@

What I did:

- u.undo and u.redo call c.setCurrentPosition(c.currentPosition()) instead of c.selectPosition(c.currentPosition())
    This accomplishes what is wanted without interfering with selection range.

- u.undoTyping and u.redoTyping now call w.setSelectionRange, i.e., they act directly on w.

@color</t>
<t tx="ekr.20070626112754.104">class baseUndoer:
    """The base class of the undoer class."""
    @others

class undoer (baseUndoer):
    """A class that implements unlimited undo and redo."""
    pass
</t>
<t tx="ekr.20070626112754.105">def __init__ (self,c):

    self.c = c
    self.debug = False # True: enable debugging code in new undo scheme.
    self.debug_print = False # True: enable print statements in debug code.

    self.granularity = c.config.getString('undo_granularity')
    if self.granularity: self.granularity = self.granularity.lower()
    if self.granularity not in ('node','line','word','char'):
        self.granularity = 'line'
    # g.trace('undoer',self.granularity)

    self.max_undo_stack_size = c.config.getInt('max_undo_stack_size') or 0

    # Statistics comparing old and new ways (only if self.debug is on).
    self.new_mem = 0
    self.old_mem = 0

    # State ivars...
    self.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    self.redoMenuLabel = "Can't Redo"
    self.undoMenuLabel = "Can't Undo"
    self.realRedoMenuLabel = "Can't Redo"
    self.realUndoMenuLabel = "Can't Undo"
    self.undoing = False # True if executing an Undo command.
    self.redoing = False # True if executing a Redo command.

    # New in 4.2...
    self.optionalIvars = []</t>
<t tx="ekr.20070626112754.106">def clearIvars (self):

    u = self

    u.p = None # The position/node being operated upon for undo and redo.

    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
</t>
<t tx="ekr.20070626112754.107"></t>
<t tx="ekr.20070626112754.108">def cutStack (self):

    u = self ; n = u.max_undo_stack_size

    if n &gt; 0 and u.bead &gt;= n and not g.app.unitTesting:

        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i &gt;= 0:
            bunch = u.beads[i]
            if hasattr(bunch,'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads))
</t>
<t tx="ekr.20070626112754.109">def getBead (self,n):

    '''Set undoer ivars from the bunch at the top of the undo stack.'''

    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None

    bunch = u.beads[n]

    self.setIvarsFromBunch(bunch)

    return bunch
</t>
<t tx="ekr.20070626112754.110">def peekBead (self,n):

    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None
    bunch = u.beads[n]
    # g.trace(n,len(u.beads),bunch)
    return bunch
</t>
<t tx="ekr.20070626112754.111">def pushBead (self,bunch):

    u = self

    # New in 4.4b2:  Add this to the group if it is being accumulated.
    bunch2 = u.bead &gt;= 0 and u.bead &lt; len(u.beads) and u.beads[u.bead]

    if bunch2 and hasattr(bunch2,'kind') and bunch2.kind == 'beforeGroup':
        # Just append the new bunch the group's items.
        bunch2.items.append(bunch)
    else:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]
        # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

        # Recalculate the menu labels.
        u.setUndoTypes()
</t>
<t tx="ekr.20070626112754.112">def setIvarsFromBunch (self,bunch):

    u = self

    u.clearIvars()

    if 0: # Debugging.
        print '-' * 40
        keys = bunch.keys()
        keys.sort()
        for key in keys:
            g.trace(key,bunch.get(key))
        print '-' * 20

    for key in bunch.keys():
        val = bunch.get(key)
        # g.trace(key,val)
        setattr(u,key,val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)
</t>
<t tx="ekr.20070626112754.113">def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    __pychecker__ = '--no-argsused' # Ignore all unused arguments here.

    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.

    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.

    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.

    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''

    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
</t>
<t tx="ekr.20070626112754.114">def redoMenuName (self,name):

    if name=="Can't Redo":
        return name
    else:
        return "Redo " + name

def undoMenuName (self,name):

    if name=="Can't Undo":
        return name
    else:
        return "Undo " + name
</t>
<t tx="ekr.20070626112754.115"># These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    # g.trace(theType,g.callers())
    u = self ; frame = u.c.frame

    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'

    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel

def setUndoType (self,theType):
    # g.trace(theType,g.callers())

    u = self ; frame = u.c.frame
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
</t>
<t tx="ekr.20070626112754.116">def setUndoTypes (self):

    u = self

    # g.trace(g.callers(7))

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")

    u.cutStack()
</t>
<t tx="ekr.20070626112754.117">def restoreTree (self,treeInfo):

    """Use the tree info to restore all vnode and tnode data,
    including all links."""

    u = self

    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
</t>
<t tx="ekr.20070626112754.118">def restoreVnodeUndoInfo (self,bunch):

    """Restore all ivars saved in the bunch."""

    v = bunch.v

    v.statusBits = bunch.statusBits
    v._parent    = bunch.parent
    v._next      = bunch.next
    v._back      = bunch.back

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
</t>
<t tx="ekr.20070626112754.119">def restoreTnodeUndoInfo (self,bunch):

    t = bunch.t

    t.headString  = bunch.headString
    t.bodyString  = bunch.bodyString
    t.vnodeList   = bunch.vnodeList
    t.statusBits  = bunch.statusBits
    t._firstChild = bunch.firstChild

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        t.unknownAttributes = uA
        t._p_changed = 1
</t>
<t tx="ekr.20070626112754.120">def saveTree (self,p,treeInfo=None):

    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    &lt;&lt; about u.saveTree &gt;&gt;

    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v.t))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
</t>
<t tx="ekr.20070626112754.121">@ 
The old code made a free-standing copy of the tree using v.copy and t.copy.  This looks "elegant" and is WRONG.  The problem is that it can not handle clones properly, especially when some clones were in the "undo" tree and some were not.   Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to properly restore the vnodes and tnodes.  It creates a list of tuples, on tuple for each vnode in the tree.  Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the nodes.  The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to the old v.copy and t.copy methods.

Aside:  Prior to 4.2 Leo used a scheme that was equivalent to the createUndoInfoDict info, but quite a bit uglier.
</t>
<t tx="ekr.20070626112754.122">def createVnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode for undo."""

    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parent     = v._parent,
        next       = v._next,
        back       = v._back,
        # The tnode never changes so there is no need to save it here.
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
</t>
<t tx="ekr.20070626112754.123">def createTnodeUndoInfo (self,t):

    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        t = t,
        headString = t.headString,
        bodyString = t.bodyString,
        vnodeList  = t.vnodeList[:],
        statusBits = t.statusBits,
        firstChild = t._firstChild,
    )

    if hasattr(t,'unknownAttributes'):
        bunch.unknownAttributes = t.unknownAttributes

    return bunch
</t>
<t tx="ekr.20070626112754.124">def trace (self):

    ivars = ('kind','undoType')

    for ivar in ivars:
        print ivar, getattr(self,ivar)
</t>
<t tx="ekr.20070626112754.125">def updateMarks (self,oldOrNew):

    '''Update dirty and marked bits.'''

    u = self ; c = u.c

    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    dirty   = g.choose(isOld,u.oldDirty,  u.newDirty)
    marked  = g.choose(isOld,u.oldMarked, u.newMarked)
    changed = g.choose(isOld,u.oldChanged,u.newChanged)

    if dirty:   u.p.setDirty(setDescendentsDirty=False)
    else:       u.p.clearDirty()

    if marked:  c.setMarked(u.p)
    else:       c.clearMarked(u.p)

    u.c.setChanged(changed)
</t>
<t tx="ekr.20070626112754.126"></t>
<t tx="ekr.20070626112754.127"></t>
<t tx="ekr.20070626112754.128">def afterChangeGroup (self,p,undoType,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

    bunch = u.beads[u.bead]
    if bunch.kind == 'beforeGroup':
        bunch.kind = 'afterGroup'
    else:
        g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)

    # Set the types &amp; helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = undoType

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newP = p.copy()
    bunch.newSel = w.getSelectionRange()

    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag

    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
</t>
<t tx="ekr.20070626112754.129">def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node using d created by beforeChangeNode.'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the type &amp; helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBody = p.bodyString()
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newHead = p.headString()
    bunch.newMarked = p.isMarked()
    bunch.newSel = w.getSelectionRange()

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.130">def afterChangeTree (self,p,command,bunch):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the types &amp; helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree

    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = w.getSelectionRange()
    bunch.newText = w.getAllText()
    bunch.newTree = u.saveTree(p)

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.131">def afterClearRecentFiles (self,bunch):

    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]

    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles

    u.pushBead(bunch)

    return bunch
</t>
<t tx="ekr.20070626112754.132">def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types &amp; helpers
    bunch.kind = 'clone'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode

    bunch.newBack = p.back() # 6/15/05
    bunch.newParent = p.parent() # 6/15/05

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.133">def afterDehoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types &amp; helpers
    bunch.kind = 'dehoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDehoistNode
    bunch.redoHelper = u.redoDehoistNode

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.134">def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types &amp; helpers
    bunch.kind = 'delete'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.135">def afterHoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types &amp; helpers
    bunch.kind = 'hoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoHoistNode
    bunch.redoHelper = u.redoHoistNode

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.136">def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types &amp; helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # g.trace(repr(command),g.callers())

    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            t = bunch2.t
            afterTree.append(
                g.Bunch(t=t,head=t.headString[:],body=t.bodyString[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.137">def afterMark (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node for mark and unmark commands.'''

    __pychecker__ = '--no-argsused'
        # 'command' unused, but present for compatibility with similar methods.

    u = self
    if u.redoing or u.undoing: return

    # Set the type &amp; helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark

    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.138">def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set the types &amp; helpers.
    bunch.kind = 'move'
    bunch.undoType = command

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    bunch.newBack   = p.back()
    bunch.newN = p.childIndex()
    bunch.newParent = p.parent()

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.139"></t>
<t tx="ekr.20070626112754.140">def beforeChangeGroup (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command

    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
</t>
<t tx="ekr.20070626112754.141">def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):

    '''Return data that gets passed to afterChangeNode'''

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBody = oldBody or p.bodyString()
    bunch.oldHead = oldHead or p.headString()

    return bunch
</t>
<t tx="ekr.20070626112754.142">def beforeChangeTree (self,p):

    # g.trace(p.headString())

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    bunch = u.createCommonBunch(p)
    bunch.oldSel = w.getSelectionRange()
    bunch.oldText = w.getAllText()
    bunch.oldTree = u.saveTree(p)

    return bunch
</t>
<t tx="ekr.20070626112754.143">def beforeClearRecentFiles (self):

    u = self ; p = u.c.currentPosition()

    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch
</t>
<t tx="ekr.20070626112754.144">def beforeCloneNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    return bunch
</t>
<t tx="ekr.20070626112754.145">def beforeDeleteNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()

    return bunch
</t>
<t tx="ekr.20070626112754.146">def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):

    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone

    if pasteAsClone:
        # Save the list of bunches created by fc.createVnode.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch
</t>
<t tx="ekr.20070626112754.147">def beforeMark (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command

    return bunch
</t>
<t tx="ekr.20070626112754.148">def beforeMoveNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBack = p.back()
    bunch.oldN = p.childIndex()
    bunch.oldParent = p.parent()

    return bunch
</t>
<t tx="ekr.20070626112754.149">def createCommonBunch (self,p):

    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = w.getSelectionRange(),
        p = p.copy(),
    )
</t>
<t tx="ekr.20070626112754.150"># Translation does not affect these routines.

def canRedo (self):

    u = self

    return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

    u = self

    return u.undoMenuLabel != "Can't Undo"
</t>
<t tx="ekr.20070626112754.151">def clearUndoState (self):

    """Clears then entire Undo state.

    All non-undoable commands should call this method."""

    u = self
    u.setRedoType("Can't Redo")
    u.setUndoType("Can't Undo")
    u.beads = [] # List of undo nodes.
    u.bead = -1 # Index of the present bead: -1:len(beads)
    u.clearIvars()
</t>
<t tx="ekr.20070626112754.152">def enableMenuItems (self):

    u = self ; frame = u.c.frame

    menu = frame.menu.getMenu("Edit")
    frame.menu.enableMenu(menu,u.redoMenuLabel,u.canRedo())
    frame.menu.enableMenu(menu,u.undoMenuLabel,u.canUndo())
</t>
<t tx="ekr.20070626112754.153">if 0:
    def getMark (self):

        __pychecker__ = '--no-classattr' # self.bead does, in fact, exist.

        return self.bead

    def rollbackToMark (self,n):

        u = self

        u.bead = n
        u.beads = u.beads[:n+1]
        u.setUndoTypes()

    rollBackToMark = rollbackToMark
</t>
<t tx="ekr.20070626112754.154">def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    __pychecker__ = 'maxlines=2000' # Ignore the size of this method.

    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    u = self ; c = u.c
    trace = False # Can cause unit tests to fail.
    &lt;&lt; return if there is nothing to do &gt;&gt;
    # g.trace(undo_type,g.callers(7))
    &lt;&lt; init the undo params &gt;&gt;
    &lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
    &lt;&lt; save undo text info &gt;&gt;
    &lt;&lt; save the selection and scrolling position &gt;&gt;
    &lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;
    return bunch
</t>
<t tx="ekr.20070626112754.155">if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
</t>
<t tx="ekr.20070626112754.156"># Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
</t>
<t tx="ekr.20070626112754.157">@
Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i &lt; min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i

# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace:
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"
</t>
<t tx="ekr.20070626112754.158">@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
</t>
<t tx="ekr.20070626112754.159">#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
</t>
<t tx="ekr.20070626112754.160">@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
if not p.isDirty():
    bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
</t>
<t tx="ekr.20070626112754.161">@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            &lt;&lt; set newBead if the change does not continue a word &gt;&gt;
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
</t>
<t tx="ekr.20070626112754.162">old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 &gt;= len(old_s) or new_col-1 &gt;= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
</t>
<t tx="ekr.20070626112754.163">def redo (self,event=None):

    '''Redo the operation undone by the last undo.'''

    u = self ; c = u.c
    # g.trace(g.callers(7))

    if not u.canRedo():
        # g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return

    # g.trace(u.undoType)
    # g.trace(u.bead+1,len(u.beads),u.peekBead(u.bead+1))
    u.redoing = True 
    u.groupCount = 0

    c.beginUpdate()
    try:
        c.endEditing()
        if u.redoHelper: u.redoHelper()
        else: g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
    finally:
        if 0: # Don't do this: it interferes with selection ranges.
            # This strange code forces a recomputation of the root position.
            c.selectPosition(c.currentPosition())
        else:
            c.setCurrentPosition(c.currentPosition())
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.bodyWantsFocusNow()
        u.redoing = False
        u.bead += 1
        u.setUndoTypes()</t>
<t tx="ekr.20070626112754.164">def redoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
</t>
<t tx="ekr.20070626112754.165">def redoCloneNode (self):

    u = self ; c = u.c

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.setDirty()

    c.selectPosition(u.newP)
</t>
<t tx="ekr.20070626112754.166">def redoDeleteNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
</t>
<t tx="ekr.20070626112754.167">def redoInsertNode (self):

    u = self ; c = u.c

    # g.trace('newP',u.newP.v,'back',u.newBack,'parent',u.newParent.v)

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()

    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.newP)
</t>
<t tx="ekr.20070626112754.168">def redoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
</t>
<t tx="ekr.20070626112754.169">def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1


    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        c.beginUpdate()
        try:
            for z in bunch.items:
                self.setIvarsFromBunch(z)
                if z.redoHelper:
                    # g.trace(z.redoHelper)
                    z.redoHelper() ; count += 1
                else:
                    g.trace('oops: no redo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)

    u.groupCount -= 1

    for v in dirtyVnodeList:
        v.t.setDirty()

    g.es("redo %d instances" % count)

    c.selectPosition(p)
    newSel and c.frame.body.setSelectionRange(newSel)</t>
<t tx="ekr.20070626112754.170">def redoNodeContents (self):

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    # Restore the body.
    u.p.setTnodeText(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)

    # Restore the headline.
    u.p.initHeadString(u.newHead)
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.

    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)

    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()
</t>
<t tx="ekr.20070626112754.171">def redoMark (self):

    u = self ; c = u.c

    u.updateMarks('new')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.setDirty()

        c.selectPosition(u.p)</t>
<t tx="ekr.20070626112754.172">def redoMove (self):

    u = self ; c = u.c

    # g.trace(u.p)

    if u.newParent:
        u.p.moveToNthChildOf(u.newParent,u.newN)
    elif u.newBack:
        u.p.moveAfter(u.newBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot=oldRoot)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.173">def redoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setSelectionRange(u.newSel)
</t>
<t tx="ekr.20070626112754.174">def undo (self,event=None):

    """Undo the operation described by the undo parameters."""

    u = self ; c = u.c
    # g.trace(g.callers(7))

    if not u.canUndo():
        # g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return

    # g.trace(u.undoType)
    # g.trace(len(u.beads),u.bead,u.peekBead(u.bead))
    u.undoing = True
    u.groupCount = 0

    c.beginUpdate()
    try:
        c.endEditing()
        if u.undoHelper: u.undoHelper()
        else: g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
    finally:
        if 0: # Don't do this: it interferes with selection ranges.
            # This strange code forces a recomputation of the root position.
            c.selectPosition(c.currentPosition())
        else:
            c.setCurrentPosition(c.currentPosition())
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.bodyWantsFocusNow()
        u.undoing = False
        u.bead -= 1
        u.setUndoTypes()</t>
<t tx="ekr.20070626112754.175">def undoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
</t>
<t tx="ekr.20070626112754.176">def undoCloneNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.177">def undoDeleteNode (self):

    u = self ; c = u.c

    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)

    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()
    u.p.setAllAncestorAtFileNodesDirty() # New in 4.4b3.
    c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.178">def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        c.beginUpdate()
        try:
            for z in reversedItems:
                self.setIvarsFromBunch(z)
                # g.trace(z.undoHelper)
                if z.undoHelper:
                    z.undoHelper() ; count += 1
                else:
                    g.trace('oops: no undo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)

    u.groupCount -= 1

    for v in dirtyVnodeList:
        v.t.clearDirty()

    g.es("undo %d instances" % count)

    c.selectPosition(p)
    oldSel and c.frame.body.setSelectionRange(oldSel)</t>
<t tx="ekr.20070626112754.179">def undoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
</t>
<t tx="ekr.20070626112754.180">def undoInsertNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)

    c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.181">def undoMark (self):

    u = self ; c = u.c

    u.updateMarks('old')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.clearDirty()
        c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.182">def undoMove (self):

    u = self ; c = u.c

    # g.trace(u.p,u.oldParent,u.oldN)

    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        u.p.moveToRoot(oldRoot=c.rootPosition())

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.clearDirty()

    c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.183">def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and dirty and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setTnodeText(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)
    c.frame.tree.setHeadline(u.p,u.oldHead) # New in 4.4b2.

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.clearDirty()
</t>
<t tx="ekr.20070626112754.184">def undoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setSelectionRange(u.oldSel)
</t>
<t tx="ekr.20070626112754.185">def undoRedoTree (self,p,new_data,old_data):

    '''Replace p and its subtree using old_data during undo.'''

    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.bodyString())

    return p # Nothing really changes.
</t>
<t tx="ekr.20070626112754.186">def selectPosition(self,p,updateBeadList=True):

    """Select a new position."""

    c = self ; cc = c.chapterController

    if cc:
        cc.selectChapterForPosition(p)

    # g.trace(p.headString(),g.callers())

    c.frame.tree.select(p,updateBeadList)

    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
</t>
<t tx="ekr.20070626112754.187">tree_select_lockout = False

def select (self,p,updateBeadList=True,scroll=True):

    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        val = 'break'
        self.tree_select_lockout = True
        val = self.treeSelectHelper(p,updateBeadList,scroll)
    finally:
        self.tree_select_lockout = False

    return val  # Don't put a return in a finally clause.
</t>
<t tx="ekr.20070626112754.188">#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def treeSelectHelper (self,p,updateBeadList,scroll):

    c = self.c ; frame = c.frame
    body = w = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p:
        # Bug fix: 5/31/07: do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    # g.trace('      ===',id(w),p and p.headString())
    if self.trace_select and not g.app.unitTesting: g.trace('tree',g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p,updateBeadList) # Remember this position.
    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
</t>
<t tx="ekr.20070626112754.189"># Remember the position of the scrollbar before making any changes.
if not body: g.trace('no body!','c.frame',c.frame,'old_p',old_p)

yview = body.getYScrollPosition()
insertSpot = c.frame.body.getInsertPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if c.edit_widget(old_p):
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
</t>
<t tx="ekr.20070626112754.190"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing newlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
w.setAllText(s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    w.setYScrollPosition(first)

if p.v and p.v.t.insertSpot != None:
    spot = p.v.t.insertSpot
    w.setInsertPoint(spot)
    w.see(spot)
else:
    w.setInsertPoint(0)

# g.trace("select:",p.headString())
</t>
<t tx="ekr.20070626112754.191">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.headString())

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.192">def setCurrentPosition (self,p):

    """Set the presently selected position. For internal use only.

    Client code should use c.selectPosition instead."""

    c = self ; cc = c.chapterController

    # g.trace(p.headString(),g.callers())

    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()

        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        newRoot = c.findRootPosition(c._currentPosition)
        if newRoot:
            c.setRootPosition(newRoot)
        # This is *not* an error: newRoot can be None when switching chapters.
        # else: g.trace('******** no new root')
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition</t>
<t tx="ekr.20070626112754.193"># Indent and Undent did not set selection properly.
# Improved setSelectionAreas &amp; getBodyLines: these required subtle changes in several methods.</t>
<t tx="ekr.20070626112754.194">def reformatParagraph (self,event=None):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body ; w = body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    &lt;&lt; compute vars for reformatParagraph &gt;&gt;
    if lines:
        &lt;&lt; compute the leading whitespace &gt;&gt;
        &lt;&lt; compute the result of wrapping all lines &gt;&gt;
        &lt;&lt; update the body, selection &amp; undo state &gt;&gt;</t>
<t tx="ekr.20070626112754.195">theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = w.getAllText()
oldSel =  w.getSelectionRange()
oldYview = body.getYScrollPosition()

head,lines,tail = c.findBoundParagraph()
</t>
<t tx="ekr.20070626112754.196">indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i &lt; len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)

indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
</t>
<t tx="ekr.20070626112754.197">trailingNL = lines and lines[-1].endswith('\n')
lines = [g.choose(z.endswith('\n'),z[:-1],z) for z in lines]

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult)
if trailingNL: result = result + '\n'</t>
<t tx="ekr.20070626112754.198">junk, ins = body.setSelectionAreas(head,result,tail)

# Advance to the next paragraph.
s = w.getAllText()
ins += 1 # Move past the selection.
while ins &lt; len(s):
    i,j = g.getLine(s,ins)
    line = s[i:j]
    if line.startswith('@') or line.isspace():
        ins = j+1
    else:
        ins = i ; break

changed = original != head + result + tail
if changed:
    undoType = g.choose(changed,"Reformat Paragraph",None)
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

w.setSelectionRange(ins,ins,insert=ins)
w.see(ins)
if changed:
    c.recolor()
</t>
<t tx="ekr.20070626112754.199">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview):

    c = self ; body = c.frame.body ; p = c.currentPosition()

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    # Expand the selection.
    head = head or ''
    middle = middle or ''
    tail = tail or ''
    i = len(head)
    j = max(i,len(head)+len(middle)-1)
    newSel = i,j
    body.setSelectionRange(newSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel or newSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.seeInsertPoint()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
</t>
<t tx="ekr.20070626112754.200">def setSelectionAreas (self,before,sel,after):

    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    w = self.bodyCtrl
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0,len(s))
    w.insert(0,before+sel+after)
    i = len(before)
    j = max(i,len(before)+len(sel)-1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i,j,insert=j)
    return i,j
</t>
<t tx="ekr.20070626112754.201">def getBodyLines (self,expandSelection=False):

    """Return head,lines,tail where:

    before is string containg all the lines before the selected text
    (or the text before the insert point if no selection)
    lines is a list of lines containing the selected text (or the line containing the insert point if no selection)
    after is a string all lines after the selected text
    (or the text after the insert point if no selection)"""

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    oldVview = body.getYScrollPosition()

    if expandSelection:
        s = w.getAllText()
        head = tail = ''
        oldSel = 0,len(s)
        lines = g.splitLines(s) # Retain the newlines of each line.
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,s,tail = body.getSelectionLines()
        lines = g.splitLines(s) # Retain the newlines of each line.

        # Expand the selection.
        i = len(head)
        j = max(i,len(head)+len(s)-1)
        oldSel = i,j

    return head,lines,tail,oldSel,oldVview # string,list,string,tuple.
</t>
<t tx="ekr.20070626112754.202">def getSelectionLines (self):

    """Return before,sel,after where:

    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)"""

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return '','',''

    # At present, called only by c.getBodyLines.
    w = self.bodyCtrl
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if i == j:
        i,j = g.getLine(s,i)
    else:
        i,junk = g.getLine(s,i)
        junk,j = g.getLine(s,j)


    before = g.toUnicode(s[0:i],g.app.tkEncoding)
    sel    = g.toUnicode(s[i:j],g.app.tkEncoding)
    after  = g.toUnicode(s[j:len(s)],g.app.tkEncoding)

    # g.trace(i,j,'sel',repr(s[i:j]),'after',repr(after))
    return before,sel,after # 3 strings.
</t>
<t tx="ekr.20070626112754.203">def getInsertLines (self):

    """Return before,after where:

    before is all the lines before the line containing the insert point.
    sel is the line containing the insert point.
    after is all the lines after the line containing the insert point.

    All lines end in a newline, except possibly the last line."""

    w = self.bodyCtrl
    s = w.getAllText()
    insert = w.getInsertPoint()
    i,j = g.getLine(s,insert)
    before = s[0:i]
    ins = s[i:j]
    after = s[j:]

    before = g.toUnicode(before,g.app.tkEncoding)
    ins    = g.toUnicode(ins,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)

    return before,ins,after
</t>
<t tx="ekr.20070626112754.204"></t>
<t tx="ekr.20070626112754.205">def removeBlankLines (self,event):

    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''

    c = self.c
    head,lines,tail,oldSel,oldYview = c.getBodyLines()

    changed = False ; result = []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    result = ''.join(result)

    if changed:
        oldSel = None ; undoType = 'remove-blank-lines'
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20070626112754.206">def convertBlanks (self,event=None):

    '''Convert all blanks to tabs in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Blanks'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
</t>
<t tx="ekr.20070626112754.207">def convertTabs (self,event=None):

    '''Convert all tabs to blanks in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
            s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Tabs'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
</t>
<t tx="ekr.20070626112754.208">def dedentBody (self,event=None):

    '''Remove one tab's worth of indentation from all presently selected lines.'''

    c = self ; current = c.currentPosition() ; undoType='Unindent'

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20070626112754.209">def extract (self,event=None):

    '''Create child node from the elected body text, deleting all selected text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if lines:
        headline = lines[0].strip()
        del lines[0]
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+'\n',None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
        u.afterChangeGroup(current,undoType=undoType)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.210">def extractSection (self,event=None):

    '''Create a section definition node from the selected body text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType='Extract Section'
    current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    &lt;&lt; Set headline for extractSection &gt;&gt;
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
        u.afterChangeGroup(current,undoType=undoType)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.211">if len(headline) &lt; 5:
    oops = True
else:
    head1 = headline[0:2] == '&lt;&lt;'
    head2 = headline[0:2] == '@&lt;'
    tail1 = headline[-2:] == '&gt;&gt;'
    tail2 = headline[-2:] == '@&gt;'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
</t>
<t tx="ekr.20070626112754.212">def extractSectionNames(self,event=None):

    '''Create child nodes for every section reference in the selected text.
    The headline of each new child node is the section reference.
    The body of each child node is empty.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                &lt;&lt; Find the next section name &gt;&gt;
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setSelectionRange(oldSel)
    body.setFocus()
</t>
<t tx="ekr.20070626112754.213">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
    head2 = string.find(s,"&gt;&gt;",head1)
else:
    head1 = string.find(s,"@&lt;")
    if head1 &gt; -1:
        head2 = string.find(s,"@&gt;",head1)

if head1 == -1 or head2 == -1 or head1 &gt; head2:
    name = None
else:
    name = s[head1:head2+2]
</t>
<t tx="ekr.20070626112754.214">def indentBody (self,event=None):

    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; current = c.currentPosition() ; undoType='Indent Region'
    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20070626112754.215">def addComments (self,event=None):

    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; p = c.currentPosition()
    d = g.scanDirectives(c,p)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('No text selected',color='blue')
        return

    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',d3+' '

    # Comment out non-blank lines.
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            result.append(line[0:i]+openDelim+line[i:]+closeDelim)
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
</t>
<t tx="ekr.20070626112754.216">def deleteComments (self,event=None):

    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; p = c.currentPosition()
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return

    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
</t>
<t tx="ekr.20070626112754.217"></t>
<t tx="ekr.20070626112754.218"></t>
<t tx="ekr.20070626112754.219"></t>
<t tx="ekr.20070626112754.220">def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if j2 &lt; len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot &lt; self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()</t>
<t tx="ekr.20070626112754.221">def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    col2 = max(0,min(col,j2-i2-1))
    spot = i2 + col2
    # g.trace('spot',spot,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)</t>
<t tx="ekr.20070626112754.222">def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot &lt; i: spot = i
        elif spot &gt; j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)</t>
<t tx="ekr.20070626112754.223">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i &gt;= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j &gt;= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i &lt; j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 &lt; len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 &lt; len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 &gt; j2: return

    self.moveToHelper(event,i2+1,extend)
</t>
<t tx="ekr.20070626112754.224">def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
            i -= 1
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i -= 1
        i += 1

    self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20070626112754.225">def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    i = w.getInsertPoint()

    while i &gt;= 0:
        if s[i] == '.': break
        i -= 1
    else: return

    j = i-1
    while j &gt;= 0:
        if s[j] == '.':
            j += 1 ; break
        j -= 1
    else: j = 0

    while j &lt; i and s[j].isspace():
        j += 1

    if j &lt; i:
        self.moveToHelper(event,j,extend)
</t>
<t tx="ekr.20070626112754.226">def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins) + 1
    i = min(i,len(s))
    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20070626112754.227">def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1

    # Skip to the next non-blank line.
    i = j
    while j &lt; len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20070626112754.228">def backwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i,j = g.getLine(s,j)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i &gt; 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i &gt; 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20070626112754.229">def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t</t>
<t tx="ekr.20070626112754.230">def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=True)
</t>
<t tx="ekr.20070626112754.231">def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=False)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=True)
</t>
<t tx="ekr.20070626112754.232">def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    g.es('Extend mode %s' % (g.choose(val,'on','off')), color='red')
    c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20070626112754.233">def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange(sort=False)
    if i == j: return

    ins = w.getInsertPoint()
    ins = g.choose(ins==i,j,i)
    w.setInsertPoint(ins)
    w.setSelectionRange(i,j,insert=None)
</t>
<t tx="ekr.20070626112754.234">def extendToLine (self,event):

    '''Select the line at the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
</t>
<t tx="ekr.20070626112754.235">def extendToSentence (self,event):

    '''Select the line at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)</t>
<t tx="ekr.20070626112754.236">def extendToWord (self,event):

    '''Select the word at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
        i -= 1
    while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        i -= 1
    i += 1

    # Move to the end of the word.
    i1 = i
    while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)</t>
<t tx="ekr.20070626112754.237">def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=True)

def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False)

def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
</t>
<t tx="ekr.20070626112754.238">def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)

def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
</t>
<t tx="ekr.20070626112754.239">def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)

def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)

def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)

def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
</t>
<t tx="ekr.20070626112754.240">def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)

def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)

def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)

def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
</t>
<t tx="ekr.20070626112754.241">def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)

def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)

def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)

def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)

def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20070626112754.242"></t>
<t tx="ekr.20070626112754.243"></t>
<t tx="ekr.20070626112754.244"></t>
<t tx="ekr.20070626112754.245"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    c = self.c ; u = c.undoer ; w = c.edit_widget(p)
    if c.suppressHeadChanged: return
    if not w: return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace('changed',changed,'old',repr(oldRevert),'new',repr(s))
        if changed:
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(flag=changed,scroll=False)
            # scroll=False in 4.4.1; flag = changed in 4.4.3.
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
        else:
            c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
</t>
<t tx="ekr.20070626112754.246"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.247">def onHeadlineKey (self,event):

    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # g.trace(repr(ch),g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20070626112754.248">def endEditLabel (self):

    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.k ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None

    # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
    # if k:
        # k.setDefaultUnboundKeyAction()
        # k.showStateAndMode() # Destroys UNL info.

    # Important: this will redraw if necessary.
    self.onHeadChanged(p)

    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.249"></t>
<t tx="ekr.20070626112754.250"># The signature is slightly different than the Tk.Text.insert method.

def tag_add(self,tagName,i,j=None,*args):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.tag_add(w,tagName,i,*args)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.tag_add(w,tagName,i,j,*args)

</t>
<t tx="ekr.20070626112754.251">def extendToParagraph (self,event):

    '''Select the paragraph surrounding the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    # Find the start of the paragraph.
    if line.strip(): # Search backward.
        while i &gt; 0:
            i2,j2 = g.getLine(s,i-1)
            line = s[i2:j2]
            if line.strip(): i = i2
            else: break # Use the previous line.
    else: # Search forward.
        while j &lt; len(s):
            i,j = g.getLine(s,j)
            line = s[i:j]
            if line.strip(): break
        else: return

    # Select from i to the end of the paragraph.
    self.selectParagraphHelper(w,i)
</t>
<t tx="ekr.20070626112754.252">def selectParagraphHelper (self,w,start):

    '''Select from start to the end of the paragraph.'''

    s = w.getAllText()
    i1,j = g.getLine(s,start)
    while j &lt; len(s):
        i,j2 = g.getLine(s,j)
        line = s[i:j2]
        if line.strip(): j = j2
        else: break

    j = max(start,j-1)
    w.setSelectionRange(i1,j,insert=j)
</t>
<t tx="ekr.20070626112754.253">def backwardKillParagraph (self,event):

    '''Kill the previous paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='backward-kill-paragraph')
    try:
        self.backwardParagraphHelper(event,extend=True)
        i,j = w.getSelectionRange()
        if i &gt; 0: i = min(i+1,j)
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.254">def killParagraph (self,event):

    '''Kill the present paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='kill-paragraph')
    try:
        self.extendToParagraph(event)
        i,j = w.getSelectionRange()
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.255"># The text frame somehow was not being packed as usual.</t>
<t tx="ekr.20070626112754.256">def createStatusLine (self):
    if not self.statusLine:
        self.statusLine  = self.statusLineClass(self.c,self.outerFrame)
    return self.statusLine

def clearStatusLine (self):
    self.statusLine and self.statusLine.clear()

def disableStatusLine (self,background=None):
    self.statusLine and self.statusLine.disable(background)

def enableStatusLine (self,background="white"):
    self.statusLine and self.statusLine.enable(background)

def getStatusLine (self):
    return self.statusLine

getStatusObject = getStatusLine

def putStatusLine (self,s,color=None):
    self.statusLine and self.statusLine.put(s,color)

def setFocusStatusLine (self):
    self.statusLine and self.statusLine.setFocus()

def statusLineIsEnabled(self):
    return self.statusLine and self.statusLine.isEnabled()

def updateStatusLine(self):
    self.statusLine and self.statusLine.update()</t>
<t tx="ekr.20070626112754.257">class tkStatusLineClass:

    '''A class representing the status line.'''

    @others
</t>
<t tx="ekr.20070626112754.258">def __init__ (self,c,parentFrame):

    self.c = c
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)

    bg = self.statusFrame.cget("background")
    self.textWidget = w = g.app.gui.bodyTextWidget(
        self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove",name='status-line')
    self.textWidget.pack(side="left",expand=1,fill="x")
    w.bind("&lt;Button-1&gt;", self.onActivate)
    self.show()

    c.frame.statusFrame = self.statusFrame
    c.frame.statusLabel = self.labelWidget
    c.frame.statusText  = self.textWidget
</t>
<t tx="ekr.20070626112754.259">def clear (self):

    w = self.textWidget
    if not w: return

    w.configure(state="normal")
    w.delete(0,"end")
    w.configure(state="disabled")
</t>
<t tx="ekr.20070626112754.260">def disable (self,background=None):

    c = self.c ; w = self.textWidget
    if w:
        if not background:
            background = self.statusFrame.cget("background")
        w.configure(state="disabled",background=background)
    self.enabled = False
    c.bodyWantsFocus()

def enable (self,background="white"):

    # g.trace()
    c = self.c ; w = self.textWidget
    if w:
        w.configure(state="normal",background=background)
        c.widgetWantsFocus(w)
    self.enabled = True

def isEnabled(self):
    return self.enabled</t>
<t tx="ekr.20070626112754.261">def get (self):

    w = self.textWidget
    if w:
        return w.getAllText()
    else:
        return ""
</t>
<t tx="ekr.20070626112754.262">def getFrame (self):

    return self.statusFrame
</t>
<t tx="ekr.20070626112754.263">def onActivate (self,event=None):

    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
</t>
<t tx="ekr.20070626112754.264">def pack (self):

    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)

show = pack
</t>
<t tx="ekr.20070626112754.265">def put(self,s,color=None):

    # g.trace('tkStatusLine',self.textWidget,s)

    w = self.textWidget
    if not w:
        g.trace('tkStatusLine','***** disabled')
        return

    w.configure(state="normal")
    w.insert("end",s)

    if color:
        if color not in self.colorTags:
            self.colorTags.append(color)
            w.tag_config(color,foreground=color)
        w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        w.tag_config("black",foreground="black")
        w.tag_add("black","end")

    w.configure(state="disabled")
</t>
<t tx="ekr.20070626112754.266">def unpack (self):

    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
</t>
<t tx="ekr.20070626112754.267">def update (self):

    c = self.c ; bodyCtrl = c.frame.body.bodyCtrl

    if g.app.killed or not self.isVisible:
        return

    s = bodyCtrl.getAllText()    
    index = bodyCtrl.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,index)
    if col &gt; 0:
        s2 = s[index-col:index]
        s2 = g.toUnicode(s2,g.app.tkEncoding)
        col = g.computeWidth (s2,c.tab_width)

    # Important: this does not change the focus because labels never get focus.
    self.labelWidget.configure(text="line %d, col %d" % (row,col))
    self.lastRow = row
    self.lastCol = col
</t>
<t tx="ekr.20070626112754.268"></t>
<t tx="ekr.20070626112754.269">def selectAllText (self,insert=None): # tkTextWidget

    '''Select all text of the widget, *not* including the extra newline.'''

    w = self ; s = w.getAllText()
    if insert is None: insert = len(s)
    w.setSelectionRange(0,len(s),insert=insert)
</t>
<t tx="ekr.20070626112754.270"></t>
<t tx="ekr.20070626112754.271">def doNowebSecRef (self,s,i):

    c = self.c
    self.tag("nameBrackets",i,i+2)

    # See if the line contains the right name bracket.
    j = s.find(self.rb+"=",i+2)
    k = g.choose(j==-1,2,3)
    if j == -1:
        j = s.find(self.rb,i+2)
    if j == -1:
        return i + 2
    else:
        # includes brackets
        searchName = s[i:j]
        ref = g.findReference(c,searchName,self.p)
        if ref:
            self.tag("link",i+2,j)
            if self.use_hyperlinks:
                &lt;&lt; set the hyperlink &gt;&gt;
        elif k == 3: # a section definition
            self.tag("link",i+2,j)
        else:
            self.tag("name",i+2,j)
        self.tag("nameBrackets",j,j+k)
        return j + k</t>
<t tx="ekr.20070626112754.272"># Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
self.body.tag_delete(tagName)
self.tag(tagName,i+2,j)

ref.tagName = tagName
self.body.tag_bind(tagName,"&lt;Control-1&gt;",ref.OnHyperLinkControlClick)
self.body.tag_bind(tagName,"&lt;Any-Enter&gt;",ref.OnHyperLinkEnter)
self.body.tag_bind(tagName,"&lt;Any-Leave&gt;",ref.OnHyperLinkLeave)
</t>
<t tx="ekr.20070626112754.273"></t>
<t tx="ekr.20070626112754.274">Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 5194, in about
    g.app.gui.runAboutLeoDialog(c,version,theCopyright,url,email)
  File "c:\prog\tigris-cvs\leo\src\leoTkinterGui.py", line 197, in runAboutLeoDialog
    d = leoTkinterDialog.tkinterAboutLeo(c,version,theCopyright,url,email)
  File "c:\prog\tigris-cvs\leo\src\leoTkinterDialog.py", line 203, in __init__
    self.createFrame()
  File "c:\prog\tigris-cvs\leo\src\leoTkinterDialog.py", line 238, in createFrame
    text.insert("end",version,"version")
TypeError: insert() takes exactly 3 arguments (4 given)</t>
<t tx="ekr.20070626112754.275">def createFrame (self):

    """Create the frame for an About Leo dialog."""

    if g.app.unitTesting: return

    frame = self.frame
    theCopyright = self.copyright ; email = self.email
    url = self.url ; version = self.version

    # Calculate the approximate height &amp; width. (There are bugs in Tk here.)
    lines = string.split(theCopyright,'\n')
    height = len(lines) + 8 # Add lines for version,url,email,spacing.
    width = 0
    for line in lines:
        width = max(width,len(line))
    width = max(width,len(url))
    width += 10 # 9/9/02

    frame.pack(padx=6,pady=4)

    self.text = w = g.app.gui.plainTextWidget(
        frame,height=height,width=width,bd=0,bg=frame.cget("background"))
    w.pack(pady=10)

    try:
        bitmap_name = g.os_path_join(g.app.loadDir,"..","Icons","Leoapp.GIF") # 5/12/03
        image = Tk.PhotoImage(file=bitmap_name)
        w.image_create("1.0",image=image,padx=10)
    except Exception:
        pass # This can sometimes happen for mysterious reasons.

    w.insert("end",version) #,tag="version")
    w.tag_add('version','end-%dc' %(len(version)+1),'end-1c')
    w.insert("end",theCopyright) #,tag="copyright")
    w.tag_add('copyright','end-%dc' %(len(theCopyright)+1),'end-1c')
    w.insert("end",'\n')
    w.insert("end",url)
    w.tag_add('url','end-%dc' %(len(url)+1),'end-1c')
    w.insert("end",'\n')
    w.insert("end",email)
    w.tag_add('url','end-%dc' %(len(email)+1),'end-1c')

    w.tag_config("version",justify="center")
    w.tag_config("copyright",justify="center",spacing1="3")
    w.tag_config("url",underline=1,justify="center",spacing1="10")

    w.tag_bind("url","&lt;Button-1&gt;",self.onAboutLeoUrl)
    w.tag_bind("url","&lt;Enter&gt;",self.setArrowCursor)
    w.tag_bind("url","&lt;Leave&gt;",self.setDefaultCursor)

    w.tag_config("email",underline=1,justify="center",spacing1="10")
    w.tag_bind("email","&lt;Button-1&gt;",self.onAboutLeoEmail)
    w.tag_bind("email","&lt;Enter&gt;",self.setArrowCursor)
    w.tag_bind("email","&lt;Leave&gt;",self.setDefaultCursor)

    w.configure(state="disabled")
</t>
<t tx="ekr.20070626112754.276">@nocolor

1. Backspace does not work when there is an end selection

- Edit headline: cursor at end of last character.
- Drag right: apparent whitespace is selected.
- Now can not use backspace key.

The problem was a special case in backwardDeleteCharacter.

2. Select-all does not work properly in headlines.

@color</t>
<t tx="ekr.20070626112754.277"></t>
<t tx="ekr.20070626112754.278"></t>
<t tx="ekr.20070626112754.279">@nocolor

Email from Terry Brown.

I've written a simple plugin such that double clicking any 
headline in a tree with '@bookmarks' as its root will grab the 
url from the first line of the body text.

My problem is that I had to duplicate a lot of code from here:

Code--&gt;Gui Base classes--&gt;@thin leoFrame.py--&gt;class 
leoTree--&gt;tree.OnIconDoubleClick (@url)

specifically this whole piece:

@color
     if not g.doHook("@url1",c=c,p=p,v=p,url=url):
         # Note: the UNL plugin has its own notion of what a good url is.
         &lt;&lt; check the url; return if bad &gt;&gt;
         &lt;&lt; pass the url to the web browser &gt;&gt;
     g.doHook("@url2",c=c,p=p,v=p)
@nocolor

So I'm wondering if that could be split of to a different function, 
i.e. the first part of leoTree.OnIconDoubleClick gets the url, and 
the second part handles the url, and I want to be able to call just 
the second part.

It's important that this solution will trigger UNL if it's loaded, 
and similar animals.

So, if it's not too tricky, could the handle url part of 
leoTree.OnIconDoubleClick be split out for calling?</t>
<t tx="ekr.20070626112754.280">def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.bodyString().split('\n')
            url = lines and lines[0] or ''
        else:
            &lt;&lt; stop the url after any whitespace &gt;&gt;
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            self.handleUrlInUrlNode(url)
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06</t>
<t tx="ekr.20070626112754.281"># For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i &gt; -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i &gt; -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
</t>
<t tx="ekr.20070626112754.282">def handleUrlInUrlNode(self,url):

    # Note: the UNL plugin has its own notion of what a good url is.

    c = self.c
    # g.trace(url)
    &lt;&lt; check the url; return if bad &gt;&gt;
    &lt;&lt; pass the url to the web browser &gt;&gt;
</t>
<t tx="ekr.20070626112754.283">@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

if not url or len(url) == 0:
    g.es("no url following @url")
    return

# Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return</t>
<t tx="ekr.20070626112754.284">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)
    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
    else:
        import webbrowser
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()
</t>
<t tx="ekr.20070626112754.285"></t>
<t tx="ekr.20070626112754.286">recentFileMessageWritten = False

def writeRecentFilesFile (self,c):

    '''Write the appropriate .leoRecentFiles.txt file.'''

    tag = '.leoRecentFiles.txt'

    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                if not self.recentFileMessageWritten:
                    self.recentFileMessageWritten = True
                    print ('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
</t>
<t tx="ekr.20070626112754.287">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)

    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass

    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()

    if theFile:
        theFile.close()
</t>
<t tx="ekr.20070626112754.288"></t>
<t tx="ekr.20070626112754.289">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    # g.trace('event.keysym_num',event.keysym_num,event,dir(event))

    &lt;&lt; define vars &gt;&gt;
    if keysym in special_keys: return None

    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = (False or self.trace_masterKeyHandlerGC) and not g.app.unitTesting
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',repr(event.keysym),'ch:',repr(event.char),
            'state.kind:',k.state.kind,'\n',g.callers())
        # if (self.master_key_count % 100) == 0: g.printGcSummary()

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        &lt;&lt; handle mode bindings &gt;&gt;

    if traceGC: g.printNewObjects('masterKey 2')

    &lt;&lt; handle per-pane bindings &gt;&gt;
    &lt;&lt; handle keys without bindings &gt;&gt;
</t>
<t tx="ekr.20070626112754.290">k = self ; c = k.c ; gui = g.app.gui

if event: event = gui.leoKeyEvent(event,c)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1</t>
<t tx="ekr.20070626112754.291"># First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'

# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
</t>
<t tx="ekr.20070626112754.292">keyStatesTuple = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

# g.trace('w_name',w_name,'w',w,'isTextWidget(w)',g.app.gui.isTextWidget(w))
# g.trace('button',k.masterBindingsDict.get('button'))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d.keys())
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
</t>
<t tx="ekr.20070626112754.293">if traceGC: g.printNewObjects('masterKey 5')

modesTuple = ('insert','overwrite')

if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
    # insert/overwrite normal character.  &lt;Return&gt; is *not* a normal character.
    if trace: g.trace('plain key in insert mode',repr(stroke))
    if traceGC: g.printNewObjects('masterKey 4')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(char) &gt; 1:
    # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'

elif keysym.find('Escape') != -1:
    # Never insert escape characters.
    return 'break'

else:
    if trace: g.trace(repr(stroke),'no func')
    if traceGC: g.printNewObjects('masterKey 6')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
</t>
<t tx="ekr.20070626112754.294">def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or self.trace_masterKeyHandler and not g.app.unitTesting

    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
</t>
<t tx="ekr.20070626112754.295">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer and k.useTextWidget: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
</t>
<t tx="ekr.20070626112754.296">k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
</t>
<t tx="ekr.20070626112754.297">def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = False or c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
</t>
<t tx="ekr.20070626112754.298">def callAltXFunction (self,event):

    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # print 'callAltXFunc',func

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.299"># This is much less confusing.</t>
<t tx="ekr.20070626112754.300"></t>
<t tx="ekr.20070626112754.301">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4014079
By: ktenney

I've been looking at the Leo file format and discovered that a copied node is
nearly a valid Leo file, just add;

&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings/&gt;

Would it be possible to drop the requirement for these tags or
add them when copying a node?

I think it would be nice if copied nodes were valid Leo files.

@color</t>
<t tx="ekr.20070626112754.302">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4005750
By: ktenney

I like the option @string relative_path_base_directory = .

which puts @file nodes in the same directory as the current Leo file.

I would like it if 
open('file.txt','w').close()

put file.txt in the same directory as the current Leo file.

in g.getBaseDirectory I changed::
    if base and len(base) &gt; 0 and g.os_path_isabs(base):
        return base # base need not exist yet.

to::
    if base and len(base) &gt; 0 and g.os_path_isabs(base):
        os.chdir(base)
        return base # base need not exist yet.

it should probably be configurable::

    if base and len(base) &gt; 0 and g.os_path_isabs(base):
        if app.config.python_cwd_is_leo_base:
            os.chdir(base)
        return base # base need not exist yet.

@color
</t>
<t tx="ekr.20070626112754.303"># Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory(c):

    base = app.config.relative_path_base_directory

    if base and base == "!":
        base = app.loadDir
    elif base and base == ".":
        base = c.openDirectory

    # g.trace(base)
    if base and len(base) &gt; 0 and g.os_path_isabs(base):
        # Set c.chdir_to_relative_path as needed.
        if not hasattr(c,'chdir_to_relative_path'):
            c.chdir_to_relative_path = c.config.getBool('chdir_to_relative_path')
        # Call os.chdir if requested.
        if c.chdir_to_relative_path:
            os.chdir(base)
        return base # base need not exist yet.
    else:
        return "" # No relative base given.
</t>
<t tx="ekr.20070626112754.304"></t>
<t tx="ekr.20070626112754.305"></t>
<t tx="ekr.20070626112754.306">class minibufferFind (baseEditCommandsClass):

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
</t>
<t tx="ekr.20070626112754.307">def __init__(self,c,finder):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # g.trace('minibufferFind: finder',finder)

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []

    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    self.replaceStringShortcut = s
</t>
<t tx="ekr.20070626112754.308"></t>
<t tx="ekr.20070626112754.309">def setFindScope(self,where):

    '''Set the find-scope radio buttons.

    `where` must be in ('node-only','entire-outline','suboutline-only'). '''

    h = self.finder

    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.svarDict['radio-search-scope'].get()
        if var:
            h.svarDict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
</t>
<t tx="ekr.20070626112754.310"># This redirection is required to remove gui-dependencies.

def getOption (self,ivar):          return self.finder.getOption(ivar)
def setOption (self,ivar,val):      self.finder.setOption(ivar,val)
def toggleOption (self,ivar):       self.finder.toggleOption(ivar)
</t>
<t tx="ekr.20070626112754.311">def showFindOptions (self):

    '''Show the present find options in the status line.'''

    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')

    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )

    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
</t>
<t tx="ekr.20070626112754.312">def setupChangePattern (self,pattern):

    h = self.finder ; w = h.change_ctrl

    s = g.toUnicode(pattern,g.app.tkEncoding)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
</t>
<t tx="ekr.20070626112754.313">def setupSearchPattern (self,pattern):

    h = self.finder ; w = h.find_ctrl

    s = g.toUnicode(pattern,g.app.tkEncoding)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
</t>
<t tx="ekr.20070626112754.314">def addChangeStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.change_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20070626112754.315">def addFindStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.find_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20070626112754.316">def changeAll (self,event):

    k = self.k ; tag = 'change-all' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Change All From: ',protect=True)
        k.getArg(event,tag,1,self.changeAll)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = 'Change All: %s With: ' % (self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,tag,2,self.changeAll,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg,changeAll=True)

</t>
<t tx="ekr.20070626112754.317">def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
</t>
<t tx="ekr.20070626112754.318">def findAgain (self,event):

    f = self.finder

    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
</t>
<t tx="ekr.20070626112754.319">def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
</t>
<t tx="ekr.20070626112754.320">def generalChangeHelper (self,find_pattern,change_pattern,changeAll=False):

    # g.trace(repr(change_pattern))

    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()

    if changeAll:
         self.finder.changeAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
</t>
<t tx="ekr.20070626112754.321">def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):

    c = self.c

    self.setupSearchPattern(pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
</t>
<t tx="ekr.20070626112754.322">def lastStateHelper (self):

    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
</t>
<t tx="ekr.20070626112754.323">def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
</t>
<t tx="ekr.20070626112754.324">def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20070626112754.325">def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20070626112754.326">def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20070626112754.327">def setupArgs (self,forward=False,regexp=False,word=False):

    h = self.finder ; k = self.k

    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)

    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
</t>
<t tx="ekr.20070626112754.328">def stateZeroHelper (self,event,tag,prefix,handler,escapes=[]):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)

    # g.trace(escapes,g.callers())
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
</t>
<t tx="ekr.20070626112754.329">def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)

def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)
</t>
<t tx="ekr.20070626112754.330">def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20070626112754.331">class searchCommandsClass (baseEditCommandsClass):

    '''Implements many kinds of searches.'''

    @others
</t>
<t tx="ekr.20070626112754.332">def __init__ (self,c):

    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.findTabHandler = None
    self.minibufferFindHandler = None
    self.inited = False

    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None

    # For isearch commands.
    self.ifinder = leoFind.leoFind(c,title='ifinder')
    self.isearch_v = None # vnode of last isearch.
    self.isearch_stack = [] # A stack of previous matches: entries are: (sel,insert)
    self.ignoreCase = None
    self.forward = None
    self.regexp = None
</t>
<t tx="ekr.20070626112754.333">def getPublicCommands (self):

    return {
        'clone-find-all':                       self.cloneFindAll,

        'find-all':                             self.findAll,
        'change-all':                           self.changeAll,

        # Thin wrappers on Find tab
        'change':                               self.findTabChange,
        'change-then-find':                     self.findTabChangeThenFind,
        'find-next':                            self.findTabFindNext,
        'find-prev':                            self.findTabFindPrev,

        'hide-find-tab':                        self.hideFindTab,

        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
        'isearch-with-present-options':         self.isearchWithPresentOptions,

        'open-find-tab':                        self.openFindTab,

        'replace-string':                       self.replaceString,

        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.

        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,

        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,

        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
</t>
<t tx="ekr.20070626112754.334"></t>
<t tx="ekr.20070626112754.335">def openFindTab (self,event=None,show=True):

    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    wasOpen = self.inited

    if self.inited:
        log.selectTab(tabName)
    else:
        self.inited = True
        log.selectTab(tabName,createText=False)
        f = log.frameDict.get(tabName)
        self.findTabHandler = g.app.gui.createFindTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
</t>
<t tx="ekr.20070626112754.336"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):
    '''Execute the 'Change' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):
    '''Execute the 'Replace, Find' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindAll(self,event=None):
    '''Execute the 'Find All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    '''Execute the 'Find Next' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    '''Execute the 'Find Previous' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()

def hideFindTab (self,event=None):
    '''Hide the Find tab.'''
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
</t>
<t tx="ekr.20070626112754.337">def getHandler(self,show=False):

    '''Return the minibuffer handler, creating it if necessary.'''

    c = self.c

    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.

    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler
</t>
<t tx="ekr.20070626112754.338">def setFindScopeEveryWhere (self, event):
    '''Set the 'Entire Outline' radio button in the Find tab.'''
    return self.setFindScope('entire-outline')

def setFindScopeNodeOnly  (self, event):
    '''Set the 'Node Only' radio button in the Find tab.'''
    return self.setFindScope('node-only')

def setFindScopeSuboutlineOnly (self, event):
    '''Set the 'Suboutline Only' radio button in the Find tab.'''
    return self.setFindScope('suboutline-only')

def showFindOptions (self,event):
    '''Show all Find options in the minibuffer label area.'''
    self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event):
    '''Toggle the 'Ignore Case' checkbox in the Find tab.'''
    return self.toggleOption('ignore_case')

def toggleMarkChangesOption (self, event):
    '''Toggle the 'Mark Changes' checkbox in the Find tab.'''
    return self.toggleOption('mark_changes')
def toggleMarkFindsOption (self, event):
    '''Toggle the 'Mark Finds' checkbox in the Find tab.'''
    return self.toggleOption('mark_finds')
def toggleRegexOption (self, event):
    '''Toggle the 'Regexp' checkbox in the Find tab.'''
    return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event):
    '''Toggle the 'Reverse' checkbox in the Find tab.'''
    return self.toggleOption('reverse')

def toggleSearchBodyOption (self, event):
    '''Set the 'Search Body' checkbox in the Find tab.'''
    return self.toggleOption('search_body')

def toggleSearchHeadlineOption (self, event):
    '''Toggle the 'Search Headline' checkbox in the Find tab.'''
    return self.toggleOption('search_headline')

def toggleWholeWordOption (self, event):
    '''Toggle the 'Whole Word' checkbox in the Find tab.'''
    return self.toggleOption('whole_word')

def toggleWrapSearchOption (self, event):
    '''Toggle the 'Wrap Around' checkbox in the Find tab.'''
    return self.toggleOption('wrap')

def setFindScope (self, where):  self.getHandler().setFindScope(where)
def toggleOption (self, ivar):   self.getHandler().toggleOption(ivar)
</t>
<t tx="ekr.20070626112754.339">def changeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    self.getHandler().changeAll(event)

def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type &lt;Return&gt; to end the search string. The
    command will then prompt for the replacement string. Typing a second
    &lt;Return&gt; key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Set the 'Regexp' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Set the 'Regexp' checkbox to True, then do search-with-present-options.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Set the 'Word Search' checkbox to False and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Set the 'Word Search' checkbox to False, then do search-with-present-options.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Set the 'Word Search' checkbox to True, then do search-with-present-options.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Set the Word Search' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the &lt;Return&gt; key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
</t>
<t tx="ekr.20070626112754.340">def findAgain (self,event):

    '''The find-again command is the same as the find-next command
    if the search pattern in the Find tab is not '&lt;find pattern here&gt;'
    Otherwise, the find-again is the same as the search-with-present-options command.'''

    h = self.getHandler()

    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to search-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)
</t>
<t tx="ekr.20070626112754.341">def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=False)

def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=False)

def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=True)

def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=True)

def isearchWithPresentOptions (self,event):
    '''Begin an incremental regexp search using the regexp and reverse options from the find panel.'''
    self.startIncremental(event,forward=None,ignoreCase=None,regexp=None)
</t>
<t tx="ekr.20070626112754.342">def iSearchBackspace (self):

    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.w

    if not self.isearch_stack:
        ins = w.getInsertPoint()
        self.endSearch(ins,ins)
        return 

    gui.set_focus(c,w)
    pattern = k.getLabel(ignorePrompt=True)
    self.scolorizer(event=None,pattern=pattern)

    sel,ins = self.isearch_stack.pop()

    if sel:
        i,j = sel
        w.setSelectionRange(i,j,insert=ins)
    else:
        w.setInsertPoint(ins)

    w.seeInsertPoint()

    if not self.isearch_stack:
        self.endSearch(ins,ins)
</t>
<t tx="ekr.20070626112754.343">def startIncremental (self,event,forward,ignoreCase,regexp):

    c = self.c ; k = self.k ; w = self.w

    # None is a signal to get the option from the find tab.
    if forward is None or regexp is None:
        self.openFindTab(show=False)
        if not self.minibufferFindHandler:
            self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)
        getOption = self.minibufferFindHandler.getOption
        # g.trace('reverse',getOption('reverse'))
        # g.trace('pattern',getOption('pattern_match'))
    else:
        getOption = lambda a: False # The value isn't used.

    self.event = event
    self.forward    = g.choose(forward is None,not getOption('reverse'),forward)
    self.ignoreCase = g.choose(ignoreCase is None,getOption('ignore_case'),ignoreCase)
    self.regexp     = g.choose(regexp  is None,getOption('pattern_match'),regexp)
    # Note: the word option can't be used with isearches!

    self.ins1 = ins = w.getInsertPoint()
    sel = w.getSelectionRange() or (ins,ins),
    self.isearch_stack = [(sel,ins),]

    k.setLabelBlue('Isearch%s%s%s: ' % (
            g.choose(self.forward,'',' Backward'),
            g.choose(self.regexp,' Regexp',''),
            g.choose(self.ignoreCase,' NoCase',''),
        ),protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
</t>
<t tx="ekr.20070626112754.344"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w

    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return

    c.bodyWantsFocusNow()
    if keysym == 'Return':
        i,j = w.getSelectionRange()
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
    elif keysym == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif ch:
        k.updateLabel(event)
        self.iSearchHelper(event)
        self.scolorizer(event)
</t>
<t tx="ekr.20070626112754.345">def scolorizer (self,event,pattern=None):

    '''Colorizer for incremental searches.'''

    k = self.k ; w = self.w
    s = pattern or k.getLabel(ignorePrompt=True)
    # g.trace(repr(s))
    w.tag_delete('color','color1')
    if not s: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    ind = 0
    index = w.getInsertPoint()
    index2 = index + len(s)
    # g.trace(index,index2)
    # Colorize in the forward direction, regardless of the kind of search.
    while ind:
        try:
            ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        except: break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(s))
            # g.trace(ind)
            if ind in (index,index2):
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
</t>
<t tx="ekr.20070626112754.346">def iSearchHelper (self,event):

    '''Move the cursor to position that matches the pattern in the miniBuffer.
    isearches do not cross node boundaries.'''

    c = self.c ; gui = g.app.gui ; k = self.k ; w = self.w
    p = c.currentPosition() ;
    self.searchString = pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    s = w.getAllText()

    if self.isearch_v != p.v:
        self.isearch_v = p.v
        self.isearch_stack = []

    sel = w.getSelectionRange()
    startindex = insert = w.getInsertPoint()

    if self.forward:
        i1 = startindex
        j1 = len(s)
    else:
        i1 = 0
        j1 = min(len(s),startindex + len(pattern))

    i,j = self.ifinder.searchHelper(s,i1,j1,pattern,
        backwards=not self.forward,
        nocase=self.ignoreCase,
        regexp=self.regexp,
        word=False, # Incremental word-matches are not possible!
        swapij=False)

    if i != -1:
        self.isearch_stack.append((sel,insert),)
        # g.trace(i1,j1,i,j,pos,newpos)
        gui.set_focus(c,w)
        w.setSelectionRange(i,j,insert=i)
</t>
<t tx="ekr.20070626112754.347">def endSearch (self,i,j):

    w = self.w
    w.tag_delete('color','color1')

    insert = g.choose(self.forward,'sel.end','sel.start')
    w.setSelectionRange(i,j,insert=insert)

    self.k.keyboardQuit(event=None)</t>
<t tx="ekr.20070626112754.348">class leoFind:

    """The base class for Leo's Find commands."""

    @others
</t>
<t tx="ekr.20070626112754.349">def __init__ (self,c,title=None):

    # g.trace('leoFind',c)

    self.c = c

    # Spell checkers use this class, so we can't always compute a title.
    if title:
        self.title = title
    else:
        &lt;&lt; compute self.title &gt;&gt;

    &lt;&lt; init the gui-independent ivars &gt;&gt;

def init (self,c):
    self.oops()
</t>
<t tx="ekr.20070626112754.350">if not c.mFileName:
    s = "untitled"
else:
    path,s = g.os_path_split(c.mFileName)

self.title = "Find/Change for %s" %  s
</t>
<t tx="ekr.20070626112754.351">self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated by update_ivars just before doing any find.
@c

&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = searchWidget() # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos &gt;= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
self.selStart = self.selEnd = None # For selection-only searches.
</t>
<t tx="ekr.20070626112754.352">if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.selection_only = None
    self.wrap = None
    self.whole_word = None

if 1:
    self.change_ctrl = None
    self.find_ctrl = None
    self.frame = None
    self.svarDict = {}
</t>
<t tx="ekr.20070626112754.353"></t>
<t tx="ekr.20070626112754.354"># The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_change:
        self.doChangeAllScript()
    elif self.selection_only:
        self.change()
    else:
        self.changeAll()
</t>
<t tx="ekr.20070626112754.355"># The user has pushed the "Change" button from the find panel.

def changeButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
    else:
        self.change()
</t>
<t tx="ekr.20070626112754.356"># The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
        if self.script_search:
            self.doFindScript()
        else:
            self.findNext()
    else:
        if self.script_search:
            self.change()
            self.doFindScript()
        else:
            self.changeThenFind()
</t>
<t tx="ekr.20070626112754.357"># The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    elif self.selection_only:
        self.findNext()
    else:
        self.findAll()
</t>
<t tx="ekr.20070626112754.358"># The user has pushed the "Find" button from the find panel.

def findButton(self):

    self.setup_button()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
</t>
<t tx="ekr.20070626112754.359"># Initializes a search when a button is pressed in the Find panel.

def setup_button(self):

    c = self.c
    self.p = c.currentPosition()

    c.bringToFront()
    if 0: # We _must_ retain the editing status for incremental searches!
        c.endEditing()

    self.update_ivars()
</t>
<t tx="ekr.20070626112754.360"></t>
<t tx="ekr.20070626112754.361"># The user has selected the "Replace" menu item.

def changeCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
    else:
        self.change()
</t>
<t tx="ekr.20070626112754.362"># The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
        self.doFindScript()
    else:
        self.changeThenFind()
</t>
<t tx="ekr.20070626112754.363">def dismiss (self):
    pass
</t>
<t tx="ekr.20070626112754.364"># The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
</t>
<t tx="ekr.20070626112754.365"># The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

    self.setup_command()

    self.reverse = not self.reverse

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()

    self.reverse = not self.reverse
</t>
<t tx="ekr.20070626112754.366">def handleUserClick (self,p):

    """Reset suboutline-only search when the user clicks a headline."""

    try:
        if self.c and self.suboutline_only:
            # g.trace(p)
            self.onlyPosition = p.copy()
    except: pass
</t>
<t tx="ekr.20070626112754.367"># Initializes a search when a command is invoked from the menu.

def setup_command(self):

    # g.trace('leoFind')

    if 0: # We _must_ retain the editing status for incremental searches!
        self.c.endEditing()

    self.update_ivars()
</t>
<t tx="ekr.20070626112754.368"></t>
<t tx="ekr.20070626112754.369">@ This routine performs a single batch change operation, updating the head or body string of p and leaving the result in s_ctrl.  We update the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; w = self.s_ctrl
    # Replace the selection with self.change_text
    if pos1 &gt; pos2: pos1,pos2=pos2,pos1
    s = w.getAllText()
    if pos1 != pos2: w.delete(pos1,pos2)
    w.insert(pos1,self.change_text)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+len(self.change_text))
    w.setSelectionRange(insert,insert)
    w.setInsertPoint(insert)
    # Update the node
    s = w.getAllText() # Used below.
    if self.in_headline:
        &lt;&lt; change headline &gt;&gt;
    else:
        &lt;&lt; change body &gt;&gt;
</t>
<t tx="ekr.20070626112754.370">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.headString():

    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Headline',undoData)
</t>
<t tx="ekr.20070626112754.371">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.bodyString():

    undoData = u.beforeChangeNodeContents(p)

    c.setBodyString(p,s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Body',undoData)
</t>
<t tx="ekr.20070626112754.372">def change(self,event=None):

    if self.checkArgs():
        self.initInHeadline()
        self.changeSelection()
</t>
<t tx="ekr.20070626112754.373">def changeAll(self):

    # g.trace(g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.currentPosition()
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        while 1:
            pos1, pos2 = self.findNextMatch()
            if pos1 is None: break
            count += 1
            self.batchChange(pos1,pos2)
            s = w.getAllText()
            i,j = g.getLine(s,pos1)
            line = s[i:j]
            self.printLine(line,allFlag=True)
        p = c.currentPosition()
        u.afterChangeGroup(p,undoType,reportFlag=True)
        g.es("changed: %d instances" % (count))
    finally:
        c.endUpdate()
        self.restore(saveData)
</t>
<t tx="ekr.20070626112754.374">def changeThenFind(self):

    if not self.checkArgs():
        return

    self.initInHeadline()
    if self.changeSelection():
        self.findNext(False) # don't reinitialize
</t>
<t tx="ekr.20070626112754.375">def doChangeScript (self):

    g.app.searchDict["type"] = "change"
    self.runChangeScript()

def doChangeAllScript (self):

    """The user has just pressed the Change All button with script-change box checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "changeAll"
    while 1:
        self.runChangeScript()
        if not g.app.searchDict.get("continue"):
            break

def runChangeScript (self):

    try:
        assert(self.script_change)
        exec self.change_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing change script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
</t>
<t tx="ekr.20070626112754.376">def doFindScript (self):

    g.app.searchDict["type"] = "find"
    self.runFindScript()

def doFindAllScript (self):

    """The user has just pressed the Find All button with script-find radio button checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "findAll"
    while 1:
        self.runFindScript()
        if not g.app.searchDict.get("continue"):
            break

def runFindScript (self):

    try:
        exec self.find_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing find script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
</t>
<t tx="ekr.20070626112754.377">def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                &lt;&lt; create the found node and begin the undo group &gt;&gt;
            clones.append(self.p.v.t)
            &lt;&lt; create a clone of p under the find node &gt;&gt;
    if self.clone_find_all and clones:
        c.setRootPosition(c.findRootPosition(found)) # New in 4.4.2.
        u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    c.redraw_now()
    g.es("found: %d matches" % (count))
    self.restore(data)
</t>
<t tx="ekr.20070626112754.378">u.beforeChangeGroup(c.currentPosition(),undoType)

undoData = u.beforeInsertNode(c.currentPosition())

oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)

u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
</t>
<t tx="ekr.20070626112754.379">undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
</t>
<t tx="ekr.20070626112754.380">def findNext(self,initFlag=True):

    c = self.c
    if not self.checkArgs():
        return

    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()

    pos, newpos = self.findNextMatch()

    if pos is not None:
        self.showSuccess(pos,newpos)
    else:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found: " + "'" + self.find_text + "'")
        self.restore(data)
</t>
<t tx="ekr.20070626112754.381"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not self.search_headline and not self.search_body:
        return None, None

    if len(self.find_text) == 0:
        return None, None

    p = self.p ; self.errors = 0
    while p:
        pos, newpos = self.search()
        # g.trace('pos',pos,'p',p.headString(),g.callers())
        if pos is not None:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            return None,None # Abort the search.
        elif self.node_only:
            return None,None # We are only searching one node.
        else:
            p = self.p = self.selectNextPosition()
    return None, None
</t>
<t tx="ekr.20070626112754.382">def resetWrap (self,event=None):

    self.wrapPosition = None
    self.onlyPosition = None
</t>
<t tx="ekr.20070626112754.383"># Selects the next node to be searched.

def selectNextPosition(self):

    c = self.c ; p = self.p

    if self.selection_only:
        return None

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace('switching to body',g.callers(5))
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()

    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        # g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
</t>
<t tx="ekr.20070626112754.384"></t>
<t tx="ekr.20070626112754.385">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; w = self.find_ctrl

    # g.trace(g.callers())
    c.widgetWantsFocusNow(w)
    g.app.gui.selectAllText(w)
    c.widgetWantsFocus(w)
</t>
<t tx="ekr.20070626112754.386">def oops(self):
    print ("leoFind oops:",
        g.callers(10),"should be overridden in subclass")
</t>
<t tx="ekr.20070626112754.387">def selectAllFindText (self,event=None):

    __pychecker__ = '--no-argsused' # event

    # This is called only when the user presses ctrl-a in the find panel.

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        w.selectAllText()

    return "break"
</t>
<t tx="ekr.20070626112754.388"></t>
<t tx="ekr.20070626112754.389">def checkArgs (self):

    val = True
    if not self.search_headline and not self.search_body:
        g.es("not searching headline or body")
        val = False
    if len(self.find_text) == 0:
        g.es("empty find patttern")
        val = False
    return val
</t>
<t tx="ekr.20070626112754.390">def init_s_ctrl (self,s):

    w = self.s_ctrl
    w.setAllText(s)
    i = g.choose(self.reverse,len(s),0)
    w.setInsertPoint(i)
    return w
</t>
<t tx="ekr.20070626112754.391"># Initializes for the Find All and Change All commands.

def initBatchCommands (self):

    c = self.c ; w = c.frame.body.bodyCtrl
    self.in_headline = self.search_headline # Search headlines first.
    self.errors = 0

    # Select the first node.
    if self.suboutline_only or self.node_only or self.selection_only:
        self.p = c.currentPosition()
        if self.selection_only: self.selStart,self.selEnd = w.getSelectionRange()
        else:                   self.selStart,self.selEnd = None,None
    else:
        p = c.rootPosition()
        if self.reverse:
            while p and p.next():
                p = p.next()
            p = p.lastNode()
        self.p = p

    # Set the insert point.
    self.initBatchText()
</t>
<t tx="ekr.20070626112754.392"># Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    return self.init_s_ctrl(s)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self):
    p = self.p
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    return self.init_s_ctrl(s)
</t>
<t tx="ekr.20070626112754.393"># Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

    c = self.c ; p = self.p

    # Do not change this without careful thought and extensive testing!
    if self.search_headline and self.search_body:
        # A temporary expedient.
        if self.reverse:
            self.in_headline = False
        else:
            # Search headline first.
            self.in_headline = (
                p == c.frame.tree.editPosition() and
                c.get_focus() != c.frame.body.bodyCtrl)
    else:
        self.in_headline = self.search_headline
</t>
<t tx="ekr.20070626112754.394"># For incremental searches

def initInteractiveCommands(self):

    c = self.c ; p = self.p

    self.errors = 0
    if self.in_headline:
        c.frame.tree.setEditPosition(p)
        w = c.edit_widget(p)
        sel = None
    else:
        w = c.frame.bodyCtrl
        sel = w.getSelectionRange()
    pos = w.getInsertPoint()
    st = self.initNextText()
    c.widgetWantsFocus(w)
    st.setInsertPoint(pos)
    if sel:
        self.selStart,self.selEnd = sel
    else:
        self.selStart,self.selEnd = None,None
    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = pos
        # Do not set self.wrapPosition here: that must be done after the first search.
</t>
<t tx="ekr.20070626112754.395">def printLine (self,line,allFlag=False):

    both = self.search_body and self.search_headline
    context = self.batch # "batch" now indicates context

    if allFlag and both and context:
        g.es('-' * 20,self.p.headString())
        theType = g.choose(self.in_headline,"head: ","body: ")
        g.es(theType + line)
    elif allFlag and context and not self.p.isVisited():
        # We only need to print the context once.
        g.es('-' * 20,self.p.headString())
        g.es(line)
        self.p.setVisited()
    else:
        g.es(line)
</t>
<t tx="ekr.20070626112754.396"># Restores the screen after a search fails

def restore (self,data):

    c = self.c
    in_headline,p,t,insert,start,end = data

    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)

    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        t.setSelectionRange(insert,insert)
        t.setInsertPoint(insert)
        t.seeInsertPoint()

    #g.trace(c.widget_name(t))

    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocusNow()
    else:
        c.widgetWantsFocusNow(t)
</t>
<t tx="ekr.20070626112754.397">def save (self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    insert = w.getInsertPoint()
    sel = w.getSelectionRange()
    if len(sel) == 2:
        start,end = sel
    else:
        start,end = None,None
    return (self.in_headline,p,w,insert,start,end)
</t>
<t tx="ekr.20070626112754.398"># New in Leo 4.4.3: This is now gui-independent code.

def update_ivars (self):

    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        # g.trace(self.svarDict.get(key))
        val = self.svarDict[key].get()
        setattr(self, key, val) # No more _flag hack.

    # Set ivars from radio buttons. Convert these to 1 or 0.
    search_scope = self.svarDict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0)

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.getAllText()
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.getAllText()
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
</t>
<t tx="ekr.20070626112754.399">class findTab (leoFind):

    '''An adapter class that implements Leo's Find tab.'''

    @others
</t>
<t tx="ekr.20070626112754.400">def __init__(self,c,parentFrame):

    # g.trace('findTab',c)

    # Init the base class...
    leoFind.__init__(self,c,title='Find Tab')

    self.c = c
    self.parentFrame = parentFrame
    self.frame = self.outerFrame = self.top = None

    self.optionsOnly = c.config.getBool('show_only_find_tab_options')

    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.initGui()
    self.createFrame(parentFrame)
    self.createBindings()
    self.init(c) # New in 4.3: init only once.
</t>
<t tx="ekr.20070626112754.401">def createBindings (self):
    self.oops()

def createFrame (self,parent):
    __pychecker__ = '--no-argsused'
    self.oops()

def getOption (self,ivar):
    self.oops()

def init (self,c):
    self.oops()

def initGui (self):
    pass # Optional method.

def setOption (self,ivar,val):
    __pychecker__ = '--no-argsused'
    self.oops()

def toggleOption (self,ivar):
    self.oops()

# self.oops is defined in the leoFind class.
</t>
<t tx="ekr.20070626112754.402"></t>
<t tx="ekr.20070626112754.403">def findButtonCallback(self,event=None):

    self.findButton()
    return 'break'
</t>
<t tx="ekr.20070626112754.404">def hideTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.405"></t>
<t tx="ekr.20070626112754.406">def changeCommand (self,event=None):

    self.setup_command()
    self.change()

def changeThenFindCommand(self,event=None):

    self.setup_command()
    self.changeThenFind()
</t>
<t tx="ekr.20070626112754.407">def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
</t>
<t tx="ekr.20070626112754.408">def cloneFindAllCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
</t>
<t tx="ekr.20070626112754.409">def findAgainCommand (self):

    s = self.find_ctrl.getAllText()

    if s and s != '&lt;find pattern here&gt;':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
</t>
<t tx="ekr.20070626112754.410">def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
</t>
<t tx="ekr.20070626112754.411">def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()

def findPrevCommand (self,event=None):

    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
</t>
<t tx="ekr.20070626112754.412">@ Notes:

- The spell tab is only shown if Aspell was properly imported.
- Added leoLog.finishCreate and tkLog.finishCreate, called from c.finishCreate.
- Added force option to deleteTab.
- Handled errors better in the aspell init logic.</t>
<t tx="ekr.20070626112754.413">def openSpellTab (self,event=None):

    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        self.handler = spellTabHandler(c,tabName)
        if not self.handler.loaded:
            log.deleteTab(tabName,force=True)
</t>
<t tx="ekr.20070626112754.414"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()

def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
</t>
<t tx="ekr.20070626112754.415">def finishCreate (self,initEditCommanders=True):  # New in 4.4.

    '''Finish creating the commander after frame.finishCreate.

    Important: this is the last step in the startup process.'''

    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName())

    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = g.app.gui.createKeyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if initEditCommanders: ### g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    c.frame.log.finishCreate()

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)

    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.416">def printCommandsDict (self):

    c = self

    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print
</t>
<t tx="ekr.20070626112754.417">def finishCreate (self,c):

    f = self ; f.c = c
    # g.trace('tkFrame','c',c,g.callers())

    self.trace_status_line = c.config.getBool('trace_status_line')
    self.use_chapters      = c.config.getBool('use_chapters')
    self.use_chapter_tabs  = c.config.getBool('use_chapter_tabs')

    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBar()
    f.createSplitterComponents()
    f.createStatusLine()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()

    # f.enableTclTraces()
</t>
<t tx="ekr.20070626112754.418">def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)

    # Create the canvas, tree, log and body.
    if f.use_chapters:
        c.chapterController = cc = leoChapters.chapterController(c)

    if self.use_chapters and self.use_chapter_tabs:
        cc.tt = leoTkinterTreeTab(c,f.split2Pane1,cc)

    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)

    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl

    # Configure.
    f.setTabWidth(c.tab_width)
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
</t>
<t tx="ekr.20070626112754.419">def createFirstTreeNode (self):

    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot(oldRoot=None)
    c.setRootPosition(p) # New in 4.4.2.
    c.editPosition(p)
</t>
<t tx="ekr.20070626112754.420">def enableTclTraces (self):

    c = self.c
    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("&lt;FocusIn&gt;")
    # c.frame.bar1.unbind_all("&lt;FocusOut&gt;")

    # Any widget would do:
    w = c.frame.bar1
    if True:
        def focusIn (event):
            print("Focus in  %s (%s)" % (
                event.widget,event.widget.winfo_class()))

        def focusOut (event):
            print("Focus out %s (%s)" % (
                event.widget,event.widget.winfo_class()))

        w.bind_all("&lt;FocusIn&gt;", focusIn)
        w.bind_all("&lt;FocusOut&gt;", focusOut)
    else:
        def tracewidget(event):
            g.trace('enabling widget trace')
            Pmw.tracetk(event.widget, 1)

        def untracewidget(event):
            g.trace('disabling widget trace')
            Pmw.tracetk(event.widget,0)

        w.bind_all("&lt;Control-1&gt;", tracewidget)
        w.bind_all("&lt;Control-Shift-1&gt;", untracewidget)
</t>
<t tx="ekr.20070626112754.421">def finishCreate (self):

    # g.trace('tkLog')

    c = self.c ; log = self

    c.searchCommands.openFindTab(show=False)
    c.spellCommands.openSpellTab()
    log.selectTab('Log')
</t>
<t tx="ekr.20070626112754.422">def deleteTab (self,tabName,force=False):

    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell') and not force:
        self.selectTab('Log')

    elif tabName in self.nb.pagenames():
        # g.trace(tabName,force)
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')

    # New in Leo 4.4b1.
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.423">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3987635
By: rogererens

At present I have to go through the list in the Plugin Manager again, trying to
remember which plugins I had enabled in the previous version.

Possibly the .leoRecentFiles.txt construct analogue may be used?

@color

</t>
<t tx="ekr.20070626112754.424">def loadHandlers(tag):

    """Load all enabled plugins from the plugins directory"""

    def pr (*args,**keys):
        if not g.app.unitTesting:
            g.es_print(*args,**keys)

    fileName = "pluginsManager.txt"
    plugins_path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_abspath(theFile) for theFile in files]
    s = g.app.config.getEnabledPlugins()
    theConfigFile = g.app.config.enabledPluginsFileName
    # g.trace('len(s)',s and len(s) or 0)
    if s:
        pr('@enabled-plugins found in %s' % (theConfigFile),color='blue')
        enabled_files = getEnabledFiles(s,plugins_path)
    else:
        for theDir,place in (
            (g.app.homeDir,'HOME'),
            (plugins_path,'leo/config')
        ):
            manager_path = g.os_path_join(theDir,fileName)
            if g.os_path_exists(manager_path):
                g.es_print('%s: %s' % (fileName,theDir),color='blue')
                break
        else: pr('%s not found. No plugins will be loaded' % fileName)
        if g.os_path_exists(manager_path):
            &lt;&lt; set enabled_files from pluginsManager.txt &gt;&gt;
        else:  return

    # Load plugins in the order they appear in the enabled_files list.
    if files and enabled_files:
        for theFile in enabled_files:
            if theFile in files:
                loadOnePlugin(theFile)

    # Note: g.plugin_signon adds module names to g.app.loadedPlugins
    if 0:
        if g.app.loadedPlugins:
            pr("%d plugins loaded" % (len(g.app.loadedPlugins)), color="blue")
</t>
<t tx="ekr.20070626112754.425">try:
    # New in 4.3: The first reference to a plugin in pluginsManager.txt controls.
    theFile = open(manager_path)
    s = theFile.read()
    pr('Using settings in pluginsManager.txt')
    enabled_files = getEnabledFiles(s,plugins_path)
    theFile.close()
except IOError:
    pr("Can not open: %s"  % manager_path)
    # Don't import leoTest initially.  It causes problems.
    import leoTest ; leoTest.fail()
    return
</t>
<t tx="ekr.20070626112754.426">def getEnabledFiles (s,plugins_path):

    enabled_files = []
    disabled_files = []
    for s in g.splitLines(s):
        s = s.strip()
        if s:
            if g.match(s,0,"#"):
                s = s[1:].strip()
                # Kludge: ignore comment lines containing a blank or not ending in '.py'.
                if s and s.find(' ') == -1 and s[-3:] == '.py':
                    path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                    if path not in enabled_files and path not in disabled_files:
                        # print 'disabled',path
                        disabled_files.append(path)
            else:
                path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                if path not in enabled_files and path not in disabled_files:
                    # print 'enabled',path
                    enabled_files.append(path)

    return enabled_files</t>
<t tx="ekr.20070626112754.427"></t>
<t tx="ekr.20070626112754.428">@nocolor
@

It is now possible to debug both Leo-specific and non-Leo-specific scripts easily with winpdb.

Preliminaries: New settings

The following two new settings now control whether the execute-script and debug commands write the script to an external file.

- @bool write_script_file = True

True: The execute script command writes the script to be executed to a file, then executes the script using Python's execFile function. The script_file_path setting specifies the path to this file.

False (legacy): The execute script command uses Python's exec command to execute the script. 

- @string script_file_path = ../test/scriptFile.py

The path to the file to be written by the execute-script command.

Notes:

- This setting has effect only if the write_script_file setting is True.
- Use / to as the path delimiter, regardless of platform.
- The default path is ../test/scriptFile.py if no path is given.
- The path starts at g.app.loadDir, so for example ../test/scriptFile.py is equivalent to leo/test/scriptFile.py
- The filename should end in .py.

From here on, let us assume the settings are as shown above.  There are at least three ways of debugging scripts, depending on your preferences and whether the script contains leo-specific code (g, c or p) or not.

First way:  The debug command

The debug command now works almost exactly like Kent's original @button node. This way of debugging can only be used for general scripts, not leo-specific scripts.  

The debug command writes the script to scriptFile.py and invokes the debugger as specified by the existing @string debugger_kind option.  winpdb opens and is already 'attached' to the script to be debugged.  You can single-step as you like.  Leo continues to run, but killing the debugger will also kill Leo.  When started this way, winpdb is really 'attached' to *all* of Leo, which means you can single step past the end of the script into Leo's executeScript code and from there into all of Leo(!)

As I write this I realize that the code uses arguments specific to winpdb.  That may have to be generalized, though I am not sure why anyone would want to use another debugger...

Second way: @button winpdb

This is almost exactly equivalent to the debug command, except that the script file must be *different* from the script file specified by the  script_file_path setting (The @button code *itself* uses the execute-script command, so we have to pass the script code, not the @button code to the debugger).

Third way: The execute-script command with explicit debugger breaks

The third way of debugging scripts allows winpdb to debug scripts that use c, g and p.  I'm actually not sure of exactly how and why it works, but it certainly does work.

In contrast to the previous two ways, a little more work is needed because winpdb does not start automatically.  But I am getting ahead of myself.

To use this way, insert the following two lines of code at the start of the script to be debugged::

import rpdb2
rpdb2.start_embedded_debugger('go',fAllowUnencrypted=True)

Now just execute the execute-script command (*not* the debug command)  Leo will appear to hang.  Indeed, the  start_embedded_debugger command is waiting for *another* copy of winpdb to 'attach' to the script's process.  This process is all of Leo!  The default timeout is 5 minutes: I'm not sure what happens when the timeout happens: probably an exception gets thrown.

So you must start winpdb explicitly.  On XP just do something like

python c:\python25\Scripts\_winpdb.py -t

The -t option tells winpdb that no encoding of password is necessary.  The password is specified in the call to rpdb2.start_embedded_debugger in your script.  In this example, the password is 'go'.  Use the File:Attach command in winpdb to attach winpdb to Leo.  Specify the password as 'go' and you will see the scriptFile.py containing your entire script.  You can execute or single-step through the script. 

To repeat, the big difference is that c, g and p are defined, so you can debug any script this way.  As before, killing winpdb also kills Leo.

P.S.  winpdb and its documentation has been improved recently.  See

http://www.digitalpeers.com/pythondebugger/  and especially

http://www.digitalpeers.com/pythondebugger/embedded.htm

The discussion of embedded debugging may have been written specifically with Leo in mind.  It certainly could have been.
</t>
<t tx="ekr.20070626112754.429">def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    execfile(scriptFile,d)
                else:
                    exec script in d
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
</t>
<t tx="ekr.20070626112754.430">def redirectScriptOutput (self):

    c = self

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
</t>
<t tx="ekr.20070626112754.431">def unredirectScriptOutput (self):

    c = self

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
</t>
<t tx="ekr.20070626112754.432">def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        parts = path.split('/')
        path = g.app.loadDir
        for part in parts:
            path = g.os_path_abspath(g.os_path_join(path,part))
    else:
        path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile.py'))

    # Write the file.
    try:
        f = file(path,'w')
        f.write(script)
        f.close()
    except Exception:
        path = None

    return path</t>
<t tx="ekr.20070626112754.433">def debug (self,event=None):

    '''Start an external debugger in another process to debug the presently selected text.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    # pythonDir = g.os_path_dirname(python)
    script = p.bodyString()
    winpdb = self.findDebugger()
    if not winpdb: return

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
</t>
<t tx="ekr.20070626112754.434">def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
</t>
<t tx="ekr.20070626112754.435">def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):

    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands ; w = c.frame.body.bodyCtrl
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and w.hasSelection():
                s = w.getSelectedText()
            else:
                s = w.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    # g.trace(type(script),repr(script))
    return script
</t>
<t tx="ekr.20070626112754.436">if g.unitTesting:

    c,p = g.getTestVars()
    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
</t>
<t tx="ekr.20070626112754.437">def handleScriptException (c,p,script,script1):

    g.es("exception executing script",color='blue')

    full = c.config.getBool('show_full_tracebacks_in_scripts')

    fileName, n = g.es_exception(full=full)

    if p and not script1 and fileName == "&lt;string&gt;":
        c.goToScriptLineNumber(p,script,n)

    &lt;&lt; dump the lines near the error &gt;&gt;
</t>
<t tx="ekr.20070626112754.438">if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

# Print surrounding lines.
i = max(0,n-2)
j = min(n+2,len(lines))
while i &lt; j:
    ch = g.choose(i==n-1,'*',' ')
    s = "%s line %d: %s" % (ch,i+1,lines[i])
    g.es(s,newline=False)
    i += 1
</t>
<t tx="ekr.20070626112754.439">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4113315

&gt; def runAskOkCancelNumberDialog(self,c,title,message): 
&gt; """Create and run askOkCancelNumber dialog .""" 

Can I appeal for a runAskOkCancelStringDialog(self,c,title,message)

and that perhaps both the Number and String forms have an optional 'default'
parameter?

As it happens I wanted to use it for an 'encryptNode' plug-in.  So some people
might want a runAskOkCancelPasswordDialog version, displaying asterisks... personally
I don't mind having the password visible when I type it, and for AES encryption
with 16 char keys it's probably appropriate.

@color</t>
<t tx="ekr.20070626112754.440"># This is another step toward making Leo's core gui-independent</t>
<t tx="ekr.20070626112754.441"></t>
<t tx="ekr.20070626112754.442"></t>
<t tx="ekr.20070626112754.443">def bindHotKey (self,widget):

    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)
</t>
<t tx="ekr.20070626112754.444">def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)
    # g.trace('stroke',stroke,'bindStroke',bindStroke)

    if w:
        widgets = [w]
    else:
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None     
        if 1: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
            canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke)
        return k.masterKeyHandler(event,stroke=stroke)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                w.bind(bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding %s to %s' % (
                    bindStroke, c.widget_name(w)), color = 'blue')
                if g.app.unitTesting: raise
</t>
<t tx="ekr.20070626112754.445">def print_bindings (name,window):

    bindings = window.bind()
    print
    print "Bindings for", name
    for b in bindings:
        print b
</t>
<t tx="ekr.20070626112754.446">def bindHotKey (self,widget):

    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)
</t>
<t tx="ekr.20070626112754.447">def setMinibufferBindings (self):

    '''Create bindings for the minibuffer..'''

    f = self ; c = f.c ; k = c.k ; w = f.miniBufferWidget

    if not c.useTextMinibuffer: return

    for kind,callback in (
        ('&lt;Key&gt;',           k.masterKeyHandler),
        ('&lt;Button-1&gt;',      k.masterClickHandler),
        ('&lt;Button-3&gt;',      k.masterClick3Handler),
        ('&lt;Double-1&gt;',      k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',      k.masterDoubleClick3Handler),
    ):
        w.bind(kind,callback)

    if 0:
        if sys.platform.startswith('win'):
            # Support Linux middle-button paste easter egg.
            w.bind("&lt;Button-2&gt;",frame.OnPaste)
</t>
<t tx="ekr.20070626112754.448">def createBindings (self,w=None):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''

    frame = self.frame ; c = self.c ; k = c.k
    if not w: w = self.bodyCtrl

    w.bind('&lt;Key&gt;', k.masterKeyHandler)

    for kind,func,handler in (
        ('&lt;Button-1&gt;',  frame.OnBodyClick,          k.masterClickHandler),
        ('&lt;Button-3&gt;',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('&lt;Double-1&gt;',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',  None,                       k.masterDoubleClick3Handler),
        ('&lt;Button-2&gt;',  frame.OnPaste,              k.masterClickHandler),
    ):
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        w.bind(kind,bodyClickCallback)</t>
<t tx="ekr.20070626112754.449">def bind (self,*args,**keys):

    return self.bodyCtrl.bind(*args,**keys)
</t>
<t tx="ekr.20070626112754.450">def setTabBindings (self,tabName):

    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    w = self.textDict.get(tabName)

    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('&lt;Key&gt;',       k.masterKeyHandler),
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClick3Handler),
    ):
        w.bind(kind,handler)

    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        return self.onRightClick(event,menu)

    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)

    tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
    tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)

    k.completeAllBindingsForWidget(w)
</t>
<t tx="ekr.20070626112754.451">def setBindings (self,):

    '''Create master bindings for all headlines.'''

    tree = self ; k = self.c.k ; canvas = self.canvas

    # g.trace('self',self,'canvas',canvas)

    &lt;&lt; make bindings for a common binding widget &gt;&gt;

    tree.setCanvasBindings(canvas)

    k.completeAllBindingsForWidget(canvas)

    k.completeAllBindingsForWidget(self.bindingWidget)

</t>
<t tx="ekr.20070626112754.452">self.bindingWidget = w = g.app.gui.plainTextWidget(
    self.canvas,name='bindingWidget')

w.bind('&lt;Key&gt;',k.masterKeyHandler)

table = (
    ('&lt;Button-1&gt;',       k.masterClickHandler,          tree.onHeadlineClick),
    ('&lt;Button-3&gt;',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('&lt;Double-Button-1&gt;',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('&lt;Double-Button-3&gt;',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        # g.trace('func',func)
        return handler(event,func)
    w.bind(a,treeBindingCallback)

self.textBindings = w.bindtags()
</t>
<t tx="ekr.20070626112754.453"></t>
<t tx="ekr.20070626112754.454">def isPlainKey (self,shortcut):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self ; shortcut = shortcut or ''

    for s in ('Alt','Ctrl','Command'):
        if shortcut.find(s) != -1:
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('&lt;') and shortcut.endswith('&gt;'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut == 'Tab'
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain
</t>
<t tx="ekr.20070626112754.455">if g.unitTesting:

    import string

    c,p = g.getTestVars()
    k = c.k

    for ch in (string.printable):
        if ch == '\n': continue # A special case.
        assert k.isPlainKey(ch), 'wrong: not plain: %s' % (ch)

    special = (
        'Return', # A special case.
        'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
        'KP_F1','KP_F2','KP_F3','KP_F4',
        'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
        'Home','Left','Linefeed','Next','Num_Lock',
        'PageDn','PageUp','Pause','Prior','Right','Up',
        'Sys_Req',
    )

    for ch in special:
        assert not k.isPlainKey(ch), 'wrong: is plain: %s' % (ch)
</t>
<t tx="ekr.20070626112754.456">def shortcutFromSetting (self,setting):

    k = self

    if not setting:
        return None

    s = g.stripBrackets(setting.strip())
    &lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;
    if k.swap_mac_keys and sys.platform == "darwin":
        &lt;&lt; swap cmd and ctrl keys &gt;&gt;
    &lt;&lt; convert minus signs to plus signs &gt;&gt;
    &lt;&lt; compute the last field &gt;&gt;
    &lt;&lt; compute shortcut &gt;&gt;
    # g.trace(setting,shortcut)
    return shortcut

canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting = shortcutFromSetting
</t>
<t tx="ekr.20070626112754.457">s2 = s.lower()

cmd   = s2.find("cmd") &gt;= 0     or s2.find("command") &gt;= 0
ctrl  = s2.find("control") &gt;= 0 or s2.find("ctrl") &gt;= 0
alt   = s2.find("alt") &gt;= 0
shift = s2.find("shift") &gt;= 0   or s2.find("shft") &gt;= 0
</t>
<t tx="ekr.20070626112754.458">if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
</t>
<t tx="ekr.20070626112754.459"># Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
</t>
<t tx="ekr.20070626112754.460">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    # g.trace(last,last2)
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()

        # New in Leo 4.4.2: Alt-2 is not a key event!
        if last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
</t>
<t tx="ekr.20070626112754.461">table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])
</t>
<t tx="ekr.20070626112754.462">def tkbindingFromStroke (self,stroke):

    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''

    stroke = g.stripBrackets(stroke)

    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)

    # g.trace('&lt;%s&gt;' % stroke)
    return '&lt;%s&gt;' % stroke
</t>
<t tx="ekr.20070626112754.463">def prettyPrintKey (self,stroke,brief=False):

    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    return g.choose(brief,s,'&lt;%s&gt;' % s)
</t>
<t tx="ekr.20070626112754.464">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = False or k.traceMasterCommand
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    &lt;&lt; define specialKeysyms &gt;&gt;
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val</t>
<t tx="ekr.20070626112754.465">specialKeysyms = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)</t>
<t tx="ekr.20070626112754.466">if stroke or len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
</t>
<t tx="ekr.20070626112754.467">def callStateFunction (self,event):

    k = self ; val = None

    # g.trace(k.state.kind)

    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')

    return val
</t>
<t tx="ekr.20070626112754.468">def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
</t>
<t tx="ekr.20070626112754.469">def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: pass # Ignore the key.
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
</t>
<t tx="ekr.20070626112754.470">class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c):

        # g.trace('leoKeyEvent(tkGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        self.widget = self.w

    def __repr__ (self):

        return 'tkGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))</t>
<t tx="ekr.20070626112754.471">def defineSpecialKeys (self):

    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''

    k = self

    # g.trace('base keyHandler')

    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&amp;" : "ampersand",
        "^" : "asciicircum",
        "~" : "asciitilde",
        "*" : "asterisk",
        "@" : "at",
        "\\": "backslash",
        "|" : "bar",
        "{" : "braceleft",
        "}" : "braceright",
        "[" : "bracketleft",
        "]" : "bracketright",
        ":" : "colon",      # removed from code.
        "," : "comma",
        "$" : "dollar",
        "=" : "equal",
        "!" : "exclam",     # removed from code.
        "&gt;" : "greater",
        "&lt;" : "less",
        "-" : "minus",
        "#" : "numbersign",
        '"' : "quotedbl",
        "'" : "quoteright",
        "(" : "parenleft",
        ")" : "parenright", # removed from code.
        "%" : "percent",
        "." : "period",     # removed from code.
        "+" : "plus",
        "?" : "question",
        "`" : "quoteleft",
        ";" : "semicolon",
        "/" : "slash",
        " " : "space",      # removed from code.
        "_" : "underscore",
    }

    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s

    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict.keys():
        k.guiBindNamesInverseDict [k.guiBindNamesDict.get(key)] = key

</t>
<t tx="ekr.20070626112754.472"># One call to Tk.Canvas.bbox remains, but that is in leoTkinterTree so it has no effect on portability.</t>
<t tx="ekr.20070626112754.473"></t>
<t tx="ekr.20070626112754.474">def createMenusFromTables (self):

    c = self.c

    self.defineMenuTables()

    self.createFileMenuFromTable()
    self.createEditMenuFromTable()
    self.createOutlineMenuFromTable()

    g.doHook("create-optional-menus",c=c)

    if self.useCmdMenu:
        self.createCmndsMenuFromTable()

    self.createWindowMenuFromTable()
    self.createHelpMenuFromTable()
</t>
<t tx="ekr.20070626112754.475">def createFileMenuFromTable (self):

    c = self.c
    fileMenu = self.createNewMenu("&amp;File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &amp;With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    &lt;&lt; create the recent files submenu &gt;&gt;
    self.add_separator(fileMenu)
    &lt;&lt; create the read/write submenu &gt;&gt;
    &lt;&lt; create the tangle submenu &gt;&gt;
    &lt;&lt; create the untangle submenu &gt;&gt;
    &lt;&lt; create the import submenu &gt;&gt;
    &lt;&lt; create the export submenu &gt;&gt;
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
</t>
<t tx="ekr.20070626112754.476">self.createNewMenu("Recent &amp;Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
</t>
<t tx="ekr.20070626112754.477">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
</t>
<t tx="ekr.20070626112754.478">tangleMenu = self.createNewMenu("Tan&amp;gle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
</t>
<t tx="ekr.20070626112754.479">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
</t>
<t tx="ekr.20070626112754.480">importMenu = self.createNewMenu("&amp;Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
</t>
<t tx="ekr.20070626112754.481">exportMenu = self.createNewMenu("&amp;Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
</t>
<t tx="ekr.20070626112754.482">def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&amp;Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    &lt;&lt; create the edit body submenu &gt;&gt;
    &lt;&lt; create the edit headline submenu &gt;&gt;
    &lt;&lt; create the find submenu &gt;&gt;

    self.createMenuEntries(editMenu,self.editMenuTop2Table)
</t>
<t tx="ekr.20070626112754.483">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
</t>
<t tx="ekr.20070626112754.484">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
</t>
<t tx="ekr.20070626112754.485">findMenu = self.createNewMenu("&amp;Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
</t>
<t tx="ekr.20070626112754.486">def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&amp;Outline")

    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)

    &lt;&lt; create check submenu &gt;&gt;
    &lt;&lt; create expand/contract submenu &gt;&gt;
    &lt;&lt; create move submenu &gt;&gt;
    &lt;&lt; create mark submenu &gt;&gt;
    &lt;&lt; create goto submenu &gt;&gt;
</t>
<t tx="ekr.20070626112754.487">checkOutlineMenu = self.createNewMenu("Chec&amp;k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
</t>
<t tx="ekr.20070626112754.488">expandMenu = self.createNewMenu("E&amp;xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
</t>
<t tx="ekr.20070626112754.489">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
</t>
<t tx="ekr.20070626112754.490">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
</t>
<t tx="ekr.20070626112754.491">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
</t>
<t tx="ekr.20070626112754.492">def createCmndsMenuFromTable (self):

    cmdsMenu = self.createNewMenu('&amp;Cmds')

    if 0: # Now in the minibuffer table.
        # Used in top table: q,u,x
        self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &amp;: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t,u
        ('&amp;Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&amp;ditors',       self.cmdsMenuBodyEditorsTable),
        ('&amp;Buffers...',         self.cmdsMenuBuffersTable),
        ('&amp;Chapters...',        self.cmdsMenuChaptersTable),
        ('C&amp;ursor/Selection...',[]),
        ('&amp;Focus...',           self.cmdsMenuFocusTable),
        ('&amp;Macro...',           self.cmdsMenuMacroTable),
        ('M&amp;inibuffer',         self.cmdsMenuMinibufferTable),
        #('&amp;Panes...',           self.cmdsMenuPanesTable),
        ('&amp;Pickers...',         self.cmdsMenuPickersTable),
        ('&amp;Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&amp;gisters...',       self.cmdsMenuRegistersTable),
        ('R&amp;un Script/Tests',   self.cmdsMenuRunTable),
        ('Scr&amp;olling...',       self.cmdsMenuScrollTable),
        ('Spell C&amp;heck...',     self.cmdsMenuSpellCheckTable),
        ('&amp;Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&amp;ngs',    self.cmdsMenuToggleTable),
    ):
        if table == self.cmdsMenuChaptersTable and not self.c.chapterController:
            continue
        menu = self.createNewMenu(name,'&amp;Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &amp;: b,e,f,s,t,x
        ('Cursor &amp;Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &amp;Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &amp;To...',                self.cursorMenuExtendTable),
        ('Cursor &amp;Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&amp;xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&amp;ursor/Selection...')
        self.createMenuEntries(menu,table)</t>
<t tx="ekr.20070626112754.493">def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&amp;Window")

    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
</t>
<t tx="ekr.20070626112754.494">def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        self.getMacHelpMenu()
    else:
        helpMenu = self.createNewMenu("&amp;Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)</t>
<t tx="ekr.20070626112754.495">def defineMenuTables (self):

    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

</t>
<t tx="ekr.20070626112754.496">def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
</t>
<t tx="ekr.20070626112754.497">def defineEditMenuTopTable (self):

    self.editMenuTopTable = [
        # &amp;: u,r reserved for undo/redo: a,d,p,t,y.
        # &amp; (later): e,g,n,v.
        ("Can't Undo",'undo'),
        ("Can't Redo",'redo'), 
        '-',
        ('Cu&amp;t','cut-text'),
        ('Cop&amp;y','copy-text'),
        ('&amp;Paste','paste-text'),
        ('&amp;Delete','backward-delete-char'),
        ('Select &amp;All','select-all'),
        '-',
    ]
</t>
<t tx="ekr.20070626112754.498">def defineEditMenuEditBodyTable (self):

    self.editMenuEditBodyTable = [
        # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
        '*extract-&amp;section',
        '*extract-&amp;names',
        '*&amp;extract',
        '-',
        '*convert-all-b&amp;lanks',
        '*convert-all-t&amp;abs',
        '*convert-&amp;blanks',
        '*convert-&amp;tabs',
        '*insert-body-&amp;time',
        '*&amp;reformat-paragraph',
        '-',
        '*&amp;indent-region',
        '*&amp;unindent-region',
        '*&amp;match-brackets',
        '*add-comments',
        '*delete-comments',
    ]
</t>
<t tx="ekr.20070626112754.499">def defineEditMenuEditHeadlineTable (self):

    self.editMenuEditHeadlineTable = [
        '*edit-&amp;headline',
        '*&amp;end-edit-headline',
        '*&amp;abort-edit-headline',
        '*insert-headline-&amp;time',
        '*toggle-&amp;angle-brackets',
    ]
</t>
<t tx="ekr.20070626112754.500">def defineEditMenuFindMenuTable (self):

    self.editMenuFindMenuTable = [
        # &amp;: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,u,w,x
        '*&amp;open-find-tab',
        '*&amp;hide-find-tab',
        '*search-&amp;with-present-options',
        '-',
        '*find-&amp;next',
        '*find-&amp;prev',
        '*&amp;change',
        '*find-&amp;all',
        '*clone-fi&amp;nd-all',
        '*change-a&amp;ll',
        '-',
        '*&amp;find-character',
        '*find-character-extend-&amp;selection',
        '*&amp;backward-find-character',
        '*backward-find-character-&amp;extend-selection',
        '-',
        '*&amp;isearch-forward',
        '*isea&amp;rch-backward',
        '*isearch-forward-rege&amp;xp',
        '*isearch-backward-regex&amp;p',
        '-',
        '*&amp;query-replace',
        '*q&amp;uery-replace-regex',
    ]
</t>
<t tx="ekr.20070626112754.501">def defineEditMenuTop2Table (self):

    c = self.c

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")

    self.editMenuTop2Table = [
        '*&amp;goto-global-line',
        '*&amp;execute-script',
        (label,'toggle-invisibles'),
        ("Setti&amp;ngs",'open-leoSettings-leo'),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
</t>
<t tx="ekr.20070626112754.502">def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
</t>
<t tx="ekr.20070626112754.503">def defineFileMenuTopTable (self):

    self.fileMenuTopTable = [
        '*&amp;new',
        ('&amp;Open...','open-outline'),
    ]
</t>
<t tx="ekr.20070626112754.504">def defineFileMenuTop2Table (self):

    self.fileMenuTop2Table = [
        '-',
        ('&amp;Close','close-window'),
        ('&amp;Save','save-file'),
        ('Save &amp;As','save-file-as'),
        ('Save As &amp;Unzipped','save-file-as-unzipped'),
        ('Save As &amp;Zipped','save-file-as-zipped'),
        ('Save &amp;To','save-file-to'),
        ('Re&amp;vert To Saved','revert'),
    ]
</t>
<t tx="ekr.20070626112754.505">def defineFileMenuReadWriteMenuTable (self):

    self.fileMenuReadWriteMenuTable = [
        '*&amp;read-outline-only',
        ('Read @file &amp;Nodes','read-at-file-nodes'),
        ('Write &amp;Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &amp;Missing @file Nodes','write-missing-at-file-nodes'),
        '*write-&amp;outline-only',
        ('&amp;Write @file Nodes','write-at-file-nodes'),
    ]
</t>
<t tx="ekr.20070626112754.506">def defineFileMenuTangleMenuTable (self):

    self.fileMenuTangleMenuTable = [
        '*tangle-&amp;all',
        '*tangle-&amp;marked',
        '*&amp;tangle',
    ]
</t>
<t tx="ekr.20070626112754.507">def defineFileMenuUntangleMenuTable (self):

    self.fileMenuUntangleMenuTable = [
        '*untangle-&amp;all',
        '*untangle-&amp;marked',
        '*&amp;untangle',
    ]
</t>
<t tx="ekr.20070626112754.508">def defineFileMenuImportMenuTable (self):

    self.fileMenuImportMenuTable = [
        #&amp;: c,d,f,n,o,r,
        '*import-&amp;derived-file',
        ('Import To @&amp;file','import-at-file'),
        ('Import To @&amp;root','import-at-root'),
        '*import-&amp;cweb-files',
        '*import-&amp;noweb-files',
        '*import-flattened-&amp;outline',
    ]
</t>
<t tx="ekr.20070626112754.509">def defineFileMenuExportMenuTable (self):

    self.fileMenuExportMenuTable = [
        '*export-&amp;headlines',
        '*outline-to-&amp;cweb',
        '*outline-to-&amp;noweb',
        '*&amp;flatten-outline',
        '*&amp;remove-sentinels',
        '*&amp;weave',
    ]
</t>
<t tx="ekr.20070626112754.510">def defineFileMenuTop3MenuTable (self):

    self.fileMenuTop3MenuTable = [
        ('E&amp;xit','exit-leo'),
    ]
</t>
<t tx="ekr.20070626112754.511">def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
</t>
<t tx="ekr.20070626112754.512">def defineOutlineMenuTopMenuTable (self):

    self.outlineMenuTopMenuTable = [
        '*c&amp;ut-node',
        '*c&amp;opy-node',
        '*&amp;paste-node',
        ('Pas&amp;te Node As Clone','paste-retaining-clones'),
        '*&amp;delete-node',
        '-',
        '*&amp;insert-node',
        '*&amp;clone-node',
        '*sort-childre&amp;n',
        '*&amp;sort-siblings',
        '-',
        '*&amp;hoist',
        ('D&amp;e-Hoist','de-hoist'), # To preserve the '-' in De-Hoist.
        '-',
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
</t>
<t tx="ekr.20070626112754.513">def defineOutlineMenuCheckOutlineMenuTable (self):

    self.outlineMenuCheckOutlineMenuTable = [
        # &amp;: a,c,d,o
        '*check-&amp;outline',
        '*&amp;dump-outline',
        '-',
        '*check-&amp;all-python-code',
        '*&amp;check-python-code',
    ]
</t>
<t tx="ekr.20070626112754.514">def defineOutlineMenuExpandContractMenuTable (self):

    self.outlineMenuExpandContractMenuTable = [
        '*&amp;contract-all',
        '*contract-&amp;node',
        '*contract-&amp;parent',
        '*contract-or-go-&amp;left',
        '-',
        '*expand-p&amp;rev-level',
        '*expand-n&amp;ext-level',
        '*expand-and-go-right',
        '*expand-or-go-right',
        '-',
        '*expand-to-level-&amp;1',
        '*expand-to-level-&amp;2',
        '*expand-to-level-&amp;3',
        '*expand-to-level-&amp;4',
        '*expand-to-level-&amp;5',
        '*expand-to-level-&amp;6',
        '*expand-to-level-&amp;7',
        '*expand-to-level-&amp;8',
        '-',
        '*expand-&amp;all',
        '*expand-n&amp;ode',
    ]
</t>
<t tx="ekr.20070626112754.515">def defineOutlineMenuMoveMenuTable (self):

    self.outlineMenuMoveMenuTable = [
        ('Move &amp;Down','move-outline-down'),
        ('Move &amp;Left','move-outline-left'),
        ('Move &amp;Right','move-outline-right'),
        ('Move &amp;Up','move-outline-up'),
        '-',
        '*&amp;promote',
        '*&amp;demote',
    ]
</t>
<t tx="ekr.20070626112754.516">def defineOutlineMenuMarkMenuTable (self):

    self.outlineMenuMarkMenuTable = [
        '*&amp;mark',
        '*mark-&amp;subheads',
        '*mark-changed-&amp;items',
        '*mark-changed-&amp;roots',
        '*mark-&amp;clones',
        '*&amp;unmark-all',
    ]
</t>
<t tx="ekr.20070626112754.517">def defineOutlineMenuGoToMenuTable (self):

    self.outlineMenuGoToMenuTable = [
        # &amp;: a,b,c,d,e,f,g,h,i,l,m,n,o,p,r,s,t,v,
        ('Go To &amp;First Node','goto-first-node'),
        ('Go To First V&amp;isible','goto-first-visible-node'),
        ('Go To First Si&amp;bling','goto-first-sibling'),
        '-',
        ('Go To Next C&amp;hanged','goto-next-changed'),
        ('Go To Next &amp;Clone','goto-next-clone'),
        ('Go To Next &amp;Marked','goto-next-marked'),
        ('Go To Next N&amp;ode','goto-next-node'),
        ('Go To Next &amp;Sibling','goto-next-sibling'),
        ('Go To Next Visibl&amp;e','goto-next-visible'),
        ('Go To Next Visite&amp;d','go-forward'),
        '-',
        ('Go To P&amp;arent','goto-parent'),
        '-',
        ('Go To &amp;Prev Node','goto-prev-node'),
        ('Go To P&amp;rev Sibling','goto-prev-sibling'),
        ('Go To Pre&amp;v Visible','goto-prev-visible'),
        ('Go To Prev Visi&amp;ted','go-back'),
        '-',
        ('Go To Last Node','goto-last-node'),
        ('Go To Last Siblin&amp;g','goto-last-sibling'),
        ('Go To &amp;Last Visible','goto-last-visible-node'),
    ]
</t>
<t tx="ekr.20070626112754.518">def defineCmdsMenuTables (self):

    if 0: # Replaced by minibuffer submenu.
        self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuChaptersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuRunTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()</t>
<t tx="ekr.20070626112754.519">def defineCmdsMenuAbbrevTable (self):

    self.cmdsMenuAbbrevTable = [
        # &amp;: a,e,i,k,l,r,w,v
        'abbre&amp;v-mode',
        '-',
        '&amp;list-abbrevs',
        '&amp;read-abbrev-file',
        '&amp;write-abbrev-file',
        '-',
        '&amp;add-global-abbrev',
        '&amp;inverse-add-global-abbrev',
        '&amp;kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&amp;expand-region-abbrevs',
    ]
</t>
<t tx="ekr.20070626112754.520">def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &amp;: a,c,d
        '&amp;add-editor',
        '&amp;cycle-editor-focus',
        '&amp;delete-editor',
    ]</t>
<t tx="ekr.20070626112754.521">def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&amp;append-to-buffer',
        '&amp;kill-buffer',
        'list-&amp;buffers',
        '&amp;list-buffers-alphabetically',
        '&amp;prepend-to-buffer',
        '&amp;rename-buffer',
        '&amp;switch-to-buffer',
    ]
</t>
<t tx="ekr.20070626112754.522">def defineCmdsMenuChaptersTable (self):

    self.cmdsMenuChaptersTable = [
        '&amp;clone-node-to-chapter',
        'c&amp;opy-node-to-chapter',
        'c&amp;reate-chapter',
        '&amp;move-node-to-chapter',
        '&amp;remove-chapter',
        '&amp;select-chapter',
    ]
</t>
<t tx="ekr.20070626112754.523">def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char',
        'back-&amp;paragraph',
        'back-&amp;sentence',
        'back-&amp;word',
        '-',
        'beginning-of-&amp;buffer',
        'beginning-of-&amp;line',
        '-',
        'pre&amp;vious-line',
    ]

    self.cursorMeuuBackExtendTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char-extend-selection',
        'back-&amp;paragraph-extend-selection',
        'back-&amp;sentence-extend-selection',
        'back-&amp;word-extend-selection',
        '-',
        'beginning-of-&amp;buffer-extend-selection',
        'beginning-of-&amp;line-extend-selection',
        '-',
        'pre&amp;vious-line-extend-selection',
    ]

    self.cursorMenuExtendTable = [
        # &amp;: l,p,s,w
        'extend-to-&amp;line',
        'extend-to-&amp;paragraph',
        'extend-to-&amp;sentence',
        'extend-to-&amp;word',
    ]

    self.cursorMenuForwardTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer',
        'end-of-&amp;line',
        '-',
        'forward-&amp;char',
        'forward-&amp;paragraph',
        'forward-&amp;sentence',
        'forward-&amp;end-word',
        'forward-&amp;word',
        '-',
        '&amp;next-line',
    ]

    self.cursorMenuForwardExtendTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer-extend-selection',
        'end-of-&amp;line-extend-selection',
        '-',
        'forward-&amp;char-extend-selection',
        'forward-&amp;paragraph-extend-selection',
        'forward-&amp;sentence-extend-selection',
        'forward-&amp;end-word-extend-selection',
        'forward-&amp;word-extend-selection',#
        '-',
        '&amp;next-line-extend-selection',    
    ]</t>
<t tx="ekr.20070626112754.524">def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&amp;cycle-all-focus',
        'focus-to-&amp;body',          
        'focus-to-&amp;log',             
        'focus-to-&amp;minibuffer',     
        'focus-to-&amp;tree',             
    ]
</t>
<t tx="ekr.20070626112754.525">def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&amp;load-file',
        '-',
        '&amp;start-kbd-macro',
        '&amp;end-kbd-macro',
        '&amp;name-last-kbd-macro',
        '-',
        '&amp;call-last-keyboard-macro',
        '&amp;insert-keyboard-macro',
    ]
</t>
<t tx="ekr.20070626112754.526">def defineCmdsMenuMinibufferTable (self):

    self.cmdsMenuMinibufferTable = [
        # &amp;: f,h,i,q,r,s,v
        '&amp;full-command',
        'keyboard-&amp;quit',
        '&amp;repeat-complex-command',
        '&amp;view-lossage',
        '-',
        '&amp;show-mini-buffer',
        'h&amp;ide-mini-buffer',
        '-',
        '&amp;help-for-minibuffer',
    ]
</t>
<t tx="ekr.20070626112754.527">def defineCmdsMenuPickersTable (self):

    self. cmdsMenuPickersTable = [
        'show-&amp;colors',
        'show-find-&amp;options',
        'show-&amp;fonts',
    ]</t>
<t tx="ekr.20070626112754.528">def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&amp;clear-rectangle',
        'c&amp;lose-rectangle',
        '&amp;delete-rectangle',
        '&amp;kill-rectangle',
        '&amp;open-rectangle',
        '&amp;string-rectangle',
        '&amp;yank-rectangle',
    ]
</t>
<t tx="ekr.20070626112754.529">def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &amp;: a,c,e,i,j,n,p,r,v
        '&amp;append-to-register',
        'copy-r&amp;ectangle-to-register',
        '&amp;copy-to-register',
        'i&amp;ncrement-register',
        '&amp;insert-register',
        '&amp;jump-to-register',
        # 'number-to-register',
        '&amp;point-to-register',
        'p&amp;repend-to-register',
        '&amp;view-register',
    ]
</t>
<t tx="ekr.20070626112754.530">def defineCmdsMenuRunTable (self):

    self.cmdsMenuRunTable = [
    # &amp;: e,r
    '&amp;execute-script',
    '&amp;run-unit-tests',
    ]
</t>
<t tx="ekr.20070626112754.531">def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &amp;: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&amp;line',
        'scroll-outline-down-&amp;page',
        'scroll-outline-le&amp;ft',
        'scroll-outline-&amp;right',
        's&amp;croll-outline-up-line',
        'scr&amp;oll-outline-up-page',
        '-',
        'scroll-&amp;down',
        'scroll-&amp;up',
        '-',
        'scroll-down-&amp;extend-selection',
        'scroll-up-e&amp;xtend-selection',
    ]</t>
<t tx="ekr.20070626112754.532">def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&amp;open-spell-tab',
        'spell-&amp;change',
        'spell-change-&amp;then-find',
        'spell-&amp;find',
        'spell-&amp;ignore',
    ]
</t>
<t tx="ekr.20070626112754.533">def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &amp;: a,b,c,d,e,f,g,i,l,m,n,o,p,r,s,u
        '&amp;beautify',
        'beautify-&amp;all',
        '-',
        'center-&amp;line',
        'center-&amp;region',
        '-',
        '&amp;capitalize-word',
        '&amp;downcase-word',
        '&amp;upcase-word',
        '-',
        'd&amp;owncase-region',
        'u&amp;pcase-region',
        '-',
        '&amp;indent-region',
        'indent-r&amp;elative',
        'indent-ri&amp;gidly',
        'u&amp;nindent-region',
        '-',
        'sort-colu&amp;mns',
        'sort-&amp;fields',
        '&amp;sort-lines',
    ]</t>
<t tx="ekr.20070626112754.534">def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &amp;: d,e,m,s,t,u,v
        'toggle-a&amp;utocompleter',
        'toggle-call&amp;tips',
        'toggle-&amp;extend-mode',
        'toggle-input-&amp;state',
        'toggle-in&amp;visibles',
        'toggle-&amp;mini-buffer',
        'toggle-split-&amp;direction',
        '-',
        # &amp;: a,b,c,f,h,i,r,w,x
        'toggle-find-&amp;ignore-case-option',
        'toggle-find-in-&amp;body-option',
        'toggle-find-in-&amp;headline-option',
        'toggle-find-mark-&amp;changes-option',
        'toggle-find-mark-&amp;finds-option',
        'toggle-find-rege&amp;x-option',
        'toggle-find-&amp;reverse-option',
        'toggle-find-&amp;word-option',
        'toggle-find-wrap-&amp;around-option',
    ]
</t>
<t tx="ekr.20070626112754.535">def defineWindowMenuTables (self):

    self.windowMenuTopTable = [
        # &amp;: a,b,c,d,e,f,l,m,n,o,p,r,s,t,u,w,x,y
        '*&amp;equal-sized-panes',
        '*&amp;toggle-active-pane',
        '*toggle-&amp;split-direction',
        '-',
        '*contract-&amp;body-pane',
        '*contract-&amp;log-pane',
        '*contract-&amp;outline-pane',
        '*contract-&amp;pane',
        '-',
        '*expand-bo&amp;dy-pane',
        '*expand-lo&amp;g-pane',
        '*expand-o&amp;utline-pane',
        '*expand-pa&amp;ne',
        '-',
        '*&amp;fully-expand-body-pane',
        '*full&amp;y-expand-log-pane',
        '*fully-e&amp;xpand-outline-pane',
        '*fully-exp&amp;and-pane',
        '-',
        '*&amp;resize-to-screen',
        '*&amp;cascade-windows',
        '*&amp;minimize-all',
        '-',
        '*open-compare-window',
        '*open-python-&amp;window',
    ]
</t>
<t tx="ekr.20070626112754.536">def defineHelpMenuTables (self):

    self.helpMenuTable = [
        # &amp;: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&amp;About Leo...',           'about-leo'),
        ('Online &amp;Home Page',       'open-online-home'),
        '*open-online-&amp;tutorial',
        '*open-&amp;users-guide',
        '-',
        ('Open Leo&amp;Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&amp;Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&amp;Settings.leo',   'open-leoSettings-leo'),
        ('Open &amp;myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&amp;ipts.leo',       'open-scripts-leo'),
        # ('Open t&amp;est.leo',          'open-test-leo'),
        '-',
        '*he&amp;lp-for-minibuffer',
        '*help-for-&amp;command',
        '-',
        '*&amp;apropos-autocompletion',
        '*apropos-&amp;bindings',
        '*apropos-&amp;debugging-commands',
        '*apropos-&amp;find-commands',
        '-',
        '*pri&amp;nt-bindings',
        '*print-c&amp;ommands',
    ]
</t>
<t tx="ekr.20070626112754.537"></t>
<t tx="ekr.20070626112754.538">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3991223

I assigned both Control and Shift modifiers to do scrolling: this is so my
finger can hit a key in the lower left corner of the keyboard, and I don't have
to worry too much about my aim (I have LARGE fingers). Also, I stop the
scrolling on the JUST button release -- less worry about my finger slipping off
the key.</t>
<t tx="ekr.20070626112754.539"></t>
<t tx="ekr.20070626112754.540"></t>
<t tx="ekr.20070626112754.541">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3916155

When a node is among several other nodes at the same level of hierarchy, which
are all children of a node, and the "MOVE LFET" command is executed, the node
does move left in the outline hierarchy, but it also move down to just before
the next node at the higher hierarchy level - the level to which it is moving
left.

EKR: I love this new option: how did we ever live without it?

@color</t>
<t tx="ekr.20070626112754.542">@nocolor

This option tells how to treat an uppercase letter typed when the outline pane
is active but no headline is being edited. In such situations Leo searchs for an
node whose headline starts with the present prefix, ignoring case The prefix
starts with the first letter typed and other letters are added if they are typed
within a 'short' period of time, as specified by the outline_nav_extend_delay

True: Look in invisible nodes.
False: Look only in visible nodes.

I set this option to False because it is too easy form me to type Shift-whatever
when I meant Ctrl-whatever.

@color</t>
<t tx="ekr.20070626112754.543">http://sourceforge.net/forum/message.php?msg_id=3985382

</t>
<t tx="ekr.20070626112754.544"></t>
<t tx="ekr.20070626112754.545"></t>
<t tx="ekr.20070626112754.546"></t>
<t tx="ekr.20070626112754.547">def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()

    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
</t>
<t tx="ekr.20070626112754.548">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4132529

I'm generating Leo files with ElementTree and ran into a minor issue.

ElementTree generates an empty tag with a space before the closing slash:

&lt;globals /&gt;

in Leo's code for dummy elements to allow copied nodes to be valid Leo files,
the empty tags are generated without the space

leoFileCommands.py 2917
        self.put('&lt;globals/&gt;\n')
        self.put('&lt;preferences/&gt;\n')
        self.put('&lt;find_panel_settings/&gt;\n')

it then checks for these tags in getDummyElements() leoFileCommands.py 1298

Since ElementTree has the space before the slash, 
it's XML is considered invalid by Leo according to
this test.

I would like it if the space could be added in Leo's
self.put(...) and the check in getDummyElements()

The XML specs show the space as optional.

@color</t>
<t tx="ekr.20070626112754.549">def putClipboardHeader (self):

    c = self.c ; tnodes = 0
    &lt;&lt; count the number of tnodes &gt;&gt;
    self.put('&lt;leo_header file_format="1" tnodes=')
    self.put_in_dquotes(str(tnodes))
    self.put(" max_tnode_index=")
    self.put_in_dquotes(str(tnodes))
    self.put("/&gt;") ; self.put_nl()

    # New in Leo 4.4.3: Add dummy elements so copied nodes form a valid .leo file.
    self.put('&lt;globals/&gt;\n')
    self.put('&lt;preferences/&gt;\n')
    self.put('&lt;find_panel_settings/&gt;\n')
</t>
<t tx="ekr.20070626112754.550">c.clearAllVisited()

for p in c.currentPosition().self_and_subtree_iter():
    t = p.v.t
    if t and not t.isWriteBit():
        t.setWriteBit()
        tnodes += 1
</t>
<t tx="ekr.20070626112754.551">def getDummyElements (self):

    # New in Leo 4.4.3: Ignore the dummy elements that allow
    # Pasted Leo outlines to be valid .leo files.
    while 1:
        for tag in ('&lt;globals','&lt;preferences','&lt;find_panel_settings'):
            if self.matchTag(tag) and self.matchTag('/&gt;'):
                break
        else:
            break
</t>
<t tx="ekr.20070626112754.552"></t>
<t tx="ekr.20070626112754.553">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4134384
By: rshanley

A C++ sourcefile that opens and closes multiple namespace blocks messes up the
import. I noticed this for a source file that would 1) open a namespace block
to define a class, 2) close the namespace block and provide the constructor
for the class just defined, and 3) repeat 1) and 2) many times. When this first
occured I thought leo was hung, the word "namepace" appeared in the log pane
13 times where the actual number of namespace blocks was 10, and the .leo file
grew by 24 Mb. When the offending @file node was deleted, the size of the file
shrunk from about 33 Mb to about 9 Mb.

The following small test file causes Import To @File to produce a corrupt
outline.

On a positive note, I have been using leo profitably in navigating unfamiliar
C++ source code for about two months in concert with other tools. This is the
first problem I've had, other than cockpit error.

@color
@language c++

namespace arb
{
    class a: public dbm::X
    {
    public:
        a(int c);
    private:
        int m_a;
    };
}

arb::a::a
(
    int c
)
{
    m_a = c**2;
}


namespace arb
{
    class b: public dbm::X
    {
    public:
    b(int c);
    private:
    int m_a;
    };
}

arb::a::b
(
int c
)
{
m_b = c**2;
}


namespace arb
{

class c: public dbm::X
{
public:
c(int c);
private:
int m_a;
};
}

arb::a::c
(
int c
)
{
m_a = c**2;
}

namespace arb
{

class d: public dbm::X
{
public:
d(int c);
private:
int m_a;
};
}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20070626112754.554"># Creates a child of parent for each C function definition seen.

def scanCText (self,s,parent):

    scanner = self.cScanner(self)
    scanner.scan(s,parent)
</t>
<t tx="ekr.20070626112754.555">@
The C scanner uses an internal class as an organizational aid. This is far
superior, imo, to using a single huge scanCText function organized with noweb
section references. Indeed, the helper class creates a separate namespace for
use by the various helper functions.

At present only the C scanner uses this organization, and the utilities of the
cScanner class are identical to the utilites of the leoImportCommands class.
This duplication would go away if all the scanners derived from a baseScanner
class, but that is not likely any time soon, if ever.
@c

class cScanner:
    @others</t>
<t tx="ekr.20070626112754.556">def __init__ (self,importer):

    # Copy ivars.
    self.c = importer.c
    self.encoding = importer.encoding
    self.methodKind = g.choose(importer.fileType==".c","functions","methods")
    self.methodName = importer.methodName
    self.rootLine = importer.rootLine
    self.treeType = importer.treeType

    # Other ivars.
    self.function_start = 0
    self.name = None
    self.scan_start = 0
</t>
<t tx="ekr.20070626112754.557">def scan (self,s,parent,init=True):

    c = self.c
    if init:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language c\n")
    else:
        saveData = self.name,self.function_start,self.scan_start

    self.name,self.function_start,self.scan_start = '',0,0
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        # if i == 0 or ch == '\n': g.trace('line',repr(g.get_line(s,i)))
        # g.trace('ch',repr(ch))
        if ch == '/':         i = self.skipComments(s,i)
        elif ch in ('"',"'"): i = g.skip_string(s,i)
        elif ch == '(':     i = self.doOuterParen(s,i,parent) # Possible function/method definition.
        elif ch == ';':     i = self.doSemicolon(s,i) # Signals a possible start of a function.
        elif g.is_c_id(ch): i = self.doId(s,i,parent) # Possible class/namespace definition.
        else: i += 1
        assert i &gt; progress
    self.appendUnusedText(s,i,parent)
    if init:
        if parent.hasChildren(): c.appendStringToBody(parent,'@others')
    else:
        self.name,self.function_start,self.scan_start = saveData</t>
<t tx="ekr.20070626112754.558">def appendUnusedText (self,s,i,parent):

    c = self.c

    i = g.skip_ws_and_nl(s,self.scan_start)
    if i &lt; len(s):
        s2 = s[self.scan_start:]
        # g.trace(repr(s2))
        c.appendStringToBody(parent,s2)
</t>
<t tx="ekr.20070626112754.559">def doId (self,s,i,parent):

    j = i ; i = g.skip_c_id(s,i)
    name = s[j:i]
    if name in ('class','namespace'):
        i = self.doInner(s,j,parent,name)
    else:
        self.name = name
        while g.match(s,i,'::'):
            self.name = self.name + '::'
            i = g.skip_ws_and_nl(s,i+2)
            if g.match(s,i,'~'):
                i += 1
                self.name = self.name + '~'
            i = g.skip_ws_and_nl(s,i)
            j = i ; i = g.skip_c_id(s,i)
            name2 = s[j:i]
            self.name = self.name + name2
    return i
</t>
<t tx="ekr.20070626112754.560">def doInner (self,s,i,parent,kind):

    '''Handle a namespace or class definition.'''

    c = self.c
    start = i
    i += len(kind)
    j = g.skip_ws_and_nl(s,i)
    i = g.skip_c_id(s,j)
    name = s[j:i].strip()
    if not name: return i
    i = g.skip_ws_and_nl(s,i)
    bracket = i
    if not g.match(s,i,'{'): return i
    i = g.skip_braces(s,i)
    if g.match(s,i,'}'):
        end = i
        i = g.skip_ws_and_nl(s,i+1)
        if g.match(s,i,';'): i += 1
        # Append previous text.
        prev = s[self.scan_start:start]
        c.appendStringToBody(parent,prev)
        self.scan_start = self.function_start = i
        preamble = s[start:bracket+1]
        # Create children.
        p = self.createHeadline(parent,headline='%s %s' % (kind,name),body=preamble)
        body = s[bracket+1:end]
        self.scan(body,p.copy(),init=False)
        # Finish the text.
        if p.hasChildren(): c.appendStringToBody(p,'\n\t@others')
        c.appendStringToBody(p,s[end:i])    
    else:
        g.trace('missing "}" following %s' % kind)
    return i
</t>
<t tx="ekr.20070626112754.561">def doOuterParen (self,s,i,parent):

    '''Handle '(' at the top level.
    This begins a function/method if and only if the character after the matching ')' is '{'.'''

    # Skip the param list.  It may not be properly matched if there are #if's involved.
    c = self.c
    i = g.skip_parens(s,i)
    if not g.match(s,i,')'): return i
    i = g.skip_ws_and_nl(s,i+1)
    if g.match(s,i,';'):
        return self.doSemicolon(s,i)
    elif g.match(s,i,'='):
        # An initializer ends a declaration.
        i = g.skip_ws_and_nl(s,i+1)
        if g.match(s,i,'{'):
            i = g.skip_braces(s,i)
        self.function_start = i
        return i
    elif g.match(s,i,'{'):
        i = g.skip_braces(s,i)
        if g.match(s,i,'}'):
            i += 1
            # g.trace('function %s' % self.name)
            c.appendStringToBody(parent,s[self.scan_start:self.function_start])
            body = s[self.function_start:i]
            p = self.createHeadline(parent,headline=self.name,body=body)
        else:
            g.trace('no matching "}" in function/method definition')
        self.scan_start = self.function_start = i
        return i
    else:
        return i
</t>
<t tx="ekr.20070626112754.562">def doSemicolon (self,s,i):

    self.function_start = i+1 # The semicolon ends the declaration.
    return i+1
</t>
<t tx="ekr.20070626112754.563">def skipComments (self,s,i):

    if g.match(s,i,"//"):
        i = g.skip_line(s,i)
    elif g.match(s,i,"/*"):
        i = g.skip_block_comment(s,i)
    else:
        i += 1

    return i
</t>
<t tx="ekr.20070626112754.564"></t>
<t tx="ekr.20070626112754.565">def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)
    # Create the vnode.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)
    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
</t>
<t tx="ekr.20070626112754.566">def error (self,s): g.es(s)
</t>
<t tx="ekr.20070626112754.567">def getLeadingIndent (self,s,i):

    """Return the leading whitespace of a line, ignoring blank and comment lines."""

    i = g.find_line_start(s,i)
    while i &lt; len(s):
        # g.trace(g.get_line(s,i))
        j = g.skip_ws(s,i) # Bug fix: 2/14/03
        if g.is_nl(s,j) or g.match(s,j,"#"): # Bug fix: 2/14/03
            i = g.skip_line(s,i) # ignore blank lines and comment lines.
        else:
            i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
            # g.trace("returns:",width)
            return width
    # g.trace("returns:0")
    return 0
</t>
<t tx="ekr.20070626112754.568"># The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):

    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
</t>
<t tx="ekr.20070626112754.569">def massageComment (self,s):

    """Returns s with all runs of whitespace and newlines converted to a single blank.

    Also removes leading and trailing whitespace."""

    s = s.strip()
    s = s.replace("\n"," ")
    s = s.replace("\r"," ")
    s = s.replace("\t"," ")
    s = s.replace("  "," ")
    s = s.strip()
    return s
</t>
<t tx="ekr.20070626112754.570">def setEncoding (self):

    # scanDirectives checks the encoding: may return None.
    theDict = g.scanDirectives(self.c)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
</t>
<t tx="ekr.20070626112754.571">def skipLeadingComments (self,s):

    """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

    Returns (body, comment)"""

    # g.trace(g.get_line(s,0))
    s_original = s
    s = s.lstrip()
    i = 0 ; comment = ""
    if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
        &lt;&lt; scan for C-style comments &gt;&gt;
    elif self.fileType == ".lua":
        &lt;&lt; scan for Lua comments &gt;&gt;
    elif self.fileType == ".pas":
        &lt;&lt; scan for Pascal comments &gt;&gt;
    elif self.fileType == ".py":
        &lt;&lt; scan for Python comments &gt;&gt;
    comment = string.strip(comment)
    if len(comment) == 0:
        return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
    elif self.treeType == "@file":
        return s[i:], "@ " + comment
    else:
        return s[i:], "@ " + comment + "\n"
</t>
<t tx="ekr.20070626112754.572">while i &lt; len(s):
    if g.match(s,i,"//"): # Handle a C++ comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,"/*"): # Handle a block C comment.
        j = i + 2 ; i = g.skip_block_comment (s,i)
        k = g.choose(g.match(s,i-2,"*/"),i-2,i)
        if self.fileType == ".java":
            # 8/2/02: a hack: add leading whitespace then remove it.
            comment = self.undentBody(comment)
            comment2 = ' ' * 2 + s[j:k]
            comment2 = self.undentBody(comment2)
            comment = comment + comment2 + "\n"
        else:
            comment = comment + self.massageComment(s[j:k]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.573">while i &lt; len(s):
    if g.match(s,i,"--"): # Handle a Lua line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.574">while i &lt; len(s):
    if g.match(s,i,"//"): # Handle a Pascal line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,'(*'):
        j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.575">while i &lt; len(s) and g.match(s,i,'#'):
    j = i + 1 ; i = g.skip_line(s,i)
    comment = self.undentBody(comment)
    comment = comment + self.massageComment(s[j:i]) + "\n"
    # 8/2/02: Preserve leading whitespace for undentBody
    i = g.skip_ws(s,i)
    i = g.skip_blank_lines(s,i)
</t>
<t tx="ekr.20070626112754.576"># We look at the first line to determine how much leading whitespace to delete.

def undentBody (self,s):

    """Removes extra leading indentation from all lines."""

    # g.trace(s)
    i = 0 ; result = ""
    # Copy an @code line as is.
    if g.match(s,i,"@code"):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]
    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i)
    if undent == 0: return s
    while i &lt; len(s):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        line = s[j:i]
        # g.trace(line)
        line = g.removeLeadingWhitespace(line,undent,self.tab_width)
        result += line
    return result
</t>
<t tx="ekr.20070626112754.577">Down arrow wasn't handled properly.</t>
<t tx="ekr.20070626112754.578"></t>
<t tx="ekr.20070626112754.579">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3994218
By: rich_ries

Leo 4.4.2.1 (also seen in 4.4 final)

I was commenting some code, using the markup marks for various emphases. When
I went back and moved the cursor over the first two characters (the hidden markup
characters) of the line, I got the following error message:

===========================================================
exception executing command
Traceback (most recent call last):

  File "...leoCommands.py",line 264, in doCommand
    val = command(event)

  File "...leoEditCommands.py", line 3703, in nextLine
    g.app.gui.setSelectionRange(w,'end-%dc' % (len(selected)+1),'end-1c') # works

  File "...leoEditCommands.py", line 3314, in moveUpOrDownHelper
    txt = w.get( 'insert linestart', 'insert lineend' )

TypeError: unpack non-sequence
===========================================================

I did not get this when moving the cursor over the visible characters.

@color</t>
<t tx="ekr.20070626112754.580"></t>
<t tx="ekr.20070626112754.581">Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\prog\tigris-cvs\leo\plugins\groupOperations.py", line 139, in &lt;module&gt;
    groupOpPI = Tkinter.PhotoImage( data = groupOps )
  File "C:\prog\tigris-cvs\leo\plugins\groupOperations.py", line 139, in &lt;module&gt;
    groupOpPI = Tkinter.PhotoImage( data = groupOps )

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'

RuntimeError: Too early to create image
RuntimeError: Too early to create image

IronPythonGui 1
found  1 test routine for leoOPML
found  1 test routine for leoOPML
unexpected exception in g.importFromPath(leo_pdf)
unexpected exception in g.importFromPath(leo_pdf)
Traceback (most recent call last):
Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\prog\tigris-cvs\leo\plugins\leo_pdf.py", line 401, in &lt;module&gt;
    class Writer (docutils.writers.Writer):
  File "C:\prog\tigris-cvs\leo\plugins\leo_pdf.py", line 401, in &lt;module&gt;
    class Writer (docutils.writers.Writer):

AttributeError: 'module' object has no attribute 'writers'
AttributeError: 'module' object has no attribute 'writers'

---mod_leo2asc 0.4-------
unexpected exception in g.importFromPath(nodebar)
unexpected exception in g.importFromPath(nodebar)
Traceback (most recent call last):
Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\prog\tigris-cvs\leo\plugins\nodebar.py", line 33, in &lt;module&gt;
    nodeupPI = Tk.PhotoImage( data = nodeup )
  File "C:\prog\tigris-cvs\leo\plugins\nodebar.py", line 33, in &lt;module&gt;
    nodeupPI = Tk.PhotoImage( data = nodeup )

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'

RuntimeError: Too early to create image
RuntimeError: Too early to create image

rst3 plugin: SilverCity not loaded
unexpected exception in g.importFromPath(templates)
unexpected exception in g.importFromPath(templates)
Traceback (most recent call last):
Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\prog\tigris-cvs\leo\plugins\templates.py", line 88, in &lt;module&gt;
    templatePI = Tkinter.PhotoImage(data=template)
  File "C:\prog\tigris-cvs\leo\plugins\templates.py", line 88, in &lt;module&gt;
    templatePI = Tkinter.PhotoImage(data=template)

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'

RuntimeError: Too early to create image
RuntimeError: Too early to create image

@suite test syntax of all plugins
EEEEE..E.......................................................................................................................
======================================================================
ERROR: @test test.leo

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in d
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 615, in runLeoTest
    ok, frame = g.openWithFileName(path,c,enableLog=False)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 822, in openWithFileName
    g.es("exceptions opening: %s" % (fileName),color="red")
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

======================================================================
ERROR: @test leoDist.leo

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in d
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 615, in runLeoTest
    ok, frame = g.openWithFileName(path,c,enableLog=False)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 822, in openWithFileName
    g.es("exceptions opening: %s" % (fileName),color="red")
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

======================================================================
ERROR: @test LeoPy.leo

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in d
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 615, in runLeoTest
    ok, frame = g.openWithFileName(path,c,enableLog=False)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 822, in openWithFileName
    g.es("exceptions opening: %s" % (fileName),color="red")
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

======================================================================
ERROR: @test leoPlugins.leo

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in d
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 615, in runLeoTest
    ok, frame = g.openWithFileName(path,c,enableLog=False)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 822, in openWithFileName
    g.es("exceptions opening: %s" % (fileName),color="red")
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

======================================================================
ERROR: @test LeoDocs.leo

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in d
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 615, in runLeoTest
    ok, frame = g.openWithFileName(path,c,enableLog=False)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 822, in openWithFileName
    g.es("exceptions opening: %s" % (fileName),color="red")
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

======================================================================
ERROR: ('test function', '&lt;unbound method opmlFileCommandsClass.test_fc_deleteFileWithMessage&gt;')
----------------------------------------------------------------------
Traceback (most recent call last):
  File "&lt;string&gt;", line 57, in runTest
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "&lt;string&gt;", line 4, in test_fc_deleteFileWithMessage
  File "c:\prog\tigris-cvs\leo\src\leoFileCommands.py", line 2307, in deleteFileWithMessage
    g.es("exception deleting backup file:" + fileName)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

----------------------------------------------------------------------
Ran 127 tests in 1077.640s

FAILED (errors=6)
Traceback (most recent call last):
  File "C:\prog\test\leoBridgeTest.py", line 79, in &lt;module&gt;
    main()
  File "C:\prog\test\leoBridgeTest.py", line 32, in main
    runUnitTests(c,g)
  File "C:\prog\test\leoBridgeTest.py", line 71, in runUnitTests
    g.es('unexpected exception')
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError
&gt;&gt;&gt;</t>
<t tx="ekr.20070626112754.582">def ecnl(tabName='Log'):
    g.ecnls(1,tabName)

def ecnls(n,tabName='Log'):
    log = app.log
    if log and not log.isNull:
        while log.newlines &lt; n:
            g.enl(tabName)

def enl(tabName='Log'):
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl(tabName)

def es(s,*args,**keys):
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get('color')
    tabName = keys.get('tabName','Log')
        # Default goes to log pane *Not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and log.isNull:
            pass
        elif log:
            # print 'g.es',s
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
</t>
<t tx="ekr.20070626112754.583"># The buggy code only happens when there is no binding for backward-delete-char.
# http://sourceforge.net/forum/forum.php?thread_id=1681392&amp;forum_id=10227</t>
<t tx="ekr.20070626112754.584"></t>
<t tx="ekr.20070626112754.585"></t>
<t tx="ekr.20070626112754.586">def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    p = c.nodeHistory.goNext()
    if not p: return

    if c.contractVisitedNodes:
        p.contract()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.587">def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    p = c.nodeHistory.goPrev()
    if not p: return

    if c.contractVisitedNodes:
        p.contract()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.588">def goToFirstNode (self,event=None):

    '''Select the first node of the entire outline.'''

    c = self ; p = c.rootPosition()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.589">def goToFirstSibling (self,event=None):

    '''Select the first sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    if p.hasBack():
        while p.hasBack():
            p.moveToBack()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.590">def goToFirstVisibleNode (self,event=None):

    '''Select the first visible node of the selected chapter or hoist.'''

    c = self

    p = c.firstVisible()
    if p:
        c.selectPosition(p)

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.591">def goToLastNode (self,event=None):

    '''Select the last node in the entire tree.'''

    c = self ; p = c.rootPosition()
    while p and p.hasThreadNext():
        p.moveToThreadNext()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.592">def goToLastSibling (self,event=None):

    '''Select the last sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    if p.hasNext():
        while p.hasNext():
            p.moveToNext()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.593">def goToLastVisibleNode (self,event=None):

    '''Select the last visible node of selected chapter or hoist.'''

    c = self

    p = c.lastVisible()
    if p:
        c.selectPosition(p)

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.594">def goToNextClone (self,event=None):

    '''Select the next node that is a clone of the selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return
    if not p.isCloned(): return

    t = p.v.t
    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.v.t == t:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
</t>
<t tx="ekr.20070626112754.595">def goToNextDirtyHeadline (self,event=None):

    '''Select the node that is marked as changed.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isDirty():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
</t>
<t tx="ekr.20070626112754.596">def goToNextMarkedHeadline (self,event=None):

    '''Select the next marked node.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isMarked():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
</t>
<t tx="ekr.20070626112754.597">def goToNextSibling (self,event=None):

    '''Select the next sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.next())
</t>
<t tx="ekr.20070626112754.598">def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.parent())
</t>
<t tx="ekr.20070626112754.599">def goToPrevSibling (self,event=None):

    '''Select the previous sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.back())
</t>
<t tx="ekr.20070626112754.600">def selectThreadBack (self,event=None):

    '''Select the node preceding the selected node in outline order.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadBack()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.601">def selectThreadNext (self,event=None):

    '''Select the node following the selected node in outline order.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()

    c.treeSelectHelper(p)</t>
<t tx="ekr.20070626112754.602"># This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return
    if not c.canSelectVisBack(): return

    p.moveToVisBack(c)

    if p:
        redraw = not p.isVisible(c)
        if not redraw: c.frame.tree.setSelectedLabelState(c.currentPosition())
    else:
        redraw = True

    c.treeSelectHelper(p,redraw=redraw)
</t>
<t tx="ekr.20070626112754.603">def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return
    if not c.canSelectVisNext(): return

    p.moveToVisNext(c)

    if p:
        redraw = not p.isVisible(c)
        if not redraw: c.frame.tree.setSelectedLabelState(c.currentPosition())
    else:
        redraw = True

    c.treeSelectHelper(p,redraw=redraw)
</t>
<t tx="ekr.20070626112754.604"></t>
<t tx="ekr.20070626112754.605">def treeFocusHelper (self):

    c = self

    if c.config.getBool('stayInTreeAfterSelect'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.606">def treeSelectHelper (self,p,redraw=True):

    c = self ; current = c.currentPosition()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectPosition(p,updateBeadList=False)
        finally:
            c.endUpdate(redraw)

    c.treeFocusHelper()
</t>
<t tx="ekr.20070626112754.607"></t>
<t tx="ekr.20070626112754.608">def contractAllHeadlines (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self

    c.beginUpdate()
    try: # update...
        for p in c.allNodes_iter():
            p.contract()
        # Select the topmost ancestor of the presently selected node.
        p = c.currentPosition()
        while p and p.hasParent():
            p.moveToParent()
        c.selectVnode(p)
    finally:
        c.endUpdate()

    c.treeFocusHelper()

    c.expansionLevel = 1 # Reset expansion level.
</t>
<t tx="ekr.20070626112754.609">def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.currentPosition()

    # g.trace(p.headString())

    c.beginUpdate()
    try:
        p.contract()
    finally:
        c.endUpdate()

    c.treeFocusHelper()
</t>
<t tx="ekr.20070626112754.610">def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()

    if p.hasChildren() and p.isExpanded():
        # g.trace('contract',p.headString())
        c.contractNode()
    elif p.hasParent() and p.parent().isVisible(c):
        # g.trace('goto parent',p.headString())
        c.goToParent()

    c.treeFocusHelper()</t>
<t tx="ekr.20070626112754.611">def contractParent (self,event=None):

    '''Contract the parent of the presently selected node.'''

    c = self ; p = c.currentPosition()

    parent = p.parent()
    if not parent: return

    c.beginUpdate()
    try:
        parent.contract()
    finally:
        c.endUpdate(False)

    c.treeSelectHelper(parent)
</t>
<t tx="ekr.20070626112754.612">def expandAllHeadlines (self,event=None):

    '''Expand all headlines.
    Warning: this can take a long time for large outlines.'''

    c = self ; p = root = c.rootPosition()

    c.beginUpdate()
    try:
        while p:
            c.expandSubtree(p)
            p.moveToNext()
        c.selectVnode(root)
    finally:
        c.endUpdate()
        c.treeFocusHelper()

    c.expansionLevel = 0 # Reset expansion level.
</t>
<t tx="ekr.20070626112754.613">def expandAllSubheads (self,event=None):

    '''Expand all children of the presently selected node.'''

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.beginUpdate()
    try:
        c.expandSubtree(v)
        while child:
            c.expandSubtree(child)
            child = child.next()
        c.selectVnode(v)
    finally:
        c.endUpdate()
        c.treeFocusHelper()
</t>
<t tx="ekr.20070626112754.614">def expandLevel1 (self,event=None):
    '''Expand the outline to level 1'''
    self.expandToLevel(1)

def expandLevel2 (self,event=None):
    '''Expand the outline to level 2'''
    self.expandToLevel(2)

def expandLevel3 (self,event=None):
    '''Expand the outline to level 3'''
    self.expandToLevel(3)

def expandLevel4 (self,event=None):
    '''Expand the outline to level 4'''
    self.expandToLevel(4)

def expandLevel5 (self,event=None):
    '''Expand the outline to level 5'''
    self.expandToLevel(5)

def expandLevel6 (self,event=None):
    '''Expand the outline to level 6'''
    self.expandToLevel(6)

def expandLevel7 (self,event=None):
    '''Expand the outline to level 7'''
    self.expandToLevel(7)

def expandLevel8 (self,event=None):
    '''Expand the outline to level 8'''
    self.expandToLevel(8)

def expandLevel9 (self,event=None):
    '''Expand the outline to level 9'''
    self.expandToLevel(9)
</t>
<t tx="ekr.20070626112754.615">def expandNextLevel (self,event=None):

    '''Increase the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(c.expansionLevel + 1)
</t>
<t tx="ekr.20070626112754.616">def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    c = self ; v = c.currentVnode()

    c.beginUpdate()
    try:
        v.expand()
    finally:
        c.endUpdate()
        c.treeFocusHelper()
</t>
<t tx="ekr.20070626112754.617">def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        c.treeFocusHelper()
        return

    c.beginUpdate()
    try:
        if not p.isExpanded():
            c.expandNode()
        c.selectVnode(p.firstChild())
    finally:
        c.endUpdate()
        c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode()
        else:
            c.beginUpdate()
            try:
                c.selectVnode(p.firstChild())
            finally:
                c.endUpdate()
    c.treeFocusHelper()
</t>
<t tx="ekr.20070626112754.618">def expandOnlyAncestorsOfNode (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self ; level = 1

    c.beginUpdate()
    try:
        for p in c.allNodes_iter():
            p.contract()
        for p in c.currentPosition().parents_iter():
            p.expand()
            level += 1
    finally:
        c.endUpdate()
        c.treeFocusHelper()

    c.expansionLevel = level # Reset expansion level.
</t>
<t tx="ekr.20070626112754.619">def expandPrevLevel (self,event=None):

    '''Decrease the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(max(1,c.expansionLevel - 1))
</t>
<t tx="ekr.20070626112754.620"></t>
<t tx="ekr.20070626112754.621">def cantMoveMessage (self):

    c = self ; h = c.rootPosition().headString()
    kind = g.choose(h.startswith('@chapter'),'chapter','hoist')
    g.es("Can't move node out of %s" % (kind),color="blue")
</t>
<t tx="ekr.20070626112754.622">def demote (self,event=None):

    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    command = 'Demote'
    if not current or not current.hasNext():
        c.treeFocusHelper() ; return

    # Make sure all the moves will be valid.
    next = current.next()
    while next:
        if not c.checkMoveWithParentWithWarning(next,current,True):
            c.treeFocusHelper() ; return
        next.moveToNext()

    c.beginUpdate()
    try: # update...
        c.endEditing()
        u.beforeChangeGroup(current,command)
        p = current.copy()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            undoData = u.beforeMoveNode(child)
            child.moveToNthChildOf(p,p.numberOfChildren())
            u.afterMoveNode(child,command,undoData)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = current.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(current,command,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(current)  # Also sets rootPosition.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(current) # Moving can change syntax coloring.
</t>
<t tx="ekr.20070626112754.623">@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):

    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    next = p.visNext(c)

    while next and p.isAncestorOf(next):
        next = next.visNext(c)
    if not next:
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        &lt;&lt; Move p down &amp; set moved if successful &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20070626112754.624">if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)

else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)

if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20070626112754.625">def moveOutlineLeft (self,event=None):

    '''Move the selected node left if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    if not p.hasParent():
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        if sparseMove: # New in Leo 4.4.2
            parent.contract()
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20070626112754.626">def moveOutlineRight (self,event=None):

    '''Move the selected node right if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    back = p.back()
    if not back:
        c.treeFocusHelper()
        return

    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeFocusHelper()
        return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # g.trace(p,p.parent())
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20070626112754.627">def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    back = p.visBack(c)
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        &lt;&lt; Move p up &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)

    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20070626112754.628">if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

parent = p.parent()

# For this special case we move p after back2.
specialCase = back2 and p.v in back2.v.t.vnodeList

if specialCase:
    # The move must be legal.
    moved = True
    back2.contract()
    p.moveAfter(back2)
elif not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            moved = False
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        # g.trace('move to root')
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20070626112754.629">def promote (self,event=None):

    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren():
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        u.beforeChangeGroup(p,command)
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            undoData = u.beforeMoveNode(child)
            child.moveAfter(after)
            after = child
            u.afterMoveNode(child,command,undoData)
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterChangeGroup(p,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20070626112754.630">def endEditLabelCommand (self,event=None):

    '''End editing of a headline and move focus to the body pane.'''

    frame = self ; c = frame.c
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        # g.trace('setting focus')
        if c.config.getBool('stayInTreeAfterEditHeadline'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.631"></t>
<t tx="ekr.20070626112754.632"># Ends the editing in the outline.

def endEditing(self):

    c = self
    c.frame.tree.endEditLabel()
</t>
<t tx="ekr.20070626112754.633">@nocolor

It's about Nav_buttons v1.5 (cvs version from last Saturday) 

Pressing the green back button causes 

Error: 1 
AttributeError Exception in Tk callback 
Function: &lt;bound method Commands.goPrevVisitedNode of Commander 39717104: u'F:\\D\\PIM\\PIM_main.leo'&gt; (type: &lt;type 'instancemethod'&gt;) 
Args: () 
Traceback (innermost last): 
File "F:\C\Programs\Leo_cvs\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__ 
return apply(self.func, args) 
File "F:\C\Programs\Leo_cvs\src\leoCommands.py", line 4435, in goPrevVisitedNode 
c.treeCommandHelper(v) 
AttributeError: Commands instance has no attribute 'treeCommandHelper' 

@color</t>
<t tx="ekr.20070626112754.634">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4201463
By: fgeatfhv

I have done a cvs update today afternoon.

I know that there was an issue with the cursor. The problem there was that it
jumped down several lines at once after the 2nd key press. This one seems different
from that, though, as it goes down 2 lines if there are empty lines following
the line the cursor currently stands on.

@color
</t>
<t tx="ekr.20070626112754.635">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4205072
By: rcy3cornelledu

I find the following behavior strange: In a new window, make node "A" and clone
it.  Then make node "B" and put it between the cloned nodes "A", and finally
select the bottom node "A" so that the outline looks like:

A
B
A &lt;- select this node

Now, perform a "Move Node Up" operation, with keyboard or menu.  I get:

A &lt;- this node selected
B
A

It seems that the cloned nodes have swapped positions.  I would have expected
to see:

A
A &lt;- this node selected
B

which would be more like the behavior if I select the top node and "Move Down"


I am using the evening-of-March 6, 2007 CVS snapshot of LEO on ActivePython,
on the following platforms:

Leo 4.4.3 alpha 1, build  1.124 , January 26, 2006
Python 2.4.3, Tk 8.4.12, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

Leo 4.4.3 alpha 1, build  1.124 , January 26, 2006
Python 2.4.3, Tk 8.4.12, Pmw 1.2
linux2

If I can provide any more information, please let me know:
richard.c.yeh@bankofamerica.com, richard.c.yeh@gmail.com (I use LEO both at
work and at home.)

@color
</t>
<t tx="ekr.20070626112754.636">
Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2474, in doHook
    return f(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 92, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 70, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 49, in callTagHandler
    result = handler(tag,keywords)

  File "C:\prog\tigris-cvs\leo\plugins\rClick.py", line 156, in rClicker
    n0,p0=ind0.split('.',2)

AttributeError: 'int' object has no attribute 'split'
</t>
<t tx="ekr.20070626112754.637">@nocolor

the current CVS does not write to the log pane that settings, either present
in myLeoSettings.leo or the current file, were read.

@color
</t>
<t tx="ekr.20070626112754.638">def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    &lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print()
                print s
                g.app.logWaiting.append((s+'\n','blue'),)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)</t>
<t tx="ekr.20070626112754.639"># This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None</t>
<t tx="ekr.20070626112754.640">def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(fileName=path,initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
</t>
<t tx="ekr.20070626112754.641">def updateSettings (self,c,localFlag):

    d = self.readSettings(c)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
</t>
<t tx="ekr.20070626112754.642"></t>
<t tx="ekr.20070626112754.643">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4204734
By: fgeatfhv

This is something I encountered in 4.3.1 already, but seems to have gotten worse
since then:

A double click on a @url node results in two single clicks on that node. Result:
Nothing happens.

This occurs if there are many nodes expanded and/or the @url node itself contains
a lot of text.

If I contract all nodes (Alt+-), return to the @url node and double click it
again, the double click works and the app starts.


Franz

@color</t>
<t tx="ekr.20070626112754.644">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4197778
By: rogererens

After enabling the slideshow plugin I can advance to the next slide using the
next-slide-command, but the pressing the button that results from @button NxtSlide
in leoslideshows.leo gives an error:
simulateCommand: no command for next-slide

Leo Log Window...
Leo 4.4.3 alpha 1, build  1.125 , January 26, 2006
Python 2.5.0, Tk 8.4.12, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

leoID = rogererens (in C:\Documents and Settings\Roger)
global config dir: E:\_cvs_\Leo\config
home dir: C:\Documents and Settings\Roger
reading settings in E:\_cvs_\Leo\config\leoSettings.leo
reading: C:\Documents and Settings\Roger\Desktop\leoslideshows.leo
simulateCommand: no command for next-slide

@color
</t>
<t tx="ekr.20070626112754.645">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''

    k = self ; c = k.c
    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('Redefining %s' % (commandName), color='red')

    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        # g.trace('stroke',stroke,'pane',pane,commandName,g.callers())
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok:
            g.es_print('@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif verbose:
        g.es_print('@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in d.values():
            for key in d.keys():
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
</t>
<t tx="ekr.20070626112754.646">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4188344
By: ktenney

current cvs W2K

Here's a @nosent node,
legend: &lt;&gt; title
        | between headline and body
        \ indicates a child node

&lt;@nosent nosent.py&gt;
|
@others

t = 'test
 \
  &lt;class test&gt;
  |
  class test:
      @others
  \
   &lt;body&gt;
   |
   pass

this produces the file:

class test:
    pass    
t = 'test'

without the &lt;BLANKLINE&gt; between 
@others and t = 'test' in the top node:

class test:
    pass    t = 'test'
</t>
<t tx="ekr.20070626112754.647"></t>
<t tx="ekr.20070626112754.648">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4162357

@color</t>
<t tx="ekr.20070626112754.649">def findSectionName(self,s,i):

    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("&lt;&lt;",i)
        n2 = s.find("&gt;&gt;",i)
    else:
        n1 = s.find("&lt;&lt;",i,end)
        n2 = s.find("&gt;&gt;",i,end)

    ok = -1 &lt; n1 &lt; n2

    # New in Leo 4.4.3: warn on extra brackets.
    if ok:
        for ch,j in (('&lt;',n1+2),('&gt;',n2+2)):
            if g.match(s,j,ch):
                line = g.get_line(s,i)
                g.es('dubious brackets in %s' % line)
                break

    return ok, n1, n2
</t>
<t tx="ekr.20070626112754.650"></t>
<t tx="ekr.20070626112754.651"></t>
<t tx="ekr.20070626112754.652">def writeWaitingLog (self):

    # g.trace(g.app.gui,self.log)

    if self.log:
        if 1: # not self.log.isNull: # The test for isNull would probably interfere with batch mode.
            for s,color in self.logWaiting:
                g.es(s,color=color,newline=0) # The caller must write the newlines.
            self.logWaiting = []
    else:
        print 'writeWaitingLog: still no log!'
</t>
<t tx="ekr.20070626112754.653">def put (self,s,color=None,tabName='Log'):
    if self.enabled:
        ### g.rawPrint(s)
        try:
            print s,
        except UnicodeError:
            s = s.encode('ascii','replace')
            print s,

def putnl (self,tabName='Log'):
    if self.enabled:
        # g.rawPrint("")
        print
</t>
<t tx="ekr.20070626112754.654"></t>
<t tx="ekr.20070626112754.655">def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    __pychecker__ = '--no-argsused' # keywords not used.

    if not isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    adjustSysPath(g)
    if pymacs:
        script = windowFlag = False
    else:
        script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
</t>
<t tx="ekr.20070626112754.656"># Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"

# NOW we can set g.
g = leoGlobals
assert(g.app)
</t>
<t tx="ekr.20070626112754.657">try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()

try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20070626112754.658">def adjustSysPath (g):

    '''Adjust sys.path to enable imports as usual with Leo.'''

    import sys

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','src','test')

    for theDir in leoDirs:
        path = g.os_path_abspath(
            g.os_path_join(g.app.loadDir,'..',theDir))
        if path not in sys.path:
            sys.path.append(path)
</t>
<t tx="ekr.20070626112754.659">def completeFileName (fileName):

    import leoGlobals as g

    if not fileName:
        return None

    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
</t>
<t tx="ekr.20070626112754.660">def createFrame (fileName):

    """Create a LeoFrame during Leo's startup process."""

    import leoGlobals as g

    # g.trace('fileName',fileName)

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName,initEditCommanders=True)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if frame.c.chapterController:
        frame.c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame</t>
<t tx="ekr.20070626112754.661">def createNullGuiWithScript (script):

    import leoGlobals as g
    import leoGui

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    # if not g.app.root:
        # g.app.root = g.app.gui.createRootWindow()
    # g.app.gui.finishCreate()
    g.app.gui.setScript(script)
</t>
<t tx="ekr.20070626112754.662">def getBatchScript ():

    import leoGlobals as g
    windowFlag = False

    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()

    # Bug fix 4/27/07: Don't put a return in a finally clause.
    return script, windowFlag
</t>
<t tx="ekr.20070626112754.663">def isValidPython():

    if sys.platform == 'cli':
        return True

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0</t>
<t tx="ekr.20070626112754.664">def reportDirectories(verbose):

    import leoGlobals as g

    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
</t>
<t tx="ekr.20070626112754.665">def startPsyco ():

    import leoGlobals as g

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        g.app.use_psyco = False
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
        g.app.use_psyco = False
</t>
<t tx="ekr.20070626112754.666">def initLeo (self):

    '''Init the Leo app to which this class gives access.
    This code is based on leo.run().'''

    if not self.isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    if not self.getLeoID(): return
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    g.app.config.readSettingsFiles(None,verbose=True)
    self.createGui() # Create the gui *before* loading plugins.
    if self.verbose: self.reportDirectories()
    self.adjustSysPath()
    g.doHook("start1") # Load plugins.
    g.init_sherlock(args=[])
    g.app.initing = False
    g.doHook("start2",c=None,p=None,v=None,fileName=None)
</t>
<t tx="ekr.20070626112754.667"># Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"

# NOW we can set g.
self.g = g = leoGlobals
assert(g.app)
g.app.leoID = None
</t>
<t tx="ekr.20070626112754.668">try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()

try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20070626112754.669">def adjustSysPath (self):

    '''Adjust sys.path to enable imports as usual with Leo.'''

    import sys

    g = self.g

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','src','test')

    for theDir in leoDirs:
        path = g.os_path_abspath(
            g.os_path_join(g.app.loadDir,'..',theDir))
        if path not in sys.path:
            sys.path.append(path)
</t>
<t tx="ekr.20070626112754.670">def createGui (self):

    g = self.g

    if self.guiName == 'nullGui':
        import leoGui
        import leoFrame
        g.app.gui = leoGui.nullGui("nullGui")
        # print 'createGui:','g.app:',id(g.app),g.app
        # print 'createGui:','g.app.gui',g.app.gui
        g.app.log = g.app.gui.log = log = leoFrame.nullLog()
        log.isNull = False
        log.enabled = True # Allow prints from nullLog.
        # g.app.writeWaitingLog()
    else:
        assert False,'leoBridge.py must run with nullGui'

    if 0: # A gui main loop is probably a bad idea.
        if self.guiName == 'tkinter':
            import leoTkinterGui
            g.app.gui = leoTkinterGui.tkinterGui()
            g.app.root = g.app.gui.createRootWindow()
            g.app.gui.finishCreate()


</t>
<t tx="ekr.20070626112754.671">def isValidPython(self):

    import sys

    if sys.platform == 'cli':
        return True

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0</t>
<t tx="ekr.20070626112754.672">def getLeoID (self):

    import os
    import sys

    g = self.g ; tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = False and not g.app.unitTesting
    &lt;&lt; try to get leoID from sys.leoID &gt;&gt;
    if not g.app.leoID:
        &lt;&lt; try to get leoID from "leoID.txt" &gt;&gt;
    if not g.app.leoID:
        &lt;&lt; try to get leoID from os.getenv('USER') &gt;&gt;
    return g.app.leoID
</t>
<t tx="ekr.20070626112754.673"># This would be set by in Python's sitecustomize.py file.

# Use hasattr &amp; getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es("leoID = " + g.app.leoID, color='red')</t>
<t tx="ekr.20070626112754.674">for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) &gt; 0:
                g.app.leoID = s.strip()
                if verbose:
                    g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                break
            elif verbose:
                g.es("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()
</t>
<t tx="ekr.20070626112754.675">try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'): %s " % (repr(theId)),color='red')
        g.app.leoID = theId

except Exception:
    pass
</t>
<t tx="ekr.20070626112754.676">def reportDirectories (self):

    g = self.g

    for kind,theDir in (
        ("global config",g.app.globalConfigDir),
        ("home",g.app.homeDir),
    ):
        g.es('%s dir: %s' % (kind,theDir),color="blue")
</t>
<t tx="ekr.20070626112754.677">def event_generate(self,stroke):

    w = self ; c = self.c ; char = stroke

    # Canonicalize the setting.
    stroke = c.k.shortcutFromSetting(stroke)

    # g.trace('baseTextWidget','char',char,'stroke',stroke)

    class eventGenerateEvent:
        def __init__ (self,c,w,char,keysym):
            self.c = c
            self.char = char
            self.keysym = keysym
            self.leoWidget = w
            self.widget = w

    event = eventGenerateEvent(c,w,char,stroke)
    c.k.masterKeyHandler(event,stroke=stroke)
</t>
<t tx="ekr.20070626112754.678"></t>
<t tx="ekr.20070626112754.679"># Subclassing from wx.EvtHandler allows methods of this and derived class to be event handlers.

class baseTextWidget:

    '''The base class for all wrapper classes for leo Text widgets.'''

    @others
</t>
<t tx="ekr.20070626112754.680">def __init__ (self,c,baseClassName,name,widget):

    self.baseClassName = baseClassName
    self.c = c
    self.name = name
    self.virtualInsertPoint = None
    self.widget = widget # Not used at present.

def __repr__(self):
    return '%s: %s' % (self.baseClassName,id(self))

</t>
<t tx="ekr.20070626112754.681"># Don't even think of using key up/down events.
# They don't work reliably and don't support auto-repeat.

def onChar (self, event):

    c = self.c
    keycode = event.GetKeyCode()
    event.leoWidget = self
    keysym = g.app.gui.eventKeysym(event)
    #g.trace('text: keycode %3s keysym %s' % (keycode,keysym))
    if keysym:
        c.k.masterKeyHandler(event,stroke=keysym)</t>
<t tx="ekr.20070626112754.682">def update (self,*args,**keys):             pass
def update_idletasks (self,*args,**keys):   pass
</t>
<t tx="ekr.20070626112754.683"># def _appendText(self,s):            self.oops()
# def _get(self,i,j):                 self.oops()
# def _getAllText(self):              self.oops()
# def _getFocus(self):                self.oops()
# def _getInsertPoint(self):          self.oops()
# def _getLastPosition(self):         self.oops()
# def _getSelectedText(self):         self.oops()
# def _getSelectionRange(self):       self.oops()
# def _hitTest(self,pos):             self.oops()
# def _insertText(self,i,s):          self.oops()
# def _scrollLines(self,n):           self.oops()
# def _see(self,i):                   self.oops()
# def _setAllText(self,s):            self.oops()
# def _setBackgroundColor(self,color): self.oops()
# def _setFocus(self):                self.oops()
# def _setInsertPoint(self,i):        self.oops()
# def _setSelectionRange(self,i,j):   self.oops()

# _findFocus = _getFocus
</t>
<t tx="ekr.20070626112754.684">def oops (self):

    print('wxGui baseTextWidget oops:',self,g.callers(),
        'must be overridden in subclass')
</t>
<t tx="ekr.20070626112754.685"></t>
<t tx="ekr.20070626112754.686">def toPythonIndex (self,index):

    w = self

    if type(index) == type(99):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return w._getLastPosition()
    else:
        # g.trace(repr(index))
        s = w._getAllText()
        row,col = index.split('.')
        row,col = int(row),int(col)
        i = g.convertRowColToPythonIndex(s,row-1,col)
        # g.trace(index,row,col,i,g.callers(6))
        return i

toGuiIndex = toPythonIndex</t>
<t tx="ekr.20070626112754.687"># This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):

    return g.convertRowColToPythonIndex(s,row,col)    
</t>
<t tx="ekr.20070626112754.688"># These methods are widget-independent because they call the corresponding _xxx methods.</t>
<t tx="ekr.20070626112754.689">def appendText (self,s):

    w = self
    w._appendText(s)
</t>
<t tx="ekr.20070626112754.690">def bind (self,kind,*args,**keys):

    w = self

    pass # g.trace('wxLeoText',kind,args[0].__name__)</t>
<t tx="ekr.20070626112754.691">def clipboard_clear (self):

    g.app.gui.replaceClipboardWith('')

def clipboard_append(self,s):

    s1 = g.app.gui.getTextFromClipboard()

    g.app.gui.replaceClipboardWith(s1 + s)
</t>
<t tx="ekr.20070626112754.692">def delete(self,i,j=None):

    w = self
    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    # g.trace(i,j,len(s),repr(s[:20]))
    s = w.getAllText()
    w.setAllText(s[:i] + s[j:])
</t>
<t tx="ekr.20070626112754.693">def deleteTextSelection (self):

    w = self
    i,j = w._getSelectionRange()
    if i == j: return

    s = w._getAllText()
    s = s[i:] + s[j:]

    # g.trace(len(s),repr(s[:20]))
    w._setAllText(s)
</t>
<t tx="ekr.20070626112754.694">def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75): # tkTextWidget.

    w = self

    return ###

    def addFlashCallback(w,count,index):
        # g.trace(count,index)
        i,j = w.toPythonIndex(index),w.toPythonIndex(index+1)
        Tk.Text.tag_add(w,'flash',i,j)
        Tk.Text.after(w,delay,removeFlashCallback,w,count-1,index)

    def removeFlashCallback(w,count,index):
        # g.trace(count,index)
        Tk.Text.tag_remove(w,'flash','1.0','end')
        if count &gt; 0:
            Tk.Text.after(w,delay,addFlashCallback,w,count,index)

    try:
        Tk.Text.tag_configure(w,'flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass ; g.es_exception()</t>
<t tx="ekr.20070626112754.695">def getFocus (self):

    w = self
    w2 = w._getFocus()
    # g.trace('w',w,'focus',w2)
    return w2

findFocus = getFocus
</t>
<t tx="ekr.20070626112754.696">def get(self,i,j=None):

    w = self

    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    s = w._get(i,j)
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.697">def getAllText (self):

    w = self

    s = w._getAllText()
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.698">def getInsertPoint(self):

    w = self
    i = w._getInsertPoint()

    # g.trace(self,'baseWidget: i:',i,'virtual',w.virtualInsertPoint)

    if i is None:
        if w.virtualInsertPoint is None:
            i = 0
        else:
            i = w.virtualInsertPoint

    w.virtualInsertPoint = i

    return i
</t>
<t tx="ekr.20070626112754.699">def GetName(self):
    return self.name

getName = GetName</t>
<t tx="ekr.20070626112754.700">def getSelectedText (self):

    w = self
    s = w._getSelectedText()
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.701">def getSelectionRange (self,sort=True):

    """Return a tuple representing the selected range of the widget.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self

    sel = w._getSelectionRange() # wx.richtext.RichTextCtrl returns (-1,-1) on no selection.
    if len(sel) == 2 and sel[0] &gt;= 0 and sel[1] &gt;= 0:
        #g.trace(self,'baseWidget: sel',repr(sel),g.callers(6))
        i,j = sel
        if sort and i &gt; j: i,j = j,i
        return sel
    else:
        # Return the insertion point if there is no selected text.
        i =  w._getInsertPoint()
        #g.trace(self,'baseWidget: i',i,g.callers(6))
        return i,i
</t>
<t tx="ekr.20070626112754.702">def getYScrollPosition (self):

     w = self
     return w._getYScrollPosition()
</t>
<t tx="ekr.20070626112754.703">def getWidth (self):

    '''Return the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    return 0
</t>
<t tx="ekr.20070626112754.704">def hasSelection (self):

    w = self
    i,j = w.getSelectionRange()
    return i != j
</t>
<t tx="ekr.20070626112754.705"># The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toPythonIndex(i)
    # w._setInsertPoint(i)
    w._insertText(i,s)
</t>
<t tx="ekr.20070626112754.706">def indexIsVisible (self,i):

    return False # Code will loop if this returns True forever.</t>
<t tx="ekr.20070626112754.707">def replace (self,i,j,s):

    w = self
    w.delete(i,j)
    w.insert(i,s)
</t>
<t tx="ekr.20070626112754.708">def scrollLines (self,n):

    w = self
    w._scrollLines(n)</t>
<t tx="ekr.20070626112754.709">def see(self,index):

    w = self
    i = self.toPythonIndex(index)
    w._see(i)

def seeInsertPoint(self):

    w = self
    i = w._getInsertPoint()
    w._see(i)
</t>
<t tx="ekr.20070626112754.710">def selectAllText (self,insert=None):

    '''Select all text of the widget.'''

    w = self
    w.setSelectionRange(0,'end',insert=insert)
</t>
<t tx="ekr.20070626112754.711">def setAllText (self,s):

    w = self
    w._setAllText(s)</t>
<t tx="ekr.20070626112754.712">def setBackgroundColor (self,color):

    w = self

    # Translate tk colors to wx colors.
    d = { 'lightgrey': 'light grey', 'lightblue': 'leo blue',}

    color = d.get(color,color)

    return w._setBackgroundColor(color)

SetBackgroundColour = setBackgroundColor</t>
<t tx="ekr.20070626112754.713">def setFocus (self):

    w = self
    # g.trace('baseText')
    return w._setFocus()

SetFocus = setFocus
</t>
<t tx="ekr.20070626112754.714">def setInsertPoint (self,pos):

    w = self
    w.virtualInsertPoint = i = w.toPythonIndex(pos)
    # g.trace(self,i)
    w._setInsertPoint(i)
</t>
<t tx="ekr.20070626112754.715">def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    # g.trace(self,'baseWidget',repr(i1),'=',repr(i),repr(j1),'=',repr(j),repr(insert1),'=',repr(insert),g.callers(4))

    if i == j:
        w._setInsertPoint(j)
    else:
        w._setSelectionRange(i,j)

    if insert is not None and insert in (i,j):
        ins = w.toPythonIndex(insert)
        if ins in (i,j):
            self.virtualInsertPoint = ins
</t>
<t tx="ekr.20070626112754.716">def setWidth (self,width):

    '''Set the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    pass
</t>
<t tx="ekr.20070626112754.717">def setYScrollPosition (self,i):

     w = self
     w._setYScrollPosition(i)</t>
<t tx="ekr.20070626112754.718"></t>
<t tx="ekr.20070626112754.719">def mark_set(self,markName,i):

    w = self
    i = self.toPythonIndex(i)

    ### Tk.Text.mark_set(w,markName,i)
</t>
<t tx="ekr.20070626112754.720"># The signature is slightly different than the Tk.Text.insert method.

def tag_add(self,tagName,i,j=None,*args):

    w = self
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)

    return ###

    if not hasattr(w,'leo_styles'):
        w.leo_styles = {}

    style = w.leo_styles.get(tagName)

    if style is not None:
        # g.trace(i,j,tagName)
        w.textBaseClass.SetStyle(w,i,j,style)</t>
<t tx="ekr.20070626112754.721">def tag_configure (self,colorName,**keys):
    pass

tag_config = tag_configure</t>
<t tx="ekr.20070626112754.722">def tkColorToWxColor (self, color):

    d = {
        'black':        wx.BLACK,
        "red":          wx.RED,
        "blue":         wx.BLUE,
        "#00aa00":      wx.GREEN,
        "firebrick3":   wx.RED,
        'white':        wx.WHITE,
    }

    return d.get(color)</t>
<t tx="ekr.20070626112754.723">def tag_delete (self,tagName,*args,**keys):

    pass # g.trace(tagName,args,keys)</t>
<t tx="ekr.20070626112754.724">def tag_names (self, *args):

    return []
</t>
<t tx="ekr.20070626112754.725">def tag_ranges(self,tagName):

    return tuple() ###

    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
</t>
<t tx="ekr.20070626112754.726">def tag_remove(self,tagName,i,j=None,*args):

    w = self
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)

    return ### Not ready yet.

    if not hasattr(w,'leo_styles'):
        w.leo_styles = {}

    style = w.leo_styles.get(tagName)

    if style is not None:
        # g.trace(i,j,tagName)
        w.textBaseClass.SetStyle(w,i,j,style)</t>
<t tx="ekr.20070626112754.727">def yview (self,*args):

    '''w.yview('moveto',y) or w.yview()'''

    return 0,0</t>
<t tx="ekr.20070626112754.728">def xyToPythonIndex (self,x,y):
    return 0
</t>
<t tx="ekr.20070626112754.729">class leoBody:

    """The base class for the body pane in Leo windows."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.730">def __init__ (self,frame,parentFrame):

    self.frame = frame
    self.c = c = frame.c
    self.editorWidgets = {} # keys are pane names, values are text widgets
    self.forceFullRecolorFlag = False
    frame.body = self

    # May be overridden in subclasses...
    self.bodyCtrl = self.widget = None ### self
    self.numberOfEditors = 1
    self.pb = None # paned body widget.

    self.use_chapters = c.config.getBool('use_chapters')

    # Must be overridden in subclasses...
    self.colorizer = None
</t>
<t tx="ekr.20070626112754.731">mustBeDefinedInSubclasses = (
    # Birth, death &amp; config.
    '__init__',
    'createBindings',
    'createControl',
    'setColorFromConfig',
    'setFontFromConfig'
    # Editors
    'createEditorLabel',
    'setEditorColors',
    # Events...
    'scheduleIdleTimeRoutine',
    # Low-level gui...(May be deleted)
    'getBodyPaneHeight',
    'getBodyPaneWidth',
    'hasFocus',
    'setFocus',
    # 'tag_add',
    # 'tag_bind',
    # 'tag_configure',
    # 'tag_delete',
    # 'tag_remove',
)
</t>
<t tx="ekr.20070626112754.732">mustBeDefinedOnlyInBaseClass = (
    'getAllText',
    'getColorizer',
    'getInsertLines',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionAreas',
    'getSelectionLines',
    'getYScrollPosition',
    'hasTextSelection',
    'oops',
    'onBodyChanged',
    'onClick',
    'recolor',
    'recolor_now',
    'recolor_range',
    'see',
    'seeInsertPoint',
    'selectAllText',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
    'setSelectionAreas',
    'setYScrollPosition',
    'updateSyntaxColorer',
    # Editors... (These may be overridden)
    # 'addEditor',
    # 'cycleEditorFocus',
    # 'deleteEditor',
    # 'selectEditor',
    # 'selectLabel',
    # 'unselectLabel',
    # 'updateEditors',
)
</t>
<t tx="ekr.20070626112754.733"># Birth, death &amp; config
def createBindings (self,w=None):               self.oops()
def createControl (self,frame,parentFrame,p):   self.oops()
def setColorFromConfig (self,w=None):           self.oops()
def setFontFromConfig (self,w=None):            self.oops()
# Editor
def createEditorLabel (self,pane):              self.oops()
def setEditorColors (self,bg,fg):               self.oops()
# Events...
def scheduleIdleTimeRoutine (self,function,*args,**keys): self.oops()
</t>
<t tx="ekr.20070626112754.734"></t>
<t tx="ekr.20070626112754.735">def getColorizer(self):

    return self.colorizer

def recolor_now(self,p,incremental=False):

    self.colorizer.colorize(p.copy(),incremental)

def recolor_range(self,p,leading,trailing):

    self.colorizer.recolor_range(p.copy(),leading,trailing)

def recolor(self,p,incremental=False):

    if 0: # Do immediately
        self.colorizer.colorize(p.copy(),incremental)
    else: # Do at idle time
        self.colorizer.schedule(p.copy(),incremental)

def updateSyntaxColorer(self,p):

    return self.colorizer.updateSyntaxColorer(p.copy())
</t>
<t tx="ekr.20070626112754.736">@ Notes:
- body.bodyCtrl and body.frame.bodyCtrl must always be the same.

- This code uses self.pb, a paned body widget, created by tkBody.finishCreate.


</t>
<t tx="ekr.20070626112754.737"></t>
<t tx="ekr.20070626112754.738">def addEditor (self,event=None):

    '''Add another editor to the body pane.'''

    c = self.c ; p = c.currentPosition()

    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1

    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        w_old = self.editorWidgets.get('1')
        self.updateInjectedIvars(w_old,p)
        self.selectLabel(w_old) # Immediately create the label in the old editor.

    name = '%d' % self.totalNumberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))

    f = self.createEditorFrame(pane)
    &lt;&lt; create text widget w &gt;&gt;
    self.editorWidgets[name] = w

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)

    self.pb.updatelayout()
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.updateInjectedIvars(w,p)
    self.selectLabel(w)
    self.selectEditor(w)
    self.updateEditors()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.739">w = self.createTextWidget(self.frame,f,name=name,p=p)
w.delete(0,'end')
w.insert('end',p.bodyString())
w.see(0)

self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(w)
</t>
<t tx="ekr.20070626112754.740">def cycleEditorFocus (self,event=None):

    '''Cycle keyboard focus between the body text editors.'''

    c = self.c ; d = self.editorWidgets ; w = self.bodyCtrl
    values = d.values()
    if len(values) &gt; 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.selectEditor(w2)
        self.bodyCtrl = self.frame.bodyCtrl = w2
        # print '***',g.app.gui.widget_name(w2),id(w2)

    return 'break'
</t>
<t tx="ekr.20070626112754.741">def deleteEditor (self,event=None):

    '''Delete the presently selected body text editor.'''

    w = self.bodyCtrl ; d = self.editorWidgets

    if len(d.keys()) == 1: return

    name = w.leo_name

    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)

    # Select another editor.
    w = d.values()[0]
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.numberOfEditors -= 1
    self.selectEditor(w)
</t>
<t tx="ekr.20070626112754.742">def findEditorForChapter (self,chapter,p):

    '''Return an editor to be assigned to chapter.'''

    d = self.editorWidgets ; values = d.values()

    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w,'leo_p') and w.leo_p and w.leo_p.equal(p)):
                # g.trace('***',id(w),'match chapter and p',p.headString())
                return w

    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
            # g.trace('***',id(w),'match only chapter',p.headString())
            return w

    # As a last resort, return the present editor widget.
    # g.trace('***',id(self.bodyCtrl),'no match',p.headString())
    return self.bodyCtrl
</t>
<t tx="ekr.20070626112754.743">def unselectLabel (self,w):

    self.createChapterIvar(w)
    self.packEditorLabelWidget(w)
    s = self.computeLabel(w)
    w.leo_label.configure(text=s,bg='LightSteelBlue1')

def selectLabel (self,w):

    if self.numberOfEditors &gt; 1:
        self.createChapterIvar(w)
        self.packEditorLabelWidget(w)
        s = self.computeLabel(w)
        # g.trace(s,g.callers())
        w.leo_label.configure(text=s,bg='white')
    elif w.leo_label:
        w.leo_label.pack_forget()
        w.leo_label = None</t>
<t tx="ekr.20070626112754.744">def assignPositionToEditor (self,p):

    '''Called *only* from tree.select to select the present body editor.'''

    c = self.c ; cc = c.chapterController ; w = self.bodyCtrl

    self.updateInjectedIvars(w,p)
    self.selectLabel(w)

    # g.trace('===',id(w),w.leo_chapter.name,w.leo_p.headString())
</t>
<t tx="ekr.20070626112754.745"># Called from addEditor and assignPositionToEditor

def updateEditors (self):

    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) &lt; 2: return # There is only the main widget.

    for key in d.keys():
        w = d.get(key)
        v = w.leo_v
        if v and v == p.v and w != self.bodyCtrl:
            w.delete(0,'end')
            w.insert('end',p.bodyString())
            # g.trace('update',w,v)
            self.recolorWidget(w)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.746"></t>
<t tx="ekr.20070626112754.747">def computeLabel (self,w):

    s = w.leo_label_s

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter.name,s)

    return s
</t>
<t tx="ekr.20070626112754.748">def createChapterIvar (self,w):

    c = self.c ; cc = c.chapterController

    if not hasattr(w,'leo_chapter') or not w.leo_chapter:
        if cc and self.use_chapters: ### c.config.getBool('use_chapters'):
            w.leo_chapter = cc.getSelectedChapter()
        else:
            w.leo_chapter = None
</t>
<t tx="ekr.20070626112754.749">def ensurePositionExists(self,w):

    '''Return True if w.leo_p exists or can be reconstituted.'''

    c = self.c

    if c.positionExists(w.leo_p):
        return True
    else:
        g.trace('***** does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v and p2.v == w.leo_v:
                w.leo_p = p2.copy()
                return True
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            return False
</t>
<t tx="ekr.20070626112754.750">def inactivateActiveEditor(self,w):

    '''Inactivate all the previously active editor.'''

    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d.keys():
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            # g.trace('inactivate',id(w2))
            break
    else:
        if trace: g.trace('no active editor!')</t>
<t tx="ekr.20070626112754.751">def recolorWidget (self,w):

    c = self.c ; old_w = self.bodyCtrl

    # g.trace(id(w),c.currentPosition().headString())

    # Save.
    self.bodyCtrl = self.frame.bodyCtrl = w

    c.recolor_now(interruptable=False) # Force a complete recoloring.

    # Restore.
    self.bodyCtrl = self.frame.bodyCtrl = old_w</t>
<t tx="ekr.20070626112754.752">def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            # g.trace('===','old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.753"># Called from addEditor and assignPositionToEditor.

def updateInjectedIvars (self,w,p):

    c = self.c ; cc = c.chapterController ; 

    if cc and self.use_chapters: ### c.config.getBool('use_chapters'):
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None

    w.leo_p = p.copy()
    w.leo_v = w.leo_p.v
    w.leo_label_s = p.headString()

    # g.trace('   ===', id(w),w.leo_chapter and w.leo_chapter.name,p.headString())
</t>
<t tx="ekr.20070626112754.754"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):

    '''Update Leo after the body has been changed.'''

    body = self ; c = self.c
    bodyCtrl = w = body.bodyCtrl
    p = c.currentPosition()
    insert = w.getInsertPoint()
    ch = g.choose(insert==0,'',w.get(insert-1))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = w.getAllText() # Note: getAllText converts to unicode.
    # g.trace('newText',repr(newText),g.callers())
    newSel = w.getSelectionRange()
    if not oldText:
        oldText = p.bodyString() ; changed = True
    else:
        changed = oldText != newText
    # g.trace(repr(ch),'changed:',changed,'newText:',repr(newText))
    if not changed: return
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed: c.setChanged(True)
    self.updateEditors()
    &lt;&lt; redraw the screen if necessary &gt;&gt;
</t>
<t tx="ekr.20070626112754.755">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False

if g.app.unitTesting:
    g.app.unitTestDict['colorized'] = True
</t>
<t tx="ekr.20070626112754.756">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True

    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    # g.trace('new val:',val,'old val:',hasattr(p.v,'iconVal') and p.v.iconVal or '&lt;None&gt;')
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
</t>
<t tx="ekr.20070626112754.757">def onClick (self,event):

    c = self.c ; k = c.k ; w = event and event.widget
    wname = c.widget_name(w)

    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        k.previousSelection = w.getSelectionRange()
        x,y = g.app.gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        # g.trace(x,y,repr(i))
        w.setSelectionRange(i,i,insert=i)
        c.editCommands.setMoveCol(w,i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')
</t>
<t tx="ekr.20070626112754.758">def oops (self):

    g.trace("leoBody oops:", g.callers(), "should be overridden in subclass")
</t>
<t tx="ekr.20070626112754.759"></t>
<t tx="ekr.20070626112754.760">def getSelectionAreas (self):

    """Return before,sel,after where:

    before is the text before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is the text after the selected text
    (or the text after the insert point if no selection)"""

    w = self.bodyCtrl
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if i == j: j = i + 1

    before = s[0:i]
    sel    = s[i:j]
    after  = s[j:]

    before = g.toUnicode(before,g.app.tkEncoding)
    sel    = g.toUnicode(sel,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)
    return before,sel,after</t>
<t tx="ekr.20070626112754.761">def getYScrollPosition (self):
    return self.bodyCtrl.getYScrollPosition()

def setYScrollPosition (self,scrollPosition):
    if len(scrollPosition) == 2:
        first,last = scrollPosition
    else:
        first = scrollPosition
    self.bodyCtrl.setYScrollPosition(first)
</t>
<t tx="ekr.20070626112754.762">def getAllText (self):                  return self.bodyCtrl.getAllText()
def getInsertPoint(self):               return self.bodyCtrl.getInsertPoint()
def getSelectedText (self):             return self.bodyCtrl.getSelectedText()
def getSelectionRange (self,sort=True): return self.bodyCtrl.getSelectionRange(sort)
def hasTextSelection (self):            return self.bodyCtrl.hasSelection()
# def scrollDown (self):                g.app.gui.yscroll(self.bodyCtrl,1,'units')
# def scrollUp (self):                  g.app.gui.yscroll(self.bodyCtrl,-1,'units')
def see (self,index):                   self.bodyCtrl.see(index)
def seeInsertPoint (self):              self.bodyCtrl.seeInsertPoint()
def selectAllText (self,event=None): # This is a command.
    w = g.app.gui.eventWidget(event) or self.bodyCtrl
    return w.selectAllText()
def setInsertPoint (self,pos):          return self.bodyCtrl.setInsertPoint(pos) # was getInsertPoint.
def setSelectionRange (self,sel):       i,j = sel ; self.bodyCtrl.setSelectionRange(i,j)
</t>
<t tx="ekr.20070626112754.763">class leoGui:

    """The base class of all gui classes.

    Subclasses are expected to override all do-nothing methods of this class."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    &lt;&lt; define leoGui file types &gt;&gt;

    @others
</t>
<t tx="ekr.20070626112754.764">allFullFiletypes = [
    ("All files",   "*"),
    ("C/C++ files", "*.c"),
    ("C/C++ files", "*.cpp"),
    ("C/C++ files", "*.h"),
    ("C/C++ files", "*.hpp"),
    ("Java files",  "*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas"),
    ("Python files","*.py")]
    # To do: *.php, *.php3, *.php4")
pythonFullFiletypes = [
    ("Python files","*.py"),
    ("All files","*"),
    ("C/C++ files","*.c"),
    ("C/C++ files","*.cpp"),
    ("C/C++ files","*.h"),
    ("C/C++ files","*.hpp"),
    ("Java files","*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas")]
    # To do: *.php, *.php3, *.php4")
textFullFiletypes = [
    ("Text files","*.txt"),
    ("C/C++ files","*.c"),
    ("C/C++ files","*.cpp"),
    ("C/C++ files","*.h"),
    ("C/C++ files","*.hpp"),
    ("Java files","*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas"),
    ("Python files","*.py"),
    ("All files","*")]
    # To do: *.php, *.php3, *.php4")
CWEBTextAllFiletypes = [
    ("CWEB files","*.w"),
    ("Text files","*.txt"),
    ("All files", "*")]
leoAllFiletypes = [
    ("Leo files","*.leo"),
    ("All files","*")]
leoFiletypes = [
    ("Leo files","*.leo")]
nowebTextAllFiletypes = [
    ("Noweb files","*.nw"),
    ("Text files", "*.txt"),
    ("All files",  "*")]
textAllFiletypes = [
    ("Text files","*.txt"),
    ("All files", "*")]
</t>
<t tx="ekr.20070626112754.765"></t>
<t tx="ekr.20070626112754.766">def __init__ (self,guiName):

    # g.trace("leoGui",guiName,g.callers())

    self.lastFrame = None
    self.leoIcon = None
    self.mGuiName = guiName
    self.mainLoop = None
    self.root = None
    self.script = None
    self.utils = None
    self.isNullGui = False
    self.bodyTextWidget = None
    self.plainTextWidget = None
    self.trace = False

</t>
<t tx="ekr.20070626112754.767">mustBeDefinedOnlyInBaseClass = (
    'guiName',
    'oops',
    'setScript',
    'widget_name',
)</t>
<t tx="ekr.20070626112754.768">mustBeDefinedInSubclasses = (
    # Startup &amp; shutdown
    'attachLeoIcon',
    'center_dialog',
    'color',
    #'createComparePanel',          # optional
    #'createFindPanel',             # optional
    'createFindTab',
    'createKeyHandlerClass',
    'createLeoFrame',
    'createRootWindow',
    'create_labeled_frame',
    'destroySelf',
    'eventChar',
    'eventKeysym',
    'eventWidget',
    'eventXY',
    # 'finishCreate', # optional.
    # 'getFontFromParams', # optional
    # 'getFullVersion', # optional.
    'getTextFromClipboard',
    'get_focus',
    'get_window_info',
    'isTextWidget',
    'keysym',
    'killGui',
    # 'makeScriptButton', # optional
    'recreateRootWindow',
    'replaceClipboardWith',
    'runAboutLeoDialog',
    'runAskLeoIDDialog',
    'runAskOkCancelNumberDialog',
    'runAskOkDialog',
    'runAskYesNoCancelDialog',
    'runAskYesNoDialog',
    'runMainLoop',
    'runOpenFileDialog',
    'runSaveFileDialog',
    'set_focus',
    #'setIdleTimeHook',             # optional       
    #'setIdleTimeHookAfterDelay',   # optional
)
</t>
<t tx="ekr.20070626112754.769"></t>
<t tx="ekr.20070626112754.770">def guiName(self):

    try:
        return self.mGuiName
    except:
        return "invalid gui name"
</t>
<t tx="ekr.20070626112754.771">def setScript (self,script=None,scriptFileName=None):

    self.script = script
    self.scriptFileName = scriptFileName
</t>
<t tx="ekr.20070626112754.772"></t>
<t tx="ekr.20070626112754.773"></t>
<t tx="ekr.20070626112754.774">def createRootWindow(self):

    """Create the hidden root window for the gui.

    Nothing needs to be done if the root window need not exist."""

    self.oops()
</t>
<t tx="ekr.20070626112754.775">def destroySelf (self):

    self.oops()
</t>
<t tx="ekr.20070626112754.776">def killGui(self,exitFlag=True):

    """Destroy the gui.

    The entire Leo application should terminate if exitFlag is True."""

    self.oops()
</t>
<t tx="ekr.20070626112754.777">def recreateRootWindow(self):

    """Create the hidden root window of the gui
    after a previous gui has terminated with killGui(False)."""

    self.oops()
</t>
<t tx="ekr.20070626112754.778">def runMainLoop(self):

    """Run the gui's main loop."""

    self.oops()
</t>
<t tx="ekr.20070626112754.779">def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    self.oops()

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskOkCancelStringDialog(self,c,title,message):
    """Create and run askOkCancelString dialog ."""
    self.oops()

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()
</t>
<t tx="ekr.20070626112754.780">def createKeyHandlerClass (self,c,useGlobalKillbuffer=True,useGlobalRegisters=True):

    self.oops()

    # import leoKeys # Do this here to break a circular dependency.

    # return leoKeys.keyHandlerClass(c,useGlobalKillbuffer,useGlobalRegisters)</t>
<t tx="ekr.20070626112754.781">def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an open file dialog ."""

    self.oops()

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run a save file dialog ."""

    self.oops()
</t>
<t tx="ekr.20070626112754.782">def createComparePanel(self,c):
    """Create Compare panel."""
    self.oops()

def createFindPanel(self,c):
    """Create a hidden Find panel."""
    self.oops()

def createFindTab (self,c,parentFrame):
    """Create a Tkinter find tab in the indicated frame."""
    self.oops()

def createLeoFrame(self,title):
    """Create a new Leo frame."""
    self.oops()
</t>
<t tx="ekr.20070626112754.783">@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for None returns.

The type of commander passed to methods depends on the type of frame or dialog being created.  The commander may be a Commands instance or one of its subcommanders.
</t>
<t tx="ekr.20070626112754.784">def replaceClipboardWith (self,s):

    self.oops()

def getTextFromClipboard (self):

    self.oops()
</t>
<t tx="ekr.20070626112754.785"># g.es calls gui.color to do the translation,
# so most code in Leo's core can simply use Tk color names.

def color (self,color):
    '''Return the gui-specific color corresponding to the Tk color name.'''
    return color # Do not call oops: this method is essential for the config classes.
</t>
<t tx="ekr.20070626112754.786">def attachLeoIcon (self,window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self,dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame (self,parent,caption=None,relief="groove",bd=2,padx=0,pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info (self,window):
    """Return the window information."""
    self.oops()
</t>
<t tx="ekr.20070626112754.787">def event_generate(self,w,kind,*args,**keys):
    '''Generate an event.'''
    return w.event_generate(kind,*args,**keys)

def eventChar (self,event,c=None):
    '''Return the char field of an event.'''
    return event and event.char or ''

def eventKeysym (self,event,c=None):
    '''Return the keysym value of an event.'''
    return event and event.keysym

def eventWidget (self,event,c=None):
    '''Return the widget field of an event.'''   
    return event and event.widget

def eventXY (self,event,c=None):
    if event:
        return event.x,event.y
    else:
        return 0,0</t>
<t tx="ekr.20070626112754.788">def getFullVersion (self,c):

    return 'leoGui: dummy version'
</t>
<t tx="ekr.20070626112754.789">def get_focus(self,frame):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self,commander,widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
</t>
<t tx="ekr.20070626112754.790">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):

    pass
    # self.oops()
</t>
<t tx="ekr.20070626112754.791">def setIdleTimeHook (self,idleTimeHookHandler):

    # print 'leoGui:setIdleTimeHook'
    pass # Not an error.

def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):

    # print 'leoGui:setIdleTimeHookAfterDelay'
    pass # Not an error.
</t>
<t tx="ekr.20070626112754.792">def makeScriptButton (
    self,c,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False, 
):

    self.oops()
</t>
<t tx="ekr.20070626112754.793"></t>
<t tx="ekr.20070626112754.794">def finishCreate (self):

    pass</t>
<t tx="ekr.20070626112754.795">def oops (self):

    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        print "leoGui oops", g.callers(), "should be overridden in subclass"
</t>
<t tx="ekr.20070626112754.796">def widget_name (self,w):

    # First try the widget's getName method.
    if hasattr(w,'getName'):
        return w.getName()
    elif hasattr(w,'_name'):
        return w._name
    else:
        return repr(w)
</t>
<t tx="ekr.20070626112754.797">class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c):

        # g.trace('leoKeyEvent(leoGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        self.widget = self.w

    def __repr__ (self):

        return 'leoGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))</t>
<t tx="ekr.20070626112754.798">class leoLog:

    """The base class for the log pane in Leo windows."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.799">def __init__ (self,frame,parentFrame):

    self.frame = frame
    if frame: # 7/16/05: Allow no commander for Null logs.
        self.c = frame.c
    else:
        self.c = None
    self.enabled = True
    self.newlines = 0
    self.isNull = False

    # Official status variables.  Can be used by client code.
    self.logCtrl = None # Set below. Same as self.textDict.get(self.tabName)
    self.tabName = None # The name of the active tab.
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)

    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    self.textDict = {}  # Keys are page names. Values are logCtrl's (text widgets).


</t>
<t tx="ekr.20070626112754.800">def onActivateLog (self,event=None):

    self.c.setLog()

def disable (self):

    self.enabled = False

def enable (self,enabled=True):

    self.enabled = enabled

</t>
<t tx="ekr.20070626112754.801">def configure (self,*args,**keys):      pass
def configureBorder(self,border):       pass
def createControl (self,parentFrame):   pass
def finishCreate (self):                pass
def setColorFromConfig (self):          pass
def setFontFromConfig (self):           pass
</t>
<t tx="ekr.20070626112754.802">def clearTab (self,tabName,wrap='none'):

    self.selectTab(tabName,wrap=wrap)
    w = self.logCtrl
    w and w.delete(0,'end')
</t>
<t tx="ekr.20070626112754.803">def createTab (self,tabName,createText=True,wrap='none'):

    # g.trace(tabName,wrap)

    c = self.c ; k = c.k

    if createText:
        w = self.createTextWidget(tabFrame)
        self.textDict [tabName] = w
    else:
        self.textDict [tabName] = None
        self.frameDict [tabName] = tabName # tabFrame
</t>
<t tx="ekr.20070626112754.804">def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)

    values = d.values()
    if self.numberOfVisibleTabs() &gt; 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return </t>
<t tx="ekr.20070626112754.805">def deleteTab (self,tabName,force=False):

    if tabName == 'Log':
        pass
    elif tabName in ('Find','Spell') and not force:
        self.selectTab('Log')
    else:
        for d in (self.textDict,self.frameDict):
            if tabName in d.keys():
                del d[tabName]
        self.tabName = None
        self.selectTab('Log')

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.806">def hideTab (self,tabName):

    __pychecker__ = '--no-argsused' # tabName

    self.selectTab('Log')
</t>
<t tx="ekr.20070626112754.807">def getSelectedTab (self):

    return self.tabName
</t>
<t tx="ekr.20070626112754.808">def lowerTab (self,tabName):

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.809">def numberOfVisibleTabs (self):

    return len([val for val in self.frameDict.values() if val != None])
</t>
<t tx="ekr.20070626112754.810">def renameTab (self,oldName,newName):
    pass
</t>
<t tx="ekr.20070626112754.811">def selectTab (self,tabName,createText=True,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c
    tabFrame = self.frameDict.get(tabName)
    if not tabFrame:
        self.createTab(tabName,createText=createText)

    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0:
        # Absolutely do not do this here!
        # It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)

    return tabFrame
</t>
<t tx="ekr.20070626112754.812"># All output to the log stream eventually comes here.

def put (self,s,color=None,tabName='Log'):
    self.oops()

def putnl (self,tabName='Log'):
    self.oops()
</t>
<t tx="ekr.20070626112754.813">def oops (self):

    print "leoLog oops:", g.callers(), "should be overridden in subclass"
</t>
<t tx="ekr.20070626112754.814">class leoTkinterLog (leoFrame.leoLog):

    """A class that represents the log pane of a Tkinter window."""

    @others
</t>
<t tx="ekr.20070626112754.815"></t>
<t tx="ekr.20070626112754.816">def __init__ (self,frame,parentFrame):

    # g.trace("leoTkinterLog")

    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)

    self.c = c = frame.c # Also set in the base constructor, but we need it here.

    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")

    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.

    self.logCtrl = self.createControl(parentFrame)
    self.setFontFromConfig()
    self.setColorFromConfig()



</t>
<t tx="ekr.20070626112754.817">def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        return self.onRightClick(event,menu)

    self.nb.bind('&lt;Button-3&gt;',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # Create and activate the default tabs.

    return self.logCtrl
</t>
<t tx="ekr.20070626112754.818">def createTextWidget (self,parentFrame):

    self.logNumber += 1
    log = g.app.gui.plainTextWidget(
        parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")

    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview

    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log
</t>
<t tx="ekr.20070626112754.819">def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    # g.trace(tabName,g.callers())

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.

    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)

    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            return self.deleteTab(tabName)

        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)

        def renameTabCallback():
            return self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu
</t>
<t tx="ekr.20070626112754.820"></t>
<t tx="ekr.20070626112754.821">def configureBorder(self,border):

    self.logCtrl.configure(bd=border)

def configureFont(self,font):

    self.logCtrl.configure(font=font)
</t>
<t tx="ekr.20070626112754.822">def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font
</t>
<t tx="ekr.20070626112754.823">def restoreAllState (self,d):

    '''Restore the log from a dict created by saveAllState.'''

    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)
</t>
<t tx="ekr.20070626112754.824">def saveAllState (self):

    '''Return a dict containing all data needed to recreate the log in another widget.'''

    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.getAllText()

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)

    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d
</t>
<t tx="ekr.20070626112754.825">def setColorFromConfig (self):

    c = self.c

    bg = c.config.getColor("log_pane_background_color") or 'white'

    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
</t>
<t tx="ekr.20070626112754.826">def SetWidgetFontFromConfig (self,logCtrl=None):

    c = self.c

    if not logCtrl: logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant", "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)

    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass

    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass

setFontFromConfig = SetWidgetFontFromConfig # Renaming supresses a pychecker warning.
</t>
<t tx="ekr.20070626112754.827"></t>
<t tx="ekr.20070626112754.828">def onActivateLog (self,event=None):

    try:
        self.c.setLog()
        self.frame.tree.OnDeactivate()
        self.c.logWantsFocus()
    except:
        g.es_event_exception("activate log")
</t>
<t tx="ekr.20070626112754.829">def hasFocus (self):

    return self.c.get_focus() == self.logCtrl
</t>
<t tx="ekr.20070626112754.830">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()
</t>
<t tx="ekr.20070626112754.831">@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...
</t>
<t tx="ekr.20070626112754.832"># All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):

    c = self.c

    # print 'tkLog.put',self.c.shortFileName(),tabName,g.callers()

    if g.app.quitting or not c or not c.exists:
        return

    if tabName:
        self.selectTab(tabName)

    if self.logCtrl:
        &lt;&lt; put s to log control &gt;&gt;
        self.logCtrl.update_idletasks()
    else:
        &lt;&lt; put s to logWaiting and print s &gt;&gt;
</t>
<t tx="ekr.20070626112754.833">if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see('end')
self.forceLogUpdate(s)
</t>
<t tx="ekr.20070626112754.834">g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
</t>
<t tx="ekr.20070626112754.835">def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)

    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see('end')
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
</t>
<t tx="ekr.20070626112754.836"></t>
<t tx="ekr.20070626112754.837">def clearTab (self,tabName,wrap='none'):

    self.selectTab(tabName,wrap=wrap)
    w = self.logCtrl
    w and w.delete(0,'end')
</t>
<t tx="ekr.20070626112754.838">def createTab (self,tabName,createText=True,wrap='none'):

    # g.trace(tabName,wrap)

    c = self.c ; k = c.k
    tabFrame = self.nb.add(tabName)
    self.menu = self.makeTabMenu(tabName)
    if createText:
        &lt;&lt; Create the tab's text widget &gt;&gt;
        if tabName != 'Log':
            # c.k doesn't exist when the log pane is created.
            # k.makeAllBindings will call setTabBindings('Log')
            self.setTabBindings(tabName)
    else:
        self.textDict [tabName] = None
        self.frameDict [tabName] = tabFrame
</t>
<t tx="ekr.20070626112754.839">w = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'

if wrap not in ('none','char','word'): wrap = 'none'
try: w.configure(bg=bg,wrap=wrap)
except Exception: pass # Could be a user error.

self.SetWidgetFontFromConfig(logCtrl=w)

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = w

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]

self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags
</t>
<t tx="ekr.20070626112754.840">def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)
    values = d.values()
    if self.numberOfVisibleTabs() &gt; 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return </t>
<t tx="ekr.20070626112754.841">def hideTab (self,tabName):

    __pychecker__ = '--no-argsused' # tabName

    self.selectTab('Log')
</t>
<t tx="ekr.20070626112754.842">def getSelectedTab (self):

    return self.tabName
</t>
<t tx="ekr.20070626112754.843">def lowerTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.844">def numberOfVisibleTabs (self):

    return len([val for val in self.frameDict.values() if val != None])
</t>
<t tx="ekr.20070626112754.845">def renameTab (self,oldName,newName):

    # g.trace('newName',newName)

    label = self.nb.tab(oldName)
    label.configure(text=newName)
</t>
<t tx="ekr.20070626112754.846">def selectTab (self,tabName,createText=True,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c

    tabFrame = self.frameDict.get(tabName)
    logCtrl = self.textDict.get(tabName)

    if tabFrame and logCtrl:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    elif not tabFrame:
        self.createTab(tabName,createText=createText,wrap=wrap)

    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0: # Absolutely do not do this here!  It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)
    return tabFrame
</t>
<t tx="ekr.20070626112754.847"></t>
<t tx="ekr.20070626112754.848">def onRightClick (self,event,menu):

    c = self.c
    menu.post(event.x_root,event.y_root)


def onClick (self,event,tabName):

    self.selectTab(tabName)
</t>
<t tx="ekr.20070626112754.849">def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)

    # This is called by getTabName.
    def selectTabCallback (newName):
        return self.selectTab(newName)

    self.getTabName(selectTabCallback)
</t>
<t tx="ekr.20070626112754.850">def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            return self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)
</t>
<t tx="ekr.20070626112754.851">def getTabName (self,exitCallback):

    canvas = self.nb.component('hull')

    # Overlay what is there!
    c = self.c
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)

    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)

    def closeTabNameCallback (event=None):
        f.pack_forget()

    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)

    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    g.app.gui.set_focus(c,e)
    e.bind('&lt;Return&gt;',getNameCallback)
</t>
<t tx="ekr.20070626112754.852">def createColorPicker (self,tabName):

    log = self

    &lt;&lt; define colors &gt;&gt;

    parent = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    colors = list(colors)
    bg = parent.cget('background')

    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)

    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')

    label = g.app.gui.plainTextWidget(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    &lt;&lt; create optionMenu and callback &gt;&gt;
    &lt;&lt; create picker button and callback &gt;&gt;
</t>
<t tx="ekr.20070626112754.853">colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
</t>
<t tx="ekr.20070626112754.854">def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)
</t>
<t tx="ekr.20070626112754.855">colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )
</t>
<t tx="ekr.20070626112754.856"></t>
<t tx="ekr.20070626112754.857">def createFontPicker (self,tabName):

    log = self
    parent = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    bg = parent.cget('background')
    font = self.getFont()
    &lt;&lt; create the frames &gt;&gt;
    &lt;&lt; create the family combo box &gt;&gt;
    &lt;&lt; create the size entry &gt;&gt;
    &lt;&lt; create the weight combo box &gt;&gt;
    &lt;&lt; create the slant combo box &gt;&gt;
    &lt;&lt; create the sample text widget &gt;&gt;
    &lt;&lt; create and bind the callbacks &gt;&gt;
    self.createBindings()
</t>
<t tx="ekr.20070626112754.858">f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')
</t>
<t tx="ekr.20070626112754.859">names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'&lt;None&gt;')

self.familyBox = familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20070626112754.860">Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4)
sizeEntry.insert(0,'12')
sizeEntry.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20070626112754.861">weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20070626112754.862">slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20070626112754.863">self.sampleWidget = sample = g.app.gui.plainTextWidget(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert(0,s)
</t>
<t tx="ekr.20070626112754.864">def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('&lt;Return&gt;',fontCallback)
</t>
<t tx="ekr.20070626112754.865">def createBindings (self):

    c = self.c ; k = c.k

    table = (
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Double-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClickHandler),
        ('&lt;Double-3&gt;',  k.masterClickHandler),
        ('&lt;Key&gt;',       k.masterKeyHandler),
        ("&lt;Escape&gt;",    self.hideFontTab),
    )

    w = self.sampleWidget
    for event, callback in table:
        w.bind(event,callback)

    k.completeAllBindingsForWidget(w)
</t>
<t tx="ekr.20070626112754.866">def getFont(self,family=None,size=12,slant='roman',weight='normal'):

    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
</t>
<t tx="ekr.20070626112754.867">def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):

    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','&lt;none&gt;',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)
</t>
<t tx="ekr.20070626112754.868">def hideFontTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.869">class nullBody (leoBody):

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.870">def __init__ (self,frame,parentFrame):

    # g.trace('nullBody','frame',frame,g.callers())

    leoBody.__init__ (self,frame,parentFrame) # Init the base class.

    self.insertPoint = 0
    self.selection = 0,0
    self.s = "" # The body text

    w = stringTextWidget(c=self.c,name='body')
    self.bodyCtrl = self.widget = w
    self.editorWidgets['1'] = w
    self.colorizer = leoColor.nullColorizer(self.c)
</t>
<t tx="ekr.20070626112754.871"></t>
<t tx="ekr.20070626112754.872">def findStartOfLine (self,lineNumber):

    lines = g.splitLines(self.s)
    i = 0 ; index = 0
    for line in lines:
        if i == lineNumber: break
        i += 1
        index += len(line)
    return index
</t>
<t tx="ekr.20070626112754.873">def scanToStartOfLine (self,i):

    if i &lt;= 0:
        return 0

    assert(self.s[i] != '\n')

    while i &gt;= 0:
        if self.s[i] == '\n':
            return i + 1

    return 0
</t>
<t tx="ekr.20070626112754.874">def scanToEndOfLine (self,i):

    if i &gt;= len(self.s):
        return len(self.s)

    assert(self.s[i] != '\n')

    while i &lt; len(self.s):
        if self.s[i] == '\n':
            return i - 1

    return i
</t>
<t tx="ekr.20070626112754.875"># Birth, death &amp; config
def bind(self,*args,**keys):                pass
def createBindings (self,w=None):           pass
def createControl (self,frame,parentFrame,p): pass
def setColorFromConfig (self,w=None):       pass
def setFontFromConfig (self,w=None):        pass
# Editors...
def addEditor (self,event=None):            pass
def assignPositionToEditor (self,p):        pass
def createEditorFrame (self,w):             pass
def cycleEditorFocus (self,event=None):     pass
def deleteEditor (self,event=None):         pass
def selectEditor(self,w):                   pass
def selectLabel (self,w):                   pass
def setEditorColors (self,bg,fg):           pass
def unselectLabel (self,w):                 pass
def updateEditors (self):                   pass
# Events...
def forceFullRecolor (self,*args,**keys):   pass
def scheduleIdleTimeRoutine (self,function,*args,**keys): pass
# Low-level gui...
def getBodyPaneHeight (self):               return 500
def getBodyPaneWidth (self):                return 600
def hasFocus (self):                        pass
def setFocus (self):                        pass
def tag_add (self,tagName,index1,index2):   pass
def tag_bind (self,tagName,event,callback): pass
def tag_configure (self,colorName,**keys):  pass
def tag_delete(self,tagName):               pass
def tag_remove (self,tagName,index1,index2):pass
</t>
<t tx="ekr.20070626112754.876">class nullFindTab (findTab):

    @others</t>
<t tx="ekr.20070626112754.877"></t>
<t tx="ekr.20070626112754.878">if 0: # Use the base-class ctor.

    def __init__ (self,c,parentFrame):

        findTab.__init__(self,c,parentFrame)
            # Init the base class.
            # Calls initGui, createFrame, createBindings &amp; init(c), in that order.
</t>
<t tx="ekr.20070626112754.879"># Called from findTab.ctor.

def initGui (self):

    self.svarDict = {} # Keys are ivar names, values are svar objects.

    for key in self.intKeys:
        self.svarDict[key] = self.svar() # Was Tk.IntVar.

    for key in self.newStringKeys:
        self.svarDict[key] = self.svar() # Was Tk.StringVar.
</t>
<t tx="ekr.20070626112754.880"># Called from findTab.ctor.

def init (self,c):

    # Separate c.ivars are much more convenient than a svarDict.
    for key in self.intKeys:
        # Get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0)
        svar = self.svarDict.get(key)
        if svar: svar.set(val)
        #g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;
    &lt;&lt; set checkboxes from ivars &gt;&gt;
</t>
<t tx="ekr.20070626112754.881">self.find_ctrl.delete(0,"end")
self.change_ctrl.delete(0,"end")

# Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
</t>
<t tx="ekr.20070626112754.882"># In Tk, setting the var also sets the widget.
# Here, we do so explicitly.
d = self.widgetsDict
for ivar,key in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-find-type"].set(key)
        w = d.get(key)
        if w: w.set(True)
        break
else:
    self.svarDict["radio-find-type"].set("plain-search")

for ivar,key in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-search-scope"].set(key)
        break
else:
    key = 'entire-outline'
    self.svarDict["radio-search-scope"].set(key)
    w = self.widgetsDict.get(key)
    if w: w.set(True)
</t>
<t tx="ekr.20070626112754.883">for ivar in (
    'ignore_case',
    'mark_changes',
    'mark_finds',
    'pattern_match',
    'reverse',
    'search_body',
    'search_headline',
    'whole_word',
    'wrap',
):
    svar = self.svarDict[ivar].get()
    if svar:
        w = self.widgetsDict.get(ivar)
        if w: w.set(True)
</t>
<t tx="ekr.20070626112754.884">def createBindings (self):
    pass</t>
<t tx="ekr.20070626112754.885">def createFrame (self,parentFrame):

    self.parentFrame = self.top = parentFrame

    self.createFindChangeAreas()
    self.createBoxes()</t>
<t tx="ekr.20070626112754.886">def createFindChangeAreas (self):

    c = self.c

    # A plainTextWidget must be a stringTextWidget
    plainTextWidget = g.app.gui.plainTextWidget

    import leoFrame
    assert issubclass(plainTextWidget,leoFrame.stringTextWidget)

    self.find_ctrl   = plainTextWidget(c,name='find-text')
    self.change_ctrl = plainTextWidget(c,name='change-text')
</t>
<t tx="ekr.20070626112754.887">def createBoxes (self):

    '''Create two columns of radio buttons &amp; check boxes.'''

    c = self.c
    # f = self.parentFrame
    self.boxes = []
    self.widgetsDict = {} # Keys are ivars, values are checkboxes or radio buttons.

    data = ( # Leading star denotes a radio button.
        ('Whole &amp;Word', 'whole_word',),
        ('&amp;Ignore Case','ignore_case'),
        ('Wrap &amp;Around','wrap'),
        ('&amp;Reverse',    'reverse'),
        ('Rege&amp;xp',     'pattern_match'),
        ('Mark &amp;Finds', 'mark_finds'),
        ("*&amp;Entire Outline","entire-outline"),
        ("*&amp;Suboutline Only","suboutline-only"),  
        ("*&amp;Node Only","node-only"),
        ('Search &amp;Headline','search_headline'),
        ('Search &amp;Body','search_body'),
        ('Mark &amp;Changes','mark_changes'),
    )

    # Important: changing these controls merely changes entries in self.svarDict.
    # First, leoFind.update_ivars sets the find ivars from self.svarDict.
    # Second, self.init sets the values of widgets from the ivars.
    # inGroup = False
    for label,ivar in data:
        if label.startswith('*'):
            label = label[1:]
            # style = g.choose(inGroup,0,wx.RB_GROUP)
            # inGroup = True
            # w = wx.RadioButton(f,label=label,style=style)
            w = self.buttonWidget(label)
            self.widgetsDict[ivar] = w
            # def radioButtonCallback(event=None,ivar=ivar):
                # svar = self.svarDict["radio-search-scope"]
                # svar.set(ivar)
            # w.Bind(wx.EVT_RADIOBUTTON,radioButtonCallback)
        else:
            #w = wx.CheckBox(f,label=label)
            w = self.buttonWidget(label)
            self.widgetsDict[ivar] = w
            # def checkBoxCallback(event=None,ivar=ivar):
                # svar = self.svarDict.get(ivar)
                # val = svar.get()
                # svar.set(g.choose(val,False,True))
                # # g.trace(ivar,val)
            # w.Bind(wx.EVT_CHECKBOX,checkBoxCallback)
        self.boxes.append(w)</t>
<t tx="ekr.20070626112754.888">def createButtons (self):

    '''Create two columns of buttons.'''

    # # Create the alignment panes.
    # buttons  = Tk.Frame(outer,background=bg)
    # buttons1 = Tk.Frame(buttons,bd=1,background=bg)
    # buttons2 = Tk.Frame(buttons,bd=1,background=bg)
    # buttons.pack(side='top',expand=1)
    # buttons1.pack(side='left')
    # buttons2.pack(side='right')

    # width = 15 ; defaultText = 'Find' ; buttons = []

    # for text,boxKind,frame,callback in (
        # # Column 1...
        # ('Find','button',buttons1,self.findButtonCallback),
        # ('Find All','button',buttons1,self.findAllButton),
        # # Column 2...
        # ('Change','button',buttons2,self.changeButton),
        # ('Change, Then Find','button',buttons2,self.changeThenFindButton),
        # ('Change All','button',buttons2,self.changeAllButton),
    # ):
        # w = underlinedTkButton(boxKind,frame,
            # text=text,command=callback)
        # buttons.append(w)
        # if text == defaultText:
            # w.button.configure(width=width-1,bd=4)
        # elif boxKind != 'check':
            # w.button.configure(width=width)
        # w.button.pack(side='top',anchor='w',pady=2,padx=2)
</t>
<t tx="ekr.20070626112754.889">class svar:
    '''A class like Tk's IntVar and StringVar classes.'''
    def __init__(self):
        self.val = None
    def get (self):
        return self.val
    def set (self,val):
        self.val = val

    SetValue = set # SetValue is the wxWidgets spelling.</t>
<t tx="ekr.20070626112754.890">class buttonWidget:

    '''A class to simulate a Tk.Button.'''

    def __init__ (self,label):
        self.label = label
        self.val = False

    def __repr (self):
        return 'nullFindTab.buttonWidget: %s' % self.label

    def get (self):
        return self.val

    def set (self,val):
        self.val = val
</t>
<t tx="ekr.20070626112754.891"># This is the same as the Tk code because we simulate Tk svars.</t>
<t tx="ekr.20070626112754.892">def getOption (self,ivar):

    var = self.svarDict.get(ivar)

    if var:
        val = var.get()
        # g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
</t>
<t tx="ekr.20070626112754.893">def setOption (self,ivar,val):

    if ivar in self.intKeys:
        if val is not None:
            var = self.svarDict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20070626112754.894">def toggleOption (self,ivar):

    if ivar in self.intKeys:
        var = self.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20070626112754.895">class nullFrame (leoFrame):

    """A null frame class for tests and batch execution."""

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.896">def __init__ (self,title,gui,useNullUndoer=False):

    # g.trace('nullFrame')

    leoFrame.__init__(self,gui) # Init the base class.
    assert(self.c is None)

    self.body = None
    self.bodyCtrl = None
    self.iconBar = nullIconBarClass(self.c,self)
    # self.iconBarClass = self.nullIconBarClass
    self.isNullFrame = True
    self.outerFrame = None
    self.statusLineClass = nullStatusLineClass
    self.title = title
    self.useNullUndoer = useNullUndoer

    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
</t>
<t tx="ekr.20070626112754.897">def destroySelf (self):

    pass
</t>
<t tx="ekr.20070626112754.898">def finishCreate(self,c):

    self.c = c

    # print 'nullFrame'

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)

    c.setLog()

    # Set the official ivar.
    self.bodyCtrl = self.body.bodyCtrl

    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)


</t>
<t tx="ekr.20070626112754.899"></t>
<t tx="ekr.20070626112754.900">def resizePanesToRatio (self,ratio,secondary_ratio):    pass
def setInitialWindowGeometry (self):                    pass
def setMinibufferBindings(self):                        pass
</t>
<t tx="ekr.20070626112754.901">def setTopGeometry (self,w,h,x,y,adjustSize=True):

    __pychecker__ = '--no-argsused' # adjustSize used in derived classes.

    self.w = w
    self.h = h
    self.x = x
    self.y = y
</t>
<t tx="ekr.20070626112754.902"># Expanding and contracting panes.
def contractPane         (self,event=None): pass
def expandPane           (self,event=None): pass
def contractBodyPane     (self,event=None): pass
def contractLogPane      (self,event=None): pass
def contractOutlinePane  (self,event=None): pass
def expandBodyPane       (self,event=None): pass
def expandLogPane        (self,event=None): pass
def expandOutlinePane    (self,event=None): pass
def fullyExpandBodyPane  (self,event=None): pass
def fullyExpandLogPane   (self,event=None): pass
def fullyExpandPane      (self,event=None): pass
def fullyExpandOutlinePane (self,event=None): pass
def hideBodyPane         (self,event=None): pass
def hideLogPane          (self,event=None): pass
def hidePane             (self,event=None): pass
def hideOutlinePane      (self,event=None): pass

# In the Window menu...
def cascade              (self,event=None): pass
def equalSizedPanes      (self,event=None): pass
def hideLogWindow        (self,event=None): pass
def minimizeAll          (self,event=None): pass
def resizeToScreen       (self,event=None): pass
def toggleActivePane     (self,event=None): pass
def toggleSplitDirection (self,event=None): pass

# In help menu...
def leoHelp (self,event=None): pass</t>
<t tx="ekr.20070626112754.903">def bringToFront (self):    pass
def deiconify (self):       pass
def get_window_info(self):
    # Set w,h,x,y to a reasonable size and position.
    return 600,500,20,20
def lift (self):            pass
def setWrap (self,flag):    pass
def update (self):          pass
</t>
<t tx="ekr.20070626112754.904">class nullGui(leoGui):

    """Null gui class."""

    __pychecker__ = '--no-argsused' # This class has many unused args.

    @others
</t>
<t tx="ekr.20070626112754.905"></t>
<t tx="ekr.20070626112754.906">def __init__ (self,guiName):

    leoGui.__init__ (self,guiName) # init the base class.

    self.clipboardContents = ''
    self.dict = {}
    self.focusWidget = None
    self.script = None
    self.lastFrame = None
    self.isNullGui = True
    self.bodyTextWidget  = leoFrame.stringTextWidget
    self.plainTextWidget = leoFrame.stringTextWidget
</t>
<t tx="ekr.20070626112754.907">def createKeyHandlerClass (self,c,useGlobalKillbuffer=True,useGlobalRegisters=True):

    import leoKeys # Do this here to break a circular dependency.

    return leoKeys.keyHandlerClass(c,useGlobalKillbuffer,useGlobalRegisters)</t>
<t tx="ekr.20070626112754.908">def runMainLoop(self):

    """Run the gui's main loop."""

    if self.script:
        frame = self.lastFrame
        g.app.log = frame.log
        # g.es("Start of batch script...\n")
        self.lastFrame.c.executeScript(script=self.script)
        # g.es("\nEnd of batch script")

    # Getting here will terminate Leo.
</t>
<t tx="ekr.20070626112754.909">def isTextWidget (self,w):

    '''Return True if w is a Text widget suitable for text-oriented commands.'''

    return w and isinstance(w,leoFrame.baseTextWidget)
</t>
<t tx="ekr.20070626112754.910">def oops(self):

    """Default do-nothing method for nullGui class.

    It is NOT an error to use this method."""

    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        g.trace("nullGui",g.callers())
</t>
<t tx="ekr.20070626112754.911">def attachLeoIcon (self,w):
    pass

def createRootWindow(self):
    pass

def destroySelf (self):
    pass

def finishCreate (self):
    pass

def getTextFromClipboard (self):
    return self.clipboardContents

def get_focus(self,frame):
    return self.focusWidget or frame.body.bodyCtrl

def get_window_info (self,window):
    return 0,0,0,0

def replaceClipboardWith (self,s):
    self.clipboardContents = s

def set_focus(self,commander,widget):
    self.focusWidget = widget</t>
<t tx="ekr.20070626112754.912">def createComparePanel(self,c):
    """Create Compare panel."""
    self.oops()

def createFindPanel(self,c):
    """Create a hidden Find panel."""
    self.oops()

def createFindTab (self,c,parentFrame):
    """Create a Tkinter find tab in the indicated frame."""
    return leoFind.nullFindTab(c,parentFrame)

def createLeoFrame(self,title):
    """Create a null Leo Frame."""
    gui = self
    self.lastFrame = leoFrame.nullFrame(title,gui)
    return self.lastFrame
</t>
<t tx="ekr.20070626112754.913">def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message):
    return self.simulateDialog("numberDialog",-1)

def runAskOkCancelStringDialog(self,c,title,message):
    return self.simulateDialog("stringDialog",'')

def runCompareDialog(self,c):
    return self.simulateDialog("compareDialog",'')

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")
</t>
<t tx="ekr.20070626112754.914">def simulateDialog (self,key,defaultVal=None):

    val = self.dict.get(key,defaultVal)

    if self.trace:
        print key, val

    return val
</t>
<t tx="ekr.20070626112754.915">class nullLog (leoLog):

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.916"></t>
<t tx="ekr.20070626112754.917">def __init__ (self,frame=None,parentFrame=None):

    # Init the base class.
    leoLog.__init__(self,frame,parentFrame)

    self.isNull = True
    self.logCtrl = self.createControl(parentFrame)
</t>
<t tx="ekr.20070626112754.918">def createControl (self,parentFrame):

    return self.createTextWidget(parentFrame)
</t>
<t tx="ekr.20070626112754.919">def createTextWidget (self,parentFrame=None):

    self.logNumber += 1

    c = self.c

    gui = c and c.frame and c.frame.gui or g.app.gui

    log = gui.plainTextWidget( ### was g.app.gui.
        c = self.c,
        name="log-%d" % self.logNumber,
    )

    return log
</t>
<t tx="ekr.20070626112754.920">def oops(self):

    g.trace("nullLog:", g.callers())
</t>
<t tx="ekr.20070626112754.921">def clearTab        (self,tabName):     pass
def createTab (self,tabName,createText=True,wrap='none'): pass
def deleteTab       (self,tabName,force=False):     pass
def getSelectedTab          (self):     pass
def lowerTab        (self,tabName):     pass
def raiseTab        (self,tabName):     pass
def renameTab (self,oldName,newName):   pass
def selectTab (self,tabName,createText=True,wrap='none'): pass
def setTabBindings  (self,tabName):     pass
</t>
<t tx="ekr.20070626112754.922">class nullStatusLineClass:

    '''A do-nothing status line.'''

    @others</t>
<t tx="ekr.20070626112754.923">def __init__ (self,c,parentFrame):

    self.c = c
    self.enabled = False
    self.parentFrame = parentFrame

    gui = c and c.frame and c.frame.gui or g.app.gui

    self.textWidget = w = gui.plainTextWidget(c,name='status-line')

    # Set the official ivars.
    c.frame.statusFrame = None
    c.frame.statusLabel = None
    c.frame.statusText  = self.textWidget
</t>
<t tx="ekr.20070626112754.924">def disable (self,background=None):
    self.enabled = False
    self.c.bodyWantsFocus()

def enable (self,background="white"):
    if w: self.c.widgetWantsFocus(self.textWidget)
    self.enabled = True

def clear (self):                   self.textWidget.delete(0,'end')
def get (self):                     return self.textWidget.getAllText()
def isEnabled(self):                return self.enabled
def getFrame (self):                return None
def onActivate (self,event=None):   pass 
def pack (self):                    pass
def put(self,s,color=None):         self.textWidget.insert('end',s)
def unpack (self):                  pass
def update (self):                  pass

hide = unpack
show = pack
</t>
<t tx="ekr.20070626112754.925">class nullTree (leoTree):

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.926">def __init__ (self,frame):

    leoTree.__init__(self,frame) # Init the base class.

    assert(self.frame)

    self.editWidgetsDict = {} # Keys are tnodes, values are stringTextWidgets.
    self.font = None
    self.fontName = None
    self.canvas = None
    self.stayInTree = True
    self.trace_edit = False
    self.trace_select = False
    self.updateCount = 0
</t>
<t tx="ekr.20070626112754.927">def printWidgets(self):

    d = self.editWidgetsDict
    keys = d.keys()
    for key in keys:
        # keys are tnodes, values are stringTextWidgets.
        w = d.get(key)
        print 'w',w,'t.headString:',key.headString,'s:',repr(w.s)

</t>
<t tx="ekr.20070626112754.928"></t>
<t tx="ekr.20070626112754.929">def getFont(self):
    return self.font

# def setColorFromConfig (self):
    # pass

def setBindings (self):
    pass

def setFont(self,font=None,fontName=None):
    self.font,self.fontName = font,fontName

def setFontFromConfig (self):
    pass
</t>
<t tx="ekr.20070626112754.930">def beginUpdate (self):
    self.updateCount += 1

def endUpdate (self,flag,scroll=False):
    self.updateCount -= 1
    if flag and self.updateCount &lt;= 0:
        self.redraw_now()

def drawIcon(self,v,x=None,y=None):
    pass

def redraw_now(self,scroll=True):
    self.redrawCount += 1
    # g.trace('nullTree')

def scrollTo(self,p):
    pass
</t>
<t tx="ekr.20070626112754.931">def edit_widget (self,p):
    d = self.editWidgetsDict ; w = d.get(p.v.t)
    if not w:
        d[p.v.t] = w = stringTextWidget(
            c=self.c,
            name='head-%d' % (1 + len(d.keys())))
        w.setAllText(p.headString())
    # g.trace('w',w,'p',p.headString())
    return w

def headWidth(self,p=None,s=''):
    return len(s)

def setEditLabelState(self,v,selectAll=False):
    pass

def setSelectedLabelState(self,*args,**keys):
    pass

def setUnselectedLabelState(self,*args,**keys):
    pass
</t>
<t tx="ekr.20070626112754.932">def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p

    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

    if p and c.edit_widget(p):
        # g.trace('selectAll',selectAll,g.callers())
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
</t>
<t tx="ekr.20070626112754.933">def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''

    # g.trace('p',p.headString(),'s',repr(s),g.callers())

    w = self.edit_widget(p)
    if w:
        w.delete(0,'end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert(0,s)
        self.revertHeadline = s
        # g.trace(repr(s),w.getAllText())
    else:
        g.trace('-'*20,'oops')
</t>
<t tx="ekr.20070626112754.934">class stringTextWidget (baseTextWidget):

    '''A class that represents text as a Python string.'''

    @others
</t>
<t tx="ekr.20070626112754.935">def __init__ (self,c,name):

    # Init the base class
    baseTextWidget.__init__ (self,c=c,
        baseClassName='stringTextWidget',name=name,widget=None)

    self.ins = 0
    self.sel = 0,0
    self.s = ''
    self.trace = False
</t>
<t tx="ekr.20070626112754.936">def _appendText(self,s):
    #if self.trace: g.trace(self,'len(s)',len(s))
    if self.trace: g.trace(self,'ins',self.ins,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    self.s = self.s + s
    self.ins = len(self.s)
    self.sel = self.ins,self.ins
def _get(self,i,j):                 return self.s[i:j]
def _getAllText(self):              return self.s
def _getFocus(self):                return self
def _getInsertPoint(self):
    # if self.trace: g.trace(self,self.ins)
    return self.ins
def _getLastPosition(self):         return len(self.s)
def _getSelectedText(self):         i,j = self.sel ; return self.s[i:j]
def _getSelectionRange(self):       return self.sel
def _getYScrollPosition(self):      return None # A flag.
def _hitTest(self,pos):             pass
def _insertText(self,i,s):
    s1 = s
    self.s = self.s[:i] + s1 + self.s[i:]
    # if self.trace: g.trace(self,'s',repr(s),'self.s',repr(self.s))
    # if self.trace: g.trace(self,'i',i,'len(s)',len(s),g.callers())
    if self.trace: g.trace(self,'i',i,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    i += len(s1)
    self.ins = i
    self.sel = i,i
def _scrollLines(self,n):           pass
def _see(self,i):                   pass
def _setAllText(self,s):
    if self.trace: g.trace(self,'len(s)',len(s),g.callers())
    if self.trace: g.trace(self,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i,i
def _setBackgroundColor(self,color): pass
def _setFocus(self):                pass
def _setInsertPoint(self,i):
    if self.trace: g.trace(self,'i',i)
    self.ins = i
    self.sel = i,i</t>
<t tx="ekr.20070626112754.937">def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    self.sel = i,j

    if insert is not None: 
        self.ins = w.toPythonIndex(insert)
    else:
        self.ins = j

    if self.trace: g.trace('i',i,'j',j,'insert',repr(insert))</t>
<t tx="ekr.20070626112754.938">class unitTestGui(nullGui):

    '''A gui class for use by unit tests.'''

    # Presently used only by the import/export unit tests.

    @others
</t>
<t tx="ekr.20070626112754.939">def __init__ (self,dict={},trace=False):

    self.oldGui = g.app.gui

    # Init the base class
    nullGui.__init__ (self,"unitTestGui")

    # Use the same kind of widgets as the old gui.
    self.bodyTextWidget = self.oldGui.bodyTextWidget
    self.plainTextWidget = self.oldGui.plainTextWidget

    self.dict = dict
    self.trace = trace
    g.app.gui = self

def destroySelf (self):

    g.app.gui = self.oldGui
</t>
<t tx="ekr.20070626112754.940"></t>
<t tx="ekr.20070626112754.941">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4169720
By: ktenney

from https://sourceforge.net/forum/message.php?msg_id=4167714

&gt;So now the answer is clear: Leo searches for leoPluginsManager 
&gt;first in the g.app.homeDir directory, and second, in the leo/plugins
directory.

I work from several machines, keep my files synced via 
a svn server at home.

I would really like to use a single pluginsManager.txt
and sync it with the files.

Here's a +1 on Leo looking in the directory of the Leo
file being opened.

This would make pluginsManager.txt behave like leoSettings.leo
</t>
<t tx="ekr.20070626112754.942"></t>
<t tx="ekr.20070626112754.943">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize)

def getRecentFiles (self):
    return g.app.config.getRecentFiles()

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getAbbrevDict(self):         return g.app.config.getAbbrevDict(self.c)
def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getOpenWith  (self):         return g.app.config.getOpenWith (self.c)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting,):return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
</t>
<t tx="ekr.20070626112754.944"></t>
<t tx="ekr.20070626112754.945">def canonicalizeSettingName (self,name):

    if name is None:
        return None

    name = name.lower()
    for ch in ('-','_',' ','\n'):
        name = name.replace(ch,'')

    return g.choose(name,name,None)

munge = canonicalizeSettingName
</t>
<t tx="ekr.20070626112754.946">def findSettingsPosition (self,c,setting):

    """Return the position for the setting in the @settings tree for c."""

    munge = self.munge

    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()

    setting = munge(setting)

    for p in root.subtree_iter():
        h = munge(p.headString())
        if h == setting:
            return p.copy()

    return c.nullPosition()
</t>
<t tx="ekr.20070626112754.947">def get (self,c,setting,kind):

    """Get the setting and make sure its type matches the expected type."""

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val

    for d in self.localOptionsList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # g.trace(kind,setting,val)
            return val

    return None
</t>
<t tx="ekr.20070626112754.948">def getValFromDict (self,d,setting,requestedType,warn=True):

    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    bunch = d.get(self.munge(setting))
    if not bunch: return None,False

    # g.trace(setting,requestedType,bunch.toString())
    val = bunch.val
    if not self.typesMatch(bunch.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            s = (
                'Warning: ignoring %s:%s not %s\n' +
                'There may be conflicting settings!')
            g.es_print(s % (bunch.kind,setting,requestedType),color='red')
            # g.trace(g.callers())
        return None, False
    elif val in (u'None',u'none','None','none','',None):
        return None, True # Exists, but is None
    else:
        # g.trace(setting,val)
        return val, True
</t>
<t tx="ekr.20070626112754.949">def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts',)

    return (
        type1 == None or type2 == None or
        type1.startswith('string') or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
</t>
<t tx="ekr.20070626112754.950">def exists (self,c,setting,kind):

    '''Return true if a setting of the given kind exists, even if it is None.'''

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            junk,found = self.getValFromDict(d,setting,kind)
            if found: return True

    for d in self.localOptionsList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    for d in self.dictList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    # g.trace('does not exist',setting,kind)
    return False
</t>
<t tx="ekr.20070626112754.951">def getAbbrevDict (self,c):

    """Search all dictionaries for the setting &amp; check it's type"""

    d = self.get(c,'abbrev','abbrev')
    return d or {}
</t>
<t tx="ekr.20070626112754.952">def getBool (self,c,setting,default=None):

    """Search all dictionaries for the setting &amp; check it's type"""

    val = self.get(c,setting,"bool")

    if val in (True,False):
        return val
    else:
        return default
</t>
<t tx="ekr.20070626112754.953">def getColor (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    return self.get(c,setting,"color")
</t>
<t tx="ekr.20070626112754.954">def getDirectory (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    theDir = self.getString(c,setting)

    if g.os_path_exists(theDir) and g.os_path_isdir(theDir):
         return theDir
    else:
        return None
</t>
<t tx="ekr.20070626112754.955">def getEnabledPlugins (self):

    """Search all dictionaries for the setting &amp; check it's type"""

    return g.app.config.enabledPluginsString
</t>
<t tx="ekr.20070626112754.956">def getFloat (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    val = self.get(c,setting,"float")
    try:
        val = float(val)
        return val
    except TypeError:
        return None
</t>
<t tx="ekr.20070626112754.957">def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize

    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"

    # g.trace(g.callers(3),family,size,slant,weight,g.shortFileName(c.mFileName))

    return g.app.gui.getFontFromParams(family,size,slant,weight)
</t>
<t tx="ekr.20070626112754.958">def getInt (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    val = self.get(c,setting,"int")
    try:
        val = int(val)
        return val
    except TypeError:
        return None
</t>
<t tx="ekr.20070626112754.959">def getLanguage (self,c,setting):

    """Return the setting whose value should be a language known to Leo."""

    language = self.getString(c,setting)
    # g.trace(setting,language)

    return language
</t>
<t tx="ekr.20070626112754.960">def getOpenWith (self,c):

    """Search all dictionaries for the setting &amp; check it's type"""

    val = self.get(c,'openwithtable','openwithtable')

    return val
</t>
<t tx="ekr.20070626112754.961">def getRatio (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    val = self.get(c,setting,"ratio")
    try:
        val = float(val)
        if 0.0 &lt;= val &lt;= 1.0:
            return val
        else:
            return None
    except TypeError:
        return None
</t>
<t tx="ekr.20070626112754.962">def getRecentFiles (self):

    return self.recentFiles
</t>
<t tx="ekr.20070626112754.963">def getShortcut (self,c,shortcutName):

    '''Return rawKey,accel for shortcutName'''

    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&amp;','') # Allow '&amp;' in names.

    bunchList = self.get(c,key,"shortcut")
    if bunchList:
        bunchList = [bunch for bunch in bunchList
            if bunch.val and bunch.val.lower() != 'none']
        return key,bunchList
    else:
        return key,[]
</t>
<t tx="ekr.20070626112754.964">def getString (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    return self.get(c,setting,"string")
</t>
<t tx="ekr.20070626112754.965"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsIvars (self,c):

    data = (
        ("default_tangle_directory","tangle_directory","directory"),
        ("default_target_language","target_language","language"),
        ("output_doc_chunks","output_doc_flag","bool"),
        ("page_width","page_width","int"),
        ("run_tangle_done.py","tangle_batch_flag","bool"),
        ("run_untangle_done.py","untangle_batch_flag","bool"),
        ("tab_width","tab_width","int"),
        ("tangle_outputs_header","use_header_flag","bool"),
    )

    for setting,ivar,theType in data:
        val = g.app.config.get(c,setting,theType)
        if val is None:
            if not hasattr(c,setting):
                setattr(c,setting,None)
                # g.trace(setting,None)
        else:
            setattr(c,setting,val)
            # g.trace(setting,val)
</t>
<t tx="ekr.20070626112754.966">def settingsRoot (self,c):

    # g.trace(c,c.rootPosition())

    for p in c.allNodes_iter():
        if p.headString().rstrip() == "@settings":
            return p.copy()
    else:
        return c.nullPosition()
</t>
<t tx="ekr.20070626112754.967"></t>
<t tx="ekr.20070626112754.968">def doAbbrev (self,p,kind,name,val):

    d = {}
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseAbbrevLine(line)
            if name: d [val] = name

    self.set (p,'abbrev','abbrev',d)
</t>
<t tx="ekr.20070626112754.969">def doBool (self,p,kind,name,val):

    if val in ('True','true','1'):
        self.set(p,kind,name,True)
    elif val in ('False','false','0'):
        self.set(p,kind,name,False)
    else:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.970">def doColor (self,p,kind,name,val):

    # At present no checking is done.
    val = val.lstrip('"').rstrip('"')
    val = val.lstrip("'").rstrip("'")

    self.set(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.971">def doDirectory (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)

doPath = doDirectory
</t>
<t tx="ekr.20070626112754.972">def doEnabledPlugins (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c
    s = p.bodyString()

    # This setting is handled differently from all other settings,
    # because the last setting must be retrieved before any commander exists.

    # g.trace('len(s)',len(s))

    # Set the global config ivars.
    g.app.config.enabledPluginsString = s
    g.app.config.enabledPluginsFileName = c and c.shortFileName() or '&lt;no settings file&gt;'
</t>
<t tx="ekr.20070626112754.973">def doFloat (self,p,kind,name,val):

    try:
        val = float(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.974">def doFont (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind not used.

    d = self.parseFont(p)

    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
</t>
<t tx="ekr.20070626112754.975">def doIf(self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # args not used.

    g.trace("'if' not supported yet")
    return None
</t>
<t tx="ekr.20070626112754.976">@ Alas, @if-gui can't be made to work. The problem is that plugins can set
g.app.gui, but plugins need settings so the leoSettings.leo files must be parsed
before g.app.gui.guiName() is known.
@c

if 0:

    def doIfGui (self,p,kind,name,val):

        __pychecker__ = '--no-argsused' # args not used.

        # g.trace(repr(name))

        if not g.app.gui or not g.app.gui.guiName():
            s = '@if-gui has no effect: g.app.gui not defined yet'
            g.es_print(s,color='blue')
            return "skip"
        elif g.app.gui.guiName().lower() == name.lower():
            return None
        else:
            return "skip"
</t>
<t tx="ekr.20070626112754.977">def doIfPlatform (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # args not used.

    # g.trace(sys.platform,repr(name))

    if sys.platform.lower() == name.lower():
        return None
    else:
        return "skip"
</t>
<t tx="ekr.20070626112754.978">def doIgnore(self,p,kind,name,val):

    return "skip"
</t>
<t tx="ekr.20070626112754.979">def doInt (self,p,kind,name,val):

    try:
        val = int(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.980">def doInts (self,p,kind,name,val):

    '''We expect either:
    @ints [val1,val2,...]aName=val
    @ints aName[val1,val2,...]=val'''

    name = name.strip() # The name indicates the valid values.
    i = name.find('[')
    j = name.find(']')

    # g.trace(kind,name,val)

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        name = name[:i]+name[j+1:].strip()
        # g.trace(name,items)
        try:
            items = [int(item.strip()) for item in items]
        except ValueError:
            items = []
            self.valueError(p,'ints[]',name,val)
            return
        kind = "ints[%s]" % (','.join([str(item) for item in items]))
        try:
            val = int(val)
        except ValueError:
            self.valueError(p,'int',name,val)
            return
        if val not in items:
            self.error("%d is not in %s in %s" % (val,kind,name))
            return

        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.981">def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''

    __pychecker__ = '--no-argsused' # val not used.

    c = self.c ; k = c.k

    # g.trace('%20s' % (name),c.fileName())
    &lt;&lt; Compute modeName &gt;&gt;

    # Create a local shortcutsDict.
    old_d = self.shortcutsDict
    d = self.shortcutsDict = {}

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if not name:
                # An entry command: put it in the special *entry-commands* key.
                aList = d.get('*entry-commands*',[])
                aList.append(bunch.entryCommandName)
                d ['*entry-commands*'] = aList
            elif bunch is not None:
                # A regular shortcut.
                bunch.val = k.strokeFromSetting(bunch.val)
                bunch.pane = modeName
                bunchList = d.get(name,[])
                # Important: use previous bindings if possible.
                key2,bunchList2 = c.config.getShortcut(name)
                bunchList3 = [b for b in bunchList2 if b.pane != modeName]
                if bunchList3:
                    # g.trace('inheriting',[b.val for b in bunchList3])
                    bunchList.extend(bunchList3)
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)

    # Restore the global shortcutsDict.
    self.shortcutsDict = old_d

    # Create the command, but not any bindings to it.
    self.createModeCommand(modeName,d)
</t>
<t tx="ekr.20070626112754.982">name = name.strip().lower()
j = name.find(' ')
if j &gt; -1: name = name[:j]
if name.endswith('mode'):
    name = name[:-4].strip()
if name.endswith('-'):
    name = name[:-1]
modeName = name + '-mode'
</t>
<t tx="ekr.20070626112754.983">def doOpenWith (self,p,kind,name,val):

    # g.trace('kind',kind,'name',name,'val',val,'c',self.c)

    d = self.parseOpenWith(p)
    d['name']=name
    d['shortcut']=val
    name = kind = 'openwithtable'
    self.openWithList.append(d)
    self.set(p,kind,name,self.openWithList)
</t>
<t tx="ekr.20070626112754.984">def doPage(self,p,kind,name,val):

    pass # Ignore @page this while parsing settings.
</t>
<t tx="ekr.20070626112754.985">def doRatio (self,p,kind,name,val):

    try:
        val = float(val)
        if 0.0 &lt;= val &lt;= 1.0:
            self.set(p,kind,name,val)
        else:
            self.valueError(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.986">def doShortcuts(self,p,kind,name,val,s=None):

    __pychecker__ = '--no-argsused' # kind,val.

    # g.trace(self.c.fileName(),name)

    c = self.c ; d = self.shortcutsDict
    if s is None: s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if bunch is not None:
                # A regular shortcut.
                bunchList = d.get(name,[])
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)
</t>
<t tx="ekr.20070626112754.987">def doString (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.988">def doStrings (self,p,kind,name,val):

    '''We expect one of the following:
    @strings aName[val1,val2...]=val
    @strings [val1,val2,...]aName=val'''

    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        items = [item.strip() for item in items]
        name = name[:i]+name[j+1:].strip()
        kind = "strings[%s]" % (','.join(items))
        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.989">def loadOnePlugin (moduleOrFileName, verbose=False):

    global loadedModules,loadingModuleNameStack

    verbose = verbose or g.app.config.getBool(c=None,setting='trace_plugins')

    if moduleOrFileName.endswith('.py'):
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            s = 'plugin %s already loaded' % moduleName
            g.es_print(s,color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        if hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                if init_result:
                    loadedModules[moduleName] = result
                else:
                    if verbose and not g.app.initing: ## or not g.app.unitTesting:
                        g.es_print('loadOnePlugin: loading module %s failed' % (moduleName),color="red")
                    result = None
            except Exception:
                g.es('Exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.
            g.trace('no init()',moduleName)
            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if result is None:
        if verbose and not g.app.initing: # or not g.app.unitTesting:
            s = 'can not load enabled %s plugin' % moduleName
            g.es_print(s,color="red")
    elif verbose:
        s = 'loaded %s plugin' % moduleName
        g.es_print(s,color="blue")

    return result</t>
<t tx="ekr.20070626112754.990">def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(fileName=fileName,gui=gui)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame</t>
<t tx="ekr.20070626112754.991">def doPlugins(tag,keywords):

    if g.app.killed:
        return

    # g.trace(tag)
    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
</t>
<t tx="ekr.20070626112754.992"># To do: use baseTextWidget class.  There seem to be problems :-)</t>
<t tx="ekr.20070626112754.993"># To be removed outside of tk-specific files.
'cget'  # removed
'clipboard_append' # uses gui, so ok.
'clipboard_clear' # uses gui, so ok.
'config' # removed
'configure' # removed
'focus_force' # removed
'focus_set' # removed

# Ok: defined in leoTkTextWidget, plainTextWidget, etc.
'_name'
'delete'
'deleteTextSelection'
'flashCharacter'
'get'
'getAllText'
'getInsertPoint'
'getName'
'getSelectedText'
'getSelectionRange'
'getYScrollPosition'
# 'getWidth' # optional.
'hasSelection'
'insert'
'replace'
'rowColToGuiIndex'
'see'
'seeInsertPoint'
'selectAllText'
'setAllText'
'setBackgroundColor'
'setInsertPoint'
'setSelectionRange'
'setYScrollPosition'
'tag_add'
'tag_bind'
'tag_config'
'tag_delete'
'tag_names'
'tag_ranges'
'toGuiIndex'
'toPythonIndex'
'xyToPythonIndex'

# Ok: in leoTkinterTree.
'leo_active'
'leo_frame'
'leo_insertSpot'
'leo_label'
'leo_label_s'
'leo_name'
'leo_p'
'leo_position'
'leo_scrollBarSpot'
'leo_selection'
'leo_v'
'leo_window_id'

# Ok only if in tk-specific files.
'bind'
'bind_all'
'bind_class'
'bindtags'
'button'
'columnconfigure'
'compare'
'dlineinfo'
'event_generate'
'grid'
'image_create'
'index'
'mark_set'
'pack'
'pack_forget'
'rowconfigure'
'search'
'selection_clear'
'selection_get'
'update'
'update_idletasks'
'winfo_id'
'winfo_toplevel'
'wm_iconbitmap'
'yview'</t>
<t tx="ekr.20070626112754.994">import string
import leoTkinterFrame
words = {}
word_chars = string.ascii_letters + string.digits + '_'
p = g.findTopLevelNode(c,'Code')
p1 = p.copy()
baseClass = leoTkinterFrame.leoTkTextWidget
allMatches = True
seen = {}
for p in p.self_and_subtree_iter():
    if seen.get(p.v.t): continue # search clones once.
    seen[p.v.t] = True
    s = p.bodyString()
    i = 0
    while 1:
        j = s.find('w.',i)
        if j == -1: break
        ch = s[j-1]
        if j == 0 or ch not in word_chars:
            j += 2
            k = g.skip_c_id(s,j)
            word = s[j:k]
            if allMatches or not hasattr(baseClass,word):
                words[word] = 1 + words.get(word,0)
            i = k
        else:
            i += 2
keys = words.keys()
keys.sort()
aList = ['%3d %s' % (words.get(key),str(key)) for key in keys]
print g.listToString(aList)
g.es('searched %s' % p1.headString())</t>
<t tx="ekr.20070626112754.995">if g.app.gui.guiName() != 'tkinter':
    return g.es('command not ready yet',color='blue')

# To be removed.
'  6 index' # later.  Disabled commands that use unless gui is tkinter.
'  1 flashCharacter'  # Calls wrapper function.
'  3 search' # later. Disabled commands that use this unless gui is tkinter.
'  7 tag_add' # Used by Yank.  
'  8 tag_config'
' 10 tag_delete'
'  5 tag_ranges'

# Can't be removed.
'  1 update_idletasks' # In an emergency global function. (also top.geometry)

# Ok.
'  1 bind'
' 73 delete'
'  2 deleteTextSelection'
'  1 event_generate' # ok.
' 21 get'
'123 getAllText'
' 96 getInsertPoint'
' 21 getSelectedText'
' 63 getSelectionRange'
'  1 getYScrollPosition'
' 12 hasSelection'
'  2 indexIsVisible'
' 77 insert'
'  1 rowColToGuiIndex'
'  4 see'
' 14 seeInsertPoint'
'  3 selectAllText'
' 16 setAllText'
'  2 setBackgroundColor'
' 54 setInsertPoint'
' 76 setSelectionRange'
'  4 setWidth'
'  1 setYScrollPosition'
'  7 toGuiIndex'
'  4 toPythonIndex'
'  3 xyToPythonIndex'
</t>
<t tx="ekr.20070626112754.996">@nocolor

- Moved makeScriptButton to the gui class.
  This is optional: it is not needed by the wxGui plugin.

- Removed calls to w.focus_force from move-line-up/down commands.

- Removed w.configure &amp; w.cget from Leo's core.
  This affected pasteText, cutText commands and c.setHeadString.
  ** The only remaining calls are in classes that are to be refactored into gui-dependent/independent parts.

@color</t>
<t tx="ekr.20070626112754.997"></t>
<t tx="ekr.20070626112754.998"></t>
<t tx="ekr.20070626112754.999">def copyText (self,event=None):

    '''Copy the selected text from the widget to the clipboard.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = w.getSelectionRange()
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)

OnCopyFromMenu = copyText
</t>
<t tx="ekr.20070626112754.1000">def cutText (self,event=None):

    '''Invoked from the mini-buffer and from shortcuts.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i,j = w.getSelectionRange()

    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        width = f.tree.headWidth(p=None,s=s)
        w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
</t>
<t tx="ekr.20070626112754.1001">def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    # g.trace('isText',g.app.gui.isTextWidget(w),w)
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()

    # print 'pasteText',i,j,middleButton,wname,repr(c.k.previousSelection)

    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()

    singleLine = wname.startswith('head') or wname.startswith('minibuffer')

    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)

        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.getAllText()
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                width = f.tree.headWidth(p=None,s=s)
                w.setWidth(width)
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.

    return 'break' # Essential

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20070626112754.1002">def OnPaste (self,event=None):

    return self.pasteText(event=event,middleButton=True)</t>
<t tx="ekr.20070626112754.1003"></t>
<t tx="ekr.20070626112754.1004">@

- Oh joy, tk headlines are plain text widgets!
- We can declare the colorizer to be gui-specific because it isn't used in other guis.</t>
<t tx="ekr.20070626112754.1005">def setHeadString (self,p,s,encoding="utf-8"):

    c = self
    w = c.edit_widget(p) # w only exists for the Tk gui.

    p.initHeadString(s,encoding)

    if w:
        w.setAllText(s)
        width = c.frame.tree.headWidth(p=None,s=s)
        w.setWidth(width)

    p.setDirty()</t>
<t tx="ekr.20070626112754.1006"># The minibufferFind class now calls the finder's get/set/toggle methods.</t>
<t tx="ekr.20070626112754.1007"></t>
<t tx="ekr.20070626112754.1008">def getOption (self,ivar):

    var = self.svarDict.get(ivar)

    if var:
        val = var.get()
        # g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
</t>
<t tx="ekr.20070626112754.1009">def setOption (self,ivar,val):

    if ivar in self.intKeys:
        if val is not None:
            var = self.svarDict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20070626112754.1010">def toggleOption (self,ivar):

    if ivar in self.intKeys:
        var = self.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20070626112754.1011"></t>
<t tx="ekr.20070626112754.1012">def showColors (self,event):

    '''Open a tab in the log pane showing various color pickers.'''

    c = self.c ; log = c.frame.log ; tabName = 'Colors'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createColorPicker(tabName)
</t>
<t tx="ekr.20070626112754.1013"></t>
<t tx="ekr.20070626112754.1014">def showFonts (self,event):

    '''Open a tab in the log pane showing a font picker.'''

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createFontPicker(tabName)
</t>
<t tx="ekr.20070626112754.1015"># The spellTabHandler class is now separate from the tkSpellTab class.
# Added g.app.gui.createSpellTab.</t>
<t tx="ekr.20070626112754.1016">def createSpellTab(self,c,spellHandler,tabName):

    return leoTkinterFind.tkSpellTab(c,spellHandler,tabName)
</t>
<t tx="ekr.20070626112754.1017">class spellTabHandler (leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""

    @others
</t>
<t tx="ekr.20070626112754.1018"></t>
<t tx="ekr.20070626112754.1019">def __init__(self,c,tabName):

    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = g.app.gui.plainTextWidget(c.frame.top)
        # A text widget for scanning.
        # Must have a parent frame even though it is not packed.

    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.tab = g.app.gui.createSpellTab(c,self,tabName)
</t>
<t tx="ekr.20070626112754.1020">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"..","plugins",'spellpyx.txt'))

    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)

    if self.aspell.aspell:
        self.dictionary = self.readDictionary(dictionaryFileName)
    else:
        self.dictionary = False
        # g.es_print('Can not open Aspell',color='red')

    return self.aspell.aspell
</t>
<t tx="ekr.20070626112754.1021">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary

    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""

    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
</t>
<t tx="ekr.20070626112754.1022"></t>
<t tx="ekr.20070626112754.1023">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""

    if not self.currentWord: return

    # g.trace(self.currentWord)

    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
</t>
<t tx="ekr.20070626112754.1024">def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; w = body.bodyCtrl

    selection = self.tab.getSuggestion()
    if selection:
        start,end = oldSel = w.getSelectionRange()
        if start:
            if start &gt; end: start,end = end,start
            w.delete(start,end)
            w.insert(start,selection)
            w.setSelectionRange(start,start+len(selection))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20070626112754.1025">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Copy the working selection range to the body pane
        start, end = self.workCtrl.getSelectionRange()
        w.setSelectionRange(start,end)
        w.see(start)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.1026">def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None

    try:
        while 1:
            # g.trace('p',p and p.headString())
            p, word = self.findNextWord(p)
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if alts:
                w = c.frame.body.bodyCtrl
                i,j = w.getSelectionRange()
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                w.setSelectionRange(i,j,insert=j)
                break
    except:
        g.es_exception()
    return alts, word
</t>
<t tx="ekr.20070626112754.1027">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
</t>
<t tx="ekr.20070626112754.1028">def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i &lt; len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.headString(),'i',i,'len(s)',len(s))
        if i &lt; len(s):
            # A non-empty word has been found.
            j = i
            while j &lt; len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            return p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.bodyString())
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
    return None,None</t>
<t tx="ekr.20070626112754.1029">def hide (self,event=None):

    self.c.frame.log.selectTab('Log')

    for message in self.messages:
        g.es(message,color='blue')

    self.messages = []
</t>
<t tx="ekr.20070626112754.1030">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""

    if not self.currentWord: return

    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
</t>
<t tx="ekr.20070626112754.1031">class tkSpellTab:

    @others
</t>
<t tx="ekr.20070626112754.1032">def __init__ (self,c,handler,tabName):

    self.c = c
    self.handler = handler
    self.tabName = tabName

    self.createFrame()
    self.createBindings()
    self.fillbox([])
</t>
<t tx="ekr.20070626112754.1033">def createBindings (self):

    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.handler.hide),
            ('spell-add',               self.handler.add),
            ('spell-find',              self.handler.find),
            ('spell-ignore',            self.handler.ignore),
            ('spell-change-then-find',  self.handler.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)

    self.listBox.bind("&lt;Double-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="ekr.20070626112754.1034">def createFrame (self):

    c = self.c ; log = c.frame.log ; tabName = self.tabName

    parentFrame = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'

    fontSize = g.choose(sys.platform.startswith('win'),9,14)

    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;

    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
</t>
<t tx="ekr.20070626112754.1035">self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)
</t>
<t tx="ekr.20070626112754.1036">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',fontSize,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',fontSize,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
</t>
<t tx="ekr.20070626112754.1037"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = []
font = ('verdana',fontSize,'normal')
width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
</t>
<t tx="ekr.20070626112754.1038"></t>
<t tx="ekr.20070626112754.1039">def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.handler.add()
</t>
<t tx="ekr.20070626112754.1040">def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.handler.change()
    self.updateButtons()


def onChangeThenFindButton(self,event=None):

    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.handler.change():
        self.handler.find()
    self.updateButtons()
</t>
<t tx="ekr.20070626112754.1041">def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    c = self.c
    self.handler.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.1042">def onHideButton(self):

    """Handle a click in the Hide button in the Spell tab."""

    self.handler.hide()
</t>
<t tx="ekr.20070626112754.1043">def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.handler.ignore()
</t>
<t tx="ekr.20070626112754.1044">def onMap (self, event=None):
    """Respond to a Tk &lt;Map&gt; event."""

    self.update(show= False, fill= False)
</t>
<t tx="ekr.20070626112754.1045">def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""

    c = self.c
    self.updateButtons()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.1046"></t>
<t tx="ekr.20070626112754.1047">def bringToFront (self):

    self.c.frame.log.selectTab('Spell')
</t>
<t tx="ekr.20070626112754.1048">def fillbox(self, alts, word=None):
    """Update the suggestions listBox in the Check Spelling dialog."""

    self.suggestions = alts

    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])

    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1)
</t>
<t tx="ekr.20070626112754.1049">def getSuggestion(self):
    """Return the selected suggestion from the listBox."""

    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None
</t>
<t tx="ekr.20070626112754.1050">def update(self,show=True,fill=False):

    """Update the Spell Check dialog."""

    c = self.c

    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.1051">def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c ; w = c.frame.body.bodyCtrl

    start, end = w.getSelectionRange()
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
</t>
<t tx="ekr.20070626112754.1052"></t>
<t tx="ekr.20070626112754.1053"></t>
<t tx="ekr.20070626112754.1054">def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
</t>
<t tx="ekr.20070626112754.1055">def getTextFromClipboard (self):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
</t>
<t tx="ekr.20070626112754.1056"></t>
<t tx="ekr.20070626112754.1057">def readAbbreviations (self,event):

    '''Read abbreviations from a file.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Abbreviation File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName)
        for x in f:
            a, b = x.split('=')
            b = b [:-1]
            self.abbrevs [a] = b
        f.close()
    except IOError:
        g.es('Can not open',fileName)
</t>
<t tx="ekr.20070626112754.1058">def writeAbbreviations (self,event):

    '''Write abbreviations to a file.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Write Abbreviations',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName,'w')
        for x in self.abbrevs:
            f.write('%s=%s\n' % (x,self.abbrevs[x]))
        f.close()
    except IOError:
        g.es('Can not create',fileName)
</t>
<t tx="ekr.20070626112754.1059">def getReadableTextFile (self):

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Text File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return None, None

    try:
        f = open(fileName,'rt')
        return f, fileName
    except IOError:
        g.es('Can not open',fileName)
        return None,None
</t>
<t tx="ekr.20070626112754.1060">def loadFile (self,event):

    '''Asks for a macro file name to load.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Macro File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName)
        self._loadMacros(f)
    except IOError:
        g.es('Can not open',fileName)
</t>
<t tx="ekr.20070626112754.1061">def _loadMacros (self,f):

    '''Loads a macro file into the macros dictionary.'''

    k = self.k
    macros = cPickle.load(f)
    for z in macros:
        k.addToDoAltX(z,macros[z])
</t>
<t tx="ekr.20070626112754.1062">def saveFile (self,event):

    '''Prompt for the name of a file and put the body text of the selected node into it..'''

    w = self.editWidget(event)
    if not w: return

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='save-file',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        s = w.getAllText()
        f = open(fileName,'w')
        f.write(s)
        f.close()
    except IOError:
        g.es('Can not create',fileName)
</t>
<t tx="ekr.20070626112754.1063">def saveMacros (self,event,macname):

    '''Asks for a file name and saves it.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Save Macros',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = file(fileName,'a+')
        f.seek(0)
        if f:
            self._saveMacros(f,macname)
    except IOError:
        g.es('Can not create',fileName)

</t>
<t tx="ekr.20070626112754.1064">def _saveMacros( self, f , name ):
    '''Saves the macros as a pickled dictionary'''
    import cPickle
    fname = f.name
    try:
        macs = cPickle.load( f )
    except:
        macs = {}
    f.close()
    if self.namedMacros.has_key( name ):
        macs[ name ] = self.namedMacros[ name ]
        f = file( fname, 'w' )
        cPickle.dump( macs, f )
        f.close()
</t>
<t tx="ekr.20070626112754.1065"></t>
<t tx="ekr.20070626112754.1066">def _executeMacro (self,macro,w):

    c = self.c ; k = self.k

    for z in macro:
        if len(z) == 2:
            w.event_generate('&lt;Key&gt;',keycode=z[0],keysym=z[1])
        else:
            meth = g.stripBrackets(z[0])
            bunchList = k.bindingsDict.get(meth,[]) ### Probably should not strip &lt; and &gt;
            if bunchList:
                b = bunchList [0]
                # ev = Tk.Event()
                # ev.widget = w
                # ev.keycode = z [1]
                # ev.keysym = z [2]
                # ev.char = z [3]
                event = g.Bunch(c=c,widget=w,keycode=z[1],keysym=z[2],char=z[3])
                k.masterCommand(event,b.f,'&lt;%s&gt;' % meth)
</t>
<t tx="ekr.20070626112754.1067">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info

    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass

    else: version = sys.platform

    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
    g.enl()
</t>
<t tx="ekr.20070626112754.1068">def getFullVersion (self,c):

    tkLevel = c.frame.top.getvar("tk_patchLevel")

    return 'Tk %s, Pmw %s' % (tkLevel,Pmw.version())
</t>
<t tx="ekr.20070626112754.1069"># This must be defined in leoGlobals: g.app.gui doesn't exist yet.

def createStandAloneTkApp(pluginName=''):

    '''Create a Tk version of the g.app object for 'stand-alone' plugins.'''

    if not g.app:
        # Important: these references do not make Leo's core gui-dependent.
        # In other words, this function is called only when Tkinter should be the gui.
        import Tkinter as Tk
        Pmw = g.importExtension('Pmw',pluginName=pluginName,verbose=True)
        if Tk and Pmw:
            import leoApp, leoGui
            g.app = leoApp.LeoApp()
            g.app.root = Tk.Tk()
            Pmw.initialise(g.app.root)
            g.app.gui = leoGui.nullGui('&lt;stand-alone app gui&gt;')
            g.computeStandardDirectories()
    return g.app
</t>
<t tx="ekr.20070626112754.1070">def cantImportDialog (pluginName,moduleName):

    '''Attempt to show a Tk dialog if an import fails.
    Yes, this is a small Tk dependency, but it can't be helped.'''

    message = '''
%s requires the %s module.
Official distributions contain this module in Leo's extensions folder,
but this module may be missing if you get Leo from cvs.
''' % (pluginName,moduleName)

    if 1: # Requires minimal further imports.
        try:
            import Tkinter as Tk
            root = g.app.root or Tk.Tk()
            title = 'Can not import %s' % moduleName
            top = createDialogFrame(Tk,root,title,message)
            root.wait_window(top)
        except ImportError:
            print 'Can not import %s' % moduleName
            print 'Can not import Tkinter'
            print 'Leo must now exit'

    else: # Can cause import problems during startup.
        import leoTkinterDialog

        d = leoTkinterDialog.tkinterAskOk(
            c=None,title='Can not import %s' %(moduleName),
            message=message)
        d.run(modal=True)
</t>
<t tx="ekr.20070626112754.1071">def createDialogFrame(Tk,root,title,message):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    top = Tk.Toplevel(root)
    top.title(title)

    def onKey(event,top=top):
        if event.char.lower() in ('\n','\r'):
            top.destroy()
    top.bind("&lt;Key&gt;",onKey)

    f = Tk.Frame(top)
    f.pack(side="top",expand=1,fill="both")

    label = Tk.Label(f,text=message)
    label.pack(pady=10)

    def okButton(top=top):
        top.destroy()

    buttons = {"text":'OK',"command":okButton,"default":True}, # Singleton tuple.
    createDialogButtons(Tk,top,buttons)

    center(top)
    top.lift()
    top.focus_force()

    # Attach the icon at idle time.
    def attachIconCallback(top=top):
        g.app.gui.attachLeoIcon(top)
    top.after_idle(attachIconCallback)

    return top
</t>
<t tx="ekr.20070626112754.1072">def createDialogButtons (Tk,top,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    f = Tk.Frame(top)
    f.pack(side="top",padx=30)

    for d in buttons:
        text = d.get("text","&lt;missing button name&gt;")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
</t>
<t tx="ekr.20070626112754.1073">def center(top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = g.get_window_info(top)

    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))

    return w,h,x,y
</t>
<t tx="ekr.20070626112754.1074"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (top):

    # This is an emergency measure: this call is NOT a major Tk-dependency.
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)

    return w,h,x,y
</t>
<t tx="ekr.20070626112754.1075">class leoTkTextWidget (Tk.Text):

    '''A class to wrap the Tk.Text widget.
    Translates Python (integer) indices to and from Tk (string) indices.

    This class inherits almost all tkText methods: you call use them as usual.'''

    # The signatures of tag_add and insert are different from the Tk.Text signatures.
    __pychecker__ = '--no-override' # suppress warning about changed signature.

    def __repr__(self):
        name = hasattr(self,'_name') and self._name or '&lt;no name&gt;'
        return 'leoTkTextWidget id: %s name: %s' % (id(self),name)

    @others</t>
<t tx="ekr.20070626112754.1076">if 0:
    def __init__ (self,c,*args,**keys):

        w = self

        # Create the actual gui widget.
        self.widget = Tk.Text(*args,**keys)

        # Init the base class.
        name = keys.get('name') or '&lt;unknown plainTextWidget&gt;'
        baseTextWidget.__init__(self,c=c,
            baseClassName='plainTextWidget',name=name,widget=self.widget)

        # self.defaultFont = font = wx.Font(pointSize=10,
            # family = wx.FONTFAMILY_TELETYPE, # wx.FONTFAMILY_ROMAN,
            # style  = wx.FONTSTYLE_NORMAL,
            # weight = wx.FONTWEIGHT_NORMAL,)
</t>
<t tx="ekr.20070626112754.1077"># Specify the names of widget-specific methods.
# These particular names are the names of wx.TextCtrl methods.

# def _appendText(self,s):            return self.widget.insert(s)
# def _get(self,i,j):                 return self.widget.get(i,j)
# def _getAllText(self):              return self.widget.get('1.0','end')
# def _getFocus(self):                return self.widget.focus_get()
# def _getInsertPoint(self):          return self.widget.index('insert')
# def _getLastPosition(self):         return self.widget.index('end')
# def _getSelectedText(self):         return self.widget.get('sel.start','sel.end')
# def _getSelectionRange(self):       return self.widget.index('sel.start'),self.widget.index('sel.end')
# def _hitTest(self,pos):             pass ###
# def _insertText(self,i,s):          return self.widget.insert(i,s)
# def _scrollLines(self,n):           pass ###
# def _see(self,i):                   return self.widget.see(i)
# def _setAllText(self,s):            self.widget.delete('1.0','end') ; self.widget.insert('1.0',s)
# def _setBackgroundColor(self,color): return self.widget.configure(background=color)
# def _setFocus(self):                return self.widget.focus_set()
# def _setInsertPoint(self,i):        return self.widget.mark_set('insert',i)
# # def _setSelectionRange(self,i,j):   return self.widget.SetSelection(i,j)
</t>
<t tx="ekr.20070626112754.1078">def getName (self):

    w = self
    return hasattr(w,'_name') and w._name or repr(w)</t>
<t tx="ekr.20070626112754.1079">if 0:
    def _setSelectionRange (self,i,j,insert=None):

        w = self.widget

        i,j = w.toGuiIndex(i),w.toGuiIndex(j)

        # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())

        # g.trace('i,j,insert',i,j,repr(insert))
        if w.compare(w,i, "&gt;", j): i,j = j,i
        w.tag_remove(w,"sel","1.0",i)
        w.tag_add(w,"sel",i,j)
        w.tag_remove(w,"sel",j,"end")

        if insert is not None:
            w.setInsertPoint(insert)
</t>
<t tx="ekr.20070626112754.1080"></t>
<t tx="ekr.20070626112754.1081">def delete(self,i,j=None):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.delete(w,i)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.delete(w,i,j)
</t>
<t tx="ekr.20070626112754.1082">def get(self,i,j=None):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        return Tk.Text.get(w,i)
    else:
        j = w.toGuiIndex(j)
        return Tk.Text.get(w,i,j)
</t>
<t tx="ekr.20070626112754.1083">def getAllText (self): # tkTextWidget.

    """Return all the text of Tk.Text widget w converted to unicode."""

    w = self
    s = Tk.Text.get(w,"1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.1084">def getInsertPoint(self): # tkTextWidget.

    w = self
    i = Tk.Text.index(w,'insert')
    i = w.toPythonIndex(i)
    return i
</t>
<t tx="ekr.20070626112754.1085">def getSelectedText (self): # tkTextWidget.

    w = self
    i,j = w.getSelectionRange()
    if i != j:
        i,j = w.toGuiIndex(i),w.toGuiIndex(j)
        s = Tk.Text.get(w,i,j)
        return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""
</t>
<t tx="ekr.20070626112754.1086">def getSelectionRange (self,sort=True): # tkTextWidget.

    """Return a tuple representing the selected range.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self
    sel = Tk.Text.tag_ranges(w,"sel")
    if len(sel) == 2:
        i,j = sel
    else:
        i = j = Tk.Text.index(w,"insert")

    i,j = w.toPythonIndex(i),w.toPythonIndex(j)  
    if sort and i &gt; j: i,j = j,i
    return i,j</t>
<t tx="ekr.20070626112754.1087">def getYScrollPosition (self):

     w = self
     return w.yview()
</t>
<t tx="ekr.20070626112754.1088">def getWidth (self):

    '''Return the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    return w.cget('width')
</t>
<t tx="ekr.20070626112754.1089">def hasSelection (self):

    w = self
    i,j = w.getSelectionRange()
    return i != j
</t>
<t tx="ekr.20070626112754.1090"># The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toGuiIndex(i)
    Tk.Text.insert(w,i,s)

</t>
<t tx="ekr.20070626112754.1091">def indexIsVisible (self,i):

    w = self

    return w.dlineinfo(i)</t>
<t tx="ekr.20070626112754.1092"># def mark_set(self,markName,i):

    # w = self
    # i = w.toGuiIndex(i)
    # Tk.Text.mark_set(w,markName,i)
</t>
<t tx="ekr.20070626112754.1093">def replace (self,i,j,s): # tkTextWidget

    w = self
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    Tk.Text.delete(w,i,j)
    Tk.Text.insert(w,i,s)
</t>
<t tx="ekr.20070626112754.1094">def see (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    Tk.Text.see(w,i)
</t>
<t tx="ekr.20070626112754.1095">def seeInsertPoint (self): # tkTextWidget.

    w = self
    Tk.Text.see(w,'insert')
</t>
<t tx="ekr.20070626112754.1096">def setAllText (self,s): # tkTextWidget

    w = self

    state = Tk.Text.cget(w,"state")
    Tk.Text.configure(w,state="normal")

    Tk.Text.delete(w,'1.0','end')
    Tk.Text.insert(w,'1.0',s)

    Tk.Text.configure(w,state=state)
</t>
<t tx="ekr.20070626112754.1097">def setBackgroundColor (self,color):

    w = self
    w.configure(background=color)</t>
<t tx="ekr.20070626112754.1098">def setYScrollPosition (self,i):

     w = self
     w.yview('moveto',i)</t>
<t tx="ekr.20070626112754.1099">def setWidth (self,width):

    '''Set the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    w.configure(width=width)
</t>
<t tx="ekr.20070626112754.1100">def tag_ranges(self,tagName):

    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
</t>
<t tx="ekr.20070626112754.1101">def tag_remove (self,tagName,i,j=None,*args):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.tag_remove(w,tagName,i,*args)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.tag_remove(w,tagName,i,j,*args)


</t>
<t tx="ekr.20070626112754.1102">def deleteTextSelection (self): # tkTextWidget

    w = self
    sel = Tk.Text.tag_ranges(w,"sel")
    if len(sel) == 2:
        start,end = sel
        if Tk.Text.compare(w,start,"!=",end):
            Tk.Text.delete(w,start,end)
</t>
<t tx="ekr.20070626112754.1103">def xyToGuiIndex (self,x,y): # tkTextWidget

    w = self
    return Tk.Text.index(w,"@%d,%d" % (x,y))

def xyToPythonIndex(self,x,y): # tkTextWidget

    w = self
    i = Tk.Text.index(w,"@%d,%d" % (x,y))
    i = w.toPythonIndex(i)
    return i
</t>
<t tx="ekr.20070626112754.1104"></t>
<t tx="ekr.20070626112754.1105"># Indices of the form %s.%s are benign because of w.rowColToGuiIndex.
</t>
<t tx="ekr.20070626112754.1106">def moveLinesUp (self,event):

    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i &gt; 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            s = w.getAllText()
            if not s.endswith('\n'): w.insert('end','\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20070626112754.1107">def moveLinesDown (self,event):

    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j &lt; len(s):
            next_i,next_j = g.getLine(s,j+1)
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20070626112754.1108">def fillRegion (self,event):

    '''Fill all paragraphs in the selected text.'''
    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='fill-region')

    s = w.getAllText()
    s1,s2 = w.getSelectionRange()
    w.setInsertPoint(s1)
    self.backwardParagraph(event)
    i = w.getInsertPoint()
    i,junk = g.getLine(s,i)
    if i == 0:
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.getInsertPoint() &gt; s2:
            break
        self.fillParagraph(event)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1109">def fillRegionAsParagraph (self,event):

    '''Fill the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='fill-region-as-paragraph')

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1110">def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward ; self.extend = extend ;
        self.insert = w.getInsertPoint()
        s = '%s character %s' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' &amp; extend',''))
        c.frame.clearStatusLine()
        c.frame.putStatusLine(s,color='blue')
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j &gt; -1: self.moveToHelper(event,j,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j &gt; -1: self.moveToHelper(event,j,extend)
        c.frame.clearStatusLine()
        k.clearState()</t>
<t tx="ekr.20070626112754.1111">def getRectanglePoints (self,w):

    c = self.c
    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    r1,r2 = g.convertPythonIndexToRowCol(s,i)
    r3,r4 = g.convertPythonIndexToRowCol(s,j)

    return r1+1,r2,r3+1,r4
</t>
<t tx="ekr.20070626112754.1112">def lineNumber (self,event):

    '''Print the line and column number and percentage of insert point.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)
    percent = int((i*100)/len(s))

    k.setLabelGrey(
        'char: %s row: %d col: %d pos: %d (%d%% of %d)' % (
            repr(s[i]),row,col,i,percent,len(s)))
</t>
<t tx="ekr.20070626112754.1113">def measure (self,w):

    s = w.getAllText()
    ins = w.getInsertPoint()
    start, junk = g.convertPythonIndexToRowCol(s,ins)
    start += 1 ; delta = 0

    ustart = start - 1
    while ustart &gt;= 1 and w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart -= 1

    ustart = start + 1
    while w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart += 1

    return delta
</t>
<t tx="ekr.20070626112754.1114">def setCommentColumn (self,event):

    '''Set the comment column for the indent-to-comment-column command.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,ins)
    self.ccolumn = col</t>
<t tx="ekr.20070626112754.1115">def shellCommandOnRegion (self,event):

    '''Execute a command taken from the selected text in a separate process.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if subprocess:
        if w.hasSelection():
            command = w.getSelectedText()
            k.commandName = 'shell-command: %s' % command
            self.executeSubprocess(event,command,input=None)
        else:
            k.clearState()
            k.resetLabel()
    else:
        k.setLabelGrey('can not execute shell-command: can not import subprocess')
</t>
<t tx="ekr.20070626112754.1116">def sortFields (self,event,which=None):

    '''Divide the selected text into lines and sort by comparing the contents of
     one field in each line. Fields are defined as separated by whitespace, so
     the first run of consecutive non-whitespace characters in a line
     constitutes field 1, the second such run constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to sort by
     field 1, etc. A negative argument means sort in descending order. Thus,
     minus 2 means sort by field 2 in reverse-alphabetical order.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')

    s = w.getAllText()
    ins = w.getInsertPoint()
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    i,junk = g.getLine(s,r1)
    junk,j = g.getLine(s,r4)
    txt = s[i:j] # bug reported by pychecker.
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for line in txt:
        f = frx.findall(line)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) &lt; i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    #w.delete('%s linestart' % is1,'%s lineend' % is2)
    w.delete(i,j)
    #i = is1.split('.')
    #int1 = int(i[0])
    int1 = i
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.setInsertPoint(ins)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1117">def swapWords (self,event,swapspots):

    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('swap-words command not ready yet',color='blue')

    s = w.getAllText()

    txt = w.get('insert wordstart','insert wordend') ###
    if not txt: return

    i = w.index('insert wordstart') ###

    self.beginCommand(undoType='swap-words')

    if len(swapspots):
        if i &gt; swapspots[1]:
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif i &lt; swapspots[1]:
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1118">def whatLine (self,event):

    '''Print the line number of the line containing the cursor.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)

    k.keyboardQuit(event)
    k.setLabel("Line %s" % row)
</t>
<t tx="ekr.20070626112754.1119"></t>
<t tx="ekr.20070626112754.1120"></t>
<t tx="ekr.20070626112754.1121">class autoCompleterClass:

    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
</t>
<t tx="ekr.20070626112754.1122">def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.object = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
</t>
<t tx="ekr.20070626112754.1123">def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('&lt;class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z

    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
</t>
<t tx="ekr.20070626112754.1124">def defineObjectDict (self):

    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p),             
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if obj:
                self.objectDict[z]=obj
</t>
<t tx="ekr.20070626112754.1125"></t>
<t tx="ekr.20070626112754.1126">def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    # Don't allow autocompletion in headlines.
    if not c.widget_name(w).startswith('head'):
        self.language = g.scanForAtLanguage(c,c.currentPosition())
        if w and self.language == 'python' and (k.enable_autocompleter or force):
            self.start(event=event,w=w)

    return 'break'
</t>
<t tx="ekr.20070626112754.1127">def autoCompleteForce (self,event=None):

    '''Show autocompletion, even if autocompletion is not presently enabled.'''

    return self.autoComplete(event,force=True)
</t>
<t tx="ekr.20070626112754.1128">def autoCompleterStateHandler (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.object) == types.DictType:
            self.membersList = self.object.keys()
        elif type(self.object) in (types.ListType,types.TupleType):
            self.membersList = self.object
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
</t>
<t tx="ekr.20070626112754.1129">def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()

def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()

def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
</t>
<t tx="ekr.20070626112754.1130">def showCalltips (self,event=None,force=False):

    '''Show the calltips at the cursor.'''

    c = self.c ; k = c.k ; w = g.app.gui.eventWidget(event)
    if not w: return

    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        self.leadinWord = self.findCalltipWord(w)
        # g.trace(self.leadinWord)
        self.object = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)

    return 'break'
</t>
<t tx="ekr.20070626112754.1131">def showCalltipsForce (self,event=None):

    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''

    return self.showCalltips(event,force=True)
</t>
<t tx="ekr.20070626112754.1132">def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''

    k = self.k
    g.es('Autocompleter %s' % (g.choose(k.enable_autocompleter,'On','Off')),color='red')

def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    g.es('Calltips %s' % (g.choose(k.enable_calltips,'On','Off')),color='red')</t>
<t tx="ekr.20070626112754.1133"></t>
<t tx="ekr.20070626112754.1134">def abort (self):

    k = self.k
    k.keyboardQuit(event=None)
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.

    k = self ; c = self.c 
    w = self.widget or c.frame.body.bodyCtrl
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    if restore:
        if i != j: w.delete(i,j)
        w.insert(i,self.selectedText)
    w.setSelectionRange(j,j,insert=j)

    self.clear()
    self.object = None
</t>
<t tx="ekr.20070626112754.1135">def appendTabName (self,word):

    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')

def clearTabName (self):

    self.setTabName('AutoComplete ')

def popTabName (self):

    s = self.tabName
    i = s.rfind('.',0,-1)
    if i &gt; -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_','') or ''
    c.frame.log.clearTab(self.tabName)
</t>
<t tx="ekr.20070626112754.1136">def appendToKnownObjects (self,obj):

    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
</t>
<t tx="ekr.20070626112754.1137">def calltip (self,obj=None):

    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        &lt;&lt; try to set s from a Python global function &gt;&gt;

    if not s:
        &lt;&lt; get s using inspect &gt;&gt;

    &lt;&lt; remove 'self' from s, but not from args &gt;&gt;
    if isStringMethod:
        &lt;&lt; remove 's' from s *and* args &gt;&gt;

    s = s.rstrip(')') # Convenient.
    &lt;&lt; insert the text and set j1 and j2 &gt;&gt;

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    &lt;&lt; put the status line &gt;&gt;
</t>
<t tx="ekr.20070626112754.1138"># The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i &gt; -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
</t>
<t tx="ekr.20070626112754.1139">isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    # g.es('inspect failed:',repr(obj))
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
</t>
<t tx="ekr.20070626112754.1140">if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
</t>
<t tx="ekr.20070626112754.1141">if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
</t>
<t tx="ekr.20070626112754.1142">junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
</t>
<t tx="ekr.20070626112754.1143">c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
</t>
<t tx="ekr.20070626112754.1144">def chain (self):

    c = self.c ; w = self.widget
    word = w.getSelectedText()
    old_obj = self.object

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.object = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.object = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = w.getInsertPoint()
        w.setSelectionRange(i,i,insert=i)
        # g.trace('chaining to',word,self.object)
        # Similar to start logic.
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
</t>
<t tx="ekr.20070626112754.1145">def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) &lt; 25:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in d.keys()] ; aList.sort()
            self.tabList = aList

    c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
    if self.tabList:
        self.tabListIndex = -1 # The next item will be item 0.
        self.setSelection(common_prefix)
    for name in self.tabList:
        g.es('%s' % (name),tabName=self.tabName)
</t>
<t tx="ekr.20070626112754.1146">def doBackSpace (self):

    '''Cut back to previous prefix.'''

    # g.trace(self.prefix,self.object,self.prevObjects)

    c = self.c
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.object:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.object
        # g.trace(self.object,obj)
        w = self.widget
        s = w.getAllText()
        i,junk = w.getSelectionRange()
        ch = 0 &lt;= i-1 &lt; len(s) and s[i-1] or ''
        # g.trace(ch)
        if ch == '.':
            self.object = obj
            w.delete(i-1)
            c.frame.body.onBodyChanged(undoType='Typing')
            i,j = g.getWord(s,i-2)
            word = s[i:j]
            # g.trace(i,j,repr(word))
            w.setSelectionRange(i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()            </t>
<t tx="ekr.20070626112754.1147">def doTabCompletion (self):

    '''Handle tab completion when the user hits a tab.'''

    c = self.c ; w = self.widget
    s = w.getSelectedText()

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex &gt;= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20070626112754.1148">def extendSelection (self,s):

    '''Append s to the presently selected text.'''

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    i,j = w.getSelectionRange()
    w.insert(j,s)
    j += 1
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')</t>
<t tx="ekr.20070626112754.1149">def findAnchor (self,w):

    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    while i &gt; 0 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None

    # g.trace(i,j,repr(word))
    return j,word</t>
<t tx="ekr.20070626112754.1150">def findCalltipWord (self,w):

    i = w.getInsertPoint()
    s = w.getAllText()
    if i &gt; 0:
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        return word
    else:
        return ''</t>
<t tx="ekr.20070626112754.1151">def finish (self):

    c = self.c ; k = self.k

    k.keyboardQuit(event=None)

    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)

    c.frame.body.onBodyChanged('Typing')
    c.recolor()
    self.clear()
    self.object = None
</t>
<t tx="ekr.20070626112754.1152"># The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):

    '''Simulate getattr function, regardless of langauge.'''

    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):

    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList
</t>
<t tx="ekr.20070626112754.1153">def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.object,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.object:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 &lt;= i &lt; start and i &lt;len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.object:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
</t>
<t tx="ekr.20070626112754.1154">def getMembersList (self,obj):

    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
</t>
<t tx="ekr.20070626112754.1155">def info (self):

    c = self.c ; doc = None ; obj = self.object ; w = self.widget

    word = w.getSelectedText()

    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word): return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es(doc,tabName='Info')
</t>
<t tx="ekr.20070626112754.1156">def insertNormalChar (self,ch,keysym):

    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = w.getSelectedText() + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = w.getSelectedText()
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = w.getSelectedText()
        if ch == '(':
            # Similar to chain logic.
            obj = self.object
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.object)
                self.object = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
</t>
<t tx="ekr.20070626112754.1157">def push (self,obj):

    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())

def pop (self):

    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj

def clear (self):

    self.prevObjects = []
    # g.trace(g.callers())

def stackNames (self):

    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList
</t>
<t tx="ekr.20070626112754.1158">def setObjectAndMembersList (self,word):

    c = self.c

    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.object = sys.modules
        self.membersList = sys.modules.keys()
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.object)
        self.object = 'aString'
        self.membersList = self.getMembersList(self.object)
    elif self.object:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.object,len(self.membersList))
</t>
<t tx="ekr.20070626112754.1159">def getObjectFromAttribute (self,word):

    obj = self.object

    if obj and self.hasAttr(obj,word):
        self.push(self.object)
        self.object = self.getAttr(obj,word)
        self.appendToKnownObjects(self.object)
        self.membersList = self.getMembersList(self.object)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.object = None
</t>
<t tx="ekr.20070626112754.1160">def completeSelf (self):

    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.selfClassName = className
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.object = None
        self.clear()
        self.membersList = []
</t>
<t tx="ekr.20070626112754.1161">def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.object = None
        self.clear()
        self.membersList = []
</t>
<t tx="ekr.20070626112754.1162">def setSelection (self,s):

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
    else:
        i = w.getInsertPoint()

    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n &gt; -1: s = s[:n]

    w.insert(i,s)
    j = i + len(s)
    w.setSelectionRange(i,j,insert=j)

    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
</t>
<t tx="ekr.20070626112754.1163">def start (self,event=None,w=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = ''
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i &gt; 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        self.autoCompleterStateHandler(event)
    else:
        self.abort()
</t>
<t tx="ekr.20070626112754.1164"># Not used at present, but soon.
</t>
<t tx="ekr.20070626112754.1165"># Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):

    g.trace(g.callers())

    self.scan(thread=True)
</t>
<t tx="ekr.20070626112754.1166">def scan (self,event=None,verbose=True,thread=True):

    __pychecker__ = '--no-argsused' # thread arg not used at present.

    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return

    # g.trace('autocompleter')

    if 0: # thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)

        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)
</t>
<t tx="ekr.20070626112754.1167">def definePatterns (self):

    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))

    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars </t>
<t tx="ekr.20070626112754.1168">def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''

    if verbose: g.es_print('Scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.headString())
        s = p.bodyString()
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        keys = self.watchwords.keys() ; keys.sort()
        for key in keys:
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        keys = self.calltips.keys() ; keys.sort()
        for key in keys:
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))

    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')
</t>
<t tx="ekr.20070626112754.1169">def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')

    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, junk = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList

    self.calltips [language] = d
</t>
<t tx="ekr.20070626112754.1170">def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')

    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i &lt; n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z
</t>
<t tx="ekr.20070626112754.1171">def makeAutocompletionList (self,a,b,glist):

    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''

    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i &gt;= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a

        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)

        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b
</t>
<t tx="ekr.20070626112754.1172">def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i &gt;= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s
</t>
<t tx="ekr.20070626112754.1173">def getCleanString (self,s):

    '''Return the prefix of s containing only chars in okchars.'''

    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s
</t>
<t tx="ekr.20070626112754.1174"></t>
<t tx="ekr.20070626112754.1175">def createProxyObjectFromClass (self,className,theClass):

    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in xrange(n)]

    def dummyCtor (self):
        pass

    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')

    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
</t>
<t tx="ekr.20070626112754.1176">def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec s

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in computeProxyObject')
            g.es_exception()
        return None
</t>
<t tx="ekr.20070626112754.1177">class forgivingParserClass:

    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''

    @others
</t>
<t tx="ekr.20070626112754.1178">def __init__ (self,c):

    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
</t>
<t tx="ekr.20070626112754.1179">def parse (self,p):

    '''The top-level parser method.

    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''

    c = self.c

    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody

    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody

    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody

    return s # Bug fix: 4/29/07: Don't put a return in a finally clause.


</t>
<t tx="ekr.20070626112754.1180">def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('Syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('Syntax error: deleting %s' % p.headString())
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''
</t>
<t tx="ekr.20070626112754.1181">def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n &gt;= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None
</t>
<t tx="ekr.20070626112754.1182">def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.headString())
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
</t>
<t tx="ekr.20070626112754.1183">class classScannerClass:

    '''A class to find class definitions in a node or its parents.'''

    @others
</t>
<t tx="ekr.20070626112754.1184">def __init__ (self,c):

    self.c = c

    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
</t>
<t tx="ekr.20070626112754.1185">def scan (self):

    c = self.c

    className,obj,p = self.findParentClass(c.currentPosition())
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None

    return className,obj,p,s
</t>
<t tx="ekr.20070626112754.1186">def findParentClass (self,root):

    autoCompleter = self.c.k.autoCompleter

    # First, see if any parent has already been scanned.
    for p in root.self_and_parents_iter():
        obj = autoCompleter.selfTnodesDict.get(p.v.t)
        if obj:
            # g.trace('found',obj,'in',p.headString())
            return None,obj,p

    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.headString())
            return className,None,p

    return None,None,None
</t>
<t tx="ekr.20070626112754.1187">def findClass (self,p):

    lines = g.splitLines(p.bodyString())
    inDoc = self.start_in_doc
    # g.trace(p.headString())
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
</t>
<t tx="ekr.20070626112754.1188">def endsDoc (self,s):

    return s.startswith('@c')
</t>
<t tx="ekr.20070626112754.1189">def startsClass (self,s):

    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
</t>
<t tx="ekr.20070626112754.1190">def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
</t>
<t tx="ekr.20070626112754.1191">def dynamicExpansion (self,event=None):

    '''Expand the word in the buffer before point as a dynamic abbrev,
    by searching in the buffer for words starting with that abbreviation (dabbrev-expand).
    This corresponds to M-/ in Emacs.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() not in ('null','tkinter'):
        return g.es('command not ready yet',color='blue')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    txt = w.get(i,j)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    if not rlist: return
    prefix = reduce(g.longestCommonPrefix,rlist)
    if prefix and prefix != txt:
        w.delete(i,j)
        w.insert(i,prefix)
    else:
        self.dynamicExpandHelper(prefix,rlist,w)
</t>
<t tx="ekr.20070626112754.1192">def dynamicExpandHelper (self,prefix=None,rlist=None,w=None):

    k = self.k ; tag = 'dabbrev-expand'
    state = k.getState(tag)

    if state == 0:
        self.w = w
        names = rlist ; event = None
        prefix2 = 'dabbrev-expand: '
        k.setLabelBlue(prefix2+prefix,protect=True)
        k.getArg(event,tag,1,self.dynamicExpandHelper,prefix=prefix2,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            w = self.w
            s = w.getAllText()
            ins = w.getInsertPoint()
            i,j = g.getWord(s,ins)
            w.delete(i,j)
            w.insert(i,k.arg)

</t>
<t tx="ekr.20070626112754.1193">def dynamicCompletion (self,event=None):

    '''Insert the common prefix of all dynamic abbrev's matching the present word.
    This corresponds to C-M-/ in Emacs.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    txt = w.get(i,j)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    if rlist:
        prefix = reduce(g.longestCommonPrefix,rlist)
        if prefix:
            w.delete(i,j)
            w.insert(i,prefix)
</t>
<t tx="ekr.20070626112754.1194">def executeSubprocess (self,event,command,input):

    '''Execute a command in a separate process.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    k.setLabelBlue('started  shell-command: %s' % command)
    try:
        ofile = os.tmpfile()
        efile = os.tmpfile()
        process = subprocess.Popen(command,bufsize=-1,
            stdout = ofile.fileno(), stderr = ofile.fileno(),
            stdin = subprocess.PIPE, shell = True)
        if input: process.communicate(input)
        process.wait()
        efile.seek(0)
        errinfo = efile.read()
        if errinfo: w.insert('insert',errinfo)
        ofile.seek(0)
        okout = ofile.read()
        if okout: w.insert('insert',okout)
    except Exception, x:
        w.insert('insert',x)

    k.setLabelGrey('finished shell-command: %s' % command)
</t>
<t tx="ekr.20070626112754.1195">def insertRegister (self,event):

    '''Prompt for a register name and and insert the value of another register into its contents.'''

    c = self.c ; k = self.k ; state = k.getState('insert-reg')

    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ',protect=True)
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.rectangleCommands.yankRectangle(val)
                else:
                    w.insert('insert',val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.1196">def insertToBuffer (self,event):

    '''Add the selected body text at the insert point of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Insert to buffer: ')
    self.getBufferName(self.insertToBufferFinisher)

def insertToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
            self.beginCommand('insert-to-buffer: %s' % p.headString())
            i = w.getInsertPoint()
            w.insert(i,s)
            w.seeInsertPoint()
            self.endCommand()
        finally:
            c.endUpdate()
</t>
<t tx="ekr.20070626112754.1197">def prependToBuffer (self,event):

    '''Add the selected body text to the start of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Prepend to buffer: ')
    self.getBufferName(self.prependToBufferFinisher)

def prependToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
            self.beginCommand('prepend-to-buffer: %s' % p.headString())
            w.insert(0,s)
            w.setInsertPoint(0)
            w.seeInsertPoint()
            self.endCommand()
        finally:
            c.endUpdate()
            c.recolor_now()

</t>
<t tx="ekr.20070626112754.1198">def doOneReplace (self,event):

    w = self.editWidget(event)
    if not w: return

    i = w.tag_ranges('qR')
    w.delete(i[0],i[1])
    w.insert('insert',self.qR)
    self.replaced += 1
</t>
<t tx="ekr.20070626112754.1199">def findNextMatch (self,event):

    '''Find the next match and select it.
    Return True if a match was found.
    Otherwise, call quitSearch and return False.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    w.tag_delete('qR')
    if self.regexp:
        &lt;&lt; handle regexp &gt;&gt;
    else:
        &lt;&lt; handle plain search &gt;&gt;
</t>
<t tx="ekr.20070626112754.1200">try:
    regex = re.compile(self.qQ)
except:
    self.quitSearch(event,'Illegal regular expression')
    return False

txt = w.get('insert','end')
match = regex.search(txt)

if match:
    start = match.start()
    end = match.end()
    length = end - start
    i = w.getInsertPoint()
    w.setInsertPoint(i+start)
    w.tag_add('qR','insert','insert +%sc' % length)
    w.tag_config('qR',background='lightblue')
    txt = w.get('insert','insert +%sc' % length)
    return True
else:
    self.quitSearch(event)
    return False
</t>
<t tx="ekr.20070626112754.1201">i = w.search(self.qQ,'insert',stopindex='end')

if i:
    w.setInsertPoint(i)
    w.tag_add('qR','insert','insert +%sc' % len(self.qQ))
    w.tag_config('qR',background='lightblue')
    return True
else:
    self.quitSearch(event)
    return False
</t>
<t tx="ekr.20070626112754.1202">def regionalExpandAbbrev (self,event):

    '''Exapand abbreviations throughout a region.'''

    k = self.k ; w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    i1,i2 = w.getSelectionRange()
    ins = w.getInsertPoint()
    &lt;&lt; define a new generator searchXR &gt;&gt;

    # EKR: the 'result' of calling searchXR is a generator object.
    k.regx.iter = searchXR(i1,i2,ins,event)
    k.regx.iter.next() # Call it the first time.</t>
<t tx="ekr.20070626112754.1203">@ This is a generator (it contains a yield).
To make this work we must define a new generator for each call to regionalExpandAbbrev.
@c
def searchXR (i1,i2,ins,event):
    k = self.k
    w = self.editWidget(event)
    if not w: return

    w.tag_add('sXR',i1,i2)
    while i1:
        tr = w.tag_ranges('sXR')
        if not tr: break
        i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        if i1:
            word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            w.tag_delete('found')
            w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            w.tag_config('found',background='yellow')
            if self.abbrevs.has_key(word):
                k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                yield None
                if k.regXKey == 'y':
                    ind = w.index('%s wordstart' % i1)
                    w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    w.insert(ind,self.abbrevs[word])
            i1 = '%s wordend' % i1
    w.setInsertPoint(ins,ins,insert=ins)
    w.tag_delete('sXR')
    w.tag_delete('found')
    k.setLabelGrey('')
    self.k.regx = g.bunch(iter=None,key=None)
</t>
<t tx="ekr.20070626112754.1204">'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
</t>
<t tx="ekr.20070626112754.1205">def sortLines (self,event,which=None):

    '''Sort lines of the selected text by comparing the entire text of a line.
    A prefix argument means sort in descending order.'''

    c = self.c ; k = c.k
    w = self.editWidget(event)
    if not self._chckSel(event): return

    self.beginCommand(undoType='sort-lines')
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        aList = g.splitLines(s[i:j])
        aList.sort()
        if which: aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1206">def sortColumns (self,event):

    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not self._chckSel(event): return
    self.beginCommand(undoType='sort-columns')
    try:
        s = w.getAllText()
        ins = w.getInsertPoint()
        sel_1,sel_2 = w.getSelectionRange()
        sint1,sint2 = g.convertPythonIndexToRowCol(s,sel_1)
        sint3,sint4 = g.convertPythonIndexToRowCol(s,sel_2)
        sint1 += 1 ; sint3 += 1
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        txt = s[i:j]
        columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
            for z in xrange(sint1,sint3+1)]
        aList = g.splitLines(txt)
        zlist = zip(columns,aList)
        zlist.sort()
        s = g.joinLines([z[1] for z in zlist])
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_1+len(s),insert=sel_1+len(s))
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1207"></t>
<t tx="ekr.20070626112754.1208">@
At present the only colorizer is only used in by the Tk gui.
There will be no need to deal with this unless a new gui plugin uses the old colorizer.</t>
<t tx="ekr.20070626112754.1209">def setFontFromConfig (self):

    c = self.c

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.bold_font:
        self.bold_font.configure(weight="bold")

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.italic_font:
        self.italic_font.configure(slant="italic",weight="normal")

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.bolditalic_font:
        self.bolditalic_font.configure(weight="bold",slant="italic")

    self.color_tags_list = []
    self.image_references = []
</t>
<t tx="ekr.20070626112754.1210">def removeAllImages (self):

    for photo,image,line_index,i in self.image_references:
        try:
            ### self.body.deleteCharacter(image)
            s = self.allBodyText
            w = self.body.bodyCtrl
            index = g.convertRowColToPythonIndex(s,line_index,i)
            w.delete(index)
            self.allBodyText = w.getAllText()
        except:
            pass # The image may have been deleted earlier.

    self.image_references = []
</t>
<t tx="ekr.20070626112754.1211"></t>
<t tx="ekr.20070626112754.1212">def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    # g.trace('c',self.c)

    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        if sys.platform == 'darwin':
            &lt;&lt; clear accelerator if it is a plain key &gt;&gt;
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
</t>
<t tx="ekr.20070626112754.1213">if type(data) == type(''):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&amp;','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data</t>
<t tx="ekr.20070626112754.1214"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
</t>
<t tx="ekr.20070626112754.1215">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
</t>
<t tx="ekr.20070626112754.1216">for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
</t>
<t tx="ekr.20070626112754.1217"></t>
<t tx="ekr.20070626112754.1218">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''

    # pychecker complains about initAllEditCommanders.

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # print 'endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers()
            k.newMinibufferWidget = None
</t>
<t tx="ekr.20070626112754.1219">def event_generate(self,w,kind,*args,**keys):
    '''Generate an event.'''
    return w.event_generate(kind,*args,**keys)

def eventChar (self,event,c=None):
    '''Return the char field of an event.'''
    return event and event.char or ''

def eventKeysym (self,event,c=None):
    '''Return the keysym value of an event.'''
    return event and event.keysym

def eventWidget (self,event,c=None):
    '''Return the widget field of an event.'''   
    return event and event.widget

def eventXY (self,event,c=None):
    if event:
        return event.x,event.y
    else:
        return 0,0</t>
<t tx="ekr.20070626112754.1220">def manufactureKeyPressForCommandName (self,w,commandName):

    '''Implement a command by passing a keypress to Tkinter.'''

    k = self ; c = k.c

    stroke = k.getShortcutForCommandName(commandName)

    if stroke and w:
        # g.trace(stroke)
        g.app.gui.event_generate(w,stroke)
    else:
        g.trace('no shortcut for %s' % (commandName),color='red')
</t>
<t tx="ekr.20070626112754.1221"></t>
<t tx="ekr.20070626112754.1222">def masterClickHandler (self,event,func=None):

    k = self ; c = k.c ; gui = g.app.gui
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = not g.app.unitTesting and (False or k.trace_masterClickHandler)

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1

    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        c.frame.body.onClick(event) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x,y = gui.eventXY(event)
        x = w.xyToPythonIndex(x,y)
        i,j = k.getEditableTextRange()
        if i &lt;= x &lt;= j:
            w.setSelectionRange(x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'
    if event and func:
        if trace: g.trace(func.__name__)
        val = func(event) # Don't even *think* of overriding this.
        c.masterFocusHandler()
        if trace: g.trace('val:',val,g.callers())
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
</t>
<t tx="ekr.20070626112754.1223">def masterDoubleClickHandler (self,event,func=None):

    k = self ; c = k.c ; w = event and event.widget

    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        gui = g.app.gui
        x,y = gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        s = w.getAllText()
        start,end = g.getWord(s,i)
        w.setSelectionRange(start,end)
        return 'break'
</t>
<t tx="ekr.20070626112754.1224">def masterMenuHandler (self,stroke,func,commandName):

    k = self ; c = k.c ; w = c.frame.getFocus()

    # g.trace('stroke',stroke,'func',func and func.__name__,commandName,g.callers())

    # Create a minimal event for commands that require them.
    event = g.Bunch(c=c,char='',keysym='',widget=w)

    if stroke:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
</t>
<t tx="ekr.20070626112754.1225">def OnBodyClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyclick1",c=c,p=p,v=p,event=event):
            self.OnActivateBody(event=event)
        g.doHook("bodyclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyrclick1",c=c,p=p,v=p,event=event):
            pass # By default Leo does nothing.
        g.doHook("bodyrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
</t>
<t tx="ekr.20070626112754.1226">def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c
    trace = not g.app.unitTesting and (False or self.trace_edit)

    if p and p != self.editPosition():

        if trace:
            g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(True)

    self.setEditPosition(p) # That is, self._editPosition = p

    if trace: g.trace(c.edit_widget(p))

    if p and c.edit_widget(p):
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
</t>
<t tx="ekr.20070626112754.1227"></t>
<t tx="ekr.20070626112754.1228"></t>
<t tx="ekr.20070626112754.1229">@ 

- It is True by default. In effect, this setting was False in previous versions
of Leo, which might be considered a bug.

- Fixed docs.</t>
<t tx="ekr.20070626112754.1230"># oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    at = self

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.bodyString())

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    if self.write_strips_blank_lines:
        s = self.cleanLines(p,s)
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        kind = at.directiveKind4(s,i)
        &lt;&lt; handle line at s[i] &gt;&gt;
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
</t>
<t tx="ekr.20070626112754.1231">@

If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if (at.sentinels or at.force_newlines_in_at_nosent_bodies) and not trailingNewlineFlag:
        # g.trace('Added newline',repr(s))
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
</t>
<t tx="ekr.20070626112754.1232">if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    # g.trace('miscDirective')
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
</t>
<t tx="ekr.20070626112754.1233">def putCodeLine (self,s,i):

    """Put a normal code line."""

    at = self

    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.trace('atRaw',at.raw,'line',repr(line),g.callers(4))

    if self.write_strips_blank_lines:
        # Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)

            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)

        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
</t>
<t tx="ekr.20070626112754.1234"></t>
<t tx="ekr.20070626112754.1235"></t>
<t tx="ekr.20070626112754.1236">def printPlugins ():

    g.es_print('Enabled plugins...')
    keys = loadedModules.keys()
    keys = [s.lower() for s in keys]
    keys.sort()
    for key in keys:
        g.es_print(key)
</t>
<t tx="ekr.20070626112754.1237"></t>
<t tx="ekr.20070626112754.1238">def printSettings (self,c):

    '''Prints the value of every setting, except key bindings and commands and open-with tables.
    The following letters indicate where the active setting came from:

    - D indicates default settings.
    - F indicates the file being loaded,
    - L indicates leoSettings.leo,
    - M indicates myLeoSettings.leo,
    '''

    settings = {} # Keys are setting names, values are (letter,val)

    if c:
        d = self.localOptionsDict.get(c.hash())
        self.printSettingsHelper(settings,d,letter='[F]')

    for d in self.localOptionsList:
        self.printSettingsHelper(settings,d)

    for d in self.dictList:
        self.printSettingsHelper(settings,d)

    keys = settings.keys() ; keys.sort()
    for key in keys:
        data = settings.get(key)
        letter,val = data
        print '%45s = %s %s' % (key,letter,val)
        g.es('%s %s = %s' % (letter,key,val))</t>
<t tx="ekr.20070626112754.1239">def printSettingsHelper(self,settings,d,letter=None):

    suppressKind = ('shortcut','shortcuts','openwithtable')
    suppressKeys = (None,'_hash','shortcut')

    if d:
        &lt;&lt; set letter &gt;&gt;
        for key in d.keys():
            if key not in suppressKeys and key not in settings.keys():
                bunch = d.get(key)
                if bunch.kind not in suppressKind:
                    settings[key] = (letter,bunch.val)</t>
<t tx="ekr.20070626112754.1240">theHash = d.get('_hash').lower()

if letter:
    pass
elif theHash.endswith('myleosettings.leo'):
    letter = '[M]'
elif theHash.endswith('leosettings.leo'):
    letter = ' ' * 3
else:
    letter = '[D]'

# g.trace(letter,theHash)</t>
<t tx="ekr.20070626112754.1241">
</t>
<t tx="ekr.20070626112754.1242">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3737745

http://sourceforge.net/forum/message.php?msg_id=3785897

Would it be possible to have the table of "Open With" editors to be part of
the config system? I find myself patching the list every time I D/L a new Leo
version to add the editor I use. This would also help isolate the user from
the "guts" of Leo, theereby being less intimidating.
</t>
<t tx="ekr.20070626112754.1243"></t>
<t tx="ekr.20070626112754.1244">def set (self,p,kind,name,val):

    """Init the setting for name to val."""

    __pychecker__ = '--no-argsused' # p used in subclasses, not here.

    c = self.c ; key = self.munge(name)
    # if kind and kind.startswith('setting'): g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d [key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')

</t>
<t tx="ekr.20070626112754.1245">def parseOpenWith (self,p):

    d = {'command': None,}

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseOpenWithLine(line,d)

    return d
</t>
<t tx="ekr.20070626112754.1246">def parseOpenWithLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if not g.match(s,0,'#'):
        d['command'] = s
</t>
<t tx="ekr.20070626112754.1247">def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """

    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
</t>
<t tx="ekr.20070626112754.1248">if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"

if ext[0] != ".":
    ext = "."+ext

# print "ext",ext
</t>
<t tx="ekr.20070626112754.1249">theDict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to p.v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
</t>
<t tx="ekr.20070626112754.1250">searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20070626112754.1251">@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None

body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed

if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
</t>
<t tx="ekr.20070626112754.1252">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
</t>
<t tx="ekr.20070626112754.1253">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
</t>
<t tx="ekr.20070626112754.1254">def createOpenWithTempFile (self,p,ext):

    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
</t>
<t tx="ekr.20070626112754.1255">for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
</t>
<t tx="ekr.20070626112754.1256">def openWithTempFilePath (self,p,ext):

    """Return the path to the temp file corresponding to p and ext."""

    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)

        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)

        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)

        name = g.toUnicode(name,g.app.tkEncoding)

        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))

        path = g.os_path_join(td,name)

        return path
</t>
<t tx="ekr.20070626112754.1257">def createOpenWithMenuFromTable (self,table):

    '''Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.'''

    c = self.c
    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &amp;With...")
    amp_index = label.find("&amp;")
    label = label.replace("&amp;","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    self.setMenu("Open With...",openWithMenu)
    # Create the menu items in of the Open With menu.
    for entry in table:
        if len(entry) != 3: # 6/22/03
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
    self.createOpenWithMenuItemsFromTable(openWithMenu,table)
    for entry in table:
        name,shortcut,data = entry
        c.k.bindOpenWith (shortcut,name,data)
</t>
<t tx="ekr.20070626112754.1258">def createOpenWithMenuItemsFromTable (self,menu,table):

    '''Create an entry in the Open with Menu from the table.

    Each entry should be a sequence with 2 or 3 elements.'''

    c = self.c ; k = c.k

    if g.app.unitTesting: return

    for data in table:
        &lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;
        # g.trace(label,accelerator)
        realLabel = self.getRealMenuName(label)
        underline=realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        callback = self.defineOpenWithMenuCallback(openWithData)

        self.add_command(menu,label=realLabel,
            accelerator=accelerator or '',
            command=callback,underline=underline)
</t>
<t tx="ekr.20070626112754.1259">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)

if ok:
    if len(data) == 2:
        label,openWithData = data ; accelerator = None
    else:
        label,accelerator,openWithData = data
        accelerator = k.shortcutFromSetting(accelerator)
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
else:
    g.trace('bad data in Open With table: %s' % repr(data))
    continue # Ignore bad data
</t>
<t tx="ekr.20070626112754.1260">def bindOpenWith (self,shortcut,name,data):

    '''Register an open-with command.'''

    k = self ; c = k.c

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,data=data):
        return c.openWith(data=data)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
</t>
<t tx="ekr.20070626112754.1261"></t>
<t tx="ekr.20070626112754.1262">def cleanAllLines (self,event):

    '''Clean all lines in the selected tree.'''

    c = self.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl
    if not w: return

    c.beginUpdate()
    try:
        for p in current.self_and_subtree_iter():
            c.selectPosition(p)
            w.setSelectionRange(0,0,insert=0)
            c.editCommands.cleanLines(event)
        c.selectPosition(current)
    finally:
        c.endUpdate(False)
</t>
<t tx="ekr.20070626112754.1263">def cleanLines (self,event):

    '''Removes leading whitespace from otherwise blanks lines.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()

    lines = [] ; changed = False
    for line in g.splitlines(s):
        if line.strip():
            lines.append(line)
        else:
            if line.endswith('\n'):
                lines.append('\n')
            changed = changed or '\n' != line

    if changed:
        self.beginCommand(undoType='clean-lines')
        result = ''.join(lines)
        if w.hasSelection():
            i,j = w.getSelectionRange()
            w.delete(i,j)
            w.insert(i,result)
            w.setSelectionRange(i,j+len(result))
        else:
            w.delete(0,'end')
            w.insert(0,result)
        self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20070626112754.1264"></t>
<t tx="ekr.20070626112754.1265">@nocolor

Leo now supports zipped .leo files:

- Leo now has save-file-as-zipped and save-file-as-unzipped commands, and
corresponding Save File As Zipped and Save File as Unzipped items in the File
menu. These are exactly the same as Leo's Save As commands except that they
temporarily force Leo to write the file in either zipped or unzipped format.

- Leo remembers whether a file was originally zipped. The read logic handles
either zipped or unzipped .leo files automatically. The write logic will zip the
file if it was originally zipped or if the save-file-as-zipped command is being
executed.

- Leo writes files with .leo extension, regardless of whether the file is zipped
or not. Zipped .leo files contain a single archive, whose name is the same as
the .leo file itself.

These seem like the simplest conventions:

- The new save commands suffice to compress and expand .leo files on a
file-by-file basis. In particular, there is no need for any user settings.

- Outside of Leo you can change the extension to .leo.zip and use stuffit or
other program to expand the .leo file contained within. I've only tested this on
XP, but it should work everywhere...

At present the code uses Python's zipfile module to read and write zipped files.
In turn, the zipfile module uses the zlib module to do the compression.
Conceivably somebody might want Leo to use some other compression technique, say
Python's tarfile module. However, I think the present way should suffice for
most people.</t>
<t tx="ekr.20070626112754.1266">@nocolor

By: samcollett ( Sam Collett ) 
 Compressed LEO files   
2003-01-07 16:57

Would it be possible to have a new file format that was basically a compressed
version of LEO files? Maybe using the gzip compression method. You could then
save a lot of space when you do large files. Not being a professional
programmer myself (I mainly dabble in web design - HTML and Active Server
Pages) how difficult would this be to implement? You would just output using a
different file extension so users of the older versions can still use files
with the LEO extension.
</t>
<t tx="ekr.20070626112754.1267">@nocolor
http://sourceforge.net/forum/message.php?msg_id=2442772
By: ejoy

I made an experiment last night. I replaced the call to open()in leofilecommand.py
with a call to gzip.open().

The LeoPy.leo file saved this way is only 600K! And there is no significant
speed down in saving.

I think it is a good idea to add compression support for load/save .leo files.
When reading or writing file with name ending with ".leo.gz", leo can call gzip
module to uncompress/compress the file, saving a lot of disk space.

What do you think of this?</t>
<t tx="ekr.20070626112754.1268">def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    if not self.use_sax:
        &lt;&lt; read the entire file into the buffer &gt;&gt;
        theFile.close()
        self.fileIndex = 0
    &lt;&lt; Set the default directory &gt;&gt;
    self.topPosition = None
    ok, ratio = self.getLeoFile(
        theFile,fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    if not self.use_sax: # Delete the file buffer
        self.fileBuffer = ""
    return ok</t>
<t tx="ekr.20070626112754.1269">isZipped = zipfile.is_zipfile(fileName)

if isZipped:
    aList = theFile.infolist()
    contentsName = aList[0].filename
    self.fileBuffer = theFile.read(contentsName)
else:
    self.fileBuffer = theFile.read()
</t>
<t tx="ekr.20070626112754.1270">@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) &gt; 0:
    c.openDirectory = theDir
</t>
<t tx="ekr.20070626112754.1271">def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            theFile = file(fileName,'rb')
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        g.es("can not open: %s" % (fileName),color="blue")
        return None,False</t>
<t tx="ekr.20070626112754.1272"></t>
<t tx="ekr.20070626112754.1273">def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
</t>
<t tx="ekr.20070626112754.1274">def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()</t>
<t tx="ekr.20070626112754.1275">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="ekr.20070626112754.1276">def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
</t>
<t tx="ekr.20070626112754.1277">def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    c.beginUpdate()
    try:
        if c.mFileName != "":
            # Calls c.setChanged(False) if no error.
            c.fileCommands.save(c.mFileName)
        else:
            fileName = g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()

            if fileName:
                # Don't change mFileName until the dialog has suceeded.
                c.mFileName = g.ensure_extension(fileName, ".leo")
                c.frame.title = c.mFileName
                c.frame.setTitle(g.computeWindowTitle(c.mFileName))
                c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
                c.fileCommands.save(c.mFileName)
                c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)</t>
<t tx="ekr.20070626112754.1278">def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # 7/2/02: don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            # Calls c.setChanged(False) if no error.
            c.fileCommands.saveAs(c.mFileName)
            c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
</t>
<t tx="ekr.20070626112754.1279">def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
</t>
<t tx="ekr.20070626112754.1280">def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        # set local fileName, _not_ c.mFileName
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save To",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            fileName = g.ensure_extension(fileName, ".leo")
            c.fileCommands.saveTo(fileName)
            c.updateRecentFiles(fileName)

    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
</t>
<t tx="ekr.20070626112754.1281">def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
</t>
<t tx="ekr.20070626112754.1282"></t>
<t tx="ekr.20070626112754.1283">def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,p=v,v=v,fileName=fileName)
    # redraw_flag = g.app.gui.guiName() == 'tkinter'
    if ok is None:
        c.beginUpdate()
        try:
            c.endEditing()# Set the current headline text.
            self.setDefaultDirectoryForNewFiles(fileName)
            ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
            if ok:
                c.setChanged(False) # Clears all dirty bits.
                self.putSavedMessage(fileName)
                if c.config.save_clears_undo_buffer:
                    g.es("clearing undo")
                    c.undoer.clearUndoState()
        finally:
            c.endUpdate() # We must redraw in order to clear dirty node icons.
    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
    return ok
</t>
<t tx="ekr.20070626112754.1284">def saveAs(self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.beginUpdate()
        try:
            c.endEditing() # Set the current headline text.
            self.setDefaultDirectoryForNewFiles(fileName)
            if self.write_Leo_file(fileName,False): # outlineOnlyFlag
                c.setChanged(False) # Clears all dirty bits.
                self.putSavedMessage(fileName)
        finally:
            c.endUpdate() # We must redraw in order to clear dirty node icons.
    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
</t>
<t tx="ekr.20070626112754.1285">def saveTo (self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.beginUpdate()
        try:
            c.endEditing()# Set the current headline text.
            self.setDefaultDirectoryForNewFiles(fileName)
            self.write_Leo_file(fileName,False) # outlineOnlyFlag
            self.putSavedMessage(fileName)
        finally:
            c.endUpdate() # We must redraw in order to clear dirty node icons.
    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
</t>
<t tx="ekr.20070626112754.1286">def putSavedMessage (self,fileName):

    c = self.c

    zipMark = g.choose(c.isZipped,'[zipped] ','')

    g.es("saved: %s%s" % (zipMark,g.shortFileName(fileName)))</t>
<t tx="ekr.20070626112754.1287">def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False,toOPML=False):

    c = self.c
    self.putCount = 0
    self.toString = toString
    self.assignFileIndices()
    theActualFile = None
    toZip = False
    if not outlineOnlyFlag or toOPML:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        if toOPML:
            &lt;&lt; ensure that filename ends with .opml &gt;&gt;
        self.outputFile = cStringIO.StringIO()
        &lt;&lt; create theActualFile &gt;&gt;
        # t1 = time.clock()
        if toOPML:
            self.putToOPML()
        else:
            self.putLeoFile()
        # t2 = time.clock()
        s = self.outputFile.getvalue()
        # g.trace(self.leo_file_encoding)
        if toZip:
            self.writeZipFile(s)
        elif toString:
            # For support of chapters plugin.
            g.app.write_Leo_file_string = s
        else:
            theActualFile.write(s)
            theActualFile.close()
            &lt;&lt; delete backup file &gt;&gt;
            # t3 = time.clock()
            # g.es_print('len %d, putCount %d' % (len(s),self.putCount)) # 'put',t2-t1,'write&amp;close',t3-t2)
        self.outputFile = None
        self.toString = False
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=True)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        if backupName:
            &lt;&lt; delete fileName &gt;&gt;
            &lt;&lt; rename backupName to fileName &gt;&gt;
        self.toString = False
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.</t>
<t tx="ekr.20070626112754.1288">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
</t>
<t tx="ekr.20070626112754.1289"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
</t>
<t tx="ekr.20070626112754.1290">backupName = None

# rename fileName to fileName.bak if fileName exists.
if not toString and g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(c,fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False</t>
<t tx="ekr.20070626112754.1291">if not self.mFileName.endswith('opml'):
    self.mFileName = self.mFileName + '.opml'
fileName = self.mFileName</t>
<t tx="ekr.20070626112754.1292">if toString:
    theActualFile = None
elif c.isZipped:
    self.toString = toString = True
    theActualFile = None
    toZip = True
else:
    theActualFile = open(fileName, 'wb')
</t>
<t tx="ekr.20070626112754.1293">if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
</t>
<t tx="ekr.20070626112754.1294">if fileName and g.os_path_exists(fileName):

    self.deleteFileWithMessage(fileName,'')
</t>
<t tx="ekr.20070626112754.1295">if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(c,backupName,fileName)
</t>
<t tx="ekr.20070626112754.1296">def writeZipFile (self,s):

    # The name of the file in the archive.
    contentsName = g.toEncodedString(
        g.shortFileName(self.mFileName),
        self.leo_file_encoding,reportErrors=True)

    # The name of the archive itself.
    fileName = g.toEncodedString(
        self.mFileName,
        self.leo_file_encoding,reportErrors=True)

    # Write the archive.
    theFile = zipfile.ZipFile(fileName,'w',zipfile.ZIP_DEFLATED)
    theFile.writestr(contentsName,s)
    theFile.close()
</t>
<t tx="ekr.20070626112754.1297"></t>
<t tx="ekr.20070626112754.1298"># Found via unit test.  Happens regardless of chapters.</t>
<t tx="ekr.20070626112754.1299"># Returns in finally clauses prevent the re-raising of the saved exception(!!)</t>
<t tx="ekr.20070626112754.1300">https://sourceforge.net/forum/message.php?msg_id=4283692</t>
<t tx="ekr.20070626112754.1301"></t>
<t tx="ekr.20070626112754.1302">def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = g.os_path_abspath(c.config.getString('aspell_dir'))
    self.aspell_bin_dir = g.os_path_abspath(c.config.getString('aspell_bin_dir'))

    self.local_language_code = local_language_code or 'en'
    self.local_dictionary_file = g.os_path_abspath(local_dictionary_file)
    self.local_dictionary = "%s.wl" % os.path.splitext(self.local_dictionary_file) [0]

    # g.trace('code',self.local_language_code,'dict',self.local_dictionary_file)
    # g.trace('dir',self.aspell_dir,'bin_dir',self.aspell_bin_dir)

    try:
        import ctypes
        import ctypes.util
        self.use_ctypes = True
    except ImportError:
        self.use_ctypes = False
    self.aspell = self.sc = None

    if self.use_ctypes:
        self.getAspellWithCtypes()
    else:
        self.getAspell()
</t>
<t tx="ekr.20070626112754.1303">def getAspell (self):

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=None,verbose=True)

    self.aspell = aspell
    self.sc = aspell and aspell.spell_checker(prefix=self.aspell_dir,lang=self.local_language_code)
</t>
<t tx="ekr.20070626112754.1304">def getAspellWithCtypes (self):

    import ctypes
    import ctypes.util
    c_int, c_char_p = ctypes.c_int, ctypes.c_char_p

    try:
        if sys.platform.startswith('win'):
            path = g.os_path_join(self.aspell_bin_dir, "aspell-15.dll")
            self.aspell = aspell = ctypes.CDLL(path)
        else:
            path = 'aspell'
            libname = ctypes.util.find_library(path)
            assert(libname)
            self.aspell = aspell = ctypes.CDLL(libname)
    except Exception:
        if not sys.platform.startswith('win'):
            g.es_exception()
        g.es('Can not load %s' % (path),color='blue')
        self.aspell = None
        self.check = None
        self.sc = None
        return

    &lt;&lt; define and configure aspell entry points &gt;&gt;

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
</t>
<t tx="ekr.20070626112754.1305"># new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p] 

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_int, c_char_p] 

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p  

sc = new_aspell_config()
if 0:
    print sc 
    print aspell_config_replace(sc, "prefix", aspell_dir) #1/0 
    print 'prefix', aspell_dir, `aspell_config_retrieve(sc, "prefix")`
    print aspell_config_retrieve(sc, "lang")
    print aspell_config_replace(sc, "lang",self.local_language_code)
    print aspell_config_retrieve(sc, "lang")

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))

# Rudimentary error checking, needs more.  
if aspell.aspell_error_number(possible_err) != 0:
    print 'err', aspell_error_message(possible_err)
    spell_checker = None
else: 
    spell_checker = aspell.to_aspell_speller(possible_err)

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_int
word_list_size.argtypes = [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_int
word_list_elements.argtypes = [c_int,]

# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_int 
suggest.argtypes = [c_int, c_char_p, c_int]</t>
<t tx="ekr.20070626112754.1306"></t>
<t tx="ekr.20070626112754.1307">def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.es('No previous command',color='blue')
    return 'break'

def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c ; gui = g.app.gui

    keysym = gui.eventKeysym(event)
    # g.trace('state',k.state.kind,'event',repr(event),g.callers())
    if keysym == 'Return' and k.mb_history:
    # if k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
        return 'break'
    else:
        g.trace('oops')
        return k.keyboardQuit(event)
</t>
<t tx="ekr.20070626112754.1308">def keyboardQuit (self,event,hideTabs=True,setDefaultUnboundKeyAction=True):

    '''This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.'''

    k = self ; c = k.c

    if g.app.quitting:
        return

    if hideTabs:
        k.autoCompleter.exit()
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')

    # Completely clear the mode.
    if k.inputModeName:
        k.endMode(event)

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()

    if setDefaultUnboundKeyAction: k.setDefaultUnboundKeyAction()
    k.showStateAndMode()
    c.endEditing()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.1309">def setState (self,kind,n,handler=None):

    k = self
    if kind and n != None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()

    # k.showStateAndMode()
</t>
<t tx="ekr.20070626112754.1310">@

Possibilities:

- Destroy all tree widgets only when switching chapters.
- Create unique tree for each chapter.
- Remember canvas from which each widget was allocated.</t>
<t tx="ekr.20070626112754.1311">def createTab (self,tabName,select=True):

    tt = self

    if tabName not in tt.tabNames:
        tt.tabNames.append(tabName)
        tt.setNames()
</t>
<t tx="ekr.20070626112754.1312">def chapterSelectHelper (self,w=None,selectEditor=True):

    c = self.c ; cc = self.cc ; name = self.name

    # g.trace(name,'self.p',self.p) # ,'self.root',self.root) # 'w.leo_p',w and w.leo_p)

    cc.selectedChapter = self

    # Next, recompute p and possibly select a new editor.
    if w:
        assert w == c.frame.body.bodyCtrl
        assert w == c.frame.bodyCtrl
        assert w.leo_p
        # g.trace(name,'w.leo_p',w.leo_p,'p',p)
        self.p = p = self.findPositionInChapter(w.leo_p)
        if p != w.leo_p: g.trace('****** can not happen: lost p',w.leo_p)
    else:
        # This must be done *after* switching roots.
        target_p = self.p or self.root.firstChild() or self.root
        #g.trace(name,'target_p',target_p)
        #g.trace(name,'self.p',self.p,'self.root',self.root)
        self.p = p = self.findPositionInChapter(target_p)
        if selectEditor:
            w = self.findEditorInChapter(p)
            c.frame.body.selectEditor(w) # Switches text.

    c.beginUpdate()
    try:
        if name == 'main' and cc.chaptersNode:
            cc.chaptersNode.contract()    
        c.hoistStack = self.hoistStack[:]
        c.selectPosition(p)
    finally:
        c.endUpdate()
        g.doHook('hoist-changed',c=c)
        c.bodyWantsFocusNow()</t>
<t tx="ekr.20070626112754.1313">def selectTab (self,tabName):

    tt = self

    if tabName not in self.tabNames:
        tt.createTab(tabName)

    tt.cc.selectChapterByName(tabName)
</t>
<t tx="ekr.20070626112754.1314">def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # g.printGcAll()

    # Do this first.
    &lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    if c.chapterController: # New in Leo 4.4.3 b1.
        g.clearAllIvars(c.chapterController)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.keyHandler) # New in Leo 4.4.3 b1.
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)

    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)

</t>
<t tx="ekr.20070626112754.1315"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
</t>
<t tx="ekr.20070626112754.1316"></t>
<t tx="ekr.20070626112754.1317">def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.

    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''

    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)
</t>
<t tx="ekr.20070626112754.1318"># This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories)

    if c:
        if not c.config.create_nonexistent_directories:
            return None
    elif not app.config.create_nonexistent_directories:
        return None

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) &gt; 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                g.es("created directory: "+path)
            except:
                g.es("exception creating directory: "+path)
                g.es_exception()
                return None
    return dir1 # All have been created.
</t>
<t tx="ekr.20070626112754.1319"></t>
<t tx="ekr.20070626112754.1320">&lt;&lt; about os.rename &gt;&gt;

def rename (self,src,dst,mode=None,verbose=True):

    '''remove dst if it exists, then rename src to dst.

    Change the mode of the renamed file if mode is given.

    Return True if all went well.'''

    c = self.c
    head,tail=g.os_path_split(dst)
    if head and len(head) &gt; 0:
        g.makeAllNonExistentDirectories(head,c=c)

    if g.os_path_exists(dst):
        if not self.remove(dst,verbose=verbose):
            return False

    try:
        os.rename(src,dst)
        if mode != None:
            self.chmod(dst,mode)
        return True
    except Exception:
        if verbose:
            self.error("exception renaming: %s to: %s" % (
                self.outputFileName,self.targetFileName))
            g.es_exception()
        return False
</t>
<t tx="ekr.20070626112754.1321">@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
</t>
<t tx="ekr.20070626112754.1322">if g.unitTesting:

    __pychecker__ = '--no-reimport'

    import os
    c,p = g.getTestVars()
    at = c.atFileCommands

    exists = g.os_path_exists
    path = g.os_path_join(g.app.testDir,'xyzzy')
    path2 = g.os_path_join(g.app.testDir,'xyzzy2')

    # Create both paths.
    for p in (path,path2):
        if exists(p):
            os.remove(p)
        assert not exists(p)
        f = file(p,'w')
        f.write('test %s' % p)
        f.close()
        assert exists(p)

    assert at.rename(path,path2,verbose=True)
    assert exists(path2)
    f = file(path2)
    s = f.read()
    f.close()
    # print 'Contents of %s: %s' % (path2,s)
    assert s == 'test %s' % path
    os.remove(path2)
    assert not exists(path)
</t>
<t tx="ekr.20070626112754.1323">@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):

    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    __pychecker__ = '--maxlines=400'
    # g.stat()

    c = self.c
    &lt;&lt; Set ivars &gt;&gt;
    &lt;&lt; Set path from @file node &gt;&gt;
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        old.update(theDict)
    &lt;&lt; Set current directory &gt;&gt;
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        &lt;&lt; Set comment strings from delims &gt;&gt;
</t>
<t tx="ekr.20070626112754.1324">self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
</t>
<t tx="ekr.20070626112754.1325"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) &gt; 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
</t>
<t tx="ekr.20070626112754.1326"># We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory(c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            &lt;&lt; handle absolute path &gt;&gt;
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
</t>
<t tx="ekr.20070626112754.1327">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
</t>
<t tx="ekr.20070626112754.1328"># path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
</t>
<t tx="ekr.20070626112754.1329">if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
</t>
<t tx="ekr.20070626112754.1330"># 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
</t>
<t tx="ekr.20070626112754.1331"># EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
</t>
<t tx="ekr.20070626112754.1332">if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
</t>
<t tx="ekr.20070626112754.1333">if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w &gt; 0:
        self.page_width = w
</t>
<t tx="ekr.20070626112754.1334">if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w
</t>
<t tx="ekr.20070626112754.1335"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
</t>
<t tx="ekr.20070626112754.1336">if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
</t>
<t tx="ekr.20070626112754.1337">def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    &lt;&lt; Set path from @file node &gt;&gt;
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            &lt;&lt; handle @path &gt;&gt;
            return

    &lt;&lt; Set current directory &gt;&gt;
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        g.trace()
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
</t>
<t tx="ekr.20070626112754.1338"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
</t>
<t tx="ekr.20070626112754.1339"># We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
&lt;&lt; compute relative path from s[k:] &gt;&gt;

if path and len(path) &gt; 0:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        &lt;&lt; handle absolute path &gt;&gt;
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
</t>
<t tx="ekr.20070626112754.1340">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()
</t>
<t tx="ekr.20070626112754.1341"># path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
</t>
<t tx="ekr.20070626112754.1342"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
</t>
<t tx="ekr.20070626112754.1343">&lt;&lt; about os.rename &gt;&gt;

def utils_rename (c,src,dst,mode=None,verbose=True):

    '''Platform independent rename.'''

    head, tail = g.os_path_split(dst)
    if head and len(head) &gt; 0:
        g.makeAllNonExistentDirectories(head,c=c)

    if g.os_path_exists(dst):
        if not g.utils_remove(dst):
            return False
    try:
        # New in Leo 4.4b1: try using shutil first.
        try:
            import shutil # shutil is new in Python 2.3
            shutil.move(src,dst)
        except ImportError:
            if sys.platform == "win32":
                os.rename(src,dst)
            else:
                try:
                    # Alas, distutils.file_util may not exist.
                    from distutils.file_util import move_file
                    move_file(src,dst)
                except ImportError:
                    # Desperation: may give: 'Invalid cross-device link'
                    os.rename(src,dst)
        if mode:
            g.utils_chmod(dst,mode,verbose)
        return True
    except Exception:
        if verbose:
            g.es('Exception renaming %s to %s' % (src,dst),color='red')
            g.es_exception(full=False)
        return False
</t>
<t tx="ekr.20070626112754.1344">@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
</t>
<t tx="ekr.20070626112754.1345">if g.unitTesting:

    __pychecker__ = '--no-reimport'
    import os
    exists = g.os_path_exists

    c,p = g.getTestVars()

    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)

    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)

    f = file(path,'w')
    f.write('test')
    f.close()

    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)
</t>
<t tx="ekr.20070626112754.1346">@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):

    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        &lt;&lt; Collect @first attributes &gt;&gt;
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for print modes directives &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @root &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        old.update(theDict)
    &lt;&lt; Set self.tangle_directory &gt;&gt;
</t>
<t tx="ekr.20070626112754.1347">@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i&gt;j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i &gt;= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break
</t>
<t tx="ekr.20070626112754.1348">if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
</t>
<t tx="ekr.20070626112754.1349">if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
</t>
<t tx="ekr.20070626112754.1350">if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
</t>
<t tx="ekr.20070626112754.1351">@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
</t>
<t tx="ekr.20070626112754.1352">if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;
    if len(theDir) &gt; 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                &lt;&lt; handle absolute @path &gt;&gt;
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
</t>
<t tx="ekr.20070626112754.1353">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
</t>
<t tx="ekr.20070626112754.1354">if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir,c=c)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) &gt; 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) &gt; 0:
                g.es("relative path in @path directive: " + relative_path)
</t>
<t tx="ekr.20070626112754.1355">if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w &gt; 0:
        self.page_width = w
</t>
<t tx="ekr.20070626112754.1356">@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
</t>
<t tx="ekr.20070626112754.1357">if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
</t>
<t tx="ekr.20070626112754.1358">if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.

elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
</t>
<t tx="ekr.20070626112754.1359">@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) &gt; 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) &gt; 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                &lt;&lt; handle absolute path &gt;&gt;

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
</t>
<t tx="ekr.20070626112754.1360">if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir,c=c)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) &gt; 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) &gt; 0:
            g.es(kind + " directory: " + dir2)
</t>
<t tx="ekr.20070626112754.1361"></t>
<t tx="ekr.20070626112754.1362"># This is part of the tangle code.

def update_file_if_changed(c,file_name,temp_name):

    """Compares two files.

    If they are different, we replace file_name with temp_name.
    Otherwise, we just delete temp_name. Both files should be closed."""

    if g.os_path_exists(file_name):
        if filecmp.cmp(temp_name, file_name):
            kind = 'unchanged'
            ok = g.utils_remove(temp_name)
        else:
            kind = '***updating'
            mode = g.utils_stat(file_name)
            ok = g.utils_rename(c,temp_name,file_name,mode)
    else:
        kind = 'creating'
        ok = g.utils_rename(c,temp_name,file_name)

    if ok:
        g.es('%12s: %s' % (kind,file_name))
    else:
        g.es("rename failed: no file created!",color="red")
        g.es(file_name," may be read-only or in use")
</t>
<t tx="ekr.20070626112754.1363">@ An interesting change:

- Replaced frame.treeBar ivar by injected frame.canvas.leo_treeBar ivar.</t>
<t tx="ekr.20070626112754.1364">def createTkTreeCanvas (self,parentFrame,scrolls,pack):

    frame = self

    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    treeBar = Tk.Scrollbar(parentFrame,name="treeBar")

    # New in Leo 4.4.3 b1: inject the ivar into the canvas.
    canvas.leo_treeBar = treeBar

    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
        if 1: # New in 4.3.
            &lt;&lt; workaround for mouse-wheel problems &gt;&gt;

    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")

    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
    if 0:
        &lt;&lt; do scrolling by hand in a separate thread &gt;&gt;

    # g.print_bindings("canvas",canvas)
    return canvas
</t>
<t tx="ekr.20070626112754.1365"># Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("&lt;ButtonPress&gt;",mapWheel,add=1)
</t>
<t tx="ekr.20070626112754.1366"># New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')

def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay

def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('&lt;Shift Button-3&gt;',scrollDn)
    canvas.bind_all('&lt;Shift Button-1&gt;',scrollUp)
    canvas.bind_all('&lt;Shift ButtonRelease-1&gt;',off)
    canvas.bind_all('&lt;Shift ButtonRelease-3&gt;',off)
else: # Use plain click.
    canvas.bind_all( '&lt;Button-3&gt;',scrollDn)
    canvas.bind_all( '&lt;Button-1&gt;',scrollUp)
    canvas.bind_all( '&lt;ButtonRelease-1&gt;',off)
    canvas.bind_all( '&lt;ButtonRelease-3&gt;',off)
</t>
<t tx="ekr.20070626112754.1367">def setCallback (self,*args,**keys):

    """Callback to adjust the scrollbar.

    Args is a tuple of two floats describing the fraction of the visible area."""

    #g.trace(self.tree.redrawCount,args,g.callers())

    apply(self.canvas.leo_treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)

def yviewCallback (self,*args,**keys):

    """Tell the canvas to scroll"""

    #g.trace(vyiewCallback,args,keys,g.callers())

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)</t>
<t tx="ekr.20070626112754.1368">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4215654
By: rogererens

There's a bug with ordinary hoisting: in the "Outline" menu the "Delete Node"
menu item is not disabled when the local root is selected.

@color</t>
<t tx="ekr.20070626112754.1369">def canDeleteHeadline (self):

    c = self ; p = c.currentPosition()

    if c.hoistStack:
         bunch = c.hoistStack[0]
         if p == bunch.p: return False

    return p.hasParent() or p.hasThreadBack() or p.hasNext()

canCutOutline = canDeleteHeadline
</t>
<t tx="ekr.20070626112754.1370">@nocolor

Added c argument to topLevelMenu function in leoupdate.py:

exception executing command
Traceback (most recent call last):
  File "C:\Programme\Leo\src\leoCommands.py", line 269, in doCommand
    val = command(event)
  File "C:\Programme\Leo\plugins\plugins_menu.py", line 120, in callback
    p.hastoplevel(c)
TypeError: topLevelMenu() takes no arguments (1 given)
</t>
<t tx="ekr.20070626112754.1371"></t>
<t tx="ekr.20070626112754.1372">def putVnodes (self):

    """Puts all &lt;v&gt; elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("&lt;vnodes&gt;\n")

    # Make only one copy for all calls.
    self.currentPosition = c.currentPosition() 
    self.rootPosition    = c.rootPosition()
    self.topPosition     = c.topPosition()

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings_iter():
            # New in Leo 4.4.2 b2 An optimization:
            self.putVnode(p,isIgnore=p.isAtIgnoreNode()) # Write the next top-level node.

    self.put("&lt;/vnodes&gt;\n")</t>
<t tx="ekr.20070626112754.1373">def putVnode (self,p,isIgnore=False):

    """Write a &lt;v&gt; element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)
    &lt;&lt; Set gnx = tnode index &gt;&gt;
    attrs = []
    &lt;&lt; Append attribute bits to attrs &gt;&gt;
    &lt;&lt; Append tnodeList and unKnownAttributes to attrs &gt;&gt;
    attrs = ''.join(attrs)
    v_head = '&lt;v t="%s"%s&gt;&lt;vh&gt;%s&lt;/vh&gt;' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        &lt;&lt; issue informational messages &gt;&gt;
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('&lt;/v&gt;\n')
    else:
        fc.put('%s&lt;/v&gt;\n' % v_head) # Call put only once.</t>
<t tx="ekr.20070626112754.1374"># New in Leo 4.4.3
if not v.t.fileIndex:
    g.trace('*** missing t.fileIndex','v',repr(v))
    # c.dumpOutline() # Can be called inside pdb.
    if 1:
        # Print the @chapters tree
        c.chapterController.printChaptersTree()
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)
if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.

# old code.
# if v.t.fileIndex:
    # gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    # if forceWrite or self.usingClipboard:
        # v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
# else:
    # g.trace(v.t.fileIndex,v)
    # g.es("error writing file(bad v.t.fileIndex)!")
    # g.es("try using the Save To command")
</t>
<t tx="ekr.20070626112754.1375"># These string catenations are benign because they rarely happen.
attr = ""
if v.isExpanded(): attr += "E"
if v.isMarked():   attr += "M"
if v.isOrphan():   attr += "O"

# No longer a bottleneck now that we use p.equal rather than p.__cmp__
# Almost 30% of the entire writing time came from here!!!
if not self.use_sax:
    if p.equal(self.topPosition):     attr += "T" # was a bottleneck
    if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr:
    attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions &lt;v&gt; element.
if self.use_sax and p.equal(self.rootPosition):
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d</t>
<t tx="ekr.20070626112754.1376"># Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

# Debugging.
# if v.isAnyAtFileNode():
    # if hasattr(v.t,"tnodeList"):
        # g.trace(v.headString(),len(v.t.tnodeList))
    # else:
        # g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))</t>
<t tx="ekr.20070626112754.1377">if isOrphan and isThin:
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

# For testing.
# if p.isAtIgnoreNode():
     # for p2 in p.self_and_subtree_iter():
            # if p2.isAtThinFileNode():
                # g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
</t>
<t tx="ekr.20070626112754.1378">def putTnodeList (self,v):

    """Put the tnodeList attribute of a tnode."""

    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!
    nodeIndices = g.app.nodeIndices
    tnodeList = v.t.tnodeList
    if tnodeList:
        # g.trace("%4d" % len(tnodeList),v)
        for t in tnodeList:
            try: # Will fail for None or any pre 4.1 file index.
                theId,time,n = t.fileIndex
            except:
                g.trace("assigning gnx for ",v,t)
                gnx = nodeIndices.getNewIndex()
                v.t.setFileIndex(gnx) # Don't convert to string until the actual write.
        s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
        return ' tnodeList="%s"' % (s)
    else:
        return ''</t>
<t tx="ekr.20070626112754.1379">def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create a list of all tnodes whose vnodes are marked or expanded
    if 1: # New in Leo 4.4.2 b2.
        # Put each tnode in the list only once.
        # This should have been done long ago.
        marks = [] ; expanded = []
        for p in p.subtree_iter():
            t = p.v.t
            if p.isMarked() and p.v.t not in marks:
                marks.append(t)
            if p.hasChildren() and p.isExpanded() and t not in expanded:
                expanded.append(t)

        result = []
        for theList,tag in ((marks,"marks"),(expanded,"expanded")):
            if theList:
                sList = []
                for t in theList:
                    gnx = t.fileIndex
                    sList.append("%s," % nodeIndices.toString(gnx))
                s = string.join(sList,'')
                # g.trace(tag,[str(p.headString()) for p in theList])
                result.append('\n%s="%s"' % (tag,s))
    else:
        marks = [] ; expanded = []
        for p in p.subtree_iter():
            if p.isMarked() and not p in marks:
                marks.append(p.copy())
            if p.hasChildren() and p.isExpanded() and not p in expanded:
                expanded.append(p.copy())

        result = []
        for theList,tag in ((marks,"marks"),(expanded,"expanded")):
            if theList:
                sList = []
                for p in theList:
                    gnx = p.v.t.fileIndex
                    sList.append("%s," % nodeIndices.toString(gnx))
                s = string.join(sList,'')
                # g.trace(tag,[str(p.headString()) for p in theList])
                result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)</t>
<t tx="ekr.20070626112754.1380">def putDescendentUnknownAttributes (self,p):

    # pychecker complains about dumps.

    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    python23 = g.CheckVersion(version,'2.3')

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = []
    tnodesData = []
    for p2 in p.subtree_iter():
        t = p2.v.t
        if hasattr(t,"unknownAttributes"):
            if t not in tnodes :
                # g.trace(p2.headString(),t)
                tnodes.append(t) # Bug fix: 10/4/06.
                tnodesData.append((p2,t),)

    # Create a list of pairs (t,d) where d contains only pickleable entries.
    data = []
    for p,t in tnodesData:
        if type(t.unknownAttributes) != type({}):
             g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
        else:
            # Create a new dict containing only entries that can be pickled.
            d = dict(t.unknownAttributes) # Copy the dict.

            for key in d.keys():
                try:
                    # We don't actually save the pickled values here.
                    if python23:
                        pickle.dumps(d[key],protocol=1) # Requires Python 2.3
                    else:
                        pickle.dumps(d[key],bin=True) # Requires earlier versions of Python.
                except pickle.PicklingError:
                    del d[key]
                    g.es("ignoring bad unknownAttributes key %s in %s" % (
                        key,p),color="blue")
                except Exception:
                    del d[key]
                    g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
                    g.es_exception()
            data.append((t,d),)

    # Create resultDict, an enclosing dict to hold all the data.
    resultDict = {}
    nodeIndices = g.app.nodeIndices
    for t,d in data:
        gnx = nodeIndices.toString(t.fileIndex)
        resultDict[gnx]=d

    if 0:
        print "resultDict..."
        for key in resultDict:
            print repr(key),repr(resultDict.get(key))

    # Pickle and hexlify resultDict.
    if resultDict:
        try:
            tag = "descendentTnodeUnknownAttributes"
            if python23:
                s = pickle.dumps(resultDict,protocol=1) # Requires Python 2.3
                # g.trace('protocol=1')
            else:
                s = pickle.dumps(resultDict,bin=True) # Requires Earlier version of Python.
                # g.trace('bin=True')
            field = ' %s="%s"' % (tag,binascii.hexlify(s))
            return field
        except pickle.PicklingError:
            g.trace("putDescendentUnknownAttributes can't happen 1",color="red")
        except Exception:
            g.es("putDescendentUnknownAttributes can't happen 2",color='red')
            g.es_exception()
    return ''
</t>
<t tx="ekr.20070626112754.1381">@nocolor

So I'm still getting no trash tab / context menu on startup, so to 
get them I have to use the new file menu.

The content loss on save I'm thinking may be related to a really 
obnoxious habit I have, I know I shouldn't do this, but I often 
click the window manager close box when I want to 'save and exit'. 
That should work, but it's not safe... leo's not the only app. that 
can give trouble when you do that.

Anyway, I don't lose content when I select the Save menu item 
explicitly, but I do when I just click the close box and answer 
'yes' to the 'do you want to save' question.

@color</t>
<t tx="ekr.20070626112754.1382">def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c) # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        frame.c.bodyWantsFocusNow()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
</t>
<t tx="ekr.20070626112754.1383">def promptForSave (self):

    """Prompt the user to save changes.

    Return True if the user vetos the quit or save operation."""

    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    theType = g.choose(g.app.quitting, "quitting?", "closing?")

    answer = g.app.gui.runAskYesNoCancelDialog(c,
        "Confirm",
        'Save changes to %s before %s' % (name,theType))

    # print answer
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            &lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.
</t>
<t tx="ekr.20070626112754.1384"># Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title="Save",
    filetypes=[("Leo files", "*.leo")],
    defaultextension=".leo")
c.bringToFront()
</t>
<t tx="ekr.20070626112754.1385"></t>
<t tx="ekr.20070626112754.1386">@
The fix was in &lt; &lt; activate this window &gt; &gt;
Happily, the active ivar is now set only in this section, and important simplification.
</t>
<t tx="ekr.20070626112754.1387">def setEditHeadlineColors (self,p):

    c = self.c ; w = c.edit_widget(p)

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())

    fg    = self.headline_text_editing_foreground_color or 'black'
    bg    = self.headline_text_editing_background_color or 'white'
    selfg = self.headline_text_editing_selection_foreground_color or 'white'
    selbg = self.headline_text_editing_selection_background_color or 'black'

    try: # Use system defaults for selection foreground/background
        w.configure(state="normal",highlightthickness=1,
        fg=fg,bg=bg,selectforeground=selfg,selectbackground=selbg)
    except:
        g.es_exception()
</t>
<t tx="ekr.20070626112754.1388">set_focus_count = 0

def set_focus(self,c,w):

    __pychecker__ = '--no-argsused' # c not used at present.

    """Put the focus on the widget."""

    if not g.app.unitTesting and c and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        # Do not call trace here: that might affect focus!
        print 'gui.set_focus: %4d %10s %s' % (
            self.set_focus_count,c and c.shortFileName(),
            c and c.widget_name(w)), g.callers(5)

    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
</t>
<t tx="ekr.20070626112754.1389"></t>
<t tx="ekr.20070626112754.1390">def bringToFront(self,set_focus=True):

    # g.trace(g.callers())

    c = self
    c.frame.deiconify()

    if set_focus:
        c.frame.body.setFocus()

BringToFront = bringToFront # Compatibility with old scripts
</t>
<t tx="ekr.20070626112754.1391">def bringToFront (self):
    # g.trace(g.callers())
    self.top.deiconify()
    self.top.lift()

def getFocus(self):
    """Returns the widget that has focus, or body if None."""
    try:
        # This method is unreliable while focus is changing.
        # The call to update_idletasks may help.  Or not.
        self.top.update_idletasks()
        f = self.top.focus_displayof()
    except Exception:
        f = None
    if f:
        return f
    else:
        return self.bodyCtrl

def getTitle (self):
    return self.top.title()

def setTitle (self,title):
    return self.top.title(title)

def get_window_info(self):
    return g.app.gui.get_window_info(self.top)

def iconify(self):
    self.top.iconify()

def deiconify (self):
    self.top.deiconify()

def lift (self):
    self.top.lift()

def update (self):
    self.top.update()
</t>
<t tx="ekr.20070626112754.1392">def onHeadlineClick (self,event,p=None):

    # g.trace('p',p)
    c = self.c ; w = event.widget

    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'

    # g.trace(g.app.gui.widget_name(w)) #p.headString())

    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal
</t>
<t tx="ekr.20070626112754.1393">def OnActivateHeadline (self,p,event=None):

    '''Handle common process when any part of a headline is clicked.'''

    # g.trace(p.headString())

    returnVal = 'break' # Default: do nothing more.
    trace = False

    try:
        c = self.c
        c.setLog()
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")

    return returnVal
</t>
<t tx="ekr.20070626112754.1394">if p == c.currentPosition():

    if trace: g.trace('current','active',self.active)
    self.editLabel(p) # sets focus.
    # If we are active, pass the event along so the click gets handled.
    # Otherwise, do *not* pass the event along so the focus stays the same.
    returnVal = g.choose(self.active,'continue','break')
    self.active = True
else:
    if trace: g.trace("not current")
    self.select(p,scroll=False)
    w  = c.frame.body.bodyCtrl
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        spot = p.v.t.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
    else:
        w.setInsertPoint(0)
    # An important detail.
    # The *canvas* (not the headline) gets the focus so that
    # tree bindings take priority over text bindings.
    c.treeWantsFocus()
    self.active = False
    returnVal = 'break'</t>
<t tx="ekr.20070626112754.1395"></t>
<t tx="ekr.20070626112754.1396">def renameChapterHelper (self,cc,tabName):

    '''Called from cc.renameChapter to prompt for a new name.'''

    tt = self ; c = tt.c
    tab = tt.getButton(tabName)

    f = Tk.Frame(tab)
    # Elegant code.  Setting e's textvariable to chapter.sv
    # immediately updates the chapter labels as e changes.
    sv = tt.stringVarDict.get(tabName)
    e = Tk.Entry(f,background='white',textvariable=sv)
    b = Tk.Button(f,text="Close")
    f.pack(side='top')
    e.pack(side='left')
    b.pack(side='right')
    def changeCallback (event=None,f=f,sv=sv):
        newName = sv.get()
        f.pack_forget()
        tt.renameTab(newName)
        # g.trace(tabName,newName)
        theChapter = cc.getChapter(tabName)
        # c.setBodyString(theChapter.root,newName)
        cc.completeChapterRename(theChapter,newName)
        c.bodyWantsFocusNow()
    e.bind('&lt;Return&gt;',changeCallback)
    e.selection_range(0,'end')
    b.configure(command=changeCallback)
    c.widgetWantsFocusNow(e)</t>
<t tx="ekr.20070626112754.1397">def createChapter (self,event=None):

    '''create-chapter command.
    Create a chapter with a dummy first node.'''

    cc = self ; k = cc.c.k ; tag = 'create-chapter'
    state = k.getState(tag)

    if state == 0:
        names = cc.chaptersDict.keys()
        k.setLabelBlue('Create chapter: ',protect=True)
        k.getArg(event,tag,1,self.createChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=None,
                undoType='Create Chapter')</t>
<t tx="ekr.20070626112754.1398">def createTopLevelMenuItems (self,tmenu):

    cc = self.cc ; menu = tmenu

    for kind,label,command in (
        ('','New Chapter',cc.createChapter),
        ('','Remove This Chapter',cc.removeChapter),
        ('','Rename This Chapter',cc.renameChapter),
        ('-',None,None),
        ('...','Clone Node To Chapter...',cc.cloneToChapter),
        ('...','Copy Node To Chapter...',cc.copyToChapter),
        ('...','Move Node To Chapter...',cc.moveToChapter),
    ):
        if kind == '-':
            menu.add_separator()
        elif kind == '...':
            submenu = Tk.Menu(menu,tearoff=0)
            menu.add_cascade(menu=submenu,label=label)
            def chapterMenuCallback(event=None,cc=cc,command=command,submenu=submenu):
                self.setupChaptersMenu(submenu,command)
            submenu.configure(postcommand=chapterMenuCallback)
        else:
            menu.add_command(label=label,command=command)</t>
<t tx="ekr.20070626112754.1399"></t>
<t tx="ekr.20070626112754.1400">def __init__(self,c,frame,canvas):

    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Configuration and debugging settings.
    # These must be defined here to eliminate memory leaks.
    self.allow_clone_drags          = c.config.getBool('allow_clone_drags')
    self.center_selected_tree_node  = c.config.getBool('center_selected_tree_node')
    self.enable_drag_messages       = c.config.getBool("enable_drag_messages")
    self.expanded_click_area        = c.config.getBool('expanded_click_area')
    self.gc_before_redraw           = c.config.getBool('gc_before_redraw')

    self.headline_text_editing_foreground_color = c.config.getColor(
        'headline_text_editing_foreground_color')
    self.headline_text_editing_background_color = c.config.getColor(
        'headline_text_editing_background_color')
    self.headline_text_editing_selection_foreground_color = c.config.getColor(
        'headline_text_editing_selection_foreground_color')
    self.headline_text_editing_selection_background_color = c.config.getColor(
        'headline_text_editing_selection_background_color')
    self.headline_text_selected_foreground_color = c.config.getColor(
        "headline_text_selected_foreground_color")
    self.headline_text_selected_background_color = c.config.getColor(
        "headline_text_selected_background_color")
    self.headline_text_editing_selection_foreground_color = c.config.getColor(
        "headline_text_editing_selection_foreground_color")
    self.headline_text_editing_selection_background_color = c.config.getColor(
        "headline_text_editing_selection_background_color")
    self.headline_text_unselected_foreground_color = c.config.getColor(
        'headline_text_unselected_foreground_color')
    self.headline_text_unselected_background_color = c.config.getColor(
        'headline_text_unselected_background_color')

    self.idle_redraw = c.config.getBool('idle_redraw')
    self.initialClickExpandsOrContractsNode = c.config.getBool(
        'initialClickExpandsOrContractsNode')
    self.look_for_control_drag_on_mouse_down = c.config.getBool(
        'look_for_control_drag_on_mouse_down')
    self.select_all_text_when_editing_headlines = c.config.getBool(
        'select_all_text_when_editing_headlines')

    self.stayInTree     = c.config.getBool('stayInTreeAfterSelect')
    self.trace          = c.config.getBool('trace_tree')
    self.trace_alloc    = c.config.getBool('trace_tree_alloc')
    self.trace_chapters = c.config.getBool('trace_chapters')
    self.trace_edit     = c.config.getBool('trace_tree_edit')
    self.trace_gc       = c.config.getBool('trace_tree_gc')
    self.trace_redraw   = c.config.getBool('trace_tree_redraw')
    self.trace_select   = c.config.getBool('trace_select')
    self.trace_stats    = c.config.getBool('show_tree_stats')
    self.use_chapters   = c.config.getBool('use_chapters')

    # Objects associated with this tree.
    self.canvas = canvas

    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;

    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.

    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount &lt;= 0
    self.verbose = True

    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()

    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = [] # New in 4.4b2: a list of free Tk.Text widgets

    self.freeUserIcons = []
</t>
<t tx="ekr.20070626112754.1401">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height
</t>
<t tx="ekr.20070626112754.1402"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if present headline is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = 0.0
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw_now)
</t>
<t tx="ekr.20070626112754.1403"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()
</t>
<t tx="ekr.20070626112754.1404">def setCanvasBindings (self,canvas):

    k = self.c.k

    canvas.bind('&lt;Key&gt;',k.masterKeyHandler)
    canvas.bind('&lt;Button-1&gt;',self.onTreeClick)

    &lt;&lt; make bindings for tagged items on the canvas &gt;&gt;
    &lt;&lt; create baloon bindings for tagged items on the canvas &gt;&gt;</t>
<t tx="ekr.20070626112754.1405">where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '&lt;Button-1&gt;',self.onClickBoxClick),
    ('iconBox','&lt;Button-1&gt;',self.onIconBoxClick),
    ('iconBox','&lt;Double-1&gt;',self.onIconBoxDoubleClick),
    ('iconBox','&lt;Button-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;Double-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;B1-Motion&gt;',self.onDrag),
    ('iconBox','&lt;Any-ButtonRelease-1&gt;',self.onEndDrag),
)
for tag,event,callback in table:
    canvas.tag_bind(tag,event,callback)
</t>
<t tx="ekr.20070626112754.1406">if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)
</t>
<t tx="ekr.20070626112754.1407">def newText (self,p,x,y):

    canvas = self.canvas ; tag = "textBox"
    c = self.c ;  k = c.k
    if self.freeText:
        w,theId = self.freeText.pop()
        canvas.coords(theId,x,y) # Make the window visible again.
            # theId is the id of the *window* not the text.
    else:
        # Tags are not valid in Tk.Text widgets.
        self.textNumber += 1
        w = g.app.gui.plainTextWidget(
            canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
        w.bindtags(self.textBindings) # Set the bindings for this widget.

        if 0: # Crashes on XP.
            &lt;&lt; patch by Maciej Kalisiak to handle scroll-wheel events &gt;&gt;

        theId = canvas.create_window(x,y,anchor="nw",window=w,tag=tag)
        w.leo_window_id = theId # Never changes.

        if self.trace_alloc: g.trace('%3d %6s' % (theId,id(w)),align=-20)

    # Common configuration.
    if 0: # Doesn't seem to work.
        balloon = Pmw.Balloon(canvas,initwait=700)
        balloon.tagbind(canvas,theId,balloonHelp='Headline')

    if p:
        self.ids[theId] = p # Add the id of the *window*
        self.setHeadlineText(theId,w,p.headString())
        w.configure(width=self.headWidth(p=p))
        w.leo_position = p # This p never changes.
            # *Required*: onHeadlineClick uses w.leo_position to get p.

        # Keys are p.key().  Entries are (w,theId)
        self.visibleText [p.key()] = w,theId
    else:
        g.trace('**** can not happen.  No p')

    return w
</t>
<t tx="ekr.20070626112754.1408">def PropagateButton4(e):
    canvas.event_generate("&lt;Button-4&gt;")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("&lt;Button-5&gt;")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("&lt;MouseWheel&gt;")
    return "break"

instance_tag = w.bindtags()[0]
w.bind_class(instance_tag, "&lt;Button-4&gt;", PropagateButton4)
w.bind_class(instance_tag, "&lt;Button-5&gt;", PropagateButton5)
w.bind_class(instance_tag, "&lt;MouseWheel&gt;",PropagateMouseWheel)
</t>
<t tx="ekr.20070626112754.1409"></t>
<t tx="ekr.20070626112754.1410">def completeAllBindingsForWidget (self,w):

    k = self ; d = k.bindingsDict

    # g.trace('w',w,d.has_key('Alt+Key-4'))

    for stroke in d.keys():
        k.makeMasterGuiBinding(stroke,w=w)
</t>
<t tx="ekr.20070626112754.1411">def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict.keys():
        k.makeMasterGuiBinding(stroke,w=w)
</t>
<t tx="ekr.20070626112754.1412">def createModeBindings (self,modeName,d,w):

    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''

    __pychecker__ = '--no-argsused' # w not used (except for debugging).

    k = self ; c = k.c

    # g.trace(g.listToString(d.keys()))

    for commandName in d.keys():
        if commandName == '*entry-commands*': continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('No such command: %s. Referenced from %s' % (
                commandName,modeName))
            continue
        bunchList = d.get(commandName,[])
        for bunch in bunchList:
            stroke = bunch.val
            # Important: bunch.val is a stroke returned from k.strokeFromSetting.
            # Do not call k.strokeFromSetting again here!
            if stroke and stroke not in ('None','none',None):
                if 0:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        bunch.nextMode)

                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.Bunch(
                    commandName=commandName,
                    func=func,
                    nextMode=bunch.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2
</t>
<t tx="ekr.20070626112754.1413">def finishCreate (self):

    '''Find or make the @chapters and @chapter trash nodes.'''

    # This must be called late in the init process:
    # at present, called by g.openWithFileName and c.new.

    cc = self ; c = cc.c

    # Create the @chapters node if needed, and set cc.chaptersNode.
    if not cc.chaptersNode and not cc.findChaptersNode():
        cc.createChaptersNode()

    # Create the main chapter
    cc.chaptersDict['main'] = chapter(c=c,chapterController=cc,name='main',root=c.rootPosition())

    tag = '@chapter'
    for p in c.allNodes_iter():
        h = p.headString()
        if h.startswith(tag) and not h.startswith('@chapters'):
            tabName = h[len(tag):].strip()
            if tabName and tabName not in ('main',):
                if cc.chaptersDict.get(tabName):
                    self.error('duplicate chapter name: %s' % tabName)
                else:
                    cc.chaptersDict[tabName] = chapter(c=c,chapterController=cc,name=tabName,root=p)

    cc.selectChapterByName('main')
</t>
<t tx="ekr.20070626112754.1414">@
The major problem was that the code that recycled widgets was initially disabled when using multiple trees.</t>
<t tx="ekr.20070626112754.1415"></t>
<t tx="ekr.20070626112754.1416">def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""

    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
</t>
<t tx="ekr.20070626112754.1417">def destroySelf (self):

    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c

    # Indicate that the commander is no longer valid.
    c.exists = False 

    # g.trace(self)

    # Important: this destroys all the objects of the commander too.
    self.destroyAllObjects()

    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()
</t>
<t tx="ekr.20070626112754.1418"></t>
<t tx="ekr.20070626112754.1419"></t>
<t tx="ekr.20070626112754.1420">@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler

    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
</t>
<t tx="ekr.20070626112754.1421"># Disables the "idle" hook.
def disableIdleTimeHook():

    g.app.idleTimeHook = False
</t>
<t tx="ekr.20070626112754.1422"># An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):

    __pychecker__ = '--no-argsused' # args &amp; keys not used.

    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for z in g.app.windowList:
                c = z.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return

    for z in g.app.windowList:
        c = z.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
</t>
<t tx="ekr.20070626112754.1423">@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. c.hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):

    if g.app.killed or g.app.hookError: # or (g.app.gui and g.app.gui.isNullGui):
        return None

    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag in ('open0','start1'):
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            g.es_print(s,color="blue")
        return None

    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins

    try:
        # Pass the hook to the hook handler.
        # print 'doHook',f.__name__,keywords.get('c')
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
</t>
<t tx="ekr.20070626112754.1424">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.

    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''

    # g.trace('base keyHandler',g.callers())

    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '

    # These must be defined here to avoid memory leaks.
    self.enable_autocompleter           = c.config.getBool('enable_autocompleter_initially')
    self.enable_calltips                = c.config.getBool('enable_calltips_initially')
    self.ignore_caps_lock               = c.config.getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = c.config.getBool('ignore_unbound_non_ascii_keys')
    self.swap_mac_keys                  = c.config.getBool('swap_mac_keys')
    self.trace_bind_key_exceptions      = c.config.getBool('trace_bind_key_exceptions')
    self.trace_masterClickHandler       = c.config.getBool('trace_masterClickHandler')
    self.traceMasterCommand             = c.config.getBool('trace_masterCommand')
    self.trace_masterKeyHandler         = c.config.getBool('trace_masterKeyHandler')
    self.trace_masterKeyHandlerGC       = c.config.getBool('trace_masterKeyHandlerGC')
    self.trace_key_event                = c.config.getBool('trace_key_event')
    self.trace_minibuffer               = c.config.getBool('trace_minibuffer')
    self.warn_about_redefined_shortcuts = c.config.getBool('warn_about_redefined_shortcuts')
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;

    self.defineTkNames()
    self.defineSpecialKeys()
    self.autoCompleter = autoCompleterClass(self)
    self.setDefaultUnboundKeyAction()
</t>
<t tx="ekr.20070626112754.1425">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.previousSelection = None # A hack for middle-button paste: set by masterClickHandler, used by pasteText.
self.state = g.bunch(kind=None,n=None,handler=None)
</t>
<t tx="ekr.20070626112754.1426">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
</t>
<t tx="ekr.20070626112754.1427"># debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
</t>
<t tx="ekr.20070626112754.1428">def clearAllIvars (o):

    """Clear all ivars of o, a member of some class."""

    if o:
        o.__dict__.clear()
</t>
<t tx="ekr.20070626112754.1429">def collectGarbage():

    try:
        if not g.app.trace_gc_inited:
            g.enable_gc_debug()

        if g.app.trace_gc_verbose or g.app.trace_gc_calls:
            # print('Collecting garbage',g.callers())
            print 'collectGarbage:'

        gc.collect()
    except Exception:
        pass

    # Only init once, regardless of what happens.
    g.app.trace_gc_inited = True
</t>
<t tx="ekr.20070626112754.1430">no_gc_message = False

def enable_gc_debug(event=None):

    if gc:
        if g.app.trace_gc_verbose:
            gc.set_debug(
                gc.DEBUG_STATS | # prints statistics.
                gc.DEBUG_LEAK | # Same as all below.
                gc.DEBUG_COLLECTABLE |
                gc.DEBUG_UNCOLLECTABLE |
                gc.DEBUG_INSTANCES |
                gc.DEBUG_OBJECTS |
                gc.DEBUG_SAVEALL
            )
        # else:
            # gc.set_debug(gc.DEBUG_STATS)
    elif not g.no_gc_message:
        g.no_gc_message = True
        g.es('Can not import gc module',color='blue')
</t>
<t tx="ekr.20070626112754.1431"># Formerly called from unit tests.

def printGc(tag=None):

    if not g.app.trace_gc: return None

    tag = tag or g._callerName(n=2)

    printGcObjects(tag=tag)
    printGcRefs(tag=tag)

    if g.app.trace_gc_verbose:
        printGcVerbose(tag=tag)
</t>
<t tx="ekr.20070626112754.1432">def printGcRefs (tag=''):

    refs = gc.get_referrers(app.windowList[0])
    print('-' * 30,tag)

    if g.app.trace_gc_verbose:
        print("refs of", app.windowList[0])
        for ref in refs:
            print(type(ref))
    else:
        print("%d referers" % len(refs))
</t>
<t tx="ekr.20070626112754.1433">def printGcAll (tag=''):

    # Suppress warning about keywords arg not supported in sort.

    tag = tag or g._callerName(n=2)
    d = {} ; objects = gc.get_objects()
    print('-' * 30)
    print('%s: %d objects' % (tag,len(objects)))

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except: pass
        # if type(obj) == type(()):
            # print id(obj),repr(obj)
        d[t] = d.get(t,0) + 1

    if 1: # Sort by n
        items = d.items()
        try:
            # Support for keword args to sort function exists in Python 2.4.
            # Support for None as an alternative to omitting cmp exists in Python 2.3.
            items.sort(key=lambda x: x[1],reverse=True)
        except: pass
        for z in items:
            print '%40s %7d' % (z[0],z[1])
    else: # Sort by type
        keys = d.keys() ; keys.sort()
        for t in keys:
            print '%40s %7d' % (t,d.get(t))
</t>
<t tx="ekr.20070626112754.1434">def printGcObjects(tag=''):

    '''Print newly allocated objects.'''

    tag = tag or g._callerName(n=2)
    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        if delta == 0: return
        lastObjectCount = n2

        &lt;&lt; print number of each type of object &gt;&gt;
        if 0:
            &lt;&lt; print added functions &gt;&gt;

    except Exception:
        traceback.print_exc()

printNewObjects = pno = printGcObjects

</t>
<t tx="ekr.20070626112754.1435">global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    t = type(obj)
    if t == 'instance' and t not in types.StringTypes:
        try: t = obj.__class__
        except: pass
    if t != types.FrameType:
        r = repr(t) # was type(obj) instead of repr(t)
        n = typesDict.get(r,0) 
        typesDict[r] = n + 1

# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

empty = True
for key in keys:
    n3 = lastTypesDict.get(key,0)
    n4 = typesDict.get(key,0)
    delta2 = n4-n3
    if delta2 != 0:
        empty = False
        break

if not empty:
    # keys = [repr(key) for key in keys]
    keys.sort()
    print '-' * 30
    print "%s: garbage: %d, objects: %d, delta: %d" % (tag,n,n2,delta)

    if 0:
        for key in keys:
            n1 = lastTypesDict.get(key,0)
            n2 = typesDict.get(key,0)
            delta2 = n2-n1
            if delta2 != 0:
                print("%+6d =%7d %s" % (delta2,n2,key))

lastTypesDict = typesDict
typesDict = {}
</t>
<t tx="ekr.20070626112754.1436"># import types
import inspect

global lastFunctionsDict

funcDict = {}

# Don't print more than 50 objects.
n = 0
for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        n += 1

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if n &lt; 50 and not lastFunctionsDict.has_key(key):
            print(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            print("args", args)
            if varargs: print("varargs",varargs)
            if varkw: print("varkw",varkw)
            if defaults:
                print("defaults...")
                for s in defaults: print(s)

lastFunctionsDict = funcDict
funcDict = {}
</t>
<t tx="ekr.20070626112754.1437">def printGcSummary (tag=''):

    tag = tag or g._callerName(n=2)

    g.enable_gc_debug()

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = '%s: printGCSummary: garbage: %d, objects: %d' % (tag,n,n2)
        print s
    except:
        traceback.print_exc()
</t>
<t tx="ekr.20070626112754.1438"># WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(tag=''):

    tag = tag or g._callerName(n=2)
    global lastObjectsDict
    objects = gc.get_objects()
    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]

    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o

    dicts = 0 ; seqs = 0

    i = 0 ; n = len(newObjects)
    while i &lt; 100 and i &lt; n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            #print id(o),repr(o)
            seqs += 1
        #else:
        #    print(o)
        i += 1
    print('=' * 40)
    print('dicts: %d, sequences: %d' % (dicts,seqs))
    print("%s: %d new, %d total objects" % (tag,len(newObjects),len(objects)))
    print('-' * 40)
</t>
<t tx="ekr.20070626112754.1439"></t>
<t tx="ekr.20070626112754.1440"></t>
<t tx="ekr.20070626112754.1441"></t>
<t tx="ekr.20070626112754.1442">@ The fix was to g.skip_to_end_of_line (!)

All such functions now return len(s) as a boundary condition.
This is a major change.  All unit tests pass.</t>
<t tx="ekr.20070626112754.1443">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4315027
By: billpage

In Leo 4.4.3 alpha 2 using "Import noweb files" causes Leo to crash. I first
tried omething more complex but I found that even if I create a simple one node
test outline, use "Export Outline to noweb" to create a .nw file then try to
import that noweb file I get the same result.

https://sourceforge.net/forum/message.php?msg_id=4318521
By: billpage

On May 15, 2007 9:48 AM Ralf Hemmecke (another Axiom developer)
sent to me the following example:

Then the first thing I tried was to import a noweb file. I used 
leo-4-4-3-alpha-2 on the following file (dont put the %--- line into the 
file but keep the final empty line.

%---BEGIN asfiles.pl.nw
&lt;&lt;*&gt;&gt;=
Here is the code
@

%---END asfile.pl.nw

LEO hangs itself up. I seem to be unlucky. Unfortunately, I am not a 
python programmer myself so that I could dig into the problem.

I now give up for the second time. The empty line at the end seems not 
the only problem.

I know that LEO has some good ideas, especially I like the cloning 
stuff, but I cannot appreciate LEO not only for the reason that it 
doesn't let me import my files.

-----
http://sourceforge.net/forum/message.php?msg_id=4318542
By: billpage

Here is last part of the the error message traceback that I get
when doing the above test on OpenSuSE 10.2 with Leo 4.4.3 alpha 2:

  ... 
  File "/home/wspage/leo-4-4-3-alpha-2/src/leoImport.py", line 3118, in
isDocStart
    if not g.match(s,i,"@"):

  File "/home/wspage/leo-4-4-3-alpha-2/src/leoGlobals.py", line 3432, in match
    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i

KeyboardInterrupt

wrote /home/wspage/.leoRecentFiles.txt

--------

after hitting Control-C in the console window that started Leo.

</t>
<t tx="ekr.20070626112754.1444">@nocolor
https://sourceforge.net/forum/message.php?msg_id=4315078
By: billpage

I have a similar problem to that described by the author of this thread. I am
one of the developers of the Axiom open source project (see:
http://wiki.axiom-developer.org ). Axiom uses noweb format for all source files
in the distribution and includes C, Lisp, make, awk scripts, Boot, and Spad
code (the last two programming languages specific to Axiom).

Pervasive use of Literate Programming is a accepted goal of the project but
it is not yet fully achieved. We still have many discussions concerning the
merits of different approaches to adding documentation to such a large "illiterate"
legacy code base. (Some of the code in Axiom was written more than 30 years
ago and was never properly documented.) The issue of building "traditional"
(Knuth-style) monolithic book-sized volumes for the various components of Axiom
by merging large numbers of legacy source code files and newly developed
documentation into a small number of noweb files is especially contentious.
Based on information on the Leo web site and experience with the Leo tutorials,
I have repeatedly advocated the use of Leo as an alternative to this traditional
approach. Now some of the other Axiom developers might finally be listening...

But as I said, I have a problem. When I try to import the Axiom noweb files
into Leo I get "odd" results. These files are processed properly by noweb's
notangle and noweave commands but I can not reproduce this using Leo. The
documentation and code chunks (sections) are not always represented as nodes
in the outline in the way I would expect, e.g. I see nodes named "Limbo", "avoiding"
and "center" in addition to most (but not all) of the &lt;&lt; chunk names &gt;&gt; in the
noweb file.  Plus Leo's "Export Weave" command does not produce output that
sufficiently closely resembles the noweave output of noweb. We need/expect to
be able to process this output of weave by LaTeX but it contains other generated
text that is clearly not LaTeX compatible.

More specifically: I do not see any @ignore directive in the root node following
import of the noweb file. Nor do I see any generated @file, @root or other
directives. At the moment I am using "Leo 4.4.2.1 final, build  1.83 , October
29, 2006" from the Windows exe install file, but my comments also apply to the
same version of Leo on Linux.

I have other questions as well concerning customization of Leo's parsing and
generation of comments in target source languages other than Java and C which
I have not found answered in the Leo users guide or tutorials. But I will save
that for another time.

http://wiki.axiom-developer.org
</t>
<t tx="ekr.20070626112754.1445"></t>
<t tx="ekr.20070626112754.1446">def createOutline (self,fileName,parent):

    c = self.c ; u = c.undoer
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".lua", ".pas", ".py", ".pyw", ".php")
    &lt;&lt; Read file into s &gt;&gt;
    # Create the top-level headline.
    undoData = u.beforeInsertNode(parent)
    p = parent.insertAsLastChild()
    if self.treeType == "@file":
        p.initHeadString("@file " + fileName)
    else:
        p.initHeadString(fileName)
    u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        c.setBodyString(p,body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p)
    elif ext == ".el":
        self.scanElispText(s,p)
    elif ext in (".fs", ".fi"):
        self.scanForthText(s,p)
    elif ext == ".java":
        self.scanJavaText(s,p,True) #outer level
    elif ext == ".lua":
        self.scanLuaText(s,p)
    elif ext == ".pas":
        self.scanPascalText(s,p)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p)
    elif ext == ".php":
        self.scanPHPText(s,p) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return p
</t>
<t tx="ekr.20070626112754.1447">try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None
</t>
<t tx="ekr.20070626112754.1448">def getTabWidth (self):

    d = g.scanDirectives(self.c)
    w = d.get("tabwidth")
    if w not in (0,None):
        return w
    else:
        return self.c.tab_width
</t>
<t tx="ekr.20070626112754.1449">def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            g.setGlobalOpenDir(fileName)
            &lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1450">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
</t>
<t tx="ekr.20070626112754.1451">def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)
</t>
<t tx="ekr.20070626112754.1452">def importFilesCommand (self,files=None,treeType=None,
    perfectImport=True,testing=False,verbose=False):
        # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) &lt; 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    c.beginUpdate()
    try: # range of update...
        if len(files) == 2:
            &lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                perfectImport = False ###
                testing = True; verbose = True
                if perfectImport and treeType == "@file": # Can't correct @root trees.
                    self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                else:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    finally:
        c.endUpdate()
    c.selectVnode(current)
</t>
<t tx="ekr.20070626112754.1453">@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) &gt; 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)
</t>
<t tx="ekr.20070626112754.1454"></t>
<t tx="ekr.20070626112754.1455"># Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,firstVnode):
    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

# Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,firstVnode):

    __pychecker__ = '--no-objattrs' # suppress bad warnings re lastVnode.

    c = self.c
    if len(strings) == 0: return None
    if not self.stringsAreValidMoreFile(strings): return None
    c.beginUpdate()
    try: # range of update...
        firstLevel, junk = self.moreHeadlineLevel(strings[0])
        lastLevel = -1 ; theRoot = lastVnode = None
        index = 0
        while index &lt; len(strings):
            progress = index
            s = strings[index]
            level, newFlag = self.moreHeadlineLevel(s)
            level -= firstLevel
            if level &gt;= 0:
                &lt;&lt; Link a new vnode v into the outline &gt;&gt;
                &lt;&lt; Set the headline string, skipping over the leader &gt;&gt;
                &lt;&lt; Count the number of following body lines &gt;&gt;
                &lt;&lt; Add the lines to the body text of v &gt;&gt;
                v.setDirty()
            else: index += 1
            assert progress &lt; index
        if theRoot:
            theRoot.setDirty()
            c.setChanged(True)
    finally:
        c.endUpdate()
    return theRoot
</t>
<t tx="ekr.20070626112754.1456">assert(level &gt;= 0)
if lastVnode is None:
    # g.trace(firstVnode)
    theRoot = v = firstVnode.insertAfter()
elif level == lastLevel:
    v = lastVnode.insertAfter()
elif level == lastLevel + 1:
    v = lastVnode.insertAsNthChild(0)
else:
    assert(level &lt; lastLevel)
    while level &lt; lastLevel:
        lastLevel -= 1
        lastVnode = lastVnode.parent()
        assert(lastVnode)
        assert(lastLevel &gt;= 0)
    v = lastVnode.insertAfter()
lastVnode = v
lastLevel = level
</t>
<t tx="ekr.20070626112754.1457">j = 0
while g.match(s,j,'\t'):
    j += 1
if g.match(s,j,"+ ") or g.match(s,j,"- "):
    j += 2

v.initHeadString(s[j:])
</t>
<t tx="ekr.20070626112754.1458">bodyLines = 0
index += 1 # Skip the headline.
while index &lt; len(strings):
    s = strings[index]
    level, junk = self.moreHeadlineLevel(s)
    level -= firstLevel
    if level &gt;= 0:
        break
    # Remove first backslash of the body line.
    if g.match(s,0,'\\'):
        strings[index] = s[1:]
    bodyLines += 1
    index += 1
</t>
<t tx="ekr.20070626112754.1459">if bodyLines &gt; 0:
    body = ""
    n = index - bodyLines
    while n &lt; index:
        body += strings[n]
        if n != index - 1:
            body += "\n"
        n += 1
    v.setTnodeText(body)
</t>
<t tx="ekr.20070626112754.1460">def importFlattenedOutline (self,files): # Not a command, so no event arg.

    c = self.c ; u = c.undoer ; current = c.currentPosition()
    if current == None: return
    if len(files) &lt; 1: return

    self.setEncoding()
    fileName = files[0] # files contains at most one file.
    g.setGlobalOpenDir(fileName)
    &lt;&lt; Read the file into array &gt;&gt;

    # Convert the string to an outline and insert it after the current node.
    undoData = u.beforeInsertNode(current)
    p = self.convertMoreStringsToOutlineAfter(array,current)
    if p:
        c.endEditing()
        c.validateOutline()
        c.editPosition(p)
        p.setDirty()
        c.setChanged(True)
        u.afterInsertNode(p,'Import',undoData)
    else:
        g.es(fileName + " is not a valid MORE file.")
</t>
<t tx="ekr.20070626112754.1461">try:
    theFile = open(fileName)
    s = theFile.read()
    s = string.replace(s,"\r","")
    s = g.toUnicode(s,self.encoding)
    array = string.split(s,"\n")
    theFile.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return
</t>
<t tx="ekr.20070626112754.1462"># return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel (self,s):

    level = 0 ; i = 0
    while g.match(s,i,'\t'):
        level += 1
        i += 1
    plusFlag = g.choose(g.match(s,i,"+"),True,False)
    if g.match(s,i,"+ ") or g.match(s,i,"- "):
        return level, plusFlag
    else:
        return -1, plusFlag
</t>
<t tx="ekr.20070626112754.1463"># Used by paste logic.

def stringIsValidMoreFile (self,s):

    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.stringsAreValidMoreFile(strings)

def stringsAreValidMoreFile (self,strings):

    if len(strings) &lt; 1: return False
    level1, plusFlag = self.moreHeadlineLevel(strings[0])
    if level1 == -1: return False
    # Check the level of all headlines.
    i = 0 ; lastLevel = level1
    while i &lt; len(strings):
        s = strings[i] ; i += 1
        level, newFlag = self.moreHeadlineLevel(s)
        if level &gt; 0:
            if level &lt; level1 or level &gt; lastLevel + 1:
                return False # improper level.
            elif level &gt; lastLevel and not plusFlag:
                return False # parent of this node has no children.
            elif level == lastLevel and plusFlag:
                return False # last node has missing child.
            else:
                lastLevel = level
                plusFlag = newFlag
    return True
</t>
<t tx="ekr.20070626112754.1464"></t>
<t tx="ekr.20070626112754.1465">def createOutlineFromWeb (self,path,parent):

    c = self.c ; u = c.undoer
    junk,fileName = g.os_path_split(path)

    undoData = u.beforeInsertNode(parent)

    # Create the top-level headline.
    p = parent.insertAsLastChild()
    p.initHeadString(fileName)
    if self.webType=="cweb":
        c.setBodyString(p,"@ignore\n" + self.rootLine + "@language cweb")

    # Scan the file, creating one section for each function definition.
    self.scanWebFile(path,p)

    u.afterInsertNode(p,'Import',undoData)

    return p
</t>
<t tx="ekr.20070626112754.1466">def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.webType = webType

    c.beginUpdate()
    try:
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutlineFromWeb(fileName,current)
            v.contract()
            v.setDirty()
            c.setChanged(True)
        c.selectVnode(current)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1467">def findFunctionDef (self,s,i):

    # Look at the next non-blank line for a function name.
    i = g.skip_ws_and_nl(s,i)
    k = g.skip_line(s,i)
    name = None
    while i &lt; k:
        if g.is_c_id(s[i]):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
        elif s[i] == '(':
            if name: return name
            else: break
        else: i += 1
    return None
</t>
<t tx="ekr.20070626112754.1468">@ This method returns the proper headline text.

1. If s contains a section def, return the section ref.
2. cweb only: if s contains @c, return the function name following the @c.
3. cweb only: if s contains @d name, returns @d name.
4. Otherwise, returns "@"
@c

def scanBodyForHeadline (self,s):

    if self.webType == "cweb":
        &lt;&lt; scan cweb body for headline &gt;&gt;
    else:
        &lt;&lt; scan noweb body for headline &gt;&gt;
    return "@" # default.
</t>
<t tx="ekr.20070626112754.1469">i = 0
while i &lt; len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    # Allow constructs such as @ @c, or @ @&lt;.
    if self.isDocStart(s,i):
        i += 2 ; i = g.skip_ws(s,i)
    if g.match(s,i,"@d") or g.match(s,i,"@f"):
        # Look for a macro name.
        directive = s[i:i+2]
        i = g.skip_ws(s,i+2) # skip the @d or @f
        if i &lt; len(s) and g.is_c_id(s[i]):
            j = i ; g.skip_c_id(s,i) ; return s[j:i]
        else: return directive
    elif g.match(s,i,"@c") or g.match(s,i,"@p"):
        # Look for a function def.
        name = self.findFunctionDef(s,i+2)
        return g.choose(name,name,"outer function")
    elif g.match(s,i,"@&lt;"):
        # Look for a section def.
        # A small bug: the section def must end on this line.
        j = i ; k = g.find_on_line(s,i,"@&gt;")
        if k &gt; -1 and (g.match(s,k+2,"+=") or g.match(s,k+2,"=")):
            return s[j:k+2] # return the section ref.
    i = g.skip_line(s,i)
</t>
<t tx="ekr.20070626112754.1470">i = 0
while i &lt; len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if g.match(s,i,"&lt;&lt;"):
        k = g.find_on_line(s,i,"&gt;&gt;=")
        if k &gt; -1:
            ref = s[i:k+2]
            name = string.strip(s[i+2:k])
            if name != "@others":
                return ref
    else:
        name = self.findFunctionDef(s,i)
        if name:
            return name
    i = g.skip_line(s,i)
</t>
<t tx="ekr.20070626112754.1471">def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")

    try: # Read the file into s.
        f = open(fileName)
        s = f.read()
    except:
        g.es("Can not import " + fileName, color="blue")
        return

    &lt;&lt; Create a symbol table of all section names &gt;&gt;
    &lt;&lt; Create nodes for limbo text and the root section &gt;&gt;
    while i &lt; len(s):
        outer_progress = i
        &lt;&lt; Create a node for the next module &gt;&gt;
        assert(i &gt; outer_progress)</t>
<t tx="ekr.20070626112754.1472">i = 0 ; self.web_st = []

while i &lt; len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if self.isDocStart(s,i):
        if theType == "cweb": i += 2
        else: i = g.skip_line(s,i)
    elif theType == "cweb" and g.match(s,i,"@@"):
        i += 2
    elif g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k &gt; -1: self.cstEnter(s[j:k])
    else: i += 1
    assert (i &gt; progress)

# g.trace(self.cstDump())
</t>
<t tx="ekr.20070626112754.1473">i = 0
while i &lt; len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isModuleStart(s,i) or g.match(s,i,lb):
        break
    else: i = g.skip_line(s,i)
    assert(i &gt; progress)

j = g.skip_ws(s,0)
if j &lt; i:
    self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if g.match(s,i,lb):
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        else: i = g.skip_line(s,i)
        assert(i &gt; progress)
    self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

# g.trace(g.get_line(s,i))
</t>
<t tx="ekr.20070626112754.1474">if theType=="cweb":
    assert(self.isModuleStart(s,i))
    start = i
    if self.isDocStart(s,i):
        i += 2
        while i &lt; len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i): break
            else: i = g.skip_line(s,i)
            assert (i &gt; progress)
    &lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;
else:
    assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
    start = i ; i = g.skip_line(s,i)
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i): break
        else: i = g.skip_line(s,i)
        assert (i &gt; progress)

body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20070626112754.1475">if g.match(s,i,"@d") or g.match(s,i,"@f"):
    i += 2 ; i = g.skip_line(s,i)
    # Place all @d and @f directives in the same node.
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
        else: break
        assert (i &gt; progress)
    i = g.skip_ws_and_nl(s,i)

while i &lt; len(s) and not self.isModuleStart(s,i):
    progress = i
    i = g.skip_line(s,i)
    i = g.skip_ws_and_nl(s,i)
    assert (i &gt; progress)

if g.match(s,i,"@c") or g.match(s,i,"@p"):
    i += 2
    while i &lt; len(s):
        progress = i
        i = g.skip_line(s,i)
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        assert (i &gt; progress)
</t>
<t tx="ekr.20070626112754.1476"></t>
<t tx="ekr.20070626112754.1477"># We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.

def cstCanonicalize (self,s,lower=True):

    if lower:
        s = string.lower(s)
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"\r","")
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
</t>
<t tx="ekr.20070626112754.1478">def cstDump (self):

    self.web_st.sort()
    s = "Web Symbol Table...\n\n"
    for name in self.web_st:
        s += name + "\n"
    return s
</t>
<t tx="ekr.20070626112754.1479"># We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

    # Don't enter names that end in "..."
    s = string.rstrip(s)
    if s.endswith("..."): return

    # Put the section name in the symbol table, retaining capitalization.
    lower = self.cstCanonicalize(s,True)  # do lower
    upper = self.cstCanonicalize(s,False) # don't lower.
    for name in self.web_st:
        if string.lower(name) == lower:
            return
    self.web_st.append(upper)
</t>
<t tx="ekr.20070626112754.1480"># This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):

    # Do nothing if the ... convention is not used.
    target = string.strip(target)
    if not target.endswith("..."): return target
    # Canonicalize the target name, and remove the trailing "..."
    ctarget = target[:-3]
    ctarget = self.cstCanonicalize(ctarget)
    ctarget = string.strip(ctarget)
    found = False ; result = target
    for s in self.web_st:
        cs = self.cstCanonicalize(s)
        if cs[:len(ctarget)] == ctarget:
            if found:
                g.es("****** " + target + ": is also a prefix of: " + s)
            else:
                found = True ; result = s
                # g.es("replacing: " + target + " with: " + s)
    return result
</t>
<t tx="ekr.20070626112754.1481">def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):

    __pychecker__ = 'maxlines=500'

    &lt;&lt; about this algorithm &gt;&gt;
    c = self.c
    root = p.copy()
    at = c.atFileCommands
    if testing:
        &lt;&lt; clear all dirty bits &gt;&gt;
    &lt;&lt; Assign file indices &gt;&gt;
    &lt;&lt; Write root's tree to to string s &gt;&gt;

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()

    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 1: # For testing.
            &lt;&lt; put the corrected fat lines in a new node &gt;&gt;
        &lt;&lt; correct root's tree using write_lines &gt;&gt;
    if verify:
        &lt;&lt; verify that writing the tree would produce the original file &gt;&gt;
</t>
<t tx="ekr.20070626112754.1482">@nocolor
@

This algorithm corrects the result of an Import To @file command so that it is guaranteed that the result of writing the imported file will be identical to the original file except for any sentinels that have been inserted.

On entry, p points to the newly imported outline.

We correct the outline by applying Bernhard Mulder's algorithm.

1.  We use the atFile.write code to write the newly imported outline to a string s.  This string contains represents a thin derived file, so it can be used to recreate then entire outline structure without any other information.

Splitting s into lines creates the fat_lines argument to mu methods.

2. We make corrections to fat_lines using Mulder's algorithm.  The corrected fat_lines represents the corrected outline.  To do this, we set the arguments as follows:

- i_lines: fat_lines stripped of sentinels
- j_lines to the lines of the original imported file.

The algorithm updates fat_lines using diffs between i_lines and j_lines.

3. Mulder's algorithm doesn't specify which nodes have been changed.  In fact, it Mulder's algorithm doesn't really understand nodes at all.  Therefore, if we want to mark changed nodes we do so by comparing the original version of the imported outline with the corrected version of the outline.
</t>
<t tx="ekr.20070626112754.1483">for p2 in p.self_and_subtree_iter():
    p2.clearDirty()
</t>
<t tx="ekr.20070626112754.1484">nodeIndices = g.app.nodeIndices

nodeIndices.setTimestamp()

for p2 in root.self_and_subtree_iter():
    try: # Will fail for None or any pre 4.1 file index.
        theId,time,n = p2.v.t.fileIndex
    except TypeError:
        p2.v.t.fileIndex = nodeIndices.getNewIndex()
</t>
<t tx="ekr.20070626112754.1485">at.write(root,thinFile=True,toString=True)
s = at.stringOutput
if not s: return
</t>
<t tx="ekr.20070626112754.1486">write_lines_node = root.insertAfter()
write_lines_node.initHeadString("write_lines")
s = ''.join(write_lines)
write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.1487">@ Notes:
1. This code must overwrite the newly-imported tree because the gnx's in
write_lines refer to those nodes.

2. The code in readEndNode now reports when nodes change during importing. This
code also marks changed nodes.
@c

try:
    at.correctedLines = 0
    at.targetFileName = "&lt;perfectImport string-file&gt;"
    at.inputFile = fo = g.fileLikeObject()
    at.file = fo # Strange, that this is needed.  Should be cleaned up.
    for line in write_lines:
        fo.write(line)
    firstLines,junk,junk = c.atFileCommands.scanHeader(fo,at.targetFileName)
    # To do: pass params to readEndNode.
    at.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
    n = at.correctedLines
    if verbose:
        g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
except:
    g.es("Exception in Perfect Import",color="red")
    g.es_exception()
    s = None
</t>
<t tx="ekr.20070626112754.1488">try:
    # Read the original file into before_lines.
    before = file(fileName)
    before_lines = before.readlines()
    before.close()

    # Write the tree into after_lines.
    at.write(root,thinFile=True,toString=True)
    after_lines1 = g.splitLines(at.stringOutput)

    # Strip sentinels from after_lines and compare.
    after_lines = mu.removeSentinelsFromLines(after_lines1,delims)

    # A major kludge: Leo can not represent unindented blank lines in indented nodes!
    # We ignore the problem here by stripping whitespace from blank lines.
    # We shall need output options to handle such lines.
    if convertBlankLines:
        mu.stripWhitespaceFromBlankLines(before_lines)
        mu.stripWhitespaceFromBlankLines(after_lines)
    if before_lines == after_lines:
        if verbose:
            g.es("Perfect Import verified",color="blue")
    else:
        leoTest.fail()
        if verbose:
            g.es("Perfect Import failed verification test!",color="red")
            &lt;&lt; dump the files &gt;&gt;
except IOError:
    g.es("Can not reopen %s!" % fileName,color="red")
    leoTest.fail()
</t>
<t tx="ekr.20070626112754.1489">print len(before_lines),len(after_lines)

if len(before_lines)==len(after_lines):
    for i in xrange(len(before_lines)):
        extra = 3
        if before_lines[i] != after_lines[i]:
            j = max(0,i-extra)
            print '-' * 20
            while j &lt; i + extra + 1:
                leader = g.choose(i == j,"* ","  ")
                print "%s%3d" % (leader,j), repr(before_lines[j])
                print "%s%3d" % (leader,j), repr(after_lines[j])
                j += 1
else:
    for i in xrange(min(len(before_lines),len(after_lines))):
        if before_lines[i] != after_lines[i]:
            extra = 5
            print "first mismatch at line %d" % i
            print "printing %d lines after mismatch" % extra
            print "before..."
            for j in xrange(i+1+extra):
                print "%3d" % j, repr(before_lines[j])
            print
            print "after..."
            for k in xrange(1+extra):
                print "%3d" % (i+k), repr(after_lines[i+k])
            print
            print "with sentinels"
            j = 0 ; k = 0
            while k &lt; i + 1 + extra:
                print "%3d" % k,repr(after_lines1[j])
                if not g.is_sentinel(after_lines1[j],delims):
                    k += 1
                j += 1
            break
</t>
<t tx="ekr.20070626112754.1490"></t>
<t tx="ekr.20070626112754.1491"></t>
<t tx="ekr.20070626112754.1492">def scanPythonClass (self,s,i,start,parent):

    """Creates a child node c of parent for the class, and children of c for each def in the class."""

    # g.trace(g.get_line(s,i))
    c = self.c
    class_indent = self.getLeadingIndent(s,i)
    &lt;&lt; set class_name and headline &gt;&gt;
    if not class_name: return i
    i = g.skip_line(s,i) # Skip the class line.
    i,prefix,body = self.createClassNodeText(s,i,start)
    class_vnode = self.createHeadline(parent,prefix + body,headline)
    savedMethodName = self.methodName
    self.methodName = headline
    # Create a node for leading declarations of the class.
    i = self.scanPythonDecls(s,i,class_vnode,class_indent,indent_parent_ref_flag=True)
    start,i = self.scanPythonClassHelper(s,i,class_indent,class_name,class_vnode)
    s2 = s[start:i]
    if s2: c.appendStringToBody(class_vnode,s2)
    self.methodName = savedMethodName
    return i
</t>
<t tx="ekr.20070626112754.1493"># Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i &lt; len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    class_name = s[j:i]
    headline = "class " + class_name
else:
    headline = ''
    class_name = ''
</t>
<t tx="ekr.20070626112754.1494">def scanPythonClassHelper(self,s,i,class_indent,class_name,class_vnode):

    indent =  self.getLeadingIndent(s,i)
    start = i = g.skip_blank_lines(s,i)
    parent_vnode = None
    while i &lt; len(s):
        progress = i
        # New in Leo 4.4.1: ignore comment lines, whatever their indentation.
        if indent &lt;= class_indent:
            j = g.skip_ws(s,i)
            if g.match(s,j,'#'):
                i = g.skip_to_end_of_line(s,j)
            else: break
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
            j = g.skip_nl(s,i)
            if not backslashNewline:
                indent = self.getLeadingIndent(s,j)
                if indent &gt; class_indent: i = j
                else: break
            else: i = j
        elif g.match_c_word(s,i,"def"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonDef(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif g.match_c_word(s,i,"class"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonClass(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
        elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
        else: i += 1
        assert(progress &lt; i)
    return start,i
</t>
<t tx="ekr.20070626112754.1495">def createParentText (self,class_vnode,class_name):

    '''Insert the proper body text in the class_vnode.'''

    c = self.c

    # This must be done after the declaration reference is generated.
    if self.treeType == "@file":
        c.appendStringToBody(class_vnode,"\t@others\n")
    else:
        ref = g.angleBrackets(' class %s methods ' % (class_name))
        c.appendStringToBody(class_vnode,"\t" + ref + "\n\n")
</t>
<t tx="ekr.20070626112754.1496">def createClassNodeText (self,s,i,start):

    # Create the section name using the old value of self.methodName.
    if  self.treeType == "@file":
        prefix = ""
    else:
        prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
        self.methodsSeen = True

    # i points just after the class line.

    # Add a docstring to the class node.
    docStringSeen = False
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j != len(s): # No scanning error.
            i = j ; docStringSeen = True

    body = s[start:i]
    body = self.undentBody(body)
    if docStringSeen: body = body + '\n'

    return i,prefix,body
</t>
<t tx="ekr.20070626112754.1497">def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    &lt;&lt; set headline or return i &gt;&gt;
    i = self.skipPythonDef(s,i,start)
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    &lt;&lt; Create def node &gt;&gt;
    self.methodName = savedMethodName
    return i
</t>
<t tx="ekr.20070626112754.1498">i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i &lt; len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i
</t>
<t tx="ekr.20070626112754.1499"># Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)
</t>
<t tx="ekr.20070626112754.1500">def scanPythonDecls (self,s,i,parent,indent,indent_parent_ref_flag=True):

    c = self.c
    done = False ; start = i
    while not done and i &lt; len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n':
            backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            # 2/14/03: break on lesser indention.
            j = g.skip_ws(s,i)
            if not g.is_nl(s,j) and not g.match(s,j,"#") and not backslashNewline:
                lineIndent = self.getLeadingIndent(s,i)
                if lineIndent &lt;= indent:
                    break
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            &lt;&lt; break on def or class &gt;&gt;
        else: i += 1
        assert(progress &lt; i)
    j = g.skip_blank_lines(s,start)
    if g.is_nl(s,j): j = g.skip_nl(s,j)
    if j &lt; i:
        &lt;&lt; Create a child node for declarations &gt;&gt;
    return i
</t>
<t tx="ekr.20070626112754.1501">if g.match_c_word(s,i,"def") or g.match_c_word(s,i,"class"):
    i = g.find_line_start(s,i)
    done = True
    break
else:
    i = g.skip_c_id(s,i)
</t>
<t tx="ekr.20070626112754.1502">headline = ref = g.angleBrackets(" " + self.methodName + " declarations ")
leading_tab = g.choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
c.appendStringToBody(parent,leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
    body = "@code\n\n" + body
self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20070626112754.1503"># See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    c = self.c
    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i &lt; len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            &lt;&lt; handle possible Python function or class &gt;&gt;
        else: i += 1
        assert(progress &lt; i)
    if not decls_seen: # 2/17/03
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
    &lt;&lt; Append a reference to the methods of this file &gt;&gt;
    &lt;&lt; Append any unused python text to the parent's body text &gt;&gt;
</t>
<t tx="ekr.20070626112754.1504">if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file":
            c.appendStringToBody(parent,"@others\n")
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)
</t>
<t tx="ekr.20070626112754.1505">if self.treeType == "@root" and self.methodsSeen:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
</t>
<t tx="ekr.20070626112754.1506"># Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i &lt; len(s):
    c.appendStringToBody(parent,s[start:])
</t>
<t tx="ekr.20070626112754.1507">def skipPythonDef (self,s,i,start):

    # g.trace(g.get_line(s,i))

    # Set defIndent to the indentation of the def line.
    defIndent = self.getLeadingIndent(s,start)
    parenCount = 0
    &lt;&lt; skip the entire signature &gt;&gt;
    indent = self.getLeadingIndent(s,i)
    while i &lt; len(s): # and indent &gt; defIndent
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            if not backslashNewline:
                # New in Leo 4.4.1: don't set indent for comment lines.
                j = g.skip_ws(s,i)
                if not g.match(s,j,'#'):
                    indent = self.getLeadingIndent(s,i)
                    if indent &lt;= defIndent and parenCount == 0:
                        break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress &lt; i)

    return i
</t>
<t tx="ekr.20070626112754.1508"># Now that we count parens, we must be careful to skip the entire signature.

j = s.find('(',i)
if j != -1:
    j = g.skip_matching_python_parens(s,j)

if j == -1 or not g.match(s,j+1,':'):
    g.es_print('Warning: improper signature: %s' % g.get_line(s,i))
    return i
else:
    i = g.skip_line(s,j) # Still not quite 100% correct.
</t>
<t tx="ekr.20070626112754.1509">if g.unitTesting:

    c,p = g.getTestVars()
    self = c.importCommands

    # global c # Get syntax warning if this is not first.
    # if self: c = self.c             # Run from @test node: c not global
    # else: self = c.importCommands   # Run from @suite: c *is* global
    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    &lt;&lt; define s &gt;&gt;
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test1') and result.endswith('return 1'),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test2') and result.endswith('pass'),'result:\n%s' % result
</t>
<t tx="ekr.20070626112754.1510">s = '''\
def test1():
    aList = (a,
b,c)
# underindented comment.
    return 1

def test2():
# underindented comment.
    pass
'''

s = g.adjustTripleString(s,self.tab_width)
</t>
<t tx="ekr.20070626112754.1511">if g.unitTesting:

    c,p = g.getTestVars()
    self = c.importCommands

    # global c # Get syntax warning if this is not first.
    # if self: c = self.c             # Run from @test node: c not global
    # else: self = c.importCommands   # Run from @suite: c *is* global

    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    &lt;&lt; define s &gt;&gt;
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test1') and result.endswith('return 1'),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test2') and result.endswith('return 2'),'result:\n%s' % result
</t>
<t tx="ekr.20070626112754.1512">s = '''\
def test1(
        a=2):
    return 1

def test2(
a=3):
    return 2
'''

s = g.adjustTripleString(s,self.tab_width)
</t>
<t tx="ekr.20070626112754.1513">if g.unitTesting:

    c,p = g.getTestVars()
    self = c.importCommands

    # global c # Get syntax warning if this is not first.
    # if self: c = self.c             # Run from @test node: c not global
    # else: self = c.importCommands   # Run from @suite: c *is* global

    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    &lt;&lt; define s &gt;&gt;
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('class aClass') and result.endswith("'eggs'"),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('class aClass2') and result.endswith("'twit'"),'result:\n%s' % result
</t>
<t tx="ekr.20070626112754.1514">s = '''\
class aClass:
    def spam():
        return 'spam'
# underindented comment line
    def eggs():
        return 'eggs'

class aClass2:
    def twit():
        return 'twit'
'''

s = g.adjustTripleString(s,self.tab_width)
</t>
<t tx="ekr.20070626112754.1515">def scanElispText(self,s,p):

    c = self.c
    c.appendStringToBody(p,"@ignore\n@language elisp\n")
    i = 0 ; start = 0
    while i &lt; len(s):
        progress = i
        ch = s[i] ; # g.trace(g.get_line(s,i))
        if ch == ';':
            i = g.skip_line(s,i)
        elif ch == '(':
            j = self.skipElispParens(s,i)
            k = g.skip_ws(s,i+1)
            if g.match_word(s,k,"defun") or g.match_word(s,k,"defconst") or g.match_word(s,k,"defvar"):
                data = s[start:i]
                if data.strip():
                    self.createElispDataNode(p,data)
                self.createElispFunction(p,s[i:j+1])
                start = j+1
            i = j
        else:
            i += 1
        assert(progress &lt; i)
    data = s[start:len(s)]
    if data.strip():
        self.createElispDataNode(p,data)
</t>
<t tx="ekr.20070626112754.1516">def skipElispParens (self,s,i):

    level = 0 ; n = len(s)
    assert(g.match(s,i,'('))

    while i &lt; n:
        c = s[i]
        if c == '(':
            level += 1 ; i += 1
        elif c == ')':
            level -= 1
            if level &lt;= 0:
                return i
            i += 1
        elif c == '"': i = g.skip_string(s,i) # Single-quotes are not strings.
        elif g.match(s,i,";"):  i = g.skip_line(s,i)
        else: i += 1
    return i
</t>
<t tx="ekr.20070626112754.1517">def skipElispId (self,s,i):

    n = len(s)
    while i &lt; n and g.isWordChar(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20070626112754.1518">def createElispFunction (self,p,s):

    body = s
    i = 1 # Skip the '('
    i = g.skip_ws(s,i)

    # Set the prefix in the headline.
    assert(g.match(s,i,"defun") or g.match_word(s,i,"defconst") or g.match_word(s,i,"defvar"))
    if g.match_word(s,i,"defconst"):
        prefix = "const "
    elif g.match_word(s,i,"defvar"):
        prefix = "var "
    else:
        prefix = ""

    # Skip the "defun" or "defconst" or "defvar"
    i = self.skipElispId(s,i)

    # Get the following id.
    i = g.skip_ws(s,i)
    j = self.skipElispId(s,i)
    theId = prefix + s[i:j]

    self.createHeadline(p,body,theId)
</t>
<t tx="ekr.20070626112754.1519">def createElispDataNode (self,p,s):

    data = s
    # g.trace(len(data))

    # Skip blank lines and comment lines.
    i = 0
    while i &lt; len(s):
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,';'):
            i = g.skip_line(s,i)
        else: break

    # Find the next id, probably prefixed by an open paren.
    if g.match(s,i,"("):
        i = g.skip_ws(s,i+1)
    j = self.skipElispId(s,i)
    theId = s[i:j]
    if not theId:
        theId = "unnamed data"

    self.createHeadline(p,data,theId)
</t>
<t tx="ekr.20070626112754.1520">def scanForthText (self,s,parent):

    """Minimal forth scanner - leave it to user to create nodes as they see fit."""

    self.c.setBodyString(parent,"@ignore\n" + "@language forth\n" + self.rootLine + s)
</t>
<t tx="ekr.20070626112754.1521"># Creates a child of parent for each Java function definition seen.

def scanJavaText (self,s,parent,outerFlag): # True if at outer level.

    __pychecker__ = 'maxlines=500'

    &lt;&lt; define scanJavaText vars &gt;&gt;
    # if not outerFlag: g.trace("inner:",s)
    while i &lt; len(s):
        # g.trace(g.get_line(s,i))
        ch = s[i]
        # These cases skip tokens.
        if ch == '/':
            &lt;&lt; handle possible Java comments &gt;&gt;
        elif ch == '"' or ch == '\'': i = g.skip_string(s,i)
        # These cases help determine where functions start.
        elif ch == '=':
            &lt;&lt; handle equal sign in Java &gt;&gt;
        elif ch == '(':
            &lt;&lt; handle open paren in Java &gt;&gt;
        elif ch == ';':
            &lt;&lt; handle semicolon in Java &gt;&gt;
            class_seen = False
        # These cases can create child nodes.
        elif ch == '{':
            &lt;&lt; handle open curly bracket in Java &gt;&gt;
        elif g.is_c_id(s[i]):
            &lt;&lt; skip and remember the Java id &gt;&gt;
        else: i += 1
    &lt;&lt; Append any unused text to the parent's body text &gt;&gt;
</t>
<t tx="ekr.20070626112754.1522">c = self.c
method_seen = False
class_seen = False # True: class keyword seen at outer level.
interface_seen = False # True: interface keyword seen at outer level.
lparen = None  # not None if '(' seen at outer level.
scan_start = 0
name = None
function_start = 0 # g.choose(outerFlag, None, 0)
i = 0
</t>
<t tx="ekr.20070626112754.1523">if g.match(s,i,"//"):
    i = g.skip_line(s,i)
elif g.match(s,i,"/*"):
    i = g.skip_block_comment(s,i)
else:
    i += 1
</t>
<t tx="ekr.20070626112754.1524">@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = 0 # 3/23/03: (bug fix: was None) We can't be in a function.
lparen = None   # We have not seen an argument list yet.
if g.match(s,i,'='):
    i = g.skip_braces(s,i)
</t>
<t tx="ekr.20070626112754.1525">lparen = i
# This will skip any equal signs inside the paren.
i = g.skip_parens(s,i)
if g.match(s,i,')'):
    i += 1
    i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,';'):
        lparen = None # not a function definition.
else: lparen = None
</t>
<t tx="ekr.20070626112754.1526">@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
    function_start = i + 1 # The semicolon ends the declaration.
</t>
<t tx="ekr.20070626112754.1527">brace_ip1 = i
i = g.skip_braces(s,i) # Skip all inner blocks.
brace_ip2 = i

if not g.match (s,i,'}'):
    g.es("unmatched '{'")
elif not name:
    i += 1
elif (outerFlag and (class_seen or interface_seen)) or (not outerFlag and lparen):
    # g.trace("starting:",name)
    # g.trace("outerFlag:",outerFlag)
    # g.trace("lparen:",lparen)
    # g.trace("class_seen:",class_seen)
    # g.trace("scan_start:",g.get_line_after(s,scan_start))
    # g.trace("func_start:",g.get_line_after(s,function_start))
    # g.trace("s:",g.get_line(s,i))

    # Point i _after_ the last character of the method.
    i += 1
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
    function_end = i
    headline = name
    if outerFlag:
        leader = "" ; decl_leader = ""
        if class_seen:
            headline = "class " + headline
            methodKind = "classes"
        else:
            headline = "interface " + headline
            methodKind = "interfaces"
    else:
        leader = "\t" # Indent only inner references.
        decl_leader = "\n"  # Declaration leader for inner references.
        methodKind = "methods"
    if method_seen:
        # Include everything after the last fucntion.
        function_start = scan_start
    else:
        &lt;&lt; create a Java declaration node &gt;&gt;
        &lt;&lt; append Java method reference to parent node &gt;&gt;
    if outerFlag: # Create a class.
        # Backtrack so we remove leading whitespace.
        function_start = g.find_line_start(s,function_start)
        body = s[function_start:brace_ip1+1]
        body = self.massageBody(body,methodKind)
        v = self.createHeadline(parent,body,headline)
        &lt;&lt; recursively scan the text &gt;&gt;
        # Append the brace to the parent.
        c.appendStringToBody(v,"}")
        i = brace_ip2 + 1 # Start after the closing brace.
    else: # Create a method.
        # Backtrack so we remove leading whitespace.
        function_start = g.find_line_start(s,function_start)
        body = s[function_start:function_end]
        body = self.massageBody(body,methodKind)
        self.createHeadline(parent,body,headline)
        i = function_end
    method_seen = True
    scan_start = function_start = i # Set the start of the _next_ function.
    lparen = None ; class_seen = False
else: i += 1
</t>
<t tx="ekr.20070626112754.1528">save_ip = i
i = scan_start
while i &lt; function_start and g.is_ws_or_nl(s,i):
    i += 1

if outerFlag:
    c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language java\n")

if i &lt; function_start:
    decl_headline = g.angleBrackets(" " + self.methodName + " declarations ")

    # Append the headline to the parent's body.
    c.appendStringToBody(parent,decl_leader + leader + decl_headline + "\n")
    scan_start = g.find_line_start(s,scan_start) # Backtrack so we remove leading whitespace.
    decls = s[scan_start:function_start]
    decls = self.undentBody(decls)
    body = g.choose(self.treeType == "@file",decls,"@code\n\n" + decls)
    self.createHeadline(parent,body,decl_headline)

i = save_ip
scan_start = i
</t>
<t tx="ekr.20070626112754.1529">if self.treeType == "@file":
    if outerFlag:
        c.appendStringToBody(parent,"\n@others\n")
    else:
        c.appendStringToBody(parent,"\n\t@others\n")
else:
    kind = g.choose(outerFlag,"classes","methods")
    ref_name = g.angleBrackets(" " + self.methodName + " " + kind + " ")
    c.appendStringToBody(parent,leader + ref_name + "\n")
</t>
<t tx="ekr.20070626112754.1530"># These mark the points in the present function.
# g.trace("recursive scan:",g.get_line(s,brace_ip1+ 1))
oldMethodName = self.methodName
self.methodName = headline
self.scanJavaText(s[brace_ip1+1:brace_ip2], # Don't include either brace.
    v,False) # inner level
self.methodName = oldMethodName
</t>
<t tx="ekr.20070626112754.1531">if g.match_c_word(s,i,"class") or g.match_c_word(s,i,"interface"):
    if g.match_c_word(s,i,"class"):
        class_seen = True
    else:
        interface_seen = True
    i = g.skip_c_id(s,i) # Skip the class or interface keyword.
    i = g.skip_ws_and_nl(s,i)
    if i &lt; len(s) and g.is_c_id(s[i]):
        # Remember the class or interface name.
        j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
else:
    j = i ; i = g.skip_c_id(s,i)
    if not lparen and not class_seen:
        name = s[j:i] # Remember the name.
</t>
<t tx="ekr.20070626112754.1532"># Used by the Java and Pascal scanners.

i = g.skip_ws_and_nl(s,scan_start)
if i &lt; len(s):
    c.appendStringToBody(parent,s[scan_start:])
</t>
<t tx="ekr.20070626112754.1533">def scanLuaText (self,s,parent):

    """Minimal Lua scanner - leave it to user to create nodes as they see fit."""

    self.c.setBodyString(parent,"@ignore\n" + "@language lua\n" + self.rootLine + s)
</t>
<t tx="ekr.20070626112754.1534"># Creates a child of parent for each Pascal function definition seen.

def scanPascalText (self,s,parent):

    c = self.c
    method_seen = False ; methodKind = "methods"
    scan_start = function_start = i = 0
    name = None
    while i &lt; len(s):
        # line = g.get_line(s,i) ; g.trace(line)
        ch = s[i]
        if ch == '{': i = g.skip_pascal_braces(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_pascal_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.is_c_id(s[i]):
            &lt;&lt; handle possible Pascal function &gt;&gt;
        else: i += 1
    &lt;&lt; Append any unused text to the parent's body text &gt;&gt;
</t>
<t tx="ekr.20070626112754.1535">if g.match_c_word(s,i,"begin"):
    i = g.skip_pascal_begin_end(s,i)
    if g.match_c_word(s,i,"end"):
        i = g.skip_c_id(s,i)
elif (g.match_c_word(s,i,"function")  or g.match_c_word(s,i,"procedure") or
    g.match_c_word(s,i,"constructor") or g.match_c_word(s,i,"destructor")):

    # line = g.get_line(s,i) ; g.trace(line)

    start = i
    i = g.skip_c_id(s,i)
    i = g.skip_ws_and_nl(s,i)
    &lt;&lt; remember the function name, or continue &gt;&gt;
    &lt;&lt; skip the function definition, or continue &gt;&gt;
    if not method_seen:
        method_seen = True
        &lt;&lt; create a child node for leading declarations &gt;&gt;
        &lt;&lt; append noweb method reference to the parent node &gt;&gt;
        function_start = start
    else: function_start = scan_start
    &lt;&lt; create a child node for the function &gt;&gt;
else: i = g.skip_c_id(s,i)
</t>
<t tx="ekr.20070626112754.1536">if i &lt; len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    while i + 1 &lt; len(s) and s[i] == '.' and g.is_c_id(s[i+1]):
        i += 1 ; j = i
        i = g.skip_c_id(s,i)
    name = s[j:i]
else: continue
</t>
<t tx="ekr.20070626112754.1537">&lt;&lt; skip past the semicolon &gt;&gt;

if not g.match_c_word(s,i,"begin"):
    continue
# Skip to the matching end.
i = g.skip_pascal_begin_end(s,i)
if g.match_c_word(s,i,"end"):
    i = g.skip_c_id(s,i)
    i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,';'):
        i += 1
    i = g.skip_ws(s,i)
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
else: continue
</t>
<t tx="ekr.20070626112754.1538">while i &lt; len(s) and s[i] != ';':
    # The paremeter list may contain "inner" semicolons.
    if s[i] == '(':
        i = g.skip_parens(s,i)
        if g.match(s,i,')'):
            i += 1
        else: break
    else: i += 1
if g.match(s,i,';'):
    i += 1
i = g.skip_ws_and_nl(s,i)

if g.match_c_word(s,i,"var"):
    # Skip to the next begin.
    i = g.skip_c_id(s,i)
    done = False
    while i &lt; len(s) and not done:
        ch = s[i]
        if ch == '{': i = g.skip_pascal_braces(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.is_c_id(ch):
            if g.match_c_word(s,i,"begin"): done = True
            else: i = g.skip_c_id(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_pascal_string(s,i)
        else: i += 1
</t>
<t tx="ekr.20070626112754.1539">save_ip = i
i = scan_start
while i &lt; start and g.is_ws_or_nl(s,i):
    i += 1
if i &lt; start:
    c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language pascal\n")
    headline = g.angleBrackets(self.methodName + " declarations ")
    # Append the headline to the parent's body.
    c.appendStringToBody(parent,headline + "\n")
    if self.treeType == "@file":
        body = s[scan_start:start]
    else:
        body = "@code\n\n" + s[scan_start:start]
    body = self.undentBody(body)
    self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i
</t>
<t tx="ekr.20070626112754.1540"># Append the headline to the parent's body.
if self.treeType == "@file":
    c.appendStringToBody(parent,"@others\n")
else:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n")
</t>
<t tx="ekr.20070626112754.1541"># Point i _after_ the last character of the function.
i = g.skip_ws(s,i)
if g.is_nl(s,i):
    i = g.skip_nl(s,i)
function_end = i
headline = name
body = s[function_start:function_end]
body = self.massageBody(body,methodKind)
self.createHeadline(parent,body,headline)
scan_start = i
</t>
<t tx="ekr.20070626112754.1542"># 08-SEP-2002 DTHEIN: Added for PHP import support.
#
# PHP uses both # and // as line comments, and /* */ as block comments

def scanPHPText (self,s,parent):

    __pychecker__ = 'maxlines=500'

    """Creates a child of parent for each class and function definition seen."""

    &lt;&lt; define scanPHPText vars &gt;&gt;
    &lt;&lt; Append file if not pure PHP &gt;&gt;

    # 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
    c.appendStringToBody(parent,"@first ")
    c.appendStringToBody(parent,s[:startOfCode])
    scan_start = i = startOfCode
    while i &lt; endOfCode:
        # line = g.get_line(s,i) ; g.trace(line)
        ch = s[i]
        # These cases skip tokens.
        if ch == '/' or ch == '#':
            &lt;&lt; handle possible PHP comments &gt;&gt;
        elif ch == '&lt;':
            &lt;&lt; handle possible heredoc string &gt;&gt;
        elif ch == '"' or ch == '\'':
            i = g.skip_string(s,i)
        # These cases help determine where functions start.
        # FIXME: probably want to capture 'var's as class member data
        elif ch == 'f' or ch =='c':
            &lt;&lt; handle possible class or function &gt;&gt;
        elif class_start and (ch == '}'):
            &lt;&lt; handle end of class &gt;&gt;
        else: i += 1
    &lt;&lt; Append any unused text to the parent's body text &gt;&gt;
    # 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
    c.appendStringToBody(parent,"@last ")
    c.appendStringToBody(parent,s[endOfCode:])
</t>
<t tx="ekr.20070626112754.1543">c = self.c
scan_start = 0
class_start = 0
function_start = 0
i = 0
class_body = ""
class_node = ""
phpClassName = re.compile("class\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")
phpFunctionName = re.compile("function\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")

# 14-SEP-2002 DTHEIN: added these 2 variables to allow use of @first/last
startOfCode = s.find("\n") + 1 # this should be the line containing the initial &lt;?php
endOfCode = s.rfind("?&gt;") # this should be the line containing the last ?&gt;
</t>
<t tx="ekr.20070626112754.1544"># If the file does not begin with &lt;?php or end with ?&gt; then
# it is simply appended like a generic import would do.

s.strip() # Remove inadvertent whitespace.

if (
    not (
        s.startswith("&lt;?P") or
        s.startswith("&lt;?p") or
        s.startswith("&lt;?=") or
        s.startswith("&lt;?\n") or
        s.startswith("&lt;?\r") or
        s.startswith("&lt;? ") or
        s.startswith("&lt;?\t")
    ) or not (
        s.endswith("?&gt;\n") or
        s.endswith("?&gt;\r") or
        s.endswith("?&gt;\r\n")
    )
):
    g.es("File seems to be mixed HTML and PHP; importing as plain text file.")
    c.setBodyString(parent,"@ignore\n" + self.rootLine + s)
    return
</t>
<t tx="ekr.20070626112754.1545">if g.match(s,i,"//"):
    i = g.skip_line(s,i)
elif g.match(s,i,"#"):
    i = g.skip_line(s,i)
elif g.match(s,i,"/*"):
    i = g.skip_block_comment(s,i)
else:
    i += 1
</t>
<t tx="ekr.20070626112754.1546">if g.match(s,i,"&lt;&lt;&lt;"):
    i = g.skip_heredoc_string(s,i)
else:
    i += 1
</t>
<t tx="ekr.20070626112754.1547">@ In PHP, all functions are typeless and start with the keyword "function;  all classes start with the keyword class.

Functions can be nested, but we don't handle that right now (I don't think it is a common practice anyway).
@c
if g.match(s,i,"function "):
    #we want to make the function a subnode of either the @file node or a class node
    # 1. get the function name
    # 2. make a reference in the parent
    # 3. create the child node, and dump the function in it.
    function_start = i
    m = phpFunctionName.match(s[i:])
    if (None == m): # function keyword without function name
        i += len("function ")
    else:
        headline = g.angleBrackets(" function " + m.group(1) + " ")
        # find the end of the function
        openingBrace = s.find('{',i)
        function_end = g.skip_php_braces(s,openingBrace)
        function_end = g.skip_to_end_of_line(s,function_end - 1) + 1 # include the line end
        # Insert skipped text into parent's body.
        if class_start:
            class_body += s[scan_start:function_start]
        else:
            c.appendStringToBody(parent,s[scan_start:function_start])
        # Append the headline to the parent's body.
        if class_start:
            class_body += (headline + "\n")
        else:
            c.appendStringToBody(parent,headline + "\n")
        # Backup to capture leading whitespace (for undent purposes)
        while (function_start &gt; 0) and (s[function_start - 1] in [" ", "\t"]):
            function_start -= 1
        # Get the body and undent it
        function_body = s[function_start:function_end]
        function_body = self.undentBody(function_body)
        if self.treeType != "@file":
            function_body = "@code\n\n" + function_body
        # Create the new node
        if class_start:
            self.createHeadline(class_node,function_body,headline)
        else:
            self.createHeadline(parent,function_body,headline)
        i = function_end
        scan_start = i
        function_end = 0
        function_start = 0 #done with this function
        function_body = ""

elif g.match(s,i,"class "):
    # we want to make the class a subnode of the @file node
    # 1. get the class name
    # 2. make a reference in the parent
    # 3. create the child node and dump the function in it
    class_start = i
    class_body = ""
    m = phpClassName.match(s[i:])
    if (None == m): # class keyword without class name
        i += len("class ")
    else:
        # Insert skipped text into parent's body.
        c.appendStringToBody(parent,s[scan_start:class_start])
        # create the headline name
        headline = g.angleBrackets(" class " + m.group(1) + " ")
        # find the place to start looking for methods (functions)
        openingBrace = s.find('{',i)
        # find the end of the class
        class_end = g.skip_php_braces(s,openingBrace)
        class_end = g.skip_to_end_of_line(s,class_end - 1) + 1 # include the line end
        # Append the headline to the parent's body.
        c.appendStringToBody(parent,headline + "\n")
        # Backup to capture leading whitespace (for undent purposes)
        while (class_start &gt; 0) and (s[class_start - 1] in [" ", "\t"]):
            class_start -= 1
        scan_start = class_start
        # Create the new node
        class_node = self.createHeadline(parent,"",headline)
        i = openingBrace

else:
    i += 1
</t>
<t tx="ekr.20070626112754.1548"># Capture the rest of the body
class_body += s[scan_start:class_end]
# insert the class node's body
if self.treeType != "@file":
    class_body = "@code\n\n" + class_body
class_body = self.undentBody(class_body)
c.appendStringToBody(class_node,class_body)
# reset the indices
i = class_end
scan_start = i
class_end = 0
class_start = 0 #done with this class
class_body=""
</t>
<t tx="ekr.20070626112754.1549">c.appendStringToBody(parent,s[scan_start:endOfCode])
</t>
<t tx="ekr.20070626112754.1550"></t>
<t tx="ekr.20070626112754.1551">def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)
    # Create the vnode.
    v = parent.insertAsLastChild()
    v.initHeadString(headline,self.encoding)
    # Set the body.
    if len(body) &gt; 0:
        self.c.setBodyString(v,body,self.encoding)
    return v
</t>
<t tx="ekr.20070626112754.1552">def error (self,s): g.es(s)
</t>
<t tx="ekr.20070626112754.1553">def getLeadingIndent (self,s,i):

    """Return the leading whitespace of a line, ignoring blank and comment lines."""

    i = g.find_line_start(s,i)
    while i &lt; len(s):
        # g.trace(g.get_line(s,i))
        j = g.skip_ws(s,i) # Bug fix: 2/14/03
        if g.is_nl(s,j) or g.match(s,j,"#"): # Bug fix: 2/14/03
            i = g.skip_line(s,i) # ignore blank lines and comment lines.
        else:
            i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
            # g.trace("returns:",width)
            return width
    # g.trace("returns:0")
    return 0
</t>
<t tx="ekr.20070626112754.1554"># The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):

    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
</t>
<t tx="ekr.20070626112754.1555">def massageBody (self,s,methodKind):

    # g.trace(s)
    # g.trace(g.get_line(s,0))
    c = self.c
    if self.treeType == "@file":
        if self.fileType == ".py": # 7/31/02: was "py"
            return self.undentBody(s)
        else:
            newBody, comment = self.skipLeadingComments(s)
            newBody = self.undentBody(newBody)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            if len(comment) &gt; 0:
                return comment + "\n@c" + newLine + newBody
            else:
                return newBody
    else:
        # Inserts &lt; &lt; self.methodName methodKind &gt; &gt; =
        cweb = self.fileType == "c" and not c.use_noweb_flag
        lb = g.choose(cweb,"@&lt;","&lt;&lt;")
        rb = g.choose(cweb,"@&gt;=","&gt;&gt;=")
        intro = lb + " " + self.methodName + " " + methodKind + " " + rb
        if self.fileType == ".py": # 7/31/02: was "py"
            newBody = self.undentBody(s)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            return intro + newLine + newBody
        else:
            newBody, comment = self.skipLeadingComments(s)
            newBody = self.undentBody(newBody)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            if len(comment) &gt; 0:
                return comment + "\n" + intro + newLine + newBody
            else:
                return intro + newLine + newBody
</t>
<t tx="ekr.20070626112754.1556">def massageComment (self,s):

    """Returns s with all runs of whitespace and newlines converted to a single blank.

    Also removes leading and trailing whitespace."""

    # g.trace(g.get_line(s,0))
    s = string.strip(s)
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"\r"," ")
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
</t>
<t tx="ekr.20070626112754.1557">def massageWebBody (self,s):

    theType = self.webType
    lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")
    &lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;
    &lt;&lt; Replace abbreviated names with full names &gt;&gt;
    s = string.rstrip(s)
    return s
</t>
<t tx="ekr.20070626112754.1558">i = 0
while i &lt; len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isDocStart(s,i):
        # Scan to end of the doc part.
        if g.match(s,i,"@ %def"):
            # Don't remove the newline following %def
            i = g.skip_line(s,i) ; start = end = i
        else:
            start = end = i ; i += 2
        while i &lt; len(s):
            progress2 = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i) or g.match(s,i,lb):
                end = i ; break
            elif theType == "cweb": i += 1
            else: i = g.skip_to_end_of_line(s,i)
            assert (i &gt; progress2)
        # Remove newlines from start to end.
        doc = s[start:end]
        doc = string.replace(doc,"\n"," ")
        doc = string.replace(doc,"\r","")
        doc = string.strip(doc)
        if doc and len(doc) &gt; 0:
            if doc == "@":
                doc = g.choose(self.webType=="cweb", "@ ","@\n")
            else:
                doc += "\n\n"
            # g.trace("new doc:",doc)
            s = s[:start] + doc + s[end:]
            i = start + len(doc)
    else: i = g.skip_line(s,i)
    assert (i &gt; progress)
</t>
<t tx="ekr.20070626112754.1559">i = 0
while i &lt; len(s):
    progress = i
    # g.trace(g.get_line(s,i))
    if g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k &gt; -1:
            name = s[j:k]
            name2 = self.cstLookup(name)
            if name != name2:
                # Replace name by name2 in s.
                # g.trace("replacing %s by %s" % (name,name2))
                s = s[:j] + name2 + s[k:]
                i = j + len(name2)
    i = g.skip_line(s,i)
    assert (i &gt; progress)
</t>
<t tx="ekr.20070626112754.1560">def setEncoding (self):

    # scanDirectives checks the encoding: may return None.
    theDict = g.scanDirectives(self.c)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
</t>
<t tx="ekr.20070626112754.1561">def skipLeadingComments (self,s):

    """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

    Returns (body, comment)"""

    # g.trace(g.get_line(s,0))
    s_original = s
    s = s.lstrip()
    i = 0 ; comment = ""
    if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
        &lt;&lt; scan for C-style comments &gt;&gt;
    elif self.fileType == ".lua":
        &lt;&lt; scan for Lua comments &gt;&gt;
    elif self.fileType == ".pas":
        &lt;&lt; scan for Pascal comments &gt;&gt;
    elif self.fileType == ".py":
        &lt;&lt; scan for Python comments &gt;&gt;
    comment = string.strip(comment)
    if len(comment) == 0:
        return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
    elif self.treeType == "@file":
        return s[i:], "@ " + comment
    else:
        return s[i:], "@ " + comment + "\n"
</t>
<t tx="ekr.20070626112754.1562">while i &lt; len(s):
    if g.match(s,i,"//"): # Handle a C++ comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,"/*"): # Handle a block C comment.
        j = i + 2 ; i = g.skip_block_comment (s,i)
        k = g.choose(g.match(s,i-2,"*/"),i-2,i)
        if self.fileType == ".java":
            # 8/2/02: a hack: add leading whitespace then remove it.
            comment = self.undentBody(comment)
            comment2 = ' ' * 2 + s[j:k]
            comment2 = self.undentBody(comment2)
            comment = comment + comment2 + "\n"
        else:
            comment = comment + self.massageComment(s[j:k]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.1563">while i &lt; len(s):
    if g.match(s,i,"--"): # Handle a Lua line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.1564">while i &lt; len(s):
    if g.match(s,i,"//"): # Handle a Pascal line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,'(*'):
        j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.1565">while i &lt; len(s) and g.match(s,i,'#'):
    j = i + 1 ; i = g.skip_line(s,i)
    comment = self.undentBody(comment)
    comment = comment + self.massageComment(s[j:i]) + "\n"
    # 8/2/02: Preserve leading whitespace for undentBody
    i = g.skip_ws(s,i)
    i = g.skip_blank_lines(s,i)
</t>
<t tx="ekr.20070626112754.1566"># We look at the first line to determine how much leading whitespace to delete.

def undentBody (self,s):

    """Removes extra leading indentation from all lines."""

    # g.trace(s)
    i = 0 ; result = ""
    # Copy an @code line as is.
    if g.match(s,i,"@code"):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]
    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i)
    if undent == 0: return s
    while i &lt; len(s):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        line = s[j:i]
        # g.trace(line)
        line = g.removeLeadingWhitespace(line,undent,self.tab_width)
        result += line
    return result
</t>
<t tx="ekr.20070626112754.1567">@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    if i &gt;= len(s): return len(s) # Bug fix: 2007/5/22
    if i &lt; 0: i = 0
    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1

def skip_to_end_of_line (s,i):

    if i &gt;= len(s): return len(s) # Bug fix: 2007/5/22
    if i &lt; 0: i = 0
    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i

def skip_to_start_of_line (s,i):

    if i &gt;= len(s): return len(s)
    if i &lt;= 0:      return 0
    i = s.rfind('\n',0,i) # Don't find s[i], so it doesn't matter if s[i] is a newline.
    if i == -1: return 0
    else:       return i + 1
</t>
<t tx="ekr.20070626112754.1568"></t>
<t tx="ekr.20070626112754.1569">def makeAllBindings (self):

    k = self ; c = k.c

    # g.trace(c.fileName(),g.callers())

    k.bindingsDict = {}
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()
</t>
<t tx="ekr.20070626112754.1570">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4320971
By: rickardlindberg

------

http://sourceforge.net/forum/message.php?msg_id=4325739


I created a cmd file like this:

script.cmd:
@echo off
echo Hello World

Then I wrote some python code to execute it:

import subprocess
output = subprocess.Popen(["script.cmd"],
stdout=subprocess.PIPE).communicate()[0]
print output

When I saved this script to test.py and ran the file, I got the correct output;
when I entered the script in the python prompt, I got the correct output; but
when I pasted the code in a leo node and executed it, I got the error message
described in my first post.

---------

exception executing script
    TypeError: an integer is required
    --------------------
      line 634:                                    GetCurrentProcess(), 0, 1,
    * line 635:                                    DUPLICATE_SAME_ACCESS)
      line 636: 
      line 637: 

If I remove the `stdout=subprocess.PIPE` part, it works fine, but then I cannot
get the output of the command.</t>
<t tx="ekr.20070626112754.1571">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4309448

Still to do: update urls for tigris.</t>
<t tx="ekr.20070626112754.1572">http://sourceforge.net/forum/message.php?msg_id=4301021
</t>
<t tx="ekr.20070626112754.1573">def openFileForWritingHelper (self,fileName):

    at = self ; c = at.c

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            if path:
                path = g.makeAllNonExistentDirectories(path,c=c)
            if not path or not g.os_path_exists(path):
                path = g.os_path_dirname(at.targetFileName)
                at.writeError("path does not exist: " + path)
                return
    except Exception:
        at.exception("exception creating path: %s" % repr(path))
        g.es_exception()
        return

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not create: read only: " + at.targetFileName)
                return
        except AttributeError: pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
    except:
        at.exception("exception creating:" + at.outputFileName)
</t>
<t tx="ekr.20070626112754.1574">@nocolor

- Select a node by clicking on it.
- The node is selected, but shift-arrow does not work.

However, clicking the canvas does work.

The fix was to give the canvas, not the headline focus when clicking on a headline.
This results in canvas bindings, not text bindings, having priority.
This is not a kludge: the text widget isn't active, so text bindings should not be in effect.

@color</t>
<t tx="ekr.20070626112754.1575"></t>
<t tx="ekr.20070626112754.1576">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4336648
By: terry_n_brown

Just a nit, but I notice that the default empty file that you get when first
running Leo is still marked 'changed' (current CVS).  I.e. it asks for confirmation
on closing, which it didn't need previously.</t>
<t tx="ekr.20070626112754.1577">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4340244
By: vransmayr

Traceback (most recent call last):

  File "C:\CVS-Reps\leo\src\leoGlobals.py", line 2545, in doHook
    return f(tag,keywords)

  File "C:\CVS-Reps\leo\src\leoPlugins.py", line 91, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "C:\CVS-Reps\leo\src\leoPlugins.py", line 70, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "C:\CVS-Reps\leo\src\leoPlugins.py", line 49, in callTagHandler
    result = handler(tag,keywords)

  File "C:\CVS-Reps\leo\plugins\maximizeNewWindows.py", line 29, in
maximize_window
    c.frame.top.state("zoomed")

AttributeError: nullFrame instance has no attribute 'top'</t>
<t tx="ekr.20070626112754.1578"></t>
<t tx="ekr.20070626112754.1579">@nocolor

https://sourceforge.net/forum/message.php?msg_id=4339681
By: ktenney

Try this;

- create new chapter, default node is 'Chapter n node 1'
- insert a node
- delete node 'Chapter n node 1'
- tab to another chapter and return to this chapter

Now there is a node '@chapters'
with children for each chapter
'@chapter &lt;chapter name&gt;'
</t>
<t tx="ekr.20070626112754.1580">def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.currentPosition()
    if not p: return

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    try:
       c.endEditing() # Make sure we capture the headline for Undo.
    finally:
        c.endUpdate(False)

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.headString()
        if h.startswith(chapters):
            if p.hasChildren():
               return cc.error('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                return cc.removeChapterByName(name)

    c.beginUpdate()
    try:
        undoData = u.beforeDeleteNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.doDelete()
        c.selectPosition(newNode)
        c.setChanged(True)
        u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()

    c.validateOutline()
</t>
<t tx="ekr.20070626112754.1581">def positionExists(self,p,root=None):

    """Return True if a position exists in c's tree"""

    c = self ; p = p.copy()

    # This code must be fast.
    if not root:
        root = c.rootPosition()

    while p:
        # g.trace(p.headString())
        if p.equal(root):
            # g.trace('True')
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()

    return False
</t>
<t tx="ekr.20070626112754.1582">def setRootPosition(self,p):

    """Set the root positioin."""

    c = self

    # g.trace(p and p.headString(),g.callers())

    if p:
        # Important: p.equal requires c._rootPosition to be non-None.
        if c._rootPosition and p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None</t>
<t tx="ekr.20070626112754.1583"></t>
<t tx="ekr.20070626112754.1584">def cutOutline (self,event=None):

    '''Delete the selected outline and send it to the clipboard.'''

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()
</t>
<t tx="ekr.20070626112754.1585">def copyOutline (self,event=None):

    '''Copy the selected outline to the clipboard.'''

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    c.fileCommands.assignFileIndices()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)
</t>
<t tx="ekr.20070626112754.1586"># To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        &lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return

    c.beginUpdate()
    try:
        copiedBunchList = []
        if pasteAsClone:
            &lt;&lt; put only needed info in copiedBunchList &gt;&gt;
        undoData = u.beforeInsertNode(current,
            pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
        c.endEditing()
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        c.setRootPosition(c.findRootPosition(pasted)) # New in 4.4.2.
        u.afterInsertNode(pasted,undoType,undoData)
    finally:
        c.endUpdate()
        c.recolor()
</t>
<t tx="ekr.20070626112754.1587">@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())
</t>
<t tx="ekr.20070626112754.1588"># Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t

# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
</t>
<t tx="ekr.20070626112754.1589">def pasteOutlineRetainingClones (self,event=None):

    '''Paste an outline into the present outline from the clipboard.
    Nodes *retain* their original identify.'''

    c = self

    return c.pasteOutline(reassignIndices=False)
</t>
<t tx="ekr.20070626112754.1590">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
</t>
<t tx="ekr.20070626112754.1591">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4337221
By: ktenney

This is reproducible for me with current cvs;

- From a Leo file, click File-&gt;New
- paste a node into into the new file
- delete the default new file node "New Headline",
  leaving the pasted node
- click the 'trash' tab
- click the main tab

the pasted node is gone, the "New Headline" node is visible .


What I did:

tree.select was doing nothing if c.positionExists(p) was false.
But this is wrong: we may be in the process of changing roots.</t>
<t tx="ekr.20070626112754.1592"># Added c.suppressHeadChanged and related logic.U</t>
<t tx="ekr.20070626112754.1593">def setChanged (self,changedFlag):

    c = self
    if not c.frame: return

    # if changedFlag: g.trace('***',g.callers())

    # Clear all dirty bits _before_ setting the caption.
    # Clear all dirty bits except orphaned @file nodes
    if not changedFlag:
        # g.trace("clearing all dirty bits")
        for p in c.allNodes_iter():
            if p.isDirty() and not (p.isAtFileNode() or p.isAtNorefFileNode()):
                p.clearDirty()

    # Update all derived changed markers.
    c.changed = changedFlag
    s = c.frame.getTitle()
    if len(s) &gt; 2 and not c.loading: # don't update while loading.
        if changedFlag:
            if s [0] != '*': c.frame.setTitle("* " + s)
        else:
            if s[0:2]=="* ": c.frame.setTitle(s[2:])
</t>
<t tx="ekr.20070626112754.1594">@nocolor

Selecting a node found the first node that matches, rather than the correct position.

Example:

A'
- B
A'
- B

A' are clones.

Select the second B.
Switch chapters, then back again.
Now the first B is selected.

@color</t>
<t tx="ekr.20070626112754.1595">def setPositionsFromStacks (self):

    c = self.c

    current = self.convertStackToPosition(self.currentVnodeStack)

    if current:
        # g.trace('using convertStackToPosition',current)
        c.setCurrentPosition(current)
    else:
        # g.trace(self.currentVnodeStack)
        c.setCurrentPosition(c.rootPosition())

    # At present this is useless: the drawing code doesn't set the top position properly.
    if 0:
        top = self.convertStackToPosition(self.topVnodeStack)
        if top:
            c.setTopPosition(top)</t>
<t tx="ekr.20070626112754.1596">def selectChapterByName (self,name):

    cc = self ; c = cc.c ; chapter = cc.chaptersDict.get(name)

    if chapter:
        if chapter != cc.selectedChapter:
            if cc.selectedChapter:
                cc.selectedChapter.unselect()
            chapter.select()
            c.setCurrentPosition(chapter.p)
            cc.selectedChapter = chapter
    else:
        cc.error('cc.selectShapter: no such chapter: %s' % name)
</t>
<t tx="ekr.20070626112754.1597">def findPositionInChapter (self,p1,strict=False):

    '''Return a valid position p such that p.v == v.'''

    # Do nothing if the present position is in the proper chapter.
    c = self.c ; name = self.name 

    root = g.choose(self.name=='main',c.rootPosition(),self.root)
    # g.trace('p1',p1)
    if p1 and c.positionExists(p1,root=root):
        # g.trace('using existing position',p)
        return p1

    if name == 'main':
        for p in self.c.allNodes_iter():
            if p.v == p1.v:
                # g.trace('*** found in main chapter',p)
                self.p = p.copy()
                return self.p
        if strict:
            return None
        else:
            self.p = c.rootPosition()
    else:
        for p in self.root.self_and_subtree_iter():
            # g.trace('testing',p,p1)
            if p.v == p1.v:
                # g.trace('*** found in chapter',p)
                self.p = p.copy()
                return self.p
        if strict:
            return None
        else:
            self.p = self.root.copy()

    if 0:
        self.error('***** chapter: %s findPositionInChapter: lost %s' % (
            self.name,p1.v.t.headString))
        g.trace(g.callers())

    return self.p.copy()
</t>
<t tx="ekr.20070626112754.1598">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4341644
Viktor Ransmayr

When you save an outline, the focus switches from the body pane
to the outline pane.

@color</t>
<t tx="ekr.20070626112754.1599"></t>
<t tx="ekr.20070626112754.1600">def downCaseRegion (self,event):
    '''Convert all characters in the selected text to lower case.'''
    self.caseHelper(event,'low','downcase-region')

def upCaseRegion (self,event):
    '''Convert all characters in the selected text to UPPER CASE.'''
    self.caseHelper(event,'up','upcase-region')

def caseHelper (self,event,way,undoType):

    w = self.editWidget(event)
    if not w or not w.hasSelection(): return

    self.beginCommand(undoType=undoType)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    sel = g.choose(way=='low',s[i:j].lower(),s[i:j].upper())
    s2 = s[:i] + sel + s[j:]
    # g.trace('sel',repr(sel),'s2',repr(s2))
    changed = s2 != s
    if changed:
        w.setAllText(s2)
        w.setSelectionRange(i,j,insert=ins)

    self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20070626112754.1601"></t>
<t tx="ekr.20070626112754.1602">def beginCommand (self,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
</t>
<t tx="ekr.20070626112754.1603"># New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  w.getSelectionRange()
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
    else:
        self.undoData = None

    return w
</t>
<t tx="ekr.20070626112754.1604"># New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):

    '''Do the common processing at the end of each command.'''

    c = self.c ; b = self.undoData ; k = self.k

    # g.trace('changed',changed)

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)

    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()

    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
</t>
<t tx="ekr.20070626112754.1605"></t>
<t tx="ekr.20070626112754.1606">def capitalizeWord (self,event):
    '''Capitalize the word at the cursor.'''
    self.capitalizeHelper(event,'cap','capitalize-word')

def downCaseWord (self,event):
    '''Convert all characters of the word at the cursor to lower case.'''
    self.capitalizeHelper(event,'low','downcase-word')

def upCaseWord (self,event):
    '''Convert all characters of the word at the cursor to UPPER CASE.'''
    self.capitalizeHelper(event,'up','upcase-word')
</t>
<t tx="ekr.20070626112754.1607">def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke
    w = self.editWidget(event)
    if not w: return

    i = w.getInsertPoint()
    self.beginCommand(undoType='change-previous-word')
    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '&lt;Alt-c&gt;':
        self.capitalizeWord(event)
    elif stroke == '&lt;Alt-u&gt;':
         self.upCaseWord(event)
    elif stroke == '&lt;Alt-l&gt;':
        self.downCaseWord(event)

    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1608">def capitalizeHelper (self,event,which,undoType):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    word = s[i:j]
    # g.trace('word',repr(word))
    if not word.strip(): return

    self.beginCommand(undoType=undoType)

    if   which == 'cap':  word2 = word.capitalize()
    elif which == 'low':  word2 = word.lower()
    elif which == 'up':   word2 = word.upper()
    else: g.trace('can not happen: which = %s' %s (which))

    changed = word != word2
    # g.trace('changed',changed,'word2',repr(word2))

    if changed:
        w.delete(i,j)
        w.insert(i,word2)
        w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20070626112754.1609">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4353416
By: mstarzyk

When you hoist a node, then while in the tree panel - you can navigate to nodes
outside of the hosted subtree.

@color</t>
<t tx="ekr.20070626112754.1610">def lastVisible(self):

    """Move to the last visible node of the present chapter or hoist."""

    c = self ; p = c.currentPosition()

    while 1:
        next = p.visNext(c)
        # g.trace('next',next)
        if next and next.isVisible(c):
            p = next
        else: break
    return p
</t>
<t tx="ekr.20070626112754.1611">def visLimit (self):

    '''Return the topmost visible node.
    This is affected by chapters and hoists.'''

    c = self ; cc = c.chapterController

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p
        limitIsVisible = not cc or not p.headString().startswith('@chapter')
        return p,limitIsVisible
    else:
        return None,None
</t>
<t tx="ekr.20070626112754.1612">def canMoveOutlineDown (self):

    c = self ; current = c.currentPosition()

    return current and current.visNext(c)
</t>
<t tx="ekr.20070626112754.1613">def canMoveOutlineUp (self):

    c = self ; current = c.currentPosition()

    visBack = current and current.visBack(c)

    if not visBack:
        return False
    elif visBack.visBack(c):
        return True
    elif c.hoistStack:
        limit,limitIsVisible = c.visLimit()
        if limitIsVisible: # A hoist
            return current != limit
        else: # A chapter.
            return current != limit.firstChild()
    else:
        return current != c.rootPosition()
</t>
<t tx="ekr.20070626112754.1614">def canSelectThreadBack (self):
    c = self ; p = c.currentPosition()
    return p.hasThreadBack()

def canSelectThreadNext (self):
    c = self ; p = c.currentPosition()
    return p.hasThreadNext()

def canSelectVisBack (self):
    c = self ; p = c.currentPosition()
    return p.visBack(c)

def canSelectVisNext (self):
    c = self ; p = c.currentPosition()
    return p.visNext(c)
</t>
<t tx="ekr.20070626112754.1615">def isVisible (self,c):

    """Return True if all of a position's parents are expanded."""

    # v.isVisible no longer exists.
    p = self ; cc = c.chapterController ; trace = False
    limit,limitIsVisible = c.visLimit()
    limit_v = limit and limit.v or None
    if p.v == limit_v:
        if trace: g.trace('*** at limit','limitIsVisible',limitIsVisible,p.v.headString())
        return limitIsVisible

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1

    v,n = p.vParentWithStack(v,p.stack,n)
    while v:
        if v == limit_v:  # We are at a descendant of limit.
            if trace: g.trace('*** descendant of limit',
                'limitIsVisible',limitIsVisible,
                'limit.isExpanded()',limit.isExpanded(),'v',v)
            if limitIsVisible:
                return limit.isExpanded()
            else: # Ignore the expansion state of @chapter nodes.
                return True
        if not v.isExpanded():
            if trace: g.trace('*** non-limit parent is not expanded',v)
            return False
        v,n = p.vParentWithStack(v,p.stack,n)

    return True
</t>
<t tx="ekr.20070626112754.1616">def moveToThreadBack (self):

    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
</t>
<t tx="ekr.20070626112754.1617">def moveToThreadNext (self):

    """Move a position to the next a position in threading order."""

    p = self

    if p:
        if p.v.t._firstChild:
            p.moveToFirstChild()
        elif p.v._next:
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.v._next:
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.

    return p
</t>
<t tx="ekr.20070626112754.1618">def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            if limit == p:
                if trace: g.trace('at limit',p)
                return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        back = p.back()
        if back and (not back.hasChildren() or not back.isExpanded()):
            p.moveToBack()
        else:
            p.moveToThreadBack()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p
    else:
        # assert not p.
        return p</t>
<t tx="ekr.20070626112754.1619">def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            # Unlike moveToVisBack, being at the limit does not terminate.
            if limit == p:
                return False, None
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        if p.hasNext() and (not p.hasChildren() or not p.isExpanded()):
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        # assert not p.
        return p</t>
<t tx="ekr.20070626112754.1620">@
Also, tree.endDrag and tree.onHeadChanged now redraw the screen only if the drag
actually happened or the headline actually changed.
</t>
<t tx="ekr.20070626112754.1621">def drawTopTree (self):

    """Draws the top-level tree, taking into account the hoist state."""

    c = self.c ; canvas = self.canvas
    trace = False or self.trace or self.trace_redraw

    self.redrawing = True

    # Recycle all widgets and clear all widget lists.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.redrawCount += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if trace:
        g.trace('redrawCount',self.redrawCount,g.callers()) # 'len(c.hoistStack)',len(c.hoistStack))
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())

    self.prevPositions = g.app.positions
    if self.trace_gc: g.printNewObjects(tag='top 1')

    hoistFlag = c.hoistStack
    if c.hoistStack:
        bunch = c.hoistStack[-1] ; p = bunch.p
        h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            hoistFlag = False
    else:
        p = c.rootPosition()

    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)

    if self.trace_gc: g.printNewObjects(tag='top 2')
    if self.trace_stats: self.showStats()

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
</t>
<t tx="ekr.20070626112754.1622"></t>
<t tx="ekr.20070626112754.1623">http://sourceforge.net/forum/message.php?msg_id=4356197</t>
<t tx="ekr.20070626112754.1624">def canDemote (self):

    c = self
    return c.currentPosition().hasNext()
</t>
<t tx="ekr.20070626112754.1625">def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                g.alert(message)
            return False
    return True
</t>
<t tx="ekr.20070626112754.1626"></t>
<t tx="ekr.20070626112754.1627"></t>
<t tx="ekr.20070626112754.1628">def norefWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atNorefFileNodeName()
        at.initWriteIvars(root,targetFileName,nosentinels=False,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            return
        &lt;&lt; write root's tree &gt;&gt;
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)

rawWrite = norefWrite
</t>
<t tx="ekr.20070626112754.1629">&lt;&lt; put all @first lines in root &gt;&gt;
at.putOpenLeoSentinel("@+leo-ver=4")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

for p in root.self_and_subtree_iter():
    &lt;&lt; Write p's node &gt;&gt;

at.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;
</t>
<t tx="ekr.20070626112754.1630">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.putBuffered(line) ; at.onl()
    i = g.skip_nl(s,i)
</t>
<t tx="ekr.20070626112754.1631">s2 = c.config.output_initial_comment
if s2:
    lines = string.split(s2,"\\n")
    for line in lines:
        line = line.replace("@date",time.asctime())
        if len(line)&gt; 0:
            at.putSentinel("@comment " + line)
</t>
<t tx="ekr.20070626112754.1632">at.putOpenNodeSentinel(p)

s = p.bodyString()

if self.write_strips_blank_lines:
    s = self.cleanLines(p,s)

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True)
    at.outputStringWithLineEndings(s)

# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
    at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p)
</t>
<t tx="ekr.20070626112754.1633">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    at.putBuffered(line[i:]) ; at.onl()
</t>
<t tx="ekr.20070626112754.1634">def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString): return
        for p in root.self_and_subtree_iter():
            &lt;&lt; Write p's headline if it starts with @@ &gt;&gt;
            &lt;&lt; Write p's body &gt;&gt;
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)

silentWrite = asisWrite # Compatibility with old scripts.
</t>
<t tx="ekr.20070626112754.1635">s = p.headString()

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) &gt; 0:
        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
        at.outputFile.write(s)
</t>
<t tx="ekr.20070626112754.1636">s = p.bodyString()

if self.write_strips_blank_lines:
    s = self.cleanLines(p,s)

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
</t>
<t tx="ekr.20070626112754.1637">def cleanLines (self,p,s):

    '''Return a copy of s, with all trailing whitespace removed.
    If a change was made, update p's body text and set c dirty.'''

    c = self.c ; cleanLines = [] ; changed = False
    lines = g.splitLines(s)
    for line in lines:
        if line.strip():
            cleanLines.append(line)
        elif line.endswith('\n'):
            cleanLines.append('\n')
            if line != '\n': changed = True
        else:
            cleanLines.append('')
            if line != '': changed = True
    s = g.joinLines(cleanLines)

    if changed and not g.app.unitTesting:
        p.setTnodeText(s)
        c.setBodyString(p,s)
        c.setChanged(True)

    return s</t>
<t tx="ekr.20070626112754.1638"></t>
<t tx="ekr.20070626112754.1639"># Run all @test and @suite nodes in this .leo file.

import leoTest
leoTest.doTests(c,all=True,verbosity=1)</t>
<t tx="ekr.20070626112754.1640">import unittest

class testRoutineTestCase(unittest.TestCase):
    @others

p = c.currentPosition() ; p1 = p.copy()

try:
    g.app.unitTesting = True
    g.app.unitTestDict["fail"] = False
    changed = c.isChanged()
    suite = unittest.makeSuite(unittest.TestCase)
    for p in c.allNodes_iter():
        h = p.headString()
        if h.startswith('test_') and p.bodyString().strip():
            testCase = testRoutineTestCase(c,g,p)
            suite.addTest(testCase)
    # Verbosity: 1: print just dots.
    unittest.TextTestRunner(verbosity=1).run(suite)
finally:
    c.setChanged(changed) # Restore changed state.
    c.selectPosition(p1)
    g.app.unitTesting = False
</t>
<t tx="ekr.20070626112754.1641">def __init__ (self,c,g,p,verbose=False):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.g = g
    self.p = p.copy()
    self.verbose = verbose

    self.name = p.headString().strip()
    self.code = p.bodyString()
</t>
<t tx="ekr.20070626112754.1642">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20070626112754.1643">def runTest (self):

    c = self.c ; g = self.g ; p = self.p ; name = self.name

    d = {'c':c,'g':g,'p':p}

    script = g.getScript(c,p).strip()
    script = self.removeLeadingWs(script)

    isMethod = self.isMethod(script)

    # Create a call to the function.
    if isMethod:
        s = '%s\n%s(self=None)\n' % (script,name)
    else:
        s = '%s\n%s()\n' % (script,name)

    if self.verbose:
        g.trace('executing...\n\n%s' % s)

    exec s in d # Execute s in a environment containing c, g and p.
</t>
<t tx="ekr.20070626112754.1644">def isMethod (self,s):

    '''Return True if the test_ method's first arg is self.'''

    if s.find('self') == -1:
        return False

    name = self.name
    i = s.find('def %s' % name)
    if i == -1:
        g.trace('%s not defined' % name)
    else:
        i += (4 + len(name))
        i = g.skip_ws(s,i)
        if g.match(s,i,'('):
            return g.match_word(s,i+1,'self')
        else:
            g.trace('%s not defined 2' % name)
            g.trace(repr(s[i:i+10]))</t>
<t tx="ekr.20070626112754.1645">def shortDescription (self):

    return 'test function',repr(self.name)</t>
<t tx="ekr.20070626112754.1646">def removeLeadingWs (self,code):

    if not code.strip():
        return ''

    lines = g.splitLines(code)
    line = lines[0]
    i = g.skip_ws(line,0)
    ws = line[0:i]
    if not ws:
        return code
    result = [] ; n = len(ws)
    for line in lines:
        if line.startswith(ws):
            result.append(line[n:])
        elif not line.strip() and line.endswith('\n'):
            result.append('\n')
        else:
            print 'removeLeadingWs:underindented line:%s' % repr(line)
            result.append(line)

    # g.trace(g.listToString(result))

    result = ''.join(result)
    return result</t>
<t tx="ekr.20070626112754.1647">(done) create-chapter
(done) show-chapters
(done) hide-chapters
(done) Allow permanent chapter renames.
(done) Eliminate error messages.</t>
<t tx="ekr.20070626112754.1648">def getPublicCommands (self):

    c = self.c ; cc = c.chapterController

    # g.trace('cc',cc,g.callers())

    if cc:
        return {
            'clone-node-to-chapter':    cc.cloneNodeToChapter,
            'convert-node-to-chapter':  cc.convertNodeToChapter,
            'copy-node-to-chapter':     cc.copyNodeToChapter,
            'create-chapter':           cc.createChapter,
            'create-chapter-from-node': cc.createChapterFromNode,
            'move-node-to-chapter':     cc.moveNodeToChapter,
            'remove-chapter':           cc.removeChapter,
            'rename-chapter':           cc.renameChapter,
            'select-chapter':           cc.selectChapter,
        }
    else:
        return {}
</t>
<t tx="ekr.20070626112754.1649">@nocolor

Made installing aspell easier.

http://sourceforge.net/forum/message.php?msg_id=4318634
By: billpage

What I did:

- Use ctypes.util.find_library('aspell') to find aspell lib.
- Return in several places if currentWord is None.
  This fixes crashers if no suggestions are found.

@color</t>
<t tx="ekr.20070626112754.1650">@others
</t>
<t tx="ekr.20070626112754.1651">class spellCommandsClass (baseEditCommandsClass):

    '''Commands to support the Spell Tab.'''

    @others
</t>
<t tx="ekr.20070626112754.1652">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.handler = None

    # All the work happens when we first open the frame.
</t>
<t tx="ekr.20070626112754.1653">def getPublicCommands (self):

    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
</t>
<t tx="ekr.20070626112754.1654">class AspellClass:

    """A wrapper class for Aspell spell checker"""

    @others
</t>
<t tx="ekr.20070626112754.1655">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; «original» «count» «offset»: «miss», «miss», ... 
    None: 
    # «original» «offset» 
    simplifyed to not create the string then make a list from it
    """

    # g.trace('word',word)

    if not self.aspell:
        g.trace('aspell not installed')
        return None
    elif self.use_ctypes:
        if self.check(self.spell_checker,word,len(word)):
            return None
        else:
            return self.suggestions(word)
    else:
        if self.sc.check(word):
            return None
        else:
            return self.sc.suggest(word)
</t>
<t tx="ekr.20070626112754.1656">def suggestions(self,word):

    "return list of words found"

    aList = []
    sw = self.suggest(self.spell_checker, word, len(word))

    if self.word_list_size(sw):
        ewords = self.word_list_elements(sw)
        while 1: 
            x = self.string_enumeration_next(ewords)
            if x is None: break
            aList.append(x)
    return aList</t>
<t tx="ekr.20070626112754.1657">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.

    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es_print("Unable to update local aspell dictionary: %s" % err)
        return False
</t>
<t tx="ekr.20070626112754.1658">Added globalDynamicAbbrevs setting.</t>
<t tx="ekr.20070626112754.1659">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4255709

I have some questions about the usage of dynamic abbreviations in Leo. As an
Emacs user, I know how they work in Emacs: they expand partially entered words
using a dictionary of words from the currently open buffers.

- I found a thread in the SF Forums titled "dynamic-abbreviations increases
its scope", 07-20-2005. The functionality described in this thread seems to
be the functionality I am familiar with as an Emacs uses. Is this the functionality
accessed through the commands dabbrev-completion and dabbrev-expands ?
- What is the difference between dabbrev-completion and dabbrev-expands ? 
- I often get a TK exception when I use dabbrev-completion "TypeError: reduce()
of empty sequence with no initial value". What am I doing wrong ?

Can somebody answer these questions for me or point me to documentation that
describes Leo's support for dynamic abbreviations?

-----------
http://sourceforge.net/forum/message.php?msg_id=4260706

command completion is shell or readline functionality to automatically finish
what you've typed so far, thus "completing" the type-in of the command for you.

abbreviation expansion is actually going to put a bunch of characters in your
buffer where you only had to enter the abbreviation for it.

---------
http://sourceforge.net/forum/message.php?msg_id=4263851

Already solved a part of it. The exception is raised when the characters entered
cannot be completed to a previously typed word. In LeoPy.leo, Code--&gt;Core
classes...--&gt;@thin leoEditCommands.py--&gt;editCommandsClass--&gt;dynamic
abbreviation...--&gt;dynamicExpansion2, no check is made that the call to
self.getDynamicList does not retrieve an empty list. I've added this check (locally)
and at least the exception is not raised anymore. Apparently I am the only one
using this functionality, otherwise taht person surely would have also encountered
the problem.

Unfortunately, when looking at the code it seems that only those words are completed
in the current node :( Is there another mechanism for completion (that also
considers other, e.g. previously viewed, nodes) or am I overlooking something ?</t>
<t tx="ekr.20070626112754.1660">@nocolor

The abbrev facility described above operates automatically as you insert text, but all abbrevs must be defined explicitly.

By contrast, dynamic abbrevs allow the meanings of abbrevs to be determined automatically from the contents of the buffer, but dynamic abbrev expansion happens only when you request it explicitly.

M-/
    Expand the word in the buffer before point as a dynamic abbrev, by searching in the buffer for words starting with that abbreviation (dabbrev-expand).
    (EKR: Inserts first found matching work.  Repeated searches finds previous matches)

C-M-/
    Complete the word before point as a dynamic abbrev (dabbrev-completion).
    (EKR: inserts commen prefix of all abbreviations found)

 For example, if the buffer contains `does this follow ' and you type f o M-/, the effect is to insert `follow' because that is the last word in the buffer that starts with `fo'. A numeric argument to M-/ says to take the second, third, etc. distinct expansion found looking backward from point. Repeating M-/ searches for an alternative expansion by looking farther back. After scanning all the text before point, it searches the text after point. The variable dabbrev-limit, if non-nil, specifies how far in the buffer to search for an expansion.

After scanning the current buffer, M-/ normally searches other buffers, unless you have set dabbrev-check-all-buffers to nil.

For finer control over which buffers to scan, customize the variable dabbrev-ignored-buffer-regexps. Its value is a list of regular expressions. If a buffer's name matches any of these regular expressions, dynamic abbrev expansion skips that buffer.

A negative argument to M-/, as in C-u - M-/, says to search first for expansions after point, and second for expansions before point. If you repeat the M-/ to look for another expansion, do not specify an argument. This tries all the expansions after point and then the expansions before point.

After you have expanded a dynamic abbrev, you can copy additional words that follow the expansion in its original context. Simply type SPC M-/ for each word you want to copy. The spacing and punctuation between words is copied along with the words.

The command C-M-/ (dabbrev-completion) performs completion of a dynamic abbreviation. Instead of trying the possible expansions one by one, it finds all of them, then inserts the text that they have in common. If they have nothing in common, C-M-/ displays a list of completions, from which you can select a choice in the usual manner. See section E.3 Completion. </t>
<t tx="ekr.20070626112754.1661"></t>
<t tx="ekr.20070626112754.1662">def getDynamicList (self,w,txt,rlist):

    items = []
    if self.globalDynamicAbbrevs:
        for p in self.c.allNodes_iter():
            s = p.bodyString()
            if s:
                items.extend(self.dynaregex.findall(s))
    else:
        # Make a big list of what we are considering a 'word'
        s = w.getAllText()
        items.append(self.dynaregex.findall(s))

    # g.trace('txt',repr(txt),'len(items)',len(items))

    if items:
        for word in items:
             if not word.startswith(txt) or word == txt:
                 continue
                # dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)

    # g.trace('rlist',rlist)
</t>
<t tx="ekr.20070626112754.1663"># Also made all code gui-independent.</t>
<t tx="ekr.20070626112754.1664"></t>
<t tx="ekr.20070626112754.1665">def dehoist (self,event=None):

    '''Undo a previous hoist of an outline.'''

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        c.beginUpdate()
        try:
            if bunch.expanded: p.expand()
            else:              p.contract()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')
        g.doHook('hoist-changed',c=c)

def hoist (self,event=None):

    '''Make only the selected outline visible.'''

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        c.beginUpdate()
        try:
            p.expand()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')
        g.doHook('hoist-changed',c=c)
</t>
<t tx="ekr.20070626112754.1666">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4134565

The following are now enabled by default:

# Plugin_manager.py needs plugins_menu.py
plugins_menu.py
plugin_manager.py
open_with.py
mod_scripting.py
rst3.py
UNL.py

# Enabled by default in Leo 4.4.3. (order is important)
nav_buttons.py
hoist.py
image.py
leo_to_html.py

I left out cleo because it has been reported not to be fully functional with Leo 4.4.3.</t>
<t tx="ekr.20070626112754.1667"></t>
<t tx="ekr.20070626112754.1668"></t>
<t tx="ekr.20070626112754.1669">@nocolor

- Standardized icon-area button fonts.

- Deleting/cutting an @chapter node 'by hand' equivalent to deleting a chapter.

- Added hoist-changed hook and use the hook in the hoist plugin.

- Added support for chapters to hoist/dehoist commands and hoist plugin.
    - Do not allow de-hoist of an @chapter node.
    - Created c.hoistLevel that subtracts one from len(c.hoistStack) when in a chapter.

- Don't expand parent of @chapers node when switching to main chapter.

- Don't show @chapter node in hoist.

- fix 'No inverse for &lt;chapter command&gt;' messages.</t>
<t tx="ekr.20070626112754.1670"></t>
<t tx="ekr.20070626112754.1671"></t>
<t tx="ekr.20070626112754.1672">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y ; h1 = None
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data

    while p: # Do not use iterator.
        # This is the ONLY copy of p that needs to be made;
        # no other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h # Set h1 *after* calling drawNode.
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
    # Draw the vertical line.
    if h1 is None: h1 = h
    y2 = g.choose(level==0,yfirst+(h1-1)/2,yfirst-h1/2-1)
    self.drawLine(None,x,y2,x,ylast+self.hline_y-h)
    return y
</t>
<t tx="ekr.20070626112754.1673">def contract(self):

    self.statusBits &amp;= ~ self.expandedBit

    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit

    # g.trace(self,g.callers())

    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit
</t>
<t tx="ekr.20070626112754.1674">def expandAllAncestors (self,p):

    '''Expand all ancestors without redrawing.

    Return a flag telling whether a redraw is needed.'''

    c = self.c ; cc = c.chapterController ; redraw_flag = False
    # inChapter = cc and cc.inChapter()

    c.beginUpdate()
    try:
        for p in p.parents_iter():
            # g.trace('testing',p)
            if cc and p.headString().startswith('@chapter'):
                break
            if not p.isExpanded():
                # g.trace('inChapter',inChapter,'p',p,g.callers())
                p.expand()
                redraw_flag = True
    finally:
        c.endUpdate(False)

    return redraw_flag
</t>
<t tx="ekr.20070626112754.1675"></t>
<t tx="ekr.20070626112754.1676"></t>
<t tx="ekr.20070626112754.1677">def insertHeadline (self,event=None,op_name="Insert Node"):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if (
            (current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)
        ):
            if c.config.getBool('insert_new_nodes_at_end'):
                p = current.insertAsLastChild()
            else:
                p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.beginUpdate()
    try:
        c.editPosition(p,selectAll=True)
    finally:
        c.endUpdate(False)

    return p # for mod_labels plugin.
</t>
<t tx="ekr.20070626112754.1678">def clone (self,event=None):

    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone()
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels and chapters plugins.
</t>
<t tx="ekr.20070626112754.1679"># Makes sure all nodes are valid.

def validateOutline (self,event=None):

    c = self

    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True
</t>
<t tx="ekr.20070626112754.1680">def createChild (self,parent,s):

    '''Create a child node of parent without changing the undo stack.
    set the headString of the new node to s.'''

    c = self.c
    p = parent.insertAsLastChild()
    p.initHeadString(s)
    c.setChanged(True)

    return p
</t>
<t tx="ekr.20070626112754.1681"></t>
<t tx="ekr.20070626112754.1682">@ Aha! The Commands class can easily recompute the root position::

    c.setRootPosition(c.findRootPosition(p))

Any command that changes the outline should call this code.

As a result, the fundamental p and v methods that alter trees need never
convern themselves about reporting the changed root.  A big improvement.
@c

def findRootPosition (self,p):

    '''Return the root position of the outline containing p.'''

    c = self ; p = p.copy()

    while p and p.hasParent():
        p.moveToParent()
        # g.trace(p.headString(),g.callers())

    while p and p.hasBack():
        p.moveToBack()

    # g.trace(p and p.headString())

    return p</t>
<t tx="ekr.20070626112754.1683"></t>
<t tx="ekr.20070626112754.1684">def select (self,w=None,selectEditor=True):

    '''Restore chapter information and redraw the tree when a chapter is selected.'''

    if self.selectLockout: return

    try:
        self.selectLockout = True
        self.chapterSelectHelper(w,selectEditor)
        if self.cc.tt:
            self.cc.tt.setTabLabel(self.name)
    finally:
        self.selectLockout = False
</t>
<t tx="ekr.20070626112754.1685">def findEditorInChapter (self,p):

    '''return w, an editor displaying position p.'''

    chapter = self ; c = self.c

    w = c.frame.body.findEditorForChapter(chapter,p)
    w.leo_chapter = chapter
    w.leo_p = p and p.copy()
    return w</t>
<t tx="ekr.20070626112754.1686">def positionIsInChapter (self,p):

    p2 = self.findPositionInChapter (p,strict=True)

    # g.trace(self.name,'returns',p2)
    return p2</t>
<t tx="ekr.20070626112754.1687">def rename (self,newName):

    p = self.root
    s = '@chapter ' + newName
    p.setHeadString(s)
</t>
<t tx="ekr.20070626112754.1688">class leoTkinterTreeTab (leoFrame.leoTreeTab):

    '''A class representing a tabbed outline pane drawn with Tkinter.'''

    @others</t>
<t tx="ekr.20070626112754.1689"></t>
<t tx="ekr.20070626112754.1690">def __init__ (self,c,parentFrame,chapterController):

    leoFrame.leoTreeTab.__init__ (self,c,chapterController,parentFrame)
        # Init the base class.  Sets self.c, self.cc and self.parentFrame.

    self.tabNames = [] # The list of tab names.  Changes when tabs are renamed.

    self.createControl()
</t>
<t tx="ekr.20070626112754.1691">def createControl (self):

    tt = self ; c = tt.c

    # Create the main container.
    tt.frame = Tk.Frame(c.frame.iconFrame)
    tt.frame.pack(side="left")

    # Create the chapter menu.
    self.chapterVar = var = Tk.StringVar()
    var.set('main')

    tt.chapterMenu = menu = Pmw.OptionMenu(tt.frame,
        labelpos = 'w', label_text = 'chapter',
        menubutton_textvariable = var,
        items = [],
        command = tt.selectTab,
    )
    menu.pack(side='left',padx=5)</t>
<t tx="ekr.20070626112754.1692"></t>
<t tx="ekr.20070626112754.1693">def destroyTab (self,tabName):

    tt = self

    if tabName in tt.tabNames:
        tt.tabNames.remove(tabName)
        tt.setNames()
</t>
<t tx="ekr.20070626112754.1694">def setTabLabel (self,tabName):

    tt = self
    tt.chapterVar.set(tabName)
</t>
<t tx="ekr.20070626112754.1695">def setNames (self):

    '''Recreate the list of items.'''

    tt = self
    names = tt.tabNames[:]
    if 'main' in names: names.remove('main')
    names.sort()
    names.insert(0,'main')
    tt.chapterMenu.setitems(names)
</t>
<t tx="ekr.20070626112754.1696"></t>
<t tx="ekr.20070626112754.1697">class chapterCommandsClass (baseEditCommandsClass):

    @others
</t>
<t tx="ekr.20070626112754.1698">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # c.chapterController does not exist yet.
</t>
<t tx="ekr.20070626112754.1699">def canDehoist(self):

    c = self
    return c.hoistLevel() &gt; 0

def canHoist(self):

    # N.B.  This is called at idle time, so minimizing positions is crucial!
    c = self
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        return bunch.p and not c.isCurrentPosition(bunch.p)
    elif c.currentPositionIsRootPosition():
        return c.currentPositionHasNext()
    else:
        return True
</t>
<t tx="ekr.20070626112754.1700"></t>
<t tx="ekr.20070626112754.1701">@

c.finishCreate was being called twice, once for the setting file, and again for the 'actual file.'
The first time cc was None, and error messages were generated.

The fix was to define the Cmds:Chapters menu only if c.chapterController exists.</t>
<t tx="ekr.20070626112754.1702">def __init__ (self,c):

    self.c = c

    self.chaptersDict = {}
        # Keys are chapter names, values are chapters.
        # Important: chapter names never change, even if their @chapter node changes.

    self.chaptersNode = None # Set later
    self.selectedChapter = None
    self.trace = False
    self.tt = None # May be set in finishCreate.
    self.use_tabs = c.config.getBool('use_chapter_tabs')

    # g.trace('chapterController',g.callers())
</t>
<t tx="ekr.20070626112754.1703">def newLeoCommanderAndFrame(self,fileName=None,gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leoCommands

    if not fileName: fileName = ""
    if not gui: gui = g.app.gui
    &lt;&lt; compute the window title &gt;&gt;

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    if updateRecentFiles:
        c.updateRecentFiles(fileName)

    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
</t>
<t tx="ekr.20070626112754.1704"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
</t>
<t tx="ekr.20070626112754.1705"># remove-chapter does not remove @chapter node.</t>
<t tx="ekr.20070626112754.1706"></t>
<t tx="ekr.20070626112754.1707"></t>
<t tx="ekr.20070626112754.1708">def sortChildren (self,event=None):

    '''Sort the children of a node.'''

    c = self ; u = c.undoer ; undoType = 'Sort Children'
    p = c.currentPosition()
    if not p or not p.hasChildren(): return

    c.beginUpdate()
    try: # In update
        c.endEditing()
        u.beforeChangeGroup(p,undoType)
        c.sortChildrenHelper(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(p,undoType,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1709">def sortChildrenHelper (self,p):

    c = self ; u = c.undoer

    # Create a list of tuples sorted on headlines.
    pairs = [(child.headString().lower(),child.copy()) for child in p.children_iter()]
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        undoData = u.beforeMoveNode(child)
        child.moveToNthChildOf(p,index)
        u.afterMoveNode(child,'Sort',undoData)
        index += 1</t>
<t tx="ekr.20070626112754.1710">def sortSiblings (self,event=None):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    p = c.currentPosition()
    if not p: return

    parent = p.parent()
    if not parent:
        c.sortTopLevel()
    else:
        c.beginUpdate()
        try: # In update...
            c.endEditing()
            u.beforeChangeGroup(p,undoType)
            c.sortChildrenHelper(parent)
            dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
            c.setChanged(True)
            u.afterChangeGroup(p,'Sort Siblings',dirtyVnodeList=dirtyVnodeList)
        finally:
            c.endUpdate()
</t>
<t tx="ekr.20070626112754.1711">def sortTopLevel (self,event=None):

    '''Sort the top-level nodes of an outline.'''

    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    root = c.rootPosition()
    if not root: return

    # Create a list of tuples sorted by headlines.
    pairs = [(p.headString().lower(),p.copy())
        for p in root.self_and_siblings_iter()]
    pairs.sort()

    c.beginUpdate()
    try: # In update...
        dirtyVnodeList = []
        u.beforeChangeGroup(root,undoType)
        if 1: # In group...
            h,p = pairs[0]
            if p != root:
                undoData = u.beforeMoveNode(p)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                p.moveToRoot(oldRoot=root)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMoveNode(p,'Sort',undoData)
            for h,next in pairs[1:]:
                undoData = u.beforeMoveNode(next)
                next.moveAfter(p)
                u.afterMoveNode(next,'Sort',undoData)
                p = next
            c.setRootPosition(c.findRootPosition(root)) # New in 4.4.2.
        u.afterChangeGroup(root,undoType,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1712"></t>
<t tx="ekr.20070626112754.1713">def checkOutline (self,event=None,verbose=True,unittest=False,full=True):

    """Report any possible clone errors in the outline.

    Remove any unused tnodeLists."""

    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    for p in c.allNodes_iter():
        try:
            count += 1
            &lt;&lt; remove unused tnodeList &gt;&gt;
            if full: # Unit tests usually set this false.
                &lt;&lt; do full tests &gt;&gt;
        except AssertionError,message:
            errors += 1
            &lt;&lt; give test failed message &gt;&gt;
    if verbose or not unittest:
        &lt;&lt; print summary message &gt;&gt;
    return errors
</t>
<t tx="ekr.20070626112754.1714"># Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; g.es_print(s,color="blue")
    delattr(v.t,"tnodeList")
    v.t._p_changed = True
</t>
<t tx="ekr.20070626112754.1715">if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others
</t>
<t tx="ekr.20070626112754.1716">threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"
</t>
<t tx="ekr.20070626112754.1717">back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"

if next:
    assert p == next.back(), "p==next.back"
</t>
<t tx="ekr.20070626112754.1718">if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"

for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"

if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"
</t>
<t tx="ekr.20070626112754.1719">if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
</t>
<t tx="ekr.20070626112754.1720">if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"
</t>
<t tx="ekr.20070626112754.1721">if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"
</t>
<t tx="ekr.20070626112754.1722">vnodeList = p.v.t.vnodeList

for v in vnodeList:

    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) &gt; 1, "len(vnodeList) &gt; 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"
</t>
<t tx="ekr.20070626112754.1723"># Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = c.edit_widget(p)
    if t:
        s = t.getAllText()
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"
</t>
<t tx="ekr.20070626112754.1724">s = "test failed: %s %s" % (message,repr(p))
print s ; g.es_print(s,color="red")
</t>
<t tx="ekr.20070626112754.1725">if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    g.es_print(s,color="red")
elif verbose:
    g.es(s,color="green")
</t>
<t tx="ekr.20070626112754.1726"></t>
<t tx="ekr.20070626112754.1727">def checkAllPythonCode(self,event=None,unittest=False,ignoreAtIgnore=True):

    '''Check all nodes in the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():

        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.cleanHeadString()
                    return result # End the unit test: it has failed.

    if not unittest:
        g.es("Check complete",color="blue")

    return result
</t>
<t tx="ekr.20070626112754.1728">if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
</t>
<t tx="ekr.20070626112754.1729">def checkPythonCode (self,event=None,unittest=False,ignoreAtIgnore=True,suppressErrors=False):

    '''Check the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    if not unittest:
        g.es("checking Python code   ")

    for p in c.currentPosition().self_and_subtree_iter():

        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest,suppressErrors)
                except (parser.ParserError,SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    g.es("surprise in checkPythonNode")
                    g.es_exception()
                    return "surprise" # abort

    if not unittest:
        g.es("Check complete",color="blue")

    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result
</t>
<t tx="ekr.20070626112754.1730">if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
</t>
<t tx="ekr.20070626112754.1731">def checkPythonNode (self,p,unittest=False,suppressErrors=False):

    c = self

    h = p.headString()
    # We must call getScript so that we can ignore directives and section references.
    body = g.getScript(c,p.copy())
    if not body: return

    try:
        compiler.parse(body + '\n')
    except (parser.ParserError,SyntaxError):
        if not suppressErrors:
            s = "Syntax error in: %s" % h
            g.es_print(s,color="blue")
        if unittest: raise
        else:
            g.es_exception(full=False,color="black")
            c.setMarked(p)

    c.tabNannyNode(p,h,body,unittest,suppressErrors)
</t>
<t tx="ekr.20070626112754.1732"># This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False,suppressErrors=False):

    """Check indentation using tabnanny."""

    c = self

    try:
        # readline = g.readLinesGenerator(body).next
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
        return

    except parser.ParserError, msg:
        if not suppressErrors:
            g.es("ParserError in %s" % headline,color="blue")
            g.es(str(msg))

    except tokenize.TokenError, msg:
        if not suppressErrors:
            g.es("TokenError in %s" % headline,color="blue")
            g.es(str(msg))

    except tabnanny.NannyNag, nag:
        if not suppressErrors:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("Indentation error in %s, line %d" % (headline, badline),color="blue")
            g.es(message)
            g.es("offending line:\n%s" % repr(str(line))[1:-1])

    except:
        g.trace("unexpected exception")
        g.es_exception()

    if unittest: raise
    else: c.setMarked(p)
</t>
<t tx="ekr.20070626112754.1733">def dumpOutline (self,event=None):

    """ Dump all nodes in the outline."""

    c = self

    for p in c.allNodes_iter():
        p.dump()
</t>
<t tx="ekr.20070626112754.1734"></t>
<t tx="ekr.20070626112754.1735">def prettyPrintAllPythonCode (self,event=None,dump=False):

    '''Reformat all Python code in the outline to make it look more beautiful.'''

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():

        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyAllPythonCode (self,event=None,dump=False):
    return self.prettyPrintAllPythonCode (event,dump)</t>
<t tx="ekr.20070626112754.1736">def prettyPrintPythonCode (self,event=None,p=None,dump=False):

    '''Reformat all Python code in the selected tree to make it look more beautiful.'''

    c = self

    if p: root = p.copy()
    else: root = c.currentPosition();

    pp = c.prettyPrinter(c)

    for p in root.self_and_subtree_iter():

        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyPythonCode (self,event=None,dump=False):
    return self.prettyPrintPythonCode (event,dump)

</t>
<t tx="ekr.20070626112754.1737">def prettyPrintPythonNode (self,p=None,dump=False):

    c = self

    if not p:
        p = c.currentPosition()

    pp = c.prettyPrinter(c)

    # Unlike scanDirectives, scanForAtLanguage ignores @comment.
    if g.scanForAtLanguage(c,p) == "python":
        pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()
</t>
<t tx="ekr.20070626112754.1738">class prettyPrinter:

    @others
</t>
<t tx="ekr.20070626112754.1739">def __init__ (self,c):

    self.array = []
        # List of strings comprising the line being accumulated.
        # Important: this list never crosses a line.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.lastName = None # The name of the previous token type.
    self.line = 0 # Same as self.srow
    self.lineParenLevel = 0
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.squareBracketLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False
    &lt;&lt; define dispatch dict &gt;&gt;
</t>
<t tx="ekr.20070626112754.1740">self.dispatchDict = {

    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
</t>
<t tx="ekr.20070626112754.1741">def clear (self):
    self.lines = []
</t>
<t tx="ekr.20070626112754.1742">def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding

    print ; print '-'*10, p.cleanHeadString()

    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
</t>
<t tx="ekr.20070626112754.1743">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
</t>
<t tx="ekr.20070626112754.1744">def endUndo (self):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()

    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
</t>
<t tx="ekr.20070626112754.1745">def get (self):

    if self.lastName != 'newline' and self.lines:
        # Strip the trailing whitespace from the last line.
        self.lines[-1] = self.lines[-1].rstrip()

    return self.lines
</t>
<t tx="ekr.20070626112754.1746">def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return

    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
</t>
<t tx="ekr.20070626112754.1747">def put (self,s,strip=True):

    """Put s to self.array, and strip trailing whitespace if strip is True."""

    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
</t>
<t tx="ekr.20070626112754.1748">def putArray (self):

    """Add the next text by joining all the strings is self.array"""

    self.lines.append(''.join(self.array))
    self.array = []
    self.lineParenLevel = 0
</t>
<t tx="ekr.20070626112754.1749">def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row &amp; col where the token begins in the source.
    self.erow,self.ecol = t4 # row &amp; col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name
</t>
<t tx="ekr.20070626112754.1750">def doEndMarker (self):

    self.putArray()
</t>
<t tx="ekr.20070626112754.1751">def doErrorToken (self):

    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
</t>
<t tx="ekr.20070626112754.1752">def doDedent (self):

    pass

def doIndent (self):

    self.array.append(self.val)
</t>
<t tx="ekr.20070626112754.1753">def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.

    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()

    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')

    # Suppress start-of-line logic.
    self.line = self.erow
</t>
<t tx="ekr.20070626112754.1754">def doName(self):

    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=&lt;&gt;*-+&amp;|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val
</t>
<t tx="ekr.20070626112754.1755">def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()
</t>
<t tx="ekr.20070626112754.1756">def doNumber (self):

    self.array.append(self.val)
</t>
<t tx="ekr.20070626112754.1757">def doOp (self):

    val = self.val
    outer = self.lineParenLevel &lt;= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','&lt;=','&gt;=','&lt;','&gt;','&lt;&gt;','*','**','+','&amp;','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '&gt;&gt;':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '&lt;&lt;':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and not g.isWordChar(prev[-1]):
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
</t>
<t tx="ekr.20070626112754.1758">def doStartLine (self):

    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]

    if self.ws:
        self.array.append(self.ws)
</t>
<t tx="ekr.20070626112754.1759">def oops(self):

    print "unknown PrettyPrinting code: %s" % (self.name)
</t>
<t tx="ekr.20070626112754.1760">def trace(self):

    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
</t>
<t tx="ekr.20070626112754.1761">def putToken (self,token5tuple):

    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
</t>
<t tx="ekr.20070626112754.1762">def replaceBody (self,p,lines):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    sel = c.frame.body.getInsertPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')

    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        c.setBodyString(p,body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
</t>
<t tx="ekr.20070626112754.1763"></t>
<t tx="ekr.20070626112754.1764"></t>
<t tx="ekr.20070626112754.1765">def contractSubtree (self,p):

    for p in p.subtree_iter():
        p.contract()
</t>
<t tx="ekr.20070626112754.1766">def expandSubtree (self,v):

    c = self
    last = v.lastNode()

    c.beginUpdate()
    try:
        while v and v != last:
            v.expand()
            v = v.threadNext()
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1767">def expandToLevel (self,level):

    c = self
    c.beginUpdate()
    try:
        current = c.currentPosition()
        n = current.level()
        for p in current.self_and_subtree_iter():
            if p.level() - n + 1 &lt; level:
                p.expand()
            else:
                p.contract()
        c.expansionLevel = level
        c.expansionNode = c.currentPosition()
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1768"></t>
<t tx="ekr.20070626112754.1769">def markChangedHeadlines (self,event=None):

    '''Mark all nodes that have been changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1770">def markChangedRoots (self,event=None):

    '''Mark all changed @root nodes.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                s = p.bodyString()
                flag, i = g.is_special(s,0,"@root")
                if flag:
                    bunch = u.beforeMark(p,undoType)
                    c.setMarked(p)
                    c.setChanged(True)
                    u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1771">def markAllAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes as changed.'''

    c = self ; p = c.rootPosition()

    c.beginUpdate()
    try: # In update...
        while p:
            if p.isAtFileNode() and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1772">def markAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes in the selected tree as changed.'''

    c = self
    p = c.currentPosition()
    if not p: return

    after = p.nodeAfterTree()
    c.beginUpdate()
    try: # In update...
        while p and p != after:
            if p.isAtFileNode() and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1773">def markClones (self,event=None):

    '''Mark all clones of the selected node.'''

    c = self ; u = c.undoer ; undoType = 'Mark Clones'
    current = c.currentPosition()
    if not current or not current.isCloned():
        g.es('The current node is not a clone',color='blue')
        return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.v.t == current.v.t:
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                c.setChanged(True)
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1774">def markHeadline (self,event=None):

    '''Toggle the mark of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    try: # In update...
        undoType = g.choose(p.isMarked(),'Unmark','Mark')
        bunch = u.beforeMark(p,undoType)
        if p.isMarked():
            c.clearMarked(p)
        else:
            c.setMarked(p)
        dirtyVnodeList = p.setDirty()
        c.setChanged(True)
        u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1775">def markSubheads (self,event=None):

    '''Mark all children of the selected node as changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in current.children_iter():
            if not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1776">def unmarkAll (self,event=None):

    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        changed = False
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                c.clearMarked(p)
                p.v.t.setDirty()
                u.afterMark(p,undoType,bunch)
        dirtyVnodeList = [p.v for p in c.allNodes_iter() if p.v.isDirty()]
        if changed: c.setChanged(True)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()</t>
<t tx="ekr.20070626112754.1777"></t>
<t tx="ekr.20070626112754.1778">def dragAfter(self,p,after):

    c = self ; u = self.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkMoveWithParentWithWarning(p,after.parent(),True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(after)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20070626112754.1779">def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()

    c.beginUpdate()
    try: # In update...
        # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
        clone = p.clone() # Creates clone &amp; dependents, does not set undo.
        if not c.checkMoveWithParentWithWarning(clone,parent,True):
            clone.doDelete() # Destroys clone and makes p the current node.
            c.selectPosition(p) # Also sets root position.
            c.endUpdate(False) # Nothing has changed.
            return
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
           dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
           dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(clone) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20070626112754.1780">def dragToNthChildOf(self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkMoveWithParentWithWarning(p,parent,True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20070626112754.1781">def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    c.beginUpdate()
    try: # In update...
        clone = p.clone() # Creates clone.  Does not set undo.
        if c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            inAtIgnoreRange = clone.inAtIgnoreRange()
            c.endEditing()
            undoData = u.beforeInsertNode(current)
            dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
            clone.moveAfter(after)
            if inAtIgnoreRange and not clone.inAtIgnoreRange():
                # The moved node have just become newly unignored.
                dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
            p = clone
        else:
            # g.trace("invalid clone drag")
            clone.doDelete()
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="ekr.20070626112754.1782"></t>
<t tx="ekr.20070626112754.1783">def cloneNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then clone the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'clone-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = cc.chaptersDict.keys()
        prefix = 'Clone node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.cloneNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.cloneNodeToChapterHelper(k.arg)</t>
<t tx="ekr.20070626112754.1784">def cloneNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ;  u = c.undoer ; undoType = 'Clone Node To Chapter'
    p = c.currentPosition() ; h = p.headString()
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if fromChapter.name == 'main' and h.startswith('@chapter'):
        return cc.error('can not clone @chapter node')
    # g.trace('from',fromChapter.name,'to',toChapter)

    c.beginUpdate()
    try:
        # Open the group undo.
        c.undoer.beforeChangeGroup(p,undoType)
        # Do the clone.  c.clone handles the inner undo.
        clone = c.clone()
        # Do the move.
        undoData2 = u.beforeMoveNode(clone)
        clone.unlink()
        if toChapter.name == 'main':
            clone.moveAfter(toChapter.p)
        else:
            parent = cc.getChapterNode(toChapter.name)
            clone.moveToLastChildOf(parent)
        u.afterMoveNode(clone,'Move Node',undoData2,dirtyVnodeList=[])
        c.selectPosition(clone)
        c.setChanged(True)
        # Close the group undo.
        # Only the ancestors of the moved node get set dirty.
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.undoer.afterChangeGroup(clone,undoType,reportFlag=False,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(False)

    toChapter.p = clone.copy()
    toChapter.select()
    fromChapter.p = p.copy()
</t>
<t tx="ekr.20070626112754.1785">def convertNodeToChapter (self,event=None):

    '''convert-node-to-chapter command.

    Make the selected node into a new chapter, 'in place'.
    That is, create the new @chapter node as the next sibling of the node,
    then move the node as the first child of the new @chapter node.'''

    cc = self ; c = cc.c ; k = c.k ; tag = 'convert-node-to-chapter'
    state = k.getState(tag)

    p = c.currentPosition()
    if p.headString().startswith('@chapter'):
        cc.error('Can not create a new chapter from from an @chapter or @chapters node.')
        return

    if state == 0:
        names = cc.chaptersDict.keys()
        k.setLabelBlue('Convert node to chapter: ',protect=True)
        k.getArg(event,tag,1,self.convertNodeToChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=c.currentPosition(),
                undoType='Convert Node To Chapter')
</t>
<t tx="ekr.20070626112754.1786">def copyNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then copy the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'copy-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = cc.chaptersDict.keys()
        prefix = 'Copy node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.copyNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.copyNodeToChapterHelper(k.arg)</t>
<t tx="ekr.20070626112754.1787">def copyNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; u = c.undoer ; undoType = 'Copy Node To Chapter'
    p = c.currentPosition() ; h = p.headString()
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if fromChapter.name == 'main' and h.startswith('@chapter'):
        return cc.error('can not copy @chapter node')
    # g.trace('from',fromChapter.name,'to',toChapter.name)

    c.beginUpdate()
    try:
        # For undo, we treat the copy like a pasted (inserted) node.
        # Use parent as the node to select for undo.
        parent = cc.getChapterNode(toChapter.name)
        undoData = u.beforeInsertNode(parent,pasteAsClone=False,copiedBunchList=[])
        s = c.fileCommands.putLeoOutline()
        p2 = c.fileCommands.getLeoOutline(s)
        p2.unlink()
        p2.moveToLastChildOf(parent)
        c.selectPosition(p2)
        u.afterInsertNode(p2,undoType,undoData)
        c.setChanged(True)
    finally:
        c.endUpdate(False)

    toChapter.p = p2.copy()
    toChapter.select()
    fromChapter.p = p.copy()
</t>
<t tx="ekr.20070626112754.1788">def createChapterByName (self,name,p,undoType):

    cc = self ; c = cc.c

    if not name:
        return cc.error('No name')

    oldChapter = cc.getSelectedChapter()
    theChapter = cc.chaptersDict.get(name)
    if theChapter:
        return cc.error('Duplicate chapter name: %s' % name)

    bunch = cc.beforeCreateChapter(c.currentPosition(),oldChapter.name,name,undoType)
    if undoType == 'Convert Node To Chapter':
        root = p.insertAfter()
        root.initHeadString('@chapter %s' % name)
        p.moveToFirstChildOf(root)
    elif undoType in ('Create Chapter From Node','Create Chapter'):
        # Create the @chapter node.
        # If p exists, clone it as the first child, else create a dummy first child.
        root = cc.getChapterNode(name,p=p)
    else:
        return g.trace('Can not happen: bad undoType: %s' % undoType)

    cc.chaptersDict[name] = chapter(c=c,chapterController=cc,name=name,root=root)
    cc.selectChapterByName(name)
    cc.afterCreateChapter(bunch,c.currentPosition())

    # g.es('created chapter %s' % (name),color='blue')
    return True
</t>
<t tx="ekr.20070626112754.1789">def createChapterFromNode (self,event=None):

    '''create-chapter-from-node command.

    Create a chapter whose first node is a clone of the presently selected node.'''

    cc = self ; c = cc.c ; k = c.k ; tag = 'create-chapter-from-node'
    state = k.getState(tag)

    p = c.currentPosition()
    if p.headString().startswith('@chapter'):
        cc.error('Can not create a new chapter from from an @chapter or @chapters node.')
        return

    if state == 0:
        names = cc.chaptersDict.keys()
        k.setLabelBlue('Create chapter from node: ',protect=True)
        k.getArg(event,tag,1,self.createChapterFromNode,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=p,
                undoType='Create Chapter From Node')
</t>
<t tx="ekr.20070626112754.1790">def moveNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then move the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'move-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = cc.chaptersDict.keys()
        prefix = 'Copy node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.moveNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.moveNodeToChapterHelper(k.arg)</t>
<t tx="ekr.20070626112754.1791">def moveNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; u = c.undoer ; undoType = 'Move Node To Chapter'
    p = c.currentPosition()
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)

    if 1: # Defensive code: should never happen.
        if fromChapter.name == 'main' and p.headString().startswith('@chapter'):
            return cc.error('can not move @chapter node')

    c.beginUpdate()
    try:
        if toChapter.name == 'main':
            sel = (p.threadBack() != fromChapter.root and p.threadBack()) or p.nodeAfterTree()
        else:
            sel = p.threadBack() or p.nodeAfterTree()
        if sel:
            # Get 'before' undo data.
            inAtIgnoreRange = p.inAtIgnoreRange()
            undoData = u.beforeMoveNode(p)
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
            # Do the move.
            if toChapter.name == 'main':
                p.unlink()
                p.moveAfter(toChapter.p)
            else:
                p.unlink()
                p.moveToLastChildOf(toChapter.root)
            c.selectPosition(sel)
            c.setChanged(True)
            # Do the 'after' undo operation.
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(False) # toChapter.select will do the drawing.

    if sel:
        toChapter.p = p.copy()
        toChapter.select()
        fromChapter.p = sel.copy()
    else:
        cc.error('Can not move the last node of a chapter.')
</t>
<t tx="ekr.20070626112754.1792">def removeChapter (self,event=None):

    cc = self ; c = cc.c

    theChapter = cc.selectedChapter
    if not theChapter: return

    name = theChapter.name

    if name == 'main':
        return cc.error('Can not remove the main chapter')
    else:
        cc.removeChapterByName(name)
</t>
<t tx="ekr.20070626112754.1793">def removeChapterByName (self,name):

    cc = self ; c = cc.c ; tt = cc.tt

    theChapter = cc.chaptersDict.get(name)
    if not theChapter: return

    c.beginUpdate()
    try:
        savedRoot = theChapter.root
        bunch = cc.beforeRemoveChapter(c.currentPosition(),name,savedRoot)
        cc.deleteChapterNode(name)
        del cc.chaptersDict[name] # Do this after calling deleteChapterNode.
        if tt:tt.destroyTab(name)
        cc.selectChapterByName('main')
        cc.afterRemoveChapter(bunch,c.currentPosition())
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1794"># newName is for unitTesting.

def renameChapter (self,event=None,newName=None):

    '''Use the minibuffer to get a new name for the present chapter.'''

    cc = self ; c = cc.c ; k = cc.c.k ; tt = cc.tt
    tag = 'rename-chapter'
    theChapter = cc.selectedChapter
    if not theChapter: return
    if theChapter.name == 'main':
        return cc.error('Can not rename the main chapter')

    state = k.getState(tag)

    if state == 0 and not newName:
        names = cc.chaptersDict.keys()
        prefix = 'Rename this chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.renameChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if newName: k.arg = newName
        if k.arg and k.arg != theChapter.name:
            oldChapterName = theChapter.name
            del cc.chaptersDict[theChapter.name]
            cc.chaptersDict[k.arg] = theChapter
            theChapter.name = k.arg
            root = theChapter.root
            root.initHeadString('@chapter %s' % k.arg)
            if tt:
                tt.setTabLabel(k.arg)
                tt.destroyTab(oldChapterName)
                tt.createTab(k.arg)
            c.redraw_now()
</t>
<t tx="ekr.20070626112754.1795">def selectChapter (self,event=None):

    '''Use the minibuffer to get a chapter name,
    then create the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'select-chapter'
    state = k.getState(tag)

    if state == 0:
        names = cc.chaptersDict.keys()
        prefix = 'Select chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.selectChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.selectChapterByName(k.arg)
</t>
<t tx="ekr.20070626112754.1796"></t>
<t tx="ekr.20070626112754.1797"></t>
<t tx="ekr.20070626112754.1798"># ctypes comes standard with Python 2.5, but can be installed for Python 2.4.
</t>
<t tx="ekr.20070626112754.1799"></t>
<t tx="ekr.20070626112754.1800"># Created menu-command-key command that just returns 'continue'.</t>
<t tx="ekr.20070626112754.1801">@

This should fix the nodenavigator plugin.

Added goto-first-visible command.</t>
<t tx="ekr.20070626112754.1802">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4362825
By: rcy3cornelledu

The "Home" key selects first node in main outline, regardless of which chapter
is currently displayed.</t>
<t tx="ekr.20070626112754.1803">def firstVisible(self):

    """Move to the first visible node of the present chapter or hoist."""

    c = self ; p = c.currentPosition()

    while 1:
        back = p.visBack(c)
        if back and back.isVisible(c):
            p = back
        else: break
    return p
</t>
<t tx="ekr.20070626112754.1804">def selectChapterForPosition (self,p):

    '''
    Select a chapter containing position p.
    Do nothing if p if p does not exist or is in the presently selected chapter.
    '''
    cc = self ; c = cc.c

    if not p or not c.positionExists(p):
        return

    theChapter = cc.getSelectedChapter()
    if not theChapter: return

    # g.trace('selected:',theChapter.name)
    firstName = theChapter.name
    if firstName != 'main':
        if theChapter.positionIsInChapter(p): return

    for name in cc.chaptersDict.keys():
        if name not in (firstName,'main'):
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                cc.selectChapterByName(name)
                return
    else:
        cc.selectChapterByName('main')
</t>
<t tx="ekr.20070626112754.1805">@
Selecting a node now never truncates the beadList.</t>
<t tx="ekr.20070626112754.1806">class nodeHistory:

    '''A class encapsulating knowledge of visited nodes.'''

    @others
</t>
<t tx="ekr.20070626112754.1807">def canGoToNextVisited (self):

    return self.beadPointer + 1 &lt; len(self.beadList)

def canGoToPrevVisited (self):

    return self.beadPointer &gt; 0
</t>
<t tx="ekr.20070626112754.1808">def clear (self):

    self.visitedList = []
</t>
<t tx="ekr.20070626112754.1809">def goNext (self):

    '''Return the next visited node, or None.'''
    if self.beadPointer + 1 &lt; len(self.beadList):
        self.beadPointer += 1
        p,chapter = self.beadList[self.beadPointer]
        self.selectChapter(chapter)
        return p
    else:
        return None

def goPrev (self):

    '''Return the previous visited node, or None.'''
    if self.beadPointer &gt; 0:
        self.beadPointer -= 1
        p,chapter = self.beadList[self.beadPointer]
        self.selectChapter(chapter)
        return p
    else:
        return None
</t>
<t tx="ekr.20070626112754.1810">def __init__ (self,c):

    self.c = c

    self.beadList = [] # list of (position,chapter) tuples for the Back and Forward commands.
    self.beadPointer = -1
    self.visitedList = [] # list of (position,chapter) tuples for the Nodes dialog.
</t>
<t tx="ekr.20070626112754.1811">def remove (self,p):

    for data in self.visitedList:
        p2,chapter = data
        if p == p2:
            self.visitedList.remove(data)
            break
</t>
<t tx="ekr.20070626112754.1812">def selectChapter (self,chapter):

    c = self.c ; cc = c.chapterController
    if not cc or not chapter: return

    if chapter != cc.getSelectedChapter():
        cc.selectChapterByName(chapter.name)
</t>
<t tx="ekr.20070626112754.1813">def update (self,p,updateBeadList):

    if updateBeadList:
        self.updatePositionList(p)
    self.updateVisitedList(p)
</t>
<t tx="ekr.20070626112754.1814">def updatePositionList (self,p):

    # Don't change the list if p is already in it.
    c = self.c ; cc = c.chapterController
    update = True
    for data in self.beadList:
        p2,chapter = data
        if p2 == p:
            update = False
        if not c.positionExists(p2,root=c.rootPosition()):
            self.beadList.remove(data)
            update = True ; break

    # Add the node to the end, and set the bead pointer to the end.
    if update:
        theChapter = cc and cc.getSelectedChapter()
        data = p.copy(),theChapter
        self.beadList.append(data)
        self.beadPointer = len(self.beadList)-1
        #g.trace('updating bead list',p.headString())
        #print [p.headString() for p in self.beadList]
</t>
<t tx="ekr.20070626112754.1815">def updateVisitedList (self,p):

    '''Make p the most recently visited position.'''

    c = self.c ; cc = c.chapterController
    for data in self.visitedList:
        p2,chapter = data
        if p2 == p:
            self.visitedList.remove(data)
            break

    chapter = cc and cc.getSelectedChapter()
    data = p.copy(),chapter
    self.visitedList.insert(0,data)

    # g.trace('len(c.visitedList)',len(c.visitedList))
    # g.trace([z.headString()[:10] for z in self.visitedList]) # don't assign to p!
</t>
<t tx="ekr.20070626112754.1816">def visitedPositions (self):

    return [p.copy() for p,chapter in self.visitedList]
</t>
<t tx="ekr.20070626112754.1817">menu = frame.menu.getMenu("Go To...")
enable(menu,"Go To Prev Visited",c.nodeHistory.canGoToPrevVisited())
enable(menu,"Go To Next Visited",c.nodeHistory.canGoToNextVisited())
enable(menu,"Go To Prev Visible",c.canSelectVisBack())
enable(menu,"Go To Next Visible",c.canSelectVisNext())
if 0: # These are too slow.
    enable(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
    enable(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())
enable(menu,"Go To Next Clone",isCloned)
enable(menu,"Go To Prev Node",c.canSelectThreadBack())
enable(menu,"Go To Next Node",c.canSelectThreadNext())
enable(menu,"Go To Parent",hasParent)
enable(menu,"Go To Prev Sibling",hasBack)
enable(menu,"Go To Next Sibling",hasNext)
</t>
<t tx="ekr.20070626112754.1818"># CleanLines was adding a trailing newline.
# The fix was to suppress this during unit tests.</t>
<t tx="ekr.20070626112754.1819">@nocolor

By: mstarzyk

There is a problem with coloring of @file (@thin, and others) nodes. 
After you navigate in the tree out of the node, then the node you just
left does not get the proper (unselected) color - until you close and 
reopen the parent node.

This is a problem when you have several @thin nodes and switch 
between them, because it is difficult in the tree which node is the 
current - they are all dark green. 
Please see below for a patch that fixes this problem. 

Cheers, 
Maciek

Index: plugins/cleo.py
===================================================================
RCS file: /cvs/leo/plugins/cleo.py,v
retrieving revision 1.9
diff -r1.9 cleo.py
504c504
&lt;     def custom_colours(self,v):
---
&gt;     def custom_colours(self, v, node_is_selected):
520c520
&lt;                 if h == MeSelf:
---
&gt;                 if node_is_selected:
527c527
&lt;             if h == MeSelf:
---
&gt;             if node_is_selected:
814c814
&lt;         fg, bg = self.custom_colours(p.v)
---
&gt;         fg, bg = self.custom_colours(p.v, node_is_selected=False)
835c835
&lt;         fg, bg = self.custom_colours(p.v)
---
&gt;         fg, bg = self.custom_colours(p.v, node_is_selected=True)
</t>
<t tx="ekr.20070626112754.1820"></t>
<t tx="ekr.20070626112754.1821">@nocolor

The coloring for PHP has 2 major issues that

 1 - it wont trigger on multiple line comments: /* */

 2 - Enlarged Keywords sometimes bug on key up end key down movement of cursor
in the body, it sucks visualy too,.


What I did:

- Added /* and */ to php delims.  This solves 1.

- @settings--&gt;Colors--&gt;Syntax colors &amp; options--&gt;Options for jEdit colorer--&gt;Langauge-specific colors--&gt;php--&gt;@font php keyword fonts (old colorizer)

The new settings:

php_keyword_font_size = None
php_keyword_font_slant = roman
    # roman, italic
php_keyword_font_weight = normal
    # normal, bold
</t>
<t tx="ekr.20070626112754.1822">self.state_dict = {
    "blockComment" : self.continueBlockComment,
    "doubleString" : self.continueDoubleString, # 1/25/03
    "nocolor"      : self.continueNocolor,
    "normal"       : self.doNormalState,
    "singleString" : self.continueSingleString,  # 1/25/03
    "string3s"     : self.continueSinglePythonString,
    "string3d"     : self.continueDoublePythonString,
    "doc"          : self.continueDocPart,
    "unknown"      : self.doNormalState, # 8/25/05
}

# Eventually all entries in these dicts will be entered dynamically
# under the control of the XML description of the present language.

if 0: # not ready yet.

    self.dict1 = { # 1-character patterns.
        '"' : self.doString,
        "'" : self.doString,
        '@' : self.doPossibleLeoKeyword,
        ' ' : self.doBlank,
        '\t': self.doTab }

    self.dict2 = {} # 2-character patterns

    # Searching this list might be very slow!
    mutli_list = [] # Multiple character patterns.

    # Enter single-character patterns...
    if self.has_pp_directives:
        dict1 ["#"] = self.doPPDirective

    for ch in string.ascii_letters:
        dict1 [ch] = self.doPossibleKeyword
    dict1 ['_'] = self.doPossibleKeyword

    if self.language == "latex":
        dict1 ['\\'] = self.doPossibleKeyword

    if self.language == "php":
        dict1 ['&lt;'] = self.doSpecialPHPKeyword
        dict1 ['?'] = self.doSpecialPHPKeyword

    # Enter potentially multi-character patterns.  (or should this be just 2-character patterns)
    if self.language == "cweb":
        dict2 ["@("] = self.doPossibleSectionRefOrDef
    else:
        dict2 ["&lt;&lt;"] = self.doPossibleSectionRefOrDef

    if self.single_comment_start:
        n = len(self.single_comment_start)
        if n == 1:
            dict1 [self.single_comment_start] = self.doSingleCommentLine
        elif n == 2:
            dict2 [self.single_comment_start] = self.doSingleCommentLine
        else:
            mutli_list.append((self.single_comment_start,self.doSingleCommentLine),)

    if self.block_comment_start:
        n = len(self.block_comment_start)
        if n == 1:
            dict1 [self.block_comment_start] = self.doBlockComment
        elif n == 2:
            ddict2 [self.block_comment_start] = self.doBlockComment
        else:
            mutli_list.append((self.block_comment_start,self.doBlockComment),)
</t>
<t tx="ekr.20070626112754.1823"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "cpp" : "// /* */",# C++.
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "// /* */", # 6/23/07: was "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "cpp" : "cpp",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.

self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
</t>
<t tx="ekr.20070626112754.1824">if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2
</t>
<t tx="ekr.20070626112754.1825">if g.match(s.lower(),i,"&lt;?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?&gt;"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1
</t>
<t tx="ekr.20070626112754.1826">def doNormalState (self,s,i):

    __pychecker__ = 'maxlines=500'

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&amp;&lt;&gt;' and self.language=="html") or
        (ch == '$' and self.language=="rapidq") or
        (self.language == 'forth' and ch in "`~!@#$%^&amp;*()_+-={}|[];':\",./&lt;&gt;?")
    ):
        &lt;&lt; handle possible keyword &gt;&gt;
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        &lt;&lt; handle at keyword &gt;&gt;
    elif g.match(s,i,self.single_comment_start):
        &lt;&lt; handle single-line comment &gt;&gt;
    elif g.match(s,i,self.block_comment_start):
        &lt;&lt; start block comment &gt;&gt;
    elif ch == '%' and self.language=="cweb":
        &lt;&lt; handle latex line &gt;&gt;
    elif self.language=="latex":
        &lt;&lt; handle latex normal character &gt;&gt;
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        &lt;&lt; handle string &gt;&gt;
    elif ch == '#' and self.has_pp_directives:
        &lt;&lt; handle C preprocessor line &gt;&gt;
    elif self.language == "php" and (g.match(s,i,"&lt;") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        &lt;&lt; handle special php keywords &gt;&gt;
    elif ch == ' ':
        &lt;&lt; handle blank &gt;&gt;
    elif ch == '\t':
        &lt;&lt; handle tab &gt;&gt;
    else:
        &lt;&lt; handle normal character &gt;&gt;

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress &lt; i)
    return i,state
</t>
<t tx="ekr.20070626112754.1827"></t>
<t tx="ekr.20070626112754.1828">if self.language == "latex":
    &lt;&lt; handle possible latex keyword &gt;&gt;
elif self.language == "html":
    &lt;&lt; handle possible html keyword &gt;&gt;
elif self.language == "forth":
    &lt;&lt; handle possible forth keyword &gt;&gt;
else:
    &lt;&lt; handle general keyword &gt;&gt;
i = j
</t>
<t tx="ekr.20070626112754.1829">if g.match(s,i,"\\"):
    if i + 1 &lt; len(s) and s[i+1] in self.latex_special_keyword_characters:
        j = i + 2 # A special 2-character LaTex keyword.
    else:
        j = self.skip_id(s,i+1)
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
</t>
<t tx="ekr.20070626112754.1830">if g.match(s,i,"&lt;!---") or g.match(s,i,"&lt;!--"):
    if g.match(s,i,"&lt;!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"&lt;"):
    if g.match(s,i,"&lt;/"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&amp;"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/&gt;"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,"&gt;"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
</t>
<t tx="ekr.20070626112754.1831">j = self.skip_id(s,i+1,chars="`~!@#$%^&amp;*()-_=+[]{};:'\\\",./&lt;&gt;?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True

    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)
</t>
<t tx="ekr.20070626112754.1832">if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@&lt;"):
        &lt;&lt; handle cweb ref or def &gt;&gt;
    else:
        word = self.getCwebWord(s,i)
        if word:
            &lt;&lt; Handle cweb control word &gt;&gt;
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)
</t>
<t tx="ekr.20070626112754.1833">self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@&gt;=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@&gt;",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
</t>
<t tx="ekr.20070626112754.1834"># Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@&lt;","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@&gt;"
    j = s.find("@&gt;",i)
    if j &gt; -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2
</t>
<t tx="ekr.20070626112754.1835"># print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i&gt;0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j
</t>
<t tx="ekr.20070626112754.1836">k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"
</t>
<t tx="ekr.20070626112754.1837">self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
</t>
<t tx="ekr.20070626112754.1838"></t>
<t tx="ekr.20070626112754.1839">if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1
</t>
<t tx="ekr.20070626112754.1840"></t>
<t tx="ekr.20070626112754.1841"># g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
</t>
<t tx="ekr.20070626112754.1842"># 10/17/02: recognize comments in preprocessor lines.
j = i
while i &lt; len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)
</t>
<t tx="ekr.20070626112754.1843">if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1
</t>
<t tx="ekr.20070626112754.1844">if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1
</t>
<t tx="ekr.20070626112754.1845"># self.tag("normal",i,i+1)
i += 1
</t>
<t tx="ekr.20070626112754.1846"></t>
<t tx="ekr.20070626112754.1847"></t>
<t tx="ekr.20070626112754.1848"></t>
<t tx="ekr.20070626112754.1849">Alt-home is now bound to goto-first-visible rather than goto-first.</t>
<t tx="ekr.20070626112754.1850">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319356

Pythonistas have come to expect that::

 $ easy_install &lt;app&gt;

will locate and install the most recent version of app and install it.
</t>
<t tx="ekr.20070626112754.1851">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4359597

These are no longer needed now that the user can use the Debian package manager or easy_install.</t>
<t tx="ekr.20070626112754.1852">@nocolor

This script runs all @test nodes as follows:

- Copies all @suite and @tests nodes to dynamicUnitTests.leo.

- Runs leoDynamicTest.py in a separate process. In turn, leoDynamicTest.py
  use the leoBridge module to run dynamicUnitTests.leo.
  (test.leo contains the source code for leoDynamicTest.py.)

Thus, all unit tests will be run with the latest Leo sources.

Allowing @test nodes in leoPy.leo is important: unit tests can be placed near
the code they are intended to test.</t>
<t tx="ekr.20070626112754.1853"></t>
<t tx="ekr.20070626112754.1854">@nocolor

What I did:

- use g.getTestVars()
- Replaced test_ functions with @test.
- Removed the code in unitTest.leo that looks for test_functions.
</t>
<t tx="ekr.20070626112754.1855"></t>
<t tx="ekr.20070626112754.1856">The chapter commands provide a good example.  In this file, see the node:

Code--&gt;Core classes...--&gt;@thin leoChapters.py--&gt;class chapterController--&gt;Undo

The general plan is this:

1. The command handler calls a **beforeCommand** method before changing the outline.

The beforeCommand method creates a g.Bunch that contains all the information needed to
restore the outline to its previous state. Typically, the beforeCommand method
will call c.undoer.createCommonBunch(p), where p is, as usual,
c.currentPosition().

2. After changing the outline the command handler calls an **afterCommand** method.

This method should take as one argument the g.Bunch returned by the
beforeCommand method. In the discussion below, denote this bunch by b. The
afterCommand method adds any information required to redo the operation after
the operation has been undone.

The afterCommand method also sets b.undoHelper and b.redoHelper to two method
that actually perform the undo and redo operations. (Actually, the beforeCommand
method could also set these two entries).

When the afterCommand method has 'filled in' all the entries of b, the
afterCommand method must call u.pushBead(b). This pushes all the undo
operation on a stack managed by the Leo's undoer, i.e., c.commands.undoer.

3. The undoer calls the undoHelper and redoHelper methods to perform the actual undo and redo operations.

The undoer handles most of the housekeeping chores related to undo and redo.  All the undoHelper and redoHelper methods have to do is actually alter Leo's outline.

**Note**: the undoer creates an ivar (instance variable) of the *undoer* class for every entry in the bunch b passed as an argument to u.pushBead(b).  For example, suppose u = c.commands.under and that b has ivars 'a','b' and 'c'.  Then, on entry to the undoHelper and the redoHelper the u.a, u.b and u.c ivars will be defined.  This makes it unnecessary for the undoHelper or the redoHelper to 'unpack' b explicitly.

Writing correct undo and redo helpers is usually a bit tricky.  The code is often subtly different from the original code that implements a command.  That just can't be helped.




</t>
<t tx="ekr.20070626112754.1857"></t>
<t tx="ekr.20070626112754.1858">def afterCreateChapter (self,bunch,p):

    cc = self ; u = cc.c.undoer
    if u.redoing or u.undoing: return

    bunch.kind = 'create-chapter'
    bunch.newP = p.copy()

    # Set helpers
    bunch.undoHelper = cc.undoInsertChapter
    bunch.redoHelper = cc.redoInsertChapter

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.1859">def afterRemoveChapter (self,bunch,p):

    cc = self ; u = cc.c.undoer
    if u.redoing or u.undoing: return

    bunch.kind = 'remove-chapter'
    bunch.newP = p.copy()

    # Set helpers
    bunch.undoHelper = cc.undoRemoveChapter
    bunch.redoHelper = cc.redoRemoveChapter

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.1860">def beforeCreateChapter (self,p,oldChapterName,newChapterName,undoType):

    cc = self ; u = cc.c.undoer

    bunch = u.createCommonBunch(p)

    bunch.oldChapterName = oldChapterName
    bunch.newChapterName = newChapterName
    bunch.savedRoot = None
    bunch.undoType = undoType

    return bunch
</t>
<t tx="ekr.20070626112754.1861">def beforeRemoveChapter (self,p,newChapterName,savedRoot):

    cc = self ; u = cc.c.undoer

    bunch = u.createCommonBunch(p)

    bunch.newChapterName = newChapterName
    bunch.savedRoot = savedRoot
    bunch.undoType = 'Remove Chapter'

    return bunch
</t>
<t tx="ekr.20070626112754.1862">def redoInsertChapter (self):

    cc = self ; c = cc.c ; u = c.undoer

    # g.trace(u.newChapterName,u.oldChapterName,u.p)

    cc.createChapterByName(u.newChapterName,p=u.savedRoot,undoType=u.undoType)
    theChapter = cc.getChapter(u.newChapterName)

    if u.undoType == 'Convert Node To Chapter':
        pass
    elif u.undoType in ('Create Chapter From Node','Create Chapter'):
        root = theChapter.root
        firstChild = root.firstChild()
        firstChild.unlink()
        firstChild = u.savedRoot.firstChild()
        firstChild.linkAsNthChild(root,0)
    else:
        return g.trace('Can not happen: bad undoType: %s' % u.undoType)
</t>
<t tx="ekr.20070626112754.1863">def redoRemoveChapter (self):

    cc = self ; u = cc.c.undoer

    cc.removeChapterByName(u.newChapterName)
    cc.selectChapterByName('main')</t>
<t tx="ekr.20070626112754.1864">def undoInsertChapter (self):

    cc = self ; c = cc.c ; u = c.undoer

    newChapter = cc.getChapter(u.newChapterName)

    bunch = u.beads[u.bead]
    bunch.savedRoot = root = newChapter.root

    if u.undoType == 'Convert Node To Chapter':
        p = root.firstChild()
        p.moveAfter(root)
    else:
        pass # deleting the chapter will delete the node.

    cc.removeChapterByName(u.newChapterName)
    cc.selectChapterByName('main')
</t>
<t tx="ekr.20070626112754.1865">def undoRemoveChapter (self):

    cc = self ; c = cc.c ; u = c.undoer

    # u.savedRoot is the entire @chapter tree.
    # Link it as the last child of the @chapters node.
    parent = cc.findChaptersNode()
    u.savedRoot.linkAsNthChild(parent,parent.numberOfChildren())

    # Now recreate the chapter.
    name = u.newChapterName
    cc.chaptersDict[name] = chapter(c=c,chapterController=cc,name=name,root=u.savedRoot)
    cc.selectChapterByName(name)
</t>
<t tx="ekr.20070703172620"></t>
<t tx="ekr.20070703172620.1"></t>
<t tx="ekr.20070703172620.2"># can not open: C:\prog\tigris-cvs\leo\config\myLeoSettings.leo
</t>
<t tx="ekr.20070703172620.3">def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeDir second.
    if configDir == loadDir:
        g.es("%s not found in %s" % (name,configDir))
    else:
        fileName = g.os_path_join(homeDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es("%s not found in %s or %s" % (name,configDir,homeDir))
</t>
<t tx="ekr.20070703172620.4">def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(fileName=fileName,gui=gui)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame</t>
<t tx="ekr.20070703172620.5">@

It's a bit tricky to ensure that leo/src is in sys.path
The code now changes the working directory to leo/src,
and leoDynamicTest.py adds os.getcwd() to sys.path if it is not there.
This is a dubious plan.

# import os,sys
# print 'cwd', os.getcwd()
# for s in sys.path: print s
</t>
<t tx="ekr.20070703172620.6">class debugCommandsClass (baseEditCommandsClass):

    @others
</t>
<t tx="ekr.20070703172620.7">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
</t>
<t tx="ekr.20070703172620.8">def getPublicCommands (self):

    k = self

    return {
        'collect-garbage':              self.collectGarbage,
        'debug':                        self.debug,
        'disable-gc-trace':             self.disableGcTrace,
        'dump-all-objects':             self.dumpAllObjects,
        'dump-new-objects':             self.dumpNewObjects,
        'enable-gc-trace':              self.enableGcTrace,
        'free-tree-widgets':            self.freeTreeWidgets,
        'print-focus':                  self.printFocus,
        'print-stats':                  self.printStats,
        'print-gc-summary':             self.printGcSummary,
        'run-all-unit-tests':           self.runAllUnitTests, # The new way...
        'run-unit-tests':               self.runUnitTests,
        'run-all-unit-tests-locally':   self.runAllUnitTestsLocally, # The old way...
        'run-unit-tests-locally':       self.runUnitTestsLocally,
        'verbose-dump-objects':         self.verboseDumpObjects,
    }
</t>
<t tx="ekr.20070703172620.9">def collectGarbage (self,event=None):

    """Run Python's Gargabe Collector."""

    g.collectGarbage()
</t>
<t tx="ekr.20070703172620.10">def debug (self,event=None):

    '''Start an external debugger in another process to debug the presently selected text.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    # pythonDir = g.os_path_dirname(python)
    script = p.bodyString()
    winpdb = self.findDebugger()
    if not winpdb: return

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
</t>
<t tx="ekr.20070703172620.11">def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
</t>
<t tx="ekr.20070703172620.12">def dumpAllObjects (self,event=None):

    '''Print a summary of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcAll()
    g.app.trace_gc = old

def dumpNewObjects (self,event=None):

    '''Print a summary of all Python objects created
    since the last time Python's Garbage collector was run.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcObjects()
    g.app.trace_gc = old

def verboseDumpObjects (self,event=None):

    '''Print a more verbose listing of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcVerbose()
    g.app.trace_gc = old
</t>
<t tx="ekr.20070703172620.13">def disableGcTrace (self,event=None):

    '''Enable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = False


def enableGcTrace (self,event=None):

    '''Disable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = True
    g.enable_gc_debug()

    if g.app.trace_gc_verbose:
        g.es('enabled verbose gc stats',color='blue')
    else:
        g.es('enabled brief gc stats',color='blue')
</t>
<t tx="ekr.20070703172620.14">def freeTreeWidgets (self,event=None):

    '''Free all widgets used in Leo's outline pane.'''

    c = self.c

    c.frame.tree.destroyWidgets()
    c.redraw_now()
</t>
<t tx="ekr.20070703172620.15"># Doesn't work if the focus isn't in a pane with bindings!

def printFocus (self,event=None):

    '''Print information about the requested focus (for debugging).'''

    c = self.c

    g.es_print('      hasFocusWidget: %s' % c.widget_name(c.hasFocusWidget))
    g.es_print('requestedFocusWidget: %s' % c.widget_name(c.requestedFocusWidget))
    g.es_print('           get_focus: %s' % c.widget_name(c.get_focus()))
</t>
<t tx="ekr.20070703172620.16">def printGcSummary (self,event=None):

    '''Print a brief summary of all Python objects.'''

    g.printGcSummary()
</t>
<t tx="ekr.20070703172620.17">def printStats (self,event=None):

    '''Print statistics about the objects that Leo is using.'''

    c = self.c
    c.frame.tree.showStats()
    self.dumpAllObjects()
</t>
<t tx="ekr.20070703172620.18">def runAllUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.doTests(c,all=True)

def runUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.doTests(c,all=False)

def runAllUnitTests (self,event=None):
    '''Run all unit tests contained in the entire outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=True)

def runUnitTests(self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=False)
</t>
<t tx="ekr.20070703172620.19"></t>
<t tx="ekr.20070703172620.20">def computeGlobalConfigDir():

    # Suppresses warning about sys.leo_config_directory
    #__pychecker__ = '--limit = 0'
    #__pychecker__ = '--no-classattr --no-objattrs'

    import leoGlobals as g

    encoding = g.startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")

    if theDir:
        theDir = g.os_path_abspath(theDir)

    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None

    return theDir
</t>
<t tx="ekr.20070703172620.21">def computeHomeDir():

    """Returns the user's home directory."""

    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) &gt; 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
</t>
<t tx="ekr.20070703172620.22">def computeLeoDir ():

    loadDir = g.app.loadDir

    g.app.leoDir = theDir = g.os_path_dirname(loadDir)

    if theDir not in sys.path:
        sys.path.append(theDir)

    if 0: # This is required so we can do import leo (as a package)
        theParentDir = g.os_path_dirname(theDir)
        if theParentDir not in sys.path:
            sys.path.append(theParentDir)
</t>
<t tx="ekr.20070703172620.23">def computeLoadDir():

    """Returns the directory containing leo.py."""

    import leoGlobals as g
    import sys

    try:
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__ # was leo.__file__
        if sys.platform=='win32':
            if len(path) &gt; 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_abspath(path,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None

        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        raise
        #import traceback ; traceback.print_exc()
        #return None
</t>
<t tx="ekr.20070703172620.24">def computeStandardDirectories():

    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''

    if 0:
        import sys
        for s in sys.path: g.trace(s)

    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.

    g.app.leoDir = g.computeLeoDir()

    g.app.homeDir = g.computeHomeDir()

    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))

    g.app.globalConfigDir = g.computeGlobalConfigDir()

    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))

    g.app.user_xresources_path = g.os_path_join(g.app.homeDir,'.leo_xresources')
</t>
<t tx="ekr.20070703172620.25">def startupEncoding ():

    import leoGlobals as g
    import sys

    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding

    return encoding
</t>
<t tx="ekr.20070703172620.26">def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()</t>
<t tx="ekr.20070703172620.27">class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
</t>
<t tx="ekr.20070703172620.28">def __init__(self,c,all):

    self.c = c
    self.all = all

    self.fileName = 'dynamicUnitTest.leo'
    self.root = None # The root of the tree to copy when self.all is False.
    self.tags = ('@test','@suite','@unittests','@unit-tests')
</t>
<t tx="ekr.20070703172620.29">def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test', self.fileName))

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
</t>
<t tx="ekr.20070703172620.30">def createOutline (self,c2):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c = self.c
    c2root = c2.rootPosition()
    c2root.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    c2.beginUpdate()
    if self.all:
        p = c.rootPosition() ; limit_p = None
    else:
        p = self.root ; p = c.currentPosition()
        limit_p = p.nodeAfterTree()
    try:
        c2root.expand()
        while p and p != limit_p:
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    # print h
                    p2 = p.copyTreeAfter()
                    p2.unlink()
                    p2.moveToLastChildOf(c2root)
                    p.moveToNodeAfterTree()
                    break
            else:
                p.moveToThreadNext()
    finally:
        c2.endUpdate(False)
</t>
<t tx="ekr.20070703172620.31">def runTests (self):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo in a separate process.
    '''

    trace = False
    if trace: import time
    g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
    print 'creating: %s' % (self.fileName)
    c = self.c ; p = c.currentPosition()
    if trace: t1 = time.time()
    found = self.searchOutline(p.copy())
    if trace:
         t2 = time.time() ; print 'find:  %0.2f' % (t2-t1)
    if found:
        gui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=gui)
        if trace:
            t3 = time.time() ; print 'gui:   %0.2f' % (t3-t2)
        found = self.createOutline(c2)
        if trace:
            t4 = time.time() ; print 'copy:  %0.2f' % (t4-t3)
        self.createFileFromOutline(c2)
        if trace:
            t5 = time.time() ; print 'write: %0.2f' % (t5-t4)
        self.runLeoDynamicTest()
        if trace:
            t6 = time.time() ; print 'run:   %0.2f' % (t6-t5)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in selected outline')
</t>
<t tx="ekr.20070703172620.32">def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    args = [sys.executable, path, '--silent']

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
</t>
<t tx="ekr.20070703172620.33">def searchOutline (self,p):

    c = self.c ; p = c.currentPosition()
    iter = g.choose(self.all,c.allNodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.headString()
        for s in self.tags:
            if h.startswith(s):
                self.root = p.copy()
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.currentPosition().parents_iter():
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    self.root = p.copy()
                    return True

    return False
</t>
<t tx="ekr.20070703172620.34">@nocolor
https://sourceforge.net/forum/message.php?msg_id=4385604
By: rich_ries

From: Rich

Coupla problems:

(1) I pressed Alt+9 (just fooling around -- err, experimenting!) and got the
following error window:

====================================================================
Error: 1
AttributeError Exception in Tk callback
  Function: &lt;function masterBindKeyCallback at 0x01461F30&gt; (type: &lt;type
'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x00F85260&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\Language\Python\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py", line
1747, in __call__
    return apply(self.func, args)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoKeys.py", line
2150, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoKeys.py", line
3086, in masterKeyHandler
    return k.masterCommand(event,b.func,b.stroke,b.commandName)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoKeys.py", line
2272, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 283, in doCommand
    c.redraw_now()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 5720, in redraw_now
    c.frame.tree.redraw_now()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 822, in redraw_now
    self.redrawHelper(scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 838, in redrawHelper
    self.drawTopTree()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1185, in drawTopTree
    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1213, in drawTree
    h,indent = self.drawNode(const_p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 976, in drawNode
    return self.force_draw_node(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1004, in force_draw_node
    h2 = self.drawText(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1031, in drawText
    self.configureTextState(p)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1890, in configureTextState
    self.setUnselectedLabelState(p) # unselected
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 2349, in setUnselectedLabelState
    self.setUnselectedHeadlineColors(p)
  File "C:\Software Engineering\Literate Programming\Leo\plugins\cleo.py", line
818, in setUnselectedHeadlineColors
    fg, bg = self.custom_colours(p.v,node_is_selected=False)
  File "C:\Software Engineering\Literate Programming\Leo\plugins\cleo.py", line
520, in custom_colours
    MeSelf = self.c.currentPosition().headString()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoNodes.py", line
1330, in headString
    return self.v.headString()
AttributeError: 'NoneType' object has no attribute 'headString'

================================================
  Event contents:
    char: 9
    delta: 57
    height: ??
    keycode: 57
    keysym: 9
    keysym_num: 57
    num: ??
    serial: 1993
    state: 131072
    time: 91071250
    type: 2
    widget: .21028576.21057624.21057784.21057824.21057944.21058024.canvas
    width: ??
    x: 318
    x_root: 352
    y: 87
    y_root: 191
--------------------------------------------------------------------
and the following in the Log Pane:

exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 270, in doCommand
    val = command(event)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 4228, in expandAllHeadlines
    c.endUpdate()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 5597, in endUpdate
    c.frame.tree.endUpdate(flag,scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 777, in endUpdate
    self.redraw_now(scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 822, in redraw_now
    self.redrawHelper(scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 838, in redrawHelper
    self.drawTopTree()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1185, in drawTopTree
    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1213, in drawTree
    h,indent = self.drawNode(const_p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 976, in drawNode
    return self.force_draw_node(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1004, in force_draw_node
    h2 = self.drawText(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1031, in drawText
    self.configureTextState(p)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1890, in configureTextState
    self.setUnselectedLabelState(p) # unselected
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 2349, in setUnselectedLabelState
    self.setUnselectedHeadlineColors(p)
  File "C:\Software Engineering\Literate Programming\Leo\plugins\cleo.py", line
818, in setUnselectedHeadlineColors
    fg, bg = self.custom_colours(p.v,node_is_selected=False)
====================================================================

(2) Looking through the key bindings, I saw
"@shortcuts Gui operations focus-to-body = Alt-D"
but when I tried it, it actually moves to a headline that starts with "D"


--Rich
</t>
<t tx="ekr.20070703172620.35"># Misspelled words not selected properly on Linux.</t>
<t tx="ekr.20070703172620.36">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        # Save the selection range.
        ins = w.getInsertPoint()
        i,j = w.getSelectionRange()
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Restore the selection range.
        w.setSelectionRange(i,j,insert=ins)
        w.see(ins)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070703172620.37">def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None

    try:
        while 1:
            # g.trace('p',p and p.headString())
            p, word = self.findNextWord(p)
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if alts:
                w = c.frame.body.bodyCtrl
                i,j = w.getSelectionRange()
                c.beginUpdate()
                try:
                    c.frame.tree.expandAllAncestors(p)
                    c.selectPosition(p)
                finally:
                    c.endUpdate()
                    w.setSelectionRange(i,j,insert=j)
                break
    except:
        g.es_exception()
    return alts, word
</t>
<t tx="ekr.20070703172620.38">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
</t>
<t tx="ekr.20070703172620.39">def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i &lt; len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.headString(),'i',i,'len(s)',len(s))
        if i &lt; len(s):
            # A non-empty word has been found.
            j = i
            while j &lt; len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            return p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.bodyString())
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
    return None,None</t>
<t tx="ekr.20070703172620.40">@nocolor
https://sourceforge.net/forum/message.php?msg_id=4385699
By: rich_ries

From: Rich

Trying the Group Operations gave the following error message:

Traceback (most recent call last):
  File "C:\Software Engineering\Literate Programming\Leo\src\leoGlobals.py",
line 2553, in doHook
    return f(tag,keywords)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoPlugins.py",
line 91, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoPlugins.py",
line 70, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoPlugins.py",
line 49, in callTagHandler
    result = handler(tag,keywords)
  File "C:\Software Engineering\Literate Programming\Leo\plugins\groupOperations.py",
line 235, in drawImages
    if lassoer.moveNode and lassoer.moveNode.isVisible():
TypeError: isVisible() takes exactly 2 arguments (1 given)

=====================================================================

--Rich

</t>
<t tx="ekr.20070703172620.41"># Moving into a chapters node from the main chapter does an automatic hoist.</t>
<t tx="ekr.20070703172620.42">def selectChapterForPosition (self,p):

    '''
    Select a chapter containing position p.
    Do nothing if p if p does not exist or is in the presently selected chapter.
    '''
    cc = self ; c = cc.c

    if not p or not c.positionExists(p):
        return

    theChapter = cc.getSelectedChapter()
    if not theChapter: return

    # g.trace('selected:',theChapter.name)
    # First, try the presently selected chapter.
    firstName = theChapter.name
    if firstName == 'main' or theChapter.positionIsInChapter(p):
        return # Bug fix: 7/2/07. All position are in the main chapter.

    for name in cc.chaptersDict.keys():
        if name not in (firstName,'main'):
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                cc.selectChapterByName(name)
                return
    else:
        cc.selectChapterByName('main')
</t>
<t tx="ekr.20070703172620.43">@nocolor

- Made inter-outline moves &amp; copies work again.
- Also, warn that inter-outline clones transfer have no effect.  An oversight in the original code?
- Note: none of these operations are presently undoable.

In short, this code is no worse than it has ever been, but I cannot recommend either this code or its functionality as a model of good practice.
</t>
<t tx="ekr.20070703172620.44">def getLeoOutlineFromClipboard (self,s,reassignIndices=True):

    '''Read a Leo outline from string s in clipboard format.'''

    try:
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=True)
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=False)
    except invalidPaste:
        v = None
        g.es("Invalid Paste As Clone",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    return v

getLeoOutline = getLeoOutlineFromClipboard # for compatibility</t>
<t tx="ekr.20070703172620.45">def finishPaste(self,reassignIndices=True):

    """Finish pasting an outline from the clipboard.

    Retain clone links if reassignIndices is False."""

    c = self.c
    current = c.currentPosition()
    if reassignIndices:
        &lt;&lt; reassign tnode indices &gt;&gt;
    c.selectPosition(current)
    return current
</t>
<t tx="ekr.20070703172620.46">@ putLeoOutline calls assignFileIndices (when copying nodes) so that vnode can be associated with tnodes.
However, we must _reassign_ the indices here so that no "False clones" are created.
@c

nodeIndices = g.app.nodeIndices

current.clearVisitedInTree()

for p in current.self_and_subtree_iter():
    t = p.v.t
    if not t.isVisited():
        t.setVisited()
        # New in Leo 4.4.2 b2: use gnx's.  maxTnodeIndex is no longer used.
        t.fileIndex = nodeIndices.getNewIndex()
        # g.trace(t.fileIndex)</t>
<t tx="ekr.20070703172620.47">def getLeoOutlineHelper (self,s,reassignIndices,checking):

    self.checking = checking
    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.descendentUnknownAttributesDictList = []
    v = None

    self.tnodesDict = {}
    if not reassignIndices:
        &lt;&lt; recreate tnodesDict &gt;&gt;
    try:
        self.getXmlVersionTag()
        self.getXmlStylesheetTag()
        self.getTag("&lt;leo_file&gt;")
        self.getClipboardHeader()
        self.getDummyElements()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("&lt;/leo_file&gt;")
        if not checking:
            v = self.finishPaste(reassignIndices)
    finally:
        self.fileBuffer = None ; self.fileIndex = 0
        self.usingClipboard = False
        self.tnodesDict = {}
    return v
</t>
<t tx="ekr.20070703172620.48">nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t

if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]
</t>
<t tx="ekr.20070703172620.49">def getClipboardHeader (self):

    if self.getOpenTag("&lt;leo_header"):
        return # &lt;leo_header&gt; or &lt;leo_header/&gt; has been seen.

    while 1:
        if self.matchTag("file_format="):
            self.getDquote() ; self.getLong() ; self.getDquote()
        elif self.matchTag("tnodes="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("max_tnode_index="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("&gt;&lt;/leo_header&gt;"): # new in 4.2: allow this form.
            break
        else:
            self.getTag("/&gt;")
            break</t>
<t tx="ekr.20070703172620.50"># Added calls to c,p = g.getTestVars()

(fixed) leoNodes.py:2801: No global (p) found
(fixed) leoNodes.py:2804: No global (c) found

(fixed) leoConfig.py:1739: No global (c) found

(fixed) leoKeys.py:4446: No global (c) found

(fixed) leoEditCommands.py:7823: No global (c) found
(fixed) leoEditCommands.py:8508: No global (e) found
</t>
<t tx="ekr.20070703172620.51"></t>
<t tx="ekr.20070703172620.52">selectEditorLockout = False

def selectEditor(self,w):

    '''Select editor w and node w.leo_p.'''

    #  Called by body.onClick and whenever w must be selected.

    if self.selectEditorLockout:
        return

    if w and self.bodyCtrl == w:
        # Bug fix: 7-3-2007.
        c = self.c
        if w.leo_p and w.leo_p != c.currentPosition():
            c.selectPosition(w.leo_p)
            c.bodyWantsFocusNow()
        return

    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(w)
    finally:
        self.selectEditorLockout = False

    return val # Don't put a return in a finally clause.
</t>
<t tx="ekr.20070703172620.53">def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    if 0:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    self.inactivateActiveEditor(w)

    # The actual switch.
    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return 'break'

    if 0:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    c.frame.tree.expandAllAncestors(w.leo_p)
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls assignPositionToEditor.
    c.recolor_now()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'</t>
<t tx="ekr.20070703172620.54"># g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)

if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20070703172620.55"></t>
<t tx="ekr.20070703172620.56"></t>
<t tx="ekr.20070703172620.57">def es_print(s,*args,**keys):

    print g.toEncodedString(s,'ascii')

    if g.app.gui and not g.app.gui.isNullGui and not g.unitTesting:
        g.es(s,*args,**keys)
</t>
<t tx="ekr.20070703172620.58">if g.unitTesting:
    if 0: # Not usually enabled.
        g.es_print('\ntest of es_print: Ă',color='red')
</t>
<t tx="ekr.20070703172620.59">def es(s,*args,**keys):
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    log = app.log
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get('color')
    tabName = keys.get('tabName','Log')
        # Default goes to log pane *Not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            s = g.toEncodedString(s,'ascii')
            if newline: print s
            else: print s,
    else:
        if log and log.isNull:
            pass
        elif log:
            # print 'g.es',s
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
</t>
<t tx="ekr.20070703172620.60"></t>
<t tx="ekr.20070703172620.61">@nocolor

For full details, see: http://sourceforge.net/forum/forum.php?thread_id=1765685&amp;forum_id=10226

What I did:

- Added support for @unit-tests: the entire tree is copied to the dynamic.leo file
- Put most unit tests in @thin unitTests.txt (with @all).
- Added support for -silent command-line option.  It suppresses most startup messages.
- Modified run-unit-test command so it runs dynamically.
    - The new commands are run-unit-tests, run-all-unit-tests,
      run-unit-tests-locally and run-all-unit-tests-locally.
- Created unit test buttons with Alt-4 and Alt-5 bindings.
- Tell how long it took to create .leo file.
- @testcase not needed: @suite is good enough

@color</t>
<t tx="ekr.20070703172620.62">def doTests(c,all,verbosity=1):

    p = c.currentPosition() ; p1 = p.copy()
    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()
        if all: theIter = c.all_positions_iter()
        else:   theIter = p.self_and_subtree_iter()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
        for p in theIter:
            if isTestNode(p): # @test
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
            elif isSuiteNode(p): # @suite
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)
            # elif isTestCaseNode(p): # @testcase or @test-case
                # test = makeTestClass(c,p)
                # if test: suite.addTest(test)

        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
    finally:
        c.setChanged(changed) # Restore changed state.
        c.selectPosition(p1)
        g.unitTesting = g.app.unitTesting = False
</t>
<t tx="ekr.20070703172620.63">class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
</t>
<t tx="ekr.20070703172620.64">def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
</t>
<t tx="ekr.20070703172620.65">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
</t>
<t tx="ekr.20070703172620.66">def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
</t>
<t tx="ekr.20070703172620.67">def tearDown (self):

    pass

    # To do: restore the outline.
</t>
<t tx="ekr.20070703172620.68">def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p}
    else:
        d = {}

    # Execute the script. Let unit test handle any errors!
    if 0: # debug
        import pdb
        pdb.run(script+'\n',d)
    else:
        exec script + '\n' in d
</t>
<t tx="ekr.20070703172620.69">def shortDescription (self):

    return self.p.headString() + '\n'
</t>
<t tx="ekr.20070703172620.70">@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        print "no script in %s" % h
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print "%s script did not set g.app.scriptDict" % h
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None
</t>
<t tx="ekr.20070703172620.71">def makeTestCase (c,p):

    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None
</t>
<t tx="ekr.20070703172620.72">@
It is essential to rotect them with::

     if g.unitTesting:

A new unit test ensures that this is so.</t>
<t tx="ekr.20070703172620.73">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4382336
By: rich_ries

&gt;&gt; Offhand, I don't have a great solution to this.
&gt;&gt; Anyone have an idea?

The rst3 plugin sends its error message solely to the console; can not
the spell-check do the same?
</t>
<t tx="ekr.20071028032929"></t>
<t tx="ekr.20071028032929.1"></t>
<t tx="ekr.20071028032929.2"></t>
<t tx="ekr.20071028032929.3"></t>
<t tx="ekr.20071028032929.4">leo.py reads and writes exactly like LeoCB</t>
<t tx="ekr.20071028032929.5">Amazing.  I wrote some dummy code last night, read up on indices this morning, and got everything to work in a couple of hours. The result is very fast: no optimization is needed for Leo. I love Tkinter!

Added c.recolor and tree.recolor routines.  This hooks should be called whenever the body text changes.  Apparently there is no "OnTextChanged" event in Tk.</t>
<t tx="ekr.20071028032929.6"></t>
<t tx="ekr.20071028032929.7"></t>
<t tx="ekr.20071028032929.8">This marked my complete frustration with wxLeo and wxPython, and the real beginning of the work on leo.py.</t>
<t tx="ekr.20071028032929.9"></t>
<t tx="ekr.20071028032929.10">I am totally in love with Python.  Everything is so much easier:  Automatic debugging, no declarations, no types, no compilation. Great data structures. Even without single stepping the debugging is easy.

All major aspects of c2py are now complete.</t>
<t tx="ekr.20071028032929.11">I am not sure exactly when this happened.  The details apparently have been lost.  There was a time when I was experimenting with Python and wxPython, and a time when I was working on wxWindows version of Leo.</t>
<t tx="ekr.20071028032929.12"></t>
<t tx="ekr.20071028032929.13"></t>
<t tx="ekr.20071028032929.14"></t>
<t tx="ekr.20071028032929.15"></t>
<t tx="ekr.20071028032929.16"></t>
<t tx="ekr.20071028032929.17"></t>
<t tx="ekr.20071028032929.18"></t>
<t tx="ekr.20071028032929.19">atFile.scanAllDirectives was overriding the delim computed by scanHeader.

The fix was to add a reading param to scanAllDirectives that suppresses the scan for delims.</t>
<t tx="ekr.20071028032929.20"></t>
<t tx="ekr.20071028032929.21"></t>
<t tx="ekr.20071028032929.22">- Moved call to assignFileIndices into write_Leo_file.
- Called assignFileIndices in writeAtFileNodes, writeDirtyAtFileNodes, writeMissingAtFileNodes</t>
<t tx="ekr.20071028032929.23">Otherwise the tree-drawing code will change the position!</t>
<t tx="ekr.20071028032929.24"></t>
<t tx="ekr.20071028032929.25">What I did:

1. Converted the following ivars by hand:

app -&gt; g.app
globalDirectiveList -&gt; g.globalDirectiveList

2.  Replaced Tkinter by tk:

try: import Tkinter as Tk
except ImportError: Tk = None

3. Replaced "from leoPlugins import *" by import leoPlugins.
	- Replaced registerHandler by leoPlugins.registerHandler.</t>
<t tx="ekr.20071028032929.26">@nocolor 

Create the list of functions in leoGlobals.py.
	OR:  create the list by importing leoGlobals.py and looking at g.__dict__
Put this list in the script.</t>
<t tx="ekr.20071028032929.27"></t>
<t tx="ekr.20071028032929.28"></t>
<t tx="ekr.20071028032929.29"></t>
<t tx="ekr.20071028032929.30"></t>
<t tx="ekr.20071028032929.31"></t>
<t tx="ekr.20071028032929.32">See notes in project.  This was very clever code.</t>
<t tx="ekr.20071028032929.33">- created convertStackToPosition.
- created getExistingVnode.
- Major hack to getVnode.
</t>
<t tx="ekr.20071028032929.34">Moved a call to c.frame.tree.drawIcon(v) so that the icon will, in fact, be redrawn.

This was apparently an old bug.</t>
<t tx="ekr.20071028032929.35">This requires Python 2.2, as does iterators.</t>
<t tx="ekr.20071028032929.36">The setDirty logic is now about as clean as it can be.</t>
<t tx="ekr.20071028032929.37">- Changed readAll so it uses c.nullPosition by default.
- Test p is None in scanDirectives.

These two changes _might_ be enough to ensure the arg to p.__cmp__ is always a position in Leo's _core_.  However, user code is a different matter!

The coding style is to use: "if p is None:" rather than "if p == None:".  However, there is no way to enforce that style, so I have left the test against None in p.__cmp__.

Use the p.equal method when speed is crucial.</t>
<t tx="ekr.20071028032929.38"></t>
<t tx="ekr.20071028032929.39">This is a time-critical routine.</t>
<t tx="ekr.20071028032929.40"></t>
<t tx="ekr.20071028032929.41">1. Reduced copies of positions in drawTree.

Allocated copies in drawTree rather than in drawBox, drawIcon and drawText.  This reduces the number of copies by one third.

2. Eliminated extraneous positions in fileCommands read logic.

This was due to calling v.setMarked rather than v.initMarked, which calls c.doHook.  I don't know why this allocates so many positions, and it does.

3. Sped up fileCommands write logic by 30% (or more?)

This was a weird one.  p.__cmp__ is up to 10 times slower than p.equal.  I don't think there is any recursive code in p.__cmp__, and I suppose there might be...</t>
<t tx="ekr.20071028032929.42"></t>
<t tx="ekr.20071028032929.43"></t>
<t tx="ekr.20071028032929.44"></t>
<t tx="ekr.20071028032929.45"></t>
<t tx="ekr.20071028032929.46">These assert that the old or simple ways of computing positions and levels are equivalent to the optimized ways.

These assertions significantly slow down moves.  This shows that the optimized code truly is essential.</t>
<t tx="ekr.20071028032929.47"></t>
<t tx="ekr.20071028032929.48"></t>
<t tx="ekr.20071028032929.49">The code set a _next field to a position instead of a vnode.</t>
<t tx="ekr.20071028032929.50">Changes since the last cvs update:
	
- Disables changes if not a complete word.
- Disables changes if preceded by prefix:
	- Running this script twice is now safe.
- Disables changes if preceded by "def " or "."
- Added replace parameter for safety.
</t>
<t tx="ekr.20071028032929.51"></t>
<t tx="ekr.20071028032929.52"></t>
<t tx="ekr.20071028032929.53">Removed all code governed by "if not g.sharedNodes".
</t>
<t tx="ekr.20071028032929.54"></t>
<t tx="ekr.20071028032929.55">I started the transition to "pure" position code.

That is, I started eliminating code in "not g.sharedNodes" parts.  I did this because doing things "both ways" doesn't make any sense: much easier to change code.</t>
<t tx="ekr.20071028032929.56">self_and_siblings_iter()
self_and_parents_iter()
</t>
<t tx="ekr.20071028032929.57">This allows the user to choose a "safe mode".  It is off by default.</t>
<t tx="ekr.20071028032929.58"></t>
<t tx="ekr.20071028032929.59">We _can_ make the Leo compatible with old scripts !!!

1. Iterators replace most calls to next(), threadNext() etc., so any _other_ calls to there routines do _not_ have to be efficient:

2. In other words, iterators are the place to "optimize" tree traversals.

3. I added proxies to the position class so that p.x() is valid almost anywhere that v.x() is valid.

The only exceptions is that the v.linkX and v.unlink routines should only be called explicitly from the position class.

4.  I shall define porv.setCurrentVnode() and porv.currentVnode () in terms of porv.setCurrentPosition and porv.currentPosition.

This will deal with positions or vnodes as appropriate.

5. Added t ivar to position class:  self.t = self.v.t

Therefore, almost all code should continue to work!
</t>
<t tx="ekr.20071028032929.60"></t>
<t tx="ekr.20071028032929.61"></t>
<t tx="ekr.20071028032929.62"></t>
<t tx="ekr.20071028032929.63"></t>
<t tx="ekr.20071028032929.64"></t>
<t tx="ekr.20071028032929.65"></t>
<t tx="ekr.20071028032929.66"></t>
<t tx="ekr.20071028032929.67">Changed leoConfig.leo, and the popup menu.

By: sbeards ( Scott Beardsley ) 
 BUG: Toggle brackets via Ctrl+B   
2004-02-11 17:21  

The ToggleAngleBrackets keyboard command (Ctrl+B) doesn't seem to be working at all. </t>
<t tx="ekr.20071028032929.68">Changed Undo/Redo messages:

- Insert Outline to Insert Node.
- Delete Outline to Delete Node.
- Clone to Clone Node.

This is a real code change: it affects the undo/redo logic.

BTW, some way should be found to translate these (and all other text as well!!).</t>
<t tx="ekr.20071028032929.69"></t>
<t tx="ekr.20071028032929.70"></t>
<t tx="ekr.20071028032929.71">
</t>
<t tx="ekr.20071028032929.72"></t>
<t tx="ekr.20071028032929.73"></t>
<t tx="ekr.20071028032929.74">- Fixed Dan Winkler's bug with CashRegister.ss.

- Possibly fixed the "Zope Sprint" bug.

- Ensure trailing newline in scripts.

- Fixed indent problem in leoTkinterGui.py.

- Fixed several problems in the Convert All Blanks/Tabs commands.

- Give shorter message when saving a read-only file fails.
  This is a bit of a kludge.  Only time will tell if it works acceptably.

- Leo no longer writes "empty" attributes like a="".  This arose because Leo no longer writes cloned attributes.

- Added some code to save and restore the "top" vnode, but this really is useless at present: the "top" vnode is a function of the scroll state, and that is a Tk-dependent value.  The only proper way of computing the top node would be to look at the scroll state, and this I don't care to do now.

</t>
<t tx="ekr.20071028032929.75"></t>
<t tx="ekr.20071028032929.76">This is correct and more accurate.

- Created v.setAllAncestorAtFileNodesDirty.

- Call v.setAllAncestorAtFileNodesDirty instead of v.setDirty.

- "Duplicate" calls to v.setAllAncestorAtFileNodesDirty are needed just as with v.setDirty.

- This change affects drags, moves, clones, insert, delete, sorting.</t>
<t tx="ekr.20071028032929.77"></t>
<t tx="ekr.20071028032929.78"></t>
<t tx="ekr.20071028032929.79">c.doCommand calls tree.redrawAfterException on exceptions.  This works because doCommand is itself _not_ contained in any begin/endUpdate pair, so setting self.updateCount = 0 in tree.redrawAfterException will work.</t>
<t tx="ekr.20071028032929.80">Changed:

if sys.platform not in ("linux1","linux2"):

to:

if sys.platform not in ("darwin",freebsd4","freebsd5","linux1","linux2"):

in:

&lt; &lt; set bind_shortcut and menu_shortcut using accel &gt; &gt;</t>
<t tx="ekr.20071028032929.81"></t>
<t tx="ekr.20071028032929.82">The fix was to insert code to test for a special case.

I wonder what this code would look like in the shared-tnode world?
</t>
<t tx="ekr.20071028032929.83"></t>
<t tx="ekr.20071028032929.84"></t>
<t tx="ekr.20071028032929.85">This is so handy.</t>
<t tx="ekr.20071028032929.86"></t>
<t tx="ekr.20071028032929.87"></t>
<t tx="ekr.20071028032929.88">The assertion

assert(i == new_len)

in &lt; &lt; initialize new states &gt; &gt; has caused no end of troubles.  The new code eliminates the assertion by brute force.  It has never been clear why the assert has failed, and it does so rarely.  However, the very worst that can happen is that some lines aren't colored properly, so it's not a big deal.</t>
<t tx="ekr.20071028032929.89"></t>
<t tx="ekr.20071028032929.90">Created tree.enableDrawingAfterException and called it in es_exception.</t>
<t tx="ekr.20071028032929.91"></t>
<t tx="ekr.20071028032929.92"></t>
<t tx="ekr.20071028032929.93"></t>
<t tx="ekr.20071028032929.94"></t>
<t tx="ekr.20071028032929.95"></t>
<t tx="ekr.20071028032929.96"></t>
<t tx="ekr.20071028032929.97"></t>
<t tx="ekr.20071028032929.98"></t>
<t tx="ekr.20071028032929.99"></t>
<t tx="ekr.20071028032929.100">The nullGui class is not ready for prime time yet.</t>
<t tx="ekr.20071028032929.101">Useful for unit testing.</t>
<t tx="ekr.20071028032929.102"></t>
<t tx="ekr.20071028032929.103"></t>
<t tx="ekr.20071028032929.104">Added at = self</t>
<t tx="ekr.20071028032929.105"></t>
<t tx="ekr.20071028032929.106"></t>
<t tx="ekr.20071028032929.107">This affects only the Reformat Paragraph command.</t>
<t tx="ekr.20071028032929.108"></t>
<t tx="ekr.20071028032929.109"></t>
<t tx="ekr.20071028032929.110"></t>
<t tx="ekr.20071028032929.111"></t>
<t tx="ekr.20071028032929.112">@nocolor

Leo now uses yymmddhhmmss as the format of timestamps.  This is good for sorting chronologically.</t>
<t tx="ekr.20071028032929.113">Using * shows files like readme that don't have a file extension.</t>
<t tx="ekr.20071028032929.114"></t>
<t tx="ekr.20071028032929.115"></t>
<t tx="ekr.20071028032929.116">The fix is to add a scripting arg to atFile.scanAllDirectives.</t>
<t tx="ekr.20071028032929.117">Also removed a confusing traceback.</t>
<t tx="ekr.20071028032929.118"></t>
<t tx="ekr.20071028032929.119">Found a batch-mode bug: the meaning of moves depends on whether nodes are expanded.  This won't be good in batch mode.</t>
<t tx="ekr.20071028032929.120"></t>
<t tx="ekr.20071028032929.121">It turns out that executing a script was setting the tnodeList for the node if the node had section refs!  This was the source of the ongoing mystery about why some nodes had tnodeLists.  Resolving this mystery puts Leo's read/write code on a firmer foundation.

This was tricky to make sure that tnodeList's are created and written only when necessary:

- The fileCommands.putVnode writes tnodeList only for @file nodes.
  (and only non-empty tnodeList's)

- new_df.write clears at.root.tnodeList when writing a script.

- c.checkOutline (and the related script) does not consider that an empty tnodeList is an error.</t>
<t tx="ekr.20071028032929.122"></t>
<t tx="ekr.20071028032929.123"></t>
<t tx="ekr.20071028032929.124">Replaced string concatenation with list operations.</t>
<t tx="ekr.20071028032929.125"></t>
<t tx="ekr.20071028032929.126">Dialogs return a predefined value.</t>
<t tx="ekr.20071028032929.127"></t>
<t tx="ekr.20071028032929.128"></t>
<t tx="ekr.20071028032929.129"># Line 1108: _multiples = [(2., Numeric.log10(2.)), (5., Numeric.log10(5.))]

I suspect this was a file that contained both tabs and spaces.</t>
<t tx="ekr.20071028032929.130"></t>
<t tx="ekr.20071028032929.131">My conclusion at present is that the problem lies with 4.0.4, not 4.1.  I can see nothing seriously wrong with the present code:

- Missing tnodeList errors are possible when @file nodes are cloned when converting from 3.x to 4.x.  The tnodeList probably should have been made part of tnodes, not vnodes; it's too late to change now.

- Missing tnodeList errors are not serious: Leo will recover as usual.

- The copy/paste code had a few bugs that I corrected today.  I doubt whether these would have caused major problems.

In short, the present code appears to be reasonably solid.  I should withdraw the 4.0.4 code asap.</t>
<t tx="ekr.20071028032929.132"></t>
<t tx="ekr.20071028032929.133"></t>
<t tx="ekr.20071028032929.134">The old way always surprised me.

To make this work I disabled checks in the read logic if at.importing is true</t>
<t tx="ekr.20071028032929.135"></t>
<t tx="ekr.20071028032929.136"></t>
<t tx="ekr.20071028032929.137"></t>
<t tx="ekr.20071028032929.138">Only double-quoted strings are valid in html.  A lone single-quote caused a cascade of mismatched comments.</t>
<t tx="ekr.20071028032929.139">This has been around ever since the dragging code was created.</t>
<t tx="ekr.20071028032929.140">Plugins are now loaded in the order in which they appear in pluginsManager.txt.

Removed all "compile-time" enabling/disabling code from leoPlugins.leo.

The only such checks that remain are checks to see if Tkinter can be imported, and other similar checks.
</t>
<t tx="ekr.20071028032929.141"></t>
<t tx="ekr.20071028032929.142">The only change was that replaceClipboardWith now no longer returns a value.</t>
<t tx="ekr.20071028032929.143"></t>
<t tx="ekr.20071028032929.144"></t>
<t tx="ekr.20071028032929.145"></t>
<t tx="ekr.20071028032929.146"></t>
<t tx="ekr.20071028032929.147"></t>
<t tx="ekr.20071028032929.148">getBodyLines must set head = tail = None when lines is expanded to include everything.

This probably affects several other commands.</t>
<t tx="ekr.20071028032929.149"></t>
<t tx="ekr.20071028032929.150"></t>
<t tx="ekr.20071028032929.151">This fixes several related bugs:  updateRecentFiles was not being called except when openWithFileName was called.</t>
<t tx="ekr.20071028032929.152"></t>
<t tx="ekr.20071028032929.153"></t>
<t tx="ekr.20071028032929.154">app.batchLog was completely redundant.</t>
<t tx="ekr.20071028032929.155"></t>
<t tx="ekr.20071028032929.156"></t>
<t tx="ekr.20071028032929.157">The command seems to work well enough when we get this message.</t>
<t tx="ekr.20071028032929.158">Apparently I added shortcuts to the popup menu for the first time recently.

The "duplicate binding" logic would complain if popups actually tried to bind the shortcuts.

The fix: to add a dontBind param to createMenuEntries and set that param when creating the popup menu.</t>
<t tx="ekr.20071028032929.159">Replaced asserts with warnings.</t>
<t tx="ekr.20071028032929.160">Renaming bodyCtrl to body conflicted with a previous var named body.</t>
<t tx="ekr.20071028032929.161">putRefLine must return if putRefAt finds an error.</t>
<t tx="ekr.20071028032929.162">This "real" test exposed several problems:

- Only --script was recognized, not -script.
- Created global app.batchLog var.
- Changes to nullLog.__init__
	- inits app.batchLog if app.batchMode is true.
	- inits app.batchLog if app.batchMode is true (only if app.batchLog not inited).
- trace now _always_ uses print.  This prevents problems with traces in nullLog.
- es now uses app.batchLog.put if app.batchMode is true.
- nullGui.runMainLoop prints nothing unless app.batchLog is enabled.</t>
<t tx="ekr.20071028032929.163"></t>
<t tx="ekr.20071028032929.164"></t>
<t tx="ekr.20071028032929.165"></t>
<t tx="ekr.20071028032929.166"></t>
<t tx="ekr.20071028032929.167"></t>
<t tx="ekr.20071028032929.168"></t>
<t tx="ekr.20071028032929.169">This is a convenience routine for scripts.  It does not update the body pane.</t>
<t tx="ekr.20071028032929.170"></t>
<t tx="ekr.20071028032929.171">These exposed some further problems with the reorg.
</t>
<t tx="ekr.20071028032929.172"></t>
<t tx="ekr.20071028032929.173">Must call </t>
<t tx="ekr.20071028032929.174"></t>
<t tx="ekr.20071028032929.175">@nocolor

- (fixed) I noticed this in leoConfig.leo: config_encoding = iso-8859-1

- (fixed) ImportError: No module named leoDialog.

- (fixed) TypeError: about() takes exactly 2 arguments (1 given) (plugin_menu plugin)

- (fixed) mod_spelling plugin: several bugs.</t>
<t tx="ekr.20071028032929.176">It was very easy to do: just use the atFile.write to write into a file-like object.

The only other complication: we temporarily replace the root's body text with just the selected text.

Created app.scriptDict to communicate between the Execute Script command and the scripts being executed.

app.script["script1"] contains the original script.

app.script["script2"] contains the preprocessed script.  This will contain Leo sentinel lines.</t>
<t tx="ekr.20071028032929.177">Moved @others inside if "tk and 1:"</t>
<t tx="ekr.20071028032929.178"></t>
<t tx="ekr.20071028032929.179">This is a necessary precondition to supporting Unicode file and directory names properly.  It's not at all clear whether this is sufficient.  Anyway, these routines help clean up the code.

I took care that scripts import only those os_path_xxx routines that are necessary.  However, this process could have introduced bugs.</t>
<t tx="ekr.20071028032929.180">The find &amp; change scripts show the power of Leo's new script find/change commands.

Getting these scripts correct was a bit tricky.</t>
<t tx="ekr.20071028032929.181"></t>
<t tx="ekr.20071028032929.182"></t>
<t tx="ekr.20071028032929.183"></t>
<t tx="ekr.20071028032929.184"></t>
<t tx="ekr.20071028032929.185"></t>
<t tx="ekr.20071028032929.186"></t>
<t tx="ekr.20071028032929.187"></t>
<t tx="ekr.20071028032929.188"></t>
<t tx="ekr.20071028032929.189"></t>
<t tx="ekr.20071028032929.190">Due to moving and renaming some commands routines.</t>
<t tx="ekr.20071028032929.191">A simple bug due to the reorg.</t>
<t tx="ekr.20071028032929.192"></t>
<t tx="ekr.20071028032929.193">The new setEditVnode setter didn't set the global.</t>
<t tx="ekr.20071028032929.194">This is much more natural than the old way.</t>
<t tx="ekr.20071028032929.195">This removes a bit of a kludge.</t>
<t tx="ekr.20071028032929.196"></t>
<t tx="ekr.20071028032929.197">The biggest Aha was getting rid of redirection routines.

I could get rid of the tree redicrection routines if I used a proper tree class.  It's probably not worth it...</t>
<t tx="ekr.20071028032929.198">Moved get/setRealMenuName &amp; setRealMenuNamesFromTable.

It is really satisfying to get rid of these globals.  It makes the leoGlobals file much stronger.</t>
<t tx="ekr.20071028032929.199">These were hardly used anyway, and getting rid of them greatly clarifies the code.

These may create small problems in plugins...</t>
<t tx="ekr.20071028032929.200">- Key insight 1:  menus must belong to frames, _not_ to a gui.

- Key insight 2:  frame.menu.getFrame is gui-independed, so no need to "redirect"

- Key insight 3:  We prefer "binding" routines to "redirection" routines.

	Redirection routines just cause confusion and unnecessary work.

- Moved all global menu routines into gui-specific classes.

	This is an application of insight 3.  We want to bind things, not redirect calls.

- Moved all gui menu routines into gui-specfic classes.

	Same principle at work.  Much less work.

- Key insight 4:  Leo's core always calls frame.menu.x, _not_ app.gui.menu.x.

	For one thing, menu code must be frame-dependent, so a general app.gui.menu method WILL NOT WORK.

- Eliminated all frame "redirection" routines relating to menus.

I am very pleased with the result.  The new code is simpler and much less confusion.</t>
<t tx="ekr.20071028032929.201">There was a name colision between the code that used to be in the Frame class.</t>
<t tx="ekr.20071028032929.202"></t>
<t tx="ekr.20071028032929.203">Another problems due to the reorg.

Whole word searches did not succeed if the pattern was at the start or end of body text.

The getCharBeforeIndex and getCharAfterIndex routines must check for start and end of text.

While I was at it, I changed is_c_id so that it returns false if the argument is None.</t>
<t tx="ekr.20071028032929.204">Apparently this must be done after creating the dialog.</t>
<t tx="ekr.20071028032929.205">This was the result of the reorg.</t>
<t tx="ekr.20071028032929.206"></t>
<t tx="ekr.20071028032929.207"></t>
<t tx="ekr.20071028032929.208">- Eliminated app.gui.utils class (all code in app.gui class).

- Eliminated Focus routines in leoGlobals.py (now in app.gui class).</t>
<t tx="ekr.20071028032929.209"></t>
<t tx="ekr.20071028032929.210">At long last I realized that the gui-specific app.gui class should have an associated utils class to handle gui-specific routines that used to be in leoGlobals.py.

The pattern is:

	gu = app.gui.utils
	...
	gu.xxx(args)

It would be possible to define all the body wrapper methods in terms of the app.gui.utils class.  However, these routines naturally belong in the gui-specific class, so not as much is gained by doing this as might be imagined at first.

Anyway, the road is now clear to rewrite the wx gui plugin.  It will probably take only a few hours to do this!</t>
<t tx="ekr.20071028032929.211">This went remarkably smoothly.

The separation of gui-dependent from gui-independent code was usually trivial.

The Find classes were a bit harder: I created about a dozen tkinter wrapper routines so that all the utils could be moved into the base class.  This means that all the find logic is in the base class, and implementing a wx Find panel will be very easy.

The app.gui routines no longer require a "run" routine.  Instead, calling app.gui.createXPanel creates the panel and runs it.  All panels now support a "bringToFront" routine that is called to make the panel visible when the panel already exists.</t>
<t tx="ekr.20071028032929.212">- Moved recentFiles ivar from frame class to commands class.

- updateRecentFiles must call app.config.setRecentFiles with self.recentFiles as the arg, not c.recentFiles.</t>
<t tx="ekr.20071028032929.213"></t>
<t tx="ekr.20071028032929.214">What I did:

- Created wrappers for tk calls in core.
	- Removed all tk calls in undoRedoText
- Created wrappers for all tk calls in leoTkinterFrame
	(exception) OnInsertHeadlineTime uses v.edit_text
- Moved gui-independent commands code from leoTkinterFrame to leoFrame.
	No changes were needed!
- Changed x.commands to x.c for all classes x.
- Eliminated intermediate event handlers in frame class.
- Removed event param from all commands handlers.
	- Exception: the cut/copy/paste handlers must have an event param.
-Moved all non-gui commands into commands class.
	- Removed all frame routines that called commands.
	**There is now a clear separation between gui-dependent routines in leoFrame subclasses
	  and gui-independent routines in Commands class.
- Created stub routines for gui-dependent routines in leoFrame class</t>
<t tx="ekr.20071028032929.215">Rather than calling oops, it is so much more intelligent to call the corresponding bodyCtrl routine!</t>
<t tx="ekr.20071028032929.216"></t>
<t tx="ekr.20071028032929.217">This was very easy.  Almost all the menu code is now gui-independent.  This will make implementing the wx gui plugin _much_ easier.</t>
<t tx="ekr.20071028032929.218">Leo was mistaking the escaped percentile sign "\%" (backslash followed by
percentile) for the LaTeX comment delimiter (plain percentile sign).

The fix was:

1. Add "\\%" to the list of LaTeX keywords.
2. Create latex_special_keyword_characters = "@(){}%"
3. Use latex_special_keyword_characters when scanning for possible LaTeX keywords.
</t>
<t tx="ekr.20071028032929.219">The problem is that a successful search _must_ reset the selection range, so there isn't much point to this command.  Moreover, the Find All and Change All commands would loop if they aren't equivalent to the Find and Change commands when this option is in effect.  All in all, an almost useless option.  Too bad.</t>
<t tx="ekr.20071028032929.220"></t>
<t tx="ekr.20071028032929.221"></t>
<t tx="ekr.20071028032929.222">LeoPy.leo, The "Code" part only:

nodes,lines,pages, 2398, 79524, 2070

leoPlugins.leo:  Plugins &amp; scripts

nodes,lines,pages, 403, 10880, 298

LeoDocs.leo:  Users Guide

nodes,lines,pages, 379, 44606, 967</t>
<t tx="ekr.20071028032929.223"></t>
<t tx="ekr.20071028032929.224">"mbcs" probably will work only on Windows!</t>
<t tx="ekr.20071028032929.225">A recent change was done incorrectly.  There is no "find()" method: I changed it to findNext().</t>
<t tx="ekr.20071028032929.226"></t>
<t tx="ekr.20071028032929.227"></t>
<t tx="ekr.20071028032929.228"></t>
<t tx="ekr.20071028032929.229">A useful little utility to set up script-find/change.</t>
<t tx="ekr.20071028032929.230">This involved fixing a bug in idle_body_key so that the oldText param is honored if present.</t>
<t tx="ekr.20071028032929.231">The Script Change checkbox will have a few uses:

- It is replacement for a script that replaces the selection with text.  Yes, this script would be easy to write, but why not write it for the user?

Leo will execute a "default change script" when the Script Change checkbox is checked.  Simple and effective.</t>
<t tx="ekr.20071028032929.232"></t>
<t tx="ekr.20071028032929.233">Yes, we really do need script-based find/change.  The reason is that the find panel (and the associated find commands) is really the only good place to allow the user to do an interactive search.  Without this feature, all interactive find/change scripts would have to duplicate all the work of the find/change commands.

Still to do: help scripts do undo.

Conventions enforced by Leo:

- The app.searchDict ivar can be used for communication between find &amp; change scripts.
- app.searchDict["type"] contains either "find", "change", "findAll" or "changeAll".
- The Find All command executes the find script only once unless the script sets
  app.searchDict["Continue"] = true  (similarly for the change all command.
- The Find Then Change command executes the find command followed by the change command.
- The Change Script command supports undo if app.searchDict has the following entry after the script executes:
	{ "v" : v, "oldText" : oldText, "newText" : s }
	A "keys" key is an optional keyword dict to be passed to setUndoParams.

Leo actually doesn't do much:

- Leo doesn't clear app.searchDict.
	- However, a _script_ can
		a) init itself and
		b) bring up the find window (Eureka!)
- The find script is repsonsible for traversing the tree.
- The find script is responsible for highlighting the found text
  or otherwise indicating to the change script what the found text was.
  For example, the re find script can set app.searchDict["m"] to the match object.
- The find script must communicate with the change script.  Leo does nothing.
- The change script must change the text, usually by using v.setBodyStringOrPane.</t>
<t tx="ekr.20071028032929.234">@color

# Example showing how a script can init the Find panel

script = """from leoGlobals import *
c = top() ; v = c.currentVnode()
print `v`
v = v.threadNext()
c.selectVnode(v)"""

from leoGlobals import *
app.searchDict = {} # Communication between search &amp; change scripts
c = top()
c.script_search_flag = true
c.find_text = script
app.findFrame.init(c)
c.frame.OnFindPanel()
</t>
<t tx="ekr.20071028032929.235">Undoing Change All cleared the body pane.

The fix was simple: call setUndoParams instead of setUndoTypingParams in batchChange.</t>
<t tx="ekr.20071028032929.236"></t>
<t tx="ekr.20071028032929.237"></t>
<t tx="ekr.20071028032929.238">The node-only option wasn't working due to a bug in createFrame.

There still may be a problem with the interaction between Node-only,Change All and Undo.</t>
<t tx="ekr.20071028032929.239"></t>
<t tx="ekr.20071028032929.240">The fix was to open files with 'rb' instead of 'r'.  This probably should be done in more places.</t>
<t tx="ekr.20071028032929.241">This command checks for unused tnodeLists and checks the topology of all clones.</t>
<t tx="ekr.20071028032929.242">Hoisting itself is easy.  The biggest challenge was preventing moves outside the hoisted area, which would too confusing.</t>
<t tx="ekr.20071028032929.243"></t>
<t tx="ekr.20071028032929.244">- Added df.fileChanged flag.  This is set by replaceTargetFileIfDifferent.

- Separated the "written" logic from the "changed" logic.  We do an auto-save only if something has actually been changed.  The "written" logic is used to warn if a tree contains no @file nodes.</t>
<t tx="ekr.20071028032929.245"></t>
<t tx="ekr.20071028032929.246"></t>
<t tx="ekr.20071028032929.247">This is required for compatibility with Leo 3.x versions.</t>
<t tx="ekr.20071028032929.248">app.use_gnx controls whether we generate full gnx's or not.  At present there is no setting for this, so 4.1 really defines a new file format.

There was some weirdness: assignFileIndices didn't actually assign all file indices!  As a hack, putTnodeList also assigns file indices.  The mystery is solved.  Leo only clears the tnodeList of roots when writing, so once a non-root node gets a tnode list it can stay a long time.  Probably should clear all non-root tnode lists, and this would slow things down.

Perhaps a script could do the job?</t>
<t tx="ekr.20071028032929.249"></t>
<t tx="ekr.20071028032929.250"></t>
<t tx="ekr.20071028032929.251">The state of frame.controlKeyIsDown is not always correct.  I added bindings to the hidden root window to try to catch this.  This may not be a good idea...</t>
<t tx="ekr.20071028032929.252">- Added config_encoding setting to specify the encoding of leoConfig.txt.
- Converted all options to Unicode when reading leoConfig.txt.
- Converted all options to config.config_encoding when writing leoConfig.txt.</t>
<t tx="ekr.20071028032929.253"></t>
<t tx="ekr.20071028032929.254">- Replaced all references in colorizer to bodyCtrl by body.x.
- Removed colorizer.bodyCtrl ivar.
- Created colorizer.body ivar.</t>
<t tx="ekr.20071028032929.255">This removes all possibility that call set_focus from Leo's core will cause problems.

Actually though, Leo's core calls no focus routines, so there should be no problems.</t>
<t tx="ekr.20071028032929.256"></t>
<t tx="ekr.20071028032929.257">Create new Idle-time and clipboard routines in leoGui and leoTkinterGui classes.  Also updated wx plugin.</t>
<t tx="ekr.20071028032929.258"></t>
<t tx="ekr.20071028032929.259"></t>
<t tx="ekr.20071028032929.260"></t>
<t tx="ekr.20071028032929.261"></t>
<t tx="ekr.20071028032929.262"></t>
<t tx="ekr.20071028032929.263"></t>
<t tx="ekr.20071028032929.264">What I did:

- assignFileIndices &amp; compactFileIndices now are identical.

- putVnode now assigns vnode indices to _all_ tnodes.
	(not all of them may be written, but that doesn't matter)

- putVnode no longer writes the "C" (cloned) attribute.

- finishPaste now _reallocates_ tnode indices in all pasted nodes.  This fixes a major copy/paste bug.  Failure to do this would have created "false clones": hidden clones that would show up when the file was read again.</t>
<t tx="ekr.20071028032929.265"></t>
<t tx="ekr.20071028032929.266">The root wasn't being set properly because of a missing break statement.</t>
<t tx="ekr.20071028032929.267"></t>
<t tx="ekr.20071028032929.268"># Changed col= to column= in several places.
# Changed @file to @file-nosent mod_autosave.ini.</t>
<t tx="ekr.20071028032929.269">The code now uses updateBodyPane as before.</t>
<t tx="ekr.20071028032929.270">We don't have to mess with the ending selection for reformatParagraph because the shift commands now properly restore the selection.</t>
<t tx="ekr.20071028032929.271"></t>
<t tx="ekr.20071028032929.272">This is a bit kludgy, due to Tk weirdnesses.  I don't think it can be helped...</t>
<t tx="ekr.20071028032929.273"></t>
<t tx="ekr.20071028032929.274">This now preserves trailing newlines correctly.  Far from intuitive.</t>
<t tx="ekr.20071028032929.275">Unlike using string.split and string.join, these preserve the state of the trailing newline.</t>
<t tx="ekr.20071028032929.276">Added -1c in setSelectionAreas and getSelectionLines.

Tk's selection mechanism isn't great here.  I want to select to the end of the line, and if I specifing x lineend the cursor actually gets placed at the start of the next line!</t>
<t tx="ekr.20071028032929.277"></t>
<t tx="ekr.20071028032929.278">The code was mistakenly calling frame.destroySelf() if the file could not be opened.  This is always wrong.

While I was at it, I added an except IOError: clause that simply reports that the file could not be opened.

I really should create a wrapper for file to handle the except IOError: case...</t>
<t tx="ekr.20071028032929.279"></t>
<t tx="ekr.20071028032929.280">"idle" hooks must test app.initing before calling app.forceShutdown().
</t>
<t tx="ekr.20071028032929.281"></t>
<t tx="ekr.20071028032929.282"></t>
<t tx="ekr.20071028032929.283">This will allow me to define frame.body as an instance of the leoTkinterBody class.</t>
<t tx="ekr.20071028032929.284"></t>
<t tx="ekr.20071028032929.285">This removes some of the frame details from the app class.

As a result, several app methods went away.</t>
<t tx="ekr.20071028032929.286">- Added new getters and setters to leoTkinterFrame.

- The following classes will soon become tkinter classes, so references to top are not important:

LeoColorPanel, LeoColorNamePanel, leoCompare, leoDialog, leoFind, leoFont, leoPrefs</t>
<t tx="ekr.20071028032929.287">- Removed v.iconx and vicony from Leo's core.
	- Added default args in tree.drawIcon() so Leo's core doesn't know about the ivars.

- tree.drawIcon is now the only routine that accesses these ivars!</t>
<t tx="ekr.20071028032929.288">
- tkinterTree now injects callbacks into vnode class.
- leoFrame.py now contains base classes named leoFrame, leoBody, leoLog and leoTree.
- Renamed present LeoFrame class to leoTkinterFrame and move it to leoTkinterFrame.py.
- Renamed present leoTree class to leoTkinterTree and move it to leoTkinterTree.py.</t>
<t tx="ekr.20071028032929.289"></t>
<t tx="ekr.20071028032929.290"></t>
<t tx="ekr.20071028032929.291"></t>
<t tx="ekr.20071028032929.292">- Simplified undoReplace code &amp; removed asserts.
- The text param is no longer used and could be removed.

Undo tests:

(passed) Read @file Nodes.
(passed) Import Derived Files

(passed) Extract Section
(passed) Extract Section Names.
(passed) Extract

(passed) Convert Tabs &amp; Convert All Tabs.
</t>
<t tx="ekr.20071028032929.293"></t>
<t tx="ekr.20071028032929.294"></t>
<t tx="ekr.20071028032929.295">This is too distracting while typing the directive.</t>
<t tx="ekr.20071028032929.296">@nocolor

The following appears in run() in leo.py:

@color

doHook("start1")
if app.killed: return # 10/15/03: allows the plugin to kill the app.</t>
<t tx="ekr.20071028032929.297">This command was not taking into account the optional -ver= part of the @+leo sentinel.</t>
<t tx="ekr.20071028032929.298">The command now looks at joined nodes if no ancestor @file node.</t>
<t tx="ekr.20071028032929.299"></t>
<t tx="ekr.20071028032929.300"></t>
<t tx="ekr.20071028032929.301"></t>
<t tx="ekr.20071028032929.302"></t>
<t tx="ekr.20071028032929.303">- Replaced all calls to v.copyTree related to undo by c.undoer.saveTree.

- Hacked u.undoReplace to handle tuple returned by u.saveTree.

- Fixed bugs in Convert All Blanks and Convert All Tabs routines.
	- These routines call convertBlanks and convertTabs as helpers.
	- Added arg to convertBlanks and convertTabs controlling whether these routines set undo state.
</t>
<t tx="ekr.20071028032929.304"></t>
<t tx="ekr.20071028032929.305"></t>
<t tx="ekr.20071028032929.306"></t>
<t tx="ekr.20071028032929.307">@language elisp
@color

(defun abc 'a "abc
xyz" cons)</t>
<t tx="ekr.20071028032929.308">Must call c.initAllCloneBits.</t>
<t tx="ekr.20071028032929.309"></t>
<t tx="ekr.20071028032929.310">This is a temporary expedient.  Probably using ch.isalpha() would be better</t>
<t tx="ekr.20071028032929.311">When doing a back scan we must test for the start of the text _after_ looking for brackets.</t>
<t tx="ekr.20071028032929.312"></t>
<t tx="ekr.20071028032929.313"></t>
<t tx="ekr.20071028032929.314">This was tricky to get right:

- There are several calls to after_idle(idle_body_key), so which gets scheduled is a matter of timing.  To handle that I added the tree.forceFullRedraw() routine.

- The undo/redo code also recolors the text.  Added a new param to undoRedoText so that it could force a full redraw after cut/paste.
</t>
<t tx="ekr.20071028032929.315">The new code is now guaranteed to go to the proper node of the outline.  However, @doc parts may disrupt line counts within a node.</t>
<t tx="ekr.20071028032929.316"></t>
<t tx="ekr.20071028032929.317"></t>
<t tx="ekr.20071028032929.318">Somehow a number of calls to c.initJoinedCloneBits got omitted.</t>
<t tx="ekr.20071028032929.319">vnode attributes would typically be used for things like marks or additional icons.

tnode attributes would typically be used for anything associated with shared headline or body text.</t>
<t tx="ekr.20071028032929.320">tkinterGui.destroy must call frame.top.destroy.</t>
<t tx="ekr.20071028032929.321"></t>
<t tx="ekr.20071028032929.322"></t>
<t tx="ekr.20071028032929.323">The code was attempting to reference an ivar.  I placed sentinelNameDict inside sentinelName() and referenced it directly.</t>
<t tx="ekr.20071028032929.324">This is required so that attributes get set in the leoApp object rather than the proxy object.</t>
<t tx="ekr.20071028032929.325"></t>
<t tx="ekr.20071028032929.326"></t>
<t tx="ekr.20071028032929.327"></t>
<t tx="ekr.20071028032929.328">This is a big step forward.  newLeoCommanderAndFrame provides a place to explore the complexities of initializing LeoFrames and their commanders.

newLeoCommanderAndFrame does the following.  Order is _crucial_:

- first creates an "empty" frame first to pass to the commanders.  This was an Aha!
- then creates the commander and all subcommanders.
- then calls the new frame.finishCreate routine to create the actual frames.
- finally calls c.undoer.clearUndoState(), which requires that menus have already been created.

The present code should be moved to the tkinterGui class.</t>
<t tx="ekr.20071028032929.329">Leo now warns if it can't find either the Icons directory or the LeoApp16.ico icon in that directory.</t>
<t tx="ekr.20071028032929.330"></t>
<t tx="ekr.20071028032929.331"></t>
<t tx="ekr.20071028032929.332"></t>
<t tx="ekr.20071028032929.333"></t>
<t tx="ekr.20071028032929.334"></t>
<t tx="ekr.20071028032929.335"></t>
<t tx="ekr.20071028032929.336">This is much more natural and less cluttered.</t>
<t tx="ekr.20071028032929.337">There were bugs involving the c.pattern_match_flag and c.suboutline_only_flag.

The present code is way too fragil and clumsy.  I plan to rewrite it completely when the configuration logic is redone.

Also, the present code using only a single copy of leoConfig.txt, so changing a setting in one .leo file may change settings in other .leo files.</t>
<t tx="ekr.20071028032929.338">@nocolor

Class level-code after the method definitions was dropped:

@color

class someclass:
	def __init__(self):
		pass

	# this code is dropped
	class_var = None

def some_proc():
	pass</t>
<t tx="ekr.20071028032929.339"></t>
<t tx="ekr.20071028032929.340">allow_clone_drags = 1
# 1: Allows control-dragging to create clones.
# 0: All drags move nodes.
# See also: look_for_control_drag_on_mouse_down
# Setting this setting to 0 allows Leo to be used on Aqua.

enable_drag_messages = 1
# 1: Tell whether drags will move nodes or clone nodes.
# 0: Don't issue such messages.</t>
<t tx="ekr.20071028032929.341">The read code now clears the dirty bit in the root vnode before looking for changed text.

While I was at it, I moved some of the dirty bit logic into getLeoFile.  This makes all read commands work the same.</t>
<t tx="ekr.20071028032929.342">Fixed Go To Outline command so it doesn't crash on 4.0 files.  More work is needed:

- There are "off-by-one" errors.
- It is possible that a complete rewrite in the 4.0 case would be significantly better.</t>
<t tx="ekr.20071028032929.343">This was easy: just write a newline and an @nonl sentinel if the text does not end in a newline.

Compare with the messy 3.x code: a huge simplification.</t>
<t tx="ekr.20071028032929.344">The reason this was so strange is that the at.sentinels ivar was not initialized properly, either in the the old or new classes.  Usually this ivar is set properly (to true) because the _preceding_ file is an @file node that does init the ivar to true.

So the fix was just to set self.sentinel = true in new_df.rawWrite and old_df.rawWrite</t>
<t tx="ekr.20071028032929.345"></t>
<t tx="ekr.20071028032929.346"></t>
<t tx="ekr.20071028032929.347">Again, this wasn't an error, and it was confusing.</t>
<t tx="ekr.20071028032929.348">This wasn't a bug, but it was quite confusing.</t>
<t tx="ekr.20071028032929.349">This avoids overriding the base putSentinel routine with a routine with a different signature.

This argument was never used anyway.</t>
<t tx="ekr.20071028032929.350">This avoids overriding the base scanText routine with a routine with a different signature.</t>
<t tx="ekr.20071028032929.351">leo.py

- Added leoDialog and traceback to import list.
- Removed app args from createFrame and initSherlock.

leoApp

- Changed tList = [] to tDict = {}
- Removed app.finishCreate.

- leoCommands

- Removed some unused local vars in Convert Blanks/Tabs and Reformat Paragraph commands.

leoCompare

- Removed import leoApp, leoCommands from run() method.

leoFileCommands

- Removed unused self.a ivar.
- Removed unused first line below in getPrefs:
	s = string.lower(name)
	language = string.replace(name,"/","")

leoFrame:

- removed some imports from inside createNewMenu and deleteMenuItem.  Plugins should not need these.

- Removed unused vars:
	changed: &lt;&lt; read optional version param &gt;&gt;
	changed: old_df.readOpenFile
	changed: scanText
	changed: &lt;&lt; Test for @path &gt;&gt;
	changed: &lt;&lt; compute relative path from s[k:] &gt;&gt;
	changed: putDocPart (3.x)
	changed: putCodePart &amp; allies
	changed: new_df.readOpenFile
	changed: nodeSentinelText
	changed: &lt;&lt; write then entire @file tree &gt;&gt; (4.x)

leoGlobals:

- Removed unused vars in
	scanAtTabwidthDirective,skip_braces,skip_php_braces,skip_pp_part,isValidEncoding
	&lt;&lt; Set local vars &gt;&gt;
	&lt;&lt; compute relative path from s[k:] &gt;&gt;

leoGui

- Changed self.defaultFont to app.config.defaultFont in getFontFromParams.
- Added leoFrame to import list.

leoNodes

- Fixed real bug in appendStringToBody.
	- The code used none instead of None: changed test just to if not s: return

leoPlugins

- Removed import sys from loadHanders()

leoTree

- Disabled unused call to canvas.find_closest in OnContinueDrag.  Maybe this will help performance?</t>
<t tx="ekr.20071028032929.352">Fixed:

c:\prog\leoCVS\leo\src\leoFileCommands.py:814: Local variable (config) not used
c:\prog\leoCVS\leo\src\leoImport.py:994: Local variable (c) not used
c:\prog\leoCVS\leo\src\leoCompare.py:707: Local variable (c) not used
c:\prog\leoCVS\leo\src\leoCompare.py:707: Local variable (cmp) not used
c:\prog\leoCVS\leo\src\leoFontPanel.py:155: Local variable (c) not used
c:\prog\leoCVS\leo\src\leoApp.py:224: Local variable (tList) not used
c:\prog\leoCVS\leo\src\leoTree.py:1512: Parameter (v) not used (createPopupMenu)
c:\prog\leoCVS\leo\src\leoTree.py:1603: Parameter (v) not used (showPopupMenu)
c:\prog\leoCVS\leo\src\leoApp.py:365: No module attribute (leoID) found (remove app.setLeoId)</t>
<t tx="ekr.20071028032929.353"></t>
<t tx="ekr.20071028032929.354">- Changed app().x to app.x everywhere.

- Changed a.x to app.x everywhere, and eliminated the assignments a = app()

This paves the way to use the app.gui.x pattern more widely.

I did this now so that I could check this with Pychecker: I must run Pychecker anyway so this kills two birds with one stone.
</t>
<t tx="ekr.20071028032929.355"></t>
<t tx="ekr.20071028032929.356">The reason app() is needed is that it's definition doesn't change, even though what it returns does change during startup.

The problem with using a global app var is that from leoGlobals import * picks up and _caches_ the _uninitialized_ value.  Setting leoGlobals.app in the startup logic does not affect all the cached values.

The only way to prevent this would be be avoid importing any of Leo's modules until after the app object has been created.  This looks impossible, and it would be very brittle even if it were possible.

I _really_ would like from leoGlobals import app to work, but how to delay the import until later?</t>
<t tx="ekr.20071028032929.357">These routines now do the following:

1. Print a warning message if their internal string representation is not a unicode string.

2. Convert their results to unicode.</t>
<t tx="ekr.20071028032929.358">The tnode ctor now ensures that headline and body text are converted to Unicode using app.tkEncoding.</t>
<t tx="ekr.20071028032929.359">This was never needed, and removing it prepares to change app from a function to a global var.
</t>
<t tx="ekr.20071028032929.360"></t>
<t tx="ekr.20071028032929.361">1. Called getAllText in the following routines:

colorizeAnyLanguage
convertAllBlanks,convertAllTabs,extract,extractSection,extractSectionNames
OnExecuteScript

2. Called getSelectedText in the following routines:

OnExecuteScript

3. Called x = toUnicode(s,app().tkEncoding) in the following routines after a call to t.get(...)

bound_paragraph,getBodyLines,reformatParagraph
OnReturnKey
OnFindMatchingBracket,findMatchingBracket
updateStatusRowCol
changeAll,findAll
&lt;&lt; test for whole word match &gt;&gt;</t>
<t tx="ekr.20071028032929.362">Previously, nothing was printed if </t>
<t tx="ekr.20071028032929.363">Created new LeoApp16.ico icon w.wm_iconbitmap().

The old code still works with Python 2.2.</t>
<t tx="ekr.20071028032929.364"></t>
<t tx="ekr.20071028032929.365">All the real code has now been moved from leoGlobals.py to leoGui.py.</t>
<t tx="ekr.20071028032929.366"></t>
<t tx="ekr.20071028032929.367"></t>
<t tx="ekr.20071028032929.368">This is the foundation for "foreign" guis.</t>
<t tx="ekr.20071028032929.369"></t>
<t tx="ekr.20071028032929.370"></t>
<t tx="ekr.20071028032929.371">After the 4.0 beta 1 release I changed the default so that _new_ format derived files are written if leoConfig.txt does not exist.</t>
<t tx="ekr.20071028032929.372"></t>
<t tx="ekr.20071028032929.373"></t>
<t tx="ekr.20071028032929.374">This allows the caller to do an auto-save only if something was really written.</t>
<t tx="ekr.20071028032929.375">When I first tried to open LeoPy.leo after writing all @file nodes (With the Write @file Nodes command) I got a

"No joinList for tnode" message.

What I did:

1. Error recovery worked perfectly.  No damage was done!

2. getLeoFile must call setAllJoinLinks _before_ reading @file nodes so that findChild will see a valid joinList.

	- This is perfectly safe in 4.0 because reading _never_ creates vnodes or alters vnode links.

3. writeAtFileNodes now does an auto-save.</t>
<t tx="ekr.20071028032929.376"></t>
<t tx="ekr.20071028032929.377"></t>
<t tx="ekr.20071028032929.378"></t>
<t tx="ekr.20071028032929.379"></t>
<t tx="ekr.20071028032929.380">The output is the same in both the old and new versions.</t>
<t tx="ekr.20071028032929.381"></t>
<t tx="ekr.20071028032929.382">findChild now calls at.readError when t.joinList is None so reading will stop immediately without crashing.</t>
<t tx="ekr.20071028032929.383">@+doc and @+at sentinels indicate trailing whitespace.

It is crucial that whitespace is _always_ handled correctly.</t>
<t tx="ekr.20071028032929.384">This didn't do anything...</t>
<t tx="ekr.20071028032929.385">Must be done to clear tnodeList in the .leo file.  This allows the user to create a 3.x compatible .leo file.</t>
<t tx="ekr.20071028032929.386"></t>
<t tx="ekr.20071028032929.387"></t>
<t tx="ekr.20071028032929.388">I was surprised that the top-level class was a subclass of oldDerivedFile.  This isn't really good.

The first step of separating the class was to make the sentinel constants global to the module.  This required substantial changes.

After that, I separated the atFile class just by providing the initIvars and readLine routines.  To make readLine work I had to init self.encoding.  That's all!

Derived classes must follow base classes in the module, so I changed the top-level node to force the correct order regardless of node order.</t>
<t tx="ekr.20071028032929.389">Changed made:

1. Look ahead in putDocLine to preserve additional leading whitespace.
2. Do _not_ eliminate newline in readLastDocLine.  That must be done only by @nonl logic.

Note:  The code can not do a perfect job of restoring whitespace: it can not distinguish between @ and @space on a line by itself.  However, this construction is rare, and there really is no difference between them.</t>
<t tx="ekr.20071028032929.390"></t>
<t tx="ekr.20071028032929.391">The code calls at.writeAll(writeAtFileNodesFlag=true) to write all nodes in the selected tree.</t>
<t tx="ekr.20071028032929.392">Handling @first and @last is actually quite subtle, and the old code handles the job correctly.

getAtFirstLastLines simply couldn't cut it.  Thanks again to Dave Hein.</t>
<t tx="ekr.20071028032929.393">This must be done to preserve the tnodeList.</t>
<t tx="ekr.20071028032929.394">This code hasn't been tested yet.

- Don't change body text if a) @last and b) only difference is last newline.</t>
<t tx="ekr.20071028032929.395">This is a big step forward:  it eliminates some nasty modes.

- scanHeader returns flag instead of setting ivar.
- Write code uses config.write_old_format_derived_files.</t>
<t tx="ekr.20071028032929.396">Both the old and new write code does this.</t>
<t tx="ekr.20071028032929.397">This is too annoying during testing.</t>
<t tx="ekr.20071028032929.398">We no longer need this: the write_old_format_derived_files setting is enough to disable new writes.

In other words, the transition to 4.0 has begun!</t>
<t tx="ekr.20071028032929.399">This is the clean way of setting the default using the config.write_old_format_derived_files setting.</t>
<t tx="ekr.20071028032929.400">This is the clean way of forcing writes using old or new format.</t>
<t tx="ekr.20071028032929.401">findChild(4.0) and createNthChild (3.x) both now call v.t.setVisited.  The code in top_df.read warns if any non-empty node is unvisited.

This check, and the check that headlines match pretty much guarantees that out-of-synch outlines will generate errors.  In that case, there is no need a gnx timestamp in @+leo sentinels!</t>
<t tx="ekr.20071028032929.402"></t>
<t tx="ekr.20071028032929.403">These changes made in leoPlugins.leo (use_gnx) first.  They will be moved into LeoPy.leo soon.

What I did:
	- Removed gnx's for now (maybe forever?)
	- Eliminated use_gnx and using_gnx code from new read code.
	- All old read/write routines pass.
	- Fixed a bug in old write code(!!) @verbatim was not output correctly!
	- Created top_df.scanDefaultDirectory and top_df.error.
		- We must have this in order to open files in the proper directory.
	- Replaced calls to at.init_ivars by df.init_ivars
	- Created new_df.raw_write
	- Create top_df write routines.
	- Created class topLevelDerivedFileCommands
	- Created class oldDerivedFile
	- Created class newDerivedFile(oldDerivedFile)
	- Removed all error recovery logic from old read code.
	- Replaced structureErrors ivar with errors ivar.
	- Old read code now sets t.tempBodyString.
	- Move all common read code into top_df.read.
</t>
<t tx="ekr.20071028032929.404">- Moved setLeoID into leoApp.py
- Moved nodeIndices class into leoNodes.py.
- Moved askLeoID into leoDialogs.py
- Eliminated myTnode class.
- Moved myFrame methods into leoFrame.py and eliminated myFrame.
</t>
<t tx="ekr.20071028032929.405"></t>
<t tx="ekr.20071028032929.406"></t>
<t tx="ekr.20071028032929.407"></t>
<t tx="ekr.20071028032929.408"></t>
<t tx="ekr.20071028032929.409"></t>
<t tx="ekr.20071028032929.410"></t>
<t tx="ekr.20071028032929.411"></t>
<t tx="ekr.20071028032929.412"></t>
<t tx="ekr.20071028032929.413">tnodeList must be a list of tnodes, _not_ a list of tnode indices.

Indices may be reassigned, tnodes won't.

The _only_ place that an index is proper is in the file format itelf.</t>
<t tx="ekr.20071028032929.414">The script is called "Script to compare 3.x and 4.x derived files" in test.leo.
</t>
<t tx="ekr.20071028032929.415">The bug was in directiveKind.  There are two ways for the code to recognize @others.  After inserting the second way, I mistakenly commented out the first way (by commenting out @others in the table).</t>
<t tx="ekr.20071028032929.416"></t>
<t tx="ekr.20071028032929.417"></t>
<t tx="ekr.20071028032929.418"></t>
<t tx="ekr.20071028032929.419"></t>
<t tx="ekr.20071028032929.420">The new version of putLeadInSentinel works as follows:

1. It calls at.putIndent(at.indent) followed by the leading whitespace in the outline line.

The effect of this is

a) to align the @ws sentinel with the following sentinel and
b) to preserve the "spelling" of the leading whitespace on the line.

2. N.B. The calls to putLeadInSentinel happen _before_ at.indent is changed as the result of the leading whitespace. 

Again, this is so that putLeadInSentinel can preserve the spelling of whitespace.

3. The contribution of the @ws sentinel is the _difference_ between the value of at.indent when the @ws sentinel is being read and the actual whitespace on the line.  Again, we do this to make the derived file look better.</t>
<t tx="ekr.20071028032929.421">This makes the @nl look better, and has no other effect.</t>
<t tx="ekr.20071028032929.422">- Special case code for blank lines.
- Created putBlankDocLine.</t>
<t tx="ekr.20071028032929.423"></t>
<t tx="ekr.20071028032929.424"></t>
<t tx="ekr.20071028032929.425"></t>
<t tx="ekr.20071028032929.426"></t>
<t tx="ekr.20071028032929.427">I added this code to the "main" line for upward compatibility with 4.0.  The main line code does nothing with the new tnodeList attribute as yet.</t>
<t tx="ekr.20071028032929.428">This method now uses the tnode list to find the indicated tnode.  It also checks the headline.</t>
<t tx="ekr.20071028032929.429"></t>
<t tx="ekr.20071028032929.430">The code that reads the new tnodeList attribute of vnodes is contained in the "main line" code, i.e., in LeoPy.leo.  This means that Leo will always be able to read (and ignore) the tnodeList attribute.

The code that writes the attribute is part of the use_gnx plugin.

The tnodeList returns a tnode, not a vnode, so it makes sense to keep track of at.t not at.v.
</t>
<t tx="ekr.20071028032929.431">- The new code now hanles the basic cases properly.

- Added @nl sentinel to indicate whether a section ref should be followed by a newline.

- The read code now sets v.t.tempBodyString instead of call v.setBodyStringOrPane.  This is a major advance in error recovery:  nothing at all changes if errors happen.

What I did earlier:
	- Removed @+body and @-body
	- Don't write organizer nodes in @others</t>
<t tx="ekr.20071028032929.432"></t>
<t tx="ekr.20071028032929.433"></t>
<t tx="ekr.20071028032929.434">This has been changed in Python 2.3 and it probably wasn't ever a good idea...</t>
<t tx="ekr.20071028032929.435"></t>
<t tx="ekr.20071028032929.436">This removes a warning new in Python 2.3.
</t>
<t tx="ekr.20071028032929.437"></t>
<t tx="ekr.20071028032929.438"></t>
<t tx="ekr.20071028032929.439"></t>
<t tx="ekr.20071028032929.440">However, no change was required to cutomizing.html.  In other words, the online description of plugins and hooks was already good.</t>
<t tx="ekr.20071028032929.441"></t>
<t tx="ekr.20071028032929.442">@nocolor

Put install/uninstall in base directory of distribution

Put leo-script.txt goes in ./scripts/install/leo-script.txt
</t>
<t tx="ekr.20071028032929.443">The new values are:

"initial_window_height" : 600, # 7/24/03: In pixels.
"initial_window_width" :  800, # 7/24/03: In pixels.</t>
<t tx="ekr.20071028032929.444"></t>
<t tx="ekr.20071028032929.445"></t>
<t tx="ekr.20071028032929.446"></t>
<t tx="ekr.20071028032929.447"></t>
<t tx="ekr.20071028032929.448">There was no way to remove a default shortcut so that no shortcut was used.

The problem:

You attempted to remove a shortcut merely by removing an entry in the shortcuts section of leoConfig.leo/.txt.  That doesn't work:  the default shortcut remained and conflicted with a new shortcut.  BTW, Leo does need defaults for when leoConfig.txt does not exist.

The workaround:

Specify in leoConfig.leo/.txt some shortcut to override the conflicting shortcuts.
The proper fixes (now on cvs):

1. Leo now sends a warning both to the console window (if any) and to the log pane when it detects a duplicate shortcut.

2. Leo now allows leoConfig.txt to remove the shortcut for a command by specifying None (case doesn't matter) as the value of the shortcut.</t>
<t tx="ekr.20071028032929.449"></t>
<t tx="ekr.20071028032929.450"></t>
<t tx="ekr.20071028032929.451"></t>
<t tx="ekr.20071028032929.452">These aren't great tests, and they do show that now exceptions are thrown in the colorizer.</t>
<t tx="ekr.20071028032929.453">Also fixed some bugs (missing commas) in the list of rebol keywords.</t>
<t tx="ekr.20071028032929.454"></t>
<t tx="ekr.20071028032929.455">This was a most irritating bug.

The problem was in tree.OnDeactivate.  The calls to tree.endEditLabel() and tree. self.dimEditLabel() were interfering with the double-click logic.

What I did:

- Changed tree.OnDeactivate so that it only tried to deactivate the headline if the focus was previously in the tree.  Simple, effective.

- Added get_focus to leoGlobals.py.

- Removed unused frame.active and frame.activeFrame ivars.
	
- Changed set_focus so it only call widget.focus_set if there has been a real change in focus.
	- This has no effect, and could cause problems due to bad params being passed.</t>
<t tx="ekr.20071028032929.456">Added openWithFileName to leoGlobals.py.

	- This allows startup code to create a frame without an existing frame.
	- frame.OpenWithFileName now just calls this global.

Changed startup code so that:

	- Only one window is ever created on startup.
	- Windows are not witdrawn when they are created.</t>
<t tx="ekr.20071028032929.457">This shows Leo's nav buttons and status line.</t>
<t tx="ekr.20071028032929.458"></t>
<t tx="ekr.20071028032929.459">Fixed minor bugs in convertAllBlanks and convertAllTabs (reported no change when there was a change.)</t>
<t tx="ekr.20071028032929.460">This constitutes a major changes to Leo's fundamental vnode code.  

v.copyTree now creates a free-standing tree that may be linked into an existing outline using any of the v.linkX routines.  This is a major simplification that was long overdue.

N.B.  Copied trees share tnodes with the original code.  It would be easy to make this optional, and at present all code expects tnodes to be shared.

N.B.  Nodes of the copied trees are _not_ joined to the original tree.  That is, the copied vnodes v do not appear in v.t.joinList.
</t>
<t tx="ekr.20071028032929.461">The following commands are affected:

Convert All Blanks, Convert All Tabs, Extract, Extract Names, Extract Section.

What I did:

- Rewrote undoer.undoReplace.
	- It is not enough to call createDependents or destroyDependents.
	- 

- Called setUndoParams with oldText, newText, oldSel, newSel params.
</t>
<t tx="ekr.20071028032929.462"></t>
<t tx="ekr.20071028032929.463">The new code assumes nothing about when event handlers get called.</t>
<t tx="ekr.20071028032929.464"></t>
<t tx="ekr.20071028032929.465"></t>
<t tx="ekr.20071028032929.466">- added set_focus and force_focus utilities for better tracing.
- changed drawText so it calls setNormalLabelState when v == editVnode.
	idle_redraw no longer interferes with the headline being edited.
- setNormalLabelState now selects all text and calls set_focus.
- added callers keyword param to trace.
- simplified c.insertHeadline: it no longer has to avoid redraws.</t>
<t tx="ekr.20071028032929.467">This must be done to plug a major security hole.
</t>
<t tx="ekr.20071028032929.468"></t>
<t tx="ekr.20071028032929.469">This was pretty easy.  What I did:

- Changed getTextSelection so that it returns a tuple (insert,insert) instead of (None,None) if the selection range is empty.  This does most of the work!  However, the changeSelection code must now explicitly test to see whether start==end

- Pass an oldSel param to most calls of onBodyChanged.

- Added a newSel param to onBodyChanged and idle_body_key.

- Forced the focus to the body pane after pressing undo/redo buttons in the Spell Checker.  This makes the selection visible.</t>
<t tx="ekr.20071028032929.470">Shift-Control-O was causing a crash.  Not surprising since it had no business in call OnOpenWith.

What I did:
	
- removed event param from OnOpenWith.
- Created an Open With Submenu in &lt;&lt; create the top-level file entries &gt;&gt;
	This has the effect of not allowing a shortcut for this menu.
- Use app().hasOpenWithMenu to enable or disable Open With menu.
- Removed Shift-Control-O setting in leoConfig.leo/.txt.</t>
<t tx="ekr.20071028032929.471"></t>
<t tx="ekr.20071028032929.472"></t>
<t tx="ekr.20071028032929.473">Made this change to the Color, Compare, Font, Prefs and Spelling panels.  However, this doesn't set the focus as I would like.</t>
<t tx="ekr.20071028032929.474">dict was being altered in a loop where it shouldn't be.  Changed the name of the var in the loop from dict to d.</t>
<t tx="ekr.20071028032929.475">Symptom: Sometimes the "reading" messages would not appear when reading an outline.

Cause: Several event handlers are called at unpredictable times during the load process.  These may try to reset the log.

Solution:

- create app.setLog, app.lockLog and app.unlocklog methods.
- call app.lockLog before opening an outline.</t>
<t tx="ekr.20071028032929.476">Changed destroyOpenWithFilesForFrame and createOpenWithTempFile so they don't loop on a list that is being modified.</t>
<t tx="ekr.20071028032929.477"></t>
<t tx="ekr.20071028032929.478"></t>
<t tx="ekr.20071028032929.479">@color

# Commanders and subcommanders.
class Commands (baseCommands): pass
class atFile (baseAtFile): pass
class fileCommands (baseFileCommands): pass
class leoImportCommands (baseLeoImportCommands): pass
class tangleCommands (baseTangleCommands): pass

# Helper classes.
class colorizer (baseColorizer): pass
class config (baseConfig): pass
class undoer (baseUndoer): pass

# Key data classes.
class LeoFrame (baseLeoFrame): pass
class leoTree (baseLeoTree): pass
class tnode (baseTnode): pass
class vnode (baseVnode): pass

# Dialogs and other panels
class leoColorPanel (baseLeoColorPanel): pass
class leoColorNamePanel(baseLeoColorNamePanel): pass
class leoComparePanel (baseLeoComparePanel): pass
class leoCompare (baseLeoCompare): pass
class leoFontPanel (baseLeoFontPanel): pass
class leoDialog (baseLeoDialog): pass
class LeoPrefs (baseLeoPrefs): pass
</t>
<t tx="ekr.20071028032929.480">- Made functions into class methods.
- Make sure to close pipes after every command.
- Rewrite local dictionary in alph order.
</t>
<t tx="ekr.20071028032929.481"></t>
<t tx="ekr.20071028032929.482">At present setup.py must be run from the top level leo directory.  Hopefully this will be fixed.

Also, the linux install script won't work.
</t>
<t tx="ekr.20071028032929.483">c:\prog\leoCVS\leo\src\leoAtFile.py:2791: Format string argument count (1) doesn't match arguments (2)

c:\prog\leoCVS\leo\src\leoFrame.py:976: No global (a) found

This may have been the cause of some problems with the log panel.

c:\prog\leoCVS\leo\src\leoNodes.py:1174: Parameter (encoding) not used

This may have been the cause of some "unicode" problems.</t>
<t tx="ekr.20071028032929.484">The old code had no chance of working.  I think I actually understand what is happening now...</t>
<t tx="ekr.20071028032929.485">The body_pane_wraps setting is used if neither of these directives is in effect.
</t>
<t tx="ekr.20071028032929.486"></t>
<t tx="ekr.20071028032929.487">Added code to check for errors in the table passed to createOpenWithMenuFromTable.</t>
<t tx="ekr.20071028032929.488">We have to do the &lt;&lt; set removeTrailing &gt;&gt; logic when the delete key is pressed, and that wasn't happening.

The new code now remembers properly when the user deletes a trailing newline.</t>
<t tx="ekr.20071028032929.489"></t>
<t tx="ekr.20071028032929.490">created frame.setInitialWindowGeometry.</t>
<t tx="ekr.20071028032929.491">1. Added destroy routines for all major classes

This allows most window objects to be garbage collected when a window closes.  In practice it is _very_ difficult to remove all references to all window objects.  Breaking those links "by hand" in the destroy routines is a more pragmatic approach.

The big drawback is that destroy methods must be updated when a new ivar is added to a ctor that refers to other objects.  In practice, such ivars aren't added often.

With these new routines in place Leo does, in fact, recycle most objects from windows when a window closes.  This plugs the last (relatively minor) leak in Leo.

2. Created a _general_ way of clearing all ivars of an object.

o.__dict__.clear() does the job!

3. Remvoed all destroy routines, replacing them by app.destroyAllWindowObjects().

This is a simple, effective, pragmatic approach, and it doesn't require changes when new ivars are added to ivars!</t>
<t tx="ekr.20071028032929.492"></t>
<t tx="ekr.20071028032929.493"></t>
<t tx="ekr.20071028032929.494">These are not needed now that Python has a gc that can recover cycles.

Everything should go away because:

- app().windowList no longer points to a frame.
- frame.top.destroy() eliminates all the Tk pointers.</t>
<t tx="ekr.20071028032929.495">I did the following:

- Searched for use_gnx, using_gnx, use_pre_4pt0_file_formats.
- Removed all 4.0 constants from &lt;&lt; atFile constants &gt;&gt;
- Removed the setting corresponding to use_pre_4pt0_file_formats config ivar.

As I was doing this I moved routines and code snippets into the Abandoned Code from 4.0 node.

This is a major step forward for Leo!  The code base is mostly back to 3.10 days, with some improvements to vnodes and tnodes.</t>
<t tx="ekr.20071028032929.496"></t>
<t tx="ekr.20071028032929.497"></t>
<t tx="ekr.20071028032929.498">Fractions cause problems in some locales.  The height/width params weren't used anyway!
</t>
<t tx="ekr.20071028032929.499">This was all that was needed to correct the problem with new windows.</t>
<t tx="ekr.20071028032929.500">- Added self.widgets list and associated logic in deleteBindings.

We can't rely on the Tk.Widget to delete the associated Python objects!

- Added printGarbage routine to leoGlobals.py.</t>
<t tx="ekr.20071028032929.501">This is significant for two reasons:

1.  It shows how to reduce the number of Tk widgets allocated to a constant (linear in size of the canvas).

2.  It shows that incremental drawing could be used with vxnodes.

This code took a lot of work.  Issues involving the scrollbar resulted in a two-pass drawing algorithm.  The first pass populates the canvas.  The second pass sets the visible area properly after the scrollbar is set properly.

The visual appearance of scrolling appears identical, regardless of whether incremental allocation is used.  This is an important result.

To enable incremental allocation of Tk widgets during redraws, set self.allocateOnlyVisibleNodes = true in tree.__init__.

Pros:
	
- substantially reduces the number of Tk widgets that get allocated.

Cons:
	
- More complex code (it appears solid)
- A two-pass screen redrawing algorithm (it appears fast enough)
- Not all nodes become visible immediately when sliding the scrollbar.
	This is mostly likely because the actual redrawing of the screen happens at idle time.</t>
<t tx="ekr.20071028032929.502">The new code is simple, elegant, efficient, flexible.  A good day.</t>
<t tx="ekr.20071028032929.503">Here are the results from running checkClones2Links script on this file:

multipleTargetsInDerivedFiles: 8

(fixed) class nodeIndices      (improperly duplicated in leoAtFile.py)
(fixed) frame.OpenWithFileName (improperly duplicated in Recent Files submenu)
(fixed) recentButtonCallback   (improperly duplicated in Mark/Goto submenu)

-- Used several times in same derived file.  Will this be valid in LeoN?

&lt;&lt; Append any unused text to the parent's body text &gt;&gt; (used several times in leoImport.py)
&lt;&lt; Check both parts for @ comment conventions &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Compare single characters &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Set the default directory &gt;&gt; (used several times in leoAtFile.py)

-- Used (properly) in two different derived files:

replacePatterns (used on purpose in setup.py and postSetup.py)

clonedAtFileNodes: 9

@file ../plugins/add_directives.py
@file ../plugins/french_fm.py
@file ../plugins/open_with.py
@file ../plugins/vim.py
@file ../plugins/xemacs.py
@file c:\prog\test\multiple.txt
@file-nosent nosentCloneTest.txt
@silentfile ../doc/PKG-INFO.TXT
@silentfile ../doc/README.TXT
</t>
<t tx="ekr.20071028032929.504"></t>
<t tx="ekr.20071028032929.505"></t>
<t tx="ekr.20071028032929.506">This code is extremely dangerous at present.</t>
<t tx="ekr.20071028032929.507"></t>
<t tx="ekr.20071028032929.508"></t>
<t tx="ekr.20071028032929.509"></t>
<t tx="ekr.20071028032929.510"></t>
<t tx="ekr.20071028032929.511"></t>
<t tx="ekr.20071028032929.512">This completely eliminates namespace polution and also simplifies tree.select.</t>
<t tx="ekr.20071028032929.513">Nav plugin now warns if icons do not exist.

Leo now destroys the Recent Nodes dialog when user hit the close button at the top of the window.

Leo updates the Recent Nodes panel only if it is visible.</t>
<t tx="ekr.20071028032929.514"></t>
<t tx="ekr.20071028032929.515">Created new nav_buttons plugin.  This plugin adds 4 new buttons to the icon area at the top of each Leo window:

- Back and Forward arrows that work like a typical web browser.  Clicking the back arrow button takes you to the last node in the tree you visited.  Clicking the forward arrow button moves you forward.  The forward arrow button is dimmed unless you have clicked the back arrow button recently.

- The Recent button opens a non-modal dialog showing all the nodes you have visited recently.  This dialog is updated cleanly by the tree.select method.  You will see this entries change dynamically.  There are buttons in this dialog for clearing individual entries or clearing all entries.  Double-clicking any entry in this dialog takes you to that node, as does clicking the Go button.

The entries in the Recent Nodes pane do _not_ correspond to the order implied by the Forward and Back arrows.  Rather, the most recently visited node is on top, followed by the next most recently visited node, and so on, with the additional feature that nodes appear only once in the list.

- The Marks button opens a non-modal dialog showing all marked nodes in the tree.  Marking or unmarking nodes in the tree adds or deletes entries from this dialog.  Double-clicking any entry in this dialog takes you to that node, as does clicking the Go button.

I think the Marks dialog will be more useful for most people, for the following reasons:
1. You get to choose the nodes that appear in the dialog (using the Mark and Unmark commands)
2. The nodes appear in outline order.

In addition, hypertext links now enabled by default.  Control-click any section reference to go to its definition.  I changed the colorer so that it does _not_ underline active hyperlinks in section reference.  If a section reference is underlined, it means the definition does _not_ exist.  Otherwise the section reference _does_ exist and control-clicking the reference takes you to the defining node in one of its descendents.

Still to do: extending the color_markup plugin so that it underlines hypertext links in comments, """ python strings and doc parts.

It was great fun doing this project: plugins rule!  However, I am not really convinced that these dialogs are actually going to get used all that much.  For me, gathering nodes together using clones is by far the best way to make sense of a complex project.

Anyway, the code looks robust and fairly complete.  I have no plans for any more hacking, though all sorts of additions are fairly obvious, including more buttons in the Marks window. 

What I did:

leoColor.py

- Hypertext links now enabled by default.  Control-click any section reference to go to its definition.

- Leo no longer underlines active hypertext links. 

- To do: http hypertext links in color_markup plugin?

leoCommands.py

- Added c.beadList &amp; c.beadPointer to implement browser-style forward and back buttons.  Adding these ivars to the commands class is reasonable because the Forward &amp; Back commands are now official Leo commands.

The logic for the Forward &amp; Back commands is similar to the "bead" scheme used by undo.  However, it is completely separate.  In particular, these commands are careful to check that a node actually exists in the present tree before going to it!  And the Recent Nodes dialog removes nodes that do not presently exist using the v.exists method.

- Added optional updateBeadList param to c.selectVnode.  This adds flexibility to how the Forward &amp; Back commands work: I'm not sure that Leo uses this flexibility at present.

leoDialog.py

Added three new classes to support Recent nodes and Marks listboxes: class listBoxDialog and two derived classes:
	
- class recentSectionsDialog (listBoxDialog):
- class marksDialog (listBoxDialog):

leoFrame.py

- Initialized bead logic in frame.__init__.  This is a kludge.  Beads should be a separate class.

- Added support for existing graphics to addIconButton. (different names for keyword args).

- Added Go Back and Go Forward commands (and related logic) renaming the old commands to Go To Prev Node and Go To Next Node.

leoNodes.py

- Added exists method.  This method is used to check (quickly!) whether v is in c's tree.  We need this logic because undo may have altered nodes that appear on the bead list.

leoTree.py

- Added support for Forward &amp; Back commands to tree.select after select2 hook.

- Added select3 so that plugins can call their own code following this new code.</t>
<t tx="ekr.20071028032929.516">Apparaently the zfill string method was added in Python 2.2.2.</t>
<t tx="ekr.20071028032929.517"></t>
<t tx="ekr.20071028032929.518">@color

I am uneasy about the security implications of having Leo execute script x if it is passed a "script:x" parameter.  Perhaps I am being over-cautious.

Anyway, there is no need for this machinery.  To create reference file for unit testing call leoUnitTest.createReferenceFiles in the old copy of Leo.  This only needs to be done once.

@color

if 0: # Just run this from the reference copy of Leo.
	import leoUnitTest
	leoUnitTest.createReferenceFiles()

if 0: # Not needed.  It does work, though.

	from leoGlobals import *
	import os

	os.spawnl(os.P_NOWAIT,"c:/python22/python.exe",
		"-i c:/prog/leoCVS/leo/src/leo.py",
		"script:leoUnitTest,createReferenceFiles")</t>
<t tx="ekr.20071028032929.519"></t>
<t tx="ekr.20071028032929.520">Using an idle hooks completely simplifies the code, and it means that Leo never slows down to update the area.</t>
<t tx="ekr.20071028032929.521"></t>
<t tx="ekr.20071028032929.522"></t>
<t tx="ekr.20071028032929.523"></t>
<t tx="ekr.20071028032929.524">Removed the ancient kludge for forcing the height &amp; width of f.  The code in leoFileCommands.getGlobals now works!

The reason that Leo was opening small windows without the height &amp; width params is that getGlobals was telling it to do so!

Changed leoConfig.leo/.txt to use 75 and 200 for the initial height and width.</t>
<t tx="ekr.20071028032929.525"></t>
<t tx="ekr.20071028032929.526">I replaced all the ivars with a dict and several lists.  This is much more clean.  However, the same idea isn't so good for the commands class: using individual ivars is much simpler.  Similar remarks apply to the Prefs panel.</t>
<t tx="ekr.20071028032929.527">destroyIconFrame
createIconFrame
insertButtonInIconFrame</t>
<t tx="ekr.20071028032929.528">This affect the Write Missing @file Nodes command.</t>
<t tx="ekr.20071028032929.529"></t>
<t tx="ekr.20071028032929.530"></t>
<t tx="ekr.20071028032929.531"></t>
<t tx="ekr.20071028032929.532">The new code uses three passes in colorizeAnyLanguage!

Pass 0:  The normal code.

insertWiki picture sets colorer.redoColoring = true if it is ever called in pass 0.  This ensures that the following two passes will be called.  If the body contains no images, the new code is equivalent to the old.

Pass 1:  Insert graphics into the body text.

We do this in a separate pass to simplify the following kludge.

Pass 2:  Insert dummy characters and recolor the text.

Images take up a real index, yet the get routine does not return any character for them!  We insert dummy blanks in s at the positions corresponding to each image to keep everything in synch.  We then recolor the line normally.

This three-pass algorithm appears to be robust.  In particular, it handles the following special cases:

- The user can invalidate an image name, requiring a full redraw.

- The user can delete an image itself, leaving the markup unchanged.  The image will reappear the next time Leo does a full redraw.

- An image may appear twice in the body text.

- The user may edit any line not containing a graphic without invoking passes 1 and 2.</t>
<t tx="ekr.20071028032929.533">	- Fixed bug: continued """ weren't colored properly when @markup wiki not in effect!

</t>
<t tx="ekr.20071028032929.534">There is now only a single entry point into Leo: the run() routine.

This routine uses an optional fileName arg.</t>
<t tx="ekr.20071028032929.535">- This supports the @markup wiki directive.

- It can add arbitrarily many directives.</t>
<t tx="ekr.20071028032929.536">Not yet: user directives for leoAtFile.py or leoTangle.py.</t>
<t tx="ekr.20071028032929.537">Created "init-color-markup" hook for use of markup plugins.

This allows the colorizer to completely recolor a node when the @markup directive changes.</t>
<t tx="ekr.20071028032929.538">Continued """ weren't colored properly when @markup wiki not in effect!
</t>
<t tx="ekr.20071028032929.539"></t>
<t tx="ekr.20071028032929.540">1.  Leo now scans all .py files in the plugins folder when looking for plugins.

Filenames need not start with mod_, and Leo scans only the plugins folder.

2. Replaced detailed loading message with a summary of the number of files loaded &amp; examined.

3. Added importFromPath in leoGlobals.py.

This encapsulates a lot of details, and makes it unnecessary to alter sys.path.

</t>
<t tx="ekr.20071028032929.541">1.  Changed handleLeoHook to doHook.

2. Changed most instances of:

  if doHook(...) == None:

to:

	if not doHook(...)

This works provided that doHook does not return a "significant" value.</t>
<t tx="ekr.20071028032929.542">- Converted wiki code to a plugin.  No need for config settings!

- Added code to parse wiki stuff in doc parts and comments.</t>
<t tx="ekr.20071028032929.543">Added the following stub hooks for customizing the outline pane:

	drawBox   doHook("draw-outine-box",tree=self,v=v,x=x,y=y)
	drawIcon  doHook("draw-outline-icon",tree=self,v=v,x=x,y=y)
	drawNode  doHook("draw-outline-node",tree=self,v=v,x=x,y=y)
	drawText  doHook("draw-outline-text-box",tree=self,v=v,x=x,y=y)
	drawTree  doHook("draw-sub-outline",tree=self,v=v,x=x,y=y,h=h,level=level)
	redraw    doHook("redraw-entire-outline",c=self.commands)

Conceivably it would be better for a plugin just to replace these routines.</t>
<t tx="ekr.20071028032929.544">I have found this command to be highly annoying and unwanted.</t>
<t tx="ekr.20071028032929.545"></t>
<t tx="ekr.20071028032929.546"></t>
<t tx="ekr.20071028032929.547">- Load plugins and execute hooks in alphabetical order.

- Created "new" hook.  Somewhat useful.

Created "create-optional-menus" hook: extremely useful.  The first stub hook.</t>
<t tx="ekr.20071028032929.548"></t>
<t tx="ekr.20071028032929.549">

Early this morning I uploaded the new 4.0 code base to cvs.  This is an important milestone in Leo's history.  I urge anyone using code on cvs to at least skim through this long posting.

1.  Code on cvs is safe and stable

AT PRESENT, the code on cvs reads and writes 3.x files just as before.   The code appears stable, which is not surprising because the new code is based on the old.  Very few changes were needed to handle the new file formats.  These changes are enabled when app().use_gnx is true. app().use_gnx is false on cvs now.

I think the present cvs code is safe and stable.  However, I _strongly_ recommend that you assume otherwise:  Please make backups of any files or folders affected by the new cvs code.

Most of the work required to read and write 4.x .leo and derived files is complete; there are only a few days work left before the transition to 4.x formats.  I do NOT recommend that you enable the new code; some file format changes are in store.  You will be warned when the transition to the new file formats happens on cvs.  This will be another major event: all sentinels will change.

2.  Code bases have merged

The code on cvs merges the 3.x and 4.x code bases.  In retrospect, I regret splitting the development.  It really didn't help.  In any event, there will be no more splits in development.

With the merged code base, one can easily imaging releasing both 3.x versions and 4.0 beta versions in parallel.  Indeed, the only difference between the two versions would be the setting of app().use_gnx.  Also note that even in the 4.0 final version you will be able to write 3.x files.  Just set use_pre_4pt0_file_formats = 1 in leoConfig.txt.

The latest cvs code assumes that leo folders contain the config, doc,  plugins, scripts and src subfolders.  The new version of the installer script, leo.nsi, found in LeoPy.leo, creates these folders.  See the diary entry for 5/12 in LeoPy.leo for a list of the changes made to support the new directory structure.

3.  Improved code base &amp; new invariant

I took the opportunity afforded by 4.0 to clean up the old code base in several important ways.  First, the new code uses proper Python lists to represent join lists.  This greatly clarifies the relevant sections of code, and may even provide a performance boost.  Secondly, tnodes now contain both headline and body text.   This change creates an important invariant:  vnodes with the same vnx's always point to tnodes with the same tnx's.  This invariant is vital to resolving conflicts properly.

4.  Prototype of graphics &amp; styled text

leoColor.py contains a prototype of code that allows wiki-style markup in body panes.  This is important work, because it tests Tk's abilities to handle styling and graphics in the highly dynamic environment that is Leo's body pane.  Some details:

- There are a few bugs left to fix, and it is clear that this prototype is a great success.  The combination of Python and Tk are easily up to the job.  The programming details are interesting, and not interesting enough to discuss here :-)  Look at the topic called (Graphics &amp; Styled Text: Wiki format) in LeoPy.leo if you are curious.

- The code that handles the wiki formatting is disabled at present on cvs.  To enable it, just change if 1: to if 0: in doWikiText.  It is quite safe to do so: the syntax colorer catches all exceptions.  The worst that can happen is that some of your text won't be colored properly.

- The present code only handles wiki markup in Python triple-quoted strings denoted by three double quotes.  Because wiki markup uses single quotes, it does not seem prudent to allow wiki formatting in ''' strings.  Still to do: allow wiki markup in doc parts and comments.  This will be easy enough.

- doWikiText at present only handles the following markup:

    __bold__,
    ''italics'' (two single quotes, not a single double quote!)
   {picture file=&lt;filename&gt;}
   ~~&lt;color specifier&gt;~~ 

To repeat: using wiki markup to denote styling and graphics is merely a prototyping expedient.  I'm not sure how to represent such information.  The great advantage of a text-based specification is that it doesn't change the rest of Leo _at all_.  In particular, I had a nice aha: we can use the Show Invisibles command to show or hide the wiki text.  When invisibles are hidden, all you see are the _effects_ of the wiki markup.  When invisibles are visible, you see the markup plus their effects.  No need for extra commands.

- rst is another alternative to wiki format.  I'll soon start another thread to discuss the pros &amp; cons.  Please don't vote here.

- Instead of the present hand-written parser, Leo should use an "official" parser for whatever markup is chosen.  However, this can wait.

5. To do

There are significant additional work to do before 4.0 final.  After 4.0 alpha 1 comes out (maybe in a week?), I plan to rewrite the code that reads .leo files.  The new code will use an xml parser (probably sax) to read .leo files rather than the present hand-written mess.  I have fairly high hopes that sax will significantly speed up the reading of .leo files themselves.  Note, however, that such tools can _not_ be used to read derived files because derived files are not xml files.

Edward</t>
<t tx="ekr.20071028032929.550">This required folder-by-folder copies, so it was potentially error prone.</t>
<t tx="ekr.20071028032929.551"></t>
<t tx="ekr.20071028032929.552">This cleans up the list of files being read.</t>
<t tx="ekr.20071028032929.553">These don't change often enough to warrant reading every time.</t>
<t tx="ekr.20071028032929.554"></t>
<t tx="ekr.20071028032929.555">1. Created config, doc, examples, plugins, scripts, src, test &amp; tools folders.  This really clarifies matters.

2. Removed the following files:

- nsi.leo file.  This was a duplicate of code in LeoPy.leo.  
- The following unused .bat files: bdist.bat, go.bat, help.bat, sdist.bat.
- The two resource files: leo.rc and leo.res.  These are for Delphi!

3. These changes required changes to:

- Actual code.  The following commands were affected:
	- The About Leo dialog (path to icon in dialog).
	- Tree drawing code (path to icons)
	- Open LeoDocs.leo and Open leoConfig.leo commands in help dialog.
	- Initialization in leoConfig.py.

Note: Tangle/Untangle will find tangle_done.py and untangle_done.py provided that the scripts folder is in sys.path.

- The leo.nsi script that creates leoinstall.exe.  This required considerable amount of work.

- Paths specified in @file nodes.

- All files in cvs.  The attic contains all the old files.  cvs contains new 1.1 versions of all code.  This is most unfortunate.  However, the cvs code started out with the 3.11.1 code base, so 4.0 changes will be visible.
</t>
<t tx="ekr.20071028032929.556">Sometimes the reading: @file messages were not showing up during Open commands. Perhaps the are differences in the events that caused app().log to be set to None, or to be set before the Tk text widget was initialized.  Could problems with configuration show up like this?  Or maybe it was just a weird Windoze bug...

Added code to force setting of app().log in OpenWithFileName.

If this bug shows itself again I'll add print code to show the following:

- The frame associated with app().log.
- The events that set app().log to something _other than_ None.</t>
<t tx="ekr.20071028032929.557"></t>
<t tx="ekr.20071028032929.558">Saving LeoPy.leo generated 46740 calls to v.threadNext!

It looks like optimizing threadNext would be useful.
There seems to be no need to optimize threadBack.</t>
<t tx="ekr.20071028032929.559"></t>
<t tx="ekr.20071028032929.560"></t>
<t tx="ekr.20071028032929.561">What I did:

- Replaced mFirstChild with mChildren.
- Partially replaced mBack and mNext fields.
- Assumed the existence of c.frame.dummyChildren array.

I abaondoned this code for the following reasons:

- The new code might be slower than the old code!

- mBack, mNext and mFirstChild will take less space than mChildren.

- Precomputing threadNext() and maybe threadBack() may be _much_ faster.</t>
<t tx="ekr.20071028032929.562"></t>
<t tx="ekr.20071028032929.563">In 4.0 we must have a single, global (per-outline) tnodesDict so that all joined vnodes in fact use the same tnode.

This dict must never be reinitialized!

*** N.B.: we create the sharing of the common tnode first, then create the join link later, at the end of getLeo2 or other top-level read routines.

</t>
<t tx="ekr.20071028032929.564">This actually may have found one broken clone.  It certainly did find a copy of code.</t>
<t tx="ekr.20071028032929.565">nodeAfterTree was being called too often.

Used same logic to delete tree after read errors that was used to delete tree when using gnx.  The old code called doDelete, and that was the cause of huge delays when there were read errors.

Removed the &lt;&lt; Handle all status bits &gt;&gt; logic from atFile.read.  There is no need for this!  The fileCommands logic sets the current node logic.</t>
<t tx="ekr.20071028032929.566">Eliminated awkward dummy nodes.</t>
<t tx="ekr.20071028032929.567"></t>
<t tx="ekr.20071028032929.568"></t>
<t tx="ekr.20071028032929.569"></t>
<t tx="ekr.20071028032929.570">What I did:

- Created fileCommands.setAllJoinLinks to create or update all join links.

- The fileCommands.getLeoFile and fileCommands.readAtFileNodes now contain:

self.setAllJoinLinks(c.rootVnode())
c.initAllCloneBits()

** Removed the code equivalent to setAllJoinLinks from atFile.read.

** Removed the code that scans the entire vnode tree for the current &amp; top attributes.
	The code _must_ set these without rescanning an entire derived file!

- Added atFileNodesFlag=true param to getLeoFile.

- Added partialFlag=false param to atFile.readAll.</t>
<t tx="ekr.20071028032929.571">More checks would be good.</t>
<t tx="ekr.20071028032929.572">This was easy to do because most code uses the v.headString() getter.
</t>
<t tx="ekr.20071028032929.573">The first version didn't work, and caused clones not to work!

This could have caused a major mess with Leo.py, but I reverted to a previous copy and I believe no clone links have been damaged.</t>
<t tx="ekr.20071028032929.574"></t>
<t tx="ekr.20071028032929.575">I'm not sure how an empty filename got passed to this routine, and it did happen.</t>
<t tx="ekr.20071028032929.576">See the (Rewriting joinList code) project for full details.

Examining the code revealed that the undoReplace code does not work.  This is a long-standing bug!

</t>
<t tx="ekr.20071028032929.577"></t>
<t tx="ekr.20071028032929.578">Leo was using the defaultID when creating new gnx's.  We must always use app().userID when creating new gnx's!

- Added userID ivar to node indices class.
- Removed the id arg to getNewIndex.</t>
<t tx="ekr.20071028032929.579">We do this to discourage users from messing with such lines.

Leo writes bogus @space "sentinels" following @+v and @+t sentinels, and readLinesToNextSentinel looks for such lines while scanning without calling sentinelKind.

Perhaps readLinesToNextSentinel should be called readLinesToNextRealSentinel ;-)</t>
<t tx="ekr.20071028032929.580"></t>
<t tx="ekr.20071028032929.581"></t>
<t tx="ekr.20071028032929.582">What I did:

- created nodeIndices.setTimestamp() routine.

This sets the new timeString ivar.  This saves a large number of calls to time.strftime.
All write routines should call setTimestamp once.

- created assignAllGnx method.  The compact/AssignFileIndices methods call this if use_gnx is true.

This ensures that all fileCommands write code assigns gnx's.

Also, Leo doesn't needlessly compute file indices when use_gnx is true.

- Assert's will fail in the fileCommands write code if we try to write a node without a gnx.

- The atFile.write code allocates t.gnx if needed.

This may be needed for the Write @file Nodes command.</t>
<t tx="ekr.20071028032929.583"></t>
<t tx="ekr.20071028032929.584"></t>
<t tx="ekr.20071028032929.585">I left in the commented out code that reads these fields, just in case we come across old .leo files with them in.  This code should be removed completely soon.

What I did:

For reading/writing .leo files:

- Removed gnx arg from createChild.
- Removed the code that allocates v.gnx.
- Removed the code that reads and writes the vnx= field.
- Removed v.getGnx

For reading/writing derived files:

- Removed the code that reads the gnx field in @+v sentinel lines.
- Called putSentinel instead of putSentinelAndGnx when writing vnodes in derived files.</t>
<t tx="ekr.20071028032929.586">This should minimize any pain on Linux systems.</t>
<t tx="ekr.20071028032929.587">I want to make sure that the proper read code is executed when reading _old_ .leo files when a.use_gnx is true.

I checked to make sure that node indices are resolved properly in all cases.  They are because self.tnodesDict is used regardless of a.use_gnx.

I also did a search on .use_gnx and in all cases the code will handle old .leo files even when use_gnx is true.</t>
<t tx="ekr.20071028032929.588">This makes the code clearer and cleaner.  I wrote getT before knowing about dict.get.</t>
<t tx="ekr.20071028032929.589"></t>
<t tx="ekr.20071028032929.590">This is far simpler than trying to figure out whether to allocate them beforehand.

Added code to do this when writing both .leo files and derived files.
</t>
<t tx="ekr.20071028032929.591"></t>
<t tx="ekr.20071028032929.592">The read code handles both txn and t attributes for compatibility wity old files.</t>
<t tx="ekr.20071028032929.593">We want to be specific because v elements will have both vnx and tnx fields.  The tnx field is about to replace the old tx field.</t>
<t tx="ekr.20071028032929.594">It sets app().use_gnx = false.</t>
<t tx="ekr.20071028032929.595"></t>
<t tx="ekr.20071028032929.596">This was a vain attempt to speed up the code.  Apparently the problem is elsewhere.  However, the new code is much simpler, so I'll stay with it.</t>
<t tx="ekr.20071028032929.597">This substantially reduces the size and clutter of .leo files.</t>
<t tx="ekr.20071028032929.598"></t>
<t tx="ekr.20071028032929.599"></t>
<t tx="ekr.20071028032929.600"></t>
<t tx="ekr.20071028032929.601"></t>
<t tx="ekr.20071028032929.602">This should be false if you plan to upload changes to Leo's cvs site.</t>
<t tx="ekr.20071028032929.603">This command is needed, I think, so that people can continue to use older versions of Leo.</t>
<t tx="ekr.20071028032929.604"></t>
<t tx="ekr.20071028032929.605"></t>
<t tx="ekr.20071028032929.606">This is required to be able to recognize shared nodes.
</t>
<t tx="ekr.20071028032929.607">The nodes are created by default, and we must be very careful to share tnodes properly.

The present code probably does this, but we must be ever vigilant.</t>
<t tx="ekr.20071028032929.608"></t>
<t tx="ekr.20071028032929.609"></t>
<t tx="ekr.20071028032929.610">List comprehensions are present in Python 2.0 or above.</t>
<t tx="ekr.20071028032929.611"></t>
<t tx="ekr.20071028032929.612"></t>
<t tx="ekr.20071028032929.613"></t>
<t tx="ekr.20071028032929.614">Fixed bug in handleLinesFollowingSentinel:
c:\prog\LeoCVS\leo\leoAtFile.py:482: No global (i) found
Removed i arg from rfind.

Fixed bug in definition of BadLeoFile:
c:\prog\LeoCVS\leo\leoFileCommands.py:27: Base class (exceptions.Exception) __init__() not called
Added call to Exception.__init__(self,message)

Fixed bug in askYesNoCancel
c:\prog\LeoCVS\leo\leoDialog.py:283: Variable (no) used before being set.
Disabled defaultButton logic.  New code would have to be thoroughly tested.

Removing unused routine: setDefaultLoc.
c:\prog\LeoCVS\leo\leoNodes.py:2581: No class attribute (defaultLoc) found

Fixed bug in put: changed a to app()
c:\prog\leoCvs\leo\leoFrame.py:4973: No global (a) found
</t>
<t tx="ekr.20071028032929.615"></t>
<t tx="ekr.20071028032929.616">@nocolor

I have just uploaded code to cvs that supports a new @lineending directive.  This directive allows you to specify the line endings for individual derived files.  This directive will override the output_newline setting in leoConfig.txt.  Note that @lineending _never_ affects the line endings in .leo files themselves:  we must have consistent line endings in .leo files!  See below for more details.

More importantly, I have "cleaned up" the code in the vital tangle.scanAllDirectives, atFile.scanAllDirectives and the scanDirectives global function by factoring out code to global helper functions.  Normally this should have been done at the start of a release cycle, not at the end, but I got carried away :-)

So please test this new code by writing all your files with the Write @file Nodes command and the Tangle all command.

I'll delay 3.11 final just a little longer to make sure I haven't done something really stupid, though I have reviewed the cvs change logs carefully (and found a few minor mistakes in the process).  I promise this will be the last changes to 3.11 (except for bug fixes) before 3.11 final finally goes out the door.

Anyway, the valid forms of the new @lineending directive are:

@lineending nl         (the default, Linux)
@lineending cr         (Mac)
@lineending crlf       (Windows)
@lineending lf          (same as nl, not recommended)
@lineending platform (same as platform value for output_newline setting in leoConfig.txt)

Edward</t>
<t tx="ekr.20071028032929.617">These utilities simplify and regularize scanning for the @encoding, @lineending, @pagewidth and @tabwidth directives for atFile.scanAllDirectives, tangle.scanAllDirectives and scanDirectives.

This is a partial solution for the problem of duplicated code in these routines.</t>
<t tx="ekr.20071028032929.618">skip_long was throwing an exception if there were no valid digits following a + or - sign.</t>
<t tx="ekr.20071028032929.619">- Enabled ok button only if 4 or more characters.
- Message now says that 4 or more characters are required.</t>
<t tx="ekr.20071028032929.620">Browsing the comp.lang.python yesturday I found that there are serious problems with Python's getdefaultlocale() routine.  Martin v. Löwis says "getdefaultlocale() is broken, and cannot be fixed", though he does suggest the following workaround:

leoGlobals.py uses locale.getpreferredencoding to define getpreferredencoding if locale.getpreferredencoding exists (it is new in Python 2.3alpha).  Otherwise, Leo uses the code copied from the 2.3a2 version of Python to define getpreferredencoding.  Either way, leoGlobals.py now defines getpreferredencoding and Leo uses getpreferredencoding rather than getdefaultlocale.</t>
<t tx="ekr.20071028032929.621">This adds http:\\ to url's if needed.</t>
<t tx="ekr.20071028032929.622">I had completely misunderstood __del__ methods!  __del__ methods _disable_ the gc's ability to collect circular garbage (!!) and so __del__ methods will _never_ be called (!!)

BTW, when deleting an entire Leo window Leo calls various destroy methods to unlink items.  This allows the garbage collector to collect all data structures.  Because of unlimited undo only these destroy methods have the potential for creating "real" garbage.</t>
<t tx="ekr.20071028032929.623"></t>
<t tx="ekr.20071028032929.624"></t>
<t tx="ekr.20071028032929.625"></t>
<t tx="ekr.20071028032929.626">- tangle.scanAllDirectives was not setting self.encoding when handling @encoding.
- tangle.scanAllDirectives wasn't scanning the @encoding line properly.
- fixed crashers in Tangle and Untangle logic.</t>
<t tx="ekr.20071028032929.627">After opening the Python window the call to tkFont() threw a (caught) exception on every call to frame.setTabWidth.  The fix was to add the optional root param.</t>
<t tx="ekr.20071028032929.628"></t>
<t tx="ekr.20071028032929.629">This makes the output look much better.  Only time will tell whether cvs likes this way...</t>
<t tx="ekr.20071028032929.630">- Added comments param to handleLinesFollowingSentinel.

- Hacked readLinesToNextSentinel so it accepts the first line even if it looks like a sentinel.
  This won't handle all cvs conflicts perfectly, but perfection isn't possible anyway...</t>
<t tx="ekr.20071028032929.631">- wrote readLinesToNextSentinel and handleLinesFollowingSentinel.
- added optional nextLine param to scanText to handle look-ahead.</t>
<t tx="ekr.20071028032929.632">I spent several days on a false start. My first try was to create a new version
of scanText called scanGnxText. This dispatched routines to handle 4.x
sentinels. There were several big problems with this approach:

- Much of scanGnxText was identical to scanText.

- Using separate routines to do the work meant that ivars had to be used for
communication between the routines rather than the local vars.

- Instead of using recursion to handle nested sentinels, scanGnxText had to
manage explicit stacks. This was so ugly...

This morning I threw in the towel. Rather than do all this extra work in the
name of "elegance" I simply added a few new cases to the old scanText. The
result is that all the old code works exactly as before, and the new code gets
to use the old tested code.

While I was at it, I made the following changes:

- Renumbered the constants in leoAtFile. Some of these numbers were duplicates,
which might have caused problems, though apparently it did not.

- Removed the "implicit child index" logic from scanText. This was never used.

BTW, the write logic always used the old logic as a starting point. The present
4.0 write code was up and running in a couple of hours.

Other notes:

- Setting app().use_gnx to true enables two commands in the Read/Write menu
that test the new code. I don't recommend doing this: there are plenty of
problems yet... app().use_gnx will be false for all 3.x releases.

- The present code uses id(v) as a dummy global node index (gnx). This will be
changed very soon.

- Still to do: the code in leoFileCommands to read and write "mark" elements.
This isn't essential, and without this no marks will be remembered in derived
files. I must also handle the process of telling Leo the user's cvs id. This
will probably involve reading leoId.txt.</t>
<t tx="ekr.20071028032929.633"></t>
<t tx="ekr.20071028032929.634">I had forgotten to compile leo.nsi.</t>
<t tx="ekr.20071028032929.635">The children of this node are a test of this.</t>
<t tx="ekr.20071028032929.636"></t>
<t tx="ekr.20071028032929.637"></t>
<t tx="ekr.20071028032929.638"></t>
<t tx="ekr.20071028032929.639"></t>
<t tx="ekr.20071028032929.640"></t>
<t tx="ekr.20071028032929.641"></t>
<t tx="ekr.20071028032929.642"></t>
<t tx="ekr.20071028032929.643"></t>
<t tx="ekr.20071028032929.644"></t>
<t tx="ekr.20071028032929.645"></t>
<t tx="ekr.20071028032929.646"></t>
<t tx="ekr.20071028032929.647"></t>
<t tx="ekr.20071028032929.648"></t>
<t tx="ekr.20071028032929.649"></t>
<t tx="ekr.20071028032929.650"></t>
<t tx="ekr.20071028032929.651"></t>
<t tx="ekr.20071028032929.652"></t>
<t tx="ekr.20071028032929.653"></t>
<t tx="ekr.20071028032929.654">Changed redraw_now to force_redraw in tree select routines.</t>
<t tx="ekr.20071028032929.655"></t>
<t tx="ekr.20071028032929.656"></t>
<t tx="ekr.20071028032929.657">This allows time to be expressed as local time or gmttime.</t>
<t tx="ekr.20071028032929.658"></t>
<t tx="ekr.20071028032929.659"></t>
<t tx="ekr.20071028032929.660"></t>
<t tx="ekr.20071028032929.661"></t>
<t tx="ekr.20071028032929.662"></t>
<t tx="ekr.20071028032929.663">These were long-standing bugs.</t>
<t tx="ekr.20071028032929.664"></t>
<t tx="ekr.20071028032929.665"></t>
<t tx="ekr.20071028032929.666">This makes the file name easier to see in the Windows task bar.
</t>
<t tx="ekr.20071028032929.667">This fixes several bugs.</t>
<t tx="ekr.20071028032929.668"></t>
<t tx="ekr.20071028032929.669">Every call to v.unjoinNode was calling c.clearAllVistied.

Fixing this bug will allow me not to use inodes &amp; locations for the foreseeable future.</t>
<t tx="ekr.20071028032929.670"></t>
<t tx="ekr.20071028032929.671"></t>
<t tx="ekr.20071028032929.672"></t>
<t tx="ekr.20071028032929.673"></t>
<t tx="ekr.20071028032929.674">scanColorDirectives now returns self.language.</t>
<t tx="ekr.20071028032929.675"></t>
<t tx="ekr.20071028032929.676"></t>
<t tx="ekr.20071028032929.677"></t>
<t tx="ekr.20071028032929.678"></t>
<t tx="ekr.20071028032929.679">@nocolor

1. Put customizeLeo.py on cvs.  I don't particularly see why this file should be much more dangerous than any other file.

2. Remove the @ignore directive from the ancestor of @file customizeLeo.py.

3. Remove the warning when customizeLeo.py is written.  However, I shall _insert_ a lock that prevents customizeLeo.py from being written unless use_customize_leo_dot_py = 1 in leoConfig.txt.

Leo will write a message to the log if customizeLeo.py is dirty but was not written because of the setting in leoConfig.txt.
</t>
<t tx="ekr.20071028032929.680"></t>
<t tx="ekr.20071028032929.681"></t>
<t tx="ekr.20071028032929.682">Simplified and regularized hooks:

- replaced "event1" and "event2" hooks with 'regular' hooks.
	* Much easier to understand.
- added "iconrclick" hooks.
- added "bodyrclick" hooks.
- added "dragging" hooks.
	* These are called when drag hook called while already dragging.
- added "hyperenter" and "hyperleave" hooks.
	* These only fire if use_hyperlinks = 1 in leoConfig.txt.
- removed "activate" and "deactivate" hooks.
	* These were not reliable.
- almost all hooks have c,v arguments now.
- "command" hooks now return "undo" and "redo" rather than "cantundo" and "cantredo"

Improved code:

- improved the tracing of hooks in customizeLeo.py.
- the tracing code also checks to make sure that most hooks have c,v keywords.
- created es_event_exception().
- put all event handlers in try/except blocks that call es_event_exception on errors.</t>
<t tx="ekr.20071028032929.683">The fix was to set the hand cursor in </t>
<t tx="ekr.20071028032929.684">v.OnEndDrag can be called even though tree.dragging is false.  </t>
<t tx="ekr.20071028032929.685"></t>
<t tx="ekr.20071028032929.686">replaced c.contractVnode by v.contract.
replaced c.expandVnode by v.expand.

This was mostly done earlier, but wasn't done completely.  Not doing so completely caused exceptions in the promote, demote and import commands.</t>
<t tx="ekr.20071028032929.687"></t>
<t tx="ekr.20071028032929.688">added raw=1 to all calls to config.get in leoConfig.py.</t>
<t tx="ekr.20071028032929.689"></t>
<t tx="ekr.20071028032929.690"></t>
<t tx="ekr.20071028032929.691"></t>
<t tx="ekr.20071028032929.692"></t>
<t tx="ekr.20071028032929.693">This can be useful when clones are in the range of different @path directives.</t>
<t tx="ekr.20071028032929.694">Dirty bits are kept in tnodes, so setting/clearing a dirty bit in a node v does the same in all nodes joined to v.

Also, made setDirtyDeleted equivalent to setDirty, which means that setAncestorsOfClonedNodesInTreeDirty is no longer used.  This is a bizarre routine:  I have no idea why it should be needed.</t>
<t tx="ekr.20071028032929.695"></t>
<t tx="ekr.20071028032929.696"></t>
<t tx="ekr.20071028032929.697">Previously saving a new file did not result update the Recent Files menu.

Created frame.updateRecentFiles routine and called it from openWithFileName and all Save routines.</t>
<t tx="ekr.20071028032929.698">In the preferences dialog the close button is now equivalent to the Cancel button.

While I was at it, I eliminated OnClosePrefsFrame.  The OnCancel routine works just fine.
</t>
<t tx="ekr.20071028032929.699">There was a typo in the documentation of chapter 8, "About hooks". In the hook table the "when called" column of "headkey1" and "headkey2" says "before/after *body* keystrokes", instead of "headline keystrokes".

Fixed in LeoPy.leo, LeoDocs.leo and on the web site.</t>
<t tx="ekr.20071028032929.700">These were easy to do and they may be of real help to some people in some situations.</t>
<t tx="ekr.20071028032929.701">I have just uploaded a major improvement to Leo's expand/contract routines.
This came about as the result of a request by Travers A. Hough.

His comment was that it would be better to have the Expand To Level n commands
work only on the presently selected outline: "Having Expand" commands that work
only on a suboutline...would most likely be what the programmer really wanted."
Indeed, this is correct. I'm not sure why I didn't see this earlier.

As I played with the expand/contract commands it gradually became apparent that
the new way of doing things makes a number of existing or requested commands
obsolete:

1. I redefined Expand To Level 1 to mean contract the presently selected
outline. So there is no need for a Contract Present Node command (!)

2. Expand To Level 2 now does what the requested Expand Present Node command
would have done. Moreover, this command eliminates the need for the old
Contract Subheads command!

3. Expand to Level 3 now does what the old Expand Subheads command did!

4. With all these commands now gone (without sacrificing anything!) it became
possible to consolidate the Expand and Contract submenus into a single
Expand/Contract submenu. This is a pretty big win, in fact, because it shows in
one place all the shortcuts that cause expansion and contraction.

As requested, I changed the Contract All command to select the topmost ancestor
of the presently selected node if that node becomes invisible as the result of
the contraction. This eliminates what was in fact quite irritating behavior.

It is truly unusual that a feature request should spark both wholesale
simplifications and an increase in power, and that is what has happened. In
this area, I think, as perhaps in no other, Leo's way of handling outlines is
now clearly superior to how the great MORE outliner worked.</t>
<t tx="ekr.20071028032929.702"></t>
<t tx="ekr.20071028032929.703"></t>
<t tx="ekr.20071028032929.704"></t>
<t tx="ekr.20071028032929.705"></t>
<t tx="ekr.20071028032929.706">In other words, the Pressing the Enter key in the Find panel executes the Find Next command.
</t>
<t tx="ekr.20071028032929.707"></t>
<t tx="ekr.20071028032929.708"></t>
<t tx="ekr.20071028032929.709">These are just conveniences, so the user doesn't have to check for save, saveas and saveto command hooks.</t>
<t tx="ekr.20071028032929.710"></t>
<t tx="ekr.20071028032929.711"></t>
<t tx="ekr.20071028032929.712"></t>
<t tx="ekr.20071028032929.713"></t>
<t tx="ekr.20071028032929.714">In the unusual case that a language has no single-line comment delimiter, Leo will remove the block delimiters from the headline text in node sentinels.  createNthChild must take this into account by doing a second comparison of headlines if the normal comparison fails.  If the second comparison of headlines succeeds we assume that we should use the headline from the outline instead of the derived file.  I believe some kind of kludge like this will also be required for 4.0.

This is kludgy, and I don't know what else to do.</t>
<t tx="ekr.20071028032929.715">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1806338
By: stwerff
Open Discussion 12/23/02

There seems to be a problem to find the correct vnode when there is a double
comment given:

vnode not found in outline: exp_definitions*)

The finish comment seems to interfere with the @+node:

(*@+node:1::exp_definitions*)

Jurjen

</t>
<t tx="ekr.20071028032929.716">@nocolor

I see. This is an interesting hole. This problem only arises with languages such as html that have
paired comment delims _and_ that have no single-line comment delimiter. 

The only solution seems to me to remove either just the closing comment delim or both comment
delims from the headline text of +-node sentinels. Do you agree? I'll make the change today.
</t>
<t tx="ekr.20071028032929.717"></t>
<t tx="ekr.20071028032929.718">leoFileCommands.put was recently changed, and the following code was accidentally omitted:

	elif self.outputString != None: # Write to a string
		self.outputString += s</t>
<t tx="ekr.20071028032929.719">Re-enabled the following code in
&lt;&lt; set path to the full pathname of a temp file using ext &gt;&gt;

a.openWithFileNum += 1</t>
<t tx="ekr.20071028032929.720">This allows Leo to be used with a black background.</t>
<t tx="ekr.20071028032929.721">changed s.self to s,self in tangle.os.</t>
<t tx="ekr.20071028032929.722">The error reporting code is still highly experimental.  In particular, encoding errors in headlines may generate many redundant messages as sentinel lines are written.

Here is what I did:

Phase I: get body text working with utf-8.
	done: accept @+leo,encoding=&lt;the_encoding&gt; when reading derived files.
	done: always use &lt;?xml version="1.0" encoding="UTF-8"&gt;
	done: Read and write .leo files using utf-8 encoding. (It's always been this way).
	done: convert body text to unicode when reading .leo files.
	done: ensure unicode in body key handler.

Phase II: get find/change working with utf-8.
	done:  don't call repr on unicode strings in es().
	done: convert from utf-8 to unicode when reading find/change params in leoConfig.txt
	done: encode unicode to utf-8 before writing find/change params in leoConfig.txt.

Phase III: support @encode.  Test with iso-8859-1 and utf-8 encodings.
	done: Colorize @encoding.
	done: Recognize @encoding in various scanDirectives routines.
	done: Add self.encoding ivars to atFile and Tangle classes.
	done: Write -encoding=x. in @+leo header
	done: Write derived files using atFile.self.encoding
	done: Use unicode for all headline text.
	done: Read derived files using atFile.self.encoding.
	done: Add leo_file_encoding to leoFileCommands class.
	done: Initialize leo_file_encoding when reading .leo file
	done: Use leo_file_encoding when reading tnode and vnode text.
	done: Use leo_file_encoding when writing tnode and vnode text.
	done: Create config.new_leo_file_encoding.
	done: Create config.default_derived_file_encoding.
	done: Use default_derived_file_encoding when writing derived files.
	done: Use new_leo_file_encoding when creating new .leo files.

Phase IV: Use unicode everywhere
	done: @encoding on import/export
	done: @encoding on tangle/untangle

Phase V: cleanup
	done: replace fnW by fn.  replace pathW by path.
	done: assert unicode type when writing derived files.
	done: remove unused unicode utilities
	done: remove or replace all instances of xml_version_string.
	done: create toUnicode and toString utils.
	done: change test+unicode to toUnicode
	done: change test+encode to toString
	done: create isValidEncoding
	- better error reporting</t>
<t tx="ekr.20071028032929.723">I don't believe there is a great need for other encodings in leoConfig.txt and I don't plan to support anything but utf-8 encoding in leoConfig.txt.</t>
<t tx="ekr.20071028032929.724"></t>
<t tx="ekr.20071028032929.725"></t>
<t tx="ekr.20071028032929.726">The fix was to set true = 1 ; false = 0 in leoGlobals.py.</t>
<t tx="ekr.20071028032929.727"></t>
<t tx="ekr.20071028032929.728">This corrects a hang in the Open With command.
</t>
<t tx="ekr.20071028032929.729"></t>
<t tx="ekr.20071028032929.730"></t>
<t tx="ekr.20071028032929.731"></t>
<t tx="ekr.20071028032929.732">@ Please add "event=event" to the parameter list when calling handleLeoHook() from event handlers. 

I'm trying to add a menu item to the popup menu and am trying to use "event1"
for "headPopup" to do so.

I need to replace the OnPopup method with my custom method.  But I find that
I need the event object in order to do so.  However, the calls to handleLeoHook
(in event handler methods) do not pass the event object.

It seems like a good idea to pass the event as one of the keywords for event1
and event2.</t>
<t tx="ekr.20071028032929.733"></t>
<t tx="ekr.20071028032929.734"></t>
<t tx="ekr.20071028032929.735">It's actually working, but it's work is being undone by a previous binding.</t>
<t tx="ekr.20071028032929.736"></t>
<t tx="ekr.20071028032929.737">This was done in c2py.py, leoAtFile.py and leoColor.py.

I actually think this was foolish to do, regardless of how much "cleaner" the code looks.  The problem is that it is not at all easy to test.  I think this kind of thing should wait until has a full regression testing suite.</t>
<t tx="ekr.20071028032929.738">What I did:

- es, trace &amp; trace_tag take a variable number of args.
- es, trace &amp; trace_tag convert to string using repr as needed.
- move init_sherlock to leoGlobals where it belongs.
- init_sherlock now takes an echo param.
- only trace_tag takes a "tracepoint" arg.</t>
<t tx="ekr.20071028032929.739">redoMenuLabel and undoMenuLabel must be initialized in the ctor, _not_ in clearUndoState.
</t>
<t tx="ekr.20071028032929.740">The self.oldcursor logic wasn't working reliably.
</t>
<t tx="ekr.20071028032929.741"></t>
<t tx="ekr.20071028032929.742">In most case the "x2" hook is always called, whether or not the "x1" hook overrides the default code.

The only time this can possibly make a difference is when the "x1" hook actually does override, so the issue of whether or not this is a good idea is almost always moot.</t>
<t tx="ekr.20071028032929.743">@nocolor

The following are real problems that should be cleaned up:

c:\prog\leoCvs\leo\leoApp.py:293: Object (d) has no attribute (testDialogs)

	(done) remove app.testDialogs

c:\prog\LeoCVS\leo\leoFileCommands.py:342: No class attribute (getCollapsedOpenTag) found

	(done) change getCollapsedOpenTag to getOpenTag

c:\prog\LeoCVS\leo\leoFileCommands.py:525: Catching a non-Exception object (BadLeoFile)
c:\prog\LeoCVS\leo\leoFileCommands.py:583: Catching a non-Exception object (BadLeoFile)

	(done) derive class BadLeoFile from Execption

(done) c:\prog\LeoCVS\leo\leoUndo.py:134: No class attribute (redoMenuLabel) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:138: No class attribute (undoMenuLabel) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:320: No class attribute (commands) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:394: No class attribute (debug_print) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:423: No class attribute (new_undo) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:424: No class attribute (debug) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:430: No class attribute (old_mem) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:433: No class attribute (new_mem) found

	These arise because we refer to both self.x and u.x.
	to do: change self.x to u.x.

c:\prog\LeoCVS\leo\leoCompare.py:425: No class attribute (makeWhitespaceVisible) found

(done) changed self.makeWhitespaceVisible to cmp.makeWhitespaceVisible</t>
<t tx="ekr.20071028032929.744"></t>
<t tx="ekr.20071028032929.745"></t>
<t tx="ekr.20071028032929.746"></t>
<t tx="ekr.20071028032929.747"></t>
<t tx="ekr.20071028032929.748">We must do

exec s in {}

NOT

exec s in __builtins__

Passing __builtins__ to exec is the _worst possible_ thing to do, because it pollutes the only truly global namespace FOREVER.</t>
<t tx="ekr.20071028032929.749"></t>
<t tx="ekr.20071028032929.750"></t>
<t tx="ekr.20071028032929.751"></t>
<t tx="ekr.20071028032929.752"></t>
<t tx="ekr.20071028032929.753">What I did:
	
- added self.trace ivar to trace write logic.

- changed the following sections of putCodePart:

1. &lt;&lt; put the line &gt;&gt;
	Buffered characters to make tracing easier. (reduces calls to self.os)
	Don't write trailing indentation if not writing sentinels.

2. &lt;&lt; handle @others &gt;&gt;
	Skip the newline after @others if we aren't putting sentinels.
</t>
<t tx="ekr.20071028032929.754">The present code properly handles undo/redo for operations that copy trees, but copying trees itself causes problems for further undoes.  I've disabled further undos, as was done previously, but this is a pity.

To fix this, we may have to hack on the beads to indicated that a copy has been made.  No doubt about it: copying trees is tricky.</t>
<t tx="ekr.20071028032929.755"></t>
<t tx="ekr.20071028032929.756">This bug was created recently by the new underline/realMenuName logic.  We must not set the undo/redoRealMenuName ivars in clearUndoState: that should only be done when actually setting the menu names.</t>
<t tx="ekr.20071028032929.757"></t>
<t tx="ekr.20071028032929.758">The fix was made to atFile.scanAllDirectives() and leoGlobals.scanDirectives()
tangle.scanAllDirectives() was not affected.

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):</t>
<t tx="ekr.20071028032929.759">Completed a major revision of the menu handling code to handle underlined menus.  The new code has a chance of working with translated menus.


What I did:

- Added app()./frame.setRealMenuNamesFromTable() convenience methods.
- Use underline param to specify underlined characters in menu names.
- Translate &amp; to underline index before removing &amp;.
- Alt-E conflicts with Edit menu: changed to Alt+Shift+E
- Added f.get/setMenu (canonicalize menu names)
- Used realMenuNames for undo/redo.
- Disabled Can't Undo, Can't Redo.
</t>
<t tx="ekr.20071028032929.760"></t>
<t tx="ekr.20071028032929.761"></t>
<t tx="ekr.20071028032929.762">The lambda functions for callbacks were not working properly.  While I was at it I simplified the code</t>
<t tx="ekr.20071028032929.763">The original bug report:

"The sample code to invoke idle via "Open With" does not work if leo 
is installed in a path with a blank, for example "program files/leo". 
On windows, the pathname needs to be quoted in this case."

I did not find this to be the case.  However, there were problems with the sample Open With code in customizeLeo.py and I corrected these.
</t>
<t tx="ekr.20071028032929.764">We scanning for the initial state we must make sure that i &lt; old_len and i &lt; new_len.</t>
<t tx="ekr.20071028032929.765">This was reported by David LeBlanc and fixed with major hints from Chad Netzer.
</t>
<t tx="ekr.20071028032929.766">Apparently the F4 shortcuts interferes with the Alt-F4 shortcut.</t>
<t tx="ekr.20071028032929.767">The content formerly on evisa.com, including the Leo tutorials is now on 3dtree.com.</t>
<t tx="ekr.20071028032929.768"></t>
<t tx="ekr.20071028032929.769">Use keyword params instead of synonym constants.

- import
	- removed dont_indent_refs and indent_refs synonyms.

- tangle
	- removed verbose and brief synonyms to st_dump.
	- left other flags alone: they are complex.</t>
<t tx="ekr.20071028032929.770"></t>
<t tx="ekr.20071028032929.771"></t>
<t tx="ekr.20071028032929.772">Added options for @file and @root.

The options to @root are more important (and potentially more buggy).  For the first time Leo allows you to choose whether body text in @root trees will start in code mode or doc mode by default.  Ever since I created @file trees I've regretted the choice of making doc mode the default.  Just last week I realized I'm not stuck with that old choice.

This is a little tricky, so please pay attention :-)

1. @root-doc filename and @root-code filename specify that body text is assumed to start in doc mode or code mode respectively.  The options (-doc and -code) must follow @root immediately with no intervening whitespace.  In effect, @root-code and @root-doc are two new directives.  (They aren't syntax colored yet: they will be today or tomorrow.)

2. These @root options override the new at_root_bodies_start_in_doc_mode option in leoConfig.py.  This option affects only @root trees without options.  Such "plain" @root trees are now deprecated, which only means that it is now better style to use either @root-code or @root-doc.  The reason is simple: the meaning of plain @root trees will depend on the at_root_bodies_start_in_doc_mode option, and that isn't good.

3. By default, at_root_bodies_start_in_doc_mode = 1 for compatibility for old @root trees.  I actually don't think this option is good for much; I created it before I created @root-doc and @root-code, and I decided it wouldn't hurt to leave it in.  Anyway, you now have complete flexibility about how @root works, and in particular you can make @root work just like @file.

Only minor changes were made to the Tangle and Untangle code, and the new code appears to work.  However, it has not been extensively tested.  I would like to get 3.9.1 out the door this week so the latest "official" version of Leo won't crash when PIL or tkIcon are not present.  So please report any problems with the new code immediately.</t>
<t tx="ekr.20071028032929.773">Untangle was warning about a missing section if the section had only an @doc part.</t>
<t tx="ekr.20071028032929.774">There is a good reason why os.path.normpath does not mess with slashes on Linux, and there is no reason to create another routine to do so.
</t>
<t tx="ekr.20071028032929.775"></t>
<t tx="ekr.20071028032929.776"></t>
<t tx="ekr.20071028032929.777">Used .gif file so transparency info used by tkIcon code.
Rewrote tkIcon code so it doesn't try to resize the icon.
Created custom 16x16 LeoWin.gif.</t>
<t tx="ekr.20071028032929.778">The code now uses the list leoConfig.ivars to generate exec statements that do the work.  This makes it possible to add ivars to leoConfig.ivars without changing code in leoConfig.py.
</t>
<t tx="ekr.20071028032929.779">It might be beter if the Suboutline Only and Node Only checkboxes were Radio buttons, but then we would need yet another radio button to say "Search Entire Outline", which is a bit pedantic.

Note that Node Only takes precedence over Suboutline Only if they are both checked.</t>
<t tx="ekr.20071028032929.780">This works just like the Flatten Outline command except it writes only headlines.</t>
<t tx="ekr.20071028032929.781"></t>
<t tx="ekr.20071028032929.782">The code that checks whether leading and trailing have been supplied must check against None.  Otherwise, a leading or trailing value of zero will cause middle_lines to be miscalculated.</t>
<t tx="ekr.20071028032929.783">The commands now remember the scroll position so the screen doesn't hope around.</t>
<t tx="ekr.20071028032929.784"></t>
<t tx="ekr.20071028032929.785">Created the long-overdue convertUnicodeToString utility.</t>
<t tx="ekr.20071028032929.786"></t>
<t tx="ekr.20071028032929.787"></t>
<t tx="ekr.20071028032929.788">This is called from atFile.scanAllDirectives, tangle.scanAllDirectives and utils_rename.</t>
<t tx="ekr.20071028032929.789"></t>
<t tx="ekr.20071028032929.790">@ test

@nocolor

@ test

@color</t>
<t tx="ekr.20071028032929.791">This may or may not solve a crash under Python 2.1.</t>
<t tx="ekr.20071028032929.792"></t>
<t tx="ekr.20071028032929.793">Leo now ensures that u.oldText and u.newText are set to None when using the new undo scheme.  This means that Python now has a chance of reclaiming much more memory.</t>
<t tx="ekr.20071028032929.794"></t>
<t tx="ekr.20071028032929.795"></t>
<t tx="ekr.20071028032929.796">Leo now forces a full update and redraw if there is a mismatch between the expected value and the result calculated from the Tk.Text widget.  This is safe, and won't happen often.</t>
<t tx="ekr.20071028032929.797">This was making it impossible to specify trailing newlines.  It also seems to have helped undo.</t>
<t tx="ekr.20071028032929.798"></t>
<t tx="ekr.20071028032929.799"></t>
<t tx="ekr.20071028032929.800"></t>
<t tx="ekr.20071028032929.801"></t>
<t tx="ekr.20071028032929.802"></t>
<t tx="ekr.20071028032929.803"></t>
<t tx="ekr.20071028032929.804">We can't use after_idle because that completely overloads the system.  On my machine a delay of 500-1000 msec between calls would be sufficient to handle most "periodic" tasks.</t>
<t tx="ekr.20071028032929.805">It's not perfect, and it will do for now.</t>
<t tx="ekr.20071028032929.806"></t>
<t tx="ekr.20071028032929.807"></t>
<t tx="ekr.20071028032929.808">Noweb section refs and defs _are_ valid in cweb mode!
Allow LaTex coloring in cweb @space, @* and @** doc parts.</t>
<t tx="ekr.20071028032929.809"></t>
<t tx="ekr.20071028032929.810">Cweb prefs panel setting was overriding @language python (!)</t>
<t tx="ekr.20071028032929.811"></t>
<t tx="ekr.20071028032929.812">This makes it much easier to pass parameters to hooks.
</t>
<t tx="ekr.20071028032929.813"></t>
<t tx="ekr.20071028032929.814"></t>
<t tx="ekr.20071028032929.815"></t>
<t tx="ekr.20071028032929.816">@language pascal
@color

private
uses</t>
<t tx="ekr.20071028032929.817"></t>
<t tx="ekr.20071028032929.818">We can only suppress redraws in undo/redo under very special conditions, namely that we are undoing typing in the same node.

The recent code will leave the screen in the wrong state!</t>
<t tx="ekr.20071028032929.819"></t>
<t tx="ekr.20071028032929.820">Eliminated the self.delim ivar.  This can't be set correctly when coloring incrementally.

Realized that full, non-incremental coloring must _always_ be done when switching nodes.  Even if we move from one cloned node to another, the context can be different:  different @color, @nocolor, @language and @comment directives may be in effect.

Used incremental syntax coloring when undoing.  This speed up undo tremendously.</t>
<t tx="ekr.20071028032929.821"></t>
<t tx="ekr.20071028032929.822"></t>
<t tx="ekr.20071028032929.823"></t>
<t tx="ekr.20071028032929.824"></t>
<t tx="ekr.20071028032929.825">The principle is this: people should see the scripts they are executed.
</t>
<t tx="ekr.20071028032929.826"></t>
<t tx="ekr.20071028032929.827"></t>
<t tx="ekr.20071028032929.828"></t>
<t tx="ekr.20071028032929.829"></t>
<t tx="ekr.20071028032929.830"></t>
<t tx="ekr.20071028032929.831"></t>
<t tx="ekr.20071028032929.832">@color

@ See the actual code in the child node for complete notes.</t>
<t tx="ekr.20071028032929.833">@ frame.doCommand and frame.OnMenuClick now set app.log, so top() will be reliable after any command is executed.

Note 1: The value of top() may change during a new or open command, which may change the routine used to execute the "command1" and "command2" hooks.  This is not a bug, and hook routines must be aware of this fact.
@c

def top():
	
	"""Return the commander of the topmost window"""
	
	# Warning: may be called during startup or shutdown when nothing exists.
	try:
		return app.log.commands
	except:
		return None</t>
<t tx="ekr.20071028032929.834"></t>
<t tx="ekr.20071028032929.835"></t>
<t tx="ekr.20071028032929.836">The old code jumped through hoops not to duplicate code.  The new code just uses a new doAtKeyword routine.</t>
<t tx="ekr.20071028032929.837">The key invarient:  frame.menus contains _untranslated_ names.  The translated names are used only in the label param to the Tk.menu routines.</t>
<t tx="ekr.20071028032929.838">The menu hooks make it easy to customize menus.

The open hooks make it easy to perform custom actions when opening already-existing files.</t>
<t tx="ekr.20071028032929.839">Finished convenience routines.

Used createNewMenu to create Leo's menus.</t>
<t tx="ekr.20071028032929.840"></t>
<t tx="ekr.20071028032929.841">This will allow users to create new menus without creating new ivars, an important generalization.

self.menus["top"] represents the top-level menu.  All other menus are represented by their menu name.</t>
<t tx="ekr.20071028032929.842">This is long overdue:

- put the entire command in a try: except: block.
- eliminates the need for return "break"
- provides the natural place for hooks.

It was quite easy now that we have createMenuEntries.</t>
<t tx="ekr.20071028032929.843">At present, only the start1, start2 and end1 hooks are handled, and many more could be added easily.</t>
<t tx="ekr.20071028032929.844"></t>
<t tx="ekr.20071028032929.845"></t>
<t tx="ekr.20071028032929.846"></t>
<t tx="ekr.20071028032929.847"></t>
<t tx="ekr.20071028032929.848">This was almost too easy :-)</t>
<t tx="ekr.20071028032929.849"></t>
<t tx="ekr.20071028032929.850">Leo no longer massages comments when importing Java files.

There was a bug in massageBody that prevented text from being undented properly.  There was a bug in find_line_start (!!) that caused the start of the _previous_ line to be found if s[i] was a newline.  It's amazing that these bugs were undiscovered for so long.

Treat interface like class.</t>
<t tx="ekr.20071028032929.851">It was moving past the present line if the s[i] was a newline.

This caused problems in the Java scanner, and could also cause problems in other places.</t>
<t tx="ekr.20071028032929.852"></t>
<t tx="ekr.20071028032929.853">The trailing @ in @q@ "doubles" the first @ in a sentinel, so putSentinel should not do this, and sentinelKind needs no special code to test for sentinels.

The tcweb.py script tests cweb files.  Invoke as follows:

python tcweb.py file1 file2...</t>
<t tx="ekr.20071028032929.854">@ What I did:
	
- Changed g to geom or glob.
- Removed print_stack.
- Moved alert, handleLeoHook &amp; unloadAll to leoUtils.
- Moved all leoUtils routines into leoGlobals.py.
- Removed all instances of "from leoUtils import *"
- Removed "script functions" from leo.py: getCommands, topCommands, topCommand.
	These are no longer used anywhere in the code.
- Made the prolog_xxx constants ivars of leoApp.
- Made language_delims_dict and language_extension_dict ivars of leoApp.

I have decided to leave the present scheme pretty much in place,
except to move the variables in leoGlobals.py to leoApp.py.

This will allow us to say the following:
	
1. any function f() is defined in leoGlobals.py.
2. any variable v not of the form x.f is a local variable.


</t>
<t tx="ekr.20071028032929.855"></t>
<t tx="ekr.20071028032929.856"></t>
<t tx="ekr.20071028032929.857">We must double _all_ @ signs following the @q@, so, e.g., a @@color sentinel gets turned into @q@@@@@color@&gt;.

This is easy to do in putSentinel, but a bit harder to undo:

1. sentinelKind locally adjusts the string in cweb mode.
2. skipSentinelStart skips both @@ signs in cweb mode.
3. All sections in scanText that deal with variable text must change @@ to @ within that text.</t>
<t tx="ekr.20071028032929.858"></t>
<t tx="ekr.20071028032929.859">Only rarely does a routine as elegant as wrap_lines come along.</t>
<t tx="ekr.20071028032929.860"></t>
<t tx="ekr.20071028032929.861"></t>
<t tx="ekr.20071028032929.862"></t>
<t tx="ekr.20071028032929.863"></t>
<t tx="ekr.20071028032929.864"></t>
<t tx="ekr.20071028032929.865">Added return "break" to body and headline key handlers.
Added unreachable return 0 to end of findMatchingBracket.</t>
<t tx="ekr.20071028032929.866">@nocolor

This is miserable code to get just right because there are so many paths through the code.  In addition, making informative error messages is a bit tricky too.

Changes made:

1. Removed unhelpful warnings about non-existent paths.  Only errors are given now.
2. Added logic to set self.root_name if it has not already been set.  Without this, it is impossible to test for relative filenames in @root directives, and errors happen only after tangling is complete, which is quite confusing.
3. Added error messages when a "computed" file name does not exist.
4. Removed unused self.default_directory ivar from leoTangle.py.
5. Set self.tangle_directory ivar to base directory when @root node specifies a relative directory.  This is required so the later code will try to create the proper file.
6. Renamed the path_directive_creates_directories option to create_nonexistent_directories.  This makes clearer what is going on.
</t>
<t tx="ekr.20071028032929.867">The old name was too misleading.</t>
<t tx="ekr.20071028032929.868"></t>
<t tx="ekr.20071028032929.869">Leo was not warning about orphan nodes in cweb mode.

There was new code in atFile.write _not_ to check for orphan nodes in cweb mode.  I just removed the test for language=="cweb".</t>
<t tx="ekr.20071028032929.870">The present code explicitly eliminates control-T processing in headlines, which means that control-T does not switch panes when editing headline text.  Control-T _does_ switch panes in all other cases.

This appears to be another Tk bug.</t>
<t tx="ekr.20071028032929.871"></t>
<t tx="ekr.20071028032929.872"></t>
<t tx="ekr.20071028032929.873">The old code scanned the moved tree once for every parent.  The new code scans the tree only once.  This can result in a significant speedup.</t>
<t tx="ekr.20071028032929.874">This is taken from Python Cookbook.
It's not clear how useful this is with Tk programs.</t>
<t tx="ekr.20071028032929.875">1. Eliminated special-case code (putCWEB) in atFile.write code.
2. Changed directiveKind so it returns noDirective for @space and @c when language=="cweb".
3. Changed colorizer to recognize both cweb and noweb section definitions and references when language == "cweb"</t>
<t tx="ekr.20071028032929.876">Leo preserves the &lt;?xml-stylesheet...?&gt; line if it is already present in the .leo file.

Otherwise, Leo writes a &lt;?xml-stylesheet...?&gt; line only if the stylesheet option is present in the configuration file.  The stylesheet option specifies s in &lt;?xml-stylesheet s?&gt;</t>
<t tx="ekr.20071028032929.877"></t>
<t tx="ekr.20071028032929.878"></t>
<t tx="ekr.20071028032929.879">Changed find to rfind in &lt;&lt; Set headline and ref &gt;&gt;</t>
<t tx="ekr.20071028032929.880"></t>
<t tx="ekr.20071028032929.881">scanAllDirectives just about must be called on the root of the tree, so directives are recognized.  Not @first or @last though.</t>
<t tx="ekr.20071028032929.882">The aha, just concatenate a unique user id with any local timestamp.</t>
<t tx="ekr.20071028032929.883">This may complete raw cweb mode.</t>
<t tx="ekr.20071028032929.884">It appears that nobody ever used @delims in @file trees!</t>
<t tx="ekr.20071028032929.885">Only shortcut pastes worked before.</t>
<t tx="ekr.20071028032929.886"></t>
<t tx="ekr.20071028032929.887">1. Changed "c" to "." in

methodKind = choose(self.fileType==".c","functions","methods")

2. Added self.rootLine logic to add @root self.fileName when importing to @root nodes.</t>
<t tx="ekr.20071028032929.888"></t>
<t tx="ekr.20071028032929.889"></t>
<t tx="ekr.20071028032929.890">Previously, Java only had block comments, and the ending delim wasn't being removed from doc parts.</t>
<t tx="ekr.20071028032929.891"></t>
<t tx="ekr.20071028032929.892"></t>
<t tx="ekr.20071028032929.893">As usual, I am leary of changing the Untangle logic.

To be effective, the @comment directive should follow the @language directive.</t>
<t tx="ekr.20071028032929.894"></t>
<t tx="ekr.20071028032929.895"></t>
<t tx="ekr.20071028032929.896"></t>
<t tx="ekr.20071028032929.897"></t>
<t tx="ekr.20071028032929.898"></t>
<t tx="ekr.20071028032929.899">The warning for "unknown language" had an unbound var.</t>
<t tx="ekr.20071028032929.900">The new code must check for @raw and @end_raw directives.</t>
<t tx="ekr.20071028032929.901">The &lt;&lt; Set path from @file node &gt;&gt; code was assuming that v.isAtFileNode() was non-Null.  This is no longer true with @rawfile.  The traceback was:

 File "c:\prog\leoCvs\leo\leoAtFile.py", line 424, in scanAllDirectives
    name = v.atFileNodeName()
AttributeError: 'NoneType' object has no attribute 'atFileNodeName'

The correct code is:

if v.isAtFileNode():
	name = v.atFileNodeName()
else:
	name = v.atRawFileNodeName()

dir = choose(name,os.path.dirname(name),None)</t>
<t tx="ekr.20071028032929.902"></t>
<t tx="ekr.20071028032929.903"></t>
<t tx="ekr.20071028032929.904"></t>
<t tx="ekr.20071028032929.905"></t>
<t tx="ekr.20071028032929.906"></t>
<t tx="ekr.20071028032929.907"></t>
<t tx="ekr.20071028032929.908">A small convenience urgently requested.</t>
<t tx="ekr.20071028032929.909">It wasn't always completely clear when the command was complete.</t>
<t tx="ekr.20071028032929.910">atFile.directiveKind returned miscDirective on _any_ line that starts with @.</t>
<t tx="ekr.20071028032929.911">This entailed using lots of ivars for communication between routines.</t>
<t tx="ekr.20071028032929.912"></t>
<t tx="ekr.20071028032929.913"></t>
<t tx="ekr.20071028032929.914"></t>
<t tx="ekr.20071028032929.915"></t>
<t tx="ekr.20071028032929.916">A recent change was not writing language names properly (double quotes were ommitted) in the &lt;preferences&gt; element of .leo files.</t>
<t tx="ekr.20071028032929.917">The new code is much simpler and more rational than the old, without affecting the defaults that are delivered by the module.

In addition, fixed a but that was causing most new params not to be written.</t>
<t tx="ekr.20071028032929.918">This directive only applies to @root trees.  Like @silent, it inhibits untangling.</t>
<t tx="ekr.20071028032929.919">Added missing comma before the keyword.</t>
<t tx="ekr.20071028032929.920"></t>
<t tx="ekr.20071028032929.921">Another major reorganization.</t>
<t tx="ekr.20071028032929.922">This was a major reorganization.</t>
<t tx="ekr.20071028032929.923"></t>
<t tx="ekr.20071028032929.924"></t>
<t tx="ekr.20071028032929.925"></t>
<t tx="ekr.20071028032929.926">Replaced almost all calls to traceback.print_exc by calls to es_exception.</t>
<t tx="ekr.20071028032929.927">We call scanAllDirectives on the _parent_ node, so no directives are recognized in the @rawfile tree itself, and directives _are_ recognized in ancestor nodes.  atFile::writeAll has new logic that recognizes @ignore in ancestors of @rawfile nodes, but not in @rawfile nodes themselves.

Writing the file was easy; updating the screen was harder.  We must redraw the screen whenever a headline changes, regardless of whether a node is joined to another.  The reason is that we must redraw the dirty bits of ancestor @file and @rawfile nodes.</t>
<t tx="ekr.20071028032929.928"></t>
<t tx="ekr.20071028032929.929">Removed v22 var from leoApp.py.
Removed ch3 var from getCwebWord() in leoColor.py
Removed self and name args from go function in leoCompare.py.
Added from leoUtils import * and from leoGlobals import * to leoCompare.py
Removed ok from onCompareFiles in leoCompare.py
Removed c from setAncestorsOfClonedNodesInTreeDirty in leoNodes.py
Removed import leoPrefs from leoAtFile.py
Moved unused assignment to top into #if 0 block in open in leoFileCommands.py
Removed unused name var from scanPHPText in leoImport.py
Bug fix: changed tangle_state to self in several places in root_attributes.__repr__
Bug fix: converted represent_print_bits to a method
	(It was indented as a method under class root_attributes)
Removed language,single_comment_string,start_comment_string,end_comment_string params from st_enter in leoTangle.py.
Bug fix (Major?): restored code to return part number at end of st_enter.
Latent bug fix: changed self.font to font in tree.setLineHeight.
Bug fix: all paths through idle_body_key and idle_head_key now return "break"
Removed topMenu var from tree.OnPopup.
Removed config var from leoFrame.__init__
Latent bug fix: changed editHeadlineMenu to self.editHeadlineMenu in leoFrame.__init__ 
Real bug fix: changed editHeadlineMenu to self.editHeadlineMenu in leoFrame.__del__
	(This affects how storage is freed)
Removed interp var from leoPyShellMain.</t>
<t tx="ekr.20071028032929.930"></t>
<t tx="ekr.20071028032929.931">Asumming that python and tcl are installed, It shouldn't take familiarity with python to be able to use leo. I want to be able to type

leo foo

and have leo start up on a new [outline] named foo.leo, or open the existing one if it's there.</t>
<t tx="ekr.20071028032929.932"></t>
<t tx="ekr.20071028032929.933"></t>
<t tx="ekr.20071028032929.934">Leo now does the following: 

1. Leo checks all characters that are entered (via typing or via paste) into headline and body text to see whether they can be represented in the encoding specified in leoConfig.txt. 

2. Leo issues a message and _disallows_ the entry of the character if it can't be represented in the encoding specified in leoConfig.txt. 

In practice, this draconian behavior shouldn't be too much of a nuisance, at least temporarily. Note that _all_ characters are valid in UTF-8 encoding, so the present version of Leo will allow you to specify all characters if you must. But the Latin-1 (iso-8859-1) encoding, being a one-byte encoding, limits you to at most 256 separate characters. 

In 3.8 I plan to allow you to use _all_ Unicode characters, regardless of encoding, by using so-called character references.  This will require some reorganization of the present code, so I don't want to delay 3.7 to handle them.</t>
<t tx="ekr.20071028032929.935">It is much more convenient to set these to proper defaults than it would be for the callers to do so.  Nevertheless, perhaps the caller should do so, but not now...</t>
<t tx="ekr.20071028032929.936"></t>
<t tx="ekr.20071028032929.937">This makes the present code compatible with Python 2.1.</t>
<t tx="ekr.20071028032929.938">I needed this clarification.</t>
<t tx="ekr.20071028032929.939">&gt; # Tk always uses utf-8 encoding.

You may get that impression, but it is slightly wrong. It is more
reliable if you pass Unicode strings to Tk, instead of UTF-8 encoded
byte strings.

For a byte string, Tk will guess the encoding. If it looks like UTF-8,
it is taken treated UTF-8. Otherwise, it is treated as the locale's
encoding. Unfortunately, if you ever manage to mix the two, you get
byte salad that you can't ever chew. By using Unicode strings to
interface with Tk only, you can avoid those problems.

&gt; print `s`,"tk"
&gt; s = s.encode("utf-8") # result is a string.
&gt; print `s`,"utf-8"
&gt; s = s.decode(xml_encoding) # result is unicode.
&gt; s = s.encode(xml_encoding) # result is a string.

Since xml_encoding is iso-8859-1, you are making a mistake here. You
have UTF-8 data, but you are decoding them as Latin-1. This will
succeed, but it will give an incorrect result. It will succeed since
iso-8859-1 is an single-byte code where every byte value is valid.
That means an arbitrary byte sequence can be interpreted as Latin-1,
but for many byte sequences, the resulting string is non-sense
(mojibake, as the Japanese say).

&gt; BTW, with out the first encode/decode pair I can take exceptions in
&gt; the last encode.

Nevertheless, this is the correct processing. If you have a Unicode
object, as originally obtained from Tk, you should encode as Latin-1
using

s = s.encode("iso-8859-1")

Now, for this specific string (u'a\u0102\xdf\xc9\n'), you will get a
Unicode error. The reason is that one character (\u0102) is not
supported in Latin-1 - this encoding supports only the first 256
Unicode characters.

So, when saving this as XML, the proper representation would be

'a&amp;#x102;\xdf\xc9\n'

i.e. you'll have to use a character reference. Python 2.2 does not
support generating such text very well - you'll have to catch the
Unicode error yourself, find the offending character, encode it as a
character reference, and encode all other characters as requested.

Alternatively, you can refuse encoding a document in a certain
encoding (such as Latin-1), and fall back to UTF-8.

PEP 293 (http://www.python.org/peps/pep-0293.html) will provide a
mechanism to generate character references more conveniently - in
Python 2.3, you can specify

  s.encode('iso-8859-1',errors='xmlcharrefreplace')

HTH,
Martin</t>
<t tx="ekr.20071028032929.940">The Find Previous command could not go to previous nodes.</t>
<t tx="ekr.20071028032929.941"></t>
<t tx="ekr.20071028032929.942">It would be good to have a prefix option too.</t>
<t tx="ekr.20071028032929.943">This fix was suggested by Rich Ries.  The original report follows:

I found the culprit; it's in the node &lt;&lt; scan @@ &gt;&gt; that reads: 

k = string.find(s,self.endSentinelComment,i) 

This means it stops at the FIRST endSentinelComment, which is the "*/". The rest of the line (with the correct "*/") gets chucked. Changing the line to: 

k = string.rfind(s,self.endSentinelComment,i) 

(note the "r" before "find") seems to fix the problem. 
</t>
<t tx="ekr.20071028032929.944"></t>
<t tx="ekr.20071028032929.945"></t>
<t tx="ekr.20071028032929.946">The new code in putOpenLeoSentinel follows the example of putSentinel.</t>
<t tx="ekr.20071028032929.947"></t>
<t tx="ekr.20071028032929.948">They are simply relative representations of absolute indices, and so are basically useless.</t>
<t tx="ekr.20071028032929.949">This is a huge step, and I hope it is forward. In any event, the change is simple and reversable.

I am now considering whether to use relative node indices instead of absolute node indices.

These would have the form +n and -n.  This would eliminate the cascade of changes when nodes were inserted.  The key question is whether the read logic can handle them.  I believe it can, with just a single ivar.</t>
<t tx="ekr.20071028032929.950">Amazingly, the only change required to allow reads and writes of cloned @file nodes was to eliminate the error in updateCloneIndices.  I also fixed a bug: set self.errors = 0 in atFile.read.</t>
<t tx="ekr.20071028032929.951"></t>
<t tx="ekr.20071028032929.952">The upshot: both =pod and =cut must be preceded and followed by blank lines.  The simple tests have this.

Added perlpod hack to set_delims_from_string and changed delims to use double underscores in set_delims_from_language.</t>
<t tx="ekr.20071028032929.953">This affects @path, @file and @root code.  This is probably the code with the most separate paths in all of Leo.  I would be amazed if there were no bugs here, and it does seem mostly to work.

The getBaseDirectory utility routine implements the relative_path_base_directory option:

"!" means relative to leo.py
"." means relative to .leo file.
anything else should be absolute path.</t>
<t tx="ekr.20071028032929.954">This was just too horrible to keep straight, and bodyKeepsFocus should always be true anyway.</t>
<t tx="ekr.20071028032929.955"></t>
<t tx="ekr.20071028032929.956"></t>
<t tx="ekr.20071028032929.957"></t>
<t tx="ekr.20071028032929.958"></t>
<t tx="ekr.20071028032929.959"></t>
<t tx="ekr.20071028032929.960"></t>
<t tx="ekr.20071028032929.961"></t>
<t tx="ekr.20071028032929.962"></t>
<t tx="ekr.20071028032929.963"></t>
<t tx="ekr.20071028032929.964">It looks like the undo command does not fully undo changes to cloned nodes. Follow these steps to experience this effect: 

1) clone a node (same effect whether @file / @root or other) 
2) change the headline of either node. 
3) Edit-&gt;Undo change Headline (or ctrl-Z) 

Only the node that was changed will go back to the original headline. The undo command appears to be the problem since it does not properly undo changes to all cloned nodes' headlines. </t>
<t tx="ekr.20071028032929.965">The new code is much more elegant than the old, and does a better job of reporting errors.

One new restriction has been imposed: at most one shortcut can be associated with a command.  If one really wanted to have two shortcuts, one would have to use two different command names.

In particular, there is now only one shortcut for the Find Next command.  This should not be a problem.

It is now possible to bind the arrow keys as desired.  See the complete discussion in leoConfig.leo.

Note that all bindings are made both to the body pane and the top-level pane. This keeps things consistent.</t>
<t tx="ekr.20071028032929.966"></t>
<t tx="ekr.20071028032929.967">There was a missing comma.</t>
<t tx="ekr.20071028032929.968">It was remembering it only if set as the result of a keystroke.  The present code is redundant, but what the heck.</t>
<t tx="ekr.20071028032929.969">1. Use the present body font in frame.setTabWidth.

2. Do not call frame.setTabWidth in setCommandsIvars.  Just set the ivar.  This fixes the following bug:

"If you set the @tabwidth to something other than the Preference value, you'll
see the body displayed appropriately.  However, if you do a Ctrl-s to save the
leo file, the body is redisplayed using the Preferences setting -- of course,
clicking on another node and then back to the original node displays with the
correct tab setting again.  The redisplay on save must not go through precisely
the same body display logic."
</t>
<t tx="ekr.20071028032929.970">This was too confusing to users.</t>
<t tx="ekr.20071028032929.971"></t>
<t tx="ekr.20071028032929.972">This was done simply by opening derived files and .leo files in "wb" mode.</t>
<t tx="ekr.20071028032929.973">Essentially I moved the code that updates body text from the @+node logic to the @+body logic.

This can not be completely correct.  It breaks verbatimAfterRef

From the forum message:

I have just uploaded a major change to the logic that reads derived files. Indeed, this is the first change to that logic that has ever been made since I first invented @file trees. This change is needed to correct a bug reported by Rich Ries involving referencing a section defined in a grandchild of the referencing node. 

WARNING: although this code is similar to previous code, and passes all the tests that I can think of, you
should still consider this code experimental for a while. 

The problem: Body text was being updated as the result of @+node sentinels rather than @+body sentinels.
This was stupid, as extra @+node sentinels are often generated when no body text is generated. The result is
that the body text was being cleared. 

The fix: I simply moved the code that creates body text from the @+node logic to the @+body logic in
scanText. This was relatively straightforward, and I do have some hopes that everything will once again be rock
solid. However, the context in which this code is executing is obviously changed (that is, after all, the whole
point), so no guarantees can be given at this point. 

Everything appears to work (all files derived from this file appear to be OK), and this code must be considered experimental for now.</t>
<t tx="ekr.20071028032929.974"></t>
<t tx="ekr.20071028032929.975">At this point there are no known issues with Leo and Python 2.1.

Python 2.1 gave the following warnings when importing Leo:

Python 2.1.3 (#35, Apr  8 2002, 17:47:50) [MSC 32 bit (Intel)] on win32
Type "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import leo

leoFrame.py:197: SyntaxWarning: local name 'self' in 'createMenuBar' shadows use of 'self' as
global in nested scope 'lambda'
  def createMenuBar(self, top):

leoFrame.py:1262: SyntaxWarning: local name 'self' in 'OpenWithFileName' shadows use of 'self' as
global in nested scope
 'lambda'
  def OpenWithFileName(self, fileName):

leoColor.py:1367: SyntaxWarning: local name 'self' in 'run' shadows use of 'self' as
global in nested scope 'lambda'
  def run (self):
</t>
<t tx="ekr.20071028032929.976"></t>
<t tx="ekr.20071028032929.977"></t>
<t tx="ekr.20071028032929.978"></t>
<t tx="ekr.20071028032929.979"></t>
<t tx="ekr.20071028032929.980">It was just a matter of binding some unbound vars to defaults.</t>
<t tx="ekr.20071028032929.981">- The font settings in leoConfig.txt are not active when I open Leo. They instantly activate when opening the Edit|Set Font... dialog, without having to click anything in said dialog. Then, once the .leo file is saved, the problem goes away.</t>
<t tx="ekr.20071028032929.982"></t>
<t tx="ekr.20071028032929.983"></t>
<t tx="ekr.20071028032929.984">This code improperly removed trailing whitespace, including newlines, from the "middle" text.  Clearly this is wrong, regardless of what other effects it might have.

Affected commands are indent, dedent, extract and extract section.</t>
<t tx="ekr.20071028032929.985"></t>
<t tx="ekr.20071028032929.986">This makes it convenient to update the version number in this file properly.</t>
<t tx="ekr.20071028032929.987"></t>
<t tx="ekr.20071028032929.988">We now look through the entire tree looking for @root and @file nodes.</t>
<t tx="ekr.20071028032929.989">single quote colorized text in plain text mode.  This was due to missing parentheses.</t>
<t tx="ekr.20071028032929.990"></t>
<t tx="ekr.20071028032929.991"></t>
<t tx="ekr.20071028032929.992"></t>
<t tx="ekr.20071028032929.993"></t>
<t tx="ekr.20071028032929.994"></t>
<t tx="ekr.20071028032929.995"></t>
<t tx="ekr.20071028032929.996">CVS conflict files produce so many error messages that these errors are useless.</t>
<t tx="ekr.20071028032929.997">1. Created a new sandbox and updated CVS into it.  This did not update LeoPy.leo.
2. Opened LeoPY.leo.  There were read errors in leoImport.py and leoUtils.py.
3. Used diff on CVS to determine which routines had been added to these files.
4. Cut and pasted from updated LeoPy.leo to my "real" copy of LeoPy.leo.

This is most annoying, though it is helpful to pay attention to the added code.

The read errors themselves are useless, and I removed them.

I forgot to do an update first, so after I opened LeoPy.leo with Read Outline Only, saving all files with Write @file Nodes reverted Dave Hein's changes.  So I reloaded them from the temporary sandbox.  This is very bad.</t>
<t tx="ekr.20071028032929.998"></t>
<t tx="ekr.20071028032929.999"></t>
<t tx="ekr.20071028032929.1000"></t>
<t tx="ekr.20071028032929.1001">The code is now functionally identical to the similar code in atFile.scanAllDirectives.  The old code did not handle relative paths properly in all cases.</t>
<t tx="ekr.20071028032929.1002"></t>
<t tx="ekr.20071028032929.1003">This code crashes on some Windows systems, including my XP system.  It may work on Win98.</t>
<t tx="ekr.20071028032929.1004">This involved calling readlineForceUnixNewline instead of readline in the atFile:read logic.</t>
<t tx="ekr.20071028032929.1005"></t>
<t tx="ekr.20071028032929.1006"></t>
<t tx="ekr.20071028032929.1007"></t>
<t tx="ekr.20071028032929.1008"></t>
<t tx="ekr.20071028032929.1009"></t>
<t tx="ekr.20071028032929.1010">Only the last directive was in effect in @root trees.  The new code allows node-by-node control.</t>
<t tx="ekr.20071028032929.1011">This routine does a better job of checking the Tk version than the old code in leoApp.py</t>
<t tx="ekr.20071028032929.1012">With Tk/Tcl 8.4, the Preferences window is empty (no buttons, fields, labels). 

Tcl 8.4 complains about using "col" in the grid() calls.</t>
<t tx="ekr.20071028032929.1013">Removed calls to c.frame.canvas.focus_force() selectThreadBack/Next, selectVisBack/Next.

I have no idea why this code was there originally.</t>
<t tx="ekr.20071028032929.1014">This may or may not fix Rich Reis's problems.</t>
<t tx="ekr.20071028032929.1015">How did I ever live without this?</t>
<t tx="ekr.20071028032929.1016"></t>
<t tx="ekr.20071028032929.1017">Changed:

bitmap_name = os.path.join(self.loadDir,"Icons\LeoApp.ico") 

to:

bitmap_name = os.path.join(self.loadDir,"Icons","LeoApp.ico") 
</t>
<t tx="ekr.20071028032929.1018"></t>
<t tx="ekr.20071028032929.1019">&gt; I'd love to open a node and be in the same place as when I was last there.
</t>
<t tx="ekr.20071028032929.1020">Everything appears to be working properly.</t>
<t tx="ekr.20071028032929.1021">When starting Leo with no arguments the 'NewHeadline' node was not displayed. </t>
<t tx="ekr.20071028032929.1022">os.rename can fail on some Linux systems.</t>
<t tx="ekr.20071028032929.1023">@nocolor

The new code is as follows.  This is extremely ugly, and I'm not sure there is any workaround.  The problem is that open is really just a stand-in for C's fopen routine, and the mode param is not uniform across platforms.

@color

# 9/1/02: apparently Linux requires w+ and XP requires w.
mode = choose(sys.platform=="win32","w","w+")
cf = open(self.configFileName,mode)</t>
<t tx="ekr.20071028032929.1024"></t>
<t tx="ekr.20071028032929.1025"></t>
<t tx="ekr.20071028032929.1026">This will allow Joe Orr to keep track of hits.</t>
<t tx="ekr.20071028032929.1027">The cursor now changes to an arrow when it moves over a link.</t>
<t tx="ekr.20071028032929.1028">1.  The link now takes the user to the SourceForge download page.
2.  Called os.setcwd(app().loadDir) to set the working directory for the download.</t>
<t tx="ekr.20071028032929.1029"></t>
<t tx="ekr.20071028032929.1030">This is still not working, and I am beginning to doubt that it can be done.

Notes:

1. In Tk terminology, bitmaps are 2-color only.  Most .bmp files must be considered _photo_ files.
2. I have figured out how to read .bmp and .gif files using image create photo.
3. All tests were run using tcl/tk 8.3.4, and wm iconbitmap has never worked.</t>
<t tx="ekr.20071028032929.1031">It already works in the other panes, but the recommended code crashes tk83.dll!</t>
<t tx="ekr.20071028032929.1032"></t>
<t tx="ekr.20071028032929.1033"></t>
<t tx="ekr.20071028032929.1034"></t>
<t tx="ekr.20071028032929.1035"></t>
<t tx="ekr.20071028032929.1036"></t>
<t tx="ekr.20071028032929.1037"></t>
<t tx="ekr.20071028032929.1038">There were a couple of botches in the new code:

1. leoTangle.scanAllDirectives should not issue any warning when it sees a relative path name in the @root directive.  (Which is the only place it will see it).  This is not an error.

2. leoTangle.pathError would create an exception when called.</t>
<t tx="ekr.20071028032929.1039"></t>
<t tx="ekr.20071028032929.1040"></t>
<t tx="ekr.20071028032929.1041">Amazing!</t>
<t tx="ekr.20071028032929.1042">1. Simplified the path logic in the various scanAllDirectives routines.

2. Distinguished between absolute and relative paths.  Relative paths do _not_ set the global defaults: they are handled by the file open logic which does os.path.join(default_path,file_name).

The logic is still quite complex, and for the first time the code may be simple enough to work.</t>
<t tx="ekr.20071028032929.1043">This should end most of the confusion.</t>
<t tx="ekr.20071028032929.1044">There are several problems here:

1. os.path.join(dir,file) won't work if both dir and file contain a partial path name.  I'm not sure whether this is a bug--there is probably no behavior that makes sense in all cases.

2. Unless os.path.join works above there is no way to see whether the directory is valid.</t>
<t tx="ekr.20071028032929.1045">Removed '\r' characters when reading.  The write logic is unchanged, which makes the changes slightly safer.</t>
<t tx="ekr.20071028032929.1046"></t>
<t tx="ekr.20071028032929.1047"></t>
<t tx="ekr.20071028032929.1048">An arg got dropped out when I added a flag.</t>
<t tx="ekr.20071028032929.1049">Found several bugs while doing so.  What else is new...

Use this script as follows:

- Select the node under which you want the imported files to appear.
- Open the Python window within Leo.
- Type the following in the Python window:

import leoImport
dir = "c:/prog/test"  # or some other directory
type = ".py"  # Type of files you want to import, or None for all files.
leoImport.importFiles(dir,type)</t>
<t tx="ekr.20071028032929.1050"></t>
<t tx="ekr.20071028032929.1051"></t>
<t tx="ekr.20071028032929.1052"></t>
<t tx="ekr.20071028032929.1053"></t>
<t tx="ekr.20071028032929.1054">The new code properly deletes previous entries regardless of case or path separators.</t>
<t tx="ekr.20071028032929.1055">Changed idle_body_key and idle_head_key so the old values are also checked for Unicode strings.  I don't understand why that is needed, and after a cut and paste operation it is needed.

Also fixed Tangle's version of the os routine.

Also changed the assertion and converted to unicode in tnode::setTnodeText.</t>
<t tx="ekr.20071028032929.1056"></t>
<t tx="ekr.20071028032929.1057">The calls to config.setX in the put routines in leoFileCommands.py were happening _after_ the calls to config.update().  There is not need to call the config.set routines in putPrefs and putFindSettings provided we do the following in write_LEO_file:

	c.setIvarsFromFind()
	config.setConfigFindIvars(c)
	c.setIvarsFromPrefs()
	config.setCommandsIvars(c)
	config.update()</t>
<t tx="ekr.20071028032929.1058">This creates leoConfig.txt</t>
<t tx="ekr.20071028032929.1059">The old code was totally brain dead.  If a setting was missing or "ignore" it could never be set!!  Sheesh.  This is a major bug because _all_ writes to leoConfig.txt go throught this routine.</t>
<t tx="ekr.20071028032929.1060"></t>
<t tx="ekr.20071028032929.1061">Otherwise there is no way to change the prefs!</t>
<t tx="ekr.20071028032929.1062">There were a couple of bugs here.

Note that the ratio (whichever the direction) is stored in the .leo file.  The initial_splitter_orientation setting in leoConfig.txt applies to _all_ files.  The initial_vertical_ratio and the corresponding initial_horizontal_ratio  apply only to new files, so are essentially useless.

Yes, this is pretty stupid; it's the result of not wanting to add more stuff to Leo's file format.</t>
<t tx="ekr.20071028032929.1063"></t>
<t tx="ekr.20071028032929.1064">This makes selected text look much better and makes Show Invisibles look much better as well.  

This was not easy to do.  Apparently tag settings interfer with the Tk.Text settings.  I have not found a way to specify the selectbackground color for tags.  The only way I could get things to work is only define whitespace tags when in showInvisibles mode.</t>
<t tx="ekr.20071028032929.1065">Added setRevertVars to update revert settings.  This is called from __init__ and onOk.</t>
<t tx="ekr.20071028032929.1066">This is consistent with what the Import commands do for the other file types.  It's also much safer.</t>
<t tx="ekr.20071028032929.1067">.tmp files disappear On Windows XP after Leo exits!</t>
<t tx="ekr.20071028032929.1068"></t>
<t tx="ekr.20071028032929.1069">The new spelling is to limit_directory_search_extension.  Note that this affects the valid entries in leoConfig.txt.</t>
<t tx="ekr.20071028032929.1070">Repeated double-clicking (without intervening single-click) caused the selection to move to the left.</t>
<t tx="ekr.20071028032929.1071"></t>
<t tx="ekr.20071028032929.1072">We must remove backticks from messages that might contain unicode characters so they will print properly.  There were only a few instances, and they are all error messages that hardly ever get executed, so I hope I was careful putting them in.  I should be able to find them all by looking for '"'.</t>
<t tx="ekr.20071028032929.1073">Simplified leoCompare.py and leoTangle.py.</t>
<t tx="ekr.20071028032929.1074">Now at last it is clear why Leo hasn't been writing derived files affected by clones.  It's not enough to mark v dirty.  We must mark all the cloned nodes of v's tree dirty as well.

However, we only need do this when a node is deleted, and we definitely do _not_ want to do this otherwise, for that would mark far too many nodes dirty.  To get around this, we leave v.setDirty() as it was, and use the new code only in v.setDirtyDeleted.

Note that the undo and redo cases handle this automatically because they call c.doDelete.</t>
<t tx="ekr.20071028032929.1075"></t>
<t tx="ekr.20071028032929.1076"></t>
<t tx="ekr.20071028032929.1077">Amazing.  All that was needed was some code to force conversion on write, and code in the event handlers to convert "real" unicode to UTF-8.  We are talking about 10 lines of code!

There was a problem in leoFind.findNext: it was backquoting the search string when reporting search failures.  Removing the back quotes made the message appear properly.

What was needed was simply to do:

	if type(s) == types.UnicodeType:
		xml_encoding = app().config.xml_version_string
		s = s.encode(xml_encoding)

On the string s gotten from the Text widgets in the event handlers.

As a defensive measure, I also changed the write code in two places to:

	try:
		self.outputFile.write(s)
	except UnicodeError: # This might never happen.
		xml_encoding = app().config.xml_version_string
		s = s.encode(xml_encoding)
		self.outputFile.write(s)

The old code wrote `s` instead of s.encode(xml_encoding).</t>
<t tx="ekr.20071028032929.1078">Also changed the calling code to check for val != None and val &gt; 0 or val != 0.  The only callers of skip_long are the various places that handle the @pagewidth and @tabwidth code.  Negative tab widths are allowed, but not negative page widths.</t>
<t tx="ekr.20071028032929.1079">Initializing to something else was preventing a lot of code from being used!

Retested the @path logic.  Everything seems good.</t>
<t tx="ekr.20071028032929.1080">These were used only to set the delim1, delim2 and delim3 locals in atFile.scanAllDirectives.  Getting rid of these two useless ivars greatly clarifies the code.</t>
<t tx="ekr.20071028032929.1081">This is weird.  set_language would set the delims to the default_language delims if the lanuage was "default"</t>
<t tx="ekr.20071028032929.1082"></t>
<t tx="ekr.20071028032929.1083">We can't use choose because both branches are evaluated.

self.single_comment_string was never None before because all languages had either 1 or 3 delims.  But Java now has only 2 delims to force block comments.</t>
<t tx="ekr.20071028032929.1084">The same bug appeared in leoAtFile.putIndent and leoTangle.put_leading_ws.  These routines should not do w = abs(tab_width) before the test.  I was confused that n (the desired indentation) might be negative.

Anyway, as a defensive measure, I used ' ' * abs(n) and '\t' * abs(n) in the routines in leoAtFile and leoTangle that put tabs and spaces.

Also, changed n / w to int(n/w) to avoid problems with future division.</t>
<t tx="ekr.20071028032929.1085">1. The botch was this: set_delims_from_language used to return
	delim1 = start_block_comment_string
	delim2 = end_block_comment_string
if there were only two delims.  But the callers thought that delim1 was _always_ the single_comment_string.

This actually never caused problems with @language, because all languages had either 1 or 3 delimiters.  However, it appeared when I forced block comments in Java by using only two delims.  And it could always have caused problems when people used the @comment directive.

2. Issued a warning and do nothing when no delims specified with @comment.  This could have caused crashes.

3. set_delims_from_string no longer returns hard-coded defaults.  Instead it returns None.  Callers must now beware, but this is the correct action to take.</t>
<t tx="ekr.20071028032929.1086">The change was made to leoFrame.py::reconfigurePanes.</t>
<t tx="ekr.20071028032929.1087"></t>
<t tx="ekr.20071028032929.1088">If a name table has only one name, it must be defined like

name = ("x",)

rather than

name = ("x")

This affected the following options:

"read_only"
"xml_version_string"
"limit_count"
"body_pane_wraps"</t>
<t tx="ekr.20071028032929.1089">1. Removed the following ivars.  They were never used.

self.singleCommentString = "#"
self.startCommentString = ""
self.endCommentString = ""

2. Initialized the following ivars to None in the ctor:

self.default_directory = None
self.page_width = None
self.tab_width  = None
self.presentLanguage = None
self.targetLanguage = None
self.startSentinelComment = None
self.endSentinelComment = None

This makes clear that they are really initialized in leoAtFile.scanAllDirectives.

3. Renamed leoAtFile.scanAllDirectives.&lt;&lt; Set delims to default values &gt;&gt; to &lt;&lt; Set ivars &gt;&gt;.  It's contents is now:

if 1: # 8/2/02
	self.page_width = self.commands.page_width
	self.tab_width = self.commands.tab_width
	self.presentLanguage = self.targetLanguage = c.target_language
else:
	self.page_width = leoPrefs.default_page_width
	self.tab_width = leoPrefs.default_tab_width
	self.presentLanguage = self.targetLanguage = leoPrefs.default_target_language
	
self.default_directory = leoPrefs.default_default_directory
delim1, delim2, delim3 = set_delims_from_language(self.presentLanguage)</t>
<t tx="ekr.20071028032929.1090"></t>
<t tx="ekr.20071028032929.1091">There were many, many problems in the old color panel.

- Completely revised the Revert logic in the main Color panel.
- The color name picker now reverts properly.
- Color names and color swatches are now properly updated in all cases.
  As a result, there is no need to write color values to the log window.
- Used str(name) rather than `name` to eliminate quotation marks around color names and values.
- The color picker now shows the value of the present color, not the revert color.
- Increased the width of name buttons to handle long color names.
</t>
<t tx="ekr.20071028032929.1092">See the child node for a proof.</t>
<t tx="ekr.20071028032929.1093">@nocolor

The test code shows that all normal cases are handled correctly.  Nevertheless, we must prove that Leo can properly read and write @file nodes with nested @others directives.

Writing:

putAtOthers writes all nodes to be generated by @others.  inAtOthers returns false if the node has already been visited.  Nodes will not be visited when expanding the "outer" or "upper" @others, and will be visited thereafter.  Thus, nodes will be written at most once.

putAtOthers writes only sibling nodes and nodes descending from sibling nodes.  The expansion of inner @others nodes will never include parent nodes.  The expansion of an @others directive at @file node will write all unwritten nodes in the @file node.

In short,

1. all nodes in the "range" of an @others directive are written once and only once.
2. all nodes in the "range" of an @others directive are written enclosed in @+-others sentinels.
3. No orpan nodes are written.

Reading:

The read logic is unchanged.  Everything will work as before.  In particular, note that @+-others sentinels create trees under nodes containing the @others directive, just as before.  The read logic naturally handles nesting!</t>
<t tx="ekr.20071028032929.1094"></t>
<t tx="ekr.20071028032929.1095">The bug was testing for ifdef instead of #ifdef at the start of skip_pp_if.  However, I thought the bug might be related to something else, so I ended up being much more careful about brace levels in different branches of an #if statement.  The result was the skip_pp_part routine.</t>
<t tx="ekr.20071028032929.1096">I think this is most reasonable: we don't wan't people generating files from imported files unless they take some positive action.</t>
<t tx="ekr.20071028032929.1097">This bug caused following defs to be included in the current def if the line ended in a comment that was followed immediately by another def.</t>
<t tx="ekr.20071028032929.1098">I wanted to generate the following if a class declaration is in a separate node:

class x:
	@others

Instead of:

class x:
	&lt;&lt; class x methods &gt;&gt;

+ &lt;&lt; class x methods &gt;&gt;
@others

This doesn't work at first: all nodes under class x become orphans.  However, the new version of 
</t>
<t tx="ekr.20071028032929.1099">In order to make the new import code work, I have _experimentally_ allowed a change to how leoAtFile writes code.  This is the first such change in about a year.

The old code in leoAtFile.inAtOthers did not write nodes in @others trees if such nodes descended from another @others node.  The new code allows such nodes.  Apparently the write code handles this case just fine and the old restriction was unnecessary...</t>
<t tx="ekr.20071028032929.1100">Added entries for default target language, outline, promote and demote.</t>
<t tx="ekr.20071028032929.1101">The code now makes sure that c.target_language and related vars are not None.  This should fix the problem, and I wouldn't bet my life on it.</t>
<t tx="ekr.20071028032929.1102">It's too confusing to have arrow keys mean different things in different panes.

For one thing, we want to leave the focus in the body pane after the first click in the outline pane, but that means that the arrow keys must still be functional in the _body_ pane!

Alas, all the various combinations of key bindings of arrow keys appear to do something; there are none left to use for moving around in the outline pane.  So we are stuck with poor shortcuts.</t>
<t tx="ekr.20071028032929.1103"></t>
<t tx="ekr.20071028032929.1104">The @others directive was appearing before &lt;&lt; declarations &gt;&gt; reference.

The bug report and the fix were from Walter H. Rauser.</t>
<t tx="ekr.20071028032929.1105"></t>
<t tx="ekr.20071028032929.1106">I used the dis module as a base.  It was remarkably easy.  All I needed was

1. dis.opname, the names of the opcodes and
2. some code in the dis module to use as a starting point.</t>
<t tx="ekr.20071028032929.1107">The performance of Leo is as I expected.  In particular, reading files is the biggest bottleneck, and scanning string.find, isAtFileNode, is_ws, etc. are called frequently.</t>
<t tx="ekr.20071028032929.1108"></t>
<t tx="ekr.20071028032929.1109"></t>
<t tx="ekr.20071028032929.1110"></t>
<t tx="ekr.20071028032929.1111">@nocolor

Bernhard Mulder suggested the following code for adding the path to idle to sys.path.  I used this code with only trivial modifications.  I retained the previous error handling code in case there are further exceptions...

@color

try: 
	import idle 
except: 
	executable_dir = os.path.split(sys.executable)[0]
	idledir=os.path.join(executable_dir, "tools/idle") 
	sys.path.append(idledir)
</t>
<t tx="ekr.20071028032929.1112">The fix was to put a call to frame.top.deiconify() in run() right after the call to the frame ctor.

Apparently I only use openLeo.py to open Leo.</t>
<t tx="ekr.20071028032929.1113">The Compare panel is much easier to use than the old scripts in leoCompare.py.</t>
<t tx="ekr.20071028032929.1114"></t>
<t tx="ekr.20071028032929.1115">It is remarkable how recasting the code as two classes clarifies and fortifies the code.</t>
<t tx="ekr.20071028032929.1116">@nocolor

The new rules allow leo.py 3.1 to read and write .leo files more like leo.py 2.x when there is no leoConfig.txt file.  The scheme used in leo.py 3.0 meant that preferences were _never_ written to .leo files.  It's advantage was that all defaults were specified in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

I think the present scheme is more natural, but we shall see...

In effect, Leo sets and gets various options in the following order of precedence:

1. Use explicit settings in leoConfig.txt if they exist.

2. Use defaults for leoConfig.txt, but only if leoConfig.txt exists.  These defaults are found in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

3. Use settings in .leo files if leoConfig.txt does not exist.

4. If leoConfig.txt does not exist, and the .leo file does not specify a setting, use hard-coded settings in the various classes, just as leo.py 2.x did.

Added the config.configsExist ivar to tell whether leoConfig.txt exists (as far as Leo is concerned).</t>
<t tx="ekr.20071028032929.1117">Also added tcl keywords for syntax coloring.</t>
<t tx="ekr.20071028032929.1118">The @pagewidth, @tabwidth and @language directives could not have worked while tangling!  Apparently nobody has every used these directives in @root trees!

1. Apparently, skip_long had never been executed successfully (!!)  Indeed, it computed the value of a string character by character using (s[i] - '0') which has no chance of ever working!

2. The code in tangle.scanAllDirectives that handles @pagewidth and @tabwidth could not have ever worked. is_special_bits sets the dict entries for "page_width" and "tab_width", but tangle.scanAllDirectives looks for dict["pagewidth"] and dict["tab_width"], both of which will cause exceptions!

3. The code in tangle.scanAllDirectives that handles @language failed to set the self.x copies of the c.x ivars relating to language! This bug may have dated from fairly recent times when I changed the tangle code to use the self.x ivars rather than the c.x ivars.</t>
<t tx="ekr.20071028032929.1119"></t>
<t tx="ekr.20071028032929.1120">This affects Flatten Outline and Import Flattened Outline.</t>
<t tx="ekr.20071028032929.1121">While I was at it, I made a few minor changes to leoDialog.py.

1.  Added padx and pady padding in dialogs.
2.  Added text="OK" param to AskOk.
3.  Used center_dialog utility in leoDialog.center.

The leoDialog code is still ugly, but not ugly enough to fix.</t>
<t tx="ekr.20071028032929.1122"></t>
<t tx="ekr.20071028032929.1123">I wanted to see if this would corrupt any derived files by interrupting the write.  I doubted that this would be so: events do not work like interrupts.

What happened was that the pending event seemed to slow the writing, and all derived files were written correctly.</t>
<t tx="ekr.20071028032929.1124">The answer to the question, "why not just improve compare scripts?" is that people rarely use scripts.  A compare window would be much more convenient.  And convenience matters here: it is very important that people feel comfortable importing and exporing files.</t>
<t tx="ekr.20071028032929.1125"></t>
<t tx="ekr.20071028032929.1126"></t>
<t tx="ekr.20071028032929.1127">Found many spelling errors and repeated words.</t>
<t tx="ekr.20071028032929.1128">We can't just keep getting the x,y coordinates from the event, because then we can't stop.</t>
<t tx="ekr.20071028032929.1129">All files now pass.  I changed the followoing:

	leoAtFile.py:   found bug: unbound c in read()
	leoColor.py:    removed import keyword
	leoCommands.py: removed unused vars from Convert Blanks.
</t>
<t tx="ekr.20071028032929.1130"></t>
<t tx="ekr.20071028032929.1131"></t>
<t tx="ekr.20071028032929.1132">It was amazingly easy to do this.  We need only compute self.line_height from self.font.metrics().</t>
<t tx="ekr.20071028032929.1133">Also fixed a but that resulted in Convert Tabs being undoable.</t>
<t tx="ekr.20071028032929.1134">There were several important optimizations:

1. OnDrag precomputes self.numberOfVisibleNodes().
2. Eliminate all calls to findVnodeWithIconId() in OnContinueDrag.</t>
<t tx="ekr.20071028032929.1135">Including the split direction and split ration.

Leo now uses all configuration settings from leoConfig.txt.</t>
<t tx="ekr.20071028032929.1136">Just putting a call to update() in leoFileCommands.getGlobals() does 90% of what we want.  Moving the calls to

	frame.top.deiconify()
	frame.top.lift()
	
from OpenWithFileName to getGlobals gets us to 99% of perfection.  There is a tiny flash when the frame created in leoFrame.__init__ is drawn then withdrawn.

The last 1% is accomplished by withdrawing the newly-created frame in frame.__init__.  With this last change there is no perceptable flash when a window is opened.  Of course, all callers of frame.__init__ must now call deiconify as needed.

Trying not to create a frame at all until its size is known would be much, much harder, because the frame and commands classes initialize each other.
</t>
<t tx="ekr.20071028032929.1137">The bug was in leoFileCommands.getGlobals.

This was a _really_ irritating bug.  Now windows open where they were when closed.</t>
<t tx="ekr.20071028032929.1138">This saves the "user" code a lot of work.

Note: if leoConfig.txt does not exist, the default tables in the section called:

&lt;&lt; define default tables for settings &gt;&gt;

in leoConfig.py take effect, so modifying these tables is yet another way of managing preferences.</t>
<t tx="ekr.20071028032929.1139"></t>
<t tx="ekr.20071028032929.1140">The present code works wether we destroy the prefs, font and color panels when we close them, or just withdraw them.  It is best to withdraw them, because this preserves their location on the screen when we bring them back.

Some things to keep in mind about this code:

1.  There must be code in frame.OnCloseLeoEvent to destroy these frames if present.  The reason is that these are now non-modal frames, so they could still be open when we close the Leo window that "owns" them.
This is true Regardless of whether these frames are withdrawn or destroyed when closed.

2.  Since the window are no longer modal, we might try creating them after they exist.  In that case, we must simply deiconify the panel, even if we destroy panels when they are closed.

In both cases, we _must_ maintain ivars accurately telling whether the panels have been created or not.  These ivars are owned by the leoFrame class.  They are created by leoFrame when creating a frame, and set to Null by panel code if panels are destroyed when closed.  Since the leoFrame class owns these ivars, a cleaner way would be to create a frameDestroy method for each kind of panel.  But that borders on the pedantic...</t>
<t tx="ekr.20071028032929.1141"></t>
<t tx="ekr.20071028032929.1142"></t>
<t tx="ekr.20071028032929.1143">so code can say getXparam("name") and always get a proper value.</t>
<t tx="ekr.20071028032929.1144">This was easy to do and useful.</t>
<t tx="ekr.20071028032929.1145">This was much more work than it "ought" to have been, due mainly to the fact that Tk.ListBox does not have a callback for changed selection.  So the selection becomes active only on a double-click or a change to the size or bold or italics boxes.

The present frame seems to handle all cases properly and without surprise.  The code to do so is tricky.</t>
<t tx="ekr.20071028032929.1146"></t>
<t tx="ekr.20071028032929.1147">All that is needed is that each Font and Color panel be firmly connected to a particular Leo window.  In fact, we must have separate Font &amp; Color panels for each Leo window.  The point isn't that we want all these window: in practice there is almost always just one Leo around. The point is that we can eliminate the irritation of modal windows!

This insight also applies to the Preferences panel.  It's not so important for the Find/Change window.</t>
<t tx="ekr.20071028032929.1148">This was a _huge_ amount of work.  I am quite proud of the result.  The present font panel is much more elegant and less cluttered than the examples I have looked at.  Indeed, the font panel pack a lot of power in a very small space.  I think this is really elegant design.

I spent hours and hours experimenting with different looks.  I finally realized that there is no need for radiobuttons:  they just add clutter.  More importantly, there is no need for an example frame!  The entire Leo window becomes an example.</t>
<t tx="ekr.20071028032929.1149"></t>
<t tx="ekr.20071028032929.1150">Leo keywords were mostly being coloring under the keyword settings.</t>
<t tx="ekr.20071028032929.1151">Using Ok, Cancel &amp; Revert buttons is _much_ better than Ok, Apply, Cancel because changes are made instantly.  The only problem is that the modal dialog makes it impossible to change text.  But with just a little foresight the user could create a "test" document beforehand.</t>
<t tx="ekr.20071028032929.1152"></t>
<t tx="ekr.20071028032929.1153">Leo now uses the xml_version_string configuration setting, if present, to override the UTF-8 setting used in all previous versions of Leo.  The usual value of the setting is = ISO-8859-1.  This effective changes Leo's file format: older versions of Leo will not be able to read the new files.

If the setting does not exist, whatever value is present in the .leo file will be written when the file is written.  For new files, a value of ISO-8859-1 will be used when this setting is not present.

Notice that this also affects what is written to the clipboard.</t>
<t tx="ekr.20071028032929.1154"></t>
<t tx="ekr.20071028032929.1155"></t>
<t tx="ekr.20071028032929.1156">Used the following to bind callbac:

@color

for i in xrange(len(self.recentFiles)):
	name = self.recentFiles[i]
	callback = lambda n=i: self.OnOpenRecentFile(n)
	recentFilesMenu.add_command(label=name,command=callback)
	
@nocolor
</t>
<t tx="ekr.20071028032929.1157"></t>
<t tx="ekr.20071028032929.1158"></t>
<t tx="ekr.20071028032929.1159"></t>
<t tx="ekr.20071028032929.1160"></t>
<t tx="ekr.20071028032929.1161">1. The @comment directive no longer suppresses syntax coloring.

2. Directives (but not doc parts) are colored when @language plain is in effect.  The user can, as always, suppress all coloring by using @nocolor.

The new rules are much more natural than the old, and much less confusing.</t>
<t tx="ekr.20071028032929.1162">This was a bit of a fiasco.  I updated CVS without a real test.  Hopefully I'll learn from this.

Anyway, the REM hack is as follows:  Leo will convert underscores in the @comment directives to significant spaces.  For example,

@comment REM_

causes the comment delimiter to be "REM " (Note the trailing space).

I originally inserted a skip_space in sentinelKind where the comment was "Do not skip spaces here!".  However, I eventually settled on a better solution, namely making spaces significant in scanHeader. To quote from scanHeader:

"Leading whitespace is now significant here before the @+leo.  This is part of the "REM hack".  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches."</t>
<t tx="ekr.20071028032929.1163">The "comment" code was looking for "language", not "comment" in dict.</t>
<t tx="ekr.20071028032929.1164">I'm proud of the code: it is simpler, clearer and more general than the previous code.

There were several important breakthroughs:

1. The old divideSplitter routine had hard binding to various panes.  This was wrong.  The new divideAnySplitter routine uses params for all frames, so it can be general.

2. The key invariant is that self.splitVerticalFlag tells the alignment of the main splitter.  Getting clear about this was crucial to making everything work.  I could then split the old divideSplitter routine into divideLeoSplitter and divideAnySplitter.  Once that happened, everything just worked when I changed self.splitVerticalFlag from true to false in frame.__init__ (!!)

3. We shouldn't ever delete any frames when toggling the split direction.  It's just too hard to reinitialize them.  The key to making this happen are:

a) the calls to pack_forget and
b) creating placeSplitter from the old createSplitter (now createLeoSplitter) code.

4. The key invariant allows us to define onDragMainSplitBar and onDragMainSplitBar instead of the old onDragVSplitBar and onDragHSplitBar. The new routines work regardless of split direction, so we don't have to rebind the split bars when the split direction changes.</t>
<t tx="ekr.20071028032929.1165"></t>
<t tx="ekr.20071028032929.1166"></t>
<t tx="ekr.20071028032929.1167">Change c.initJoinedCloneBit to c.initJoinedCloneBits.</t>
<t tx="ekr.20071028032929.1168"></t>
<t tx="ekr.20071028032929.1169"></t>
<t tx="ekr.20071028032929.1170"></t>
<t tx="ekr.20071028032929.1171">Added @root node to root of tree and eliminated @language and @others directives.</t>
<t tx="ekr.20071028032929.1172">Importing a Python file containing classes without methods results in nested classes.  A workaround is to insert a dummy method in each class.

The fix was to define classIndent and defIndent variables, and to ensure that we break on equality with these values.  Also changed code to generate reference to methods only if methods or nested classes were seen.

There is still a minor bug:  The following

class A:
	pass

Puts the pass statement in &lt;&lt; class A declarations &gt;&gt;.  This bug is not so easy to fix, and it is easy to correct by hand.</t>
<t tx="ekr.20071028032929.1173">Importing the following file creates orphan nodes for declaration.

import sys # This line becomes an orphaned node
class C:
    xyz = 'xyz' # This line becomes an orphaned node
    def __init__(self):
        pass

The fix was in &lt;&lt; Create a child node for declarations &gt;&gt;.</t>
<t tx="ekr.20071028032929.1174">Importing the following script

class C:
    def __init__(self):
        pass

created an outline with class C appearing in two nodes, something like:

class C:
        class C:
                def __init__(self):
                    pass

The fix was to &lt;&lt; Append a reference to class_vnode's methods &gt;&gt;.</t>
<t tx="ekr.20071028032929.1175"></t>
<t tx="ekr.20071028032929.1176">This fixes a bug involving clone bits, and is much faster than calling c.initAllCloneBits.  The code involves c.moveOutlineRight and similar code in the undo and redo logic.</t>
<t tx="ekr.20071028032929.1177">Verified that u.undoReplace will handle all clones properly.  c.copyTree simply makes copies of all tnodes after v.copyTree has actually copied the tree.  These are really simple and elegant routines.</t>
<t tx="ekr.20071028032929.1178"></t>
<t tx="ekr.20071028032929.1179">The new "replace" paradigm greatly simplifies complex undo.  The ahas:

1. swap_links is a very simple way of replacing trees.
2. The caller of swap_links can easily redo join lists and clone info.
3. We need to use new tnodes in copied trees.  This hasn't been done yet.
4. Undo and redo use exactly the same code.</t>
<t tx="ekr.20071028032929.1180">The aha is this: the import commands are in essence nothing but an insertion of a tree rather than a single node, so exactly the same code will work for undo and redo!</t>
<t tx="ekr.20071028032929.1181">@ It is often useful to print a traceback message when a try block unexpected fails.  This can be done as follows:
@color

import traceback
try:
	...
except:
	# traceback.print_exc()
	pass</t>
<t tx="ekr.20071028032929.1182"></t>
<t tx="ekr.20071028032929.1183"></t>
<t tx="ekr.20071028032929.1184"></t>
<t tx="ekr.20071028032929.1185"></t>
<t tx="ekr.20071028032929.1186"></t>
<t tx="ekr.20071028032929.1187">This is important, because it means that invalid entries in, say, the Default Tangle Directory preference will no longer abort an attempted read.</t>
<t tx="ekr.20071028032929.1188">This is a little tricky.  The general rules are:

1. Settings in the [override .leo file prefs] section of leoConfig.txt override similar settings that exist in the &lt;preferences&gt; element in .leo files.

2. You may cancel this overriding by using "ignore" (without the quotes) as the value of a setting in leoConfig.txt.  For example:

[override .leo file prefs]
tab_width = ignore

In this example, Leo will use the tab width in each .leo file, or a default value if it doesn't exist.

3. Leo won't write overridden settings to .leo files.

The actual rules are as follows:

1. If a setting is not found in either the [override .leo file prefs] section of leoConfig.txt or the preferences section of the .leo file, Leo uses a default, hard-coded value.

2. When reading a .leo file, Leo will use settings in the [override .leo file prefs] section of leoConfig.txt unless the value of the setting is "ignore" (without the quotes).  Case is insignificant when specifying the value of default_target_language.

3. When writing leoConfig.txt, Leo will write settings in the [override .leo file prefs] section of leoConfig.txt if the setting exists in leoConfig.txt and its value is not "ignore" (without the quotes).

4. When Leo saves a .leo file, Leo updates leoConfig.txt (using rule 3) and Leo will write a Preferences setting to the .leo file only if the setting will not be written to leoConfig.txt using rule 3.  NB: this rule does not change Leo's file format because all atrributes of the &lt;preferences&gt; element have always been optional.

5. Leo will update leoConfig.txt (using rule 3) whenever the user closes the Preferences Panel successfully.

As the result of these rules, changes made in the Preferences Panel will become permanent immediately if the the setting will be written under rule 3.  Otherwise, the change will become permanent when any .leo file is saved.

I believe these rules are flexible and good.</t>
<t tx="ekr.20071028032929.1189"></t>
<t tx="ekr.20071028032929.1190">These commands convert an entire tree.</t>
<t tx="ekr.20071028032929.1191"></t>
<t tx="ekr.20071028032929.1192"></t>
<t tx="ekr.20071028032929.1193">It is important not to change the c. copies of these ivars.</t>
<t tx="ekr.20071028032929.1194">These are actually quite nice to have, and they are possible only because we have a modal dialog.</t>
<t tx="ekr.20071028032929.1195">This makes it absolutely clear what is happening.</t>
<t tx="ekr.20071028032929.1196">Added @language to all @file nodes.  This is good style.</t>
<t tx="ekr.20071028032929.1197"></t>
<t tx="ekr.20071028032929.1198">Gary Herron suggested this change.  This affects a number of commands.  Apparently this makes a difference in Linux...</t>
<t tx="ekr.20071028032929.1199">This allows us to remove the c.setIvarsFromPrefs routine.  I have left it in as a reminder of what needed to be done formerly.

Removed app().prefs and all references to it.</t>
<t tx="ekr.20071028032929.1200">This variable should _not_ be eliminated!  It is needed when reading the .leo file for the first time.</t>
<t tx="ekr.20071028032929.1201">These commands now set self.mFileName only if the dialog succeeds.  This is much more natural.</t>
<t tx="ekr.20071028032929.1202"></t>
<t tx="ekr.20071028032929.1203">This was a weird one.  I have no idea what I was thinking about!  Using c.openDirectory makes absolutely no sense.  Probably the c.openDirectory ivar should go away!</t>
<t tx="ekr.20071028032929.1204">The whole preferences issue needs rethinking and reworking...</t>
<t tx="ekr.20071028032929.1205"></t>
<t tx="ekr.20071028032929.1206">DEMOTE:

  Doc: The Demote command makes all the siblings of a node children of
  the node.

  Reality: Not quite: it makes all sibilings WHICH FOLLOW a node into
  children
</t>
<t tx="ekr.20071028032929.1207">LOG WINDOW:

  Doc: The Open Log Window command opens the window, and the Close Log
  Window command closes it.  Only one of these commands is present in
  the Window menu at any time.

  Reality: These don't seem to exist.
</t>
<t tx="ekr.20071028032929.1208">INSERT HEADLINE:

  Doc: The Insert Headline command inserts a new headline as the next
  sibling of the currently selected headline.  If the root headline is
  selected, this command inserts the new headline as the first child
  of the root.

  Reality: Insert Headline appears to insert a child if the current
  headline has any children, and it appears to insert a sibling
  otherwise.
</t>
<t tx="ekr.20071028032929.1209">EXTRACT SECTION COMMAND:

  Doc: The Extract Section command creates a new node ...

  Reality: The menu item is highlighted (no mater what the first line
  contains), but NOTHING HAPPENS (no mater what the first line
  contains).

Leo.py works correctly.  Fixed docs.</t>
<t tx="ekr.20071028032929.1210">SYNTAX COLORING

  Is never highlighted so can't be used


FONT PANEL:

  Is never highlighted so can't be used

</t>
<t tx="ekr.20071028032929.1211">At long last cut/paste works properly!

1.  The way to get the contents of the clipboard is:

s = app().root.selection_get(selection="CLIPBOARD")

The following does _not_ work:

s = app().root.selection_get(selection="clipboard")

2.  Added stringIsValidMoreFile and convertMoreStringToOutlineAfter to leoImport.py.  These routines just convert the string to an array and call stringsAreValidMoreFile and convertMoreStringsToOutlineAfter.

3.  Removed app().clipboard ivar.</t>
<t tx="ekr.20071028032929.1212"></t>
<t tx="ekr.20071028032929.1213">Once again, things are easier with Python than I expect.  The ConfigParser class is quite nice: it gives a flexible framework for all kinds of preferences.  It would be good to move most, if not all, preferences into this framework.

Note: we no longer need to change the format of .leo files to handle new kinds of preferences!  Indeed, we can just define new sections of leoConfig.txt!

Leo reads and writes leoConfig.txt.  Leo looks first in sys.leo_config_directory.  If that has not been set in sitecustomize.py, then Leo looks in app().loaddir.

</t>
<t tx="ekr.20071028032929.1214">This assert isn't useful and doesn't have to be true.</t>
<t tx="ekr.20071028032929.1215">Added code to recover the old .leo file if the write fails.  We create a backup (.bak) file by renaming the .leo file if it exists.  If there is a write error, we rename the .bak file back to .leo.  Otherwise, we just delete the .bak file.</t>
<t tx="ekr.20071028032929.1216">This was so easy...It should have been done ages ago.</t>
<t tx="ekr.20071028032929.1217">LeoDocs.leo now matches Leo's web site as closely as possible.  At this point, I consider Leo's documentation completely finished.</t>
<t tx="ekr.20071028032929.1218">The solutions to the control-H bug was to call v.edit_text.focus_force() in tree.editLabel().

Adding a call to es() in endEditLabel() makes everything work, at least on XP, but this is too strange.  I finaly fixed the problem by having c.insertHeadline call c.endUpdate(false) followed by c.tree.redraw_now().  This is pretty kludgy. Apparently the call to c.endUpdate() was redrawing the outline after the headline had been selected, with the usual bad results.  </t>
<t tx="ekr.20071028032929.1219">I removed a binding that resulted in double-clicks in headlines expanding or contracting nodes.  You can expand or contract headlines now by double-clicking a node's headline or by clicking its plus/minus box.

This change was requested by Bill Drissel.</t>
<t tx="ekr.20071028032929.1220">I have spent quite a bit of time on getting dragging to work as smoothly as possible.  This has been made more difficult because I know of know way of reading the state of the mouse button without generating a mouse-moved event.

To start a drag, press the main (left) mouse button while the cursor is over the icon for a node.  The cursor will change to a hand icon. Continuing to drag the mouse will scroll the outline pane if the hand cursor moves above or below the outline pane.  If you release the mouse button while the hand cursor is above another icon, Leo will move the dragged node after the node over which the cursor rests.  If you release the mouse button when the hand cursor is not over an icon, Leo will print "not moved" and leave the outline pane as it is.  This can result in the dragged node not being visible on the screen, but it seems less alarming not to force the current node to become visible as that would undo any scrolling that has just been done.

As usual, there are a number of details.  

1. Leo only allows dragging from one icon to another.  In particular, you can't move a node to the first child of another node unless that node is already expanded.   I experimented with automatically open nodes when the cursor moves over an unexpanded node with children.  However, this was highly confusing.  It seems less alarming to expand and contract nodes explicitly. 

2. Leo scrolls the outline pane as the result of mouse-moved events, so to continue scrolling you must keep moving the mouse.  I experimented with scrolling the outline pane whenever the cursor is dragged outside it, but the results are not good.  There was a noticable delay between releasing the cursors and halting the scrolling.  The present code is simpler and more likely to work on all platforms.</t>
<t tx="ekr.20071028032929.1221">Note that tangle.scanAllDirectives already did this.</t>
<t tx="ekr.20071028032929.1222"></t>
<t tx="ekr.20071028032929.1223">es() failed if log is None because log.newlines does not exist.  The new code alters log.newlines only if log is not None.</t>
<t tx="ekr.20071028032929.1224">Leo takes an exception.  It may be because tcl 8.3.4+ is required.  The download tcl is 8.3.4.2, but I'm not sure what version is included in Python 2.2.1.</t>
<t tx="ekr.20071028032929.1225"></t>
<t tx="ekr.20071028032929.1226">In particular, the theory of operation for Tangle and Untangle was eliminated by mistake several months ago.</t>
<t tx="ekr.20071028032929.1227"></t>
<t tx="ekr.20071028032929.1228">There were two problems in this area.  First, v.moveToRoot wasn't preserving the tree when a node was moved to the root.  This caused nodes to disappear.  Second, the code wasn't taking care to change c.tree.rootVnode as needed when nodes moved up or down.

Several important routines had to be changed.  v.moveAfter and v.moveToNthChild now are careful to set c.tree.rootVnode if the root changes.  I hacked v.moveToRoot and v.linkAsRoot so that they update c.tree.rootVnode only if the oldRoot param is not None.  This allows the init code to work properly, and allows the v.moveToRoot routine to properly link in the rest of the tree.  The undo and redo code now use the new param to v.moveToRoot.</t>
<t tx="ekr.20071028032929.1229">@nocolor

The new code isn't great, and it seems to solve the immediate problem.

@color

try: # 5/27/02: We can get Unicode strings here via cut/paste.
	try:
		self.outputFile.write(s)
	except UnicodeError:
		self.outputFile.write(`s`)
except:
	es("error writing:" + `s`)</t>
<t tx="ekr.20071028032929.1230">After creating some clone nodes with the Borland version of Leo, LeoPy.leo was corrupted.  Reading the damaged file with Read Outline Only works, so apparently the problem involves the clone indices in the derived files.

The problem was that not all the code in atFile::updateCloneIndices got copied back to the Borland code.  In particular, clone indices were not cleared before being reassigned!</t>
<t tx="ekr.20071028032929.1231"></t>
<t tx="ekr.20071028032929.1232">Added skip_matching_delims utility function.</t>
<t tx="ekr.20071028032929.1233">Removed extra whitespace between sections.

Fixed bug in convertCodePartToWeb: added code to skip @file line.</t>
<t tx="ekr.20071028032929.1234">This was an attempt (probably futile) to fix a crash in cut/paste logic.</t>
<t tx="ekr.20071028032929.1235">This allows the the last filename used to be the default for the Outline To Noweb dialog.</t>
<t tx="ekr.20071028032929.1236">We generate &lt;&lt;*&gt;&gt;= only if no file name is given in @root or @file.  The old code always generated * for @root.

Also, changed &lt;&lt; append head_ref &gt;&gt; so that @c generates &lt;&lt;fileName&gt;&gt;= instead of &lt;&lt;*&gt;&gt;= whenever possible.</t>
<t tx="ekr.20071028032929.1237">I rewrote isDocStart.</t>
<t tx="ekr.20071028032929.1238"></t>
<t tx="ekr.20071028032929.1239"></t>
<t tx="ekr.20071028032929.1240">Moving an outline up before the "root" node hung in v.setDirty.

The fix was in c.moveOutlineUp: we must call v.moveToRoot, followed by back.moveAfter.  To make this work, v.moveToRoot must leave the mFirstChild link unchanged.

Fixes were also needed in undo.undo() and undo.redo() to handle this special case.</t>
<t tx="ekr.20071028032929.1241">This fixed a bug that caused Leo to hang when syntax coloring noweb code with the CWEB syntax colorer.</t>
<t tx="ekr.20071028032929.1242">This routine must take into account the kind of file being imported.</t>
<t tx="ekr.20071028032929.1243">There are many details here.  The present code handles substantial code well, and looks good.</t>
<t tx="ekr.20071028032929.1244">The green used by IDLE looks really good to me.</t>
<t tx="ekr.20071028032929.1245">The code now purports to work for both CWEB and noweb files.</t>
<t tx="ekr.20071028032929.1246"></t>
<t tx="ekr.20071028032929.1247">Outline To Noweb creates &lt;&lt; * &gt;&gt; sections when it doesn't know what name to give something.  This may be partially correct, or entirely wrong.</t>
<t tx="ekr.20071028032929.1248">Please note that the same mechanisms work unchnaged for both @root and @file trees.</t>
<t tx="ekr.20071028032929.1249">I hacked the Python and Java code (hacks on hacks) to insert nodes to carry @others commands when generating @file trees.  The Python code now handles nested classes fairly well.

At this point I'm not sure what is a bigger kludge, the "parsing" parts or the "code generation" parts.  I really don't want to do full parsing here, but the present code is pretty wild.  OTOH, it works.

Fixed bug in skip_pascal_string.

Split the Import Files command into Import To @file and Import To @root.</t>
<t tx="ekr.20071028032929.1250"></t>
<t tx="ekr.20071028032929.1251">Debugged the Import Files command for .py files.  The main problems were getting the params to the scanPythonX routines correct: these were just transcription problems.

Fixed 2 bugs in the colorizer: it wasn't handling Python triple strings or C preprocessor directives properly.

Fixed a bug in skip_python_string.  It was returning the start of the ending delim, not past it.</t>
<t tx="ekr.20071028032929.1252">It only took an hour.  I am amazed this hasn't been done long ago.</t>
<t tx="ekr.20071028032929.1253"></t>
<t tx="ekr.20071028032929.1254">Issue the "reading:" message only if the file can be opened.
Eliminated the #--- error reading x" message before read errors.</t>
<t tx="ekr.20071028032929.1255">Added a return value to update_def so that skip_body can tell if a node has been changed.  skip_body now calls v.trimTrailingLines only if the node has changed.</t>
<t tx="ekr.20071028032929.1256">Untangle was setting the pane changed even when not reporting any changes.  This was due to a call to v.trimTrailingLines.  Changed v.setBodyStringOrPane so that it calls c.setChanged and v.setDirty only if the new text is different from the old, but this doesn't completely solve the problem.</t>
<t tx="ekr.20071028032929.1257">These are helpful in leo.py because the commands are slower than in LeoCB.</t>
<t tx="ekr.20071028032929.1258"></t>
<t tx="ekr.20071028032929.1259"></t>
<t tx="ekr.20071028032929.1260">The code mistakenly set part to zero before calling update_def, with the result that the wrong parts were compared.  This simple blunder took several hours to find.</t>
<t tx="ekr.20071028032929.1261"></t>
<t tx="ekr.20071028032929.1262"></t>
<t tx="ekr.20071028032929.1263"></t>
<t tx="ekr.20071028032929.1264">Documented new file format, unlimited undo/redo, auto indent, Contract Parent and Sort Siblings commands.</t>
<t tx="ekr.20071028032929.1265">Note: this code is still untested and very likely has major bugs.</t>
<t tx="ekr.20071028032929.1266">I did this to reasssure myself that such changes were benign, and they are: all files Tangle and Untangle as before.  Also, @space (or @doc) is needed at the start of all doc parts so that Leo2 will syntax color them properly.

This took quite a bit of time, and I really should do this for all of LeoCB.leo, or alternatively, convert all of LeoCB.leo to @file trees.  I'll probably leave this as an exercise for someone else to do ;-)  Actually, the proper way to do this is probably to write a Python script.</t>
<t tx="ekr.20071028032929.1267">The code is straightforward.</t>
<t tx="ekr.20071028032929.1268"></t>
<t tx="ekr.20071028032929.1269"></t>
<t tx="ekr.20071028032929.1270">Fixed &lt;&lt; Scan and define an @code defininition &gt;&gt; and &lt;&lt; Scan and define a section definition &gt;&gt; in skip_body.  The calls to skip_code were setting k, not i.  I'm not sure how Tangle could ever have worked before.  Perhaps a reversion of some kind.

With these fixes, all files are tangled identically by LeoCB and leo.py.

Removed trailing lines in code part in st_enter.  With this change almost all files compare identical except those containing (!newline).  Fixed a bug in put_section which caused whitespace not to be properly output after (!newline).  With this fix leo.py tangles all files in tangleTest.leo exactly the same as LeoCB!</t>
<t tx="ekr.20071028032929.1271">One bug remains in the Borland version and will probably never be fixed: Preferences settings do not stick to windows.  This is a result of using the arg_xxx vars rather than ivars.</t>
<t tx="ekr.20071028032929.1272"></t>
<t tx="ekr.20071028032929.1273"></t>
<t tx="ekr.20071028032929.1274">It is intolerable to have misleading syntax coloring.  The syntax colorer treats @c just like @code.  Tangle must do the same.</t>
<t tx="ekr.20071028032929.1275">Made the root arg optional.  If present it is a list with one element and is_special_bits checks for @root.  We pass a list of one element to is_special_bits so we can distinguish between None and [None].

Removed @owncolor code.</t>
<t tx="ekr.20071028032929.1276">In leoFrame.py: make the font size platform-dependent.
In leoTree.py: use os.path.join to join Icons and file names.</t>
<t tx="ekr.20071028032929.1277"></t>
<t tx="ekr.20071028032929.1278">''' wasn't handled like """</t>
<t tx="ekr.20071028032929.1279">pychecker is a marvelous tool.  It fixes most of the problems that compilers fix.</t>
<t tx="ekr.20071028032929.1280">Caught by pychecker:  the call to special_bits was missing the i param.  This would cause a fault when executed.</t>
<t tx="ekr.20071028032929.1281">changed mStartSentinelComment to self.startSentinelComment.
changed mEndSentinelComment to self.endSentinelComment.</t>
<t tx="ekr.20071028032929.1282">changed writeError to self.writeError.</t>
<t tx="ekr.20071028032929.1283">Changed message to self.message in BadLeoFile.__init__.

Changed param to es in getTnode().</t>
<t tx="ekr.20071028032929.1284">Initialized s to "" in moreHead.

Note: v.trimTrailingLines does nothing(!)

removed v.saveOutlineWithLevel.  This uses dvnodes and is old, old code.

removed v.setThreadLinks.  This was a bad idea that should have gone away a long time ago.</t>
<t tx="ekr.20071028032929.1285">x Changed all arg_ vars to ivars in scanAllDirectives:
	arg_present_language --&gt; self.language
	arg_tab_width --&gt; self.tab_width
	arg_page_width --&gt; self.page_width
	arg_use_header_flag -&gt; self.use_header_flag
	These will affect the @comment and @language directives!
x Changed set_root_delims() to self.set_root_delims()
x Changed end_sentinel_len to len(end_sentinel)
x Changed sentinel_end to self.sentinel_end in scanDerivedFile.
x Added c = self.commands in massage_block_comment. (This routine is never used, though).
x Removed extra param to match in put_section.
x Initialized code = None in skip_body.
x Initialized path in untangleRoot before error messages that use path.
x Used marked_flag properly in untangleMarked.</t>
<t tx="ekr.20071028032929.1286">A weird one: LeoCB was removing the last character (typically half of a cr-lf combination), probably in the mistaken belief that it was an end-of-file character.  Geeze:  how do C++ programs ever work when you have to deal with minutia like eof marks and 2-character newlines.  Tk has really spoiled me.

I added code to leo.py to ensure that even compressed derived files end in a newline, which will help.</t>
<t tx="ekr.20071028032929.1287"></t>
<t tx="ekr.20071028032929.1288">Emailed Guido.  He indicated that the fix just involves filenames, so I took a look at it immediately.  Used Leo to study the code and made a simple fix.</t>
<t tx="ekr.20071028032929.1289">This fixes a serious hole in Leo:  The read logic would crash (report corrupted sentinels) if what follows a reference looked like a sentinel line!</t>
<t tx="ekr.20071028032929.1290">It turns out to be easy to suppress newlines between sentinels.  It is a bit harder to make the read logic work properly.

By single-stepping through the Borland code (which also fails when newlines are suppressed) I see that there is logic in scanText that checks for a non-blank line after a +body sentinel!  By adding a check to see that the next line is not another sentinel line we can make the read logic work properly.

I wonder: suppose the text after a reference looks like a sentinel?  What happens then?</t>
<t tx="ekr.20071028032929.1291"></t>
<t tx="ekr.20071028032929.1292">Fixed a bug that for all languages (like Python and Perl) that do not have block comments.  The change was to update_def.</t>
<t tx="ekr.20071028032929.1293">Three characters were colored blue at the start of a section def in:
  &lt;&lt;name&gt;&gt;=
The fix was to change k to 2 in one spot.</t>
<t tx="ekr.20071028032929.1294"></t>
<t tx="ekr.20071028032929.1295">This is the only undoable command.  Now it puts up a dialog saying that.</t>
<t tx="ekr.20071028032929.1296"></t>
<t tx="ekr.20071028032929.1297"></t>
<t tx="ekr.20071028032929.1298">Optimize Undo Typing by suppressing the "oldText" entry in the dict if the previous entry was "Typing" and the vnode match.  This optimization saves almost half the space used in the bead list!

Verified that the Change All and Read @file Nodes commands call clearUndoState().

The "Cut", "Copy", "Delete", "Change", "Convert Blanks", "Indent", "Undent" are now undoable.  The only change was a new param to the body key handler.

Created onBodyWillChange event handler.  We must distinguish between commands like "Find, Then Change", which must call onBodyChanged, and commands like "Cut" and "Paste" that must call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.

Keystrokes in the headline are now undoable.</t>
<t tx="ekr.20071028032929.1299">The code is hardly more complex than the old limited code.  In many places it is simpler.

The code now saves only the "optional" ivars that are non-None.  This should be an important space optimization for "Undo Typing".

While messing with Undo in the body pane I realized I could simplify idle_body_key a bit.  I believe this is important.</t>
<t tx="ekr.20071028032929.1300"></t>
<t tx="ekr.20071028032929.1301">alt-v now work in @nocolor mode.</t>
<t tx="ekr.20071028032929.1302"></t>
<t tx="ekr.20071028032929.1303"></t>
<t tx="ekr.20071028032929.1304">Almost all of the logic is language independent!

Added keywords for c,pascal,perl &amp; python.</t>
<t tx="ekr.20071028032929.1305">skip_doc must test for actual strings, not the return value from token_type.</t>
<t tx="ekr.20071028032929.1306">This was a fix to the syntax colorer only.

Also colored the equal sign in &lt;&lt;name&gt;&gt;=.</t>
<t tx="ekr.20071028032929.1307">Added undoers for Cut/Past Node commands and Sort commands.

Apparently the Copy Node command has no undo consequences.

Added calls to clearUndoState for Read and Import commands.  Actually, the Import commands could easily be undone: they are just like insert commands.

Decided not to clear the undo state after Save commands.  Do so is confusing and seems pointless.  I may revisit this issue when implementing Unlimited Undo.</t>
<t tx="ekr.20071028032929.1308">These are not present in the CVS tree.  They should be.

c2py.py, openLeo.py, tangle_done.py, untangle_done.py, __init__.py.</t>
<t tx="ekr.20071028032929.1309"></t>
<t tx="ekr.20071028032929.1310">Most problems had to do with changing c.undoX to c.undoer.undoX or u.undoX.

Everything with an undoer now works.

Cut/Copy/Paste Nodes have no undoers.
Sort commands have no undoers.</t>
<t tx="ekr.20071028032929.1311">Apparently WinCVS is set up appropriately.  Remember to use my corrct password

Did a checkout from the create menu and everything went well!</t>
<t tx="ekr.20071028032929.1312"></t>
<t tx="ekr.20071028032929.1313">It is clear that broken clone links can't be mended automatically.  That is, Leo can't be made significantly more CVS friendly.  That being so, let us consider how to use CVS with Leo.

Our goal is this: we don't want clone links to break when we check derived files into or out of the repository.  In general, clone links will break whenever we a read derived file from a .leo file different from the .leo file that created it.  So to meet our goal we must obey the following rules:

Rules for using Leo files with CVS:
	
1. All derived files in a particular revision in the CVS repository must be generated by a single .leo file. Call that file the _generating_ .leo file (for the revision as a whole and for each derived file in particular).
	
2. When we check out files from the repository we must check out the generating .leo file in addition to the derived files that we are checking out.

3. When we check in files to the repository we must check in the single .leo file that generated the derived files that we are checking in.

4. When CVS detect update conflicts in derived files, developers must resolve those conflicts in a "merged" .leo file.  All derived files that are later checked in must be derived from this .leo file.  When creating this merged .leo files, developers should take care to retain clone links.  

These rules make a virtue out of necessity.  I always envisioned that update conflicts would have to be resolved in .leo files rather than derived files.  What I now see is that this is the also the only way to prevent clone links from being broken.</t>
<t tx="ekr.20071028032929.1314">Just after I completed the Mending Dialog I realized that the concept behind this dialog was fatally flawed: cloned nodes must have the same structure!

Indeed, at the time the Mend Clone dialog is put up, the user would have no way of knowing whether any joins made sense.  Conceivably Leo could test for structural simularity, and in that case this dialog would be useless.  Note: many read errors arise from structural mismatches; clones could never be mended properly in those cases.

About the only situation in which mending would be possible is if the only differences between trees were outline differences.  This suggests that we don't test headline text at all and just rely on structure identity.</t>
<t tx="ekr.20071028032929.1315">This dialog returns a list of pairs of names.  It is up to the caller to associate the names with vnodes.</t>
<t tx="ekr.20071028032929.1316"></t>
<t tx="ekr.20071028032929.1317"></t>
<t tx="ekr.20071028032929.1318">Moved these out of the frame class: the undo class also uses them.</t>
<t tx="ekr.20071028032929.1319">We want to remove only the leading whitespace present on the first line, not all leading whitespace!

Also, the Extract Section command was deleting the section reference line.

I could have sworn I tested these commands.  Apparently not.</t>
<t tx="ekr.20071028032929.1320"></t>
<t tx="ekr.20071028032929.1321">It appears that DnD will be straightforward: probably less then 100 lines of code!</t>
<t tx="ekr.20071028032929.1322">Removed "blank" and "tab" tags on entry.  I thought I did this!  Anyway, it remains to be seen whether this has any effect on the "disappearing" selection bug.

I did some perfunctory tests on the various find/change commands and everything appears to be working well.  We shall see...</t>
<t tx="ekr.20071028032929.1323">Made headlines longer in tree.headWidth(). Sometimes the right edge of a headline was being cut off.  This must be a Tk bug, and the workaround is easy enough.</t>
<t tx="ekr.20071028032929.1324">Cleaned up the code in several ways.  Some of these have been bugging me for a while.

Yesturday I realized that the proper time to clean up code is just _after_ a release.  That way the new code will be thoroughly tested before the next release.

c.tree.currentVnode -&gt; c.currentVnode()
Used keyword.iskeyword() in leoColor.py to test whether a word is a Python keyword.
Used string.endswith() in Import code.
Renamed is_c_word() to match_c_word() to be compatible with the match and match_word names.</t>
<t tx="ekr.20071028032929.1325"></t>
<t tx="ekr.20071028032929.1326">This is used in v.sortChildren and in leoImport.sort testing routine.  Apparently the latest code is about the best that can be done.  Passing a param to the list.sort() routine might seem elegant, and apparently it is slow.  Also, it is not clear how to pass the "n" param to the sort routine. I might challenge the net to do better, but the present code works and is fast, general, elegant and clear.</t>
<t tx="ekr.20071028032929.1327">Experimented with using Python's inspect module.  However, it doesn't provide nearly the level of parsing needed for Leo's import commands.  We need access to the entire parse tree.  It is probably possible...</t>
<t tx="ekr.20071028032929.1328"></t>
<t tx="ekr.20071028032929.1329">Removing from leoUtils import * from reload_all() will cause problems.  The only workaround appears to quit Python when modifying leoUtils.  Sigh.</t>
<t tx="ekr.20071028032929.1330"></t>
<t tx="ekr.20071028032929.1331">This is a really useful command!</t>
<t tx="ekr.20071028032929.1332">This is quite tricky code.  To capture changed values we typically must set a commands method that calls an idle routine. We can't capture the values by binding Button clicks because values haven't changed yet, or so it seems.

Anyway, the preferences panel settings now appear to "stick" to the presently active window.

The print_prefs routine was vital to sorting out what was happening.</t>
<t tx="ekr.20071028032929.1333"></t>
<t tx="ekr.20071028032929.1334">Now the real work begins.</t>
<t tx="ekr.20071028032929.1335">This will serve as a start for CVS.</t>
<t tx="ekr.20071028032929.1336">Added commands handler for all radio buttons.  There was a timing problem: it took 2 clicks to set the current language.  Also added code to recolor the body pane immediately.</t>
<t tx="ekr.20071028032929.1337">It is vital that @file nodes remain dirty until they are written without errors.  Otherwise, a Save command will succeeed without warning, and a later read may cause the dreaded "clones have been cleared" message.</t>
<t tx="ekr.20071028032929.1338">The settings in the Preferences panel now "stick" to the current window.  This turns out to be very important for Tangling: I ran into serious problems with Tangling to the wrong directory when more than one window was open.</t>
<t tx="ekr.20071028032929.1339"></t>
<t tx="ekr.20071028032929.1340">This turns out to be more useful than Sort Children.</t>
<t tx="ekr.20071028032929.1341"></t>
<t tx="ekr.20071028032929.1342">All the "Tangle" Constants must be defined in the same place.  It turns out that leoUtils no longer use any of these constants anyway, so I moved them to leoTangle where they have always belonged.

scanError() is now the only part of leoUtils that uses Tangle data.  It accesses the commands instances using the top() function.  A kludge...

In any event, when I split them I also defined some new values, so values from leoGlobals.py overlapped with values from leoTangle.py.  It is a good thing I caught the problem now...</t>
<t tx="ekr.20071028032929.1343"></t>
<t tx="ekr.20071028032929.1344">Moved the tangle constants into the tangle class.

Changed header to self.header in an error message in scanAllDirective.

The source of the "mismatch" in Utils.h was that somehow I inserted @c into the root of Utils.h, which should produce errors, and eventually it did.</t>
<t tx="ekr.20071028032929.1345">I reset the default tangle directory while doing regression testing, then saved LeoPy.leo.  This destroyed files LeoPy directory, I'm not sure how, so I had to revert.  All looks well now.</t>
<t tx="ekr.20071028032929.1346"></t>
<t tx="ekr.20071028032929.1347">There was a problem with a global change command.  I'll have to do a full regression test of Tangle.  This would be a good time to use the new whitespace utility routines.</t>
<t tx="ekr.20071028032929.1348"></t>
<t tx="ekr.20071028032929.1349">This was the result of a Change All disaster.</t>
<t tx="ekr.20071028032929.1350">We have to update s_text as well as c.body so that another call to search on the same line will find the updated text.</t>
<t tx="ekr.20071028032929.1351"></t>
<t tx="ekr.20071028032929.1352"></t>
<t tx="ekr.20071028032929.1353">Newlines now set the dirty bit.

We increase auto indent after a colon.  This should happen only for Python mode...</t>
<t tx="ekr.20071028032929.1354"></t>
<t tx="ekr.20071028032929.1355">Once again, I am astounded at how easy this is.</t>
<t tx="ekr.20071028032929.1356">Convert Blanks now converts the entire body pane if there is no selected text.</t>
<t tx="ekr.20071028032929.1357">It is doubtful that leo.py will ever support a Print command directly.  Rather, users can use export commands to create text files that may then be formatted and printed as desired.  Tk does provide print support.</t>
<t tx="ekr.20071028032929.1358">Only blanks and tabs are shown, and they not very well.

What we need is a font that shows blanks and tabs as descent symbols for blanks, tabs and newlines.</t>
<t tx="ekr.20071028032929.1359">The key is that two things have to happen:

1. Menu items should be enabled only when focus is in the canvas pane.
2. Bindings for for the outline commands should be added only to the canvas pane.</t>
<t tx="ekr.20071028032929.1360"></t>
<t tx="ekr.20071028032929.1361">A useful convenience method that makes it much clearer what is going on.</t>
<t tx="ekr.20071028032929.1362"></t>
<t tx="ekr.20071028032929.1363"></t>
<t tx="ekr.20071028032929.1364"></t>
<t tx="ekr.20071028032929.1365">Sherlock attempts to read the file SherlockArgs.  If found, each line is assumed to be a separate sherlock argument.

However, the main improvement is defaulting empty arguments to "+*".  This makes tracing as easy to use as print statements.

Could trace accept multiple arguments, just like print?  No: we would lose the ability to specify tracepoints by default.  There is no need to duplicate print!</t>
<t tx="ekr.20071028032929.1366">Very easy to do, compared with other systems.</t>
<t tx="ekr.20071028032929.1367">This should solve some compatibility problems.</t>
<t tx="ekr.20071028032929.1368"></t>
<t tx="ekr.20071028032929.1369">Alt-1 refers to Alt-Button-1, not Alt-Key-1 (!)</t>
<t tx="ekr.20071028032929.1370">Changed frame.put routines so that they return during quitting.

Also removed trace statements from __del__ routines.</t>
<t tx="ekr.20071028032929.1371">We must be careful to enclose all find/change code in c.beginUpdate/c.endUpdate(false) so a redraw after the call to tree.redraw_now() in find.showSuccess won't deselect the headline text.

It would be elegant to cancel any pending redraw in tree.redraw_now, and that does not seem to work.

Because we don't always redraw the screen, we must update icons "by hand" by calling c.tree.drawIcon.

It is very tricky to compute self.in_headline correctly.

Perhaps a more sensible approach would be to have the tree.redraw routine save and restore the editing status and selection of the current headline.  However, the present code works and minimizes redraws, so there isn't much incentive...</t>
<t tx="ekr.20071028032929.1372">The idea was that if all drawing happens at idle time we could do the following:

	Eliminate all c.beginUpdate()
	Eliminate all c.endUpdate(false)
	Replace c.endUpdate() with c.redraw()
	Replace c.endUpdate(flag) with if flag: c.redraw()
	
However, the find command needs to _prohibit_ drawing, and there doesn't seem to be a clean way to do this, so using c.endUpdate(false) seems to be needed.

In other words, without c.endUpdate(false) we would need c.cancelDrawing(), and this doesn't seem any cleaner than the present code.</t>
<t tx="ekr.20071028032929.1373"></t>
<t tx="ekr.20071028032929.1374">I messed things up when I "optimized" the redraw code.  The Find code must redraw the screen _before_ making selections in the headline--otherwise the headline becomes inactive.</t>
<t tx="ekr.20071028032929.1375">Altered the Cut/Copy routines so they set Leo's internal clipboard (app().clipboard).  So to cut from LeoCB to leo.py do the following:

Copy the tree in LeoCB.
Paste the tree into empty body text of leo.py.
Select all the body text and paste.
Move to the tree view, and do a Paste Node.

Yes, this is very clumsy, but how often do we want to transfer information between LeoCB and leo.py?</t>
<t tx="ekr.20071028032929.1376">This is defensive programming.  Only a few event handlers override body handlers:  These include Control-I, Control-T and Control-D.

Exception: the command handlers for cut/copy/paste must _not_ return "break"!  The actual work is done by the Tk.Text widget.</t>
<t tx="ekr.20071028032929.1377"></t>
<t tx="ekr.20071028032929.1378">Now that event handlers return "break" they can do things involving focus that they could not do before.</t>
<t tx="ekr.20071028032929.1379">This is done in frame.createAccelerators().  For the first time leo.py handles keystrokes properly!

We could override _all_ body pane keys, and this would be dangerous until all event handlers return "break."  Indeed, doing so would create duplicate bindings, one for frame.top and one for frame.body, so without a "break" the command would be done twice!</t>
<t tx="ekr.20071028032929.1380"></t>
<t tx="ekr.20071028032929.1381">Event scripts need only return the string "break" to inhibit all further event processing!  This is what I have been missing all along, and it was staring me right in the face.  Sheesh.

This eliminates the need for several kludgy workarounds:
	The double-click event handler no longer needs to wait till idle time.
	The c.moveDown routine no longer needs to call c.select.

Another breakthrough.  Way down at the bottom of the Tk.Text documentation I discovered a list of all the key bindings defined by default in Text widgets.  This includes Control-O, which explains why body text sometimes had blanks lines inserted at the top. (Amazingly, Control-O never seems to have split lines, purely by luck.)

I can now use control-I to insert nodes again!</t>
<t tx="ekr.20071028032929.1382">This is similar to the double-click logic!</t>
<t tx="ekr.20071028032929.1383">We must compute the word to be selected before the Tk.Text widget does its default double-click handling, then actually select the text at idle-time.</t>
<t tx="ekr.20071028032929.1384"></t>
<t tx="ekr.20071028032929.1385">The code was easy to write and worked the first time.  I love Python.  I chose to ignore case in the comparison.

A more elegant solution would be to define a v.__cmp__ method, but the present code is clear enough and works.</t>
<t tx="ekr.20071028032929.1386">Fixed the Tangle Marked command.  It had numerous problems.

The code that executes Leo_done.bat and Leo_un.bat didn't work.  Now these options specify Python scripts to execute, and these scripts are passed a list of filenames that were tangled or untangled.</t>
<t tx="ekr.20071028032929.1387">Created go.bat and openLeo.py.  These simplify the process of starting leo.  Just open a console window and type go.

Added "c:\prog\LeoPy\LeoPy.leo" as default to filename argument to leo.open().</t>
<t tx="ekr.20071028032929.1388"></t>
<t tx="ekr.20071028032929.1389"></t>
<t tx="ekr.20071028032929.1390">The whole-word search only fails if there are two consecutive "in-word" characters at the beginning or end of the supposed match.

Added some logic to make suboutline-only searches work correctly.

In the process, discovered a bug in is_c_id.  It was testing for blank instead of underscore!</t>
<t tx="ekr.20071028032929.1391">tree.select now calls tree.recolor_now instead of tree.recolor.  The result is much better than before.

Did add the tree.updateScheduled ivar and logic.  This ensures that only one redraw ever happens at idle time.  It seems like the body text is drawn much faster now.  This may have been a big performance bug!

At present the performance of leo.py seems excellent.</t>
<t tx="ekr.20071028032929.1392">When the "Move Down" command did nothing the control-d ate the character at the cursor!  The workaround is to have c.moveOutlineDown call c.selectVnode(v) even if nothing happens.  This forces the body text to be restored.</t>
<t tx="ekr.20071028032929.1393">c.makeVisible and even c.beginUpdate/c.endUpdate can be eliminated!  Indeed, the tree class can work as follows:

1. All ancestors of the current node are expanded at the start of tree.redraw.
2. The current node is scrolled into view at the end of tree.redraw.

We want to do the expansion of nodes before drawing so offsets are computed properly.  We must do scrolling after idle tasks are complete so Tk.Scrollbar.get() will return proper values.

Note: we still may want to inhibit drawing even though all drawing happens at idle time.  We don't really need begin/endUpdate to do that:  just keep a flag and call c.redraw() only if the flag is true.

I'm not going to eliminate c.beginUpdate/c.endUpdate just yet.</t>
<t tx="ekr.20071028032929.1394"></t>
<t tx="ekr.20071028032929.1395">Eliminated redundant error messages.
All path problems now generate an error.  This seems safest.</t>
<t tx="ekr.20071028032929.1396">tree.makeVisible and tree.scrollTo are called before the tree is redrawn, so we can't get accurate measurements from the canvas class.  I created tree.yoffset() and tree.lastVisible() to get proper measurements.  The final code is deceptively simple; it took several hours to get it all right.

This is an important step forward because now the screen is drawn properly during interactive search commands.  It would have been intolerable to release Leo with only partly functional Find commands.

There are still "policy" questions about when and how to scroll.  The present code doesn't work smoothly in all cases.  It may be that the Tk.canvas.yview routine doesn nothing in certain unexpected situations.</t>
<t tx="ekr.20071028032929.1397">I have spent several pleasant hours preparing setup.py, manifest.in and sdist.bat.

Create a source distribution (.zip file) by running sdist.bat from c:\prog\LeoPy.

I have not been able to create a .gzip file yet.</t>
<t tx="ekr.20071028032929.1398"></t>
<t tx="ekr.20071028032929.1399"></t>
<t tx="ekr.20071028032929.1400">There was an assignment kind = kind in the section &lt;&lt; set kind for directive &gt;&gt;, so @chapter, @section were never recognized.  Amazingly, this blunder did not seem to affect anything else.

With this this bug fixed, all files in LeoCB.leo are tangled the same by LeoCB and leo.py, except for the first line and whitespace.  The first line is different because LeoCB puts slashes differently than leo.py.

When ignoring only trailing whitespace and blank lines, we see that LeoCB and leo.py differ in how they output (!newline).  LeoCB outputs a single space before (!newline) in put_section(), so this is what leo.py must do as well.

With this bugs fixed, the only differences between LeoCB.leo and leo.py involve leading and trailing whitespace and blank lines.  Tangle works!  Actually, leo.py now does a better job than LeoCB, for the following reasons:

1. leo.py does a good job of deleting trailing blank lines in sections, and this should simplify Untangle.
2. leo.py does a better job of putting leading whitespace than LeoCB, because leo.py more accurately computes the effective width of leading whitespace than does LeoCB.</t>
<t tx="ekr.20071028032929.1401">This allows us to open a file when leo starts.  From the Python interpreter do the following:

import leo
fn = "c:\prog\LeoPy\LeoPy.leo"
leo.open(fn)

The open script is the companion to the run and go scripts.  leo.run() just runs leo.  leo.go() reloads all modules before running. For reasons that I don't fully understand, leo.go() does not always handle leoUtils properly: it is sometimes necessary to do

from leoUtils import *</t>
<t tx="ekr.20071028032929.1402">Actually, clicking on another node should probably reset the "wrap_node", but it doesn't.  Only changing something in the Find panel does that.</t>
<t tx="ekr.20071028032929.1403">Tested paths when Leo invoked directly.
Tested explicit paths in @file nodes
Tested paths in prefs panel.
Tested paths in @path directive.
Tested no path anywhere.

As a result, changed writeError by error in atFile.scanAllDirectives.</t>
<t tx="ekr.20071028032929.1404">frame.defaultDirectory was never being used.</t>
<t tx="ekr.20071028032929.1405"></t>
<t tx="ekr.20071028032929.1406">It appears that putting the following in app.finishCreate will work:

	import leo
	loaddir = os.path.dirname(leo.__file__)

Apparently we can not reference leo.__file__ reliably until leo has been completely imported.  The workaround is to do so in app.finishCreate.  This is a bit mysterious, and it appears to work.</t>
<t tx="ekr.20071028032929.1407">The new path philosophy is as follows:

1. Leo will not call os.chdir except possibly after file dialogs that are not cancelled.  This will leave the file system's current directory (returned by os.getcwd()) unchanged by tangling, importing, reading or writing.

2. Commands that access files (tangling, untangling, reading, writing, importing) call either os.getcwd(), atFile.scanAllDirectives or tangle.scanAllDirectives to set appropriate ivars indicating what the proper default directory will be.

3. These commands open a file as follows, where self.default_directory is set in step 2:

	fn = os.path.join(self.default_directory, fileName)
	f = open(fn,...)</t>
<t tx="ekr.20071028032929.1408">@file trees were not being marked as dirty when cloned headlines outside those trees were changed.  This definitely would have caused errors while reading @file trees!  Fixing this bug is a big step forward.

The fix was to to have v.setDirty() ensure that all cloned nodes are set dirty and that all ancestor @file nodes are set dirty.  I eliminated v.setDirtyJoined() entirely, and eliminated all calls to v.setAncestorAtFileNodeDirty() outside of v.setDirty().  The result is much safer, cleaner and simpler code.

As a side effect, nodes now become dirty when they move.</t>
<t tx="ekr.20071028032929.1409">leo.py used to call chdir from many places to indicate which default directory should be in effect.  That was wrong. From now on, leo.py will call chdir only file dialogs return without being cancelled, that is, for Open, Save and Import commands.

Otherwise, directives will set ivars, and the code will compute full path names using
os.path.join(directory_ivar, pathname).  The neat thing about this is that if pathname already contains a full path name it will override the path in directory_ivar.

For example, the Tangle code now writes the final file like this:

	file_name = os.path.join(self.tangle_directory,section.name)
	... # tangle into temp file
	update_file_if_changed(file_name,temp_name)

This works properly whether or not section.name contains a full path name.</t>
<t tx="ekr.20071028032929.1410">If the present node is expanded, the Paste Nodes command now pastes the pasted node as the first child of the present node, rather than as the next sibling of the present node.</t>
<t tx="ekr.20071028032929.1411">trace(a) prints a if s is a string and executes a() if a is a function.</t>
<t tx="ekr.20071028032929.1412">The symptom of the bug was that it was taking a _long_ time to close windows after doing many interactive find commands.  Actually, it was redrawing the tree that was the real problem.

Disable the recycling of nodes made no difference.  By removing code I isolated the performance bug to the call to tree.redraw in find.showSuccess().  This was very good news, as it meant that the bug was in the tree code rather than in Tk or Tkinter.

The bug was caused by "extra" links to the Tk.text widgets in the vnode, specifically, the v.box_id, v.edit_text_id, v.icon_id and v.box_id ivars.  These links apparently created permanent references that prevented widgets from being deallocated when the tree was redrawn, so a large number of widgets and their binding had to be deleted when the tree was deleted.

The fix was just to eliminate these vnode ivars entirely: they were not being used!  The v.edit_text ivar could not be eliminated, so I added a call to self.edit_text.destroy() just before reallocating.  Perhaps just moving the edit_text would be better than destroying and reallocating it, but that wouldn't be so easy because of the call to self.canvas.destroy("all").</t>
<t tx="ekr.20071028032929.1413">If a clone problem is reported, the @file node is not marked dirty again, so if we save the .leo file and then quit the problem will still exist in the derived file.

This happened in Borland Leo, so it is clear if it is a problem in leo.py.

I recovered by doing a Read Outline Only.</t>
<t tx="ekr.20071028032929.1414"></t>
<t tx="ekr.20071028032929.1415">Moved Tangle utils into Tangle leoTangle.py.  These should be methods because they deal with tangle ivars.

Separated utils that call scanError from other utils.</t>
<t tx="ekr.20071028032929.1416"></t>
<t tx="ekr.20071028032929.1417"></t>
<t tx="ekr.20071028032929.1418">This happened after deleting a clone outside of the tree for @file leoColor.py.  I am not sure of the exact sequence.  Perhaps LeoCB was involved.</t>
<t tx="ekr.20071028032929.1419">This was pretty easy.  I think underlining hyperlinked section references looks good.

Still to do:

1. We need browser-style navigation: forward, up, back, home.

2. We may have to change things for Leo1.</t>
<t tx="ekr.20071028032929.1420"></t>
<t tx="ekr.20071028032929.1421"></t>
<t tx="ekr.20071028032929.1422">I finally realized why c.redraw and c.endUpdate wiped out the edit status:

1.  tree.redraw does not preserve the edit status (it probably should)
2.  tree.redraw only causes queuing of the redraw.  It doesn't happen immediately.

This was causing problems in find.show_success.  My quick fix was to create tree.redraw_now, and then to restore the status as needed.  Another, probably better, way would be to have tree.redraw restore edit status.  Duh.

However, in this case tree.redraw_now is exactly what is needed, so I feel a bit less stupid...</t>
<t tx="ekr.20071028032929.1423">There are a huge number of details to get exactly correct.  It appears that the code is close to working.</t>
<t tx="ekr.20071028032929.1424">I finally realized that v.edit_text is defined only if v is visible on the screen, that is, only if all of v's ancestors are expanded.</t>
<t tx="ekr.20071028032929.1425"></t>
<t tx="ekr.20071028032929.1426">Previously, cloned headlines were not updated in unison.  This could have been the source of some apparent "lost data".  It is remarkable how complex this logic is.

I finally chose to do a redraw in tree.endUpdate() to force headlines in synch.  We can't typically just do a redraw() in idle_headline because that messes up the editing state of v.edit_text.

I also fixed a bug in idle_body that caused control-Q to call c.setChanged() again.  The new code just sees whether the code has caused the text to change: it does not need the value of ch to do that.

idle_headline also now handles all details of marking nodes dirty.  This used to be done partly in undimHeadline.</t>
<t tx="ekr.20071028032929.1427">I made terrible blunder: I eliminated a commands ivar that was involved in writing, so the write failed and wiped out the .leo file.  Since I didn't have a recent backup .leo file, I lost todays notes.

Let this be a lesson to myself:

1.  Backup .leo files _are_ useful for backing up ouline only data.
2.  Make backup of entire LeoPy folder when there are problems.  I came very close to all of today's programming work, which would have been hard to bear.</t>
<t tx="ekr.20071028032929.1428"></t>
<t tx="ekr.20071028032929.1429">We don't need to keep track of the status of control or alt keys!  Instead, we let idle_body_key and idle_head_key compare the old with the new value.  They do nothing on a match.

An important point:  idle_body_key must make sure that v == c.currentVnode.  If it doesn't make this check we will lose data when the user types Control-K to create a new node.

The new code also takes care not to allow any newlines in headline text.</t>
<t tx="ekr.20071028032929.1430"></t>
<t tx="ekr.20071028032929.1431">This code is _vastly_ superior to the Borland code, for several reasons:

1.  Unlike the Borland code, the Python code uses no "state" variables.  This not only greatly simplifies the code, it makes it possible to restart incremental searches after the user has changed nodes or changed postion in body text.

Instead of using state variables in the find class, the code uses the c.currentVnode and the "insert" and "sel" tags of the Tk.text widgets.  This automatically ensures that the state of the search matches the state of the outline and body panes!

2. At last!  I know how to restart incremental searches without using state variables.  The trick is _not_ to call c.endEditing() in the setup routines, so set_in_headline() can use c.tree.editVnode to see if we are editing a headline.  If so, we start there.  OTOH, select_next_v _does_ call c.endEditing() and c.editVnode() to force c.tree.editVnode to have the proper value.

3. Leo now uses Tk.Text widgets for both headline and body text.  This eliminates all the special case code that selects between headline and body searches.  Moreover, the same regular expressions are now used for searches in both headlines and body text.  I doubt I could ever have produced bug-free code without this simplification.</t>
<t tx="ekr.20071028032929.1432">This hugely simplfies the find/change commands, and makes them more capable.

This also solves the "Control-K" problem in headlines.</t>
<t tx="ekr.20071028032929.1433"></t>
<t tx="ekr.20071028032929.1434">The ensure_extension routine was adding a .leo extension, thereby defeating the test for an empty file name.</t>
<t tx="ekr.20071028032929.1435">This code is much cleaner than the Borland code.  The search commands keep almost no state variables now: we always search from the present location.  This hugely simplifies the logic, and makes the code do what is expected more often.

In particular, is no longer any "first_v" or "first_position" state.  The various find and change commands will save the present state on entry, and restore that state if no finds are found.  This "local" save/restore makes much clearer what is happening.

Still to do: searching in headlines.</t>
<t tx="ekr.20071028032929.1436">The save message immediately showed a Save bug.  After doing a Save To, a following Save command used the Save To file name!  This explains why some saves "didn't take".</t>
<t tx="ekr.20071028032929.1437"></t>
<t tx="ekr.20071028032929.1438"></t>
<t tx="ekr.20071028032929.1439">This probably should depend on the size of the window, and at present it does not.</t>
<t tx="ekr.20071028032929.1440"></t>
<t tx="ekr.20071028032929.1441">I have a new toy: Python's exec statement.  This allows one to have all the flexibility found in tcl scripts.  For example, one can treat the name of variables as variables themselves.  Building statements from strings isn't quite as simple as in tcl, but the effect is exactly the same.

The added flexibily is useful when loading and saving many variables, as in the prefs and find code.  For example:

ivars = [ "tangle_batch_flag", "untangle_batch_flag",
	"use_header_flag", "output_doc_flag",
	"tangle_directory", "page_width", "tab_width" ]
	
for var in ivars:
	exec("self." + var + " = c." + var)  # self.var = c.var
	
This exec statement expresses the pattern directly.  Moreover, once the ivars list is defined many similar exec statements are possible.  Using the % operator might be even clearer:

	exec("self.%s = c.%s" % (var,var))</t>
<t tx="ekr.20071028032929.1442">This is tedious code, and Tk makes it much simpler than with other systems.</t>
<t tx="ekr.20071028032929.1443"></t>
<t tx="ekr.20071028032929.1444">Replaced global with app().idle_imported.

Replaced global with fileCommands..  This fixed a big memory botch: previously a new dummy vnode was allocated for every vnode created!

Replaced es_newline global with app().log.es_newline, i.e., frame.es_newline.  This is better than before because each log stream has its own count.</t>
<t tx="ekr.20071028032929.1445">These allow us to reclaim memory when closing a window.  It also showed a that we are wasting lots of space allocating dummy vnodes in the read logic.

With these routines in place, all __del__ routines are eventually being called, which indicates that all circular references are being destroyed by the destroy() routines.  Note that it is _not_ necessary to do any of the following:  del v, del tree, del commands or del frame.  Setting the pointers to None is enough.

Added tree.vnode_alloc_list.  v.__init__ adds items to this list.  tree.destroy removes items from this list.  This is an elegant and powerful solution: all vnodes will be reclaimed eventually, and we don't need to worry about reclaiming them while the window is open.  In particular, this avoids all problems with undo.

Added two new app() ivars to control memory management and tracing.
	self.deleteOnClose	# true: delete all frame objects when a frame closes.
	self.printDel		# true: enable prints in __del__ routines</t>
<t tx="ekr.20071028032929.1446">The frame dtor is never being called because (I think) of circular references throughout the vnode, commands and frame classes.  There are several possible approaches:

1.  Ignore the problem completely.  This makes a lot of sense, for several reasons.
	A: Memory is not an issue, and reclaiming memory at termination time doesn't help!
	B: Memory reclamation can legitimately be called a Python implementation issue.
	C: It takes time and memory to reclaim memory.
	D: Errors in reclaiming memory can lead to intermittent crashes.
	
2.  Create destroy() routine for vnodes, tnodes, commands and frames.  These routines would eliminate links between nodes, thereby freeing Python's references.  The frame.destroy() routine would also call self.top.destroy() to force the closing of the frame's window.  The destroy() routine would also do a del self to reduce the reference count of the object.

Note:  deleting vnodes and tnodes is tricky because of undo.  By far the safest course of action is never to delete these nodes until a window closes.  The easy way to do this is put every vnode in a vnode allocation list, an ivar of the tree class.  Calling tree.destroy() would do the following:

	for v in self.vnode_alloc_list:
		v.destroy()
		del v
		
With this structure in place, the __del__ routines would do nothing.  We could insert a print statement in the routines to show when the routines are actually called.  This would indicate whether circular references remain.</t>
<t tx="ekr.20071028032929.1447">The old code marked the loading headline as changed.  Added c.loading ivar to disable update of window title during loading.</t>
<t tx="ekr.20071028032929.1448">This happens when a save is quickly followed by a quit.  I can get this error when in the Python window, which is reassuring, I suppose.

frame in app().windowList trick doesn't work: very weird.

I enclosed the code in idle_redraw() in a try/except block.  I'm not sure whether this will cure all problems, but it seems like it should.</t>
<t tx="ekr.20071028032929.1449">The old code never got around to deleting the frame, tree and commands objects.

However, del self just decrements the reference count; it does not guarantee that self.__del__ is called.  In fact, it doesn't seem that __del_ is _ever_ called!  So much for cleaning up memory.

There may be a bug here, or perhaps this is just a weirdness of usint Tk or Tkinter.  At this point I haven't a clue.</t>
<t tx="ekr.20071028032929.1450"></t>
<t tx="ekr.20071028032929.1451">This is a strange one.  The problem happens when a save is quickly followed by a quit.  It appears that there is a fault in idle_redraw(), even when the code is locked out with if self in app().windowList.  This is very weird.  Even stranger is that the error traceback never happens when the Python window is opened first (so it stays open).</t>
<t tx="ekr.20071028032929.1452"></t>
<t tx="ekr.20071028032929.1453">Tested c2py.leo1to2() on LeoCB.  The script now works on both Borland and leo.py.

There is a problem with the v.commands method on Borland. The workaround was to pass the value from top() to convertLeo1to2(v,c).</t>
<t tx="ekr.20071028032929.1454"></t>
<t tx="ekr.20071028032929.1455">Once again, I am making faster progress with Python than expected.  Amazing.</t>
<t tx="ekr.20071028032929.1456">I just imported idle and voila: the IDLE IDE is available!

I did have to add r"c:\Python21\Tools\Idle" to sys.path.  I also removed the wxPython stuff from the path: they interfered with the include.

I added a few top-level functions to leo.py that were described in the scripting documentation.

I added the public commands and vnodes methods described in the scripting documentation.  Several of these routines had names that conflicted with ivars.  In those cases I changed x to mX.  The changed vnode ivars were back, firstChild, headString, next and parent.

I also added several vnode and commands methods that were described in the documentation but that did not presently exist.  Like c.findRoot, c.currentVnode, etc.

The script c2py.convertLeoTree(v) appears to work, so leo.py appears to be largely compatible with scripting in LeoCB.</t>
<t tx="ekr.20071028032929.1457"></t>
<t tx="ekr.20071028032929.1458"></t>
<t tx="ekr.20071028032929.1459">I spent almost an entire day messing with focus issues.  There are two choices:

1.  If tree.bodyKeepsFocus is true the body pane will always have focus unless we are editing a headline.  The current headline is highlighted in grey to indicate the tree has no focus.

2.  If tree.bodyKeepsFocus is false the body pane will not have focus if we select a headline by clicking on it.  In that case the curren headline will be white text on a dark blue background.  When focus shifts to the body pane, the current headline will be greyed.

After much experimentation, it seems that the first way is more convenient, though slightly less accurate as far as visual protocol goes.  I think the convenience of having focus in the body pane (where it is useful) outweighs the small visual incongruity of having the current headline be grayed even when the tree canvas is selected.

Warning: Using frame.getFocus() is much less good than using the tree.active flag, because we can edit a headline with at most two clicks.  That is not true when using frame.getFocus()

The bodyKeepsFocus logic affects all routines that alter the highlighting of headlines.</t>
<t tx="ekr.20071028032929.1460">Changed OnCloseLeoEvent so it returns not veto.</t>
<t tx="ekr.20071028032929.1461">TThe body handler didn't call setDirtyJoined.  Changed setDirtyJoined so it returns a redraw flag.</t>
<t tx="ekr.20071028032929.1462">Added virtual_event_name utility to generate &lt; &lt; name &gt; &gt;.  Sigh.

The OnCut, OnCopy and OnPaste routines just call the body key event handler to do syntax coloring and set the various dirty/changed bits.

There is a small glitch: choosing cut/copy/paste "by hand" from the menu doesn't work when the focus is in an edit label in a headline.  I'm not sure how to fix this and it is extremely minor anyway.</t>
<t tx="ekr.20071028032929.1463">Added v param to tree.recolor so we don't assume that v is the current vnode.</t>
<t tx="ekr.20071028032929.1464"></t>
<t tx="ekr.20071028032929.1465"></t>
<t tx="ekr.20071028032929.1466">I tried several options, with no luck: selectborderwidth, selectbackground, selectforground.</t>
<t tx="ekr.20071028032929.1467">Added code to leo.py to set the window icon.  Alas, the documentation is poor enough so that I don't know what the arguments to iconbitmap should be.</t>
<t tx="ekr.20071028032929.1468">I tried a lot of experiments in fileCommands.getGlobals(), and it is still not possible to set the height and width of the top level window properly.  It is still too large, and its size does not depend on the requrested width.

Note that the size of the window is set in createSplitter, by setting the size of a Frame object.  Perhaps this is interfering with matters.

The present situation is poor, but tolerable.</t>
<t tx="ekr.20071028032929.1469">Changed bd="2m" to bd=2.  This makes a big difference in how the panel looks.</t>
<t tx="ekr.20071028032929.1470">The syntax colorers can use tag_config to show tabs and spaces.  This isn't perfect (it doesn't look good now) and does not work for newlines.  It may be better than nothing, however.</t>
<t tx="ekr.20071028032929.1471">I just forgot to add it to the list of @keywords.</t>
<t tx="ekr.20071028032929.1472"></t>
<t tx="ekr.20071028032929.1473"></t>
<t tx="ekr.20071028032929.1474">These "bugs" may be appearing because these commands are always enabled in the menu.  In any case, the fixes were straightforward.</t>
<t tx="ekr.20071028032929.1475">The problem was that the body key handler was being scheduled before the new node was inserted and being called at idle time after the new node was inserted, so the body text disappeared.  The fix was to disabling scheduling if control or alt keys are down.</t>
<t tx="ekr.20071028032929.1476">All it took was the following:

font = tkFont.Font(family="Courier",size=9)
tabw = font.measure("    ")
self.body = body = Tk.Text(...font=font,tabs=tabw...)

This hard codes tabs as 4 spaces.  Later I'll make it more general.</t>
<t tx="ekr.20071028032929.1477"></t>
<t tx="ekr.20071028032929.1478">I am getting closer to getting the look of the splitter panes just right.  Setting bg="white",relief="flat",bd=0 in createSplitter helps quite a bit.

The problem with the tree pane is clearly in the Canvas widget.  If that widget is not packed the pane looks fine.  There seems to be no way to eliminate the canvas's border, and no way to prevent the border from being overwritten by the Entry widget.

Maybe there is a way: the problem may be that Entry widgets are embedded in their own windows...</t>
<t tx="ekr.20071028032929.1479">I will use leo.py from now on to develop leo.py.  It is the only way to really get the bugs out.

Changed the code that computes the length of the edit box for headlines.  We always use len(v.headString) now.  This still does not quite work properly, but it is better.

Fixed a bug in the selection logic.  The colors for the previous headline are changed only if the previous is not the same as the current.  This can happen if we click in the icon or plus/minus icon of the current headline.

Added the v.iconx and v.icony ivars so the tree.OnHeadlineKey routine can just redraw the cursor in place if it needs to change.  This is a workaround to a problem that I haven't been able to solve: namely, how to force the cursor to be visible again after the headline loses focus.  This is more than a little kludgy, especially after creating the elegant endUpdate mechanisim.  OTOH, it may point a way towards incremental redrawing of the screen.</t>
<t tx="ekr.20071028032929.1480"></t>
<t tx="ekr.20071028032929.1481"></t>
<t tx="ekr.20071028032929.1482">Changed "darkblue" to "DarkBlue".  The colors known to Tk are listed at
	http://tcl.activestate.com/man/tcl8.4/TkCmd/colors.htm 

Changed print_stack() to Print statements in es() logic.  This was more confusing than helpful.

Eliminated some accelerators (Linux only)

Added loaddir code to leo.py.
</t>
<t tx="ekr.20071028032929.1483">Added many terms to the Glossary.

Improved description of Leo2.  Partially merged Leo1 and Leo2 documentation.  It still isn't perfect.</t>
<t tx="ekr.20071028032929.1484">Probably very few people could understand the description of Leo2.</t>
<t tx="ekr.20071028032929.1485">I fixed the "last" serious bug in this version.  What was happening was that the clone information in leoFileCommands.py and leoCommands.py was alternatively being written and not being written.  The fix was to v.joinNodeTo:  there was a bug that was fixed in the Borland version that had not been fixed in this version.</t>
<t tx="ekr.20071028032929.1486">It turns out the updateCloneIndices routines in both LeoCB and leo.py are slightly buggy.  Both can increment indices multiple times for the same tnode.  In addition, LeoCB computes indices for parts of the tree beyond the actual tree, so that would increase the indices further, which is why the LeoCB version sometimes has a larger clone indices.

Neither of these "bugs" really makes a difference.  In either case, nodes are joined properly.

To "minimize" the clone indices we would do the following:

	index = 0
	v = root
	# Zero all indices.
	while v and v != next:
		v.t.cloneIndex = 0
	# Set clone index only if it has not already been set.
	while v and v != next:
		if v.t.cloneIndex == 0 and v.isCloned() and v.shouldBeClone():
			index += 1
			v.t.cloneIndex = index
		v = v.threadNext()
		
This might be just slightly slower than the "wasteful" way.</t>
<t tx="ekr.20071028032929.1487">The directory compare routines in the Python lib do not seem to exist.  The new routines compare only .py files.</t>
<t tx="ekr.20071028032929.1488"></t>
<t tx="ekr.20071028032929.1489">The lineIndent var was not set properly in &lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;, with the result that some sections contained extra leading whitespace in their body parts.

With this bug fixed, leo.py reads and writes all files correctly!</t>
<t tx="ekr.20071028032929.1490">Fixed a bug that was causing the last newline of doc parts to be deleted.  The problem was that string.rstrip() also strips newlines!  With this bug fixed it appears that Leo.py can read and write @file nodes just like Leo2CB does.

Created the removeTrailingWs() in leoUtils that strips trailing blanks and tabs.</t>
<t tx="ekr.20071028032929.1491">Rewrote the code in scanText and scanDoc that figures out where sentinels start.

The new nextLine and nextKind vars clarify what is going on.  When a non-sentinel line is output, the trailing newline is part of a sentinel if and only if nextKind is some kind of sentinel.

I'm not convinced the code in scanDoc is correct...

</t>
<t tx="ekr.20071028032929.1492">This is a very useful comparison tool.  It allows me to compare whitespace easily.</t>
<t tx="ekr.20071028032929.1493">This puts up a model dialog.  The hardest part was writing the code that centers the dialog on the screen.  Sheesh.</t>
<t tx="ekr.20071028032929.1494">I fixed many minor problems in preparation for releasing the first usable version of Leo.py.</t>
<t tx="ekr.20071028032929.1495">These bugs were simple transcription errors; they do not occur in LeoCB.

v.childIndex() was always returning 0, so naturally v.createDependents() was not working well.

Added a call to v.unlink() in v.destroyDependents.  The call to v.destroyTree() no longer does anything.</t>
<t tx="ekr.20071028032929.1496">We no longer need setIcon!!  Indeed, setIcon just calls c.redraw(), so as long as the callers enclose code in beginUpdate/endUpdate all will be well.  This eliminates a _major_ mess, and will result in further simplifications: we no longer need the distinction between the setX and initX routines!</t>
<t tx="ekr.20071028032929.1497">It turned out that tree.idle_body_key was the bottleneck, _not_ syntax coloring!

What was happening was this:  tree.redraw was being called on _every_ keystroke, and that was causing a huge amount of memory allocation and deallocation.  After a while everything ground to a halt.

The fix was very clever: I added a flag to c.endUpdate and tree.endUpdate, true by default.  tree.redraw is called only if count==0 and flag==true. So calling endUpdate(false) prevents all redraws from happening in a range of code.  This is a wonderful addition to the beginUpdate/endUpdate pattern.

Both tree.idle_body_key and v.setAncestorAtFileNodeDirty use this pattern.  The result is that tree.redraw() is called only when the icon really and truly must change.
</t>
<t tx="ekr.20071028032929.1498">Amazing.  I wrote some dummy code last night, read up on indices this morning, and got everything to work in a couple of hours. The result is very fast: no optimization is needed for Leo. I love Tkinter!

Added c.recolor and tree.recolor routines.  This hooks should be called whenever the body text changes.  Apparently there is no "OnTextChanged" event in Tk.</t>
<t tx="ekr.20071028032929.1499">Implementing this was trivial: we use a app.clipboard ivar, a string.  Using an internal clipboard means that we can't inadvertantly paste the XML representation of a string into body text.</t>
<t tx="ekr.20071028032929.1500">The only major step left before releasing a functional version of Leo is to check the @file write code.
</t>
<t tx="ekr.20071028032929.1501">The Tk clipboard handling is confusing: there are routines for clearing and setting the clipboard, but no obvious way to get the contents of the clipboard.  I could use an internal clipboard (part of the LeoApp class) for leo nodes, which would work pretty well.  If I did that I might want other commands: cut, copy and paste between node clipboard and the text widgets...

There doesn't seem to be any Python support for the clipboard, which is weird.</t>
<t tx="ekr.20071028032929.1502">This is a tedious task, no matter how it is done.</t>
<t tx="ekr.20071028032929.1503">Simplified the code that sets the current vnode and initializes icons.  Having tree.redraw update icons automatically helps a lot.

Added tree.initing hack to disable endEditLabel from marking the tree as changed. Actually, this probably isn't necessary, as top.title probably won't be redrawn until idle time anyway.</t>
<t tx="ekr.20071028032929.1504">Here is how to get accelerators working:

fileMenu.add_command(label="New", accelerator="Ctrl+N", command=self.OnNew)
self.top.bind("&lt;Control-n&gt;", self.OnNew)

Warning: using top.bind_all would not work well with multiple windows.

The accelerator="Ctrl+N" option merely sets the menu text(!).  The bind_all method actually does the work.  BTW, I had to change (self) to (self,event=None) in all the command handlers.  When an accelerator is used the handler is called with two args.  When the menu is used the handler is called with only one arg.

IDLE shows how to be a bit more clever with initialization.  I probably should study the Idle code and be clever ;-)  IDLE also use the configuration data base, and I probably should study that too.</t>
<t tx="ekr.20071028032929.1505">There are now just two routines, v.computeIcon() and v.setIcon().

v.setIcon just does c.tree.redraw() (!)

c.tree.redraw() now does nothing if the update count &gt; 0, so this is safe. Moreover, we can now enclose any code in c.beginUpdate()/c.endUpdate() without worry.

This is the way it is written in the Book.</t>
<t tx="ekr.20071028032929.1506">The &lt;Key&gt; event is called _before_ the body text is updated, so it is not possible to properly update syntax coloring, icons or tnodes there.  Instead, the &lt;Key&gt; event handler just registers an idle-time event to do the real work.  Very simple!</t>
<t tx="ekr.20071028032929.1507">The canvas widget appears to have an improper 1 or 2 pixel gray border.  I have worked around this by limiting the size of the Tk.Entry widget: expanding it only when editing is enabled.</t>
<t tx="ekr.20071028032929.1508"></t>
<t tx="ekr.20071028032929.1509">Following the IDLE code lead me astray.  IDLE does not allow the headline text to be edited!  At last some of the confusion is gone.</t>
<t tx="ekr.20071028032929.1510">openWithFileName now shows the window before loading, so that reading messages become visible.  To do this, we call app().root.update().

Made leoFrames bigger: this is done in createSplitter(!)</t>
<t tx="ekr.20071028032929.1511"></t>
<t tx="ekr.20071028032929.1512">We close the initial open window if it has not been changed.

app.quit() now closes the hidden root window to close the app.

Close processing now calls the close event handler.

There are no bugs as in wxWindows!  Everything is straightforward.</t>
<t tx="ekr.20071028032929.1513">I have rewritten the code to draw the tree, and it seems to work reliably.  However, expanding an entire tree is slow, and redrawing the tree is also slow is many nodes are visible.  I'm not sure what is causing this...

Disabling drawNode speeds up the redraw greatly.
Disabling only tags also speeds up the redraw greatly.  Indeed, way too many tags appear to be created...

Still to do: I have not been able to create edit windows in the canvas properly...</t>
<t tx="ekr.20071028032929.1514">I'm not sure whether Tkinter can read .bmp icons, so I created .gif icons, which work well.</t>
<t tx="ekr.20071028032929.1515">Rewrote v.restoreOutlineFromDVnodes.  It is now very simple because undo no longer creates dvnodes; vnodes now contain all tree information.  So when we "delete" a tree we just unlink and unjoin it, and when we "restore a tree we just relink and rejoin it.  It is truly amazing how simple the tree code now is.</t>
<t tx="ekr.20071028032929.1516">It now takes about 3 seconds to read this file, rather than the 9+ seconds needed by wxPython!  Apparently the wxPython tree class was very slow.

The _old_ bottleneck was as follows:
	Most of the time is spent in atFile scanning code
		.. c.clearAllVisited is very slow(!!) because it clears the entire tree.
			c.clearAllVisited takes about 1/3 time of the entire scanning phase (!!)
		.. Reading the file itself, is very fast, scanning in atFile::read is slow.
		.. es calls are fast.
</t>
<t tx="ekr.20071028032929.1517">A milestone.  It is now possible to read a .leo file and to draw the tree at least partially.  Most of the conversion to Tkinter has now been completed.

I removed vnode and commands getters that merely returned ivars.  Also converted wxWindows calls to Tk calls.  It is remarkable how easily the changes went.  
</t>
<t tx="ekr.20071028032929.1518">Converted all Tk prototype code to Tkinter.  It was straightforward for the most part.  The Leo window works: scrollbars work and the text panes work.  However, the tree pane is a text pane at present.

Copied menu code from Leo.py version 0.04.  Somehow the old code was lost, I have no idea why.  The copied code is wxWindows code, so it will have to be rewritten for Python.  Still, it is much easier to use the properly converted Python code.  Perhaps I deleted the code thinking that it would all have to be rewritten.  If so, that was a minor mistake.</t>
<t tx="ekr.20071028032929.1519"></t>
<t tx="ekr.20071028032929.1520">The use_tk global indicates whether Leo will use wxPython or Tkinter.  The next step is to transliterate the Tk code that creates the Leo window into Tkinter.</t>
<t tx="ekr.20071028032929.1521">After much experimentation, adding a -padx param to the log window pane seems like the only way to handle the width of the vertical scroll bar.  Without this extra padding, the scroll bar obscures the left edge of the log window.</t>
<t tx="ekr.20071028032929.1522">It simplifies and speeds up the code to use file.readline to process lines as a unit.  This way I never have to scan to the end of a line.  However, it turns out that scanning is not really the bottleneck.  In addition, we no longer read entire derived files into memory at once.

BTW, it may be possible to use readline() in the getLeoFile logic as well.  I have no idea whether this would help or not.

The problem is the _second_ half of atFile::read, that is, after the derived file has been completely scanned and all vnodes have been created!  Apparently, something (maybe shouldBeClone?) involved with setting bits is horribly slow.  I'm not sure why earlier testing didn't show this problem.  I must have been mistaken somehow in my earlier conclusions.

This actually is very good news.  It means that the raw file code is good enough as it is.  Note:  reading derived files will not slow down when I switch to Tk because we don't create vnodes unless there are file errors!

I have just found that a single call to c.clearAllVisited() in read() _substantially_ slows down the read!  Amazing.

Create v.clearVisitedInTree() and v.clearAllVisitedInTree()</t>
<t tx="ekr.20071028032929.1523">@nocolor
@ignore

This is a _very_ easy class.

Ivars
	self.root: the root vnode
	self.update: update count
		tree::beginUpdate increments.  tree::endUpdate decrements.
		Disable redraw if &gt; 0
		Redraw when falls to 0.
	self.selected: the selected vnode
	self.top the top vnode on the screen (needed?)

Tree methods know about vnodes(!) Greatly simplifies both tree and vnode classes.
tree:endUpdate does nothing if self.update &gt; 0
	User code should not call tree::redraw directly.
	Most tree methods call redraw
Insert methods create a vnode, set links and redraw.
Move methods just set links and redraw
Commands methods enclose complex operations in tree.beginUpdate/endUpdate, as they do now.
tree::delete(v) just unlinks v's tree
	vnodes are not deleted until window goes away: unlimited undo!
	v.threadNext ivar makes deleting a list trivial.

vnodes

vnodes contain headString, expanded, firstChild, parent, back, next and threadNext ivars
	tree::getThreadNext() used to set v.threadNext
	no need for dvnodes: vnodes contain all undo info!


		</t>
<t tx="ekr.20071028032929.1524">added use_tk constant in leoGlobals.</t>
<t tx="ekr.20071028032929.1525">es now outputs a newline, which makes most uses of enl and ecnl superfluous.  We can do this be string concatenation is so easy.</t>
<t tx="ekr.20071028032929.1526">There was a transliteration error in computing the line to be output which mangled long lines.</t>
<t tx="ekr.20071028032929.1527">This code has not been tested.</t>
<t tx="ekr.20071028032929.1528">There was a bug in sentinelKind.  skip_c_id won't handle @@, so @@ must be handled separately.</t>
<t tx="ekr.20071028032929.1529">It is not possible to access global _variables_ using from leoGlobals import * because that creates copies of the data.  The new way is simpler and more modular.

Revised how the prefs panel works.  The new code just sets the prefs ivars.  It is up to the caller to access the prefs panel as needed. Added tab_width preference and prefs.tab_width ivar.  This should have been done long ago.</t>
<t tx="ekr.20071028032929.1530">Fixed problems with at_xxx_ptr globals.  The problem that from leoGlobals import * doesn't work, so I changed is_special_bits so it returns a dictionary containing name:value pairs rather than setting globals.

Fixed many problems in scanAllDirectives involving paths.  Also rewrote the code in atFile::write that opens files.

At this point leo.py can read and write files except files containing @first.
</t>
<t tx="ekr.20071028032929.1531">.. initAllCloneBits had several errors.
.. self.structureErrors wasn't being initialized in atFile::Read
.. createNthChild must mark nodes as visited to suppress unvisited node logic later.
.. Added log messages any time self.structureErrors is incremented in createNthChild

At this point leo.py can read a simple test file properly, except files containing @first.</t>
<t tx="ekr.20071028032929.1532">It wasn't too hard to create a proper splitter window.  After that, creating a Leo window was trivial.</t>
<t tx="ekr.20071028032929.1533"></t>
<t tx="ekr.20071028032929.1534">I am beginning to think that globals should _never_ be used.

The @language bug appears to be a problem of not setting globals properly.</t>
<t tx="ekr.20071028032929.1535"></t>
<t tx="ekr.20071028032929.1536">Added assert in tnode::setTnodeText that we are getting a string.  This assert was not always true before I added a call to listToString in &lt;&lt; copy new_out to child's body t't' in scanText.</t>
<t tx="ekr.20071028032929.1537">The read code is slow.  I'll have to see why.

3 seconds with read doing nothing (reads leoPy.leo)
5 seconds with read reading files but not scanning them.
9 seconds with read fully enabled.

Therefore:

3 sec to read and scan LeoPy.leo
2 sec for reading all derived files
4 sec to scan all derived files.

So scanning derived files is pretty slow.

BTW, LeoCB can do everything in about 2 sec.
</t>
<t tx="ekr.20071028032929.1538">There was the usual assortment of minor problems.

.. The write code was writing flags using `flag`, and this fails if false is None.
.. Added code to make sure None is never passed to wxFileDialog as a file name.  I wonder if this could have caused problems earlier.  Once again, the C++ code is shown to be radically unsafe.

.. I think false should be defined as 0, not None.  There are several advantages:

1.  not 0 == not None, so various tests work as before.
2.  `0` is very different from `None`, and this affects the file format.

I'll make this change.  Hope it works ;-)</t>
<t tx="ekr.20071028032929.1539">A major milestone:  the read command works and so do most outline commands.  It is now clear that reading a file is fast enough so that no further work is required!

The main problems today:

1.  The code must use the test: id and id.IsOk().  Failure to make _both_ tests will cause the code to fail, possibly in an unbounded loop.  This was ultimately the problem with the Move Down command:  the threadNext code didn't make these test.  I finally called wxGetThreadNext inside threadNext and that solved the problem.

2.  I added the self.changing lockout in the LeoFrame OnTextUpdate handler so that tnodes would not be erroneously updated while switching tnodes.  The new code seems simple and robust.</t>
<t tx="ekr.20071028032929.1540">A case can be made for getters of the form:

	def getX():
		return x
		
In particular, they are a reaonable place to put asserts.  However, such getters do not seem good style in Python because all ivars are public anyway.  Moreover, getters like

	def x():
		return x
		
are invalid in Python, so there is a problem.  The simplest approach seems to be to get rid of all such redundant getters, and that is what I have just done.  Note that assert's aren't so important in wxPython, because nothing bad can happen anyway.</t>
<t tx="ekr.20071028032929.1541">This was a very interesting experience, for the following reason.

1.  The weakness of a non-compiled language is that problems don't show up until code is actually executed.
2.  Python is very safe.  The only real problem are unbounded loops.
3.  In particular, the continue statement will _always_ loop in Python unless progress the loop variable is incremented.  So care must be taken when translating C for loops into Python while loops.
4.  Even without the ability to set breakpoints (which means that single-stepping is impossible in wxPython!) it wasn't too hard to trace with print statements.  Amazing.
5.  The biggest mess came with getters that return an ivar of the same name.  I'll sleep on this, and I think the thing to do is get rid of the getter entirely:  convert x.getY() x.Y.
6.  Defining constants in a class is nice: they are accessed by class name.  For example: vnode.dirtyBit.

Status:
1.  The outline is being read in correctly.
2.  The atFile::read logic hasn't been tested.
3.  The body pane (and probably all the tnode text) is not being set properly.
4.  It is possible that we might be able to get rid of join lists!  They are used:
	a) To update the headline text
	b) For shouldBeClone.
	We could replace join lists by a reference count and temporary join lists.
	This could be really cool, and I'll have to think about this more...
	</t>
<t tx="ekr.20071028032929.1542">Created leoFileCommands.py.  We use com=self.mCommands to access the "real" commander for this class.  It would be wrong to make fileCommands a subclass of Commands; we must have exactly one commander per frame so that mCurrentVnode, mRootVnode, etc. are updated properly.

In short, the ivars of fileCommands are mFrame, mCommands and any ivars used exclusively by fileCommands.  This pattern will be used to create outlineCommands.py, findCommands.py, etc.</t>
<t tx="ekr.20071028032929.1543">The info class was confusing.  All the ivars from that class now become ivars in the fileCommands class.  The mTnodes array is now a Python dict, so there is no need for the mNumberOfTnodes or mMaxTnodeIndex ivars!  The new clode is _much_ clearer.  A major victory.</t>
<t tx="ekr.20071028032929.1544">Fixed several bugs in c2py.

Greatly simplified handlePossibleFunctionHeader; there is no need to compute a delta there:  we munge the head, args and body separately, then replace the original all at once with the new lists.  This is bullet proof.

Fixed some bugs in safeReplace and matchWord.

Fixed bugs in convertCStringToPython that caused skipDoc and skipCode to be called in the wrong places.  That was really messing things up!

Tested the speed of tests by writing speedTest.  This is so much fun!</t>
<t tx="ekr.20071028032929.1545">I have been happily converting, with the help of c2py, Leo's C++ code to python.  The new code is far, far easier to understand.</t>
<t tx="ekr.20071028032929.1546">Fixed several bugs in c2py:

1. removeExcessWS was sometimes skipping past a newline, thereby removing leading whitespace in the following line.  This made it look like the code for "if", "while" and "for" was bad.

2. the function scanning code had several bugs.  Added new code to ignore "if", "while" and "for" code.  Added new code to ignore # lines (preprocessor directives).  Added the firstOpen variable to eliminate scanning later.  This is pretty tricky code.

3. Added code to replace " . " by "." and "\t " by "\t".

4. Fixed skipPastWord so it handles underscores and digits.  This helped a lot ;-)

5. @code was not always properly converted to @c.

I think I will leave c2py as is for now.  It has the following rough edges:

1.  I don't know how to break long scripts.
2.  c2py doesn't handle : initializers in constructors well; they inhibit processing of the initializer.
3.  c2py doesn't place self. in all the places it is needed.  I'm not sure there is an elegant way to do this...</t>
<t tx="ekr.20071028032929.1547">Worked on c2py.  As documented in LeoCB.leo, had to add a __cmp__ routine in leo.py so that vnodes compare equal properly.  Fixed some minor bugs in c2py.

We now have two separate routines called leo.py.  The one used by LeoCB and LeoWX is the python expression evaluator.  The leo.py in LeoPy is the top level of leo.py.

Added signed, unsigned and bool to the list of type names.</t>
<t tx="ekr.20071028032929.1548"></t>
<t tx="ekr.20071028032929.1549">Documented the theory of operation of c2py.  This is a remarkably simple program!  Converting from string to list representation turns out to be a very good choice.</t>
<t tx="ekr.20071028032929.1550">For the last two days I have been working on c2py.py.  I am totally in love with Python.  Everything is so much easier:  Automatic debugging, no declarations, no types, no compilation. Great data structures. Even without single stepping the debugging is easy.

All major aspects of c2py are now complete.</t>
<t tx="ekr.20071028032929.1551">It has been staring me right in the face.  Idle.py supports tree views and syntax coloring!  All I need do is adapt the Idle code for Leo.  The only remaining piece of the puzzle is a good splitter window (and splitter events?)
</t>
<t tx="ekr.20071028032929.1552">All menu work is now complete, with stubs for many calls to Commands routines...
The Python menu is functional.
The Find Panel can be opened.
The Find Panel can be opened.

Still to do:
	Icons for outline
	Nodes classes
	Commands classes:
		outline commands
		file commands,
		find commands,
		tangle/untangle commands</t>
<t tx="ekr.20071102162910"></t>
<t tx="ekr.20071102162910.1"></t>
<t tx="ekr.20071102162910.2"></t>
<t tx="ekr.20071102162910.3"># This was a fairly big bit of cruft.</t>
<t tx="ekr.20071102162910.4">@nocolor

Email from Terry Brown

A softish bug, but the use of findNodeInTree() in the UNL code can 
take you to the wrong place if more than one node in the tree has 
the same headString.  Patch below - can still go wrong if more than 
one sibling has the same name, but the UNL system doesn't have a 
solution for that.

An observation - the UNL jumping code will drop you as far down the 
path as it gets, i.e. you're moved to the last node that was one the 
path, even if the path ends before the last part of the UNL is 
reached.  This is ok, i.e. "this is as far as I could follow the 
UNL", the alternative would be to not move at all if the whole UNL 
can't be followed.

Cheers -Terry

anon_cvs&gt; cvs diff leo/plugins/UNL.py
Index: leo/plugins/UNL.py
===================================================================
RCS file: /cvs/leo/plugins/UNL.py,v
retrieving revision 1.14
diff -r1.14 UNL.py
183c183,186
&lt;                             p = g.findNodeInTree(c2,p,headline)
---
&gt;                             for tmpp in p.copy().children_iter():
&gt;                                 if tmpp.headString() == headline:
&gt;                                     p = tmpp
&gt;                                     break
206c209,212
&lt;                             p = g.findNodeInTree(c,p,headline)
---
&gt;                             for tmpp in p.copy().children_iter():
&gt;                                 if tmpp.headString() == headline:
&gt;                                     p = tmpp
&gt;                                     break


@color</t>
<t tx="ekr.20071102162910.5">def findNodeInChildren(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.children_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeInTree(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(c,headline):

    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findTopLevelNode(c,headline):

    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
</t>
<t tx="ekr.20071102162910.6">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4444579
By: terry_n_brown

Sure it's what I'd expect, but I don't think it's what it does?

in the directory 'misc_py', where del.leo and addWhitelist.py live:

  python /path/to/leo/src/leo.py del.leo

works, and indeed addWhitelist.py is now correctly imported
in the node '@auto addWhitelist.py' (very cool :-)

but if I cd .. and

  python /path/to/leo/src/leo.py misc_py/del.leo

I get

reading: /media/hda7/misc_py/del.leo
can not open addWhitelist.py

and an empty node '@auto addWhitelist.py'

Makes me think it's trying to load addWhitelist.py relative to the dir from
which leo was run, not the dir of the .leo file.

@color</t>
<t tx="ekr.20071102162910.7">def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    &lt;&lt; Set path from @file node &gt;&gt;
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            &lt;&lt; handle @path &gt;&gt;
            return

    &lt;&lt; Set current directory &gt;&gt;
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
</t>
<t tx="ekr.20071102162910.8"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
</t>
<t tx="ekr.20071102162910.9"># We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
&lt;&lt; compute relative path from s[k:] &gt;&gt;

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        &lt;&lt; handle absolute path &gt;&gt;
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
</t>
<t tx="ekr.20071102162910.10">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = s[j:i].strip()

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') or
    (path[0]=="'" and path[-1] == "'")
):
    path = path[1:-1].strip()</t>
<t tx="ekr.20071102162910.11"># path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
</t>
<t tx="ekr.20071102162910.12"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
</t>
<t tx="ekr.20071102162910.13">def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        &lt;&lt; Read file into s &gt;&gt;

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".js":
        self.scanJavaScriptText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
</t>
<t tx="ekr.20071102162910.14">try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
</t>
<t tx="ekr.20071102162910.15">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4445685
By: ktenney

/dir/sub/main
contains interfaces.py and configure.zcml

the @path directive works for interfaces.py

z3
@path /dir/sub/main
..@auto interfaces.py

but I find I need a node named
@auto /dir/sub/main/configure.zcml
to get that file

@color</t>
<t tx="ekr.20071102162910.16">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4446937
By: btheado

&gt; Two hacks (now on cvs) were surprisingly effective..

Thanks for the fixes.  I just tried some more code (Tcl C source again--I just
happen to have it handy on my hard drive).  It looks like the import parser
skips over ANSI style function definitions (didn't know anyone still used those).
Here are some examples files:

http://tcl.cvs.sourceforge.net/tcl/tcl/generic/tclScan.c?revision=1.12.2.2&amp;view=
markup&amp;pathrev=core-8-4-14

and

http://tcl.cvs.sourceforge.net/tcl/tcl/generic/tclObj.c?revision=1.42.2.14&amp;view=
markup&amp;pathrev=core-8-4-14

I checked the old importer and it handles the ANSI style just fine.

Brian</t>
<t tx="ekr.20071102162910.17"># The code that was removing tags was not working properly.</t>
<t tx="ekr.20071102162910.18">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4437415

Unicode characters were not handled properly.
</t>
<t tx="ekr.20071102162910.19">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4462693

@color</t>
<t tx="ekr.20071102162910.20"># This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if c:
        if not c.config.create_nonexistent_directories:
            return None
    elif not app.config.create_nonexistent_directories:
        return None

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) &gt; 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                g.es("created directory: "+path)
            except:
                g.es("exception creating directory: "+path)
                g.es_exception()
                return None
    return dir1 # All have been created.
</t>
<t tx="ekr.20071102162910.21"># The caller must enclose this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False,fromString=None):

    """Read any derived file."""

    at = self ; c = at.c
    if 0:
        p = c.currentPosition()
        g.trace('1',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    &lt;&lt; set fileName &gt;&gt;
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    if not g.unitTesting:
        g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    if 0:
        p = c.currentPosition()
        g.trace('2',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0 and not at.thinFile:
        &lt;&lt; warn about non-empty unvisited nodes &gt;&gt;
    if at.errors == 0 and not at.importing:
        if 1: # Package this as a method for use by mod_labels plugin.
            self.copyAllTempBodyStringsToTnodes(root,thinFile)
        else:
            &lt;&lt; copy all tempBodyStrings to tnodes &gt;&gt;
    &lt;&lt; delete all tempBodyStrings &gt;&gt;
    return at.errors == 0
</t>
<t tx="ekr.20071102162910.22">if fromString:
    fileName = "&lt;string-file&gt;"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
</t>
<t tx="ekr.20071102162910.23">for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.
</t>
<t tx="ekr.20071102162910.24">for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            c.setBodyString(p,s) # Sets c and p dirty.

        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
</t>
<t tx="ekr.20071102162910.25">for p in c.allNodes_iter():

    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
</t>
<t tx="ekr.20071102162910.26">@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):

    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    __pychecker__ = '--maxlines=400'
    # g.stat()

    c = self.c
    &lt;&lt; Set ivars &gt;&gt;
    &lt;&lt; Set path from @file node &gt;&gt;
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        old.update(theDict)
    &lt;&lt; Set current directory &gt;&gt;
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        &lt;&lt; Set comment strings from delims &gt;&gt;
</t>
<t tx="ekr.20071102162910.27">self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
</t>
<t tx="ekr.20071102162910.28"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) &gt; 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
</t>
<t tx="ekr.20071102162910.29"># We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory(c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            &lt;&lt; handle absolute path &gt;&gt;
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
</t>
<t tx="ekr.20071102162910.30">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = s[j:i].strip()

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') or
    (path[0]=="'" and path[-1] == "'")
):
    path = path[1:-1].strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
</t>
<t tx="ekr.20071102162910.31"># path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
</t>
<t tx="ekr.20071102162910.32">if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
</t>
<t tx="ekr.20071102162910.33"># 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
</t>
<t tx="ekr.20071102162910.34"># EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
</t>
<t tx="ekr.20071102162910.35">if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
</t>
<t tx="ekr.20071102162910.36">if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w &gt; 0:
        self.page_width = w
</t>
<t tx="ekr.20071102162910.37">if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w
</t>
<t tx="ekr.20071102162910.38"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
</t>
<t tx="ekr.20071102162910.39">if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
</t>
<t tx="ekr.20071102162910.40">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4464980
By: terry_n_brown

When I delete the @ignore in my evil example above, when I try and write the
@auto I get the traceback below.  Perhaps just a msg. saying "Unwritable @auto
node, try re-importing, or save and load" or something?

exception writing derived files
Traceback (most recent call last):
  File "/media/hda8/home/tbrown/.gnome-desktop/Package/leo/anon_cvs/leo/src/leoF
ileCommands.py", line 3060, in write_Leo_file
    c.atFileCommands.writeAll()
  File "/media/hda8/home/tbrown/.gnome-desktop/Package/leo/anon_cvs/leo/src/leoA
tFile.py", line 2919, in writeAll
    at.writeOneAtAutoNode(p,toString=toString)
  File "/media/hda8/home/tbrown/.gnome-desktop/Package/leo/anon_cvs/leo/src/leoA
tFile.py", line 3005, in writeOneAtAutoNode
    fileName = g.os_path_join(at.default_directory,fileName)
AttributeError: atFile instance has no attribute 'default_directory'

@color</t>
<t tx="ekr.20071102162910.41">def writeAtAutoNodes (self,event=None):

    '''Write all @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=False)

def writeDirtyAtAutoNodes (self,event=None):

    '''Write all dirty @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=True)</t>
<t tx="ekr.20071102162910.42">def writeAtAutoNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @auto nodes in the selected outline"""

    at = self ; c = at.c
    p = c.currentPosition() ; after = p.nodeAfterTree()
    found = False
    c.fileCommands.assignFileIndices()
    while p and p != after:
        if p.isAtAutoNode() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = self.writeOneAtAutoNode(p,toString=toString,force=True)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @auto nodes in the selected tree")
    else:
        g.es("no @auto nodes in the selected tree")
</t>
<t tx="ekr.20071102162910.43">def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"&lt;string-file&gt;",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()
        # c.atAutoDict [fileName] = True
    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("Not written: " + at.outputFileName)

    return ok
</t>
<t tx="ekr.20071102162910.44">@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantAtAutoTree(p): # There is noting of value to write.
        g.es_print('@auto node not written:\nno children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
</t>
<t tx="ekr.20071102162910.45">def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    s = p.bodyString()

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    # g.trace('s2',s2)

    return p.hasChildren() or len(s2.strip()) &gt;= 10
</t>
<t tx="ekr.20071102162910.46">if g.unitTesting:

    assert c.atFileCommands.isSignificantAtAutoTree(p)

</t>
<t tx="ekr.20071102162910.47">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4465132
By: terry_n_brown

So I changed all my indentation to multiples of four, having decided I like
the extra line space this buys over aligning with the opening (.

leo said this when it read the file:

@auto did not import the file perfectly

but never mentioned @ignore or anything.  I made a trivial change and saved
and diff could find no difference except my trivial change... which seems perfect
to me...?

@color</t>
<t tx="ekr.20071102162910.48">def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
</t>
<t tx="ekr.20071102162910.49">if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()

    g.app.unitTestDict ['expectedErrors'] = 1
    g.app.unitTestDict ['expectedMismatchLine'] = 2

    s1 = g.toUnicode('line1 Ä, ڱ,  궯, 奠\nline2\n',encoding='utf-8')
    s2 = g.toUnicode('line1 Ä, ڱ,  궯, 奠\nline2a\n',encoding='utf-8')
    runner.checkTrialWrite(s1=s1,s2=s2)
</t>
<t tx="ekr.20071102162910.50"># https://sourceforge.net/forum/message.php?msg_id=4459798</t>
<t tx="ekr.20071102162910.51">def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    if ' ' in path and sys.platform.startswith('win'): 
        path = '"' + path + '"'

    args = [sys.executable, path, '--silent']  

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
</t>
<t tx="ekr.20071102162910.52">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4509897
By: plumloco

If you drag a parent node onto one of its children then leo crashes.

@color</t>
<t tx="ekr.20071102162910.53"></t>
<t tx="ekr.20071102162910.54">def endDrag (self,event):

    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        &lt;&lt; set vdrag, childFlag &gt;&gt;
        if self.allow_clone_drags:
            if not self.look_for_control_drag_on_mouse_down:
                self.controlDrag = c.frame.controlKeyIsDown

        redrawFlag = vdrag and vdrag.v.t != p.v.t
        if redrawFlag: # Disallow drag to joined node.
            &lt;&lt; drag p to vdrag &gt;&gt;
        elif self.trace and self.verbose:
            g.trace("Cancel drag")

        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate(redrawFlag)
        c.recolor_now() # Dragging can affect coloring.
</t>
<t tx="ekr.20071102162910.55">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
</t>
<t tx="ekr.20071102162910.56"># g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
</t>
<t tx="ekr.20071102162910.57"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):

    """The official helper of the onDrag event handler."""

    c = self.c ; canvas = self.canvas

    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    # g.trace('self.controlDrag',self.controlDrag)
    if self.allow_clone_drags:
        self.controlDrag = c.frame.controlKeyIsDown
        if self.look_for_control_drag_on_mouse_down:
            if self.enable_drag_messages:
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
</t>
<t tx="ekr.20071102162910.58">def onContinueDrag(self,event):

    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            &lt;&lt; scroll the canvas as needed &gt;&gt;
    except:
        g.es_event_exception("continue drag")
</t>
<t tx="ekr.20071102162910.59"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y &lt; 0 or y &gt; h:
    lo, hi = frame.canvas.leo_treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)

    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.canvas.leo_treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
</t>
<t tx="ekr.20071102162910.60">def onDrag(self,event):

    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()

    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)

    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
</t>
<t tx="ekr.20071102162910.61">def onEndDrag(self,event):

    """Tree end-of-drag handler called from vnode event handler."""

    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()

    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
</t>
<t tx="ekr.20071102162910.62"></t>
<t tx="ekr.20071102162910.63">def dragAfter(self,p,after):

    c = self ; u = self.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkDrag(p,after): return
    if not c.checkMoveWithParentWithWarning(p,after.parent(),True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(after)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20071102162910.64">def dragToNthChildOf(self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkDrag(p,parent): return
    if not c.checkMoveWithParentWithWarning(p,parent,True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20071102162910.65">def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()

    c.beginUpdate()
    try: # In update...
        # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
        clone = p.clone() # Creates clone &amp; dependents, does not set undo.
        if (
            not c.checkDrag(p,parent) or
            not c.checkMoveWithParentWithWarning(clone,parent,True)
        ):
            clone.doDelete() # Destroys clone and makes p the current node.
            c.selectPosition(p) # Also sets root position.
            c.endUpdate(False) # Nothing has changed.
            return
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
           dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
           dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(clone) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20071102162910.66">def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    c.beginUpdate()
    try: # In update...
        clone = p.clone() # Creates clone.  Does not set undo.
        if c.checkDrag(p,after) and c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            inAtIgnoreRange = clone.inAtIgnoreRange()
            c.endEditing()
            undoData = u.beforeInsertNode(current)
            dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
            clone.moveAfter(after)
            if inAtIgnoreRange and not clone.inAtIgnoreRange():
                # The moved node have just become newly unignored.
                dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
            p = clone
        else:
            # g.trace("invalid clone drag")
            clone.doDelete()
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="ekr.20071102162910.67"></t>
<t tx="ekr.20071102162910.68">def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                g.alert(message)
            return False
    return True
</t>
<t tx="ekr.20071102162910.69">def checkDrag (self,root,target):

    """Return False if target is any descendant of root."""

    message = "Can not drag a node into its descendant tree."

    # g.trace('root',root.headString(),'target',target.headString())

    for z in root.subtree_iter():
        if z == target:
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            else:
                g.alert(message)
            return False
    return True</t>
<t tx="ekr.20071102162910.70">def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    back = p.visBack(c)
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        moved = False
        &lt;&lt; Move p up &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)

    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20071102162910.71">if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

parent = p.parent()

# For this special case we move p after back2.
specialCase = back2 and p.v in back2.v.t.vnodeList

if specialCase:
    # The move must be legal.
    moved = True
    back2.contract()
    p.moveAfter(back2)
elif not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        # g.trace('move to root')
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20071102162910.72">@nocolor
https://sourceforge.net/forum/message.php?msg_id=4514130
By: plumloco

Some commands (such as expand-all) leave no nodes selected. The result of this
is that if you click on the body pane without first having selected a node,
an error dialog pops up.


AttributeError Exception in Tk callback
  Function: &lt;function bodyClickCallback at 0x01981A70&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x02505580&gt;,)
  Event type: ButtonPress (type num: 4)
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 80, in bodyClickCallback
    return handler(event,func)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 3187, in masterClickHandler
    c.frame.body.onClick(event) # New in Leo 4.4.2.
  File "C:\prog\tigris-cvs\leo\src\leoFrame.py", line 1297, in onClick
    c.editCommands.setMoveCol(w,i)
  File "C:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 3539, in setMoveCol
    self.moveSpotNode = p.v.t
AttributeError: 'NoneType' object has no attribute 't'

================================================
  Event contents:
    char: ??
    delta: 0
    height: ??
    keycode: ??
    keysym: ??
    keysym_num: ??
    num: 1
    send_event: False
    serial: 1525
    state: 0
    time: 4692125
    type: 4
    widget: .26496576.26526264.26526584.26526664.26719976.26720296.body-pane
    width: ??
    x: 438
    x_root: 744
    y: 87
    y_root: 651



@color</t>
<t tx="ekr.20071102162910.73">def expandAllHeadlines (self,event=None):

    '''Expand all headlines.
    Warning: this can take a long time for large outlines.'''

    c = self

    c.beginUpdate()
    try:
        p = c.rootPosition()
        while p:
            c.expandSubtree(p)
            p.moveToNext()
        c.selectVnode(c.rootPosition())
    finally:
        c.endUpdate()
        c.treeFocusHelper()

    c.expansionLevel = 0 # Reset expansion level.
</t>
<t tx="ekr.20071102162910.74">def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t</t>
<t tx="ekr.20071102162910.75">if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        ec = c.editCommands

        for spot,result in (('1.0',0),(5,5)):
            ec.setMoveCol(w,spot)
            assert ec.moveSpot == result
            assert ec.moveCol == result
    finally:
        c.endUpdate(False)
</t>
<t tx="ekr.20071102162910.76">def onClick (self,event):

    c = self.c ; k = c.k ; w = event and event.widget
    wname = c.widget_name(w)

    if not c.currentPosition(): return

    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        k.previousSelection = w.getSelectionRange()
        x,y = g.app.gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        # g.trace(x,y,repr(i))
        w.setSelectionRange(i,i,insert=i)
        c.editCommands.setMoveCol(w,i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')
</t>
<t tx="ekr.20071102162910.77">if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        y = 10
        for x in xrange(0,100,10):
            event = g.Bunch(c=c,x=x,y=y,widget=w)
            c.frame.body.onClick(event)
    finally:
        c.endUpdate(False)</t>
<t tx="ekr.20071102162910.78"></t>
<t tx="ekr.20071102162910.79"># see: http://www.diveintopython.org/xml_processing/unicode.html

def es_print(s,*args,**keys):

    encoding = sys.getdefaultencoding()

    try:
        if type(s) != type(u''):
            s = unicode(s,encoding)
    except Exception:
        s = g.toEncodedString(s,'ascii')

    if keys.get('newline') in (True,None):
        print s
    else:
        print s,

    if g.app.gui and not g.app.gui.isNullGui and not g.unitTesting:
        g.es(s,*args,**keys)
</t>
<t tx="ekr.20071102162910.80">if g.unitTesting:
    g.es_print('\ntest of es_print: Ă',color='red',newline=False)
    g.es_print('after')
    g.es_print('done')
</t>
<t tx="ekr.20071102162910.81">def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import the file perfectly\nfirst mismatched line: %d\n%s' % (
            kind,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) &lt; 100:
        pr('input...')
        for i in xrange(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in xrange(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
</t>
<t tx="ekr.20071102162910.82">if False: # Don't clutter the unit tests.

    def pr(*args,**keys): # reportMismatch test
        g.es_print(color='blue',*args,**keys)

    pr('input...')
    pr('newline=False:',newline=False)
    pr('after')
    pr('done')
</t>
<t tx="ekr.20071102162910.83">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4468174
By: rich_ries

&gt;&gt; I find that if I change an @auto node and the save of the @auto file fails
because it's locked by another app and I stop the other app, releasing the lock
then I save the file again::

&gt;&gt; The .leo file is saved, but not the @auto file.

This is not only in @auto, but in "regular" Leo, also.

@color</t>
<t tx="ekr.20071102162910.84"></t>
<t tx="ekr.20071102162910.85"># The run-unit-tests command now includes **all** @mark-for-unit-test trees.
</t>
<t tx="ekr.20071102162910.86">def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()
</t>
<t tx="ekr.20071102162910.87">class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
</t>
<t tx="ekr.20071102162910.88">def __init__(self,c,all):

    self.c = c
    self.all = all

    self.copyRoot = None # The root of copied tree.
    self.fileName = 'dynamicUnitTest.leo'
    self.root = None # The root of the tree to copy when self.all is False.
    self.tags = ('@test','@suite','@unittests','@unit-tests')
</t>
<t tx="ekr.20071102162910.89">def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test', self.fileName))

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
</t>
<t tx="ekr.20071102162910.90">def createOutline (self,c2):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c = self.c ; markTag = '@mark-for-unit-tests'
    self.copyRoot = c2.rootPosition()
    self.copyRoot.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    self.seen = []
    &lt;&lt; set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 &gt;&gt;
    c2.beginUpdate()
    try:
        self.copyRoot.expand()
        for p,limit,lookForMark,lookForNodes in (
            (p1,limit1,lookForMark1,lookForNodes1),
            (p2,limit2,lookForMark2,lookForNodes2),
        ):
            while p and p != limit:
                h = p.headString()
                if p.v.t in self.seen:
                    p.moveToNodeAfterTree()
                elif lookForMark and h.startswith(markTag):
                    self.addMarkTree(p)
                    p.moveToNodeAfterTree()
                elif lookForNodes and self.isUnitTestNode(p):
                    self.addNode(p)
                    p.moveToNodeAfterTree()
                else:
                    p.moveToThreadNext()
    finally:
        c2.endUpdate(False)</t>
<t tx="ekr.20071102162910.91">if self.all:
    # A single pass looks for all tags everywhere.
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,True
    p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
else:
    # The first pass looks everywhere for only for @mark-for-unit-tests,
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,False
    # The second pass looks in the selected tree for everything except @mark-for-unit-tests.
    # There is no second pass if the present node is an @mark-for-unit-test node.
    p = c.currentPosition()
    if p.headString().startswith(markTag):
        p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
    else:
        p2,limit2,lookForMark2,lookForNodes2 = p,p.nodeAfterTree(),False,True</t>
<t tx="ekr.20071102162910.92">def addMarkTree (self,p):

    # g.trace(len(self.seen),p.headString())

    self.seen.append(p.v.t)

    for p in p.subtree_iter():
        if self.isUnitTestNode(p) and not p.v.t in self.seen:
            self.addNode(p)
</t>
<t tx="ekr.20071102162910.93">def addNode(self,p):

    '''
    Add an @test, @suite or an @unit-test tree as the last child of self.copyRoot.
    '''

    # g.trace(len(self.seen),p.headString())

    p2 = p.copyTreeAfter()
    p2.unlink()
    p2.moveToLastChildOf(self.copyRoot)

    self.seen.append(p.v.t)
</t>
<t tx="ekr.20071102162910.94">def isUnitTestNode (self,p):

    h = p.headString()
    for tag in self.tags:
        if h.startswith(tag):
            return True
    else:
        return False
</t>
<t tx="ekr.20071102162910.95">def runTests (self):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo in a separate process.
    '''

    trace = False
    if trace: import time
    g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
    print 'creating: %s' % (self.fileName)
    c = self.c ; p = c.currentPosition()
    if trace: t1 = time.time()
    found = self.searchOutline(p.copy())
    if trace:
         t2 = time.time() ; print 'find:  %0.2f' % (t2-t1)
    if found:
        gui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=gui)
        if trace:
            t3 = time.time() ; print 'gui:   %0.2f' % (t3-t2)
        found = self.createOutline(c2)
        if trace:
            t4 = time.time() ; print 'copy:  %0.2f' % (t4-t3)
        self.createFileFromOutline(c2)
        if trace:
            t5 = time.time() ; print 'write: %0.2f' % (t5-t4)
        self.runLeoDynamicTest()
        if trace:
            t6 = time.time() ; print 'run:   %0.2f' % (t6-t5)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in selected outline')
</t>
<t tx="ekr.20071102162910.96">def searchOutline (self,p):

    c = self.c ; p = c.currentPosition()
    iter = g.choose(self.all,c.allNodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.headString()
        for s in self.tags:
            if h.startswith(s):
                self.root = c.currentPosition()
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.currentPosition().parents_iter():
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    self.root = p.copy()
                    return True

    # Finally, look for all @mark-for-unit-test nodes.
    for p in c.allNodes_iter():
        if p.headString().startswith('@mark-for-unit-test'):
            return True

    return False
</t>
<t tx="ekr.20071102162910.97">@nocolor

&gt; Can anyone point me to a discussion of what is, and is not, guanteed about how
Python schedules threads? In particular, I want the colorizing thread to
relinquish control to the gui thread quite often (for good response), but I
don't want the relinquishing itself to slow down the colorizer much. It seems a
hard problem.

From what I understand, there are perhaps only a few "guarantees" with Python
threads. One guarantee is that when Python source is executing, threads will
swap after sys.getcheckinterval() bytecodes have been processed for that thread.
You can set the delay with sys.setcheckinterval(count). It seems to be 100
bytecodes in Python 2.3-2.5, but I could have sworn it was 1000. In any case,
setting the check interval higher will result in higher speed, but lower
responsiveness.

When making certain C-level calls, Python will also allow the "active" Python
thread to switch. Which really means that the only way you can use those all of
those 4-core processors with Python in a single process is to do all of your
work in C code with carefully crafted GIL acquire and release calls.

If your code is crafted in such a way that there are "convenient" places to
yield control, you can use a technique known as 'cooperative multithreading with
generators'. It gives you the total speed, more or less, of a single thread, but
*you* choose where the context switches occur, for the cost of a bit of extra
complication.</t>
<t tx="ekr.20071102162910.98">
</t>
<t tx="ekr.20071102162910.99"></t>
<t tx="ekr.20071102162910.100"></t>
<t tx="ekr.20071102162910.101">def run (self,s,parent):

    c = self.c
    self.root = root = parent.copy()
    self.file_s = s
    self.tab_width = self.importCommands.getTabWidth(p=root)
    # g.trace('tab_width',self.tab_width)
    # Create the ws equivalent to one tab.
    if self.tab_width &lt; 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    self.mismatchWarningGiven = False
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = self.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    self.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and self.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: self.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
</t>
<t tx="ekr.20071102162910.102">def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width &lt; 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width &gt; 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed: self.regularizeError()

    return ''.join(result)
</t>
<t tx="ekr.20071102162910.103">def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width &lt; 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

</t>
<t tx="ekr.20071102162910.104">def readAtAutoNodes (self,event=None):

    '''Read all @auto nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    c.beginUpdate()
    try:
        undoData = u.beforeChangeTree(p)
        c.importCommands.readAtAutoNodes()
        u.afterChangeTree(p,'Read @auto Nodes',undoData)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20071102162910.105">def readAtAutoNodes (self):

    c = self.c
    p = c.currentPosition() ; after = p.nodeAfterTree()

    c.beginUpdate()
    try:
        found = False
        while p and p != after:
            if p.isAtAutoNode():
                if p.isAtIgnoreNode():
                    g.es_print('ignoring %s' % (p.headString()),color='blue')
                    p.moveToThreadNext()
                else:
                    self.readOneAtAutoNode(p)
                    found = True
                    p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        g.es(g.choose(found,'finished','no @auto nodes in the selected tree'),color='blue')
    finally:
        c.endUpdate()

</t>
<t tx="ekr.20071102162910.106">def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # Force an update of the body pane.
    c.setBodyString(p,p.bodyString())
    c.frame.body.onBodyChanged(undoType=None)
</t>
<t tx="ekr.20071102162910.107"></t>
<t tx="ekr.20071102162910.108"># 4.0: Don't use newline-pending logic.

def closeWriteFile (self):

    at = self

    if at.outputFile:
        at.outputFile.flush()
        if self.toString:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
</t>
<t tx="ekr.20071102162910.109">def openFileForWriting (self,root,fileName,toString):

    at = self ; c = at.c
    at.outputFile = None

    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "&lt;string: %s&gt;" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        at.openFileForWritingHelper(fileName)

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()

    return at.outputFile is not None
</t>
<t tx="ekr.20071102162910.110">def openFileForWritingHelper (self,fileName):

    at = self ; c = at.c

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            if path:
                path = g.makeAllNonExistentDirectories(path,c=c)
            if not path or not g.os_path_exists(path):
                path = g.os_path_dirname(at.targetFileName)
                at.writeError("path does not exist: " + path)
                return
    except Exception:
        at.exception("exception creating path: %s" % repr(path))
        g.es_exception()
        return

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not create: read only: " + at.targetFileName)
                return
        except AttributeError: pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
    except:
        at.exception("exception creating:" + at.outputFileName)
</t>
<t tx="ekr.20071102162910.111">def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):

    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    &lt;&lt; Clear all orphan bits &gt;&gt;
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            &lt;&lt; handle v's tree &gt;&gt;
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    &lt;&lt; say the command is finished &gt;&gt;
    return mustAutoSave
</t>
<t tx="ekr.20071102162910.112">@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
</t>
<t tx="ekr.20071102162910.113">if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False

    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p,toString=toString,force=False)
        writtenFiles.append(p.v.t)
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
</t>
<t tx="ekr.20071102162910.114">if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) &gt; 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
</t>
<t tx="ekr.20071102162910.115"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False,write_strips_blank_lines=None):

    """Write a 4.x derived file."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    &lt;&lt; set at.targetFileName &gt;&gt;
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString,
        write_strips_blank_lines=write_strips_blank_lines)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.closeWriteFile()
            &lt;&lt; set dirty and orphan bits on error &gt;&gt;
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
</t>
<t tx="ekr.20071102162910.116">if toString:
    at.targetFileName = "&lt;string-file&gt;"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
</t>
<t tx="ekr.20071102162910.117"># Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors &gt; 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
</t>
<t tx="ekr.20071102162910.118"># New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v.t.bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()
</t>
<t tx="ekr.20071102162910.119">def scannerUnitTest (self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):

    '''Run a unit test of an import scanner,
    i.e., create a tree from string s at location p.'''

    c = self.c ; h = p.headString() ; old_root = p.copy()
    oldChanged = c.changed
    c.beginUpdate()
    try:
        d = g.app.unitTestDict
        expectedErrors = d.get('expectedErrors')
        expectedErrorMessage = d.get('expectedErrorMessage')
        expectedMismatchLine = d.get('expectedMismatchLine')
        g.app.unitTestDict = {
            'expectedErrors':expectedErrors,
            'expectedErrorMessage':expectedErrorMessage,
            'expectedMismatchLine':expectedMismatchLine,
        }
        if not fileName: fileName = p.headString()
        if not s: s = self.removeSentinelsCommand([fileName],toString=True)
        title = g.choose(h.startswith('@test'),h[5:],h)
        self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
        d = g.app.unitTestDict
        ok = ((d.get('result') and expectedErrors in (None,0)) or
            (
                # checkTrialWrite returns *True* if the following match.
                # d.get('result') == False and
                d.get('actualErrors') == d.get('expectedErrors') and
                d.get('actualMismatchLine') == d.get('expectedMismatchLine') and
                (expectedErrorMessage is None or d.get('actualErrorMessage') == d.get('expectedErrorMessage'))
            ))
        if not ok:
            g.trace('result',d.get('result'),
                'actualErrors',d.get('actualErrors'),
                'expectedErrors',d.get('expectedErrors'),
                'actualMismatchLine',d.get('actualMismatchLine'),
                'expectedMismatchLine', d.get('expectedMismatchLine'),
                '\nactualErrorMessage  ',d.get('actualErrorMessage'),
                '\nexpectedErrorMessage',d.get('expectedErrorMessage'),
            )
        if not showTree and ok:
            while old_root.hasChildren():
                old_root.firstChild().doDelete()
            c.setChanged(oldChanged)

    finally:
        c.selectPosition(old_root)
        c.endUpdate()

    if g.app.unitTesting:
        assert ok

    return ok
</t>
<t tx="ekr.20071102162910.120">class baseScannerClass:

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
</t>
<t tx="ekr.20071102162910.121">def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.classIndent = 0 # The indentation of the start of the class.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.language = language
    self.methodName = ic.methodName # x, as in &lt; &lt; x methods &gt; &gt; =
    self.mismatchWarningGiven = False
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = None # Set in run: the tab width in effect in the c.currentPosition.
    self.tab_ws = '' # Set in run: the whitespace equivalent to one tab.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'  

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # May be overridden in subclasses.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',] # tags that start a tag.
    self.functionTags = []
    self.hasClasses = True
    self.hasFunctions = True
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
</t>
<t tx="ekr.20071102162910.122"></t>
<t tx="ekr.20071102162910.123">def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
</t>
<t tx="ekr.20071102162910.124">def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i &gt;= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i &gt;= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print(repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif (not strict and not g.unitTesting) and line1.lstrip() == line2.lstrip():
        if not self.mismatchWarningGiven:
            self.mismatchWarningGiven = True
            g.es_print('Warning: leading whitespace does not match')
            g.es_print('First mismatched line at line %d % (i+1)')
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        return True # A match excluding leading whitespace.
    else:
        if not g.app.unitTesting or i+1 != expectedMismatch:
            # g.es_print('compareHelper')
            g.es_print('*** first mismatch at line %d' % (i+1))
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        d ['actualMismatchLine'] = i+1
        # g.trace('lines 1...\n',repr(lines1),'\nlines2...\n',repr(lines2))
        return False
</t>
<t tx="ekr.20071102162910.125">if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    i = 0
    lines1 = ['abc',]
    lines2 = ['xyz',]

    g.app.unitTestDict ['expectedErrors'] = 1
    g.app.unitTestDict ['expectedMismatchLine'] = 1

    runner.compareHelper(lines1,lines2,i,strict=True)
</t>
<t tx="ekr.20071102162910.126">if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='java')
    i = 0
    lines1 = ['abc',]
    lines2 = [' abc',]

    g.unitTesting = False # force the warning.

    g.app.unitTestDict ['expectedErrors'] = 0
    g.app.unitTestDict ['expectedMismatchLine'] = 0

    runner.compareHelper(lines1,lines2,i,strict=False)
</t>
<t tx="ekr.20071102162910.127">@ None of these methods should ever need to be overridden in subclasses.

</t>
<t tx="ekr.20071102162910.128">def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
</t>
<t tx="ekr.20071102162910.129">def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20071102162910.130">def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

</t>
<t tx="ekr.20071102162910.131">def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
</t>
<t tx="ekr.20071102162910.132">def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i &lt; len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
</t>
<t tx="ekr.20071102162910.133">def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
</t>
<t tx="ekr.20071102162910.134">def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
</t>
<t tx="ekr.20071102162910.135">def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
</t>
<t tx="ekr.20071102162910.136">def putClass (self,s,i,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldClassIndent = self.classIndent
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.classIndent = self.getIndent(s,i)
    self.classLines = []
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,indentFlag,classDelim,decls,trailing = self.putClassHelper(s,i,codeEnd,class_name,class_node)

    declsUndentVal = self.getLeadingIndent(decls,0)

    # g.trace(class_name,'indent',self.classIndent,'indentFlag',indentFlag,'declsIndent',declsUndentVal)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name,indentFlag) or ''

    # Remove the leading whitespace in various ways from each part.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        self.undentBy(decls,undentVal) +
        self.undentBy(ref,declsUndentVal) +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.classIndent = oldClassIndent
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
</t>
<t tx="ekr.20071102162910.137">def getClassNodeRef (self,class_name,indentFlag):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    # Increase effective indentation by the width of self.tab_ws.
    # g.trace('class_name',class_name,indentFlag)

    if indentFlag:
        return '%s%s\n' % (self.tab_ws,s)
    else:
        return '%s\n' % (s)
</t>
<t tx="ekr.20071102162910.138">def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
</t>
<t tx="ekr.20071102162910.139">def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
</t>
<t tx="ekr.20071102162910.140">def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    j = i ; i = self.skipDecls(s,i,end,inClass=True)
    decls = s[j:i]

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,indentFlag = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,indentFlag = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,indentFlag,classDelim,decls,trailing
</t>
<t tx="ekr.20071102162910.141">def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and self.trace

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body1 = s[start:sigStart]
    # Bug fix: 2007/20/31: adjust start backwards to get a better undent.
    if body1.strip():
        while start &gt; 0 and s[start-1] in (' ','\t'):
            start -= 1

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if trace: g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error(
            'function %s does not end with a newline; one will be added\n%s' % (
                self.sigId,g.get_line(s,codeEnd)))
        g.trace(g.callers())

    self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
</t>
<t tx="ekr.20071102162910.142">def putRootText (self,p):

    c = self.c

    c.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
</t>
<t tx="ekr.20071102162910.143">def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        # result = ''.join([
            # g.removeLeadingWhitespace(line,undent,self.tab_width)
                # for line in g.splitLines(s)])
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result

def undentBy (self,s,undentVal):
    return ''.join(
        [g.removeLeadingWhitespace(line,undentVal,self.tab_width)
            for line in g.splitLines(s)])
</t>
<t tx="ekr.20071102162910.144">def underindentedComment (self,line):

    self.error(
        'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
</t>
<t tx="ekr.20071102162910.145">def error (self,s):

    self.errors += 1
    self.importCommands.errors += 1
    if g.app.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict['actualErrorMessage'] = s
        g.app.unitTestDict['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.trace(g.callers())
            g.es_print(s,color='red')
    else:
        g.es_print(s,color='red')

def oops (self):
    print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()
</t>
<t tx="ekr.20071102162910.146">@ Scan and skipDecls would typically not be overridden.
</t>
<t tx="ekr.20071102162910.147">def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
</t>
<t tx="ekr.20071102162910.148">def getIndent (self,s,i):

    j,j2 = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    # g.trace('%d %s' % (indent,s[j:j2]))
    return indent</t>
<t tx="ekr.20071102162910.149">def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start &lt; len(s):
        self.c.appendStringToBody(parent,s[start:]) 
</t>
<t tx="ekr.20071102162910.150">def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    assert kind in ('class','outer')
    start = i ; putRef = False ; indentFlag = None
    while i &lt; end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd &amp; codeEnd ivars.
            putRef = True
            if indentFlag is None: indentFlag = self.getIndent(s,i) &gt; self.classIndent
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd &amp; codeEnd ivars.
            putRef = True ; indent = self.getIndent(s,i)
            if indentFlag is None: indentFlag = indent &gt; self.classIndent
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = start = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else: i += 1

        # if progress == i: g.pdb()
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,indentFlag
</t>
<t tx="ekr.20071102162910.151">def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i &gt;= len(s):
        return start,False
    else:
        return i,True 
</t>
<t tx="ekr.20071102162910.152">def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i &lt; len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent &lt; startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level &lt;= 0:
                if trace: g.trace('returns\n',repr(s[start:i]))
                return i

        else: i += 1
        assert progress &lt; i

    self.error('no block')
    if 1:
        i,j = g.getLine(s,start)
        g.trace(s[max(0,i-20):i+20])
    if trace: g.trace('** no block')
    return start
</t>
<t tx="ekr.20071102162910.153">def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i &gt; start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
</t>
<t tx="ekr.20071102162910.154">def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
</t>
<t tx="ekr.20071102162910.155">def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
</t>
<t tx="ekr.20071102162910.156">def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    if trace: g.trace(g.callers())
    while i &lt; end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,self.classId) # 'class')
            break
        elif self.startsFunction(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            break
        else:
            i += 1 ;  prefix = None
        # if progress == i: g.pdb()
        assert(progress &lt; i)

    if prefix is not None: i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
</t>
<t tx="ekr.20071102162910.157">def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    return j

    # if s[j:i].strip():
        # self.error(
            # '%s %s does not start a line. Leo must insert a newline\n%s' % (
                # tag,self.sigId,g.get_line(s,j)))
        # return i
    # else:
        # return j
</t>
<t tx="ekr.20071102162910.158">def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)</t>
<t tx="ekr.20071102162910.159">def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i &lt; len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i &gt;= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
</t>
<t tx="ekr.20071102162910.160">def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
</t>
<t tx="ekr.20071102162910.161">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
</t>
<t tx="ekr.20071102162910.162"># We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasClasses and self.startsHelper(s,i,kind='class',tags=self.classTags)
    return val

def startsFunction (self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasFunctions and self.startsHelper(s,i,kind='function',tags=self.functionTags)
    return val
</t>
<t tx="ekr.20071102162910.163">def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    # if not tags: return False

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent &lt; self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
</t>
<t tx="ekr.20071102162910.164">def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    # __pychecker__ = '--no-argsused' # tags not used in the base class.

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i &lt; len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i &lt; len(s) and s[i],ids,classId)
    return i, ids, classId
</t>
<t tx="ekr.20071102162910.165">def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i &lt; len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
</t>
<t tx="ekr.20071102162910.166">def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
</t>
<t tx="ekr.20071102162910.167">def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
</t>
<t tx="ekr.20071102162910.168">def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
</t>
<t tx="ekr.20071102162910.169">def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
</t>
<t tx="ekr.20071102162910.170"></t>
<t tx="ekr.20071102162910.171">def convertBlanks (self,event=None):

    '''Convert all blanks to tabs in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Blanks'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
</t>
<t tx="ekr.20071102162910.172">def convertTabs (self,event=None):

    '''Convert all tabs to blanks in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
            s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Tabs'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
</t>
<t tx="ekr.20071102162910.173"></t>
<t tx="ekr.20071102162910.174">@nocolor

For the last several days I have been trying to smooth out rough edges in @auto.  Please test the new code on cvs.  All unit tests pass, but use extreme caution if your @auto nodes refer to valuable files.

The changes:

1. Leo will *read* an @auto node if the derived file exists, an 'insignificant' amount of data exists in the @auto tree, and the @auto node has not been read previously.  This promises to fix some quite awkward use cases.

Please report any glitches in the scheme immediately.  Problems may remain.

2. The 'perfect import' code now is a bit more relaxed, especially for 'non-strict' languages (all languages except Python):

- Leo leaves leading whitespace alone for non-strict languages.

- Leo complains about intermixed tabs and blanks in leading whitespace only for strict languages.

- Leo ignores leading whitespace in the perfect import tests for non-strict languages.

The effect is that Leo will import more files without complaint.  **However**, this also means that Leo might actually changes a derived file if such a change occurs only in leading whitespace in a non-strict language.  I *think* this is a reasonable idea: the alternative would be for Leo to be excessively fussy.

As I said earlier, all unit tests pass.  However, it may be that more changes (and more unit tests) will be needed.  Please give the new code a spin and report any problems asap.  I would like to release the latest code this Friday.

Edward</t>
<t tx="ekr.20071102162910.175">@nocolor

&gt; - create a node; 
@auto /tmp/test.txt 

(/tmp/test.txt is an existing file) 

- save the Leo file 
log pane: 
wrote: test.txt 
saved: test.leo 

/tmp/test.txt is now empty

I can see that this is going to cause problems for people.  At

http://sourceforge.net/forum/message.php?msg_id=4453784

I say

[quote] &gt; Leo will not automatically save a dirty @auto tree if Leo has not
already read this tree. This allows you to create an empty @auto node without
having to worry about Leo destroying the corresponding file.

Experience shows that this is not a good idea. It produces confusing and
counter-intuitive behavior. I am about to remove this 'feature'. [end quote]

Thus, what you report is the expected behavior. That is, the first time you
create any @auto node for an existing file you must use the read-at-auto-node
command to populate the @auto node.

But what is the solution to your confusion? As indicated above, the 'obvious'
solution (not writing 'unread' @auto trees) does not work particularly well. (I
forget exactly why not, but trust me, it doesn't.) Documentation is essential,
but probably won't prevent endless bug reports such as yours.

This isn't a fatal flaw in @auto, but it's going to be annoying unless I can
come up with a better plan.

-----

My present plan is to restore the previous way (remembering whether an @auto
node has been previously read) with several modifications:

- More traces and log messages so it is clearer why the old approach did not
work. At the very least I have to document the failed plan thoroughly.

- As Kent has just said, the bug is a "save-time" issue. Yesterday I had the
thought that the *save* operation should do an @auto *read* operation if the
node has not been previously read. That would be convenient (if it works): just
create the @auto node then do a save.

Some notes: 

- There is never much doubt about what to do if the file does not exist: just
create it, using whatever is in the @auto tree.

- I do not plan any dialogs. Long experience has convinced me that they never
work. Not only are they annoying, but at the point that they appear the user
will almost never know how to make the right choice, and will be upset at having
to make an unpleasant and unwelcome choice.

- An interesting kludge may be helpful. In the "hard" case (the derived file
exists but the @auto node has not been read) Leo will do the following:

Plan A. If the @auto node has no children, and contains a 'small' amount of body
text (say less than 100 characters and less than 10 lines), Leo will assume that
the @auto node contain no significant info and will do a *read* of the @auto
node when the user does a save.

Plan B. If the @auto node has children, or if the @auto node contain more than a
'small' amount of text, Leo will issues a warning (in the log pane, not in a
dialog) and will do nothing, neither reading the @auto node nor writing the
corresponding derived file. Thus, the @auto tree will be written to the .leo
file.

Plan B is likely to happen seldom, but if it does happen Leo can not choose
between reading or writing. Furthermore, Leo should not immediately force the
user to make a choice. For example, both the @auto node and the derived file
might contain significant information, and the user won't want to discard
either. True, there could be a cancel button in the dialog, but that will reduce
the user's consternation only slightly. Much better, imo, to do nothing drastic
and let the user 'recover' at her leisure.
</t>
<t tx="ekr.20071102162910.176"># These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName (self):
    # h = self.headString() ; tag = '@auto'
    # # Prevent conflicts with autotrees plugin: don't allow @auto-whatever to match.
    # return g.match_word(h,0,tag) and not g.match(h,0,tag+'-') and h[len(tag):].strip()
    names = ("@auto",)
    return self.findAtFileName(names)

def atFileNodeName (self):
    names = ("@file",)
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName
</t>
<t tx="ekr.20071102162910.177">def findAtFileName (self,names):

    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()

    if not g.match(h,0,'@'):
        return ""

    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
</t>
<t tx="ekr.20071102162910.178">def readAll(self,root,partialFlag=False,forceGnx=False):

    """Scan vnodes, looking for @file nodes to read."""

    at = self ; c = at.c
    if partialFlag:
        # Capture the current headline only if we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            if forceGnx: # New in Leo 4.4.2 b1: support for sax read.
                at.forceGnxOnPosition(p)
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            # g.trace('@auto',p.headString(),'name',p.atAutoNodeName())
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for p in c.allNodes_iter():
        p.v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")
</t>
<t tx="ekr.20071102162910.179">def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    # g.trace(fileName)

    # Delete all children.
    c.beginUpdate()
    try:
        while p.hasChildren():
            p.firstChild().doDelete()
    finally:
        c.endUpdate(False)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('Errors inhibited read @auto %s' % (fileName),color='red')

    if ic.errors or not g.os_path_exists(fileName):
        c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)</t>
<t tx="ekr.20071102162910.180">def putVnode (self,p,isIgnore=False):

    """Write a &lt;v&gt; element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    # Not writing @auto nodes is way too dangerous.
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # forceWrite = isIgnore or not isThin or (isThin and isOrphan)
    if isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto: forceWrite = False     # Never write non-ignored @auto trees.
    elif isThin: forceWrite = isOrphan  # Only write orphan @thin trees.
    else:        forceWrite = True      # Write all other @file trees.

    &lt;&lt; Set gnx = tnode index &gt;&gt;
    attrs = []
    &lt;&lt; Append attribute bits to attrs &gt;&gt;
    &lt;&lt; Append tnodeList and unKnownAttributes to attrs &gt;&gt;
    attrs = ''.join(attrs)
    v_head = '&lt;v t="%s"%s&gt;&lt;vh&gt;%s&lt;/vh&gt;' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        &lt;&lt; issue informational messages &gt;&gt;
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('&lt;/v&gt;\n')
    else:
        fc.put('%s&lt;/v&gt;\n' % v_head) # Call put only once.
</t>
<t tx="ekr.20071102162910.181"># New in Leo 4.4.3
if not v.t.fileIndex:
    if 0: # This is not necessarily an error.
        # c.dumpOutline() # Can be called inside pdb.
        # Print the @chapters tree
        g.trace('*** missing t.fileIndex','v',repr(v))
        c.chapterController.printChaptersTree()
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)
if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
</t>
<t tx="ekr.20071102162910.182"># These string catenations are benign because they rarely happen.
attr = ""
if v.isExpanded(): attr += "E"
if v.isMarked():   attr += "M"
if v.isOrphan():   attr += "O"

# No longer a bottleneck now that we use p.equal rather than p.__cmp__
# Almost 30% of the entire writing time came from here!!!
if not self.use_sax:
    if p.equal(self.topPosition):     attr += "T" # was a bottleneck
    if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr:
    attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions &lt;v&gt; element.
if self.use_sax and p.equal(self.rootPosition):
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d</t>
<t tx="ekr.20071102162910.183"># Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

# Debugging.
# if v.isAnyAtFileNode():
    # if hasattr(v.t,"tnodeList"):
        # g.trace(v.headString(),len(v.t.tnodeList))
    # else:
        # g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))</t>
<t tx="ekr.20071102162910.184">if isOrphan and isThin:
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

# For testing.
# if p.isAtIgnoreNode():
     # for p2 in p.self_and_subtree_iter():
            # if p2.isAtThinFileNode():
                # g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
</t>
<t tx="ekr.20071102162910.185">These commands are useful for resolving cvs conflicts in derived files.

The read-file-into-node command prompts for a filename, and creates an node
whose headline is @read-file-into-node &lt;filename&gt; and whose body text is the
entire contents of the file.

The write-file-from-node writes the body text of the selected not to a file. If
the headline of the presently selected node starts with @read-file-into-node the
command use the filename that follows in the headline. Otherwise, the command
prompts for a filename.</t>
<t tx="ekr.20071102162910.186"></t>
<t tx="ekr.20071102162910.187"></t>
<t tx="ekr.20071102162910.188">@nocolor

https://sourceforge.net/forum/message.php?msg_id=4539759
By: ktenney

&lt;ctrl-n&gt; new Leo file

rename ``NewHeadline`` to
@auto /tmp/test

type a line in the @auto node

&lt;ctrl-s&gt;

log pane reports

- created:   \tmp\test
- saved: test.leo

type another line in the @auto node

&lt;ctrl-s&gt;

log pane reports

- reading new @auto /tmp/test2
- saved: test.leo

the second line typed has disappeared.

@color</t>
<t tx="ekr.20071102162910.189"># It was appearing to hang.</t>
<t tx="ekr.20071102162910.190">def unmarkAll (self,event=None):

    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        changed = False
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                # c.clearMarked(p) # Very slow: calls a hook.
                p.v.clearMarked()
                p.v.t.setDirty()
                u.afterMark(p,undoType,bunch)
        dirtyVnodeList = [p.v for p in c.allNodes_iter() if p.v.isDirty()]
        if changed:
            g.doHook("clear-all-marks",c=c,p=p,v=p)
            c.setChanged(True)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()</t>
<t tx="ekr.20071102162910.191">if g.unitTesting:
    marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
    try:
        ok = True
        try:
            c.unmarkAll()
        except Exception:
            ok = False
    finally:
        for p in c.allNodes_iter():
            if p.v in marks:
                if not p.isMarked():
                    c.setMarked(p)
            else:
                if p.isMarked():
                    c.clearMarked(p)

    if not ok: raise
</t>
<t tx="ekr.20071102162910.192">count = 0
for p in c.allNodes_iter():
    # print '.' * p.level(),p.headString()
    count += 1
print count,'nodes'</t>
<t tx="ekr.20071102162910.193">def clearMarked  (self,p):

    c = self
    p.v.clearMarked()
    g.doHook("clear-mark",c=c,p=p,v=p)</t>
<t tx="ekr.20071102162910.194">def setDirty (self):

    self.statusBits |= self.dirtyBit
</t>
<t tx="ekr.20071102162910.195">def clearMarked (self):

    self.statusBits &amp;= ~ self.markedBit
</t>
<t tx="ekr.20071102162910.196">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4544813

When the 'r' in 'str(' is deleted, the closing bracket on the next line changes
color.  There are lots of variations, for example putting the 'r' back causes
the opening bracket on the next line to change color.

@color

g.es(r'abc')
g.es('hello')

@nocolor

The fix was to init self.prev: match_previous was coloring the wrong range.</t>
<t tx="ekr.20071102162910.197">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4543844
By: terry_n_brown

Using the xemacs plug-in for node editing it seems the tree's node-has-contents
and node-is-modified indications are no longer being updated.  The log file
says "updated from: LeoTemp_158688460_test.py" correctly, and the update occurs,
by the indications of change don't.

Also I was creating an @auto node, misspelled it's target file name the first
time, but when I corrected it and tried reading it again it still said it couldn't
find it.  The when I Save As'ed the leo file over itself it immediately read
the @auto file.

The fix was to c.setBodyString.  p.setDirty no longer redraws the screen automatically, so we must do it by hand.

@color</t>
<t tx="ekr.20071102162910.198">def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()

    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        c.beginUpdate()
        try:
            v.setTnodeText(s)
            v.t.setSelection(0,0)
            p.setDirty()
            if not c.isChanged():
                c.setChanged(True)
        finally:
            c.endUpdate()
</t>
<t tx="ekr.20071102162910.199">@nocolor

Simplified the code:

- Removed selection-only logic: it was never used.
- Only the insert point is ever used to init interactive searches.
- initBatch/NextText now take an optional ins argument.
  Both these methods set the insert point by calling init_s_ctrl.

The bug fix was to change:

pattern.lower()

to:

pattern = pattern.lower()

in backwardsHelper.

@color</t>
<t tx="ekr.20071102162910.200">class leoFind:

    """The base class for Leo's Find commands."""

    @others
</t>
<t tx="ekr.20071102162910.201">def __init__ (self,c,title=None):

    # g.trace('leoFind',c)

    self.c = c

    # Spell checkers use this class, so we can't always compute a title.
    if title:
        self.title = title
    else:
        &lt;&lt; compute self.title &gt;&gt;

    &lt;&lt; init the gui-independent ivars &gt;&gt;

def init (self,c):
    self.oops()
</t>
<t tx="ekr.20071102162910.202">if not c.mFileName:
    s = "untitled"
else:
    path,s = g.os_path_split(c.mFileName)

self.title = "Find/Change for %s" %  s
</t>
<t tx="ekr.20071102162910.203">self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated by update_ivars just before doing any find.
@c

&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = searchWidget() # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos &gt;= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
</t>
<t tx="ekr.20071102162910.204">if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.wrap = None
    self.whole_word = None

if 1:
    self.change_ctrl = None
    self.find_ctrl = None
    self.frame = None
    self.svarDict = {}
</t>
<t tx="ekr.20071102162910.205"></t>
<t tx="ekr.20071102162910.206"># The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_change:
        self.doChangeAllScript()
    else:
        self.changeAll()
</t>
<t tx="ekr.20071102162910.207"># The user has pushed the "Change" button from the find panel.

def changeButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
    else:
        self.change()
</t>
<t tx="ekr.20071102162910.208"># The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
        if self.script_search:
            self.doFindScript()
        else:
            self.findNext()
    else:
        if self.script_search:
            self.change()
            self.doFindScript()
        else:
            self.changeThenFind()
</t>
<t tx="ekr.20071102162910.209"># The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    else:
        self.findAll()
</t>
<t tx="ekr.20071102162910.210"># The user has pushed the "Find" button from the find panel.

def findButton(self):

    self.setup_button()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
</t>
<t tx="ekr.20071102162910.211"># Initializes a search when a button is pressed in the Find panel.

def setup_button(self):

    c = self.c
    self.p = c.currentPosition()

    c.bringToFront()
    if 0: # We _must_ retain the editing status for incremental searches!
        c.endEditing()

    self.update_ivars()
</t>
<t tx="ekr.20071102162910.212"></t>
<t tx="ekr.20071102162910.213"># The user has selected the "Replace" menu item.

def changeCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
    else:
        self.change()
</t>
<t tx="ekr.20071102162910.214"># The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
        self.doFindScript()
    else:
        self.changeThenFind()
</t>
<t tx="ekr.20071102162910.215">def dismiss (self):
    pass
</t>
<t tx="ekr.20071102162910.216"># The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
</t>
<t tx="ekr.20071102162910.217"># The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

    self.setup_command()

    self.reverse = not self.reverse

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()

    self.reverse = not self.reverse
</t>
<t tx="ekr.20071102162910.218">def handleUserClick (self,p):

    """Reset suboutline-only search when the user clicks a headline."""

    try:
        if self.c and self.suboutline_only:
            # g.trace(p)
            self.onlyPosition = p.copy()
    except: pass
</t>
<t tx="ekr.20071102162910.219"># Initializes a search when a command is invoked from the menu.

def setup_command(self):

    # g.trace('leoFind')

    if 0: # We _must_ retain the editing status for incremental searches!
        self.c.endEditing()

    self.update_ivars()
</t>
<t tx="ekr.20071102162910.220"></t>
<t tx="ekr.20071102162910.221">@ This routine performs a single batch change operation, updating the head or body string of p and leaving the result in s_ctrl.  We update the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; w = self.s_ctrl
    # Replace the selection with self.change_text
    if pos1 &gt; pos2: pos1,pos2=pos2,pos1
    s = w.getAllText()
    if pos1 != pos2: w.delete(pos1,pos2)
    w.insert(pos1,self.change_text)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+len(self.change_text))
    w.setSelectionRange(insert,insert)
    w.setInsertPoint(insert)
    # Update the node
    s = w.getAllText() # Used below.
    if self.in_headline:
        &lt;&lt; change headline &gt;&gt;
    else:
        &lt;&lt; change body &gt;&gt;
</t>
<t tx="ekr.20071102162910.222">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.headString():

    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Headline',undoData)
</t>
<t tx="ekr.20071102162910.223">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.bodyString():

    undoData = u.beforeChangeNodeContents(p)

    c.setBodyString(p,s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Body',undoData)
</t>
<t tx="ekr.20071102162910.224">def change(self,event=None):

    if self.checkArgs():
        self.initInHeadline()
        self.changeSelection()
</t>
<t tx="ekr.20071102162910.225">def changeAll(self):

    # g.trace(g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.currentPosition()
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        while 1:
            pos1, pos2 = self.findNextMatch()
            if pos1 is None: break
            count += 1
            self.batchChange(pos1,pos2)
            s = w.getAllText()
            i,j = g.getLine(s,pos1)
            line = s[i:j]
            self.printLine(line,allFlag=True)
        p = c.currentPosition()
        u.afterChangeGroup(p,undoType,reportFlag=True)
        g.es("changed: %d instances" % (count))
    finally:
        c.endUpdate()
        self.restore(saveData)
</t>
<t tx="ekr.20071102162910.226"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl) # 2007:10/25
    oldSel = sel = w.getSelectionRange()
    start,end = sel
    if start &gt; end: start,end = end,start
    if start == end:
        g.es("No text selected") ; return False

    # g.trace(start,end)

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text

    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)

    for w2 in (w,self.s_ctrl):
        if start != end: w2.delete(start,end)
        w2.insert(start,change_text)
        w2.setInsertPoint(g.choose(self.reverse,start,start+len(change_text)))

    # Update the selection for the next match.
    w.setSelectionRange(start,start+len(change_text))
    c.widgetWantsFocus(w)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
        if self.mark_changes:
            p.setMarked()
        if self.in_headline:
            c.frame.tree.onHeadChanged(p,'Change')
        else:
            c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.

    return True
</t>
<t tx="ekr.20071102162910.227">def makeRegexSubs(self,s,groups):

    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''

    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j &lt; n:
        k = s.find('\\',j)
        if k == -1 or k + 1 &gt;= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn &lt; len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
</t>
<t tx="ekr.20071102162910.228">def changeThenFind(self):

    if not self.checkArgs():
        return

    self.initInHeadline()
    if self.changeSelection():
        self.findNext(False) # don't reinitialize
</t>
<t tx="ekr.20071102162910.229">def doChangeScript (self):

    g.app.searchDict["type"] = "change"
    self.runChangeScript()

def doChangeAllScript (self):

    """The user has just pressed the Change All button with script-change box checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "changeAll"
    while 1:
        self.runChangeScript()
        if not g.app.searchDict.get("continue"):
            break

def runChangeScript (self):

    try:
        assert(self.script_change)
        exec self.change_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing change script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
</t>
<t tx="ekr.20071102162910.230">def doFindScript (self):

    g.app.searchDict["type"] = "find"
    self.runFindScript()

def doFindAllScript (self):

    """The user has just pressed the Find All button with script-find radio button checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "findAll"
    while 1:
        self.runFindScript()
        if not g.app.searchDict.get("continue"):
            break

def runFindScript (self):

    try:
        exec self.find_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing find script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
</t>
<t tx="ekr.20071102162910.231">def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                &lt;&lt; create the found node and begin the undo group &gt;&gt;
            clones.append(self.p.v.t)
            &lt;&lt; create a clone of p under the find node &gt;&gt;
    if self.clone_find_all and clones:
        c.setRootPosition(c.findRootPosition(found)) # New in 4.4.2.
        u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    c.redraw_now()
    g.es("found: %d matches" % (count))
    self.restore(data)
</t>
<t tx="ekr.20071102162910.232">u.beforeChangeGroup(c.currentPosition(),undoType)

undoData = u.beforeInsertNode(c.currentPosition())

oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)

u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
</t>
<t tx="ekr.20071102162910.233">undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
</t>
<t tx="ekr.20071102162910.234">def findNext(self,initFlag=True):

    c = self.c
    if not self.checkArgs():
        return

    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()

    pos, newpos = self.findNextMatch()

    if pos is None:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found: " + "'" + self.find_text + "'")
        self.restore(data)
    else:
        self.showSuccess(pos,newpos)
</t>
<t tx="ekr.20071102162910.235"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not self.search_headline and not self.search_body:
        return None, None

    if len(self.find_text) == 0:
        return None, None

    p = self.p ; self.errors = 0
    attempts = 0
    self.backwardAttempts = 0
    while p:
        pos, newpos = self.search()
        # g.trace('pos',pos,'p',p.headString(),g.callers())
        if pos is not None:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            g.trace('find errors')
            return None,None # Abort the search.
        elif self.node_only:
            return None,None # We are only searching one node.
        else:
            attempts += 1
            p = self.p = self.selectNextPosition()
    # g.trace('attempts',attempts,'backwardAttempts',self.backwardAttempts)
    return None, None
</t>
<t tx="ekr.20071102162910.236">def resetWrap (self,event=None):

    self.wrapPosition = None
    self.onlyPosition = None
</t>
<t tx="ekr.20071102162910.237">def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.

    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()
    s = w.getAllText()

    # g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)
    # g.trace('pos,newpos',pos,newpos)
    if pos == -1: return None,None
    &lt;&lt; fail if we are passed the wrap point &gt;&gt;
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)
    return pos,newpos
</t>
<t tx="ekr.20071102162910.238">if self.wrapping and self.wrapPos is not None and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos &lt; self.wrapPos:
        # g.trace("reverse wrap done")
        return None, None

    if not self.reverse and newpos &gt; self.wrapPos:
        # g.trace('wrap done')
        return None, None
</t>
<t tx="ekr.20071102162910.239">def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):

    if swapij and backwards: i,j = j,i

    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # if s: g.trace('empty',i,j,'len(s)',len(s),'pattern',pattern)
        return -1,-1

    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    return pos,newpos
</t>
<t tx="ekr.20071102162910.240">def regexHelper (self,s,i,j,pattern,backwards,nocase):

    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1

    if backwards: # Scan to the last match.  We must use search here.
        last_mo = None ; i = 0
        while i &lt; len(s):
            mo = re_obj.search(s,i,j)
            if not mo: break
            i += 1 ; last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s,i,j)

    if 0:
        g.trace('i',i,'j',j,'s[i:j]',repr(s[i:j]),
            'mo.start',mo and mo.start(),'mo.end',mo and mo.end())

    while mo and 0 &lt;= i &lt; len(s):
        if mo.start() == mo.end():
            if backwards:
                # Search backward using match instead of search.
                i -= 1
                while 0 &lt;= i &lt; len(s):
                    mo = re_obj.match(s,i,j)
                    if mo: break
                    i -= 1
            else:
                i += 1 ; mo = re_obj.search(s,i,j)
        else:
            self.match_obj = mo
            return mo.start(),mo.end()
    self.match_obj = None
    return -1,-1
</t>
<t tx="ekr.20071102162910.241">debugIndices = []

@
rfind(sub [,start [,end]])

Return the highest index in the string where substring sub is found, such that
sub is contained within s[start,end]. Optional arguments start and end are
interpreted as in slice notation. Return -1 on failure.
@c

def backwardsHelper (self,s,i,j,pattern,nocase,word):

    debug = False
    if nocase:
        s = s.lower() ; pattern = pattern.lower() # Bug fix: 10/5/06: At last the bug is found!
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)

    if i &lt; 0 or i &gt; len(s) or j &lt; 0 or j &gt; len(s):
        g.trace('bad index: i = %s, j = %s' % (i,j))
        i = 0 ; j = len(s)

    if debug and (s and i == 0 and j == 0):
        g.trace('two zero indices')

    self.backwardAttempts += 1

    # short circuit the search: helps debugging.
    if s.find(pattern) == -1:
        if debug:
            self.debugCount += 1
            if self.debugCount &lt; 50:
                g.trace(i,j,'len(s)',len(s),self.p.headString())
        return -1,-1

    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            if debug: g.trace('**word** %3s %3s %5s -&gt; %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.headString()))
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        if debug: g.trace('%3s %3s %5s -&gt; %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.headString()))
        if k == -1:
            return -1, -1
        else:
            return k,k+n
</t>
<t tx="ekr.20071102162910.242">@tabwidth 4

def plainHelper (self,s,i,j,pattern,nocase,word):

    # g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
	pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n
</t>
<t tx="ekr.20071102162910.243">def matchWord(self,s,i,pattern):

    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 &lt;= i-1 &lt; len(s) and s[i-1] or '.'
    ch2 = 0 &lt;= i+n &lt; len(s) and s[i+n] or '.'

    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)

    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))

    if isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2:
        return False
    else:
        return True
</t>
<t tx="ekr.20071102162910.244">def replaceBackSlashes (self,s):

    '''Carefully replace backslashes in a search pattern.'''

    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.

    i = 0
    while i + 1 &lt; len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                 s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
</t>
<t tx="ekr.20071102162910.245"># Selects the next node to be searched.

def selectNextPosition(self):

    c = self.c ; p = self.p ; trace = False

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        if trace: g.trace('switching to body',g.callers(5))
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()

    # if trace: g.trace(p and p.headString() or 'None')

    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        if trace: g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
</t>
<t tx="ekr.20071102162910.246"></t>
<t tx="ekr.20071102162910.247">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; w = self.find_ctrl

    # g.trace(g.callers())
    c.widgetWantsFocusNow(w)
    g.app.gui.selectAllText(w)
    c.widgetWantsFocus(w)
</t>
<t tx="ekr.20071102162910.248">def oops(self):
    print ("leoFind oops:",
        g.callers(10),"should be overridden in subclass")
</t>
<t tx="ekr.20071102162910.249">def selectAllFindText (self,event=None):

    __pychecker__ = '--no-argsused' # event

    # This is called only when the user presses ctrl-a in the find panel.

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        w.selectAllText()

    return "break"
</t>
<t tx="ekr.20071102162910.250"></t>
<t tx="ekr.20071102162910.251">def checkArgs (self):

    val = True
    if not self.search_headline and not self.search_body:
        g.es("not searching headline or body")
        val = False
    if len(self.find_text) == 0:
        g.es("empty find patttern")
        val = False
    return val
</t>
<t tx="ekr.20071102162910.252"># Initializes for the Find All and Change All commands.

def initBatchCommands (self):

    c = self.c
    self.in_headline = self.search_headline # Search headlines first.
    self.errors = 0

    # Select the first node.
    if self.suboutline_only or self.node_only:
        self.p = c.currentPosition()
    else:
        p = c.rootPosition()
        if self.reverse:
            while p and p.next():
                p = p.next()
            p = p.lastNode()
        self.p = p

    # Set the insert point.
    self.initBatchText()
</t>
<t tx="ekr.20071102162910.253"># Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self,ins=None):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    self.init_s_ctrl(s,ins)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self,ins=None):
    p = self.p
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    self.init_s_ctrl(s,ins)

def init_s_ctrl (self,s,ins):

    w = self.s_ctrl
    w.setAllText(s)
    if ins is None:
        ins = g.choose(self.reverse,len(s),0)
        # print g.choose(self.reverse,'.','*'),
    else:
        pass # g.trace('ins',ins)
    w.setInsertPoint(ins)
</t>
<t tx="ekr.20071102162910.254"># Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

    c = self.c ; p = self.p

    # Do not change this without careful thought and extensive testing!
    if self.search_headline and self.search_body:
        # A temporary expedient.
        if self.reverse:
            self.in_headline = False
        else:
            # Search headline first.
            self.in_headline = (
                p == c.frame.tree.editPosition() and
                c.get_focus() != c.frame.body.bodyCtrl)
    else:
        self.in_headline = self.search_headline
</t>
<t tx="ekr.20071102162910.255">def initInteractiveCommands(self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    self.errors = 0

    # We only use the insert point, *never* the selection range.
    ins = w.getInsertPoint()
    # g.trace('ins',ins)
    self.debugCount = 0
    self.initNextText(ins=ins)
    c.widgetWantsFocus(w)

    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = ins
        # Do not set self.wrapPosition here: that must be done after the first search.
</t>
<t tx="ekr.20071102162910.256">def printLine (self,line,allFlag=False):

    both = self.search_body and self.search_headline
    context = self.batch # "batch" now indicates context

    if allFlag and both and context:
        g.es('-' * 20,self.p.headString())
        theType = g.choose(self.in_headline,"head: ","body: ")
        g.es(theType + line)
    elif allFlag and context and not self.p.isVisited():
        # We only need to print the context once.
        g.es('-' * 20,self.p.headString())
        g.es(line)
        self.p.setVisited()
    else:
        g.es(line)
</t>
<t tx="ekr.20071102162910.257"># Restores the screen after a search fails

def restore (self,data):

    c = self.c
    in_headline,p,t,insert,start,end = data

    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)

    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        t.setSelectionRange(insert,insert)
        t.setInsertPoint(insert)
        t.seeInsertPoint()

    #g.trace(c.widget_name(t))

    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocusNow()
    else:
        c.widgetWantsFocusNow(t)
</t>
<t tx="ekr.20071102162910.258">def save (self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)

    # 2007/10/24: defensive programming for unit tests.
    if w:
        insert = w.getInsertPoint()
        sel = w.getSelectionRange()
        if len(sel) == 2:
            start,end = sel
        else:
            start,end = None,None
    else:
        start,end = None,None

    return (self.in_headline,p,w,insert,start,end)
</t>
<t tx="ekr.20071102162910.259">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.body.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible(c)
    c.beginUpdate()
    try:
        if sparseFind:
            # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
            for p in c.allNodes_iter():
                if not p.isAncestorOf(self.p):
                    p.contract()
                    redraw = True
            for p in self.p.parents_iter():
                if not p.isExpanded():
                    p.expand()
                    redraw = True
        p = self.p
        if not p: g.trace('can not happen: self.p is None')
        c.selectPosition(p)
    finally:
        c.endUpdate(redraw)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    c.widgetWantsFocusNow(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20071102162910.260"># New in Leo 4.4.3: This is now gui-independent code.

def update_ivars (self):

    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        # g.trace(self.svarDict.get(key))
        val = self.svarDict[key].get()
        setattr(self, key, val) # No more _flag hack.

    # Set ivars from radio buttons. Convert these to 1 or 0.
    search_scope = self.svarDict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0)

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.getAllText()
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.getAllText()
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
</t>
<t tx="ekr.20071102162910.261">def getSelectionRange (self,sort=True):

    """Return a tuple representing the selected range of the widget.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self

    sel = w._getSelectionRange() # wx.richtext.RichTextCtrl returns (-1,-1) on no selection.
    if len(sel) == 2 and sel[0] &gt;= 0 and sel[1] &gt;= 0:
        #g.trace(self,'baseWidget: sel',repr(sel),g.callers(6))
        i,j = sel
        if sort and i &gt; j: sel = j,i # Bug fix: 10/5/07
        return sel
    else:
        # Return the insertion point if there is no selected text.
        i =  w._getInsertPoint()
        #g.trace(self,'baseWidget: i',i,g.callers(6))
        return i,i
</t>
<t tx="ekr.20071102162910.262">@
The was to g.getLine.

This is a potentially major change.  All unit tests pass.</t>
<t tx="ekr.20071102162910.263">At least three bugs.

- Place cursor on last (blank) line.  Cursor up goes one line too far.
- Place cursor at end of line 1.  Second cursor down does nothing.
- Place cursor at end of xxxx line.  Second cursor down goes one line too far.

xxxxxxxxx
line 1
line 2
</t>
<t tx="ekr.20071102162910.264">def getWord (s,i):

    '''Return i,j such that s[i:j] is the word surrounding s[i].'''

    if i &gt;= len(s): i = len(s) - 1
    if i &lt; 0: i = 0
    # Scan backwards.
    while 0 &lt;= i &lt; len(s) and g.isWordChar(s[i]):
        i-= 1
    i += 1
    # Scan forwards.
    j = i
    while 0 &lt;= j &lt; len(s) and g.isWordChar(s[j]):
        j += 1
    return i,j

def getLine (s,i):

    '''Return i,j such that s[i:j] is the line surrounding s[i].
    s[i] is a newline only if the line is empty.
    s[j] is a newline unless there is no trailing newline.
    '''

    if i &gt; len(s): i = len(s) -1 # Bug fix: 10/6/07 (was if i &gt;= len(s))
    if i &lt; 0: i = 0
    j = s.rfind('\n',0,i) # A newline *ends* the line, so look to the left of a newline.
    if j == -1: j = 0
    else:       j += 1
    k = s.find('\n',i)
    if k == -1: k = len(s)
    else:       k = k + 1
    # g.trace('i,j,k',i,j,k,repr(s[j:k]))
    return j,k</t>
<t tx="ekr.20071102162910.265">if g.unitTesting:
    s = 'a\ncd\n\ne'
    for i,result in (
        (-1,(0,2)), # One too few.
        (0,(0,2)),(1,(0,2)),
        (2,(2,5)),(3,(2,5)),(4,(2,5)),
        (5,(5,6)),
        (6,(6,7)),
        (7,(6,7)), # One too many.
    ):
        j,k = g.getLine(s,i)
        assert (j,k) == result, 'i: %d, expected %d,%d, got %d,%d' % (i,result[0],result[1],j,k)</t>
<t tx="ekr.20071102162910.266">if g.unitTesting:
    s = 'abc xy_z5 pdq'
    i,j = g.getWord(s,5)
    assert s[i:j] == 'xy_z5','got %s' % s[i:j]
</t>
<t tx="ekr.20071102162910.267"></t>
<t tx="ekr.20071102162910.268"></t>
<t tx="ekr.20071102162910.269">def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if True: #### j2 &lt; len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot &lt; self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()</t>
<t tx="ekr.20071102162910.270">if g.unitTesting:
    c.beginUpdate()
    try:
        ec = c.editCommands ; w = c.frame.body.bodyCtrl

        for i,j,python in (
            # ('1.0','4.5',False),
            (5,50,True),
        ):
            extend = True
            ec.moveSpot = None # It's hard to init this properly.
            ec.extendHelper(w,extend,j)
            i2,j2 = w.getSelectionRange()
            # print i2,j2
            #assert 0==i2, 'Expected i=%s, got %s' % (repr(i),repr(i2))
            #assert j==j2, 'Expected j=%s, got %s' % (repr(j),repr(j2))
    finally:
        c.endUpdate(False)
</t>
<t tx="ekr.20071102162910.271">def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    trace = False

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    if trace: g.trace('ins',ins,'row',row,'col',col)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    n = max(0,j2-i2-1) # The length of the new line.
    col2 = min(col,n)
    spot = i2 + col2
    if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)</t>
<t tx="ekr.20071102162910.272">if g.unitTesting:
    c.beginUpdate()
    try:

        ec = c.editCommands ; w = c.frame.body.bodyCtrl

        for i,result,direction in (('5.8','4.8','up'),('5.8','6.8','down')):
            event = None ; extend = False; ec.moveSpot = None
            w.setInsertPoint(i)
            ec.moveUpOrDownHelper (event,direction,extend)
            i2,j2 = w.getSelectionRange()
            if 1:
                break
            else:
                assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
                assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
                w.setSelectionRange(0,0,insert=None)
    finally:
        c.endUpdate(False)
</t>
<t tx="ekr.20071102162910.273">def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot &lt; i: spot = i
        elif spot &gt; j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)</t>
<t tx="ekr.20071102162910.274">if g.unitTesting:
    c.beginUpdate()
    try:
        ec = c.editCommands ; w = c.frame.body.bodyCtrl

        for i,j,python in (
            #('1.0','4.5',False),
            (5,50,True),
        ):
            event = None ; extend = True ; ec.moveSpot = None
            w.setInsertPoint(i)
            ec.moveToHelper (event,j,extend)
            i2,j2 = w.getSelectionRange()
            assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
            assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
            w.setSelectionRange(0,0,insert=None)
    finally:
        c.endUpdate(False)
</t>
<t tx="ekr.20071102162910.275">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i &gt;= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j &gt;= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i &lt; j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 &lt; len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 &lt; len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 &gt; j2: return

    self.moveToHelper(event,i2+1,extend)
</t>
<t tx="ekr.20071102162910.276">def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
            i -= 1
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i -= 1
        i += 1

    self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20071102162910.277">def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    i = w.getInsertPoint()

    while i &gt;= 0:
        if s[i] == '.': break
        i -= 1
    else: return

    j = i-1
    while j &gt;= 0:
        if s[j] == '.':
            j += 1 ; break
        j -= 1
    else: j = 0

    while j &lt; i and s[j].isspace():
        j += 1

    if j &lt; i:
        self.moveToHelper(event,j,extend)
</t>
<t tx="ekr.20071102162910.278">def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins) + 1
    i = min(i,len(s))
    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20071102162910.279">def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1

    # Skip to the next non-blank line.
    i = j
    while j &lt; len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20071102162910.280">def backwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i,j = g.getLine(s,j)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i &gt; 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i &gt; 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20071102162910.281">def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=True)
</t>
<t tx="ekr.20071102162910.282">def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=False)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=True)
</t>
<t tx="ekr.20071102162910.283">def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    g.es('Extend mode %s' % (g.choose(val,'on','off')), color='red')
    c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20071102162910.284">def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange(sort=False)
    if i == j: return

    ins = w.getInsertPoint()
    ins = g.choose(ins==i,j,i)
    w.setInsertPoint(ins)
    w.setSelectionRange(i,j,insert=None)
</t>
<t tx="ekr.20071102162910.285">def extendToLine (self,event):

    '''Select the line at the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
</t>
<t tx="ekr.20071102162910.286">def extendToSentence (self,event):

    '''Select the line at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)</t>
<t tx="ekr.20071102162910.287">def extendToWord (self,event):

    '''Select the word at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
        i -= 1
    while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        i -= 1
    i += 1

    # Move to the end of the word.
    i1 = i
    while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)</t>
<t tx="ekr.20071102162910.288">def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=True)

def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False)

def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
</t>
<t tx="ekr.20071102162910.289">def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)

def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
</t>
<t tx="ekr.20071102162910.290">def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)

def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)

def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)

def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
</t>
<t tx="ekr.20071102162910.291">def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)

def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)

def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)

def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
</t>
<t tx="ekr.20071102162910.292">def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)

def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)

def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)

def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)

def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20071102162910.293">@
for methods that call g.getLine:

backward-delete-char
delete-indentation
fill-region (now uses the reformat-paragraph code).
setFillPrefix
</t>
<t tx="ekr.20071102162910.294">def fillRegion (self,event):

    '''Fill all paragraphs in the selected text.'''

    # New in Leo 4.4.4: just use reformat-paragraph logic.

    c = self.c ; p = c.currentPosition() ; undoType = 'fill-region'
    w = self.editWidget(event)
    i,j = w.getSelectionRange()
    c.undoer.beforeChangeGroup(p,undoType)
    while 1:
        self.c.reformatParagraph(event,undoType='reformat-paragraph')
        ins = w.getInsertPoint()
        s = w.getAllText()
        if ins &gt;= j or ins &gt;= len(s):
            break
    c.undoer.afterChangeGroup(p,undoType)
</t>
<t tx="ekr.20071102162910.295">def indentToCommentColumn (self,event):

    '''Insert whitespace to indent the line containing the insert point to the comment column.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='indent-to-comment-column')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]
    c1 = int(self.ccolumn)
    line2 = ' ' * c1 + line.lstrip()
    if line2 != line:
        w.delete(i,j)
        w.insert(i,line2)
    w.setInsertPoint(i+c1)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20071102162910.296">def setFillPrefix( self, event ):

    '''Make the selected text the fill prefix.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    self.fillPrefix = s[i:j]
</t>
<t tx="ekr.20071102162910.297">http://sourceforge.net/forum/message.php?msg_id=4557854

The customizing attributes code doesn't work from the User's Guide here:

http://webpages.charter.net/edreamleo/customizing.html#adding-extensible-attribu
tes-to-nodes-and-leo-files

I corrected the hasattr problem and added sample read code here:

@color

# Create the uA if necessary.
if not hasattr(p.v.t,'unknownAttributes'):
....p.v.t.unknownAttributes = {}

# Get the inner dictionary for the 'xyzzy' plugin, creating it if necessary.
d = p.v.t.unknownAttributes.get('xyzzy',{})

# Set some values. These values must be picklable.
d ['duration'] = 5
d ['notes'] = "This is a note."

# Update the uA.
p.v.t.unknownAttributes ['xyzzy'] = d

if hasattr(p.v.t,"unknownAttributes"):
....d = p.v.t.unknownAttributes.get("xyzzy",{ })
....g.es(d['duration'])
....g.es(d['notes'])
</t>
<t tx="ekr.20071102162910.298">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4558330
By: vransmayr

Hi Edward,

I don't get @auto nodes/trees to work the way I expected them to work ...

Here are the facts as they occur in my environment:

* I'm using the latest CVS-snapshot of Leo.

&lt;Leo Log Pane&gt;

Leo Log Window...
Leo 4.4.4 b3, build  1.210 , October 8, 2007
Python 2.4.3, Tk 8.4.7, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

redefining close-window in all to extend-to-word in all
redefining goto-first-node in tree to goto-first-visible-node in tree
redefining goto-first-node in tree to goto-first-visible-node in all
redefining goto-first-node in tree to goto-first-visible-node in all
redefining forward-sentence in text to propagate-key-event in all
redefining forward-word in text to propagate-key-event in all
redefining kill-region-save in all to propagate-key-event in all
leoID = vr20060903 (in C:\Dokumente und Einstellungen\VR)
global config dir: C:\CVS-Reps\leo\config
home dir: C:\Dokumente und Einstellungen\VR
reading settings in C:\CVS-Reps\leo\config\leoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\myLeoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\Eigene
Dateien\WLog\WLog.leo
reading: C:\Dokumente und Einstellungen\VR\Eigene Dateien\WLog\WLog.leo

&lt;/Leo Log Pane&gt;

I try to create an @auto-node from a simple python file, where I would
not expect
any problems with. - In my case I used "roman.py" in
"C:\Python24\Lib\site-packages\".

@auto C:\\Python24\\Lib\\site-packages\\roman.py

When I try to save the outline I receive the following error-messages:

&lt;Leo Log Pane&gt;

reading new @auto C:\\Python24\\Lib\\site-packages\\roman.py
*** first mismatch at line 1
original line:  u'"""Convert to and from Roman numerals"""\n'
generated line: '"""Convert to and from Roman numerals"""\r\n'
@auto did not import the file perfectly
first mismatched line: 1
'"""Convert to and from Roman numerals"""\r\n'
inserting @ignore
Errors inhibited read @auto C:\\Python24\\Lib\\site-packages\\roman.py
saved: WLog.leo

&lt;/Leo Log Pane&gt;

What am I missing ?

Regards,

    Viktor Ransmayr
</t>
<t tx="ekr.20071102162910.299"># This should have been done long ago.</t>
<t tx="ekr.20071102162910.300"># Convert all args to strings.

def trace (*args,**keys):

    #callers = keys.get("callers",False)
    newline = keys.get("newline",True)
    align =   keys.get("align",0)

    s = ""
    for arg in args:
        if type(arg) == type(u""):
            pass
            # try:    arg = str(arg) 
            # except: arg = repr(arg)
        elif type(arg) != type(""):
            arg = repr(arg)
        if len(s) &gt; 0:
            s = s + " " + arg
        else:
            s = arg
    message = s

    try: # get the function name from the call stack.
        f1 = sys._getframe(1) # The stack frame, one level up.
        code1 = f1.f_code # The code object
        name = code1.co_name # The code name
    except: name = ''
    if name == "?":
        name = "&lt;unknown&gt;"

    # if callers:
        # traceback.print_stack()

    if align != 0 and len(name) &lt; abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align &gt; 0: name = name + pad
        else:         name = pad + name

    message = g.toEncodedString(message,'ascii') # Bug fix: 10/10/07.

    if newline:
        print name + ": " + message
    else:
        print name + ": " + message,
</t>
<t tx="ekr.20071102162910.301">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4574018
</t>
<t tx="ekr.20071102162910.302">http://sourceforge.net/forum/message.php?msg_id=4573990
</t>
<t tx="ekr.20071102162910.303">def moveNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; u = c.undoer ; undoType = 'Move Node To Chapter'
    p = c.currentPosition()
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        cc.error('chapter "%s" does not exist' % toChapterName)
        return

    if 1: # Defensive code: should never happen.
        if fromChapter.name == 'main' and p.headString().startswith('@chapter'):
            return cc.error('can not move @chapter node')

    c.beginUpdate()
    try:
        if toChapter.name == 'main':
            sel = (p.threadBack() != fromChapter.root and p.threadBack()) or p.nodeAfterTree()
        else:
            sel = p.threadBack() or p.nodeAfterTree()
        if sel:
            # Get 'before' undo data.
            inAtIgnoreRange = p.inAtIgnoreRange()
            undoData = u.beforeMoveNode(p)
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
            # Do the move.
            if toChapter.name == 'main':
                p.unlink()
                p.moveAfter(toChapter.p)
            else:
                p.unlink()
                p.moveToLastChildOf(toChapter.root)
            c.selectPosition(sel)
            c.setChanged(True)
            # Do the 'after' undo operation.
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(False) # toChapter.select will do the drawing.

    if sel:
        toChapter.p = p.copy()
        toChapter.select()
        fromChapter.p = sel.copy()
    else:
        cc.error('Can not move the last node of a chapter.')
</t>
<t tx="ekr.20071102162910.304"></t>
<t tx="ekr.20071102162910.305">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4527231
By: ktenney

@others doesn't get stripped when creating
scriptfile.py for use by &lt;alt-x&gt; &lt;debug&gt;, so winpdb encounters bad syntax.

@color</t>
<t tx="ekr.20071102162910.306">def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # print '*** script\n',script
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    execfile(scriptFile,d)
                else:
                    exec script in d
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
</t>
<t tx="ekr.20071102162910.307">def redirectScriptOutput (self):

    c = self

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
</t>
<t tx="ekr.20071102162910.308">def unredirectScriptOutput (self):

    c = self

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
</t>
<t tx="ekr.20071102162910.309">def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        parts = path.split('/')
        path = g.app.loadDir
        for part in parts:
            path = g.os_path_abspath(g.os_path_join(path,part))
    else:
        path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile.py'))

    # Write the file.
    try:
        f = file(path,'w')
        f.write(script)
        f.close()
    except Exception:
        path = None

    return path</t>
<t tx="ekr.20071102162910.310">if g.unitTesting:
    # print g.listToString(dir())

    for ivar in ('c','g','p'):
        assert ivar in dir()

    assert hasattr(g.app,'tkEncoding')
</t>
<t tx="ekr.20071102162910.311">def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):

    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands ; w = c.frame.body.bodyCtrl
    if not p:
        p = c.currentPosition()
    try:
        if g.app.inBridge:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and w.hasSelection():
                s = w.getSelectedText()
            else:
                s = w.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    # g.trace(type(script),repr(script))
    return script
</t>
<t tx="ekr.20071102162910.312">if g.unitTesting:

    c,p = g.getTestVars() # Optional: prevents pychecker warnings.
    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
</t>
<t tx="ekr.20071102162910.313">def debug (self,event=None):

    '''Start an external debugger in another process to debug a script.
    The script is the presently selected text or then entire tree's script.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    script = g.getScript(c,p)
    winpdb = self.findDebugger()
    if not winpdb: return

    #check for doctest examples
    try:
        import doctest
        parser = doctest.DocTestParser()
        examples = parser.get_examples(script)

        # if this is doctest, extract the examples as a script
        if len(examples) &gt; 0:
            script = doctest.script_from_examples(script)
    except ImportError:
        pass

    # special case; debug code may include g.es("info string").
    # insert code fragment to make this expression legal outside Leo.
    hide_ges = "class G:\n def es(s,c=None):\n  pass\ng = G()\n"
    script = hide_ges + script

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
</t>
<t tx="ekr.20071102162910.314">def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
</t>
<t tx="ekr.20071102162910.315">@nocolor

RE: C++ Import to @file problem (New)

By: R Shanley (rjshanley1) - 2007-10-11 10:47
I found this problem in last night's CVS download. 

Line's like this, alone or in a larger file, take the exception shown.  

stuff* stuff::m_instance = 0; 


Traceback (most recent call last): 
File "C:\leolatestCVS\leo\src\leoCommands.py", line 276, in doCommand 
val = command(event) 
File "C:\leolatestCVS\leo\src\leoCommands.py", line 1560, in importAtFile 
c.importCommands.importFilesCommand(names,"@file") 
File "C:\leolatestCVS\leo\src\leoImport.py", line 881, in importFilesCommand 
v = self.createOutline(fileName,current) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 737, in createOutline 
self.scanCText(s,p,atAuto=atAuto) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 2516, in scanCText 
scanner.run(s,parent) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 2449, in run 
scanner.scan(s,parent) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 1981, in scan 
i = start = self.skipDecls(s,0,len(s)) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 2154, in skipDecls 
elif self.startsFunction(s,i,quick=True): 
File "C:\leolatestCVS\leo\src\leoImport.py", line 2256, in startsFunction 
i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 2286, in startsHelper 
i, ids, classId = self.skipSigStart(s,j,tags) # Rescan the first id. 
ValueError: need more than 2 values to unpack 

</t>
<t tx="ekr.20071102162910.316">@nocolor

@ For example:

def x():
    pass

if g.unitTesting:
    def test_x(): # over-indented.
        pass

def y():
    pass

@c

@color</t>
<t tx="ekr.20071102162910.317">def skipCodeBlock (self,s,i,kind):

    trace = False ; verbose = False
    # if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            i = g.skip_nl(s,i)
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                pass # We have already made progress.
            else:
                if trace and verbose: g.trace(g.get_line(s,i))
                backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
                if not backslashNewline:
                    i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                        s,i,parenCount,startIndent,underIndentedStart)
                    if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress &lt; i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 &lt; i &lt; len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
        return i,False
    if (trace or self.trace) and s[start:i].strip():
        g.trace('%s returns\n' % (kind) + s[start:i])
    return i,True
</t>
<t tx="ekr.20071102162910.318">def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace('startIndent',startIndent,'indent',indent,'line',repr(g.get_line(s,j)))
    if indent &lt;= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent &lt;= startIndent:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
</t>
<t tx="ekr.20071102162910.319"></t>
<t tx="ekr.20071102162910.320">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4566691
By: vransmayr
</t>
<t tx="ekr.20071102162910.321">@nocolor

&gt; When I tried to open the 'old' outline w/ the java-interfaces imported as
@auto-nodes Leo 'crashed'. That is using pythonw.exe did not open the outline.

Thanks for this report.  As I understand the rest of the trace, the following files did not import properly:

AdminPermission.java 
BundleEvent.java 
BundleException.java 
BundlePermission.java 
FrameworkEvent.java 
FrameworkUtil.java 
InvalidSyntaxException.java 
package.html 
packageinfo 
PackagePermission.java 
ServiceEvent.java 
ServicePermission.java 
Version.java

That should be enough to get me started :-)

Edward

Read and respond to this message at:
https://sourceforge.net/forum/message.php?msg_id=4576575
By: vransmayr

Hi Edward,

  I'm replying to this thread and not to

http://sourceforge.net/forum/message.php?msg_id=4576197

because I guess that it's not a Java-specific problem.

For the record: I performed a CVS update just before the exercise.

When I tried to open the 'old' outline w/ the java-interfaces imported
as @auto-nodes
Leo 'crashed'. - That is using "pythonw.exe ..." did not open the outline.

When I modified the windows explorer to open outlines w/ "python.exe" I received
the
following output.

&lt;cmd shell output&gt;

reading settings in C:\CVS-Reps\leo\config\leoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\myLeoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Frameworks\
OSGi\OSGi\r41\OSGi-Core-Framework-r41.leo
reading C:\Dokumente und Einstellungen\VR\.leoRecentFiles.txt
@enabled-plugins found in myLeoSettings.leo
rst3 plugin: SilverCity not loaded
loadOnePlugin: no init() detect_urls
loadOnePlugin: no init() empty_leo_file
redefining close-window in all to extend-to-word in all
redefining goto-first-node in tree to goto-first-visible-node in tree
redefining goto-first-node in tree to goto-first-visible-node in all
redefining goto-first-node in tree to goto-first-visible-node in all
redefining forward-sentence in text to propagate-key-event in all
redefining forward-word in text to propagate-key-event in all
redefining kill-region-save in all to propagate-key-event in all
*** first mismatch at line 79
original line:  u'\tstatic final long\t\t\t\t\tserialVersionUID\t=
3070510045212
61705L;\n'
generated line: '    private static class ImplHolder implements
PrivilegedAction
{\n'
@auto did not import the file perfectly
first mismatched line: 79
'    private static class ImplHolder implements PrivilegedAction {\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\AdminPermission.java
*** first mismatch at line 41
original line:  u'\tstatic final long\t\tserialVersionUID\t=
4080640865971756012
L;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 41
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\BundleEvent.java
*** first mismatch at line 38
original line:  u'\tstatic final long\tserialVersionUID\t=
3571095144220455665L;
\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 38
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\BundleException.java
*** first mismatch at line 51
original line:  u'\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 51
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\BundlePermission.java
*** first mismatch at line 41
original line:  u'\tstatic final long\t\tserialVersionUID\t=
207051004521261705L
;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 41
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\FrameworkEvent.java
*** first mismatch at line 37
original line:  u'\t/*\n'
generated line: '    private static class ImplHolder implements
PrivilegedAction
{\n'
@auto did not import the file perfectly
first mismatched line: 37
'    private static class ImplHolder implements PrivilegedAction {\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\FrameworkUtil.java
*** first mismatch at line 38
original line:  u'\tstatic final long\t\tserialVersionUID\t=
-429519442081649187
5L;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 38
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\InvalidSyntaxException.j
ava
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\package.html
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\packageinfo
*** first mismatch at line 50
original line:  u'\tstatic final long\t\t\tserialVersionUID\t=
-5107705877071099
135L;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 50
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\PackagePermission.java
*** first mismatch at line 41
original line:  u'\tstatic final long\t\t\t\tserialVersionUID\t=
879290148390940
9299L;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 41
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\ServiceEvent.java
*** first mismatch at line 43
original line:  u'\tstatic final long\t\t\tserialVersionUID\t=
-7662148639076511
574L;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 43
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\ServicePermission.java
*** first mismatch at line 46
original line:  u'\tprivate final int\t\t\tmajor;\n'
generated line: '    public static final Version\temptyVersion\t=
new Version(0,
0, 0);\n'
@auto did not import the file perfectly
first mismatched line: 46
'    public static final Version\temptyVersion\t= new Version(0, 0, 0);\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\Version.java

&lt;/cmd shell output&gt;

Kind regards,

Viktor
</t>
<t tx="ekr.20071102162910.322"></t>
<t tx="ekr.20071102162910.323">def removeSentinelsCommand (self,paths,toString=False):

    c = self.c

    self.setEncoding()

    for fileName in paths:
        g.setGlobalOpenDir(fileName)
        path, self.fileName = g.os_path_split(fileName)
        &lt;&lt; Read file into s &gt;&gt;
        &lt;&lt; set delims from the header line &gt;&gt;
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = c.config.remove_sentinels_extension
        if not ext:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        if toString:
            return s
        else:
            &lt;&lt; Write s into newFileName &gt;&gt;
            return None
</t>
<t tx="ekr.20071102162910.324">try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName, color="blue")
    leoTest.fail()
    return
</t>
<t tx="ekr.20071102162910.325"># Skip any non @+leo lines.
i = 0
while i &lt; len(s) and not g.find_on_line(s,i,"@+leo"):
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,new_df,start_delim,end_delim,derivedFileIsThin = at.parseLeoSentinel(line)
if not valid:
    if not toString: g.es("invalid @+leo sentinel in " + fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None
</t>
<t tx="ekr.20071102162910.326">try:
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    theFile = open(newFileName,mode)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    theFile.write(s)
    theFile.close()
    if not g.unitTesting:
        g.es("created: " + newFileName)
except:
    g.es("exception creating: " + newFileName)
    g.es_exception()
</t>
<t tx="ekr.20071102162910.327"></t>
<t tx="ekr.20071102162910.328"></t>
<t tx="ekr.20071102162910.329"></t>
<t tx="ekr.20071102162910.330">def scanCText (self,s,parent,atAuto=False):

    scanner = self.cScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071102162910.331">class cScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = '#' # A hack: treat preprocess directives as comments(!)
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = ['*']
        self.sigFailTokens = [';','=']
</t>
<t tx="ekr.20071102162910.332"></t>
<t tx="ekr.20071102162910.333">def scanCSharpText (self,s,parent,atAuto=False):

    scanner = self.cSharpScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071102162910.334">class cSharpScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class','interface','namespace',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = None
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = []
        self.sigFailTokens = [';','='] # Just like C.
</t>
<t tx="ekr.20071102162910.335"></t>
<t tx="ekr.20071102162910.336">def scanElispText (self,s,parent,atAuto=False):

    scanner = self.elispScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071102162910.337">class elispScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20071102162910.338">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

</t>
<t tx="ekr.20071102162910.339"># skipClass/Function/Signature are defined in the base class.</t>
<t tx="ekr.20071102162910.340">def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False
    end = self.skipBlock(s,i)
    if not g.match(s,end,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len(key)
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = g.skip_id(s,i)
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
</t>
<t tx="ekr.20071102162910.341">def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
</t>
<t tx="ekr.20071102162910.342"></t>
<t tx="ekr.20071102162910.343">def scanJavaText (self,s,parent,atAuto=False):

    scanner = self.javaScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071102162910.344">class javaScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20071102162910.345">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = '{'
    self.classTags = ['class','interface']
    self.functionTags = []
    self.sigFailTokens = [';','='] # Just like c.
</t>
<t tx="ekr.20071102162910.346">def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    # Remove 'public' and 'private'
    ids2 = [z for z in ids if z not in ('public','private','final',)]

    # Remove 'extends' and everything after it.
    ids = []
    for z in ids2:
        if z == 'extends': break
        ids.append(z)

    return i, ids and ids[-1]
</t>
<t tx="ekr.20071102162910.347"># The syntax for patterns causes all kinds of problems...</t>
<t tx="ekr.20071102162910.348">def scanJavaScriptText (self,s,parent,atAuto=False):

    scanner = self.javaScriptScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071102162910.349">class javaScriptScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20071102162910.350">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java') # Used to set comment delims.

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.hasClasses = False
    self.hasFunctions = True
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None # For now, ignore outer blocks.
    self.outerBlockDelim2 = None
    self.classTags = []
    self.functionTags = ['function']
    self.sigFailTokens = [';',] # ','=',] # Just like Java.
</t>
<t tx="ekr.20071102162910.351">def startsString(self,s,i):

    if g.match(s,i,'"') or g.match(s,i,"'"):
        # Count the number of preceding backslashes:
        n = 0 ; j = i-1
        while j &gt;= 0 and s[j] == '\\':
            n += 1
            j -= 1
        return (n % 2) == 0
    # elif g.match(s,i,'/'):
        # return i == 0 or s[i-1] != '/'
    else:
        return False
</t>
<t tx="ekr.20071102162910.352"># Not ready: '/' is also the division operator!


# def skipString (self,s,i):

    # # Returns len(s) on unterminated string.
    # if s[i] in ('"',"'"):
        # return g.skip_string(s,i,verbose=False)
    # else:
        # # Match a pattern.
        # delim = '/'
        # g.pdb()
        # assert(s[i] == delim)
        # i += 1
        # n = len(s)
        # while i &lt; n:
            # if s[i] == delim and s[i-1] != '\\':
                # return i + 1
            # else:
                # i += 1
        # return i</t>
<t tx="ekr.20071102162910.353"></t>
<t tx="ekr.20071102162910.354">def scanPascalText (self,s,parent,atAuto=False):

    scanner = self.pascalScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)</t>
<t tx="ekr.20071102162910.355">class pascalScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='pascal')

        # Set the parser delims.
        self.blockCommentDelim1 = '(*'
        self.blockCommentDelim2 = '*)'
        self.lineCommentDelim = '//'
        self.blockDelim1 = 'begin'
        self.blockDelim2 = 'end'
        self.classTags = []
        self.functionTags = ['function','procedure','constructor','destructor',]
</t>
<t tx="ekr.20071102162910.356"></t>
<t tx="ekr.20071102162910.357">def scanPHPText (self,s,parent,atAuto=False):

    scanner = self.phpScanner(importCommands=self,atAuto=atAuto)

    if scanner.isPurePHP(s):
        scanner.run(s,parent)
    else:
        fileName = scanner.fileName
        if not atAuto:
            g.es_print('%s seems to be mixed HTML and PHP.' % fileName)
        scanner.createHeadline(
            parent,body=s,headline=fileName)
</t>
<t tx="ekr.20071102162910.358">class phpScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20071102162910.359">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
</t>
<t tx="ekr.20071102162910.360">def isPurePHP (self,s):

    '''Return True if the file begins with &lt;?php or ends with ?&gt;'''

    s = s.strip()

    return (
        s.startswith('&lt;?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?&gt;'))

</t>
<t tx="ekr.20071102162910.361"># Does not create @first/@last nodes
</t>
<t tx="ekr.20071102162910.362">def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'&lt;&lt;&lt;')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return self.skipString()
    else:
        return g.skip_heredoc_string(s,i)
</t>
<t tx="ekr.20071102162910.363"></t>
<t tx="ekr.20071102162910.364">def scanPythonText (self,s,parent,atAuto=False):

    scanner = self.pythonScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071102162910.365">class pythonScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20071102162910.366">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='python')

    # Set the parser delims.
    self.lineCommentDelim = '#'
    self.classTags = ['class',]
    self.functionTags = ['def',]
    self.blockDelim1 = self.blockDelim2 = None
        # Suppress the check for the block delim.
        # The check is done in skipSigTail.
    self.strict = True

</t>
<t tx="ekr.20071102162910.367">def extendSignature(self,s,i):

    '''Extend the text to be added to the class node following the signature.

    The text *must* end with a newline.'''

    # Add a docstring to the class node,
    # And everything on the line following it
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j &lt; len(s): # No scanning error.
            # Return the docstring only if nothing but whitespace follows.
            j = g.skip_ws(s,j)
            if g.is_nl(s,j):
                return j + 1

    return i
</t>
<t tx="ekr.20071102162910.368">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_python_string(s,i,verbose=False)
</t>
<t tx="ekr.20071102162910.369"># This must be overridden in order to handle newlines properly.

def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    while i &lt; len(s):
        ch = s[i]
        if ch == '\n':
            break
        elif ch in (' ','\t',):
            i += 1
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        else:
            break

    return i,g.match(s,i,':')
</t>
<t tx="ekr.20071102162910.370">def scanUnknownFileType (self,s,p,ext,atAuto=False):

    c = self.c
    changed = c.isChanged()
    body = g.choose(atAuto,'','@ignore\n')
    if ext in ('.html','.htm'): body += '@language html\n'
    if ext in ('.txt','.text'): body += '@nocolor\n'
    c.setBodyString(p,body + self.rootLine + s)
    if atAuto:
        for p in p.self_and_subtree_iter():
            p.clearDirty()
        if not changed:
            c.setChanged(False)

    g.app.unitTestDict = {'result':True}
</t>
<t tx="ekr.20071102162910.371">@nocolor
https://sourceforge.net/forum/message.php?msg_id=4579298
By: vransmayr

However, with the plain text file w/o any suffix, a problem still exists:
when I modify it and save the outline it is not written back to the original file.

The fix was to make anything more than 10 characters 'significant', and write a
message when the @auto node contains insignificant text.

@color</t>
<t tx="ekr.20071102162910.372"></t>
<t tx="ekr.20071102162910.373">@language csharp

csharpfriends.com c# community

// CLASS1.CS -- Syntax-at-a-Glance for the C# programming language.
// A quick code reference for programmers who work in many languages.
// Executable code, minimal comments document the essence of the language.
// Copyright (C) 2001 StructureByDesign.  All Rights Reserved.

using System;
using System.Collections;
using System.IO;

namespace StructureByDesign.Syntax
{
/********************************************************************/
public class Class1: Object
{
    public static int Main(string[] args)       // Entry point.
    {
        System.Console.WriteLine("Hello");
        Class2 aclass2 = new Class2();
        aclass2.run();
        return 0;
    }
}

/********************************************************************/
interface Interface1
{
    void run();
}

/********************************************************************/
class Class2: Class1, Interface1
{
    public const int CONSTANT = 1;          // Access not restricted, implicitly static.
    private int m_intPrivateField;          // Access limited to containing type.
    //////////////////////////////////////////////////////////////
    public Class2() : base()                // Constructor.
    {
        initialize();
    }
    //////////////////////////////////////////////////////////////
    protected void initialize()             // Object initialization.
    {                                       // Access limited to containing class or types derived.
        Number = 1;
    }
    //////////////////////////////////////////////////////////////
    protected int Number                    // Language property feature.
    {
        get
        {
            return m_intPrivateField;
        }
        set
        {
            m_intPrivateField = value;      // Implicit parameter.
        }
    }
    //////////////////////////////////////////////////////////////
    public void run()
    {
        anonymousCode();
        arrays();
        collections();
        comparison();
        control();
        filesStreamsAndExceptions();
        numbersAndMath();
        primitivesAndConstants();
        runtimeTyping();
        strings();
    }
    //////////////////////////////////////////////////////////////
    void anonymousCode()
    {
        Delegate adelegate = new Delegate(Run);
        adelegate();
    }
    delegate void Delegate();
    void Run()
    {
        Console.WriteLine("Run");
    }
    //////////////////////////////////////////////////////////////
    void arrays()
    {
        int[] arrayOfInts = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        arrayOfInts[0] = 9;
        assert(arrayOfInts[0] == arrayOfInts[9]);

        String[] arrayOfStrings = new String[10];
        assert(arrayOfStrings[0] == null);
        assert(arrayOfStrings.Length == 10);

        arrayOfStrings = new String[] { "one", "two" };

        byte[,] arrayOfBytes = { {0,0,0},
                                 {0,1,2},
                                 {0,2,4}};
        assert(arrayOfBytes[2,2] == 4);
    }
    //////////////////////////////////////////////////////////////
    void collections()
    {
        IList ailist = new ArrayList();
        ailist.Add("zero"); ailist.Add("one"); ailist.Add("three");
        ailist[2] = "two";
        assert(ailist[2].Equals("two"));
        ailist.Remove("two");
        ((ArrayList)ailist).Sort();
        for(IEnumerator aie = ((ArrayList)ailist).GetEnumerator(); aie.MoveNext(); )
            ;
        foreach(String astring in ailist)
            ;

        IDictionary aidictionary = new Hashtable();
        aidictionary.Add("key", "value");
        assert(aidictionary["key"].Equals("value"));

        // Set not available.
    }
    //////////////////////////////////////////////////////////////
    void comparison()
    {
        int aint1 = 1;
        int aint2 = 2;
        int aint = 1;
        String astring1 = "one";
        String astring2 = "two";
        String astring = astring1;

        assert(aint == aint1);
        assert(aint1 != aint2);
        assert(astring == astring1);
        assert(astring1 == String.Copy("one"));         // For strings == is overloaded to compare values.
        assert(!astring1.Equals(astring2));
        assert(astring1.Equals(String.Copy("one")));

        astring = null;
        if (astring != null &amp;&amp; astring.Length &gt; 0)      // Conditional evaluation.
            assert(false);

        if (aint2 &lt; 0 || 1 &lt; aint2)
            assert(true);
    }
    //////////////////////////////////////////////////////////////
    void control()
    {
        if (true)
            assert(true);
        else
            assert(false);
        /////
        switch ('b') {
            case 'a':
                assert(false);
                break;
            case 'b':
                assert(true);
                break;
            default:
                assert(false);
                break;
        }
        /////
        for (int ai1 = 0; ai1 &lt; 10; ai1++)
            assert(true);
        /////
        int ai = 0;
        while (ai &lt; 10) {
            assert(true);
            ai++;
        }
        /////
        do
            ai--;
        while (ai &gt; 0);
        /////
        for (int x = 0; x &lt; 10; x++)        // Labeled break/continue not available.
            for (int y = 0; y &lt; 10; y++)
                if (x == 9)
                    break;
                else
                    continue;
    }
    //////////////////////////////////////////////////////////////
    void filesStreamsAndExceptions()
    {
        FileInfo afileinfo = new FileInfo("list.txt");
        try {
            StreamWriter asw = new StreamWriter("list.txt");
            asw.WriteLine("line");
            asw.WriteLine("line");
            asw.Close();

            assert(afileinfo.Exists);

            StreamReader asr = new StreamReader("list.txt");
            String astringLine;
            while ((astringLine = asr.ReadLine()) != null)
                assert(astringLine.Equals("line"));
            asr.Close();
        } catch (IOException aexception) {
            System.Console.WriteLine(aexception.Message);
            throw new NotSupportedException();
        }
        finally {
            afileinfo.Delete();
        }
    }
    //////////////////////////////////////////////////////////////
    void numbersAndMath()
    {
        assert(Int32.Parse("123") == 123);
        assert(123.ToString().Equals("123"));

        assert(Math.PI.ToString("n3").Equals("3.142"));

        assert(Int32.MaxValue &lt; Int64.MaxValue);

        assert(Math.Abs(Math.Sin(0) - 0) &lt;= Double.Epsilon);
        assert(Math.Abs(Math.Cos(0) - 1) &lt;= Double.Epsilon);
        assert(Math.Abs(Math.Tan(0) - 0) &lt;= Double.Epsilon);

        assert(Math.Abs(Math.Sqrt(4) - 2) &lt;= Double.Epsilon);
        assert(Math.Abs(Math.Pow(3,3) - 27) &lt;= Double.Epsilon);

        assert(Math.Max(0,1) == 1);
        assert(Math.Min(0,1) == 0);

        assert(Math.Abs(Math.Ceiling(9.87) - 10.0) &lt;= Double.Epsilon);
        assert(Math.Abs(Math.Floor(9.87) - 9.0) &lt;= Double.Epsilon);
        assert(Math.Round(9.87) == 10);

        Random arandom = new Random();
        double adouble = arandom.NextDouble();
        assert(0.0 &lt;= adouble &amp;&amp; adouble &lt; 1.0);
        int aint = arandom.Next(10);
        assert(0 &lt;= aint &amp;&amp; aint &lt; 10);
    }
    //////////////////////////////////////////////////////////////
    enum Season: byte { Spring=0, Summer, Fall, Winter };

    void primitivesAndConstants()
    {
        bool abool = false;
        char achar = 'A';           // 16 bits, Unicode

        byte abyte = 0x0;           // 8 bits, unsigned, hex constant
        sbyte asbyte = 0;           // 8 bits, signed

        short ashort = 0;           // 16 bits, signed
        ushort aushort = 0;         // 16 bits, unsigned

        int aint = 0;               // 32 bits, signed
        uint aunit = 0;             // 32 bits, unsigned

        long along = 0L;            // 64 bits, signed
        ulong aulong = 0;           // 64 bits, unsigned

        float afloat = 0.0F;        // 32 bits
        double adouble = 0.0;       // 64 bits

        decimal adecimal = 0;       // 128 bits, financial calculations

        Season aseason = Season.Fall;
        assert((byte)aseason == 2);
    }
    //////////////////////////////////////////////////////////////
    void runtimeTyping()
    {
        assert(new int[] { 1 } is int[]);
        assert(new ArrayList() is ArrayList);

        assert((new ArrayList()).GetType() == typeof(ArrayList));
        assert(typeof(Int32) is Type);      // Type of primitive type.

        assert(Type.GetType("System.Collections.ArrayList") == typeof(ArrayList));
    }
    //////////////////////////////////////////////////////////////
    void strings()
    {
        String astring1 = "one";
        String astring2 = "TWO";

        assert((astring1 + "/" + astring2).Equals("one/TWO"));
        assert(astring2.ToLower().Equals("two"));   // Equals ignoring case not available.
        assert(astring1.Length == 3);
        assert(astring1.Substring(0,2).Equals("on"));
        assert(astring1[2] == 'e');
        assert(astring1.ToUpper().Equals("ONE"));
        assert(astring2.ToLower().Equals("two"));
        assert(astring1.CompareTo("p") &lt; 0);
        assert(astring1.IndexOf('e') == 2);
        assert(astring1.IndexOf("ne") == 1);
        assert(astring1.Trim().Length == astring1.Length);

        assert(Char.IsDigit('1'));
        assert(Char.IsLetter('a'));
        assert(Char.IsWhiteSpace('\t'));
        assert(Char.ToLower('A') == 'a');
        assert(Char.ToUpper('a') == 'A');
    }
    //////////////////////////////////////////////////////////////
    private void assert(bool abool)
    {
        if (!abool)
            throw new Exception("assert failed");
    }
}
}

</t>
<t tx="ekr.20071102162910.374"></t>
<t tx="ekr.20071102162910.375"></t>
<t tx="ekr.20071102162910.376">@nocolor

https://sourceforge.net/forum/message.php?msg_id=4576436
By: thyrsus

I found that the effect on the current CVS of Mr. Ignatov's Fedora 7 crash fix
was that if you moved from a node that had text to a node that didn't have text,
the text window would not be blanked.  I instead use this workaround in Code--&gt;Gui
Tkinter classes--&gt;@thin leoTkinterFrame.py--&gt;class leoTkTextWidget
(Tk.Text)--&gt;Wrapper methods (leoTextWidget)--&gt;setAllText (diff taken on
leoTkinterFrame.py).

In case anyone has forgotten: this change is a workaround to a python bug that
so far has only been distributed with Fedora Core 7.  I have reported the bug
to the Fedora Core 7 folks, but they're presumably busy with other things.
It's possible the problem is actually the responsibility of the python maintainers,
in which case they'll either fix it or it will start showing up in other Linux
distributions :-/

***************
*** 3380,3386 ****
          Tk.Text.configure(w,state="normal")

          Tk.Text.delete(w,'1.0','end')
!        Tk.Text.insert(w,'1.0',s)

          Tk.Text.configure(w,state=state)
      #@-node:ekr.20061113151148.20:setAllText
--- 3376,3382 ----
          Tk.Text.configure(w,state="normal")

          Tk.Text.delete(w,'1.0','end')
!        if s: Tk.Text.insert(w,'1.0',s)

          Tk.Text.configure(w,state=state)
      #@-node:ekr.20061113151148.20:setAllText

@color
</t>
<t tx="ekr.20071102162910.377">def setAllText (self,s): # tkTextWidget

    w = self

    state = Tk.Text.cget(w,"state")
    Tk.Text.configure(w,state="normal")

    Tk.Text.delete(w,'1.0','end')
    if s: Tk.Text.insert(w,'1.0',s) # The 'if s:' is a workaround for a fedora bug.

    Tk.Text.configure(w,state=state)
</t>
<t tx="ekr.20071102162910.378">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4565216
By: hemanthps

I forgot to mention. I use the following options in my top @rst node.
@ @rst-options
code_mode=True
doc_only_mode=False
default_path =
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=False
stylesheet_path=./
write_intermediate_file = True
verbose=True
show_doc_parts_as_paragraphs=True
show_markup_doc_parts=True
underline_characters = #=+*^~"'`-:&gt;&lt;_
@c

Remaining nit:
Even though I specify @language c in my @nosent myfile.c node, the generated
rst from this plugin has
.. code-block:: Python

In Plugins--&gt;Text formatting--&gt;rst3--&gt;@thin rst3.py--&gt;class rstClass--&gt;write
methods--&gt; Top-level write code--&gt;initWrite of leoPlugins.leo, there is a line,
language = d.get('language','').lower()
in function initWrite(). But I could not yet figure out how to fill the value
'c' in that dictionary instead of the default "Python".</t>
<t tx="ekr.20071102162910.379">@nocolor
@
The run-unit-tests command runs tests using the bridge, which uses a nullGui and a stringTextWidget.

Apparently, this causes problem for unit tests:

1. Added a hack to g.getScript so it always gets the script from p.bodyString
   when g.app.gui.inBridge is True. 

2. Several unit tests fail when run from the bridge.

Both of these problems are symptoms of bugs either in c.frame.body.bodyCtrl (a
stringTextWidget) or in the code (especially c.frame.tree.select) that inits the
text widget.

@color</t>
<t tx="ekr.20071102162910.380">def run(fileName=None,pymacs=None,jyLeo=False,*args,**keywords):

    """Initialize and run Leo"""

    __pychecker__ = '--no-argsused' # keywords not used.

    if not jyLeo and not isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    adjustSysPath(g)
    if pymacs:
        script = windowFlag = False
    else:
        script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.batchMode = script is not None
    g.app.silentMode = '-silent' in sys.argv or '--silent' in sys.argv
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif jyLeo:
        import leoSwingGui
        g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
</t>
<t tx="ekr.20071102162910.381">if jyLeo:

    print '*** starting jyLeo',sys.platform # will be something like java1.6.0_02

    ### This is a hack.
    ### The jyleo script in test.leo sets the cwd to g.app.loadDir
    ### Eventually, we will have to compute the equivalent here.

    path = os.path.join(os.getcwd()) ### ,'..','src')
    if path not in sys.path:
        print 'appending %s to sys.path' % path
        sys.path.append(path)
    if 0:
        print 'sys.path...'
        for s in sys.path: print s

# Import leoGlobals, but do NOT set g.
import leoGlobals
import leoApp

# Create the app.
leoGlobals.app = leoApp.LeoApp()

# **now** we can set g.
g = leoGlobals
assert(g.app)

if jyLeo:
    startJyleo(g)
</t>
<t tx="ekr.20071102162910.382">import leoNodes
import leoConfig

# try:
    # import leoNodes
# except ImportError:
    # print "Error importing leoNodes.py"
    # import traceback ; traceback.print_exc()

# try:
    # import leoConfig
# except ImportError:
    # print "Error importing leoConfig.py"
    # import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20071102162910.383">def getBatchScript ():

    import leoGlobals as g
    windowFlag = False

    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()

    # Bug fix 4/27/07: Don't put a return in a finally clause.
    return script, windowFlag
</t>
<t tx="ekr.20071102162910.384">def doTests(c,all,verbosity=1):

    p = c.currentPosition() ; p1 = p.copy()
    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()
        if all: theIter = c.all_positions_iter()
        else:   theIter = p.self_and_subtree_iter()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
        for p in theIter:
            if isTestNode(p): # @test
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
            elif isSuiteNode(p): # @suite
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)
        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
    finally:
        c.setChanged(changed) # Restore changed state.
        c.selectPosition(p1)
        g.unitTesting = g.app.unitTesting = False
</t>
<t tx="ekr.20071102162910.385">class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
</t>
<t tx="ekr.20071102162910.386">def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
</t>
<t tx="ekr.20071102162910.387">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
</t>
<t tx="ekr.20071102162910.388">def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
</t>
<t tx="ekr.20071102162910.389">def tearDown (self):

    pass

    # To do: restore the outline.
</t>
<t tx="ekr.20071102162910.390">def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p}
    else:
        d = {}

    # Execute the script. Let unit test handle any errors!

    if 0: # debug
        import pdb
        pdb.run(script+'\n',d)
    else:
        exec script + '\n' in d
</t>
<t tx="ekr.20071102162910.391">def shortDescription (self):

    return self.p.headString() + '\n'
</t>
<t tx="ekr.20071102162910.392">@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        print "no script in %s" % h
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print "%s script did not set g.app.scriptDict" % h
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None
</t>
<t tx="ekr.20071102162910.393">def makeTestCase (c,p):

    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None
</t>
<t tx="ekr.20071102162910.394"></t>
<t tx="ekr.20071102162910.395"></t>
<t tx="ekr.20071102162910.396">def add(self,*args,**keys):

    """Add a button containing text or a picture to the icon bar.

    Pictures take precedence over text"""

    c = self.c ; f = self.iconFrame
    text = keys.get('text')
    imagefile = keys.get('imagefile')
    image = keys.get('image')
    command = keys.get('command')
    bg = keys.get('bg')

    if not imagefile and not image and not text: return

    # First define n.
    try:
        g.app.iconWidgetCount += 1
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 1

    if not command:
        def command():
            print "command for widget %s" % (n)

    if imagefile or image:
        &lt;&lt; create a picture &gt;&gt;
    elif text:
        b = Tk.Button(f,text=text,relief="groove",bd=2,command=command)
        if not self.font:
            self.font = c.config.getFontFromParams(
                "button_text_font_family", "button_text_font_size",
                "button_text_font_slant",  "button_text_font_weight",)
        b.configure(font=self.font)
        # elif sys.platform.startswith('win'):
            # width = max(6,len(text))
            # b.configure(width=width,font=('verdana',7,'bold'))
        if bg: b.configure(bg=bg)
        b.pack(side="left", fill="none")
        return b

    return None
</t>
<t tx="ekr.20071102162910.397">try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)

        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []

        refs.append((imagefile,image),)

    if not bg:
        bg = f.cget("bg")

    b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b

except:
    g.es_exception()
    return None
</t>
<t tx="ekr.20071102162910.398">@nocolor

http://sourceforge.net/forum/forum.php?thread_id=1800071&amp;forum_id=10226

Resolving conflictgs in .leo files is completely different from resolving
conflicts in derived files.

Let us use the term **conflict file** to denote a derived file that contains cvs
conflict markers (&gt;&gt;&gt;&gt;). Cvs conflict markers can corrupt sentinels by
duplicating or deleting sentinels, so Leo should not try to read or import files
containing conflicts.

@color</t>
<t tx="ekr.20071102162910.399">def defineFileMenuReadWriteMenuTable (self):

    self.fileMenuReadWriteMenuTable = [
        '*&amp;check-derived-file',
        '*check-leo-file',
        '-',
        '*&amp;read-outline-only',
        '*write-&amp;outline-only',
        '-',
        '*read-&amp;file-into-node',
        '*writ&amp;e-file-from-node',
        '-',
        ('Read @&amp;auto Nodes','read-at-auto-nodes'),
        ('Write @a&amp;uto Nodes','write-at-auto-nodes'),
        ('Write D&amp;irty @a&amp;uto Nodes','write-dirty-at-auto-nodes'),
        '-',
        ('Read @file &amp;Nodes','read-at-file-nodes'),
        ('Write &amp;Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &amp;Missing @file Nodes','write-missing-at-file-nodes'),
        ('&amp;Write @file Nodes','write-at-file-nodes'),
    ]

    # a,cd,e,f,i,l,m,n,o,r,u,w</t>
<t tx="ekr.20071102162910.400">@nocolor

Conflicts involving derived files.

The **read-file-into-node** reads an entire into a single node.

The **write-file-from-node** command writes a file from a single node.

@color</t>
<t tx="ekr.20071102162910.401">def readFileIntoNode (self,event=None):

    '''Read a file into a single node.'''

    c = self ; undoType = 'Read File Into Node'
    filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Read File Into Node",filetypes=filetypes,defaultextension=None)

    if fileName:    
        try:
            theFile = open(fileName,'r')
            s = theFile.read()
            s = '@nocolor\n' + s
            c.beginUpdate()
            try:
                w = c.frame.body.bodyCtrl
                p = c.insertHeadline(op_name=undoType)
                p.setHeadString('@read-file-into-node ' + fileName)
                p.v.setTnodeText(s)
                w.setAllText(s)
            finally:
                c.endUpdate()
        except:
            g.es("can not open:" + fileName)
</t>
<t tx="ekr.20071102162910.402">def writeFileFromNode (self,event=None):

    # If node starts with @read-file-into-node, use the full path name in the headline.
    # Otherwise, prompt for a file name.

    c = self ; p = c.currentPosition()
    h = p.headString().rstrip()
    s = p.bodyString()
    tag = '@read-file-into-node'

    if h.startswith(tag):
        fileName = h[len(tag):].strip()
    else:
        fileName = None

    if not fileName:
        filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
        fileName = g.app.gui.runSaveFileDialog(
            initialfile=None,
            title='Write File From Node',
            filetypes=filetypes,
            defaultextension=None)
    if fileName:
        try:
            theFile = open(fileName,'w')
        except IOError:
            theFile = None
        if theFile:
            if s.startswith('@nocolor\n'):
                s = s[len('@nocolor\n'):]
            theFile.write(s)
            theFile.flush()
            g.es_print('wrote: %s' % (fileName),color='blue')
            theFile.close()
        else:
            g.es('can not write %s' % (fileName),color='red')</t>
<t tx="ekr.20071102162910.403">These commands will do a trial read of the file.</t>
<t tx="ekr.20071102162910.404">def checkDerivedFile (self, event=None):  # based on atFile.read

    at = self ; c = at.c ; p = c.currentPosition() ; s = p.bodyString()

    # Create a dummy vnode as the root.
    fileName='check-derived-file'
    root_t = leoNodes.tnode()
    root_v = leoNodes.vnode(root_t)
    root = leoNodes.position(root_v)
    theFile = g.fileLikeObject(fromString=s)
    thinFile = at.scanHeaderForThin (theFile,fileName)
    # g.trace('thinFile',thinFile)
    at.initReadIvars(root,fileName,thinFile=thinFile)
    if at.errors: return
    at.openFileForReading(fileName,fromString=s)
    if not at.inputFile: return
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    if at.errors == 0:
        g.es_print('check-derived-file passed',color='blue')
</t>
<t tx="ekr.20071102162910.405">def checkLeoFile (self,event=None):

    fc = self ; c = fc.c ; p = c.currentPosition()

    # Put the body (minus the @nocolor) into the file buffer.
    s = p.bodyString() ; tag = '@nocolor\n'
    if s.startswith(tag): s = s[len(tag):]
    self.fileBuffer = s ; self.fileIndex = 0

    # Do a trial read.
    self.checking = True
    self.initReadIvars()
    c.loading = True # disable c.changed
    try:
        try:
            self.getAllLeoElements(fileName='check-leo-file',silent=False)
            g.es_print('check-leo-file passed',color='blue')
        except BadLeoFile, message:
            # g.es_exception()
            g.es_print('check-leo-file failed: %s' % str(message),color='red')
    finally:
        self.checking = False
        c.loading = False # reenable c.changed
</t>
<t tx="ekr.20071102162910.406">@nocolor

Conflicts involving .leo files.

In general, cvs conflict markers will make it impossible to read .leo files
without 'heroic' measures. Instead of using conflict inforamtion in the .leo.txt
file, Leo will simply compare the *unadulterated* .leo files.

It is easy to compare .leo files. Indeed, gnx's uniquely identify individual
nodes, so a simple pass over both files suffices to show which nodes appear in
both files, and which nodes appear in only one file. If we consider one file to
be the 'original' .leo file, and the other file to be the 'modified' .leo file,
we can then immediately see which nodes have been inserted (appear only in the
modified file), deleted (appear only in the original file) or changed (appear in
both files but with different headline or body text).

To resolve conflicts in .leo files, the user will do the following:

1. Open one of the unadulterated .leo files: this is the 'original' file.

2. Invoke the **compare-leo-files** command.  This will prompt for the 'modified' file.

This command will create a **comparison tree*, similar to the tree created by
the clone-find-all commands. This tree will have clones for all inserted,
deleted and changed nodes. The user modifies original outline as needed, then
saves the outline as usual. The comparison tree can then be deleted and the
original file saved.

@color</t>
<t tx="ekr.20071102162910.407">def compareLeoFiles (self,event):

    c = c1 = self.c ; w = c.frame.body.bodyCtrl

    # Prompt for the file to be compared with the present outline.
    filetypes = [("Leo files", "*.leo"),("All files", "*"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Compare .leo Files",filetypes=filetypes,defaultextension='.leo')
    if not fileName: return

    # Read the file into the hidden commander.
    c2 = self.createHiddenCommander(fileName)
    if not c2: return

    # Compute the inserted, deleted and changed dicts.
    d1 = self.createFileDict(c1)
    d2 = self.createFileDict(c2)  
    inserted, deleted, changed = self.computeChangeDicts(d1,d2)
    self.dumpCompareNodes(fileName,c1.mFileName,inserted,deleted,changed)

    # Create clones of all inserted, deleted and changed dicts.
    self.createAllCompareClones(inserted,deleted,changed)
    c2.frame.destroySelf()
    g.app.gui.set_focus(c,w)


</t>
<t tx="ekr.20071102162910.408">def computeChangeDicts (self,d1,d2):

    '''Compute inserted, deleted, changed dictionaries.'''

    inserted = {}
    for key in d2.keys():
        if not d1.get(key):
            inserted[key] = d2.get(key)

    deleted = {}
    for key in d1.keys():
        if not d2.get(key):
            deleted[key] = d1.get(key)

    changed = {}
    for key in d1.keys():
        if d2.get(key):
            p1 = d1.get(key)
            p2 = d2.get(key)
            if p1.headString() != p2.headString() or p1.bodyString() != p2.bodyString():
                changed[key] = p1

    return inserted, deleted, changed
</t>
<t tx="ekr.20071102162910.409">def createAllCompareClones(self,inserted,deleted,changed):

    c = self.c # Always use the visible commander
    c.beginUpdate()
    try:
        # Create parent node at the start of the outline.
        u = c.undoer ; undoType = 'Compare .leo Files'
        u.beforeChangeGroup(c.currentPosition(),undoType)
        undoData = u.beforeInsertNode(c.currentPosition())
        parent = c.currentPosition().insertAfter()
        c.setHeadString(parent,undoType)
        u.afterInsertNode(parent,undoType,undoData,dirtyVnodeList=[])
        for d,kind in (
            (deleted,'deleted'),(inserted,'inserted'),(changed,'changed')
        ):
            self.createCompareClones(d,kind,parent)
        c.selectPosition(parent)
        u.afterChangeGroup(parent,undoType,reportFlag=True) 
    finally:
        c.endUpdate(False)
    c.redraw_now()</t>
<t tx="ekr.20071102162910.410">def createCompareClones (self,d,kind,parent):

    c = self.c # Always use the visible commander.

    if d.keys():
        parent = parent.insertAsLastChild()
        c.setHeadString(parent,kind)

        for key in d.keys():
            p = d.get(key)
            clone = p.clone()
            clone.moveToLastChildOf(parent)
</t>
<t tx="ekr.20071102162910.411">def createHiddenCommander(self,fileName):

    # Read the file into a hidden commander (Similar to g.openWithFileName).
    import leoGui
    import leoFrame
    import leoCommands

    nullGui = leoGui.nullGui('nullGui')
    frame = leoFrame.nullFrame('nullFrame',nullGui,useNullUndoer=True)
    c2 = leoCommands.Commands(frame,fileName)
    theFile,c2.isZipped = g.openLeoOrZipFile(fileName)
    if theFile:
        c2.fileCommands.open(theFile,fileName,readAtFileNodesFlag=True,silent=True)
        return c2
    else:
        return None</t>
<t tx="ekr.20071102162910.412">def createFileDict (self,c):

    '''Create a dictionary of all relevant positions in commander c.'''

    d = {}
    for p in c.allNodes_iter():
        try:
            # fileIndices for pre-4.x versions of .leo files have a different format.
            i,j,k = p.v.t.fileIndex
            d[str(i),str(j),str(k)] = p.copy()
        except Exception:
            pass
    return d
</t>
<t tx="ekr.20071102162910.413">def dumpCompareNodes (self,fileName1,fileName2,inserted,deleted,changed):

    for d,kind in (
        (inserted,'inserted (only in %s)' % (fileName1)),
        (deleted, 'deleted  (only in %s)' % (fileName2)),
        (changed, 'changed'),
    ):
        print ; print kind
        for key in d.keys():
            p = d.get(key)
            print '%-32s %s' % (key,g.toEncodedString(p.headString(),'ascii'))
</t>
<t tx="ekr.20071102162910.414"></t>
<t tx="ekr.20071102162910.415">def __init__ (self,c):

    self.c = c

    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultMenuFontSize = g.app.config.defaultMenuFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize

    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)

    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
</t>
<t tx="ekr.20071102162910.416">def initIvar(self,key):

    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
</t>
<t tx="ekr.20071102162910.417">def initEncoding (self,key):

    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    # New in 4.4b3: use the global setting as a last resort.
    if encoding:
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)
    else:
        encoding = getattr(g.app.config,encodingName)
        # g.trace('g.app.config',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
</t>
<t tx="ekr.20071102162910.418">def visitNode (self,p):

    """Init any settings found in node p."""

    # g.trace(p.headString())

    munge = g.app.config.munge

    kind,name,val = self.parseHeadline(p.headString())
    kind = munge(kind)

    if kind is None: # Not an @x node. (New in Leo 4.4.4)
        pass
    if kind == "settings":
        pass
    elif kind in self.basic_types and val in (u'None',u'none','None','none','',None):
        # None is valid for all basic types.
        self.set(p,kind,name,None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        try:
            return f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind

    return None
</t>
<t tx="ekr.20071102162910.419">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize)

def getRecentFiles (self):
    return g.app.config.getRecentFiles()

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getAbbrevDict(self):         return g.app.config.getAbbrevDict(self.c)
def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getButtons   (self):         return g.app.config.buttonsList # unusual.
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getMenusList (self):         return g.app.config.menusList # unusual.
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getOpenWith  (self):         return g.app.config.getOpenWith (self.c)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting,):return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
</t>
<t tx="ekr.20071102162910.420">def doButtons (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    aList = [] ; c = self.c ; tag = '@button'
    for p in p.subtree_iter():
        h = p.headString()
        if g.match_word(h,0,tag):
            # We can not assume that p will be valid when it is used.
            script = g.getScript(c,p,useSelectedText=False,forcePythonSentinels=True,useSentinels=True)
            aList.append((p.headString(),script),)

    # g.trace(g.listToString([h for h,script in aList]))

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    g.app.config.buttonsList = aList
    g.app.config.buttonsFileName = c and c.shortFileName() or '&lt;no settings file&gt;'

</t>
<t tx="ekr.20071102162910.421">class parserBaseClass:

    """The base class for settings parsers."""

    &lt;&lt; parserBaseClass data &gt;&gt;

    @others
</t>
<t tx="ekr.20071102162910.422"># These are the canonicalized names.  Case is ignored, as are '_' and '-' characters.

basic_types = [
    # Headlines have the form @kind name = var
    'bool','color','directory','int','ints',
    'float','path','ratio','shortcut','string','strings']

control_types = [
    'abbrev','enabledplugins','font','if','ifgui','ifplatform','ignore','mode',
    'openwith','page','settings','shortcuts',
    'buttons','menus', # New in Leo 4.4.4.
    ]

# Keys are settings names, values are (type,value) tuples.
settingsDict = {}
</t>
<t tx="ekr.20071102162910.423">def __init__ (self,c):

    self.c = c
    self.recentFiles = [] # List of recent files.
    self.shortcutsDict = {}
        # Keys are cononicalized shortcut names, values are bunches.
    self.openWithList = []
        # A list of dicts containing 'name','shortcut','command' keys.

    # Keys are canonicalized names.
    self.dispatchDict = {
        'abbrev':       self.doAbbrev, # New in 4.4.1 b2.
        'bool':         self.doBool,
        'buttons':      self.doButtons, # New in 4.4.4
        'color':        self.doColor,
        'directory':    self.doDirectory,
        'enabledplugins': self.doEnabledPlugins,
        'font':         self.doFont,
        'if':           self.doIf,
        # 'ifgui':        self.doIfGui,  # Removed in 4.4 b3.
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'menus':        self.doMenus, # New in 4.4.4
        'mode':         self.doMode, # New in 4.4b1.
        'openwith':     self.doOpenWith, # New in 4.4.3 b1.
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        # 'shortcut':     self.doShortcut, # Removed in 4.4.1 b1.
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }
</t>
<t tx="ekr.20071102162910.424">def createModeCommand (self,name,modeDict):

    commandName = 'enter-' + name
    commandName = commandName.replace(' ','-')

    # g.trace(name,len(modeDict.keys()))

    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    # New in 4.4.1 b2: silently allow redefinitions of modes.
    d [commandName] = modeDict
</t>
<t tx="ekr.20071102162910.425">def error (self,s):

    print s

    # Does not work at present because we are using a null Gui.
    g.es(s,color="blue")
</t>
<t tx="ekr.20071102162910.426"></t>
<t tx="ekr.20071102162910.427">def doAbbrev (self,p,kind,name,val):

    d = {}
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseAbbrevLine(line)
            if name: d [val] = name

    self.set (p,'abbrev','abbrev',d)
</t>
<t tx="ekr.20071102162910.428">def doBool (self,p,kind,name,val):

    if val in ('True','true','1'):
        self.set(p,kind,name,True)
    elif val in ('False','false','0'):
        self.set(p,kind,name,False)
    else:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20071102162910.429">def doColor (self,p,kind,name,val):

    # At present no checking is done.
    val = val.lstrip('"').rstrip('"')
    val = val.lstrip("'").rstrip("'")

    self.set(p,kind,name,val)
</t>
<t tx="ekr.20071102162910.430">def doDirectory (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)

doPath = doDirectory
</t>
<t tx="ekr.20071102162910.431">def doEnabledPlugins (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c
    s = p.bodyString()

    # This setting is handled differently from all other settings,
    # because the last setting must be retrieved before any commander exists.

    # g.trace('len(s)',len(s))

    # Set the global config ivars.
    g.app.config.enabledPluginsString = s
    g.app.config.enabledPluginsFileName = c and c.shortFileName() or '&lt;no settings file&gt;'
</t>
<t tx="ekr.20071102162910.432">def doFloat (self,p,kind,name,val):

    try:
        val = float(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20071102162910.433">def doFont (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind not used.

    d = self.parseFont(p)

    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
</t>
<t tx="ekr.20071102162910.434">def doIf(self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # args not used.

    g.trace("'if' not supported yet")
    return None
</t>
<t tx="ekr.20071102162910.435">@ Alas, @if-gui can't be made to work. The problem is that plugins can set
g.app.gui, but plugins need settings so the leoSettings.leo files must be parsed
before g.app.gui.guiName() is known.
@c

if 0:

    def doIfGui (self,p,kind,name,val):

        __pychecker__ = '--no-argsused' # args not used.

        # g.trace(repr(name))

        if not g.app.gui or not g.app.gui.guiName():
            s = '@if-gui has no effect: g.app.gui not defined yet'
            g.es_print(s,color='blue')
            return "skip"
        elif g.app.gui.guiName().lower() == name.lower():
            return None
        else:
            return "skip"
</t>
<t tx="ekr.20071102162910.436">def doIfPlatform (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # args not used.

    # g.trace(sys.platform,repr(name))

    if sys.platform.lower() == name.lower():
        return None
    else:
        return "skip"
</t>
<t tx="ekr.20071102162910.437">def doIgnore(self,p,kind,name,val):

    return "skip"
</t>
<t tx="ekr.20071102162910.438">def doInt (self,p,kind,name,val):

    try:
        val = int(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20071102162910.439">def doInts (self,p,kind,name,val):

    '''We expect either:
    @ints [val1,val2,...]aName=val
    @ints aName[val1,val2,...]=val'''

    name = name.strip() # The name indicates the valid values.
    i = name.find('[')
    j = name.find(']')

    # g.trace(kind,name,val)

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        name = name[:i]+name[j+1:].strip()
        # g.trace(name,items)
        try:
            items = [int(item.strip()) for item in items]
        except ValueError:
            items = []
            self.valueError(p,'ints[]',name,val)
            return
        kind = "ints[%s]" % (','.join([str(item) for item in items]))
        try:
            val = int(val)
        except ValueError:
            self.valueError(p,'int',name,val)
            return
        if val not in items:
            self.error("%d is not in %s in %s" % (val,kind,name))
            return

        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
</t>
<t tx="ekr.20071102162910.440">def doMenus (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c ; aList = [] ; tag = '@menu'
    p = p.copy() ; after = p.nodeAfterTree()
    while p and p != after:
        h = p.headString()
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    # self.dumpMenuList(aList)
    # g.trace(g.listToString(aList))
    # g.es_print('creating menu from %s' % (c.shortFileName()),color='blue')
    g.app.config.menusList = aList
    g.app.config.menusFileName = c and c.shortFileName() or '&lt;no settings file&gt;'
</t>
<t tx="ekr.20071102162910.441">def doItems (self,p,aList):

    p = p.copy() ; after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        h = p.headString()
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()</t>
<t tx="ekr.20071102162910.442">def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            print
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)</t>
<t tx="ekr.20071102162910.443">def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''

    __pychecker__ = '--no-argsused' # val not used.

    c = self.c ; k = c.k

    # g.trace('%20s' % (name),c.fileName())
    &lt;&lt; Compute modeName &gt;&gt;

    # Create a local shortcutsDict.
    old_d = self.shortcutsDict
    d = self.shortcutsDict = {}

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if not name:
                # An entry command: put it in the special *entry-commands* key.
                aList = d.get('*entry-commands*',[])
                aList.append(bunch.entryCommandName)
                d ['*entry-commands*'] = aList
            elif bunch is not None:
                # A regular shortcut.
                bunch.val = k.strokeFromSetting(bunch.val)
                bunch.pane = modeName
                bunchList = d.get(name,[])
                # Important: use previous bindings if possible.
                key2,bunchList2 = c.config.getShortcut(name)
                bunchList3 = [b for b in bunchList2 if b.pane != modeName]
                if bunchList3:
                    # g.trace('inheriting',[b.val for b in bunchList3])
                    bunchList.extend(bunchList3)
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)

    # Restore the global shortcutsDict.
    self.shortcutsDict = old_d

    # Create the command, but not any bindings to it.
    self.createModeCommand(modeName,d)
</t>
<t tx="ekr.20071102162910.444">name = name.strip().lower()
j = name.find(' ')
if j &gt; -1: name = name[:j]
if name.endswith('mode'):
    name = name[:-4].strip()
if name.endswith('-'):
    name = name[:-1]
modeName = name + '-mode'
</t>
<t tx="ekr.20071102162910.445">def doOpenWith (self,p,kind,name,val):

    # g.trace('kind',kind,'name',name,'val',val,'c',self.c)

    d = self.parseOpenWith(p)
    d['name']=name
    d['shortcut']=val
    name = kind = 'openwithtable'
    self.openWithList.append(d)
    self.set(p,kind,name,self.openWithList)
</t>
<t tx="ekr.20071102162910.446">def doPage(self,p,kind,name,val):

    pass # Ignore @page this while parsing settings.
</t>
<t tx="ekr.20071102162910.447">def doRatio (self,p,kind,name,val):

    try:
        val = float(val)
        if 0.0 &lt;= val &lt;= 1.0:
            self.set(p,kind,name,val)
        else:
            self.valueError(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20071102162910.448">def doShortcuts(self,p,kind,name,val,s=None):

    __pychecker__ = '--no-argsused' # kind,val.

    # g.trace(self.c.fileName(),name)

    c = self.c ; d = self.shortcutsDict
    if s is None: s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if bunch is not None:
                # A regular shortcut.
                bunchList = d.get(name,[])
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)
</t>
<t tx="ekr.20071102162910.449">def doString (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)
</t>
<t tx="ekr.20071102162910.450">def doStrings (self,p,kind,name,val):

    '''We expect one of the following:
    @strings aName[val1,val2...]=val
    @strings [val1,val2,...]aName=val'''

    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        items = [item.strip() for item in items]
        name = name[:i]+name[j+1:].strip()
        kind = "strings[%s]" % (','.join(items))
        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
</t>
<t tx="ekr.20071102162910.451">def munge(self,s):

    return g.app.config.canonicalizeSettingName(s)
</t>
<t tx="ekr.20071102162910.452">def oops (self):
    print ("parserBaseClass oops:",
        g.callers(),
        "must be overridden in subclass")
</t>
<t tx="ekr.20071102162910.453"></t>
<t tx="ekr.20071102162910.454">def fontSettingNameToFontKind (self,name):

    s = name.strip()
    if s:
        for tag in ('_family','_size','_slant','_weight'):
            if s.endswith(tag):
                return tag[1:]

    return None
</t>
<t tx="ekr.20071102162910.455">def parseFont (self,p):

    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseFontLine(line,d)

    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)

    return d
</t>
<t tx="ekr.20071102162910.456">def parseFontLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if g.match(s,0,'#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
    else:
        # name is everything up to '='
        i = s.find('=')
        if i == -1:
            name = s ; val = None
        else:
            name = s[:i].strip()
            val = s[i+1:].strip()
            val = val.lstrip('"').rstrip('"')
            val = val.lstrip("'").rstrip("'")

        fontKind = self.fontSettingNameToFontKind(name)
        if fontKind:
            d[fontKind] = name,val # Used only by doFont.
</t>
<t tx="ekr.20071102162910.457">def parseHeadline (self,s):

    """Parse a headline of the form @kind:name=val
    Return (kind,name,val)."""

    kind = name = val = None

    if g.match(s,0,'@'):
        i = g.skip_id(s,1,chars='-')
        kind = s[1:i].strip()
        if kind:
            # name is everything up to '='
            j = s.find('=',i)
            if j == -1:
                name = s[i:].strip()
            else:
                name = s[i:j].strip()
                # val is everything after the '='
                val = s[j+1:].strip()

    # g.trace("%50s %10s %s" %(name,kind,val))
    return kind,name,val
</t>
<t tx="ekr.20071102162910.458">def parseOpenWith (self,p):

    d = {'command': None,}

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseOpenWithLine(line,d)

    return d
</t>
<t tx="ekr.20071102162910.459">def parseOpenWithLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if not g.match(s,0,'#'):
        d['command'] = s
</t>
<t tx="ekr.20071102162910.460">def parseShortcutLine (self,s):

    '''Parse a shortcut line.  Valid forms:

    --&gt; entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name -&gt; mode-name = binding
    command-name -&gt; same = binding
    '''

    name = val = nextMode = None ; nextMode = 'none'
    i = g.skip_ws(s,0)

    if g.match(s,i,'--&gt;'): # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s,i+3)
        i = g.skip_id(s,j,'-')
        entryCommandName = s[j:i]
        return None,g.Bunch(entryCommandName=entryCommandName)

    j = i
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'-&gt;'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]

    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]

    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i &gt; 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(nextMode=nextMode,pane=pane,val=val)
</t>
<t tx="ekr.20071102162910.461">def parseAbbrevLine (self,s):

    '''Parse an abbreviation line:
    command-name = abbreviation
    return (command-name,abbreviation)
    '''

    i = j = g.skip_ws(s,0)
    i = g.skip_id(s,i,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    i = g.skip_ws(s,i)
    if not g.match(s,i,'='): return None,None

    i = g.skip_ws(s,i+1)
    val = s[i:].strip()
    # Ignore comments after the shortcut.
    i = val.find('#')
    if i &gt; -1: val = val[:i].strip()

    if val: return name,val
    else:   return None,None
</t>
<t tx="ekr.20071102162910.462">def set (self,p,kind,name,val):

    """Init the setting for name to val."""

    __pychecker__ = '--no-argsused' # p used in subclasses, not here.

    c = self.c ; key = self.munge(name)
    # if kind and kind.startswith('setting'): g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d [key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')

</t>
<t tx="ekr.20071102162910.463">def setShortcut (self,name,bunch):

    c = self.c

    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&amp;','')
    self.set(c,rawKey,"shortcut",bunch)

    # g.trace(bunch.pane,rawKey,bunch.val)
</t>
<t tx="ekr.20071102162910.464">def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # g.trace(result,p.headString())
        if result == "skip":
            if 0:
                s = 'skipping settings in %s' % p.headString()
                g.es_print(s,color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
</t>
<t tx="ekr.20071102162910.465">def valueError (self,p,kind,name,val):

    """Give an error: val is not valid for kind."""

    __pychecker__ = '--no-argsused' # p not used, but needed.

    self.error("%s is not a valid %s for %s" % (val,kind,name))
</t>
<t tx="ekr.20071102162910.466">def visitNode (self,p):

    __pychecker__ = '--no-argsused' # p not used, but needed.

    self.oops()
</t>
<t tx="ekr.20071102162910.467"></t>
<t tx="ekr.20071102162910.468">def __init__ (self,frame):

    # g.trace('leoMenu',g.callers())

    self.c = c = frame.c
    self.frame = frame
    self.menus = {} # Menu dictionary.
    self.menuShortcuts = {}

    # To aid transition to emacs-style key handling.
    self.useCmdMenu = c.config.getBool('useCmdMenu')

    self.newBinding = True
        # True if using new binding scheme.
        # You can set this to False in an emergency to revert to the old way.

    if 0: # Must be done much later.
        self.defineMenuTables()
</t>
<t tx="ekr.20071102162910.469">def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    # g.trace('c',self.c)

    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        if sys.platform == 'darwin':
            &lt;&lt; clear accelerator if it is a plain key &gt;&gt;
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
</t>
<t tx="ekr.20071102162910.470">if type(data) in (type(''),type(u'')): # Bug fix: 10/10/07: Allow unicode labels.
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&amp;','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data</t>
<t tx="ekr.20071102162910.471"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
</t>
<t tx="ekr.20071102162910.472">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
</t>
<t tx="ekr.20071102162910.473">for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
</t>
<t tx="ekr.20071102162910.474">def defineMenuTables (self):

    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

</t>
<t tx="ekr.20071102162910.475">def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
</t>
<t tx="ekr.20071102162910.476">def defineEditMenuTopTable (self):

    self.editMenuTopTable = [
        # &amp;: u,r reserved for undo/redo: a,d,p,t,y.
        # &amp; (later): e,g,n,v.
        ("Can't Undo",'undo'),
        ("Can't Redo",'redo'), 
        '-',
        ('Cu&amp;t','cut-text'),
        ('Cop&amp;y','copy-text'),
        ('&amp;Paste','paste-text'),
        ('&amp;Delete','backward-delete-char'),
        ('Select &amp;All','select-all'),
        '-',
    ]
</t>
<t tx="ekr.20071102162910.477">def defineEditMenuEditBodyTable (self):

    self.editMenuEditBodyTable = [
        # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
        '*extract-&amp;section',
        '*extract-&amp;names',
        '*&amp;extract',
        '-',
        '*convert-all-b&amp;lanks',
        '*convert-all-t&amp;abs',
        '*convert-&amp;blanks',
        '*convert-&amp;tabs',
        '*insert-body-&amp;time',
        '*&amp;reformat-paragraph',
        '-',
        '*&amp;indent-region',
        '*&amp;unindent-region',
        '*&amp;match-brackets',
        '*add-comments',
        '*delete-comments',
    ]
</t>
<t tx="ekr.20071102162910.478">def defineEditMenuEditHeadlineTable (self):

    self.editMenuEditHeadlineTable = [
        '*edit-&amp;headline',
        '*&amp;end-edit-headline',
        '*&amp;abort-edit-headline',
        '*insert-headline-&amp;time',
        '*toggle-&amp;angle-brackets',
    ]
</t>
<t tx="ekr.20071102162910.479">def defineEditMenuFindMenuTable (self):

    self.editMenuFindMenuTable = [
        # &amp;: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,u,w,x
        '*&amp;open-find-tab',
        '*&amp;hide-find-tab',
        '*search-&amp;with-present-options',
        '-',
        '*find-&amp;next',
        '*find-&amp;prev',
        '*&amp;change',
        '*find-&amp;all',
        '*clone-fi&amp;nd-all',
        '*change-a&amp;ll',
        '-',
        '*&amp;find-character',
        '*find-character-extend-&amp;selection',
        '*&amp;backward-find-character',
        '*backward-find-character-&amp;extend-selection',
        '-',
        '*&amp;isearch-forward',
        '*isea&amp;rch-backward',
        '*isearch-forward-rege&amp;xp',
        '*isearch-backward-regex&amp;p',
        '-',
        '*&amp;query-replace',
        '*q&amp;uery-replace-regex',
    ]
</t>
<t tx="ekr.20071102162910.480">def defineEditMenuTop2Table (self):

    c = self.c

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")

    self.editMenuTop2Table = [
        '*&amp;goto-global-line',
        '*&amp;execute-script',
        (label,'toggle-invisibles'),
        ("Setti&amp;ngs",'open-leoSettings-leo'),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
</t>
<t tx="ekr.20071102162910.481">def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
</t>
<t tx="ekr.20071102162910.482">def defineFileMenuTopTable (self):

    self.fileMenuTopTable = [
        '*&amp;new',
        ('&amp;Open...','open-outline'),
    ]
</t>
<t tx="ekr.20071102162910.483">def defineFileMenuTop2Table (self):

    self.fileMenuTop2Table = [
        '-',
        ('&amp;Close','close-window'),
        ('&amp;Save','save-file'),
        ('Save &amp;As','save-file-as'),
        ('Save As &amp;Unzipped','save-file-as-unzipped'),
        ('Save As &amp;Zipped','save-file-as-zipped'),
        ('Save &amp;To','save-file-to'),
        ('Re&amp;vert To Saved','revert'),
    ]
</t>
<t tx="ekr.20071102162910.484">def defineFileMenuTangleMenuTable (self):

    self.fileMenuTangleMenuTable = [
        '*tangle-&amp;all',
        '*tangle-&amp;marked',
        '*&amp;tangle',
    ]
</t>
<t tx="ekr.20071102162910.485">def defineFileMenuUntangleMenuTable (self):

    self.fileMenuUntangleMenuTable = [
        '*untangle-&amp;all',
        '*untangle-&amp;marked',
        '*&amp;untangle',
    ]
</t>
<t tx="ekr.20071102162910.486">def defineFileMenuImportMenuTable (self):

    self.fileMenuImportMenuTable = [
        #&amp;: c,d,f,n,o,r,
        '*import-&amp;derived-file',
        ('Import To @&amp;file','import-at-file'),
        ('Import To @&amp;root','import-at-root'),
        '*import-&amp;cweb-files',
        '*import-&amp;noweb-files',
        '*import-flattened-&amp;outline',
    ]
</t>
<t tx="ekr.20071102162910.487">def defineFileMenuExportMenuTable (self):

    self.fileMenuExportMenuTable = [
        '*export-&amp;headlines',
        '*outline-to-&amp;cweb',
        '*outline-to-&amp;noweb',
        '*&amp;flatten-outline',
        '*&amp;remove-sentinels',
        '*&amp;weave',
    ]
</t>
<t tx="ekr.20071102162910.488">def defineFileMenuTop3MenuTable (self):

    self.fileMenuTop3MenuTable = [
        ('E&amp;xit','exit-leo'),
    ]
</t>
<t tx="ekr.20071102162910.489">def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
</t>
<t tx="ekr.20071102162910.490">def defineOutlineMenuTopMenuTable (self):

    self.outlineMenuTopMenuTable = [
        '*c&amp;ut-node',
        '*c&amp;opy-node',
        '*&amp;paste-node',
        ('Pas&amp;te Node As Clone','paste-retaining-clones'),
        '*&amp;delete-node',
        '-',
        '*&amp;insert-node',
        '*&amp;clone-node',
        '*sort-childre&amp;n',
        '*&amp;sort-siblings',
        '-',
        '*&amp;hoist',
        ('D&amp;e-Hoist','de-hoist'), # To preserve the '-' in De-Hoist.
        '-',
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
</t>
<t tx="ekr.20071102162910.491">def defineOutlineMenuCheckOutlineMenuTable (self):

    self.outlineMenuCheckOutlineMenuTable = [
        # &amp;: a,c,d,l,o
        '*check-&amp;outline',
        '*&amp;dump-outline',
        '-',
        '*compare-&amp;leo-files',
        '-',
        '*check-&amp;all-python-code',
        '*&amp;check-python-code',
    ]
</t>
<t tx="ekr.20071102162910.492">def defineOutlineMenuExpandContractMenuTable (self):

    self.outlineMenuExpandContractMenuTable = [
        '*&amp;contract-all',
        '*contract-&amp;node',
        '*contract-&amp;parent',
        '*contract-or-go-&amp;left',
        '-',
        '*expand-p&amp;rev-level',
        '*expand-n&amp;ext-level',
        '*expand-and-go-right',
        '*expand-or-go-right',
        '-',
        '*expand-to-level-&amp;1',
        '*expand-to-level-&amp;2',
        '*expand-to-level-&amp;3',
        '*expand-to-level-&amp;4',
        '*expand-to-level-&amp;5',
        '*expand-to-level-&amp;6',
        '*expand-to-level-&amp;7',
        '*expand-to-level-&amp;8',
        '-',
        '*expand-&amp;all',
        '*expand-n&amp;ode',
    ]
</t>
<t tx="ekr.20071102162910.493">def defineOutlineMenuMoveMenuTable (self):

    self.outlineMenuMoveMenuTable = [
        ('Move &amp;Down','move-outline-down'),
        ('Move &amp;Left','move-outline-left'),
        ('Move &amp;Right','move-outline-right'),
        ('Move &amp;Up','move-outline-up'),
        '-',
        '*&amp;promote',
        '*&amp;demote',
    ]
</t>
<t tx="ekr.20071102162910.494">def defineOutlineMenuMarkMenuTable (self):

    self.outlineMenuMarkMenuTable = [
        '*&amp;mark',
        '*mark-&amp;subheads',
        '*mark-changed-&amp;items',
        '*mark-changed-&amp;roots',
        '*mark-&amp;clones',
        '*&amp;unmark-all',
    ]
</t>
<t tx="ekr.20071102162910.495">def defineOutlineMenuGoToMenuTable (self):

    self.outlineMenuGoToMenuTable = [
        # &amp;: a,b,c,d,e,f,g,h,i,l,m,n,o,p,r,s,t,v,
        ('Go To &amp;First Node','goto-first-node'),
        ('Go To First V&amp;isible','goto-first-visible-node'),
        ('Go To First Si&amp;bling','goto-first-sibling'),
        '-',
        ('Go To Next C&amp;hanged','goto-next-changed'),
        ('Go To Next &amp;Clone','goto-next-clone'),
        ('Go To Next &amp;Marked','goto-next-marked'),
        ('Go To Next N&amp;ode','goto-next-node'),
        ('Go To Next &amp;Sibling','goto-next-sibling'),
        ('Go To Next Visibl&amp;e','goto-next-visible'),
        ('Go To Next Visite&amp;d','go-forward'),
        '-',
        ('Go To P&amp;arent','goto-parent'),
        '-',
        ('Go To &amp;Prev Node','goto-prev-node'),
        ('Go To P&amp;rev Sibling','goto-prev-sibling'),
        ('Go To Pre&amp;v Visible','goto-prev-visible'),
        ('Go To Prev Visi&amp;ted','go-back'),
        '-',
        ('Go To Last Node','goto-last-node'),
        ('Go To Last Siblin&amp;g','goto-last-sibling'),
        ('Go To &amp;Last Visible','goto-last-visible-node'),
    ]
</t>
<t tx="ekr.20071102162910.496">def defineCmdsMenuTables (self):

    if 0: # Replaced by minibuffer submenu.
        self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuChaptersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuRunTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()</t>
<t tx="ekr.20071102162910.497">def defineCmdsMenuAbbrevTable (self):

    self.cmdsMenuAbbrevTable = [
        # &amp;: a,e,i,k,l,r,w,v
        'abbre&amp;v-mode',
        '-',
        '&amp;list-abbrevs',
        '&amp;read-abbrev-file',
        '&amp;write-abbrev-file',
        '-',
        '&amp;add-global-abbrev',
        '&amp;inverse-add-global-abbrev',
        '&amp;kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&amp;expand-region-abbrevs',
    ]
</t>
<t tx="ekr.20071102162910.498">def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &amp;: a,c,d
        '&amp;add-editor',
        '&amp;cycle-editor-focus',
        '&amp;delete-editor',
    ]</t>
<t tx="ekr.20071102162910.499">def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&amp;append-to-buffer',
        '&amp;kill-buffer',
        'list-&amp;buffers',
        '&amp;list-buffers-alphabetically',
        '&amp;prepend-to-buffer',
        '&amp;rename-buffer',
        '&amp;switch-to-buffer',
    ]
</t>
<t tx="ekr.20071102162910.500">def defineCmdsMenuChaptersTable (self):

    self.cmdsMenuChaptersTable = [
        '&amp;clone-node-to-chapter',
        'c&amp;opy-node-to-chapter',
        'c&amp;reate-chapter',
        '&amp;move-node-to-chapter',
        '&amp;remove-chapter',
        '&amp;select-chapter',
    ]
</t>
<t tx="ekr.20071102162910.501">def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char',
        'back-&amp;paragraph',
        'back-&amp;sentence',
        'back-&amp;word',
        '-',
        'beginning-of-&amp;buffer',
        'beginning-of-&amp;line',
        '-',
        'pre&amp;vious-line',
    ]

    self.cursorMeuuBackExtendTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char-extend-selection',
        'back-&amp;paragraph-extend-selection',
        'back-&amp;sentence-extend-selection',
        'back-&amp;word-extend-selection',
        '-',
        'beginning-of-&amp;buffer-extend-selection',
        'beginning-of-&amp;line-extend-selection',
        '-',
        'pre&amp;vious-line-extend-selection',
    ]

    self.cursorMenuExtendTable = [
        # &amp;: l,p,s,w
        'extend-to-&amp;line',
        'extend-to-&amp;paragraph',
        'extend-to-&amp;sentence',
        'extend-to-&amp;word',
    ]

    self.cursorMenuForwardTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer',
        'end-of-&amp;line',
        '-',
        'forward-&amp;char',
        'forward-&amp;paragraph',
        'forward-&amp;sentence',
        'forward-&amp;end-word',
        'forward-&amp;word',
        '-',
        '&amp;next-line',
    ]

    self.cursorMenuForwardExtendTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer-extend-selection',
        'end-of-&amp;line-extend-selection',
        '-',
        'forward-&amp;char-extend-selection',
        'forward-&amp;paragraph-extend-selection',
        'forward-&amp;sentence-extend-selection',
        'forward-&amp;end-word-extend-selection',
        'forward-&amp;word-extend-selection',#
        '-',
        '&amp;next-line-extend-selection',    
    ]</t>
<t tx="ekr.20071102162910.502">def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&amp;cycle-all-focus',
        'focus-to-&amp;body',          
        'focus-to-&amp;log',             
        'focus-to-&amp;minibuffer',     
        'focus-to-&amp;tree',             
    ]
</t>
<t tx="ekr.20071102162910.503">def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&amp;load-file',
        '-',
        '&amp;start-kbd-macro',
        '&amp;end-kbd-macro',
        '&amp;name-last-kbd-macro',
        '-',
        '&amp;call-last-keyboard-macro',
        '&amp;insert-keyboard-macro',
    ]
</t>
<t tx="ekr.20071102162910.504">def defineCmdsMenuMinibufferTable (self):

    self.cmdsMenuMinibufferTable = [
        # &amp;: f,h,i,q,r,s,v
        '&amp;full-command',
        'keyboard-&amp;quit',
        '&amp;repeat-complex-command',
        '&amp;view-lossage',
        '-',
        '&amp;show-mini-buffer',
        'h&amp;ide-mini-buffer',
        '-',
        '&amp;help-for-minibuffer',
    ]
</t>
<t tx="ekr.20071102162910.505">def defineCmdsMenuPickersTable (self):

    self. cmdsMenuPickersTable = [
        'show-&amp;colors',
        'show-find-&amp;options',
        'show-&amp;fonts',
    ]</t>
<t tx="ekr.20071102162910.506">def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&amp;clear-rectangle',
        'c&amp;lose-rectangle',
        '&amp;delete-rectangle',
        '&amp;kill-rectangle',
        '&amp;open-rectangle',
        '&amp;string-rectangle',
        '&amp;yank-rectangle',
    ]
</t>
<t tx="ekr.20071102162910.507">def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &amp;: a,c,e,i,j,n,p,r,v
        '&amp;append-to-register',
        'copy-r&amp;ectangle-to-register',
        '&amp;copy-to-register',
        'i&amp;ncrement-register',
        '&amp;insert-register',
        '&amp;jump-to-register',
        # 'number-to-register',
        '&amp;point-to-register',
        'p&amp;repend-to-register',
        '&amp;view-register',
    ]
</t>
<t tx="ekr.20071102162910.508">def defineCmdsMenuRunTable (self):

    self.cmdsMenuRunTable = [
    # &amp;: e,r
    '&amp;execute-script',
    '&amp;run-unit-tests',
    ]
</t>
<t tx="ekr.20071102162910.509">def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &amp;: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&amp;line',
        'scroll-outline-down-&amp;page',
        'scroll-outline-le&amp;ft',
        'scroll-outline-&amp;right',
        's&amp;croll-outline-up-line',
        'scr&amp;oll-outline-up-page',
        '-',
        'scroll-&amp;down',
        'scroll-&amp;up',
        '-',
        'scroll-down-&amp;extend-selection',
        'scroll-up-e&amp;xtend-selection',
    ]</t>
<t tx="ekr.20071102162910.510">def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&amp;open-spell-tab',
        'spell-&amp;change',
        'spell-change-&amp;then-find',
        'spell-&amp;find',
        'spell-&amp;ignore',
    ]
</t>
<t tx="ekr.20071102162910.511">def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &amp;: a,b,c,d,e,f,g,i,l,m,n,o,p,r,s,u
        '&amp;beautify',
        'beautify-&amp;all',
        '-',
        'center-&amp;line',
        'center-&amp;region',
        '-',
        '&amp;capitalize-word',
        '&amp;downcase-word',
        '&amp;upcase-word',
        '-',
        'd&amp;owncase-region',
        'u&amp;pcase-region',
        '-',
        '&amp;indent-region',
        'indent-r&amp;elative',
        'indent-ri&amp;gidly',
        'u&amp;nindent-region',
        '-',
        'sort-colu&amp;mns',
        'sort-&amp;fields',
        '&amp;sort-lines',
    ]</t>
<t tx="ekr.20071102162910.512">def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &amp;: d,e,m,s,t,u,v
        'toggle-a&amp;utocompleter',
        'toggle-call&amp;tips',
        'toggle-&amp;extend-mode',
        'toggle-input-&amp;state',
        'toggle-in&amp;visibles',
        'toggle-&amp;mini-buffer',
        'toggle-split-&amp;direction',
        '-',
        # &amp;: a,b,c,f,h,i,r,w,x
        'toggle-find-&amp;ignore-case-option',
        'toggle-find-in-&amp;body-option',
        'toggle-find-in-&amp;headline-option',
        'toggle-find-mark-&amp;changes-option',
        'toggle-find-mark-&amp;finds-option',
        'toggle-find-rege&amp;x-option',
        'toggle-find-&amp;reverse-option',
        'toggle-find-&amp;word-option',
        'toggle-find-wrap-&amp;around-option',
    ]
</t>
<t tx="ekr.20071102162910.513">def defineWindowMenuTables (self):

    self.windowMenuTopTable = [
        # &amp;: a,b,c,d,e,f,l,m,n,o,p,r,s,t,u,w,x,y
        '*&amp;equal-sized-panes',
        '*&amp;toggle-active-pane',
        '*toggle-&amp;split-direction',
        '-',
        '*contract-&amp;body-pane',
        '*contract-&amp;log-pane',
        '*contract-&amp;outline-pane',
        '*contract-&amp;pane',
        '-',
        '*expand-bo&amp;dy-pane',
        '*expand-lo&amp;g-pane',
        '*expand-o&amp;utline-pane',
        '*expand-pa&amp;ne',
        '-',
        '*&amp;fully-expand-body-pane',
        '*full&amp;y-expand-log-pane',
        '*fully-e&amp;xpand-outline-pane',
        '*fully-exp&amp;and-pane',
        '-',
        '*&amp;resize-to-screen',
        '*&amp;cascade-windows',
        '*&amp;minimize-all',
        '-',
        '*open-compare-window',
        '*open-python-&amp;window',
    ]
</t>
<t tx="ekr.20071102162910.514">def defineHelpMenuTables (self):

    self.helpMenuTable = [
        # &amp;: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&amp;About Leo...',           'about-leo'),
        ('Online &amp;Home Page',       'open-online-home'),
        '*open-online-&amp;tutorial',
        '*open-&amp;users-guide',
        '-',
        ('Open Leo&amp;Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&amp;Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&amp;Settings.leo',   'open-leoSettings-leo'),
        ('Open &amp;myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&amp;ipts.leo',       'open-scripts-leo'),
        '-',
        '*he&amp;lp-for-minibuffer',
        '*help-for-&amp;command',
        '-',
        '*&amp;apropos-autocompletion',
        '*apropos-&amp;bindings',
        '*apropos-&amp;debugging-commands',
        '*apropos-&amp;find-commands',
        '-',
        '*pri&amp;nt-bindings',
        '*print-c&amp;ommands',
    ]
</t>
<t tx="ekr.20071102162910.515">def createMenusFromTables (self):

    c = self.c

    aList = c.config.getMenusList()
    if aList:
        self.createMenusFromConfigList(aList)
    else:
        self.defineMenuTables()

        self.createFileMenuFromTable()
        self.createEditMenuFromTable()
        self.createOutlineMenuFromTable()

        g.doHook("create-optional-menus",c=c)

        if self.useCmdMenu:
            self.createCmndsMenuFromTable()

        self.createWindowMenuFromTable()
        self.createHelpMenuFromTable()
</t>
<t tx="ekr.20071102162910.516">def createFileMenuFromTable (self):

    c = self.c
    fileMenu = self.createNewMenu("&amp;File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &amp;With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    &lt;&lt; create the recent files submenu &gt;&gt;
    self.add_separator(fileMenu)
    &lt;&lt; create the read/write submenu &gt;&gt;
    &lt;&lt; create the tangle submenu &gt;&gt;
    &lt;&lt; create the untangle submenu &gt;&gt;
    &lt;&lt; create the import submenu &gt;&gt;
    &lt;&lt; create the export submenu &gt;&gt;
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
</t>
<t tx="ekr.20071102162910.517">self.createNewMenu("Recent &amp;Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
</t>
<t tx="ekr.20071102162910.518">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
</t>
<t tx="ekr.20071102162910.519">tangleMenu = self.createNewMenu("Tan&amp;gle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
</t>
<t tx="ekr.20071102162910.520">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
</t>
<t tx="ekr.20071102162910.521">importMenu = self.createNewMenu("&amp;Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
</t>
<t tx="ekr.20071102162910.522">exportMenu = self.createNewMenu("&amp;Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
</t>
<t tx="ekr.20071102162910.523">def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&amp;Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    &lt;&lt; create the edit body submenu &gt;&gt;
    &lt;&lt; create the edit headline submenu &gt;&gt;
    &lt;&lt; create the find submenu &gt;&gt;

    self.createMenuEntries(editMenu,self.editMenuTop2Table)
</t>
<t tx="ekr.20071102162910.524">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
</t>
<t tx="ekr.20071102162910.525">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
</t>
<t tx="ekr.20071102162910.526">findMenu = self.createNewMenu("&amp;Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
</t>
<t tx="ekr.20071102162910.527">def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&amp;Outline")

    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)

    &lt;&lt; create check submenu &gt;&gt;
    &lt;&lt; create expand/contract submenu &gt;&gt;
    &lt;&lt; create move submenu &gt;&gt;
    &lt;&lt; create mark submenu &gt;&gt;
    &lt;&lt; create goto submenu &gt;&gt;
</t>
<t tx="ekr.20071102162910.528">checkOutlineMenu = self.createNewMenu("Chec&amp;k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
</t>
<t tx="ekr.20071102162910.529">expandMenu = self.createNewMenu("E&amp;xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
</t>
<t tx="ekr.20071102162910.530">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
</t>
<t tx="ekr.20071102162910.531">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
</t>
<t tx="ekr.20071102162910.532">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
</t>
<t tx="ekr.20071102162910.533">def createCmndsMenuFromTable (self):

    cmdsMenu = self.createNewMenu('&amp;Cmds')

    if 0: # Now in the minibuffer table.
        # Used in top table: q,u,x
        self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &amp;: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t,u
        ('&amp;Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&amp;ditors',       self.cmdsMenuBodyEditorsTable),
        ('&amp;Buffers...',         self.cmdsMenuBuffersTable),
        ('&amp;Chapters...',        self.cmdsMenuChaptersTable),
        ('C&amp;ursor/Selection...',[]),
        ('&amp;Focus...',           self.cmdsMenuFocusTable),
        ('&amp;Macro...',           self.cmdsMenuMacroTable),
        ('M&amp;inibuffer',         self.cmdsMenuMinibufferTable),
        #('&amp;Panes...',           self.cmdsMenuPanesTable),
        ('&amp;Pickers...',         self.cmdsMenuPickersTable),
        ('&amp;Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&amp;gisters...',       self.cmdsMenuRegistersTable),
        ('R&amp;un Script/Tests',   self.cmdsMenuRunTable),
        ('Scr&amp;olling...',       self.cmdsMenuScrollTable),
        ('Spell C&amp;heck...',     self.cmdsMenuSpellCheckTable),
        ('&amp;Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&amp;ngs',    self.cmdsMenuToggleTable),
    ):
        if table == self.cmdsMenuChaptersTable and not self.c.chapterController:
            continue
        menu = self.createNewMenu(name,'&amp;Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &amp;: b,e,f,s,t,x
        ('Cursor &amp;Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &amp;Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &amp;To...',                self.cursorMenuExtendTable),
        ('Cursor &amp;Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&amp;xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&amp;ursor/Selection...')
        self.createMenuEntries(menu,table)</t>
<t tx="ekr.20071102162910.534">def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&amp;Window")

    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
</t>
<t tx="ekr.20071102162910.535">def createHelpMenuFromTable (self,table):

    if sys.platform == 'darwin':
        self.getMacHelpMenu(table)
    else:
        helpMenu = self.createNewMenu("&amp;Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)</t>
<t tx="ekr.20071102162910.536">def createMenusFromConfigList (self,aList):

    '''Create menus from dictionary d instead of 'hard coded' menus.
    The 'top' menu has already been created.'''

    tag = '@menu'
    for z in aList:
        kind,val,val2 = z
        if kind.startswith(tag):
            name = kind[len(tag):].strip()
            if not self.handleSpecialMenus(name,parentName=None):
                self.createNewMenu(name) # Create top-level menu.
                self.createMenuFromConfigList(name,val,level=0)
        else:
            self.error('%s %s not valid outside @menu tree' % (kind,val))
</t>
<t tx="ekr.20071102162910.537">def createMenuFromConfigList (self,parentName,aList,level=0):

    table = [] ; parentMenu = self.getMenu(parentName)

    for z in aList:
        kind,val,val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu,table)
            if not self.handleSpecialMenus(name,parentName,table):
                self.createNewMenu(name,parentName) # Create submenu of parent menu.
                self.createMenuFromConfigList(name,val,level+1)
            table = []
        elif kind == '@item':
            name = str(val) # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2,name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:',kind)

    if table:
        self.createMenuEntries(parentMenu,table)</t>
<t tx="ekr.20071102162910.538">def handleSpecialMenus (self,name,parentName,table=[]):

    '''Handle a special menu if name is the name of a special menu.
    return True if this method handles the menu.'''

    c = self.c
    name2 = name.replace('&amp;','').replace(' ','').lower()

    if name2 == 'plugins':
        # Create the plugins menu using a hook.
        g.doHook("create-optional-menus",c=c)
        return True
    elif name2.startswith('recentfiles'):
        # Just create the menu.  createRecentFilesMenuItems will be called later.
        self.createNewMenu(name,parentName)
        c.recentFiles = c.config.getRecentFiles()
        return True
    elif name2 == 'help' and sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu(table)
        return helpMenu is not None
    else:
        return False
</t>
<t tx="ekr.20071102162910.539">def createRecentFilesMenuItems (self):

    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")
    if not recentFilesMenu:
        g.trace('Recent Files Menu does not exist')
        return

    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)

    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table)

    # Create all the other entries (a maximum of 36).
    accel_ch = string.digits + string.ascii_uppercase # Not a unicode problem.
    i = 0 ; n = len(accel_ch)
    for name in c.recentFiles[:n]:
        def recentFilesCallback (event=None,c=c,name=name):
            __pychecker__ = '--no-argsused' # event not used, but must be present.
            c.openRecentFile(name)
        label = "%s %s" % (accel_ch[i],g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=recentFilesCallback,underline=0)
        i += 1
</t>
<t tx="ekr.20071102162910.540">@nocolor

Cvs now contains a createCanvas convenience method to create a canvas tab in the log pane.  Here is a sample script in test.leo:

log = c.frame.log ; tag = 'my-canvas'

w = log.canvasDict.get(tag)
if not w:
..w = log.createCanvas(tag)
..w.configure(bg='yellow')

log.selectTab(tag)

I have not added a corresponding minibuffer command: only scripts have any real use for canvas tabs at present.  I'm not going to do more work on this unless somebody has a real need for it.

For an introduction to what can be done with Tk canvas widgets, see:

http://www.pythonware.com/library/tkinter/introduction/

@color
</t>
<t tx="ekr.20071102162910.541">def createCanvasWidget (self,parentFrame):

    self.logNumber += 1

    w = Tk.Canvas(parentFrame)

    logBar = Tk.Scrollbar(parentFrame,name="logBar")
    w['yscrollcommand'] = logBar.set
    logBar['command'] = w.yview
    logBar.pack(side="right", fill="y")

    logXBar = Tk.Scrollbar(parentFrame,name='logXBar',orient="horizontal") 
    w['xscrollcommand'] = logXBar.set 
    logXBar['command'] = w.xview 
    logXBar.pack(side="bottom", fill="x")

    w.pack(expand=1, fill="both")

    # Set the background color.
    configName = 'log_canvas_pane_tab_background_color'
    bg = self.c.config.getColor(configName) or 'MistyRose1'
    try: w.configure(bg=bg)
    except Exception: pass # Could be a user error.

    return w
</t>
<t tx="ekr.20071102162910.542">def createCanvas (self,tabName=None):

    c = self.c ; k = c.k

    if tabName is None:
        self.logNumber += 1
        tabName = 'Canvas %d' % self.logNumber

    tabFrame = self.nb.add(tabName)
    menu = self.makeTabMenu(tabName,allowRename=False)

    w = self.createCanvasWidget(tabFrame)

    self.canvasDict [tabName ] = w
    self.textDict [tabName] = None
    self.frameDict [tabName] = tabFrame

    self.setCanvasTabBindings(tabName,menu)

    return w
</t>
<t tx="ekr.20071102162910.543">def makeTabMenu (self,tabName=None,allowRename=True):

    '''Create a tab popup menu.'''

    # g.trace(tabName,g.callers())

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.

    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    menu.add_command(label='New CanvasTab',command=self.newCanvasTabFromMenu)

    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            return self.deleteTab(tabName)

        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)

        def renameTabCallback():
            return self.renameTabFromMenu(tabName)

        if allowRename:
            menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu
</t>
<t tx="ekr.20071102162910.544">def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)

    # This is called by getTabName.
    def selectTabCallback (newName):
        return self.selectTab(newName)

    self.getTabName(selectTabCallback)

def newCanvasTabFromMenu (self):

    self.createCanvas()
</t>
<t tx="ekr.20071102162910.545">def setTabBindings (self,tabName):

    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    w = self.textDict.get(tabName)

    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('&lt;Key&gt;',       k.masterKeyHandler),
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClick3Handler),
    ):
        w.bind(kind,handler)

    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        return self.onRightClick(event,menu)

    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)

    tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
    tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)

    k.completeAllBindingsForWidget(w)
</t>
<t tx="ekr.20071102162910.546">def setCanvasTabBindings (self,tabName,menu):

    c = self.c ; tab = self.nb.tab(tabName)

    def tabMenuRightClickCallback(event,menu=menu):
        return self.onRightClick(event,menu)

    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)

    tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
    tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)

</t>
<t tx="ekr.20071102162910.547"></t>
<t tx="ekr.20071102162910.548"></t>
<t tx="ekr.20071102162910.549">def insertChild (self,event=None):

    '''Insert a node after the presently selected node.'''

    c = self

    return c.insertHeadline(event=event,op_name='Insert Child',as_child=True)
</t>
<t tx="ekr.20071102162910.550">def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if (as_child or
            (current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)
        ):
            if c.config.getBool('insert_new_nodes_at_end'):
                p = current.insertAsLastChild()
            else:
                p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.selectPosition(p)
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.beginUpdate()
    try:
        c.editPosition(p,selectAll=True)
    finally:
        c.endUpdate(False)

    return p # for mod_labels plugin.
</t>
<t tx="ekr.20071102162910.551"># New ekr bindings: Alt-Y: yank-pop.  Alt-Ctrl-Y: cycle-all-focus.

# - Option: add-ws-to-kill-ring (or kill-ws-adds-to-kill-ring)
</t>
<t tx="ekr.20071102162910.552">class killBufferCommandsClass (baseEditCommandsClass):

    '''A class to manage the kill buffer.'''

    @others
</t>
<t tx="ekr.20071102162910.553">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.addWsToKillRing = c.config.getBool('add-ws-to-kill-ring')
    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.lastYankP = None # The position of the last item returned by iterateKillBuffer.
    self.reset = None
        # None, or the index of the next item to be returned in killBuffer by iterateKillBuffer.

def finishCreate (self):

    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k

    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
</t>
<t tx="ekr.20071102162910.554">def getPublicCommands (self):

    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'kill-ws':                  self.killWs,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
</t>
<t tx="ekr.20071102162910.555">def addToKillBuffer (self,text):

    '''Insert the text into the kill buffer if force is True or
    the text contains something other than whitespace.'''

    if self.addWsToKillRing or text.strip():
        self.killBuffer = [z for z in self.killBuffer if z != text]
        self.killBuffer.insert(0,text)
</t>
<t tx="ekr.20071102162910.556">def backwardKillSentence (self,event):

    '''Kill the previous sentence.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.rfind('.',ins)
    if i == -1: return

    undoType='backward-kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,i) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20071102162910.557">def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

</t>
<t tx="ekr.20071102162910.558">def clearKillRing (self,event=None):

    '''Clear the kill ring.'''

    self.killBuffer = []
</t>
<t tx="ekr.20071102162910.559">def getClipboard (self,w):

    '''Return the contents of the clipboard.'''

    __pychecker__ = '--no-argsused' # w not used.

    try:
        ctxt = g.app.gui.getTextFromClipboard()
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except:
        g.es_exception()

    return None
</t>
<t tx="ekr.20071102162910.560">class killBuffer_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def iterateKillBuffer (self):

    return self.killBuffer_iter_class(self.c)
</t>
<t tx="ekr.20071102162910.561">def __init__(self,c):

    # g.trace('iterateKillBuffer.__init')
    self.c = c
    self.index = 0 # The index of the next item to be returned.

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102162910.562">def next(self):

    commands = self.c.killBufferCommands
    aList = commands.killBuffer

    # g.trace(g.listToString([repr(z) for z in aList]))

    if not aList:
        self.index = 0
        return None

    if commands.reset is None:
        i = self.index
    else:
        i = commands.reset
        commands.reset = None

    if i &lt; 0 or i &gt;= len(aList): i = 0
    # g.trace(i)
    val = aList[i]
    self.index = i + 1
    return val
</t>
<t tx="ekr.20071102162910.563">def kill (self,event,frm,to,undoType=None):

    '''A helper method for all kill commands.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    w.delete(frm,to)
    w.setInsertPoint(frm)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20071102162910.564">def killLine (self,event):
    '''Kill the line containing the cursor.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    # g.trace(i,j,ins,len(s),repr(s[i:j]))
    if ins &gt;= len(s) and g.match(s,j-1,'\n'): # Kill the trailing newline.
        i = max(0,len(s)-1)
        j = len(s)
    elif j &gt; i+1 and g.match(s,j-1,'\n'): # Kill the line, but not the newline.
        j -= 1
    else: # Kill the newline.
        pass
    self.kill(event,i,j,undoType='kill-line')
</t>
<t tx="ekr.20071102162910.565">def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)

def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return

    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    # self.removeRKeys(w)
</t>
<t tx="ekr.20071102162910.566">def killSentence (self,event):

    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins)
    if i == -1: return

    undoType='kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,ins) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20071102162910.567">def killWs (self,event,undoType='kill-ws'):

    '''Kill whitespace.'''

    ws = ''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    i = j = ins = w.getInsertPoint()

    while i &gt;= 0 and s[i] in (' ','\t'):
        i-= 1
    if i &lt; ins: i += 1

    while j &lt; len(s) and s[j] in (' ','\t'):
        j += 1

    if j &gt; i:
        ws = s[i:j]
        # g.trace(i,j,repr(ws))
        w.delete(i,j)
        if undoType: self.beginCommand(undoType=undoType)
        if self.addWsToKillRing:
            self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20071102162910.568">def yank (self,event,pop=False):

    '''yank: insert the first entry of the kill ring.
    yank-pop: insert the next entry of the kill ring.
    '''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    current = c.currentPosition()
    if not current: return
    text = w.getAllText()
    i, j = w.getSelectionRange()
    clip_text = self.getClipboard(w)
    if not self.killBuffer and not clip_text: return

    undoType = g.choose(pop,'yank-pop','yank')
    self.beginCommand(undoType=undoType)
    try:
        if not pop or self.lastYankP and self.lastYankP != current:
            self.reset = 0
        s = self.kbiterator.next()
        if s is None: s = clip_text or ''
        if i != j: w.deleteTextSelection()
        if s != s.lstrip(): # s contains leading whitespace.
            i2,j2 = g.getLine(text,i)
            k = g.skip_ws(text,i2)
            if i2 &lt; i &lt;= k:
                # Replace the line's leading whitespace by s's leading whitespace.
                w.delete(i2,k)
                i = i2
        w.insert(i,s)
        w.setSelectionRange(i,i+len(s),insert=i+len(s))
        self.lastYankP = current.copy()
        c.frame.body.forceFullRecolor()
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20071102162910.569">def yankPop (self,event):

    '''Insert the next entry of the kill ring.'''

    self.yank(event,pop=True)

</t>
<t tx="ekr.20071102162910.570">def zapToCharacter (self,event):

    '''Kill characters from the insertion point to a given character.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        ch = event and event.char or ' '
        k.resetLabel()
        k.clearState()
        if ch.isspace(): return
        s = w.getAllText()
        ins = w.getInsertPoint()
        i = s.find(ch,ins)
        if i == -1: return
        self.beginCommand(undoType='zap-to-char')
        self.addToKillBuffer(s[ins:i])
        w.setAllText(s[:ins] + s[i:])
        w.setInsertPoint(ins)
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20071102162910.571">@nocolor

What I did:

- Fixed a major bug in findMarkAtIndex, the method that computes the starting point for incremental colorizing.  This was likely the source of the so-called 'docstring' bug.

- Rewrote and re-enabled the code in partialColor that determines when to end coloring. I suspect that the bug in findMarkAtIndex was making this code look more buggy than it was.

- Added the isSameColorState method in the threading colorizer (and a dummy in the old colorizer).  This allows the crucial node-switching code in treeSelectHelper to avoid colorizing a node if no real change has been made.  This can speed up the find command significantly when many matches occur in large body text.

@color</t>
<t tx="ekr.20071102162910.572">#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def treeSelectHelper (self,p,updateBeadList,scroll):

    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl # 2007/10/25
    old_p = c.currentPosition()

    if not p:
        # Bug fix: 5/31/07: do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    # g.trace('      ===',id(w),p and p.headString())
    if self.trace_select and not g.app.unitTesting: g.trace('tree',g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p,updateBeadList) # Remember this position.
    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
</t>
<t tx="ekr.20071102162910.573"># Remember the position of the scrollbar before making any changes.
if not body: g.trace('no body!','c.frame',c.frame,'old_p',old_p)

yview = body.getYScrollPosition()
insertSpot = c.frame.body.getInsertPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if c.edit_widget(old_p):
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
</t>
<t tx="ekr.20071102162910.574"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing newlines.

s = g.toUnicode(p.v.t.bodyString,"utf-8")
old_s = w.getAllText()

if True and p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
    pass
else:
    # This destroys all color tags, so do a full recolor.
    w.setAllText(s)
    self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    w.setYScrollPosition(first)

if p.v and p.v.t.insertSpot != None:
    spot = p.v.t.insertSpot
    w.setInsertPoint(spot)
    w.see(spot)
else:
    w.setInsertPoint(0)

# g.trace("select:",p.headString())
</t>
<t tx="ekr.20071102162910.575">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.headString())

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
</t>
<t tx="ekr.20071102162910.576">Suppressed doc-part-delims when show_doc_parts_as_paragraphs is True</t>
<t tx="ekr.20071102162910.577"></t>
<t tx="ekr.20071102162910.578"># Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):

    cmn = self.canonicalizeTranslatedMenuName(menuName)
    return g.app.realMenuNameDict.get(cmn,menuName)

def setRealMenuName (self,untrans,trans):

    cmn = self.canonicalizeTranslatedMenuName(untrans)
    g.app.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

    try:
        for untrans,trans in table:
            self.setRealMenuName(untrans,trans)
    except:
        g.es("exception in setRealMenuNamesFromTable")
        g.es_exception()
</t>
<t tx="ekr.20071102162910.579">def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName) # parent may be None.
        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists: " + menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&amp;")
            label = label.replace("&amp;","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&amp;")
                index_label = index_label.replace("&amp;","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating " + menuName + " menu")
        g.es_exception()
        return None
</t>
<t tx="ekr.20071102162910.580"></t>
<t tx="ekr.20071102162910.581"></t>
<t tx="ekr.20071102162910.582">def findMarkAtIndex(self,d,i):

    '''Return the higest match that starts strictly before i.
    Return 0 if no such match.'''

    keys = d.keys()
    keys.sort()
    last_i = 0 
    for key in keys:
        if key &gt;= i:
            break
        else:
            last_i = key

    if self.trace: g.trace('*******',last_i)
    return last_i
</t>
<t tx="ekr.20071102162910.583">def finishColoring (self):

    if self.trace:
        g.trace('%d' % self.threadCount,'globalTagList',len(self.globalTagList))

    limit = 500

    if self.killFlag:
        tagList = []
        self.globalTagList = []
    else:
        tagList = self.globalTagList[:limit]
        self.globalTagList = self.globalTagList[limt:]
        self.tagAll(tagList)</t>
<t tx="ekr.20071102162910.584">def partialColor (self,s):

    '''Partially recolor s'''

    mid_i,tail_i,delta,all = self.computeIndices()
    if all:
        if self.trace: g.trace('*** all lines match: recolor all')
        return self.fullColor(s)

    d = self.marksDict = self.adjustMarksDict(self.marksDict,mid_i,tail_i,delta)
    assert(mid_i == 0 or s[mid_i-1] == '\n')
    i = self.findMarkAtIndex(d,max(0,mid_i-1))
    self.start_i = self.self_end_i = i
    # if mid_i-1 != i: g.trace('backtrack',repr(s[i:mid_i]))

    # Create a list of (i,n) pairs from marksDict.
    d = self.marksDict ; keys = d.keys() ; keys.sort()
    endList = [(z,d.get(z)) for z in keys if z + d.get(z) &gt;= tail_i]
    self.marksDict = {}
    if self.trace: g.trace(self.language,'thread',self.threadCount,'i',i)
    while i &lt; len(s):
        progress = i
        if self.c.frame not in g.app.windowList:
            # print 'threading_colorizer: partialColor: window killed'
            return
        if self.killFlag:
            if self.trace: g.trace('*** killed %d*' % self.threadCount)
            return
        # if i &lt; 0 or i &gt;= len(s):
            # g.trace('can not happen','i out of range',i)
        for f in self.rulesDict.get(s[i],[]):
            n = f(self,s,i)
            if n is None: g.trace('Can not happen: matcher returns None')
            elif n &gt; 0:
                if (trace_all_matches) and f.__name__ != 'match_blanks':
                    g.trace(f.__name__,repr(s[i:i+n]))
                self.marksDict[i] = n
                i += n ; break
        else:
            i += 1
        if i &gt; tail_i:
            &lt;&lt; finish if no item in endList covers i &gt;&gt;
        assert progress &lt; i
    self.end_i = i
    self.old_s = self.s
    if self.trace: g.trace('*** done',self.threadCount)
</t>
<t tx="ekr.20071102162910.585">done = False ; n = 0 # count of elements to be removed.
for z in endList:
    i2,n2 = z
    if i2 &lt;= i:
        if i2 + n2 &lt; i:
            n += 1 # strictly before i. Remove it below.
        else:
            break # covers i.  Not done.
    else: # i2 &gt; i:
        done = True
    if done: # Add trailing items in endList to the marksDict.
        self.marksDict[i2] = n2
else:
    done = True

if done:
    if self.trace: g.trace('*** found end: i: %d %s' % (i,repr(s[i:i+20])))
    break
else:
    # Delete n entries from the front of endList.
    if n &gt; 0:
        endList = endList[n:]</t>
<t tx="ekr.20071102162910.586">def adjustMarksDict (self,d,mid_i,tail_i,delta):

    '''Adjust the marksDict d by adding delta to
    all keys and values whose keys are &gt;= mid_i.'''

    # Pass 1: Add changed items to d2, and delete them from d.
    # Important: missing entries do not cause bugs--
    # at worst they slow down the colorizer.
    # Thus, we err on the side of caution.
    d2 = {}
    for i in d.keys():
        if i &gt; tail_i:
            # d2 [i+delta] = d.get(i) + delta
            if i + delta &gt;= 0:
                val = d.get(i) + delta
                if val &gt;= 0:
                    d2 [i+delta] = val
            del d[i]
        elif i &gt;= mid_i:
            del d[i]

    # Pass 2: Insert changed items back into d.
    for i in d2.keys():
        d[i] = d2.get(i)

    return d
</t>
<t tx="ekr.20071102162910.587">def removeTagsFromRange(self,i,j):

    s = self.s ; w = self.w

    if self.trace: g.trace('i',i,'j',j)

    names = [z for z in w.tag_names() if z not in ('sel','insert')]

    x1,x2 = w.toGuiIndex(self.start_i,s=s), w.toGuiIndex(self.end_i,s=s)
    for tag in names:
        # g.trace(tag,x1,x2)
        w.tag_remove(tag,x1,x2)
</t>
<t tx="ekr.20071102162910.588">def computeIndices (self):

    '''Return (mid_i,tail_i,delta,all) where
    - mid_i is the index of the start of the changed text,
    - tail_i is the index of the start of the **new** trailing lines,
    - delta is the change in the size of the changed text,
    - all is true if all text must be recolored.'''

    old_s,new_s = self.old_s,self.s

    # The first optimization: recolor **everything** if all lines match.
    # Some routines delete, then insert the text again, deleting all tags in the process.
    if old_s == new_s:
        all = True
        return 0,0,0,all

    # The second optimization. Check to see if only one line has changed.
    ins = self.insertPoint # We must *not* call Tk here!
    new_i,new_j = g.getLine(new_s,ins)
    old_i,old_j = g.getLine(old_s,new_i)
    new_head = new_s[:new_i]
    old_head = old_s[:old_i]
    new_tail = new_s[new_j:]
    old_tail = old_s[old_j:]
    #g.trace('new_head',repr(new_head),'\n','old_head',repr(old_head))
    #g.trace('new_tail',repr(new_tail),'\n','old_tail',repr(old_tail))
    if new_head == old_head and new_tail == old_tail:
        # g.trace('**one line changed')
        mid_i = new_i
        tail_i = new_j
        #new_line = new_s[new_i:new_j]
        #old_line = old_s[old_i:old_j]
        #delta = len(new_line) - len(old_line)
        delta = (new_j-new_i) - (old_j-old_i)
        all = False
        return mid_i,tail_i,delta,all

    # The general case: compare line-by line to find the head and tail.
    new_lines = g.splitLines(new_s)
    old_lines = g.splitLines(old_s)
    new_len = len(new_lines)
    old_len = len(old_lines)
    # Find the head lines, the leading matching lines.
    i = 0
    while i &lt; new_len and i &lt; old_len and old_lines[i] == new_lines[i]:
        i += 1
    head = i
    # Find the tail lines, the trailing matching lines.
    i = 0
    while (
        old_len-i-1 &gt;=0 and new_len-i-1 &gt;=0 and
        old_lines[old_len-i-1] == new_lines[new_len-i-1]
    ):
        i += 1
    tail = i
    # Compute the change (middle) lines.
    new_head = ''.join(new_lines[:head])
    old_head = ''.join(old_lines[:head])
    # assert old_head == new_head
    if tail:
        new_tail = ''.join(new_lines[-tail:])
        old_tail = ''.join(old_lines[-tail:])
        new_middle = ''.join(new_lines[head:-tail])
        old_middle = ''.join(old_lines[head:-tail])
    else:
        # g.trace('no tail')
        new_tail = old_tail = ''
        new_middle = ''.join(new_lines[head:])
        old_middle = ''.join(old_lines[head:])
    # assert old_tail == new_tail

    # This recolors all of all changed lines.
    # We could optimize this a bit, but I doubt it would make much difference.
    mid_i = len(new_head)
    tail_i = mid_i + len(new_middle)
    delta = len(new_middle) - len(old_middle)
    all = False
    # g.trace('mid_i',mid_i,'tail_i',tail_i,'delta',delta,'all',all)
    return mid_i,tail_i,delta,all
</t>
<t tx="ekr.20071102162910.589"></t>
<t tx="ekr.20071102162910.590">def tag_ranges(self,tagName):

    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
</t>
<t tx="ekr.20071102162910.591">def toPythonIndex (self,i):
    '''Convert a Tk index to a Python index as needed.'''
    w =self
    if i is None:
        g.trace('can not happen: i is None')
        return 0
    elif type(i) in (type('a'),type(u'a')):
        s = Tk.Text.get(w,'1.0','end') # end-1c does not work.
        i = Tk.Text.index(w,i) # Convert to row/column form.
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(s,row,col)
        #g.es_print(i)
    return i
</t>
<t tx="ekr.20071102162910.592">def convertRowColToPythonIndex (s,row,col,lines=None):

    '''Convert zero-based row/col indices into a python index into string s.'''

    if row &lt; 0: return 0

    if lines is None:
        lines = g.splitLines(s)

    if row &gt;= len(lines):
        return len(s)

    col = min(col, len(lines[row]))

    #### A big bottleneck
    prev = 0
    for line in lines[:row]:
        prev += len(line)

    return prev + col
</t>
<t tx="ekr.20071102162910.593">if g.unitTesting:
    s1 = 'abc\n\np\nxy'
    s2 = 'abc\n\np\nxy\n'
    table1 = (
        (0,(-1,0)), # One too small.
        (0,(0,0)),
        (1,(0,1)),
        (2,(0,2)),
        (3,(0,3)), # The newline ends a row.
        (4,(1,0)),
        (5,(2,0)),
        (6,(2,1)),
        (7,(3,0)),
        (8,(3,1)),
        (9,(3,2)), # One too large.
    )
    table2 = (
        (9,(3,2)),
        (10,(4,0)), # One two many.
    )
    for s,table in ((s1,table1),(s2,table2)):
        for i,data in table:
            row,col = data
            result = g.convertRowColToPythonIndex(s,row,col)
            assert i == result, 'row: %d, col: %d, expected: %d, got: %s' % (row,col,i,result)</t>
<t tx="ekr.20071102162910.594">def convertPythonIndexToRowCol (s,i):

    '''Convert index i into string s into zero-based row/col indices.'''

    if not s or i &lt;= 0:
        return 0,0

    i = min(i,len(s))

    # works regardless of what s[i] is
    row = s.count('\n',0,i) # Don't include i
    if row == 0:
        return row,i
    else:
        prevNL = s.rfind('\n',0,i) # Don't include i
        # g.trace('prevNL',prevNL,'i',i,g.callers())
        return row,i-prevNL-1
</t>
<t tx="ekr.20071102162910.595">if g.unitTesting:
    s1 = 'abc\n\np\nxy'
    table1 = (
        (-1,(0,0)), # One too small.
        (0,(0,0)),
        (1,(0,1)),
        (2,(0,2)),
        (3,(0,3)), # The newline ends a row.
        (4,(1,0)),
        (5,(2,0)),
        (6,(2,1)),
        (7,(3,0)),
        (8,(3,1)),
        (9,(3,2)), # One too many.
        (10,(3,2)), # Two too many.
    )
    s2 = 'abc\n\np\nxy\n'
    table2 = (
        (9,(3,2)),
        (10,(4,0)), # One too many.
        (11,(4,0)), # Two too many.
    )
    s3 = 'ab' # Test special case.  This was the cause of off-by-one problems.
    table3 = (
        (-1,(0,0)), # One too small.
        (0,(0,0)),
        (1,(0,1)),
        (2,(0,2)), # One too many.
        (3,(0,3)), # Two too many.
    )

    for s,table in ((s1,table1),(s2,table2)):
        for i,result in table:
            row,col = g.convertPythonIndexToRowCol(s,i)
            assert row == result[0], 'i: %d, expected row %d, got %d' % (i,result[0],row)
            assert col == result[1], 'i: %d, expected col %d, got %d' % (i,result[1],col)
</t>
<t tx="ekr.20071102162910.596"></t>
<t tx="ekr.20071102162910.597">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4568499
By: ktenney

I like doctests, often debug with g.es()
statements, and open winpdb to examine what's
going on.

I've a small patch to the debug command
leoEditCommands.py--&gt;debugCommandsClass--&gt;debug
to simplify this.

The patch writes the following to the beginning of
the script being debugged;

class G:
def es(s,c=None):
  pass
g = G()

This makes the g.es() statements legal.

The patch also checks for doctests in the script,
and if found, converts them to regular code.

A node containing;

&gt;&gt;&gt; import inspect, sys
&gt;&gt;&gt; insp = sys.modules['inspect']
&gt;&gt;&gt; print insp.__name__
inspect
&gt;&gt;&gt; g.es(dir(insp))

can be run as a doctest;
&lt;alt x&gt; dt
(if the dtest.py plugin is active)

or sent to winpdb;
&lt;alt x&gt; debug

The patch doesn't change the handling of regular scripts.

It goes right after;
if not winpdb: return

#check for doctest examples
try:
....import doctest
....parser = doctest.DocTestParser()
....examples = parser.get_examples(script)

....# if this is doctest, extract the examples as a script
....if len(examples) &gt; 0:
........script = doctest.script_from_examples(script)

except ImportError:
....pass

# special case; debug code may include g.es("info string")
# insert code fragment to make this expression legal outside Leo
hide_ges = "class G:\n def es(s,c=None):\n  pass\ng = G()\n"

script = hide_ges + script

@color</t>
<t tx="ekr.20071102162910.598">@nocolor

From the documentation at: http://webpages.charter.net/edreamleo/rstplugin3.html#options

strip_at_file_prefixes (default: True)

True: remove @auto, @file, @nosent and @thin from the start of headlines.</t>
<t tx="ekr.20071102162910.599"></t>
<t tx="ekr.20071102162910.600"></t>
<t tx="ekr.20071102162910.601">def newLeoCommanderAndFrame(self,fileName=None,gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leoCommands

    if not fileName: fileName = ""
    if not gui: gui = g.app.gui
    &lt;&lt; compute the window title &gt;&gt;

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    if updateRecentFiles:
        c.updateRecentFiles(fileName)

    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
</t>
<t tx="ekr.20071102162910.602"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
</t>
<t tx="ekr.20071102162910.603">def completeFileName (fileName):

    import leoGlobals as g

    if not fileName:
        return None

    # This does not depend on config settings.
    try:
        import sys
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    fileName = g.os_path_join(os.getcwd(),fileName)
    head,ext = g.os_path_splitext(fileName)

    if not ext:
        fileName = fileName + ".leo"

    return fileName
</t>
<t tx="ekr.20071102162910.604">def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    &lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print()
                s = g.toEncodedString(s,'ascii')
                print s
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
</t>
<t tx="ekr.20071102162910.605"># This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None</t>
<t tx="ekr.20071102162910.606">def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(fileName=path,initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
</t>
<t tx="ekr.20071102162910.607">def updateSettings (self,c,localFlag):

    d = self.readSettings(c)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
</t>
<t tx="ekr.20071102162910.608">def createFrame (fileName):

    """Create a LeoFrame during Leo's startup process."""

    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName,initEditCommanders=True)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if frame.c.chapterController:
        frame.c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
</t>
<t tx="ekr.20071102162910.609">@nocolor

&gt; Oh joy. The problem can be fixed in Leo.

Maybe I spoke too soon.  The crasher in print can be worked around.  But that is not the end of the story.

The problem is determining the proper way to convert Lasidoré.leo to unicode.  Using 'utf-8' in g.toUnicode doesn't work on XP. It produces byte hash for the é.  Using 'utf-8' fails spectacularly: the entire file name looks like chinese!  It's possible that some other encoding would work, but how to discover it?

Furthermore, g.os_path_exists returns False for Lasidoré.leo.  That may indicate a problem with the Python library, or not.

Moreover, Lasidoré.leo isn't shown properly in the Leo window: 'byte hash' is shown for the é character.  Saving *this* (new) file gives a file with the dreaded square instead of é in XP.  And loading this new file also doesn't work: the file is not found and yet another new file is created.

This could be a hard problem to solve.  I'm not sure I understand the interaction between unicode and file systems well enough to fix it.

So for now, the workaround of avoiding non-ascii characters in file names seems prudent.  Sorry about this.  I would fix it if I could: it's most annoying to limit oneself to ascii file names.

Edward
</t>
<t tx="ekr.20071102162910.610">@first # -*- coding: utf-8 -*-

# The encoding above does not seem to matter--
# it suppresses a warning given by execute-script.

import os

for name in ('Lasidoré.leo','test.leo'):
    g.es('--')
    for encoding in ('utf-16','utf-8','mbcs'):
        s = r'c:\prog\tigris-cvs\leo\test\%s' % name
        s = g.toUnicode(s,encoding) # pep 277 allows unicode file names.
        g.es(encoding,s,os.path.exists(s))
</t>
<t tx="ekr.20071102162910.611">def toUnicode (s,encoding,reportErrors=False):

    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = unicode(s,encoding,"replace")
    return s
</t>
<t tx="ekr.20071102162910.612">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4566692
By: vransmayr

I tried to import

* an HTML file
* a plain version file (w/o any file extension)

In this case Leo wrote out the new empty @auto-node and didn't read in the
content of the original file.

This is not what I had expected ;-)

----- What I did:

- Removed c.atAutoDict and related logic:  The code now does not depend on past history.
- Added force keyword arg to writeOneAtAutoNode.
- Writing a .leo file never reads an @auto node.
- @auto nodes overwrite existing files only if a) they are dirty and b) they have significant info.

@color
</t>
<t tx="ekr.20071102162910.613"># This is used, at present, by g.getScript.  It is a natural status ivar in any case.</t>
<t tx="ekr.20071102162910.614">@nocolor

- Use the term 'event handler' for hook.  This is much better terminology.

- Move the discussion of event handlers to the scripting chapter.

- Removed the discussion of all menu convenience routines: they are not needed now that Leo supports @menus nodes.

- The 'writing plugins' chapter is now very simple.</t>
<t tx="ekr.20071102162910.615"></t>
<t tx="ekr.20071102162910.616"></t>
<t tx="ekr.20071102162910.617"></t>
<t tx="ekr.20071102162910.618"># Replaced the (useless) trace with an error message to the console window.</t>
<t tx="ekr.20071102162910.619">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4584199
By: ktenney

I found the Windows aspell installer and ran it.

I edited @settings
@string aspell_dir and @string aspell_bin_dir

Leo then failed to start, traceback follows

[snip]

in getAspellWithCtypes
    raise Exception('aspell checker not enabled')
Exception: aspell checker not enabled

** To do: print the settings if there are init problems.</t>
<t tx="ekr.20071102162910.620">class AspellClass:

    """A wrapper class for Aspell spell checker"""

    @others
</t>
<t tx="ekr.20071102162910.621"></t>
<t tx="ekr.20071102162910.622">def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = g.os_path_abspath(c.config.getString('aspell_dir'))
    self.aspell_bin_dir = g.os_path_abspath(c.config.getString('aspell_bin_dir'))

    self.local_language_code = local_language_code or 'en'
    self.local_dictionary_file = g.os_path_abspath(local_dictionary_file)
    self.local_dictionary = "%s.wl" % os.path.splitext(self.local_dictionary_file) [0]

    # g.trace('code',self.local_language_code,'dict',self.local_dictionary_file)
    # g.trace('dir',self.aspell_dir,'bin_dir',self.aspell_bin_dir)

    try:
        import ctypes
        import ctypes.util
        self.use_ctypes = True
    except ImportError:
        self.use_ctypes = False
    self.aspell = self.sc = None

    if self.use_ctypes:
        self.getAspellWithCtypes()
    else:
        self.getAspell()
</t>
<t tx="ekr.20071102162910.623">def getAspell (self):

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=None,verbose=False)

    self.aspell = aspell
    self.sc = aspell and aspell.spell_checker(prefix=self.aspell_dir,lang=self.local_language_code)
</t>
<t tx="ekr.20071102162910.624">def getAspellWithCtypes (self):

    import ctypes
    import ctypes.util
    c_int, c_char_p = ctypes.c_int, ctypes.c_char_p

    try:
        if sys.platform.startswith('win'):
            path = g.os_path_join(self.aspell_bin_dir, "aspell-15.dll")
            self.aspell = aspell = ctypes.CDLL(path)
        else:
            path = 'aspell'
            libname = ctypes.util.find_library(path)
            assert(libname)
            self.aspell = aspell = ctypes.CDLL(libname)
    except Exception:
        print 'Can not load %s' % (path)
        self.aspell = self.check = self.sc = None
        return

    try:
        &lt;&lt; define and configure aspell entry points &gt;&gt;
    except Exception:
        print 'aspell checker not enabled'
        self.aspell = self.check = self.sc = None
        return

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
</t>
<t tx="ekr.20071102162910.625"># new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p] 

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_int, c_char_p] 

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p  

sc = new_aspell_config()
if 0:
    print sc 
    print aspell_config_replace(sc, "prefix", aspell_dir) #1/0 
    print 'prefix', aspell_dir, `aspell_config_retrieve(sc, "prefix")`
    print aspell_config_retrieve(sc, "lang")
    print aspell_config_replace(sc, "lang",self.local_language_code)
    print aspell_config_retrieve(sc, "lang")

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))

# Rudimentary error checking, needs more.  
if aspell.aspell_error_number(possible_err) != 0:
    print 'err', aspell_error_message(possible_err)
    spell_checker = None
else: 
    spell_checker = aspell.to_aspell_speller(possible_err)

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_int
word_list_size.argtypes = [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_int
word_list_elements.argtypes = [c_int,]

# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_int 
suggest.argtypes = [c_int, c_char_p, c_int]</t>
<t tx="ekr.20071102162910.626">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; «original» «count» «offset»: «miss», «miss», ... 
    None: 
    # «original» «offset» 
    simplifyed to not create the string then make a list from it
    """

    # g.trace('word',word)

    if not self.aspell:
        g.trace('aspell not installed')
        return None
    elif self.use_ctypes:
        if self.check(self.spell_checker,word,len(word)):
            return None
        else:
            return self.suggestions(word)
    else:
        if self.sc.check(word):
            return None
        else:
            return self.sc.suggest(word)
</t>
<t tx="ekr.20071102162910.627">def suggestions(self,word):

    "return list of words found"

    aList = []
    sw = self.suggest(self.spell_checker, word, len(word))

    if self.word_list_size(sw):
        ewords = self.word_list_elements(sw)
        while 1: 
            x = self.string_enumeration_next(ewords)
            if x is None: break
            aList.append(x)
    return aList</t>
<t tx="ekr.20071102162910.628">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.

    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        # g.es_print("Unable to update local aspell dictionary: %s" % err)
        print "Unable to update local aspell dictionary: %s" % (err)
        return False
</t>
<t tx="ekr.20071102162910.629">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4574271
By: hibou-57

I've tried the Leo's import features, and it seems that my JavaScripts, written
in UTF-8, are imported as if it was ASCII. I.e., all accented characters are
imported as a sequence of character (just like what you can see with a none-utf-8
editor).

There is a work around : just create a node, and make a simple copy-past from
another editor to Leo body panel.

---------------

&gt; I've added an entry in the Windows registry to open *.leo files with Leo. The entry is like this: 

pathToPythonInterpreter pathToLeoScript "%1"

...this fails when the path to the leo file ("%1") contains accented characters (e.g. like Lasidoré.leo for example). 

&gt; But not sure this is due to Leo, indeed, I think this is rather due to the Python environment. 

Well, I hope it's a problem in Leo--it will be easier to fix :-) I'll look into this soon. Thanks for this helpful report.

@color</t>
<t tx="ekr.20071102162910.630">def setEncoding (self,p=None):

    # scanDirectives checks the encoding: may return None.
    c = self.c
    if p is None: p = c.currentPosition()
    theDict = g.scanDirectives(c,p)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
</t>
<t tx="ekr.20071102162910.631"></t>
<t tx="ekr.20071102162910.632">def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            g.setGlobalOpenDir(fileName)
            &lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20071102162910.633">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
</t>
<t tx="ekr.20071102162910.634">def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)
</t>
<t tx="ekr.20071102162910.635">def importFilesCommand (self,files=None,treeType=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) &lt; 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    c.beginUpdate()
    try: # range of update...
        if len(files) == 2:
            &lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                if not g.unitTesting:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    finally:
        c.endUpdate()
    c.selectVnode(current)
</t>
<t tx="ekr.20071102162910.636">@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) &gt; 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)
</t>
<t tx="ekr.20071102162910.637"></t>
<t tx="ekr.20071102162910.638"># Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,firstVnode):
    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

# Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,firstVnode):

    __pychecker__ = '--no-objattrs' # suppress bad warnings re lastVnode.

    c = self.c
    if len(strings) == 0: return None
    if not self.stringsAreValidMoreFile(strings): return None
    c.beginUpdate()
    try: # range of update...
        firstLevel, junk = self.moreHeadlineLevel(strings[0])
        lastLevel = -1 ; theRoot = lastVnode = None
        index = 0
        while index &lt; len(strings):
            progress = index
            s = strings[index]
            level, newFlag = self.moreHeadlineLevel(s)
            level -= firstLevel
            if level &gt;= 0:
                &lt;&lt; Link a new vnode v into the outline &gt;&gt;
                &lt;&lt; Set the headline string, skipping over the leader &gt;&gt;
                &lt;&lt; Count the number of following body lines &gt;&gt;
                &lt;&lt; Add the lines to the body text of v &gt;&gt;
                v.setDirty()
            else: index += 1
            assert progress &lt; index
        if theRoot:
            theRoot.setDirty()
            c.setChanged(True)
    finally:
        c.endUpdate()
    return theRoot
</t>
<t tx="ekr.20071102162910.639">assert(level &gt;= 0)
if lastVnode is None:
    # g.trace(firstVnode)
    theRoot = v = firstVnode.insertAfter()
elif level == lastLevel:
    v = lastVnode.insertAfter()
elif level == lastLevel + 1:
    v = lastVnode.insertAsNthChild(0)
else:
    assert(level &lt; lastLevel)
    while level &lt; lastLevel:
        lastLevel -= 1
        lastVnode = lastVnode.parent()
        assert(lastVnode)
        assert(lastLevel &gt;= 0)
    v = lastVnode.insertAfter()
lastVnode = v
lastLevel = level
</t>
<t tx="ekr.20071102162910.640">j = 0
while g.match(s,j,'\t'):
    j += 1
if g.match(s,j,"+ ") or g.match(s,j,"- "):
    j += 2

v.initHeadString(s[j:])
</t>
<t tx="ekr.20071102162910.641">bodyLines = 0
index += 1 # Skip the headline.
while index &lt; len(strings):
    s = strings[index]
    level, junk = self.moreHeadlineLevel(s)
    level -= firstLevel
    if level &gt;= 0:
        break
    # Remove first backslash of the body line.
    if g.match(s,0,'\\'):
        strings[index] = s[1:]
    bodyLines += 1
    index += 1
</t>
<t tx="ekr.20071102162910.642">if bodyLines &gt; 0:
    body = ""
    n = index - bodyLines
    while n &lt; index:
        body += strings[n]
        if n != index - 1:
            body += "\n"
        n += 1
    v.setTnodeText(body)
</t>
<t tx="ekr.20071102162910.643">def importFlattenedOutline (self,files): # Not a command, so no event arg.

    c = self.c ; u = c.undoer ; current = c.currentPosition()
    if current == None: return
    if len(files) &lt; 1: return

    self.setEncoding()
    fileName = files[0] # files contains at most one file.
    g.setGlobalOpenDir(fileName)
    &lt;&lt; Read the file into array &gt;&gt;

    # Convert the string to an outline and insert it after the current node.
    undoData = u.beforeInsertNode(current)
    p = self.convertMoreStringsToOutlineAfter(array,current)
    if p:
        c.endEditing()
        c.validateOutline()
        c.editPosition(p)
        p.setDirty()
        c.setChanged(True)
        u.afterInsertNode(p,'Import',undoData)
    else:
        g.es(fileName + " is not a valid MORE file.")
</t>
<t tx="ekr.20071102162910.644">try:
    theFile = open(fileName)
    s = theFile.read()
    s = string.replace(s,"\r","")
    s = g.toUnicode(s,self.encoding)
    array = string.split(s,"\n")
    theFile.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return
</t>
<t tx="ekr.20071102162910.645"># return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel (self,s):

    level = 0 ; i = 0
    while g.match(s,i,'\t'):
        level += 1
        i += 1
    plusFlag = g.choose(g.match(s,i,"+"),True,False)
    if g.match(s,i,"+ ") or g.match(s,i,"- "):
        return level, plusFlag
    else:
        return -1, plusFlag
</t>
<t tx="ekr.20071102162910.646"># Used by paste logic.

def stringIsValidMoreFile (self,s):

    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.stringsAreValidMoreFile(strings)

def stringsAreValidMoreFile (self,strings):

    if len(strings) &lt; 1: return False
    level1, plusFlag = self.moreHeadlineLevel(strings[0])
    if level1 == -1: return False
    # Check the level of all headlines.
    i = 0 ; lastLevel = level1
    while i &lt; len(strings):
        s = strings[i] ; i += 1
        level, newFlag = self.moreHeadlineLevel(s)
        if level &gt; 0:
            if level &lt; level1 or level &gt; lastLevel + 1:
                return False # improper level.
            elif level &gt; lastLevel and not plusFlag:
                return False # parent of this node has no children.
            elif level == lastLevel and plusFlag:
                return False # last node has missing child.
            else:
                lastLevel = level
                plusFlag = newFlag
    return True
</t>
<t tx="ekr.20071102162910.647"></t>
<t tx="ekr.20071102162910.648">def createOutlineFromWeb (self,path,parent):

    c = self.c ; u = c.undoer
    junk,fileName = g.os_path_split(path)

    undoData = u.beforeInsertNode(parent)

    # Create the top-level headline.
    p = parent.insertAsLastChild()
    p.initHeadString(fileName)
    if self.webType=="cweb":
        c.setBodyString(p,"@ignore\n" + self.rootLine + "@language cweb")

    # Scan the file, creating one section for each function definition.
    self.scanWebFile(path,p)

    u.afterInsertNode(p,'Import',undoData)

    return p
</t>
<t tx="ekr.20071102162910.649">def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.webType = webType

    c.beginUpdate()
    try:
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutlineFromWeb(fileName,current)
            v.contract()
            v.setDirty()
            c.setChanged(True)
        c.selectVnode(current)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20071102162910.650">def findFunctionDef (self,s,i):

    # Look at the next non-blank line for a function name.
    i = g.skip_ws_and_nl(s,i)
    k = g.skip_line(s,i)
    name = None
    while i &lt; k:
        if g.is_c_id(s[i]):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
        elif s[i] == '(':
            if name: return name
            else: break
        else: i += 1
    return None
</t>
<t tx="ekr.20071102162910.651">@ This method returns the proper headline text.

1. If s contains a section def, return the section ref.
2. cweb only: if s contains @c, return the function name following the @c.
3. cweb only: if s contains @d name, returns @d name.
4. Otherwise, returns "@"
@c

def scanBodyForHeadline (self,s):

    if self.webType == "cweb":
        &lt;&lt; scan cweb body for headline &gt;&gt;
    else:
        &lt;&lt; scan noweb body for headline &gt;&gt;
    return "@" # default.
</t>
<t tx="ekr.20071102162910.652">i = 0
while i &lt; len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    # Allow constructs such as @ @c, or @ @&lt;.
    if self.isDocStart(s,i):
        i += 2 ; i = g.skip_ws(s,i)
    if g.match(s,i,"@d") or g.match(s,i,"@f"):
        # Look for a macro name.
        directive = s[i:i+2]
        i = g.skip_ws(s,i+2) # skip the @d or @f
        if i &lt; len(s) and g.is_c_id(s[i]):
            j = i ; g.skip_c_id(s,i) ; return s[j:i]
        else: return directive
    elif g.match(s,i,"@c") or g.match(s,i,"@p"):
        # Look for a function def.
        name = self.findFunctionDef(s,i+2)
        return g.choose(name,name,"outer function")
    elif g.match(s,i,"@&lt;"):
        # Look for a section def.
        # A small bug: the section def must end on this line.
        j = i ; k = g.find_on_line(s,i,"@&gt;")
        if k &gt; -1 and (g.match(s,k+2,"+=") or g.match(s,k+2,"=")):
            return s[j:k+2] # return the section ref.
    i = g.skip_line(s,i)
</t>
<t tx="ekr.20071102162910.653">i = 0
while i &lt; len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if g.match(s,i,"&lt;&lt;"):
        k = g.find_on_line(s,i,"&gt;&gt;=")
        if k &gt; -1:
            ref = s[i:k+2]
            name = string.strip(s[i+2:k])
            if name != "@others":
                return ref
    else:
        name = self.findFunctionDef(s,i)
        if name:
            return name
    i = g.skip_line(s,i)
</t>
<t tx="ekr.20071102162910.654">def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")

    try: # Read the file into s.
        f = open(fileName)
        s = f.read()
    except:
        g.es("Can not import " + fileName, color="blue")
        return

    &lt;&lt; Create a symbol table of all section names &gt;&gt;
    &lt;&lt; Create nodes for limbo text and the root section &gt;&gt;
    while i &lt; len(s):
        outer_progress = i
        &lt;&lt; Create a node for the next module &gt;&gt;
        assert(i &gt; outer_progress)</t>
<t tx="ekr.20071102162910.655">i = 0 ; self.web_st = []

while i &lt; len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if self.isDocStart(s,i):
        if theType == "cweb": i += 2
        else: i = g.skip_line(s,i)
    elif theType == "cweb" and g.match(s,i,"@@"):
        i += 2
    elif g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k &gt; -1: self.cstEnter(s[j:k])
    else: i += 1
    assert (i &gt; progress)

# g.trace(self.cstDump())
</t>
<t tx="ekr.20071102162910.656">i = 0
while i &lt; len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isModuleStart(s,i) or g.match(s,i,lb):
        break
    else: i = g.skip_line(s,i)
    assert(i &gt; progress)

j = g.skip_ws(s,0)
if j &lt; i:
    self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if g.match(s,i,lb):
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        else: i = g.skip_line(s,i)
        assert(i &gt; progress)
    self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

# g.trace(g.get_line(s,i))
</t>
<t tx="ekr.20071102162910.657">if theType=="cweb":
    assert(self.isModuleStart(s,i))
    start = i
    if self.isDocStart(s,i):
        i += 2
        while i &lt; len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i): break
            else: i = g.skip_line(s,i)
            assert (i &gt; progress)
    &lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;
else:
    assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
    start = i ; i = g.skip_line(s,i)
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i): break
        else: i = g.skip_line(s,i)
        assert (i &gt; progress)

body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20071102162910.658">if g.match(s,i,"@d") or g.match(s,i,"@f"):
    i += 2 ; i = g.skip_line(s,i)
    # Place all @d and @f directives in the same node.
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
        else: break
        assert (i &gt; progress)
    i = g.skip_ws_and_nl(s,i)

while i &lt; len(s) and not self.isModuleStart(s,i):
    progress = i
    i = g.skip_line(s,i)
    i = g.skip_ws_and_nl(s,i)
    assert (i &gt; progress)

if g.match(s,i,"@c") or g.match(s,i,"@p"):
    i += 2
    while i &lt; len(s):
        progress = i
        i = g.skip_line(s,i)
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        assert (i &gt; progress)
</t>
<t tx="ekr.20071102162910.659"></t>
<t tx="ekr.20071102162910.660"># We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.

def cstCanonicalize (self,s,lower=True):

    if lower:
        s = string.lower(s)
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"\r","")
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
</t>
<t tx="ekr.20071102162910.661">def cstDump (self):

    self.web_st.sort()
    s = "Web Symbol Table...\n\n"
    for name in self.web_st:
        s += name + "\n"
    return s
</t>
<t tx="ekr.20071102162910.662"># We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

    # Don't enter names that end in "..."
    s = string.rstrip(s)
    if s.endswith("..."): return

    # Put the section name in the symbol table, retaining capitalization.
    lower = self.cstCanonicalize(s,True)  # do lower
    upper = self.cstCanonicalize(s,False) # don't lower.
    for name in self.web_st:
        if string.lower(name) == lower:
            return
    self.web_st.append(upper)
</t>
<t tx="ekr.20071102162910.663"># This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):

    # Do nothing if the ... convention is not used.
    target = string.strip(target)
    if not target.endswith("..."): return target
    # Canonicalize the target name, and remove the trailing "..."
    ctarget = target[:-3]
    ctarget = self.cstCanonicalize(ctarget)
    ctarget = string.strip(ctarget)
    found = False ; result = target
    for s in self.web_st:
        cs = self.cstCanonicalize(s)
        if cs[:len(ctarget)] == ctarget:
            if found:
                g.es("****** " + target + ": is also a prefix of: " + s)
            else:
                found = True ; result = s
                # g.es("replacing: " + target + " with: " + s)
    return result
</t>
<t tx="ekr.20071102162910.664"># atAuto must be False for unit tests: otherwise the test gets wiped out.

def cUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest(p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.c')

def cSharpUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest(p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.c#')

def elispUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.el')

def htmlUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.htm')

def javaUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.java')

def javaScriptUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.js')

def pascalUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.pas')

def phpUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.php')

def pythonUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.py')

def textUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.txt')

def defaultImporterUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,ext='.xxx')
</t>
<t tx="ekr.20071102162910.665"></t>
<t tx="ekr.20071102162910.666"># This should have been done a long time ago.</t>
<t tx="ekr.20071102162910.667"># The threading colorizer must be run with interruptable=False when there are mutliple body editors.</t>
<t tx="ekr.20071102162910.668">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4585396
By: davidmcnab

I opened up 2 body editors today in Leo, each editing different nodes.

All was well, until I closed the top editor pane, and later noticed that Leo
had overwritten the top node's text with the bottom node.</t>
<t tx="ekr.20071102162910.669"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):

    '''Update Leo after the body has been changed.'''

    trace = False
    body = self ; c = self.c
    bodyCtrl = w = body.bodyCtrl
    p = c.currentPosition()
    insert = w.getInsertPoint()
    ch = g.choose(insert==0,'',w.get(insert-1))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = w.getAllText() # Note: getAllText converts to unicode.
    if trace: g.trace('w',w,'newText',repr(newText),g.callers())
    newSel = w.getSelectionRange()
    if not oldText:
        oldText = p.bodyString() ; changed = True
    else:
        changed = oldText != newText
    if trace: g.trace(repr(ch),'changed:',changed,'newText:',repr(newText))
    if not changed: return
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed: c.setChanged(True)
    self.updateEditors()
    &lt;&lt; redraw the screen if necessary &gt;&gt;
</t>
<t tx="ekr.20071102162910.670">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False

if g.app.unitTesting:
    g.app.unitTestDict['colorized'] = True
</t>
<t tx="ekr.20071102162910.671">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True

    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    # g.trace('new val:',val,'old val:',hasattr(p.v,'iconVal') and p.v.iconVal or '&lt;None&gt;')
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
</t>
<t tx="ekr.20071102162910.672"></t>
<t tx="ekr.20071102162910.673">def createEditorFrame (self,pane):

    f = Tk.Frame(pane)
    f.pack(side='top',expand=1,fill='both')
    return f
</t>
<t tx="ekr.20071102162910.674">def packEditorLabelWidget (self,w):

    '''Create a Tk label widget.'''

    if not hasattr(w,'leo_label') or not w.leo_label:
        # g.trace('w.leo_frame',id(w.leo_frame))
        w.pack_forget()
        w.leo_label = Tk.Label(w.leo_frame)
        w.leo_label.pack(side='top')
        w.pack(expand=1,fill='both')</t>
<t tx="ekr.20071102162910.675">def setEditorColors (self,bg,fg):

    c = self.c ; d = self.editorWidgets

    for key in d.keys():
        w2 = d.get(key)
        # g.trace(id(w2),bg,fg)
        try:
            w2.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
            pass
</t>
<t tx="ekr.20071102162910.676"># This code uses self.pb, a paned body widget, created by tkBody.finishCreate.


</t>
<t tx="ekr.20071102162910.677"></t>
<t tx="ekr.20071102162910.678">def addEditor (self,event=None):

    '''Add another editor to the body pane.'''

    c = self.c ; p = c.currentPosition()

    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1

    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        w_old = self.editorWidgets.get('1')
        self.updateInjectedIvars(w_old,p)
        self.selectLabel(w_old) # Immediately create the label in the old editor.

    name = '%d' % self.totalNumberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))

    f = self.createEditorFrame(pane)
    &lt;&lt; create text widget w &gt;&gt;
    self.editorWidgets[name] = w

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)

    self.pb.updatelayout()
    c.frame.body.bodyCtrl = w

    self.updateInjectedIvars(w,p)
    self.selectLabel(w)
    self.selectEditor(w)
    self.updateEditors()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20071102162910.679">w = self.createTextWidget(f,name=name,p=p)
w.delete(0,'end')
w.insert('end',p.bodyString())
w.see(0)

self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(p,w)</t>
<t tx="ekr.20071102162910.680">def cycleEditorFocus (self,event=None):

    '''Cycle keyboard focus between the body text editors.'''

    c = self.c ; d = self.editorWidgets ; w = c.frame.body.bodyCtrl
    values = d.values()
    if len(values) &gt; 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.selectEditor(w2)
        c.frame.body.bodyCtrl = w2
        # print '***',g.app.gui.widget_name(w2),id(w2)

    return 'break'
</t>
<t tx="ekr.20071102162910.681">def deleteEditor (self,event=None):

    '''Delete the presently selected body text editor.'''

    c = self.c ; w = c.frame.body.bodyCtrl ; d = self.editorWidgets

    if len(d.keys()) == 1: return

    name = w.leo_name

    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)

    # Select another editor.
    w = d.values()[0]
    # c.frame.body.bodyCtrl = w # Don't do this now?
    self.numberOfEditors -= 1
    self.selectEditor(w)
</t>
<t tx="ekr.20071102162910.682">def findEditorForChapter (self,chapter,p):

    '''Return an editor to be assigned to chapter.'''

    c = self.c ; d = self.editorWidgets ; values = d.values()

    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w,'leo_p') and w.leo_p and w.leo_p.equal(p)):
                # g.trace('***',id(w),'match chapter and p',p.headString())
                return w

    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
            # g.trace('***',id(w),'match only chapter',p.headString())
            return w

    # As a last resort, return the present editor widget.
    # g.trace('***',id(self.bodyCtrl),'no match',p.headString())
    return c.frame.body.bodyCtrl
</t>
<t tx="ekr.20071102162910.683">def unselectLabel (self,w):

    self.createChapterIvar(w)
    self.packEditorLabelWidget(w)
    s = self.computeLabel(w)
    w.leo_label.configure(text=s,bg='LightSteelBlue1')

def selectLabel (self,w):

    if self.numberOfEditors &gt; 1:
        self.createChapterIvar(w)
        self.packEditorLabelWidget(w)
        s = self.computeLabel(w)
        # g.trace(s,g.callers())
        w.leo_label.configure(text=s,bg='white')
    elif w.leo_label:
        w.leo_label.pack_forget()
        w.leo_label = None</t>
<t tx="ekr.20071102162910.684">selectEditorLockout = False

def selectEditor(self,w):

    '''Select editor w and node w.leo_p.'''

    #  Called by body.onClick and whenever w must be selected.
    trace = False
    c = self.c

    if self.selectEditorLockout:
        return

    if w and w == self.c.frame.body.bodyCtrl:
        if w.leo_p and w.leo_p != c.currentPosition():
            c.selectPosition(w.leo_p)
            c.bodyWantsFocusNow()
        return

    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(w)
    finally:
        self.selectEditorLockout = False

    return val # Don't put a return in a finally clause.
</t>
<t tx="ekr.20071102162910.685">def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    trace = False

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    if trace:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    self.inactivateActiveEditor(w)

    # The actual switch.
    c.frame.body.bodyCtrl = w
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return 'break'

    if trace:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    c.beginUpdate()
    try:
        # g.trace('expanding ancestors of ',w.leo_p.headString(),g.callers())
        c.frame.tree.expandAllAncestors(w.leo_p)
        c.selectPosition(w.leo_p,updateBeadList=True) # Calls assignPositionToEditor.
    finally:
        c.endUpdate()

    c.recolor_now()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'
</t>
<t tx="ekr.20071102162910.686"># g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)

if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20071102162910.687">def assignPositionToEditor (self,p):

    '''Called *only* from tree.select to select the present body editor.'''

    c = self.c ; cc = c.chapterController ; w = c.frame.body.bodyCtrl

    self.updateInjectedIvars(w,p)
    self.selectLabel(w)

    # g.trace('===',id(w),w.leo_chapter.name,w.leo_p.headString())
</t>
<t tx="ekr.20071102162910.688"># Called from addEditor and assignPositionToEditor

def updateEditors (self):

    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) &lt; 2: return # There is only the main widget.

    for key in d.keys():
        w = d.get(key)
        v = w.leo_v
        if v and v == p.v and w != c.frame.body.bodyCtrl:
            w.delete(0,'end')
            w.insert('end',p.bodyString())
            # g.trace('update',w,v)
            self.recolorWidget(p,w)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20071102162910.689"></t>
<t tx="ekr.20071102162910.690">def computeLabel (self,w):

    s = w.leo_label_s

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter.name,s)

    return s
</t>
<t tx="ekr.20071102162910.691">def createChapterIvar (self,w):

    c = self.c ; cc = c.chapterController

    if not hasattr(w,'leo_chapter') or not w.leo_chapter:
        if cc and self.use_chapters:
            w.leo_chapter = cc.getSelectedChapter()
        else:
            w.leo_chapter = None
</t>
<t tx="ekr.20071102162910.692">def ensurePositionExists(self,w):

    '''Return True if w.leo_p exists or can be reconstituted.'''

    c = self.c

    if c.positionExists(w.leo_p):
        return True
    else:
        g.trace('***** does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v and p2.v == w.leo_v:
                w.leo_p = p2.copy()
                return True
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            return False
</t>
<t tx="ekr.20071102162910.693">def inactivateActiveEditor(self,w):

    '''Inactivate the previously active editor.'''

    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d.keys():
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            # g.trace('inactivate',id(w2))
            return
</t>
<t tx="ekr.20071102162910.694">def recolorWidget (self,p,w):

    c = self.c ; old_w = c.frame.body.bodyCtrl

    # g.trace('w',id(w),p.headString(),len(w.getAllText()))

    # Save.
    c.frame.body.bodyCtrl = w
    try:
        # c.recolor_now(interruptable=False) # Force a complete recoloring.
        c.frame.body.colorizer.colorize(p,incremental=False,interruptable=False)
    finally:
        # Restore.
        c.frame.body.bodyCtrl = old_w
</t>
<t tx="ekr.20071102162910.695">def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            # g.trace('===','old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocusNow()
</t>
<t tx="ekr.20071102162910.696"># Called from addEditor and assignPositionToEditor.

def updateInjectedIvars (self,w,p):

    c = self.c ; cc = c.chapterController ; 

    if cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None

    w.leo_p = p.copy()
    w.leo_v = w.leo_p.v
    w.leo_label_s = p.headString()

    # g.trace('   ===', id(w),w.leo_chapter and w.leo_chapter.name,p.headString())
</t>
<t tx="ekr.20071102162910.697"># Crashes on wx
</t>
<t tx="ekr.20071102162910.698">if g.unitTesting:
    body = c.frame.body
    p2 = p.copy()
    body.addEditor()
    body.deleteEditor()
    assert c.currentPosition() == p2</t>
<t tx="ekr.20071102162910.699">if g.unitTesting:

    body = c.frame.body

    body.addEditor()

    # Select the leftmost editor.
    w = body.editorWidgets.get('1')
    body.selectEditor(w)

    # Delete the selected editor.
    body.deleteEditor()
</t>
<t tx="ekr.20071102162910.700"></t>
<t tx="ekr.20071102162910.701"></t>
<t tx="ekr.20071102162910.702">def getSelectionAreas (self):

    """Return before,sel,after where:

    before is the text before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is the text after the selected text
    (or the text after the insert point if no selection)"""

    body = self ; w = body.bodyCtrl
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if i == j: j = i + 1

    before = s[0:i]
    sel    = s[i:j]
    after  = s[j:]

    before = g.toUnicode(before,g.app.tkEncoding)
    sel    = g.toUnicode(sel,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)
    return before,sel,after</t>
<t tx="ekr.20071102162910.703"># line 1
# line 2
# line 3
if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        s = w.getAllText()
        start,end = 11,15
        w.setSelectionRange(start,end)
        before,ins,after = c.frame.body.getSelectionAreas()
        assert before == s[0:start],'Got %s' % repr(before)
        assert ins    == s[start:end],'Got %s' % repr(ins)
        assert after == s[end:]
    finally:
        c.endUpdate(False)
# end.</t>
<t tx="ekr.20071102162910.704">def getInsertLines (self):

    """Return before,after where:

    before is all the lines before the line containing the insert point.
    sel is the line containing the insert point.
    after is all the lines after the line containing the insert point.

    All lines end in a newline, except possibly the last line."""

    body = self ; w = body.bodyCtrl
    s = w.getAllText()
    insert = w.getInsertPoint()
    i,j = g.getLine(s,insert)
    before = s[0:i]
    ins = s[i:j]
    after = s[j:]

    before = g.toUnicode(before,g.app.tkEncoding)
    ins    = g.toUnicode(ins,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)

    return before,ins,after
</t>
<t tx="ekr.20071102162910.705"># line 1
# line 2
# line 3
if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        index = 11 # in the second line.
        w.setInsertPoint(index)
        before,ins,after = c.frame.body.getInsertLines()
        assert before == '# line 1\n','Got %s' % repr(before)
        assert ins    == '# line 2\n','Got %s' % repr(ins)
        assert after.startswith('# line 3\n')
        assert after.endswith('# end.')
    finally:
        c.endUpdate(False)
# end.</t>
<t tx="ekr.20071102162910.706">def getSelectionLines (self):

    """Return before,sel,after where:

    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)"""

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return '','',''

    # At present, called only by c.getBodyLines.
    body = self ; w = body.bodyCtrl
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if i == j:
        i,j = g.getLine(s,i)
    else:
        i,junk = g.getLine(s,i)
        junk,j = g.getLine(s,j)


    before = g.toUnicode(s[0:i],g.app.tkEncoding)
    sel    = g.toUnicode(s[i:j],g.app.tkEncoding)
    after  = g.toUnicode(s[j:len(s)],g.app.tkEncoding)

    # g.trace(i,j,'sel',repr(s[i:j]),'after',repr(after))
    return before,sel,after # 3 strings.
</t>
<t tx="ekr.20071102162910.707">def setSelectionAreas (self,before,sel,after):

    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    body = self ; w = body.bodyCtrl
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0,len(s))
    w.insert(0,before+sel+after)
    i = len(before)
    j = max(i,len(before)+len(sel)-1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i,j,insert=j)
    return i,j
</t>
<t tx="ekr.20071102162910.708">def OnHyperLinkControlClick (self,event=None,c=c):

    """Callback injected into position class."""

    p = self
    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            c.frame.body.bodyCtrl.setInsertPoint(0) # 2007/10/27
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
</t>
<t tx="ekr.20071102162910.709">def OnHyperLinkEnter (self,event=None,c=c):

    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperenter1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.body.bodyCtrl.tag_config(p.tagName,background="green") # 10/27/07
        g.doHook("hyperenter2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperenter")
</t>
<t tx="ekr.20071102162910.710">def OnHyperLinkLeave (self,event=None,c=c):

    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperleave1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.body.bodyCtrl.tag_config(p.tagName,background="white") # 2007/20/25

        g.doHook("hyperleave2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperleave")
</t>
<t tx="ekr.20071102162910.711">def finishCreate(self,c):

    self.c = c

    # print 'nullFrame'

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)

    c.setLog()

    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)


</t>
<t tx="ekr.20071102162910.712">def createSplitterComponents (self):

    f = self ; c = f.c

    g.trace()

    f.createLeoSplitters(f.outerFrame)

    if 0:
        # Create the canvas, tree, log and body.
        if f.use_chapters:
            c.chapterController = cc = leoChapters.chapterController(c)

        if self.use_chapters and self.use_chapter_tabs:
            cc.tt = leoSwingTreeTab(c,f.split2Pane1,cc)

        f.canvas = f.createCanvas(f.split2Pane1)
        f.tree   = leoSwingTree.leoSwingTree(c,f,f.canvas)
        f.log    = leoSwingLog(f,f.split2Pane2)
        f.body   = leoSwingBody(f,f.split1Pane2)

    f.body = leoSwingBody(f,f.top)
    f.tree = leoSwingTree(c,f,f.top)
    f.log  = leoSwingLog(f,f.top)

    # Configure.
    f.setTabWidth(c.tab_width)
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
</t>
<t tx="ekr.20071102162910.713">def toggleActivePane (self,event=None):

    '''Toggle the focus between the outline and body panes.'''

    frame = self ; c = frame.c

    if c.get_focus() == frame.body.bodyCtrl: # 2007:10/25
        c.treeWantsFocusNow()
    else:
        c.endEditing()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20071102162910.714"># "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
# self.treeBar = None # Replaced by injected frame.canvas.leo_treeBar.

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
</t>
<t tx="ekr.20071102162910.715">def createSplitterComponents (self):

    f = self ; c = f.c

    # Create the canvas, tree, log and body.
    if f.use_chapters:
        c.chapterController = cc = leoChapters.chapterController(c)

    # split1.pane1 is the secondary splitter.

    if self.bigTree: # Put outline in the main splitter.
        if self.use_chapters and self.use_chapter_tabs:
            cc.tt = leoTkinterTreeTab(c,f.split1Pane2,cc)
        f.canvas = f.createCanvas(f.split1Pane1)
        f.tree  = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
        f.log   = leoTkinterLog(f,f.split2Pane2)
        f.body  = leoTkinterBody(f,f.split2Pane1)
    else:
        if self.use_chapters and self.use_chapter_tabs:
            cc.tt = leoTkinterTreeTab(c,f.split2Pane1,cc)
        f.canvas = f.createCanvas(f.split2Pane1)
        f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
        f.log    = leoTkinterLog(f,f.split2Pane2)
        f.body   = leoTkinterBody(f,f.split1Pane2)

    # Yes, this an "official" ivar: this is a kludge.
    # f.bodyCtrl = f.body.bodyCtrl

    # Configure.
    f.setTabWidth(c.tab_width)
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
</t>
<t tx="ekr.20071102162910.716">def setTabWidth (self, w):

    try: # This can fail when called from scripts
        # Use the present font for computations.
        font = self.body.bodyCtrl.cget("font") # 2007/10/27
        root = g.app.root # 4/3/03: must specify root so idle window will work properly.
        font = tkFont.Font(root=root,font=font)
        tabw = font.measure(" " * abs(w)) # 7/2/02
        self.body.bodyCtrl.configure(tabs=tabw)
        self.tab_width = w
        # g.trace(w,tabw)
    except:
        g.es_exception()
        pass
</t>
<t tx="ekr.20071102162910.717">def setWrap (self,p):

    c = self.c
    theDict = g.scanDirectives(c,p)
    if not theDict: return

    wrap = theDict.get("wrap")
    if self.body.wrapState == wrap: return

    self.body.wrapState = wrap
    w = self.body.bodyCtrl

    # g.trace(wrap)
    if wrap:
        w.configure(wrap="word") # 2007/10/25
        w.leo_bodyXBar.pack_forget() # 2007/10/31
    else:
        w.configure(wrap="none")
        # Bug fix: 3/10/05: We must unpack the text area to make the scrollbar visible.
        w.pack_forget()  # 2007/10/25
        w.leo_bodyXBar.pack(side="bottom", fill="x") # 2007/10/31
        w.pack(expand=1,fill="both")  # 2007/10/25
</t>
<t tx="ekr.20071102162910.718">def reconfigurePanes (self):

    c = self.c

    border = c.config.getInt('additional_body_text_border')
    if border == None: border = 0

    # The body pane needs a _much_ bigger border when tiling horizontally.
    border = g.choose(self.splitVerticalFlag,2+border,6+border)
    self.body.bodyCtrl.configure(bd=border) # 2007/10/25

    # The log pane needs a slightly bigger border when tiling vertically.
    border = g.choose(self.splitVerticalFlag,4,2) 
    self.log.configureBorder(border)
</t>
<t tx="ekr.20071102162910.719">def OnActivateBody (self,event=None):

    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; c = frame.c
        c.setLog()
        w = c.get_focus()
        if w != c.frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        c.bodyWantsFocus()
    except:
        g.es_event_exception("activate body")

    return 'break'
</t>
<t tx="ekr.20071102162910.720">def toggleActivePane (self,event=None):

    '''Toggle the focus between the outline and body panes.'''

    frame = self ; c = frame.c

    if c.get_focus() == frame.body.bodyCtrl: # 2007/10/25
        c.treeWantsFocusNow()
    else:
        c.endEditing()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20071102162910.721">def bringToFront (self):
    # g.trace(g.callers())
    self.top.deiconify()
    self.top.lift()

def getFocus(self):
    """Returns the widget that has focus, or body if None."""
    try:
        # This method is unreliable while focus is changing.
        # The call to update_idletasks may help.  Or not.
        self.top.update_idletasks()
        f = self.top.focus_displayof()
    except Exception:
        f = None
    if f:
        return f
    else:
        return self.body.bodyCtrl # 2007/10/25

def getTitle (self):
    return self.top.title()

def setTitle (self,title):
    return self.top.title(title)

def get_window_info(self):
    return g.app.gui.get_window_info(self.top)

def iconify(self):
    self.top.iconify()

def deiconify (self):
    self.top.deiconify()

def lift (self):
    self.top.lift()

def update (self):
    self.top.update()
</t>
<t tx="ekr.20071102162910.722"></t>
<t tx="ekr.20071102162910.723"></t>
<t tx="ekr.20071102162910.724"># The hack in putNewTags that converted j to 'end' had an off-by-one error.</t>
<t tx="ekr.20071102162910.725"></t>
<t tx="ekr.20071102162910.726">class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c):

        # g.trace('leoKeyEvent(leoGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        self.widget = self.w

    def __repr__ (self):

        return 'leoGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))</t>
<t tx="ekr.20071102162910.727">class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c):

        # g.trace('leoKeyEvent(tkGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        self.widget = self.w

    def __repr__ (self):

        return 'tkGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))</t>
<t tx="ekr.20071102162910.728">class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c):

        # g.trace('leoKeyEvent(swingGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        self.widget = self.w

    def __repr__ (self):

        return 'swingGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))</t>
<t tx="ekr.20071102162910.729"></t>
<t tx="ekr.20071102162910.730">def drawUserIcon (self,p,where,x,y,w2,theDict):

    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # if self.trace_gc: g.printNewObjects(tag='userIcon 1')

    # g.trace(where,x,y,theDict)

    &lt;&lt; set offsets and pads &gt;&gt;
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            &lt;&lt; draw the icon in string s &gt;&gt;
    elif theType == "file":
        theFile = theDict.get("file")
        &lt;&lt; draw the icon at file &gt;&gt;
    elif theType == "url":
        ## url = theDict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;

    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    # if self.trace_gc: g.printNewObjects(tag='userIcon 2')

    return h,w
</t>
<t tx="ekr.20071102162910.731">xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
</t>
<t tx="ekr.20071102162910.732">pass
</t>
<t tx="ekr.20071102162910.733">fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
fullname = g.os_path_normpath(fullname)

# Bug fix: the key must include distinguish nodes.
key = (fullname,p.v.t)
image = self.iconimages.get(key)

if not image:
    try:
        from PIL import Image, ImageTk
        image1 = Image.open(fullname)
        image = ImageTk.PhotoImage(image1)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if not image:
    try:
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p.copy()
    # g.trace('id',theId,p.headString(),theFile,image)

    # assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad
</t>
<t tx="ekr.20071102162910.734">pass
</t>
<t tx="ekr.20071102162910.735"></t>
<t tx="ekr.20071102162910.736">@ The reason toggle-split-direction is relatively easy is that no parents change, only the placements.

In contrast, the bigTree option requires reparenting, which is much harder in Tk.</t>
<t tx="ekr.20071102162910.737">@nocolor

I changed createSplitterComponents.

Here's a diff, which gives me a ":o" arrangement, which suits me fine.   Obviously,
inclusion in released code would need to make this dependent on an option.

--- -  2007-10-18 14:07:47.799553726 -0400
+++ leoTkinterFrame.py  2007-10-18 13:58:24.000000000 -0400
@@ -495,12 +495,12 @@
@color

        c.chapterController = cc = leoChapters.chapterController(c)

        if self.use_chapters and self.use_chapter_tabs:
-            cc.tt = leoTkinterTreeTab(c,f.split2Pane1,cc)
+            cc.tt = leoTkinterTreeTab(c,f.split1Pane2,cc)

-        f.canvas = f.createCanvas(f.split2Pane1)
+        f.canvas = f.createCanvas(f.split1Pane2)
        f.tree  = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
        f.log    = leoTkinterLog(f,f.split2Pane2)
-        f.body  = leoTkinterBody(f,f.split1Pane2)
+        f.body  = leoTkinterBody(f,f.split2Pane1)

        # Yes, this an "official" ivar: this is a kludge.
        f.bodyCtrl = f.body.bodyCtrl</t>
<t tx="ekr.20071102162910.738">def finishCreate (self,c):

    f = self ; f.c = c
    # g.trace('tkFrame','c',c,g.callers())

    self.bigTree           = c.config.getBool('big_outline_pane')
    self.trace_status_line = c.config.getBool('trace_status_line')
    self.use_chapters      = c.config.getBool('use_chapters')
    self.use_chapter_tabs  = c.config.getBool('use_chapter_tabs')

    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBar()
    f.createLeoSplitters(f.outerFrame)
    f.createSplitterComponents()
    f.createStatusLine()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()

    # f.enableTclTraces()
</t>
<t tx="ekr.20071102162910.739">def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.

    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)

    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("&lt;Button-1&gt;", f.OnActivateLeoEvent)

    f.top.bind("&lt;Control-KeyPress&gt;",f.OnControlKeyDown)
    f.top.bind("&lt;Control-KeyRelease&gt;",f.OnControlKeyUp)

    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    # f.top.bind("&lt;Activate&gt;",f.OnActivateLeoEvent)
    # f.top.bind("&lt;Deactivate&gt;",f.OnDeactivateLeoEvent)

    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")</t>
<t tx="ekr.20071102162910.740">def createFirstTreeNode (self):

    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot(oldRoot=None)
    c.setRootPosition(p) # New in 4.4.2.
    c.editPosition(p)
</t>
<t tx="ekr.20071102162910.741">def enableTclTraces (self):

    c = self.c
    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("&lt;FocusIn&gt;")
    # c.frame.bar1.unbind_all("&lt;FocusOut&gt;")

    # Any widget would do:
    w = c.frame.bar1
    if True:
        def focusIn (event):
            print("Focus in  %s (%s)" % (
                event.widget,event.widget.winfo_class()))

        def focusOut (event):
            print("Focus out %s (%s)" % (
                event.widget,event.widget.winfo_class()))

        w.bind_all("&lt;FocusIn&gt;", focusIn)
        w.bind_all("&lt;FocusOut&gt;", focusOut)
    else:
        def tracewidget(event):
            g.trace('enabling widget trace')
            Pmw.tracetk(event.widget, 1)

        def untracewidget(event):
            g.trace('disabling widget trace')
            Pmw.tracetk(event.widget,0)

        w.bind_all("&lt;Control-1&gt;", tracewidget)
        w.bind_all("&lt;Control-Shift-1&gt;", untracewidget)
</t>
<t tx="ekr.20071102162910.742">@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these
invariants. So most of this code is specialized for Leo's window. OTOH, creating
a single splitter window would be much easier than this code.
@c

def createLeoSplitters (self,parentFrame):

    # Splitter 1 is the main splitter.
    f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
        parentFrame,self.splitVerticalFlag,'splitter1')

    self.f1,self.bar1 = f1,bar1
    self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

    # ** new **
    split2parent = g.choose(self.bigTree,split1Pane2,split1Pane1)

    # Splitter 2 is the secondary splitter.
    f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
        # split1Pane1,not self.splitVerticalFlag,'splitter2')
        split2parent,not self.splitVerticalFlag,'splitter2')

    self.f2,self.bar2 = f2,bar2
    self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
</t>
<t tx="ekr.20071102162910.743">def createLeoTkSplitter (self,parent,verticalFlag,componentName):

    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)

    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)

    return f, bar, f1, f2</t>
<t tx="ekr.20071102162910.744">def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("&lt;B1-Motion&gt;", self.onDragMainSplitBar)

    else:
        bar.bind("&lt;B1-Motion&gt;", self.onDragSecondarySplitBar)
</t>
<t tx="ekr.20071102162910.745"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    # if self.bigTree:
        # pane1,pane2 = pane2,pane1

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
</t>
<t tx="ekr.20071102162910.746"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="ekr.20071102162910.747">def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot = top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax = top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot = top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax = top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset &lt; 3: offset = 3
    if offset &gt; wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
</t>
<t tx="ekr.20071102162910.748">def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    # if self.bigTree:
        # pane1,pane2 = pane2,pane1

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
</t>
<t tx="ekr.20071102162910.749"># Just put the following in your siteCustomize.py.
# (You can't call sys.setdefaultencoding after Python starts up).

import sys

sys.setdefaultencoding('utf-8')</t>
<t tx="ekr.20071102162910.750">@nocolor

Surely I must be the very last experienced programmer to figure this out :-)  Oh well, better late than never...

Last week I realized that I have been stupidly putting up with quite an annoyance: Python will throw an exception if it is passed a string that can't be converted to Python's default encoding, which is typically 'ascii'.

Today I thought to google for a solution. Clearly one was likely: Python handles unicode pretty well in most places.  I immediately found 

http://www.diveintopython.org/xml_processing/unicode.html

To change Python's default encoding, just put the following in your sitecustomize.py file (in Python's Lib folder:

import sys

sys.setdefaultencoding('utf-8')

You must restart Python after doing this.  For reasons I don't understand, sys.setdefaultencoding can not be called after Python starts up.

Cvs now contains a version of g.es_print that attempts to convert incoming arguments to unicode using the default encoding. With this change in place, the following Leo script always prints La Peña:

@first # -*- coding: utf-8 -*-

for s in (
    '---',
    u'La Pe\xf1a',
    'La Peña', # print gives "byte hash"
    u'La Peña',
):
    print s
    g.es_print(s)

BTW, the first line is required on Python 2.5.

Coming soon: a FAQ entry :-)

Edward
</t>
<t tx="ekr.20071102162910.751"></t>
<t tx="ekr.20071102162910.752"># The tree widget will use PIL if available.</t>
<t tx="ekr.20071102162910.753"></t>
<t tx="ekr.20071102162910.754">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4591494
By: rogererens

This had probably to do with the RClick plugin that was enabled in mySettings.leo.
This was the traceback:

Traceback (most recent call last):

  File "E:\_cvs_\Leo\src\leoGlobals.py", line 2575, in doHook
    return f(tag,keywords)

  File "E:\_cvs_\Leo\src\leoPlugins.py", line 91, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "E:\_cvs_\Leo\src\leoPlugins.py", line 70, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "E:\_cvs_\Leo\src\leoPlugins.py", line 49, in callTagHandler
    result = handler(tag,keywords)

  File "E:\_cvs_\Leo\plugins\rClick.py", line 77, in rClickbinder
    c.frame.log.logCtrl.bind('&lt;Button-3&gt;',c.frame.OnBodyRClick)

AttributeError: nullFrame instance has no attribute 'OnBodyRClick'

Disabling RClick gives me the Plugins menu everywhere.

@color</t>
<t tx="ekr.20071102162910.755">def OnBodyClick (self,event=None):
   pass

def OnBodyRClick(self,event=None):
    pass</t>
<t tx="ekr.20071102162910.756">@nocolor

From Terry Brown

I find that if I'm viewing a chapter and insert a node the inserted
selected 'Newheadline' scrolls out of view, although it retains focus
for typing.  Doesn't seem to do this when not viewing chapters.
Probably requires that the tree has more nodes than will fit vertically
in the display before you can see the effect.  Inserting near the top
of the list, the view jumps down the list for some reason.

@color</t>
<t tx="ekr.20071102162910.757">def select (self,w=None,selectEditor=True):

    '''Restore chapter information and redraw the tree when a chapter is selected.'''

    if self.selectLockout: return

    try:
        self.selectLockout = True
        self.chapterSelectHelper(w,selectEditor)
        if self.cc.tt:
            self.cc.tt.setTabLabel(self.name)
    finally:
        self.selectLockout = False
</t>
<t tx="ekr.20071102162910.758">def chapterSelectHelper (self,w=None,selectEditor=True):

    c = self.c ; cc = self.cc ; name = self.name

    # g.trace(name,'self.p',self.p) # ,'self.root',self.root) # 'w.leo_p',w and w.leo_p)

    cc.selectedChapter = self

    # Next, recompute p and possibly select a new editor.
    if w:
        assert w == c.frame.body.bodyCtrl
        assert w.leo_p
        # g.trace(name,'w.leo_p',w.leo_p,'p',p)
        self.p = p = self.findPositionInChapter(w.leo_p)
        if p != w.leo_p: g.trace('****** can not happen: lost p',w.leo_p)
    else:
        # This must be done *after* switching roots.
        target_p = self.p or self.root.firstChild() or self.root
        #g.trace(name,'target_p',target_p)
        #g.trace(name,'self.p',self.p,'self.root',self.root)
        self.p = p = self.findPositionInChapter(target_p)
        if selectEditor:
            w = self.findEditorInChapter(p)
            c.frame.body.selectEditor(w) # Switches text.

    c.beginUpdate()
    try:
        if name == 'main' and cc.chaptersNode:
            cc.chaptersNode.contract()    
        c.hoistStack = self.hoistStack[:]
        c.selectPosition(p)
    finally:
        c.endUpdate()
        g.doHook('hoist-changed',c=c)
        c.bodyWantsFocusNow()</t>
<t tx="ekr.20071102162910.759">def findPositionInChapter (self,p1,strict=False):

    '''Return a valid position p such that p.v == v.'''

    # Do nothing if the present position is in the proper chapter.
    c = self.c ; name = self.name 

    root = g.choose(self.name=='main',c.rootPosition(),self.root)
    # g.trace('p1',p1)
    if p1 and c.positionExists(p1,root=root):
        # g.trace('using existing position',p)
        return p1

    if name == 'main':
        for p in self.c.allNodes_iter():
            if p.v == p1.v:
                # g.trace('*** found in main chapter',p)
                self.p = p.copy()
                return self.p
        if strict:
            return None
        else:
            self.p = c.rootPosition()
    else:
        for p in self.root.self_and_subtree_iter():
            # g.trace('testing',p,p1)
            if p.v == p1.v:
                # g.trace('*** found in chapter',p)
                self.p = p.copy()
                return self.p
        if strict:
            return None
        else:
            self.p = self.root.copy()

    if 0:
        self.error('***** chapter: %s findPositionInChapter: lost %s' % (
            self.name,p1.v.t.headString))
        g.trace(g.callers())

    return self.p.copy()
</t>
<t tx="ekr.20071102162910.760">def findEditorInChapter (self,p):

    '''return w, an editor displaying position p.'''

    chapter = self ; c = self.c

    w = c.frame.body.findEditorForChapter(chapter,p)
    w.leo_chapter = chapter
    w.leo_p = p and p.copy()
    return w</t>
<t tx="ekr.20071102162910.761">def positionIsInChapter (self,p):

    p2 = self.findPositionInChapter (p,strict=True)

    # g.trace(self.name,'returns',p2)
    return p2</t>
<t tx="ekr.20071102162910.762">def rename (self,newName):

    p = self.root
    s = '@chapter ' + newName
    p.setHeadString(s)
</t>
<t tx="ekr.20071102162910.763"># New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    '''Redraw immediately: used by Find so a redraw doesn't mess up selections in headlines.'''

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return

    c = self.c

    # g.trace('scroll',scroll,g.callers())

    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary()
        if self.trace_redraw or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            # g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()

    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll)
    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()

redraw = redraw_now # Compatibility
</t>
<t tx="ekr.20071102162910.764">def redrawHelper (self,scroll=True):

    c = self.c ; trace = False
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):

        if trace: g.trace('scroll',scroll,g.callers())
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        # g.trace('canvas',self.canvas,'bbox',bbox)
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
</t>
<t tx="ekr.20071102162910.765">def dehoist (self,event=None):

    '''Undo a previous hoist of an outline.'''

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        c.beginUpdate()
        try:
            if bunch.expanded: p.expand()
            else:              p.contract()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')
        g.doHook('hoist-changed',c=c)

def hoist (self,event=None):

    '''Make only the selected outline visible.'''

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        c.beginUpdate()
        try:
            p.expand()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')
        g.doHook('hoist-changed',c=c)
</t>
<t tx="ekr.20071102162910.766">def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""

    __pychecker__ = '--no-argsused' # event not used.
    __pychecker__ = '--no-intdivide' # suppress warning about integer division.

    c = self.c ; frame = c.frame ; trace = False
    if not p or not c.positionExists(p):
        p = c.currentPosition()
    if not p or not c.positionExists(p):
        if trace: g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not c.positionExists(p):
        if trace: g.trace('no position')
        return
    try:
        h1 = self.yoffset(p)
        if self.center_selected_tree_node: # New in Leo 4.4.3.
            &lt;&lt; compute frac0 &gt;&gt;
            delta = abs(self.prevMoveToFrac-frac0)
            # g.trace(delta)
            if delta &gt; 0.0:
                self.prevMoveToFrac = frac0
                self.canvas.yview("moveto",frac0)
                if trace: g.trace("frac0 %1.2f %3d %3d %3d" % (frac0,h1,htot,wtot))
        else:
            last = c.lastVisible()
            nextToLast = last.visBack(c)
            h2 = self.yoffset(last)
            &lt;&lt; compute approximate line height &gt;&gt;
            &lt;&lt; Compute the fractions to scroll down/up &gt;&gt;
            if frac &lt;= lo: # frac is for scrolling down.
                if self.prevMoveToFrac != frac:
                    self.prevMoveToFrac = frac
                    self.canvas.yview("moveto",frac)
                    if trace: g.trace("frac  %1.2f %3d %3d %1.2f %1.2f" % (frac, h1,h2,lo,hi))
            elif frac2 + (hi - lo) &gt;= hi: # frac2 is for scrolling up.
                if self.prevMoveToFrac != frac2:
                    self.prevMoveToFrac = frac2
                    self.canvas.yview("moveto",frac2)
                    if trace: g.trace("frac2 %1.2f %3d %3d %1.2f %1.2f" % (frac2,h1,h2,lo,hi))

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)

        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.

    except:
        g.es_exception()

idle_scrollTo = scrollTo # For compatibility.</t>
<t tx="ekr.20071102162910.767"># frac0 attempt to put the 
scrollRegion = self.canvas.cget('scrollregion')
geom = self.canvas.winfo_geometry()

if scrollRegion and geom:
    scrollRegion = scrollRegion.split(' ')
    # g.trace('scrollRegion',repr(scrollRegion))
    htot = int(scrollRegion[3])
    wh,junk,junk = geom.split('+')
    junk,h = wh.split('x')
    if h: wtot = int(h)
    else: wtot = 500
    # g.trace('geom',geom,'wtot',wtot)
    if htot &gt; 0.1:
        frac0 = float(h1-wtot/2)/float(htot)
        frac0 = max(min(frac0,1.0),0.0)
    else:
        frac0 = 0.0
else:
    frac0 = 0.0 ; htot = wtot = 0
</t>
<t tx="ekr.20071102162910.768">if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
</t>
<t tx="ekr.20071102162910.769">data = frame.canvas.leo_treeBar.get() # Get the previous values of the scrollbar.
try: lo, hi = data
except: lo,hi = 0.0,1.0

# h1 and h2 are the y offsets of the present and last nodes.
if h2 &gt; 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.

frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)</t>
<t tx="ekr.20071102162910.770">@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    c = self.c
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        root = bunch.p.copy()
    else:
        root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1,isTop=True)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1,isTop):
    c = self.c ; h = 0 ; trace = False ; verbose = False
    if not c.positionExists(p):
        if trace: g.trace('does not exist',p.headString())
        return h,False # An extra precaution.
    p = p.copy()
    if trace and verbose and isTop and c.hoistStack:
        g.trace('c.hoistStack',c.hoistStack[-1].p.headString())
    if isTop and c.hoistStack: theIter = [p.firstChild()]
    else: theIter = p.self_and_siblings_iter() # Bug fix 10/27/07: was p.siblings_iter()
    for p2 in theIter: 
        if p2 == p1:
            if trace and verbose: g.trace(h,p1.headString())
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1,isTop=False)
            h += h2
            if flag:
                if trace and verbose: g.trace(h,p1.headString())
                return h, True

    if trace: g.trace('not found',p1.headString())
    return h, False
</t>
<t tx="ekr.20071102162910.771">@ 
The fix doesn't actually remember which chapter was previously selected; it
picks some chapter containing the initially selected node. This works exactly
for non-cloned nodes, but can select the 'wrong' chapter for cloned nodes.
Still, this is a big improvement over the previous code, which would not select
any node if the selected node was not in the main chapters.</t>
<t tx="ekr.20071102162910.772">tree_select_lockout = False

def select (self,p,updateBeadList=True,scroll=True):

    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        val = 'break'
        self.tree_select_lockout = True
        val = self.treeSelectHelper(p,updateBeadList,scroll)
    finally:
        self.tree_select_lockout = False

    return val  # Don't put a return in a finally clause.
</t>
<t tx="ekr.20071102162910.773">def selectChapterForPosition (self,p):

    '''
    Select a chapter containing position p.
    Do nothing if p if p does not exist or is in the presently selected chapter.
    '''
    cc = self ; c = cc.c

    if not p or not c.positionExists(p):
        return

    theChapter = cc.getSelectedChapter()
    if not theChapter: return

    # g.trace('selected:',theChapter.name)
    # First, try the presently selected chapter.
    firstName = theChapter.name
    if firstName == 'main' or theChapter.positionIsInChapter(p):
        return # Bug fix: 7/2/07. All position are in the main chapter.

    for name in cc.chaptersDict.keys():
        if name not in (firstName,'main'):
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                cc.selectChapterByName(name)
                return
    else:
        cc.selectChapterByName('main')
</t>
<t tx="ekr.20071102162910.774">def findChapterNameForPosition (self,p):

    '''
    Return the name of a chapter containing p or None if p does not exist.
    '''
    cc = self ; c = cc.c

    if not p or not c.positionExists(p):
        return None

    for name in cc.chaptersDict.keys():
        if name != 'main':
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                return name
    else:
        return 'main'
</t>
<t tx="ekr.20071102162910.775">def finishCreate (self):

    '''Find or make the @chapters and @chapter trash nodes.'''

    # This must be called late in the init process:
    # at present, called by g.openWithFileName and c.new.

    cc = self ; c = cc.c

    # Create the @chapters node if needed, and set cc.chaptersNode.
    if not cc.chaptersNode and not cc.findChaptersNode():
        cc.createChaptersNode()

    # Create the main chapter
    cc.chaptersDict['main'] = chapter(c=c,chapterController=cc,name='main',root=c.rootPosition())

    tag = '@chapter'
    for p in c.allNodes_iter():
        h = p.headString()
        if h.startswith(tag) and not h.startswith('@chapters'):
            tabName = h[len(tag):].strip()
            if tabName and tabName not in ('main',):
                if cc.chaptersDict.get(tabName):
                    self.error('duplicate chapter name: %s' % tabName)
                else:
                    cc.chaptersDict[tabName] = chapter(c=c,chapterController=cc,name=tabName,root=p)

    p = c.currentPosition()
    # g.trace(c.positionExists(p),p)
    if c.positionExists(p):
        name = cc.findChapterNameForPosition(p) or 'main'
        # g.trace('chapterController',name,c.currentPosition())
        cc.selectChapterByName(name)
    else:
        cc.selectChapterByName('main')
</t>
<t tx="ekr.20071102162910.776"></t>
<t tx="ekr.20071102162910.777">def getMacHelpMenu (self,table):

    defaultTable = [
            # &amp;: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
            ('&amp;About Leo...',           'about-leo'),
            ('Online &amp;Home Page',       'open-online-home'),
            '*open-online-&amp;tutorial',
            '*open-&amp;users-guide',
            '-',
            ('Open Leo&amp;Docs.leo',       'open-leoDocs-leo'),
            ('Open Leo&amp;Plugins.leo',    'open-leoPlugins-leo'),
            ('Open Leo&amp;Settings.leo',   'open-leoSettings-leo'),
            ('Open &amp;myLeoSettings.leo', 'open-myLeoSettings-leo'),
            ('Open scr&amp;ipts.leo',       'open-scripts-leo'),
            '-',
            '*he&amp;lp-for-minibuffer',
            '*help-for-&amp;command',
            '-',
            '*&amp;apropos-autocompletion',
            '*apropos-&amp;bindings',
            '*apropos-&amp;debugging-commands',
            '*apropos-&amp;find-commands',
            '-',
            '*pri&amp;nt-bindings',
            '*print-c&amp;ommands',
        ]

    try:
        topMenu = self.getMenu('top')
        # Use the name argument to create the special Macintosh Help menu.
        helpMenu = Tk.Menu(topMenu,name='help',tearoff=0)
        self.add_cascade(topMenu,label='Help',menu=helpMenu,underline=0)
        self.createMenuEntries(helpMenu,table or defaultTable)
        return helpMenu

    except Exception:
        g.trace('Can not get MacOS Help menu')
        g.es_exception()
        return None</t>
<t tx="ekr.20071102162910.778">@

It is too confusing at present, because it doesn't support @enabled-plugins nodes.
</t>
<t tx="ekr.20071102162910.779"></t>
<t tx="ekr.20071102162910.780"></t>
<t tx="ekr.20071102162910.781">@nocolor

http://sourceforge.net/forum/forum.php?thread_id=1853660&amp;forum_id=10228

By: Terry Brown (terry_n_brown) - 2007-10-25 09:35

current CVS, ubuntu linux 

- when I click the correct word in the list the wrong word in the body text loses its selection, so when I click Change the correct word is inserted after (with no space) the wrong word, which is not removed. 

- spell tab uses a different font, should use the same font as find tab (log font probably?) 

@color
</t>
<t tx="ekr.20071102162910.782">@others
</t>
<t tx="ekr.20071102162910.783">class spellCommandsClass (baseEditCommandsClass):

    '''Commands to support the Spell Tab.'''

    @others
</t>
<t tx="ekr.20071102162910.784">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.handler = None

    # All the work happens when we first open the frame.
</t>
<t tx="ekr.20071102162910.785">def getPublicCommands (self):

    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
</t>
<t tx="ekr.20071102162910.786">def openSpellTab (self,event=None):

    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        self.handler = spellTabHandler(c,tabName)
        if not self.handler.loaded:
            log.deleteTab(tabName,force=True)
</t>
<t tx="ekr.20071102162910.787"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()

def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
</t>
<t tx="ekr.20071102162910.788">class spellTabHandler (leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""

    @others
</t>
<t tx="ekr.20071102162910.789"></t>
<t tx="ekr.20071102162910.790">def __init__(self,c,tabName):

    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = g.app.gui.plainTextWidget(c.frame.top)
        # A text widget for scanning.
        # Must have a parent frame even though it is not packed.

    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.tab = g.app.gui.createSpellTab(c,self,tabName)
</t>
<t tx="ekr.20071102162910.791">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"..","plugins",'spellpyx.txt'))

    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)

    if self.aspell.aspell:
        self.dictionary = self.readDictionary(dictionaryFileName)
    else:
        self.dictionary = False
        # g.es_print('Can not open Aspell',color='red')

    return self.aspell.aspell
</t>
<t tx="ekr.20071102162910.792">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary

    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""

    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
</t>
<t tx="ekr.20071102162910.793"></t>
<t tx="ekr.20071102162910.794">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""

    if not self.currentWord: return

    # g.trace(self.currentWord)

    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
</t>
<t tx="ekr.20071102162910.795">def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; w = body.bodyCtrl

    selection = self.tab.getSuggestion()
    if selection:
        if hasattr(self.tab,'change_i') and self.tab.change_i is not None:
            start,end = oldSel = self.tab.change_i,self.tab.change_j
            # g.trace('using',start,end)
        else:
            start,end = oldSel = w.getSelectionRange()
        if start:
            if start &gt; end: start,end = end,start
            w.delete(start,end)
            w.insert(start,selection)
            w.setSelectionRange(start,start+len(selection))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20071102162910.796">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        # Save the selection range.
        ins = w.getInsertPoint()
        i,j = w.getSelectionRange()
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Restore the selection range.
        w.setSelectionRange(i,j,insert=ins)
        w.see(ins)
        ### w.update() ###
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20071102162910.797">def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.currentPosition()
    w = c.frame.body.bodyCtrl
    aspell = self.aspell ; alts = None ; word = None
    trace = False
    try:
        while 1:
            i,j,p,word = self.findNextWord(p)
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if trace: g.trace('alts',alts and len(alts) or 0,i,j,word,p and p.headString() or 'None')
            if alts:
                c.beginUpdate()
                try:
                    c.frame.tree.expandAllAncestors(p)
                    c.selectPosition(p)
                finally:
                    c.endUpdate()
                    w.setSelectionRange(i,j,insert=j)
                break
    except:
        g.es_exception()
    return alts, word
</t>
<t tx="ekr.20071102162910.798">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
</t>
<t tx="ekr.20071102162910.799">def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; p = p.copy() ; trace = False
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i &lt; len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.headString(),'i',i,'len(s)',len(s))
        if i &lt; len(s):
            # A non-empty word has been found.
            j = i
            while j &lt; len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            if trace: g.trace(i,j,word,p.headString())
            return i,j,p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.bodyString())
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
            if trace: g.trace(0,0,'--&gt;',p.headString())

    return None,None,None,None</t>
<t tx="ekr.20071102162910.800">def hide (self,event=None):

    self.c.frame.log.selectTab('Log')

    for message in self.messages:
        g.es(message,color='blue')

    self.messages = []
</t>
<t tx="ekr.20071102162910.801">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""

    if not self.currentWord: return

    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
</t>
<t tx="ekr.20071102162910.802">class tkSpellTab:

    @others
</t>
<t tx="ekr.20071102162910.803">def __init__ (self,c,handler,tabName):

    self.c = c
    self.handler = handler
    self.tabName = tabName
    self.change_i, change_j = None,None
    self.createFrame()
    self.createBindings()
    self.fillbox([])
</t>
<t tx="ekr.20071102162910.804">def createBindings (self):

    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.handler.hide),
            ('spell-add',               self.handler.add),
            ('spell-find',              self.handler.find),
            ('spell-ignore',            self.handler.ignore),
            ('spell-change-then-find',  self.handler.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)

    self.listBox.bind("&lt;Double-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="ekr.20071102162910.805">def createFrame (self):

    c = self.c ; log = c.frame.log ; tabName = self.tabName
    setFont = False

    parentFrame = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'

    if setFont:
        fontSize = g.choose(sys.platform.startswith('win'),9,14)

    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;

    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
</t>
<t tx="ekr.20071102162910.806">self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)
</t>
<t tx="ekr.20071102162910.807">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')

if setFont:
    self.wordLabel.configure(font=('verdana',fontSize,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
if setFont:
    self.listBox.configure(font=('verdana',fontSize,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
</t>
<t tx="ekr.20071102162910.808"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = []
if setFont:
    font = ('verdana',fontSize,'normal')
width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    if setFont:
        b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    else:
        b = Tk.Button(frame,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
</t>
<t tx="ekr.20071102162910.809"></t>
<t tx="ekr.20071102162910.810">def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.handler.add()
    self.change_i, self.change_j = None,None
</t>
<t tx="ekr.20071102162910.811">def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.handler.change()
    self.updateButtons()
    self.change_i, self.change_j = None,None


def onChangeThenFindButton(self,event=None):

    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.handler.change():
        self.handler.find()
    self.updateButtons()
    self.change_i, self.change_j = None,None
</t>
<t tx="ekr.20071102162910.812">def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    c = self.c
    self.handler.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    self.change_i, self.change_j = None,None
</t>
<t tx="ekr.20071102162910.813">def onHideButton(self):

    """Handle a click in the Hide button in the Spell tab."""

    self.handler.hide()
    self.change_i, self.change_j = None,None
</t>
<t tx="ekr.20071102162910.814">def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.handler.ignore()
    self.change_i, self.change_j = None,None</t>
<t tx="ekr.20071102162910.815">def onMap (self, event=None):
    """Respond to a Tk &lt;Map&gt; event."""

    # self.update(show= False, fill= False)
    self.updateButtons()
</t>
<t tx="ekr.20071102162910.816">def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""

    c = self.c ; w = c.frame.body.bodyCtrl

    if self.change_i is None:
        # A bad hack to get around the fact that only one selection
        # exists at any one time on Linux.
        i,j = w.getSelectionRange()
        # g.trace('setting',i,j)
        self.change_i,self.change_j = i,j

    self.updateButtons()

    return 'continue'
</t>
<t tx="ekr.20071102162910.817"></t>
<t tx="ekr.20071102162910.818">def bringToFront (self):

    # g.trace('tkSpellTab',g.callers())
    self.c.frame.log.selectTab('Spell')
</t>
<t tx="ekr.20071102162910.819">def fillbox(self, alts, word=None):
    """Update the suggestions listBox in the Check Spelling dialog."""

    self.suggestions = alts

    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])

    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1)
</t>
<t tx="ekr.20071102162910.820">def getSuggestion(self):
    """Return the selected suggestion from the listBox."""

    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None
</t>
<t tx="ekr.20071102162910.821"># def update(self,show=True,fill=False):

    # """Update the Spell Check dialog."""

    # c = self.c

    # if fill:
        # self.fillbox([])

    # self.updateButtons()

    # if show:
        # self.bringToFront()
        # c.bodyWantsFocus()
</t>
<t tx="ekr.20071102162910.822">def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c ; w = c.frame.body.bodyCtrl

    start, end = w.getSelectionRange()
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
</t>
<t tx="ekr.20071102162910.823"></t>
<t tx="ekr.20071102162910.824"># This involves using the default font.</t>
<t tx="ekr.20071102162910.825"></t>
<t tx="ekr.20071102162910.826">@nocolor

https://sourceforge.net/forum/message.php?msg_id=4596477
By: thyrsus

Latest CVS.  I do "Cmds-&gt;Body Editors...-&gt;Add Body Editor" and it splits the
body pane on the curent node.  Then I do "Cmds-&gt;Body Editors...-&gt;Delete Body
Editor"; the second body pane goes away, but the log window has this:

exception executing command
Traceback (most recent call last):
  File "/usr/local/lib/leo/src/leoCommands.py", line 276, in doCommand
    val = command(event)
  File "/usr/local/lib/leo/src/leoFrame.py", line 906, in deleteEditor
    self.selectEditor(w)
  File "/usr/local/lib/leo/src/leoFrame.py", line 978, in selectEditor
    val = self.selectEditorHelper(w)
  File "/usr/local/lib/leo/src/leoFrame.py", line 1021, in selectEditorHelper
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls
assignPositionToEditor.
  File "/usr/local/lib/leo/src/leoCommands.py", line 7300, in selectPosition
    c.frame.tree.select(p,updateBeadList)
  File "/usr/local/lib/leo/src/leoFrame.py", line 2726, in select
    val = self.treeSelectHelper(p,updateBeadList,scroll)
  File "/usr/local/lib/leo/src/leoFrame.py", line 2824, in treeSelectHelper
    frame.setWrap(p)
  File "/usr/local/lib/leo/src/leoTkinterFrame.py", line 1469, in setWrap
    self.bodyXBar.pack(side="bottom", fill="x")
  File "/usr/lib/python2.5/lib-tk/Tkinter.py", line 1762, in pack_configure
    + self._options(cnf, kw))
TclError: bad window path name
".171002092.171002988.171041068.171041100.171041164.171041260.177140108.16854830
0.168547916.bodyXBar"

The problem occurs with Fedora 7,

Leo 4.4.4 b4, build  1.215 , October 27, 2007
Python 2.5.0, Tk 8.4.13, Pmw 1.2
linux2

The problem does not occur with Fedora Core 3,

Leo 4.4.4 b4, build  1.215 , October 27, 2007
Python 2.3.4, Tk 8.4.7, Pmw 1.2
linux2

In another thread you ask what's with Fedora Core 7?  Speaking from Stephen
Colbert's gut, this feels similar to the other Python crash: Fedora turns on
all the features, and they encounter the bugs.  If the Python folks don't fix
them, you'll get to enjoy them on all the distributions soon enough :-).

    - Stephen

</t>
<t tx="ekr.20071102162910.827">def createTextWidget (self,parentFrame,p,name):

    c = self.c

    parentFrame.configure(bg='LightSteelBlue1')

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")

    # Setgrid=1 cause severe problems with the font panel.
    body = w = leoTkTextWidget (parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)

    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')

    def yscrollCallback(x,y,bodyBar=bodyBar,w=w):
        # g.trace(x,y,g.callers())
        if hasattr(w,'leo_scrollBarSpot'):
            w.leo_scrollBarSpot = (x,y)
        return bodyBar.set(x,y)

    body['yscrollcommand'] = yscrollCallback # bodyBar.set

    bodyBar['command'] =  body.yview
    bodyBar.pack(side="right", fill="y")

    # Always create the horizontal bar.
    bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview

    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")

    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)

    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v

    w.leo_active = True
    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = bodyBar # 2007/10/31
    w.leo_bodyXBar = bodyXBar # 2007/10/31
    w.leo_chapter = None
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w
</t>
<t tx="ekr.20071102162910.828"></t>
<t tx="ekr.20071102162910.829"></t>
<t tx="ekr.20071102163001"></t>
<t tx="ekr.20071102163001.1"></t>
<t tx="ekr.20071102163001.2"># Convert all args to strings.

def trace (*args,**keys):

    #callers = keys.get("callers",False)
    newline = keys.get("newline",True)
    align =   keys.get("align",0)

    s = ""
    for arg in args:
        if type(arg) == type(u""):
            pass
            # try:    arg = str(arg) 
            # except: arg = repr(arg)
        elif type(arg) != type(""):
            arg = repr(arg)
        if len(s) &gt; 0:
            s = s + " " + arg
        else:
            s = arg
    message = s

    try: # get the function name from the call stack.
        f1 = sys._getframe(1) # The stack frame, one level up.
        code1 = f1.f_code # The code object
        name = code1.co_name # The code name
    except: name = ''
    if name == "?":
        name = "&lt;unknown&gt;"

    # if callers:
        # traceback.print_stack()

    if align != 0 and len(name) &lt; abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align &gt; 0: name = name + pad
        else:         name = pad + name

    message = g.toEncodedString(message,'ascii') # Bug fix: 10/10/07.

    if newline:
        print name + ": " + message
    else:
        print name + ": " + message,
</t>
<t tx="ekr.20071102163001.3">def callers (n=8,excludeCaller=True,files=False):

    '''Return a list containing the callers of the function that called g.callerList.

    If the excludeCaller keyword is True (the default), g.callers is not on the list.

    If the files keyword argument is True, filenames are included in the list.
    '''

    # sys._getframe throws ValueError in both cpython and jython if there are less than i entries.
    # The jython stack often has less than 8 entries,
    # so we must be careful to call g._callerName with smaller values of i first.
    result = []
    i = g.choose(excludeCaller,3,2)
    while 1:
        s = g._callerName(i,files=files)
        if s:
            result.append(s)
        if not s or len(result) &gt;= n: break
        i += 1

    result.reverse()
    sep = g.choose(files,'\n',',')
    return sep.join(result)
</t>
<t tx="ekr.20071102163001.4">def _callerName (n=1,files=False):

    try: # get the function name from the call stack.
        f1 = sys._getframe(n) # The stack frame, n levels up.
        code1 = f1.f_code # The code object
        if files:
            return '%s:%s' % (g.shortFilename(code1.co_filename),code1.co_name)
        else:
            return code1.co_name # The code name
    except ValueError:
        return '' # The stack is not deep enough.
    except:
        g.es_exception()
        return '' # "&lt;no caller name&gt;"
</t>
<t tx="ekr.20071102163001.5">def __init__(self,title,gui):

    g.trace('swingFrame',g.callers(20))

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.use_chapters = False ###

    self.title = title

    leoSwingFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBarClass = self.swingIconBarClass
    self.statusLineClass = self.swingStatusLineClass
    self.iconBar = None

    self.trace_status_line = None # Set in finishCreate.

    &lt;&lt; set the leoSwingFrame ivars &gt;&gt;
</t>
<t tx="ekr.20071102163001.6"># "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
# self.treeBar = None # Replaced by injected frame.canvas.leo_treeBar.

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
</t>
<t tx="ekr.20071102163001.7">@first # -*- coding: utf-8 -*-

"""A plugin to use swing as Leo's gui."""

@language python
@tabwidth -4

__version__ = '0.01' # EKR Initial code based on LeoJy2 version 1-11-06.

try:
    &lt;&lt; imports &gt;&gt;
    import_ok = True
except Exception:
    g.es('Can not init swingGui plugin')
    g.es_exception()
    import_ok = False

True, False = 1,0

@others
</t>
<t tx="ekr.20071102163001.8">import leoGlobals as g

import leoFrame
import leoGui
import leoMenu
import leoPlugins

import java.io as io
import org.leo.shell.IsolatedJythonClassLoader as ijcl ###

ld = io.File(g.app.loadDir)
ijcl.addToSearchPath(ld)
ijcl.beginLoading()

import base64
import copy
import string
import sys

import java

import java.awt as awt
import java.awt.datatransfer as datatransfer
import java.awt.event as aevent

import javax.imageio as imageio

import java.io as io

import java.lang
import java.lang.Exception
import java.lang.System as jsys

import javax.swing as swing
import javax.swing.border as sborder
import javax.swing.event as sevent
import javax.swing.plaf.synth as synth
import javax.swing.text as stext  
import javax.swing.tree as stree
import javax.swing.undo as undo

import java.text as text

import java.util as util #
import java.util.concurrent as concurrent
import java.util.concurrent.atomic as atomic
import java.util.concurrent.locks as locks
import java.util.regex as jregex

# import pdb
from utilities.DefCallable import DefCallable
from utilities.TabManager import TabManager
from utilities.WeakMethod import WeakMethod

if 0: # Not ready yet: these should be in this file.
    import leoEditorKit2
    import EditorBackground
    import SwingMacs
    #import string
    #import leoPlugins
    #import base64
    import leoIconTreeRenderer
    import leoHeadlineTreeCellEditor
    import jarray
    import LeoUtilities
    #import copy
    import leoLanguageManager
    import PositionSpecification

if 0:
    @others
    pass</t>
<t tx="ekr.20071102163001.9">#import leoSwingMenu
#import leoSwingGui
###import leoSwingUndo
# import leoFrame

# import leoGlobals as g   

#from utilities.DefCallable import DefCallable
#from utilities.TabManager import TabManager
#from utilities.WeakMethod import WeakMethod
#import weakref

#import java
#import java.awt as awt
# import java.awt.datatransfer as datatransfer
#import java.awt.event as aevent
# import java.io as io
# import java.lang
#import java.lang.Exception
#import java.util as util #
#import java.util.concurrent as concurrent
#import java.util.concurrent.atomic as atomic
#import java.util.concurrent.locks as locks
#import java.util.regex as jregex

#import javax.imageio as imageio

#import javax.swing as swing
#import javax.swing.border as sborder
#import javax.swing.event as sevent
#import javax.swing.plaf.synth as synth
#import javax.swing.text as stext  
#import javax.swing.tree as stree
#import javax.swing.undo as undo

import leoEditorKit2
import EditorBackground
import SwingMacs
#import string
#import leoPlugins
#import base64
import leoIconTreeRenderer
import leoHeadlineTreeCellEditor
import jarray
import LeoUtilities
#import copy
import leoLanguageManager
import PositionSpecification</t>
<t tx="ekr.20071102163001.10">#import leoGlobals as g
#import leoFrame # for null gui.        
#import leoGui

#from utilities.DefCallable import DefCallable

#import java

#import java.awt as awt
#import java.awt.datatransfer as dtfr 
#import java.awt.event as aevent

#import java.io

#import java.lang.System as jsys

#import javax.swing as swing
#import javax.swing.border as sborder
#import javax.swing.event as sevent

#import java.text as text
</t>
<t tx="ekr.20071102163001.11">#import leoSwingMenu
#import leoSwingGui
###import leoSwingUndo
# import leoFrame

# import leoGlobals as g   

#from utilities.DefCallable import DefCallable
#from utilities.TabManager import TabManager
#from utilities.WeakMethod import WeakMethod
#import weakref

#import java

#import java.awt as awt
#import java.awt.datatransfer as datatransfer
#import java.awt.event as aevent

#import java.io as io

#import java.lang
#import java.lang.Exception

#import java.util as util #
#import java.util.concurrent as concurrent
#import java.util.concurrent.atomic as atomic
#import java.util.concurrent.locks as locks
#import java.util.regex as jregex

#import javax.imageio as imageio

#import javax.swing as swing
#import javax.swing.border as sborder
#import javax.swing.event as sevent
#import javax.swing.plaf.synth as synth
#import javax.swing.text as stext  
#import javax.swing.tree as stree
#import javax.swing.undo as undo

import leoEditorKit2
import EditorBackground
import SwingMacs
#import string
#import leoPlugins
#import base64
import leoIconTreeRenderer
import leoHeadlineTreeCellEditor
import jarray
import LeoUtilities
import copy
import leoLanguageManager
import PositionSpecification</t>
<t tx="ekr.20071102163001.12">#import leoGlobals as g

#import java.io as io
#import org.leo.shell.IsolatedJythonClassLoader as ijcl

#ld = io.File( g.app.loadDir )
#ijcl.addToSearchPath( ld )
#ijcl.beginLoading()

#import string
#import sys
#import leoMenu

#import java

#import java.awt as awt
#import java.awt.event as aevent
#import java.lang

#import javax.swing as swing  
#import javax.swing.border as sborder 
#import javax.swing.event as sevent
#import javax.swing.tree as stree  

# import pdb
# from utilities.DefCallable import DefCallable</t>
<t tx="ekr.20071102163001.13">def init ():

    global import_ok
    if not import_ok: return False

    if g.app.gui:
        g.es('Can not install swingGui plugin: %s gui already active' % (g.app.gui.guiName()),color='red')
        return False

    splash = LeoSplash()
    java.awt.EventQueue.invokeAndWait(splash)

    gct = GCEveryOneMinute()
    gct.start()

    tk = awt.Toolkit.getDefaultToolkit()
    tk.setDynamicLayout(True)

    return True</t>
<t tx="ekr.20071102163001.14">class leoSwingBody (sevent.DocumentListener,aevent.KeyAdapter,sevent.UndoableEditListener):

    """The base class for the body pane in Leo windows."""

    @others</t>
<t tx="ekr.20071102163001.15">def __init__ (self,frame,parentFrame):

    self.editors = []
    self.ignore_insert = 0
    self.frame = frame
    self.c = c = frame.c
    self.forceFullRecolorFlag = False
    frame.body = self
    # May be overridden i
    #leoFrame.leoBody.__init__( self, frame, parentFrame )
    self.parentFrame = parentFrame
    self._current_editor = None
    self._undo_manager = None
    self.jdp = jdp = swing.JDesktopPane()
    self.jdp.addMouseListener( self.SimplifiedUtilityRightClick( self ) )
    #class AddEditor( event.MouseAdapter ):
    #    def __init__( self ):
    #        event.MouseAdapter.__init__( self )
    #    
    #    def mouse


    #self.mAdapter = leoSwingBody.UtilityRightClick( frame.c ) 
    #self.jdp.addMouseListener( self.mAdapter )
    self.editor = leoSwingBody.Editor( jdp, frame.c, self )
    #self.tabed_pane = swing.JTabbedPane()
    self.tab_manager = TabManager()
    self.tab_manager.add( "Editors", jdp )
    g.doHook( "body_pane_added", c = self.c, tabmanager = self.tab_manager )
    parentFrame.bottomComponent = self.tab_manager.base
    self.editor.frame.setMaximum( True )
    self.oldText = ""
    self.oldSel = ""
    self.oldYview = None
    self.ch = None

    #self.frame = frame
    #self.c = c = frame.c
    #self.forceFullRecolorFlag = False
    #frame.body = self

    # May be overridden in subclasses...
    #self.bodyCtrl = self

    # Must be overridden in subclasses...
    #self.colorizer = None
</t>
<t tx="ekr.20071102163001.16">def oops (self):

    g.trace("leoBody oops:", g.callerName(2), "should be overridden in subclass")</t>
<t tx="ekr.20071102163001.17">def setFontFromConfig (self):

    self.oops()</t>
<t tx="ekr.20071102163001.18">@
These methods, implementing DocumentListener, keeps the document and position data in sync.
And also adds to the undoer.
@c

def insertUpdate( self, event):

    #doc = event.getDocument()
    #txt = doc.getText( event.getOffset(), event.getLength() )       
    self._syncText( event )

def removeUpdate( self, event):
    self._syncText( event, which = 0 )

def changedUpdate( self, event ):
    pass #this does Attribute changes

def _syncText( self, event, which = 1 ):

    if self.ignore_insert: return
    c = self.c 
    doc = event.getDocument()
    #From here to
    oldText = self.oldText
    oldSel = self.oldSel 
    oldYview = self.oldYview 
    ch = self.ch
    #Here, these are set in the KeyAdapter node

    newSel = c.frame.body.getTextSelection()
    #length = doc.getLength()
    #newText = doc.getText( 0 , length )
    p = c.currentPosition().copy()

    undoType='Typing'
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        event.consume()
        return

    pos = c.currentPosition()
    #pos.setTnodeText( newText )
    t = pos.v.t
    offset = event.getOffset()
    length = event.getLength()
    if which:
        txt = doc.getText( offset, length )
        t._bodyString.insert( offset, txt )
        dec_edit = leoSwingUndo.UndoableDocumentEvent( c , event, txt )
        #c.undoer.addUndo( dec_edit )
        if self.editor._node_undoer:
            self.editor._node_undoer.addUndo( dec_edit )
        else:
            c.undoer.addUndo( dec_edit )
            dec_edit.p = pos.copy()
    else:
        #offset = offset - length
        txt = t.bodyString[ offset: offset + length ]
        t._bodyString.delete( offset, offset + length )
        dec_edit = leoSwingUndo.UndoableDocumentEvent( c, event, txt )
        #c.undoer.addUndo( dec_edit )
        #c.frame.body.editor._node_undoer.addUndo( dec_edit )
        if self.editor._node_undoer:
            self.editor._node_undoer.addUndo( dec_edit )
        else:
            c.undoer.addUndo( dec_edit )
            dec_edit.p = pos.copy()

    if not pos.isDirty():
        pos.setDirty()
        c.setChanged( True )  

    #for z in self.editor.synchers:
    #    z.sync()

    #c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)   
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType) 
</t>
<t tx="ekr.20071102163001.19">def createBindings (self,frame):
    self.oops()

def createControl (self,parentFrame):
    self.oops()

def initialRatios (self):
    self.oops()

def onBodyChanged (self,v,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    pass

def setBodyFontFromConfig (self):
    self.oops()

</t>
<t tx="ekr.20071102163001.20">def bbox(self,index):

    self.oops()</t>
<t tx="ekr.20071102163001.21">def tag_add (self,tagName,index1,index2):

    self.oops()

def tag_bind (self,tagName,event,callback):

    self.oops()

def tag_configure (self,colorName,**keys):

    self.oops()

def tag_delete(self,tagName):

    self.oops()

def tag_remove (self,tagName,index1,index2):
    self.oops()</t>
<t tx="ekr.20071102163001.22">def cget(self,*args,**keys):

    self.oops()

def configure (self,*args,**keys):

    self.oops()</t>
<t tx="ekr.20071102163001.23">def hasFocus (self):

    return self.editor.editor.hasFocus()

def setFocus (self):

    df = DefCallable( self.editor.editor.requestFocusInWindow )
    ft = java.util.concurrent.FutureTask( df )
    java.awt.EventQueue.invokeLater( ft )

def focus_get( self ):

    return self</t>
<t tx="ekr.20071102163001.24">def getBodyPaneHeight (self):

    return self.editor.editor.getSize().height

def getBodyPaneWidth (self):

    return self.editor.editor.getSize().width </t>
<t tx="ekr.20071102163001.25">def scheduleIdleTimeRoutine (self,function,*args,**keys):

    self.oops()</t>
<t tx="ekr.20071102163001.26">def adjustIndex (self,index,offset):

    return index + offset

def compareIndices(self,i,rel,j):

    if j == 'end' or j == '1.0':
        if j == 'end':
            j = self.editor.editor.getDocument().getLength()
        elif j == '1.0':
            j = 0

    if rel == '&lt;=':
        return i &lt;= j

def convertRowColumnToIndex (self,row,column):

    self.oops()

def convertIndexToRowColumn (self,index):

    self.oops()

def getImageIndex (self,image):

    self.oops()</t>
<t tx="ekr.20071102163001.27">def getBeforeInsertionPoint (self):

    editor = self.editor.editor
    pos = editor.getCaretPosition()
    if pos == 0:
        return 0
    else:
        return pos - 1

def getInsertionPoint (self):

    return self.editor.editor.getCaretPosition()

def getCharAtInsertPoint (self):

    editor = self.editor.editor
    pos = editor.getCaretPosition()
    doc = editor.getDocument()
    dlen = doc.getLength()
    if dlen == pos:
        return " "
    else:
        return doc.getText( pos, 1 )

def getCharBeforeInsertPoint (self):
    editor = self.editor.editor
    pos = editor.getCaretPosition()
    doc = editor.getDocument()
    dlen = doc.getLength()
    if pos == 0:
        return " "
    else:
        return doc.getText( pos - 1, 1 )

def makeInsertPointVisible (self):
    pass #this doesn't seem to be a relevant method at this point

def setInsertionPoint (self,index):

    self.editor.editor.setCaretPosition( index )

def setInsertionPointToEnd (self):

    editor = self.editor.editor
    doc = editor.getDocument()
    editor.setCaretPosition( doc.getLength() )

def setInsertPointToStartOfLine (self,lineNumber): # zero-based line number

    txt = self.editor.editor.getText()
    lines = txt.splitlines( True )
    n = 0
    for z in xrange( lineNumber ):
        n += len( lines[ z ] )

    self.editor.editor.setCaretPosition( n )
</t>
<t tx="ekr.20071102163001.28">def bind (self,*args,**keys):

    #self.oops()
    pass
</t>
<t tx="ekr.20071102163001.29">def deleteTextSelection (self):

    editor = self.editor.editor
    editor.replaceSelection( "" )

def getSelectedText (self):

    editor = self.editor.editor
    return editor.getSelectedText()

def getTextSelection (self):

    editor = self.editor.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    return start, end

def hasTextSelection (self):

    editor = self.editor.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start != end: return True
    else: return False

def selectAllText (self):

    editor = self.editor.editor
    doc = editor.getDocument()
    editor.setSelectionStart( 0 )
    editor.setSelectionEnd( doc.getLength() )

def setTextSelection (self,i,j=None):

    if i is None:
        i, j = 0, 0
    elif i != None and j != None:
        pass
    else:
        i,j = i
    editor = self.editor.editor
    g.app.gui.setTextSelection( editor, i, j )</t>
<t tx="ekr.20071102163001.30"></t>
<t tx="ekr.20071102163001.31"></t>
<t tx="ekr.20071102163001.32">def deleteAllText (self):
    editor = self.editor.editor
    doc = editor.getDocument()
    doc.replace(0,doc.getLength(),"",None)

</t>
<t tx="ekr.20071102163001.33">def deleteCharacter (self,index):
    editor = self.editor.editor
    doc = editor.getDocument()
    doc.replace(index,1,"",None)

</t>
<t tx="ekr.20071102163001.34">def deleteLastChar (self):
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    sdoc.replace(sdoc.getLength()-1,1,"",None)

</t>
<t tx="ekr.20071102163001.35">def deleteLine (self,lineNumber): # zero based line number.
    editor = self.editor.editor
    txt = editor.getText()
    lines = txt.splitlines(True)
    start = lines [: lineNumber]
    end = lines [lineNumber + 1:]
    start.extend(end)
    ntxt = ''.join(start)
    sdoc = editor.getStyledDocument()
    sdoc.replace(0,sdoc.getLength(),"",None)
    sdoc.insertString(0,ntxt,None)

</t>
<t tx="ekr.20071102163001.36">def deleteLines (self,line1,numberOfLines): # zero based line numbers.
    editor = self.editor.editor
    txt = editor.getText()
    txtlines = txt.splitlines(True)
    start = txtlines [: line1]
    middle = ['\n',]
    end = txtlines [line1 + numberOfLines:]
    start.extend(middle)
    start.extend(end)
    ntxt = ''.join(start)
    sdoc = editor.getStyledDocument()
    try:
        sdoc.replace(0,sdoc.getLength(),ntxt,None)
    except java.lang.Exception, x:
        x.printStackTrace()

</t>
<t tx="ekr.20071102163001.37">def deleteRange (self,index1,index2):
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    sdoc.remove(index1,index2-index1)</t>
<t tx="ekr.20071102163001.38"></t>
<t tx="ekr.20071102163001.39">def getAllText (self):
    editor = self.editor.editor
    doc = editor.getDocument()
    return doc.getText()

</t>
<t tx="ekr.20071102163001.40">def getCharAtIndex (self,index):
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    return sdoc.getText(index,1)

</t>
<t tx="ekr.20071102163001.41">def getInsertLines (self):
    self.oops()
    return None, None, None

</t>
<t tx="ekr.20071102163001.42">def getSelectionAreas (self):
    self.oops()
    return None, None, None

</t>
<t tx="ekr.20071102163001.43">def getSelectionLines (self):
    editor = self.editor.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start == end:
        start = stext.Utilities.getRowStart(editor,start)
        end = stext.Utilities.getRowEnd(editor,start)
        if start == -1: start = 0
        if end == -1: end = 0

    before = editor.getText(0,start)
    sel = editor.getText(start,end-start)
    after = editor.getText(end,len(editor.getText())-end)
    return before, sel, after

</t>
<t tx="ekr.20071102163001.44">def getTextRange (self,index1,index2):
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    return sdoc.getText(index1,index2-index1)

</t>
<t tx="ekr.20071102163001.45"></t>
<t tx="ekr.20071102163001.46">def insertAtInsertPoint (self,s):

    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    pos = editor.getCaretPosition()
    sdoc.insertString(pos,s,None)
    editor.setCaretPosition(pos+len(s))

</t>
<t tx="ekr.20071102163001.47">def insertAtEnd (self,s):

    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    length = sdoc.getLength()
    sdoc.insertString(length-1,s,None)
    editor.setCaretPosition(length-1+len(s))

</t>
<t tx="ekr.20071102163001.48">def insertAtStartOfLine (self,lineNumber,s):

    editor = self.editor.editor
    txt = editor.getText()
    txtlines = txt.splitlines(True)
    lines = txtlines [: lineNumber]
    where = ''.join(lines)
    spot = len(where)
    sdoc = editor.getStyledDocument()
    sdoc.insertString(spot,s,None)
    editor.setCaretPosition(spot+len(s))</t>
<t tx="ekr.20071102163001.49">def setSelectionAreas (self,before,sel,after):

    editor = self.editor.editor
    doc = editor.getDocument()
    doc.remove(0,doc.getLength())
    if before:
        doc.insertString(0,before,None)
    sel_start = doc.getLength()

    if sel:
        doc.insertString(doc.getLength(),sel,None)
    sel_end = doc.getLength()

    if after:
        if after [ -1] == '\n':
            after = after [: -1]
        doc.insertString(doc.getLength(),after,None)

    g.app.gui.setTextSelection(self.editor.editor,sel_start,sel_end)

    return sel_start, sel_end
</t>
<t tx="ekr.20071102163001.50">def makeIndexVisible (self,index):
    pass

def setFirstVisibleIndex (self,index):
    pass

def getYScrollPosition (self):

    editor = self.editor.editor
    try:
        cpos = editor.getCaretPosition()
        rec = editor.modelToView( cpos )
        return rec.y 
    except:
        return 0

def setYScrollPosition (self,scrollPosition):
    #self.oops()
    #print "Y Scroll is %s" % scrollPosition
    pass   

def scrollUp (self):
    self.oops()

def scrollDown (self):
    self.oops()</t>
<t tx="ekr.20071102163001.51"># It's weird to have the tree class be responsible for coloring the body pane!

def getColorizer(self):

    return self.colorizer

def recolor_now(self,p,incremental=False):

    self.editor.editor.repaint()
    #self.colorizer.colorize(p.copy(),incremental)

def recolor_range(self,p,leading,trailing):

    pass 
    #self.colorizer.recolor_range(p.copy(),leading,trailing)

def recolor(self,p,incremental=False):

    pass
    #if 0: # Do immediately
    #    self.colorizer.colorize(p.copy(),incremental)
    #else: # Do at idle time
    #    self.colorizer.schedule(p.copy(),incremental)

def updateSyntaxColorer(self,p):
    pass
    #return self.colorizer.updateSyntaxColorer(p.copy())</t>
<t tx="ekr.20071102163001.52">class Editor( aevent.FocusListener ):

    ipath = g.os_path_join( g.app.loadDir ,"..","Icons","Leoapp2.GIF")
    icon = swing.ImageIcon( "../Icons/Leoapp2.GIF" )
    icon = swing.ImageIcon( ipath ) 
    #ifile = java.io.File( ipath )
    #iimage = imageio.ImageIO.read( ifile ) 

    @others





</t>
<t tx="ekr.20071102163001.53">class InsertTextIntoBody(swing.AbstractAction):

    def __init__ (self,c,txt):
        swing.AbstractAction.__init__(self,txt)
        self.txt = txt
        self.c = c

    def actionPerformed (self,event):

        editor = self.c.frame.body.editor.editor
        pos = editor.getCaretPosition()
        #editor.insert( self.txt, pos )
        doc = editor.getDocument()
        doc.insertString(pos,self.txt,None)



class SetHeadline(InsertTextIntoBody):

    def __init__ (self,c,txt):
        leoSwingBody.Editor.InsertTextIntoBody.__init__(self,c,txt)

    def actionPerformed (self,event):

        cp = self.c.currentPosition()
        hS = cp.headString()
        newHeadString = "%s %s" % (self.txt,hS)
        cp.setHeadString(newHeadString)


class SetHeadlineToSelection(InsertTextIntoBody):
    def __init__ (self,c,txt):
        leoSwingBody.Editor.InsertTextIntoBody.__init__(self,c,txt)

    def actionPerformed (self,event):

        txt = self.c.frame.body.editor.editor.getSelectedText()
        if txt:
            cp = self.c.currentPosition()
            cp.setHeadString(txt)



class rmvSymbol(swing.AbstractAction):
    def __init__ (self,c,symbol):
        swing.AbstractAction.__init__(self,"remove %s" % symbol)
        self.c = c
        self.symbol = symbol

    def actionPerformed (self,event):

        cp = self.c.currentPosition()
        hS = cp.headString()
        if hS.startswith(self.symbol):
            hS = hS.split()
            hS = hS [1:]
            hS = " ".join(hS)
            cp.setHeadString(hS)



class inSRMenuListener(sevent.MenuListener):

    def __init__ (self,menu,c):
        self.menu = menu
        self.c = c

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        menu = self.menu
        menu.removeAll()
        cp = self.c.currentPosition()
        InsertTextIntoBody = leoSwingBody.Editor.InsertTextIntoBody
        for z in cp.children_iter():
            hS = z.headString()
            hS = hS.strip()
            if hS.startswith("&lt;%s" % '&lt;') and hS.endswith("&gt;%s" % "&gt;"):
                menu.add(InsertTextIntoBody(self.c,hS))

</t>
<t tx="ekr.20071102163001.54">class ColorKeywordsProvider(leoEditorKit2.ColorDeterminer,sevent.DocumentListener):

    @others
</t>
<t tx="ekr.20071102163001.55">def __init__ (self,c):

    lb = leoLanguageManager.LanguageManager.getLanguageBundle(c)
    for z in dir(lb):
        if not callable(getattr(lb,z)):
            setattr(self,z,getattr(lb,z))

    self.c = c
    self.last_p = None
    self.last_language = None
    self.editor = None
    self.error_map = util.HashMap()
    fg, bg, cl = self.getLineNumberColors()
    self.line_fg = fg ; self.line_bg = bg ; self.line_cl = cl
    self.queue = concurrent.LinkedBlockingQueue()
    self.c.invisibleWatchers.append(self)
    return


</t>
<t tx="ekr.20071102163001.56">def changedUpdate (self,event):
    pass #this does Attribute changes


</t>
<t tx="ekr.20071102163001.57">def checkForLanguageChange (self,event):

    language = LeoUtilities.scanForLanguageOnLine(self.editor)
    if language:
        #if not hasattr( self, "%s_keywords" % language ):
        if self.last_language != language:
            #self.editor.repaint()
            self.last_language = language
            jlc = self.c.frame.body.editor.jlc
            jlc.fullrecolorize()



</t>
<t tx="ekr.20071102163001.58">def drawrectangle (self):
    return self._drawrectangle

</t>
<t tx="ekr.20071102163001.59">def getColoredTokens (self):

    cp = self.c.currentPosition().copy()
    if cp != self.last_p:
        #language = g.scanForAtLanguage( self.c, cp )
        language = LeoUtilities.scanForLanguage(cp)
        self.last_p = cp
        self.last_language = language
    else:
        language = self.last_language

    leoLanguageManager.LanguageManager.setLanguageInEffect(self.c,language)

    if language == None:
        language = "python"
    if hasattr(self,"%s_keywords" % language):
        return getattr(self,"%s_keywords" % language)
    else:
        hm = leoLanguageManager.LanguageManager.loadLanguage(self.c,language)
        setattr(self,"%s_keywords" % language,hm)
        return hm


</t>
<t tx="ekr.20071102163001.60">def getCommentColor (self):
    return self._commentColor

</t>
<t tx="ekr.20071102163001.61">def getCommentTokens (self):

    cp = self.c.currentPosition().copy()
    if cp != self.last_p:
        #language = g.scanForAtLanguage( self.c, cp )
        language = LeoUtilities.scanForLanguage(cp)
        self.last_p = cp
        self.last_language = language
    else:
        language = self.last_language
    if self.comment_cache.has_key(language):
        return self.comment_cache [language]
    else:
        rv = g.set_delims_from_language(language)
        rv = jarray.array(rv,java.lang.String)
        self.comment_cache [language] = rv
        return rv
    #delim1,delim2, delim3 = g.set_delims_from_language( language )
    #return [ delim1, delim2, delim3 ]

</t>
<t tx="ekr.20071102163001.62">def getCurrentLineNumberForeground (self):
    return self.line_cl

</t>
<t tx="ekr.20071102163001.63">def getDocColor (self):
    return self._docColor

</t>
<t tx="ekr.20071102163001.64">def getFoldedBackgroundColor (self):
    return self._fbColor

</t>
<t tx="ekr.20071102163001.65">def getFoldedForegroundColor (self):
    return self._ffColor



</t>
<t tx="ekr.20071102163001.66">def getFootNodeBackgroundColor (self):
    return self._fnbgColor

</t>
<t tx="ekr.20071102163001.67">def getFootNodeForegroundColor (self):
    return self._fnfgColor


</t>
<t tx="ekr.20071102163001.68">def getFootNodes (self):

    cp = self.c.currentPosition()
    t = cp.v.t
    if hasattr(t,"unknownAttributes"):
        uas = t.unknownAttributes
        if uas.has_key("footnodes"):
            fn = uas ["footnodes"]
            sb = java.lang.StringBuilder()
            for z in fn:
                sb.append(z[0]).append(" : ").append(z[1])
                if not z [1].endswith("\n"): sb.append("\n")
            return sb.toString()
    return ""


</t>
<t tx="ekr.20071102163001.69">def getInvisiblesBlock (self):
    return self._invisibleBlock

</t>
<t tx="ekr.20071102163001.70">def getInvisiblesDot (self):
    return self._invisibleDot

</t>
<t tx="ekr.20071102163001.71">def getLineNumberBackground (self):
    return self.line_bg

#public boolean useLineNumbers();
#public Color getLineNumberForeground();
#public Color getCurrentLineNumberForeground();
#public Color getLineNumberBackground();
</t>
<t tx="ekr.20071102163001.72">def getLineNumberColors (self):

    c = self.c

    bg = g.app.config.getColor(c,"line_number_background")
    fg = g.app.config.getColor(c,"line_number_foreground")
    cl = g.app.config.getColor(c,"line_number_current")
    try:
        bg = getColorInstance(bg)
        if bg == None: bg = awt.Color.BLACK
        fg = getColorInstance(fg)
        if fg == None: fg = awt.Color.RED
        cl = getColorInstance(cl)
        if cl == None: cl = awt.Color.YELLOW
    except:
        bg = awt.Color.BLACK
        fg = awt.Color.RED
        cl = awt.Color.YELLOW
    return fg, bg, cl



</t>
<t tx="ekr.20071102163001.73">def getLineNumberForeground (self):
    return self.line_fg

</t>
<t tx="ekr.20071102163001.74">def getNumericColor (self):
    return self._numericcolor

</t>
<t tx="ekr.20071102163001.75">def getOperators (self):
    return util.HashMap()


</t>
<t tx="ekr.20071102163001.76">def getPunctuationColor (self):
    return self._punctuationColor

</t>
<t tx="ekr.20071102163001.77">def getRectangleColor (self):
    return self._rectanglecolor

</t>
<t tx="ekr.20071102163001.78">def getSectionReferenceColor (self):
    return self._sectionNameColor

</t>
<t tx="ekr.20071102163001.79">def getStringColor (self):
    return self._stringColor

</t>
<t tx="ekr.20071102163001.80">def getUndefinedSectionReferenceColor (self):
    return self._undefinedSectionNameColor

</t>
<t tx="ekr.20071102163001.81">def hasFootNodes (self):

    cp = self.c.currentPosition()
    t = cp.v.t
    if hasattr(t,"unknownAttributes"):
        uas = t.unknownAttributes
        if uas.has_key("footnodes"):
            fn = uas ["footnodes"]
            if fn: return True
    return False

</t>
<t tx="ekr.20071102163001.82">def insertUpdate (self,event):
    self.checkForLanguageChange(event)

</t>
<t tx="ekr.20071102163001.83">def notify (self):
    self.c.frame.body.editor.ekit.showInvisibles(self.c.showInvisibles)

</t>
<t tx="ekr.20071102163001.84">def removeUpdate (self,event):
    self.checkForLanguageChange(event)


</t>
<t tx="ekr.20071102163001.85">def setEditor (self,editor):
    self.editor = editor
    doc = editor.getDocument()
    doc.addDocumentListener(self)


</t>
<t tx="ekr.20071102163001.86">def showInvisibles (self):
    return self.c.showInvisibles

</t>
<t tx="ekr.20071102163001.87">def underline (self):
    return self._underline

</t>
<t tx="ekr.20071102163001.88">def useLineNumbers (self):
    return g.app.config.getBool(self.c,"use_line_numbering")

</t>
<t tx="ekr.20071102163001.89">def whichInvisible (self):
    return self._which_invisible

</t>
<t tx="ekr.20071102163001.90">class RecentVisitsMenuListener(sevent.MenuListener):

    def __init__ (self,menu,c,recent):
        self.menu = menu
        self.c = c
        self.recent = recent

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        menu = self.menu
        menu.removeAll()
        goNode = leoSwingBody.Editor.goNode
        for z in self.recent:
            if z:
                menu.add(goNode(z,self.c))
</t>
<t tx="ekr.20071102163001.91">@
The key to making:
    1. Autocompleter
    2. Line numbers
    3. Any any future floaters
work is in the use of the JLayeredPane.  The JLayeredPane is made for floating widgets on top of one another.


This allows the autocompleter to appear on top of the JTextPane when needed.  It also allows
the easy placement of the Line number label to the left.

The line number label was tried as a JTextPane to start with, this gave us numbers parralel to the editor.
But this seemed to introduce a scroll bug that became apparent when the editor had a large volume of lines in it.  My
assumption is that this was because of some event the Caret for the line number editor was executing when its contents
changed.  By moving to a Label that is drawn on my a method in the LeoView class this problem no longer presented itself,
mainly because a JLabel doesnt have a Cursor.  If that was the source of the problem.

The viewport is secretly tied to the JTextPane by a specialised jython JLayeredPane that returns the preferred size of the
JTextPane instead of itself.  This causes the JScrollPane to actually scroll with the editor.

To calculate the coordinates of a floater you need to do the minimum:
1. Translate the viewports visible rectangle into the JLayeredPanes coord system.
    2. Translate the JTextPane into the JLayeredPanes coord system.
    3. Do calculations based off of those two pieces of information.


@c
</t>
<t tx="ekr.20071102163001.92">def __init__( self, parent, c , body, x = 0, y = 0):

    self.c = c
    self.body = body
    wr = java.lang.ref.WeakReference( self )
    self.body.editors.append( wr )
    self.synchers = []
    self._parent = parent 
    self.frame = swing.JInternalFrame( "", 1, 1, 1, 1, 
                                      size = ( 400, 400 ) )
    self.frame.setFocusTraversalPolicy( c.frame.ftp )
    self._attached = True

    cpane = self.frame.getContentPane()
    self.tab_manager = TabManager()
    self.tab_manager.tabsToBottom()
    self.visible_informer = VisibleInformer( self.tab_manager.jtp )
    cpane.add( self.tab_manager.base, java.awt.BorderLayout.CENTER )
    self.editorlomanager = self.leoLayoutManager()
    self.epane = swing.JPanel()
    self.epane.setLayout( self.editorlomanager )
    self.frame.setFrameIcon( leoSwingBody.Editor.icon )

    self.initializeEditor()        
    self.initializeFont()
    &lt;&lt; add EditorKit&gt;&gt;

    #self.editor.addFocusListener( self.tFocusListener())
    self.editor.addMouseListener( leoSwingBody.UtilityRightClick( c , detach_retach = True, editor = self ) )
    self.addMinibuffer()
    self.swingmacs = SwingMacs.SwingMacs( self.editor, self.minibuffer, self.minilabel, c )
    c.frame.isMenuInitialized( self.createCommanderCommander )

    #self.swingmacs.addCommands( commandercommander, commandercommander.getCommands() )
    self.addCompleters()
    self.addMenus()    

    self.brackethighlighter = self.BracketHighlighter( self.editor, c ) # initializeCaret needs this to work
    self.initializeCaret()


    self.editor.setName( "Editor" )

    self.editor.getDocument().addDocumentListener( body )
    self.editor.addKeyListener( body )
    &lt;&lt; add autocompleter &gt;&gt;
    &lt;&lt; add scrollpane &gt;&gt;


    self.configureMedia()
    self.editor.addFocusListener( self )
    self.frame.setLocation( x, y )
    parent.add( self.frame, swing.JLayeredPane.DEFAULT_LAYER )
    self.initializeEditorColors()
    self.frame.visible = 1
    self.lastPosition = None
    self.chapter = None
    wm1 = WeakMethod( self, "chapterChanged" )
    wm2 = WeakMethod( self, "headlineChanged" )
    leoPlugins.registerHandler( "chapter-changed", wm1 )
    leoPlugins.registerHandler( "chapter-removed", wm1 )
    leoPlugins.registerHandler( "headline-editing-finished", wm2 )

    bd = self.ekit.getBorder()
    vpb = self.view.getViewportBorder()
    if vpb:
        bd = sborder.CompoundBorder( bd, vpb )
    self.view.setViewportBorder( bd )
    self.sync()
    self.chapter = c.chapters.current_chapter
    g.doHook( "editor-created", editor = self )







</t>
<t tx="ekr.20071102163001.93">self.cdeterminer = cdeterminer = leoSwingBody.Editor.ColorKeywordsProvider( self.c )
self.cdeterminer = weakref.proxy( cdeterminer )
#use_line_numbers = g.app.config.getBool( c, "use_line_numbering" )  
use_line_numbers = 0 
if use_line_numbers:
    pass
    #self.initializeLineNumbering()
else:
    self.numbers = None

#self.ekit = leoEditorKit( cdeterminer, self.numbers )
import leoEditorKit2
self.ekit = leoEditorKit2( self.editor, cdeterminer, leoSwingBody.Editor.icon )
self.editor.setEditorKit( self.ekit )
#self.editor.setDocument( ekit.createDefaultDocument() )
cdeterminer.setEditor( self.editor )
import JyLeoColorizer
self.jlc = JyLeoColorizer.JyLeoColorizer( self.editor, cdeterminer )
self.foldprotection = self.FoldProtector( self.editor, self.ekit )
self.editor.getDocument().setDocumentFilter( self.foldprotection )
#self.editor.getDocument().addUndoableEditListener( self.body )

</t>
<t tx="ekr.20071102163001.94">self.autocompleter = self.autolistener( self )
self.editor.getDocument().addDocumentListener( self.autocompleter )
self.editor.addKeyListener( self.autocompleter )
g.app.config.manager.addNotificationDef( "use_autocompleter", self.useAutocompleter )
self.useAutocompleter()



</t>
<t tx="ekr.20071102163001.95">spc = swing.ScrollPaneConstants
#self.view = swing.JScrollPane( layeredpane )
self.view = swing.JScrollPane( self.editor )
self.editorlomanager.jscrollpane = self.view
self.editor.addFocusListener( leoJSPFocusListener( self.view, self.c  ) )
self.view.setHorizontalScrollBarPolicy( swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER )
self._vport = vport = self.view.getViewport()
vport.addComponentListener( self.resizer2( self.editorlomanager ) )
vport.setScrollMode( vport.BLIT_SCROLL_MODE ) #fastest, removes alot of the flicker I saw
mwl = self.view.getMouseWheelListeners()[ 0 ]
self.editor.addMouseWheelListener( mwl )
self.frame.addMouseWheelListener( mwl )
self.epane.add( self.view )
#jtp.add( "Editor", self.epane )
self.tab_manager.add( "Editor", self.epane )
self.visible_informer.addCallback( self.epane, self.nowShowing )
#jtp.add( "Editor", self.view )
#cpane.add( self.view )</t>
<t tx="ekr.20071102163001.96">@others</t>
<t tx="ekr.20071102163001.97"># Just some methods the constructor calls to build the gui components.
</t>
<t tx="ekr.20071102163001.98">def addMenus (self):

    self.menu = swing.JMenuBar()
    self.frame.setJMenuBar(self.menu)
    self.gotoMenu = gm = swing.JMenu("Goto")
    recmen = swing.JMenu("Recent")
    self.recent = []
    recmen.addMenuListener(leoSwingBody.Editor.RecentVisitsMenuListener(recmen,self.c,self.recent))
    gm.add(recmen)
    self.menu.add(gm)
    self.configureGotoMenu(gm)

    self.bodyMenu = body = swing.JMenu("Body")
    self.menu.add(body)
    directives = swing.JMenu("Directives")
    self.directiveMenu(directives)
    #self.menu.add( directives )
    body.add(directives)
    self.addLanguageMenu(body)
    headline = swing.JMenu("Headline")
    self.headlineMenu(headline)
    self.menu.add(headline)
    isSR = swing.JMenu("Insert&lt;%s%s&gt;" % ('&lt;','&gt;'))
    self.insertSR(isSR)
    body.add(isSR)


    insPath = swing.JMenuItem("Insert @path With File Dialog")
    self.addInsertPath(insPath)
    body.add(insPath)

    #self.addFootNodeMenu( body )

    config = g.app.config
    wrap = config.getBool(self.c,"body_pane_wraps")
    self.ekit.setLineWrap(wrap)
    wrapmenuitem = swing.JCheckBoxMenuItem("Wrap Lines")
    wrapmenuitem.setState(wrap)
    def wrapcommand (event):
        source = event.getSource()
        wrap = source.getState()
        self.ekit.setLineWrap(wrap)
        if wrap:
            self.view.setHorizontalScrollBarPolicy(swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER)
        else: self.view.setHorizontalScrollBarPolicy(swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED)

    wrapmenuitem.actionPerformed = wrapcommand
    body.add(wrapmenuitem)
    if config.getBool(self.c,"use_text_undo"):
        umenu = swing.JMenuItem("")
        rmenu = swing.JMenuItem("")
        gtnu = swing.JMenuItem("Goto Next Undo Spot")
        gtnr = swing.JMenuItem("Goto Next Redo Spot")
        vunstack = swing.JMenuItem("Visualise Undo Stack")
        clear_undo = swing.JMenuItem("Clear Undo")
        self._node_undoer = leoSwingUndo.NodeUndoer(self.c,umenu,rmenu,gtnu,gtnr,vunstack,clear_undo,self.editor)
        #print self._node_undoer
        body.addSeparator()
        body.add(umenu)
        body.add(rmenu)
        body.addSeparator()
        body.add(gtnu)
        body.add(gtnr)
        body.addSeparator()
        body.add(vunstack)
        body.add(clear_undo)
    else:
        self._node_undoer = None

    self.viewMenu = vmenu = swing.JMenu("Views")
    self.menu.add(vmenu)
    jmi = swing.JCheckBoxMenuItem("CompositeView")
    vmenu.add(jmi)
    jmi.actionPerformed = self.addCompositeView


    self.helpmenu = swing.JMenu("Help")
    self.menu.add(self.helpmenu)
    self.helpmenu.add(self.smacs_help(self.c,self.swingmacs,"Keystrokes"))
    self.helpmenu.add(self.smacs_help(self.c,self.swingmacs,"Commands"))
    self.helpmenu.add(self.autocompleter_help())
    if hasattr(self.body,'ebm'):
        ccomp = self.body.ebm.getControlPanelComponent()
        self.menu.add(ccomp)


</t>
<t tx="ekr.20071102163001.99">def addMinibuffer (self):

    self.minilabel = swing.JLabel()
    self.minibuffer = minibuffer = swing.JTextField(15)
    frame = swing.JPanel()
    frame.setLayout(swing.BoxLayout(frame,swing.BoxLayout.X_AXIS))
    frame.add(self.minilabel)
    frame.add(minibuffer)
    frame.setName("Minibufferbackground")
    self.epane.add(frame) # awt.BorderLayout.SOUTH )
    self.editorlomanager.minibuffer = frame
    #cpane = self.frame.getContentPane()
    #cpane.add( frame, awt.BorderLayout.SOUTH )
</t>
<t tx="ekr.20071102163001.100">def addCompleters (self):

    config = g.app.config
    if config.getBool(self.c,"complete-&lt;"):
        self.swingmacs.addCompleter("&lt;","&gt;")
    if config.getBool(self.c,"complete-("):
        self.swingmacs.addCompleter("(",")")
    if config.getBool(self.c,"complete-["):
        self.swingmacs.addCompleter("[","]")
    if config.getBool(self.c,"complete-{"):
        self.swingmacs.addCompleter("{","}")
    if config.getBool(self.c,"complete-'"):
        self.swingmacs.addCompleter("'","'")
    if config.getBool(self.c,'complete-"'):
        self.swingmacs.addCompleter('"','"')
    if config.getBool(self.c,"add_tab_for-:"):
        self.swingmacs.addTabForColon(True)




</t>
<t tx="ekr.20071102163001.101">def initializeEditor (self):


    self.editor = self.leoJTextPane(self.c)
    self.editor.setLineColor()
    self.body._current_editor = self.editor
    manager = g.app.config.manager
    wm1 = WeakMethod(self.editor,"setLineColor")
    manager.addNotificationDef("highlight_current_line",wm1)
    manager.addNotificationDef("current_line_highlight_color",wm1)
</t>
<t tx="ekr.20071102163001.102">def initializeEditorColors (self):

    self.setEditorColors()
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setEditorColors")
    manager.addNotificationDef('body_text_foreground_color',wm1)
    manager.addNotificationDef('body_text_background_color',wm1)
    manager.addNotificationDef('body_selection_color',wm1)
    manager.addNotificationDef('body_text_selected_color',wm1)


</t>
<t tx="ekr.20071102163001.103">def initializeFont (self):

    self.setFont()
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setFont")
    manager.addNotificationDef("body_text_font_family",wm1)
    manager.addNotificationDef("body_text_font_size",wm1)
    manager.addNotificationDef("body_text_font_weight",wm1)

</t>
<t tx="ekr.20071102163001.104">def initializeCaret (self):

    self.setCaret()
    wm1 = WeakMethod(self,"setCaret")
    g.app.config.manager.addNotificationDef("which_caret",wm1)

</t>
<t tx="ekr.20071102163001.105">def initializeLineNumbering (self):

    fg, bg, cl = self.getLineNumberColors()
    #self.numbers = leoEditorKit.LeoNumberLabel( bg, fg, cl )
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setLineNumberColors")
    manager.addNotificationDef("line_number_background",wm1)
    manager.addNotificationDef("line_number_foreground",wm1)
    manager.addNotificationDef("line_number_current",wm1)

</t>
<t tx="ekr.20071102163001.106">def createCommanderCommander (self,menu):

    commandercommander = self.CommanderCommander(self.c,self.swingmacs,menu)
    self.swingmacs.addCommands(commandercommander,commandercommander.getAltXCommands())</t>
<t tx="ekr.20071102163001.107">@others
</t>
<t tx="ekr.20071102163001.108">def configureMedia (self):

    c = self.c
    use_background = g.app.config.getBool(c,"use_media_background")
    if use_background:
        try:
            background_which = g.app.config.getString(c,"media_background_type")
            if background_which == 'image':
                self.setBackgroundImage()
            elif background_which == 'movie':
                movie = g.app.config.getString(c,"movie_location@as-filedialog")
                if movie:
                    self.background = swing.JPanel()
                    self.background.setOpaque(False)
                    import EditorBackgroundMovie
                    ebm = EditorBackgroundMovie(movie,self.background)
                    if ebm.loadOk():
                        self.epane.add(self.background)
                        self.editorlomanager.media = self.background
                        #self.layeredpane.add( self.background, self.layeredpane.DEFAULT_LAYER )
                        #self._vport.addChangeListener( self._resizer )
                        self.editor.setOpaque(False)
                        vport = self.view.getViewport()
                        vport.setOpaque(False)
                        self.view.setOpaque(False)
                        self.ebm = ebm
                        #print self.epm
                        ebm.addControllerToMenu(self.menu)
                    else: self.background = None
        finally:
            if not hasattr(self,'background'):
                self.background = None
    else:
        self.background = None
</t>
<t tx="ekr.20071102163001.109">def setBackgroundImage (self,notification=None,handback=None):

    c = self.c
    alpha = g.app.config.getFloat(c,"background_alpha")
    if alpha == None: alpha = 1.0
    image_path = g.app.config.getString(c,"image_location@as-filedialog")
    if image_path:
        imfile = java.io.File(image_path)
        if imfile.exists():
            bimage = imageio.ImageIO.read(imfile)
            if not hasattr(self,'background'):
                self.background = EditorBackground(bimage,bimage.getWidth(),bimage.getHeight(),alpha)
                self.epane.add(self.background)

            #    self.layeredpane.add( self.background, self.layeredpane.DEFAULT_LAYER )
            #    self._vport.addChangeListener( self._resizer )
            self.editor.setOpaque(False)
            vport = self.view.getViewport()
            vport.setOpaque(False)
            self.view.setOpaque(False)
            #self.epane.setBackedWidget( self.view.getViewport() )
            #self.epane.setImage( bimage )
            #self.epane.setAlpha( alpha )
            self.editorlomanager.media = self.background
            g.app.config.manager.addNotificationDef("background_alpha",self.setBackgroundImage)
            g.app.config.manager.addNotificationDef("image_location@as-filedialog",self.setBackgroundImage)

            #else:
            #    #self.background.setBackground( bimage, bimage.getWidth(), bimage.getHeight(), alpha )
            #    #self.background.repaint()


</t>
<t tx="ekr.20071102163001.110">def useAutocompleter (self,notification=None,handback=None):

    use = g.app.config.getBool(self.c,"use_autocompleter")
    if use:
        self.autocompleter.on = 1
    else:
        self.autocompleter.on = 0
        self.autocompleter.hideAutoBox()</t>
<t tx="ekr.20071102163001.111">def setCaret (self,notification=None,handback=None):
    c = self.c
    if g.app.config.getString(c,"which_caret"):
        caret = g.app.config.getString(c,"which_caret")
        carets = {'Box': (self.SeeThroughBoxCaret,'box_color'),
                  'Underliner': (self.UnderlinerCaret,'underliner_color'),
                  'GhostlyLeo': (self.GhostlyLeoCaret,None),
                  'ImageCaret': (self.ImageCaret,None),
                  '&lt;none&gt;': (stext.DefaultCaret,None)}

        if caret == 'ImageCaret':
            try:
                path_to_image = g.app.config.getString(c,"path_to_caret_image@as-filedialog")
                ifile = java.io.File(path_to_image)
                cimage = imageio.ImageIO.read(ifile)
                #cicon = swing.ImageIcon( path_to_image )
                self.editor.setCaret(carets[caret](cimage))
            except java.lang.Exception, x:
                x.printStackTrace()
                g.es("Could not load image for caret")
        else:
            caret, color = carets [caret]
            args = None
            if color:
                color = g.app.config.getColor(c,color)
                color = getColorInstance(color)
                args = (color)
                self.editor.setCaret(caret(color))
            else:
                self.editor.setCaret(caret())
    self.editor.getCaret().addChangeListener(self.brackethighlighter)
</t>
<t tx="ekr.20071102163001.112">def setFont (self,notification=None,handback=None):

    config = g.app.config
    c = self.c
    family = config.get(c,"body_text_font_family","family")
    size = config.get(c,"body_text_font_size","size")
    weight = config.get(c,"body_text_font_weight","weight")
    slant = None
    font = config.getFontFromParams(c,"body_text_font_family","body_text_font_size",None,"body_text_font_weight")
    if font:
        self.editor.setFont(font)</t>
<t tx="ekr.20071102163001.113">def setEditorColors (self,notification=None,handback=None):

    c = self.c

    fg = g.app.config.getColor(c,'body_text_foreground_color')
    bg = g.app.config.getColor(c,'body_text_background_color')
    sc = g.app.config.getColor(c,'body_selection_color')
    stc = g.app.config.getColor(c,'body_text_selected_color')

    fg = getColorInstance(fg,awt.Color.GRAY)
    bg = getColorInstance(bg,awt.Color.WHITE)
    sc = getColorInstance(sc,awt.Color.GREEN)
    stc = getColorInstance(stc,awt.Color.WHITE)

    self.editor.setForeground(fg)
    self.editor.setBackground(bg)
    self.editor.setSelectionColor(sc)
    self.editor.setSelectedTextColor(stc)


</t>
<t tx="ekr.20071102163001.114">def getLineNumberColors (self):

    c = self.c

    bg = g.app.config.getColor(c,"line_number_background")
    fg = g.app.config.getColor(c,"line_number_foreground")
    cl = g.app.config.getColor(c,"line_number_current")
    try:
        bg = getColorInstance(bg)
        if bg == None: bg = awt.Color.BLACK
        fg = getColorInstance(fg)
        if fg == None: fg = awt.Color.RED
        cl = getColorInstance(cl)
        if cl == None: cl = awt.Color.YELLOW
    except:
        bg = awt.Color.BLACK
        fg = awt.Color.RED
        cl = awt.Color.YELLOW
    return fg, bg, cl

def setLineNumberColors (self,notification=None,background=None):

    fg, bg, cl = self.getLineNumberColors()
    if self.numbers:
        self.numbers.setBackground(bg)
        self.numbers.setForeground(fg)
        self.numbers.setCurrent(cl)

</t>
<t tx="ekr.20071102163001.115"></t>
<t tx="ekr.20071102163001.116">def sync (self,pos=None):

    try:
        if pos == None:
            pos = self.c.currentPosition()

        if pos in self.recent:
            self.recent.remove(pos)
        else:
            if len(self.recent) == 10:
                self.recent.pop()
        self.recent.insert(0,pos)

        if self.lastPosition:
            self.foldprotection.cacheFolds(self.lastPosition.v.t)
        self.lastPosition = pos.copy()
        hs = pos.headString()
        bs = pos.bodyString()
        #self.editor.setText( bs )
        doc = self.editor.getDocument()
        doc.setPosition(pos)
        #doc.sync( bs )
        body = self.c.frame.body
        try:
            body.ignore_insert = 1
            self.jlc.ignoreEvents()
            self.foldprotection.clearFolds()
            self.foldprotection.defoldViews()
            doc.remove(0,doc.getLength())
            doc.insertString(0,bs,None)
            self.frame.setTitle(hs)
            self.jlc.recolorizenow()
            self.foldprotection.restoreFolds(pos.v.t)
            if hasattr(self,'_node_undoer'):
                self._node_undoer.setNode(pos)
        finally:
            self.jlc.watchEvents()
            body.ignore_insert = 0
    except Exception, x:
        pass
        #x.printStackTrace()

</t>
<t tx="ekr.20071102163001.117">def nowShowing (self):

    self.body._current_editor = self.editor
    self.sync()
</t>
<t tx="ekr.20071102163001.118">@others</t>
<t tx="ekr.20071102163001.119">def configureGotoMenu (self,menu):
    oltraveler = leoSwingBody.Editor.outlinetraveler(menu,self.c)
    menu.addMenuListener(oltraveler)</t>
<t tx="ekr.20071102163001.120">def directiveMenu (self,menu):

    import leoColor
    directives = []
    for z in leoColor.leoKeywords:
        directives.append(z)
    directives.sort()
    InsertTextIntoBody = leoSwingBody.Editor.InsertTextIntoBody
    for z in directives:
        menu.add(InsertTextIntoBody(self.c,z))

</t>
<t tx="ekr.20071102163001.121">def headlineMenu (self,menu):

    import leoNodes
    tnode = leoNodes.tnode()
    v = leoNodes.vnode(self.c,tnode)
    def getValue (names,self=v):
        return names
    olFindAtFileName = v.findAtFileName
    v.findAtFileName = getValue
    names = v.anyAtFileNodeName()
    v.findAtFileName = olFindAtFileName
    names = list(names)
    names.sort()
    SetHeadline = leoSwingBody.Editor.SetHeadline
    self.addSR(menu)
    for z in names:
        menu.add(SetHeadline(self.c,z))

    rmvSymbol = leoSwingBody.Editor.rmvSymbol
    rS = rmvSymbol(self.c,'@')
    menu.add(rS)
    SetHeadlineToSelection = leoSwingBody.Editor.SetHeadlineToSelection
    sTaction = SetHeadlineToSelection(self.c,"Set Headline to Selection")
    menu.add(sTaction)

</t>
<t tx="ekr.20071102163001.122">def insertSR (self,menu):

    inSRMenuListener = leoSwingBody.Editor.inSRMenuListener
    menu.addMenuListener(inSRMenuListener(menu,self.c))</t>
<t tx="ekr.20071102163001.123">def addSR (self,menu):

    class aa(swing.AbstractAction):

        def __init__ (self,c):
            swing.AbstractAction.__init__(self,'toggle &lt;%s%s&gt;' % ('&lt;','&gt;'))
            self.c = c

        def actionPerformed (self,event):
            cp = self.c.currentPosition()
            hs = cp.headString()
            hs = hs.strip()
            if hs.startswith('&lt;%s' % '&lt;') and hs.endswith('&gt;%s' % '&gt;'):
                hs = hs [2:]
                hs = hs [: -2]
            else:
                hs = '&lt;%s%s%s&gt;' % ('&lt;',hs,'&gt;')

            self.c.beginUpdate()
            cp.setHeadString(hs)
            self.c.endUpdate()

    menu.add(aa(self.c))</t>
<t tx="ekr.20071102163001.124">def addLanguageMenu (self,pmenu):
    pass
@
    lmenu = swing.JMenu("language")
    kI = self.keywordInserter(lmenu,self.c)
    lmenu.addMenuListener(kI)
    pmenu.add(lmenu)
    lS = self.languageSetter(kI)
    pmenu.addMenuListener(lS)

</t>
<t tx="ekr.20071102163001.125">def addInsertPath (self,menu):

    def __insertHeadline (event):

        jfc = swing.JFileChooser()
        jfc.setFileSelectionMode(jfc.DIRECTORIES_ONLY)
        jfc.setDialogTitle("Select Directory for %s%s" % ("@","path"))
        jfc.setApproveButtonText("Select")
        result = jfc.showOpenDialog(self.c.frame.top)
        if result == jfc.APPROVE_OPTION:
            sfile = jfc.getSelectedFile()
            self.c.frame.body.insertAtInsertPoint("%s %s" % ("@path",sfile.getAbsolutePath()))


    menu.actionPerformed = __insertHeadline


</t>
<t tx="ekr.20071102163001.126">def addCompositeView (self,event):

    if not hasattr(self,'lcv'):
        import leoCompositeView
        jpanel = swing.JPanel(awt.BorderLayout())
        #self.jtab.addTab( "CompositeView", jpanel )
        #self.jtab.setSelectedComponent( jpanel )
        self.tab_manager.add("CompositeView",jpanel)
        self.lcv = lcv = leoCompositeView.CompositeView(self.c,jpanel)
        self.visible_informer.addCallback(jpanel,lambda: lcv.sync(force=1))
        self.body._current_editor = self.lcv.jtp
    else:
        parent = self.lcv.parent
        #if self.jtab.indexOfComponent( parent ) == -1:
        if not self.tab_manager.holdsComponent(parent):

            self.tab_manager.add("CompositeView",parent)
            #self.jtab.addTab( "CompositeView", parent )
            #self.jtab.setSelectedComponent( parent )
        else:
            #self.jtab.remove( parent )
            self.tab_manager.remove(parent)
</t>
<t tx="ekr.20071102163001.127">def addFlashCardView (self,event):

    import leoFlashCardView
    if not hasattr(self,'fcv'):
        jpanel = swing.JPanel(awt.BorderLayout())
        self.jtab.addTab("FlashCardView",jpanel)
        self.jtab.setSelectedComponent(jpanel)
        self.fcv = fcv = leoFlashCardView.FlashCardView(self.c,jpanel)
        self.visible_informer.addCallback(jpanel,lambda: fcv.sync(force=1))
    else:
        parent = self.fcv.parent
        if self.jtab.indexOfComponent(parent) == -1:
            self.jtab.addTab("FlashCardView",parent)
            self.jtab.setSelectedComponent(parent)
        else:
            self.jtab.remove(parent)
</t>
<t tx="ekr.20071102163001.128">def addFootNodeMenu (self,menu):

    menu.addSeparator()
    addfn = swing.JMenuItem("Add FootNode")
    menu.add(addfn)
    rmvfn = swing.JMenu("Remove FootNode")
    menu.add(rmvfn)
    fnoderemover = self.footnoderemover(rmvfn,self.c)
    rmvfn.addMenuListener(fnoderemover)

    def addFootNode (event,c):

        pos = c.currentPosition()
        t = pos.v.t
        if not hasattr(t,"unknownAttributes"):
            uas = t.unknownAttributes = {}
            fn = []
            uas ["footnodes"] = fn
        else:
            uas = t.unknownAttributes
            if uas.has_key("footnodes"):
                fn = uas ["footnodes"]
            else:
                fn = []
                uas ["footnodes"] = fn

        jd = swing.JDialog()
        jd.title = "Add a FootNode"
        cpane = jd.getContentPane()
        cpane.setLayout(awt.BorderLayout())
        jtf = swing.JTextField()
        tborder1 = sborder.TitledBorder("Title")
        jtf.setBorder(tborder1)
        cpane.add(jtf,awt.BorderLayout.NORTH)
        jta = swing.JTextArea()
        jsp = swing.JScrollPane(jta)
        tborder2 = sborder.TitledBorder("FootNode")
        jsp.setBorder(tborder2)
        cpane.add(jsp)
        jp = swing.JPanel()
        b1 = swing.JButton("Cancel")
        b1.actionPerformed = lambda event, jd = jd: jd.dispose()
        jp.add(b1)
        b2 = swing.JButton("Ok")
        def ok (event,fn,jtf,jta,jd,c=c):
            headline = jtf.getText()
            body = jta.getText()
            fn.append((headline,body))
            c.frame.body.editor.ekit.relayout()
            jd.dispose()
        b2.actionPerformed = lambda event, fn = fn, jtf = jtf, jta = jta, jd = jd, c = c: ok(event,fn,jtf,jta,jd,c)
        jp.add(b2)
        cpane.add(jp,awt.BorderLayout.SOUTH)
        jd.size = (250,250)
        jd.preferredSize = (250,250)
        #jd.pack()
        g.app.gui.center_dialog(jd)
        jd.show()
    addfn.actionPerformed = lambda event, c = self.c: addFootNode(event,c)






</t>
<t tx="ekr.20071102163001.129">def focusGained (self,fe):

    lasteditor = self.body.editor
    self.body.editor = self
    if self.lastPosition:
        if lasteditor != self:
            if self.chapter.isValid():
                cc = self.c.chapters.getChapter()
                if self.chapter != cc:
                    self.c.chapters.selectChapter(self.chapter)

                try:
                    self.c.beginUpdate() #This part if not done right can cause weird tree sync issues
                    lp = self.lastPosition
                    self.lastPosition = None
                    self.c.frame.tree.select(lp)
                finally:
                    self.c.endUpdate()
            else:
                self.sync()

    if hasattr(self,'_node_undoer'):
        self._node_undoer.setMenu()

def focusLost (self,fe):

    self.chapter = self.c.chapters.getChapter()
    if hasattr(self,'_node_undoer'):
        if self.lastPosition:
            self._node_undoer.checkSumNode(self.lastPosition.v.t)
</t>
<t tx="ekr.20071102163001.130">def detach (self,event=None):

    self._parent2 = jf = swing.JFrame()
    bounds = self.frame.getBounds()
    self._parent.remove(self.frame)
    jf.getContentPane().add(self.frame)
    jf.setBounds(bounds)
    km = self.editor.getKeymap()
    k_and_a = self.c.frame.menu.keystrokes_and_actions
    for z in k_and_a.keys():
        action = k_and_a [z]
        km.addActionForKeyStroke(z,action)
    self._attached = False
    jf.visible = 1
    self._parent.validate()
    self._parent.repaint()


def retach (self,event=None):

    parent = self._parent2
    self._parent2 = None
    parent.remove(self.frame)
    self._parent.add(self.frame)
    parent.dispose()
    parent.visible = 0
    self._attached = True
    self._parent.validate()
    self._parent.repaint()
    self.frame.validate()
    self.frame.repaint()



</t>
<t tx="ekr.20071102163001.131">def turnSelectionIntoNode (self):

    editor = self.editor
    txt = editor.getSelectedText()
    if txt == None: return
    spot = txt.find('\n')
    headline = txt [: spot]
    editor.replaceSelection("")
    c = self.c
    c.beginUpdate()
    cp = c.currentPosition()
    np = cp.insertAsLastChild()
    np.setHeadString(headline)
    np.setBodyStringOrPane(txt)
    c.endUpdate()</t>
<t tx="ekr.20071102163001.132">def insertTextIntoBody (self,txt):

    cpos = self.editor.getCaretPosition()
    start = swing.text.Utilities.getRowStart(self.editor,cpos)
    doc = self.editor.getStyledDocument()
    txt2 = doc.getText(start,cpos-start)
    start_text = []
    for z in txt2:
        if z.isspace():
            start_text.append(z)
        else:
            start_text.append(' ')

    indent = ''.join(start_text)

    lines = txt.split('\n')
    if len(lines) &gt; 1:
        for z in xrange(len(lines)-1):
            line = lines [z + 1]
            nwline = "%s%s" % (indent,line)
            lines [z + 1] = nwline
    itext = '\n'.join(lines)
    doc.insertString(cpos,itext,None)





</t>
<t tx="ekr.20071102163001.133">def splitNode (self):

    c = self.c
    editor = self.editor
    cpos = editor.getCaretPosition()
    start = swing.text.Utilities.getRowStart(editor,cpos)
    doc = editor.getDocument()
    nn_txt = doc.getText(start,doc.getLength()-start)
    doc.remove(start,doc.getLength()-start)
    c.beginUpdate()
    cp = c.currentPosition()
    nn = cp.insertAfter()
    nn.setBodyStringOrPane(nn_txt)
    c.selectPosition(nn)
    c.endUpdate()

    dc = DefCallable(lambda: c.frame.tree.editLabel(nn))
    ft = java.util.concurrent.FutureTask(dc)
    java.awt.EventQueue.invokeLater(ft)
</t>
<t tx="ekr.20071102163001.134">def sectionReferenceToWidget (self):

    c = self.c
    cp = c.currentPosition()
    bs = cp.bodyString()
    pattern = java.util.regex.Pattern.compile("&lt;"+"&lt;"+"[^&lt;&gt;]*&gt;"+"&gt;")

    children = {}
    for z in cp.children_iter(copy=True):
        children [z.headString()] = z


    matcher = pattern.matcher(java.lang.String(bs))
    results = []
    while matcher.find():
        result = matcher.toMatchResult()
        results.append(result)

    doc = self.editor.getDocument()
    for z in results:
        begin = z.start()
        end = z.end()
        sr = bs [begin: end]
@
        if sr in children:
            jtp = swing.JTextArea()
            child = children [sr]
            jtp.setText(child.bodyString())
            jb = swing.JButton("Mooo")
            mas = swing.text.SimpleAttributeSet()
            swing.text.StyleConstants.setComponent(mas,jb)
            swing.text.StyleConstants.setForeground(mas,java.awt.Color.RED)
            doc.setCharacterAttributes(begin,end-begin,mas,1)
            doc.insertString(0,"\n",mas)
@c




</t>
<t tx="ekr.20071102163001.135">def chapterChanged (self,tag,*args,**kwords):

    try:
        chapter = args [0] ['chapter']
        if tag == "chapter-changed":
            if self.c.frame.body.editor is self:
                cp = chapter.getCurrentPosition() ; rp = chapter.getRootPosition()
                if cp or rp:
                    self.sync()
        elif tag == "chapter-removed":
            if self.c.frame.body.editor is self:
                self.sync()
    except java.lang.Exception, x:
        pass
</t>
<t tx="ekr.20071102163001.136">def headlineChanged (self,tag,*args,**kwords):

    p = args [0] ['p']
    if self.lastPosition == p:
        self.frame.setTitle(p.headString())

</t>
<t tx="ekr.20071102163001.137">@others
</t>
<t tx="ekr.20071102163001.138">def splitVertically (self,event):

    widget = self.editor
    parent = widget.getParent()

</t>
<t tx="ekr.20071102163001.139">def createEditor (self):

    editor = self.leoJTextPane(self.c)
    editor.setLineColor()
    manager = g.app.config.manager
    manager.addNotificationDef("highlight_current_line",editor.setLineColor)
    manager.addNotificationDef("current_line_highlight_color",editor.setLineColor)
    cdeterminer = cdeterminer = leoSwingBody.Editor.ColorKeywordsProvider(self.c)

    use_line_numbers = g.app.config.getBool(c,"use_line_numbering")
    if use_line_numbers:
        #self.initializeLineNumbering()
        fg, bg, cl = self.getLineNumberColors()
        numbers = leoEditorKit.LeoNumberLabel(bg,fg,cl)
        #manager = g.app.config.manager
        #manager.addNotificationDef( "line_number_background", self.setLineNumberColors )
        #manager.addNotificationDef( "line_number_foreground", self.setLineNumberColors )
        #manager.addNotificationDef( "line_number_current", self.setLineNumberColors )
    else:
        numbers = None

    ekit = leoEditorKit(cdeterminer,numbers)
    editor.setEditorKit(ekit)
    cdeterminer.setEditor(editor)
    editor.getDocument().addUndoableEditListener(self.body)
    editor.addMouseListener(leoSwingBody.UtilityRightClick(c,detach_retach=True,editor=self))

    return editor</t>
<t tx="ekr.20071102163001.140">@
In general these are subclasses of java gui listeners.

In CPython and Tk you would be using callbacks most of the time, a def or a lambda.
</t>
<t tx="ekr.20071102163001.141">@
class resizer(aevent.ComponentAdapter,sevent.ChangeListener):
    '''This class keeps the Editor size in sync with the JLayeredPane.
       It also sets where the line numbers go and where, if present,
       a background image goes.'''
    def __init__ (self,editor,side='Left'):
        self.editor = editor
        self.viewPort = self.editor.view.getViewport()
        self.vsbar = self.editor.view.getVerticalScrollBar()
        self.side = side
    def componentResized (self,event):
        source = event.getSource()
        size = source.getSize()
        editor = self.editor.editor
        esize = editor.getSize()
        editor = self.editor.editor
        visRect = self.viewPort.getViewRect() #was once getVisibleRect, bad choice...
        if self.editor.numbers:
            numbers = self.editor.numbers
            lnsize = numbers.getSize()
            if lnsize.width == 0: lnsize.width = 30
            nswidth = size.width- lnsize.width
            nvwidth = visRect.width- lnsize.width
            if esize.height != size.height or esize.width not in (nvwidth,nswidth):
                if visRect.width &gt; 0:
                    size.width = nvwidth
                else:
                    size.width = nswidth
                editor.setSize(size)
                if self.side == 'Left':
                    editor.setLocation(lnsize.width,0)
                else:
                    editor.setLocation(0,0)
                    numbers.setLocation(size.width,0)
            numsize = numbers.getSize()
            nlocation = numbers.getLocation()
            esize = editor.getSize()
            edheight = esize.height
            edwidth = esize.width
            lnsize.height = edheight
            if numsize.height &lt; lnsize.height:
                numbers.setSize(lnsize)
                if self.side == 'Left':
                    numbers.setLocation(0,0)
                else:
                    numbers.setLocation(edwidth,0)
        else:
            self.editor.editor.setSize(size)
            self.editor.editor.setLocation(0,0)
        if self.editor.background:
            self.stateChanged(None)


    def stateChanged (self,event):
        editor = self.editor.editor
        background = self.editor.background
        #visRect = editor.getVisibleRect()
        visRect = self.viewPort.getViewRect()
        x = editor.getX()
        minus = x
        if x == 0 and self.editor.numbers != None:
            minus = self.editor.numbers.getSize().width
        background.setSize(visRect.width-minus,visRect.height)
        background.setLocation(x,visRect.y)
        self.editor.layeredpane.moveToBack(background)</t>
<t tx="ekr.20071102163001.142">class resizer2(aevent.ComponentAdapter):

    def __init__ (self,layoutmanager):
        aevent.ComponentAdapter.__init__(self)
        self.layoutmanager = layoutmanager

    def componentResized (self,event):
        self.layoutmanager.layoutMedia()</t>
<t tx="ekr.20071102163001.143">class goNode(swing.AbstractAction):
    def __init__ (self,pos,c):
        swing.AbstractAction.__init__(self,pos.headString())
        self.pos = pos.copy()
        self.c = c

    def actionPerformed (self,event):

        self.c.frame.tree.select(self.pos)</t>
<t tx="ekr.20071102163001.144">class outlinetraveler(sevent.MenuListener):

    def __init__ (self,menu,c):
        self.menu = menu
        self.c = c

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        count = self.menu.getMenuComponentCount()
        for z in xrange(1,count):
            self.menu.remove(1)

        cp = self.c.currentPosition()
        self._addMenu("Parents",self.menu,cp.parents_iter(),cp)
        self._addMenu("Siblings",self.menu,cp.siblings_iter(),cp)
        self._addMenu("Children",self.menu,cp.children_iter(),cp)

    def _addMenu (self,name,menu,iterator,cp):

        goNode = leoSwingBody.Editor.goNode
        gmenu = swing.JMenu(name)
        shouldAdd = True
        for z in iterator:
            if shouldAdd:
                if not cp == z:
                    shouldAdd = False
                    menu.add(gmenu)
            if not cp == z:
                gmenu.add(goNode(z,self.c))
            else:
                gmenu.addSeparator()

</t>
<t tx="ekr.20071102163001.145">class footnoderemover(sevent.MenuListener):

    def __init__ (self,menu,c):
            self.menu = menu
            self.c = c

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        self.menu.removeAll()
        #count = self.menu.getMenuComponentCount()
        #for z in xrange( 1 , count ):
        #    self.menu.remove( 1 )

        pos = self.c.currentPosition()
        t = pos.v.t
        if hasattr(t,"unknownAttributes"):
            uas = t.unknownAttributes
            if uas.has_key("footnodes"):
                footnodes = uas ["footnodes"]
                def rmv (item,footnodes=footnodes,c=self.c):
                    footnodes.remove(item)
                    c.frame.body.editor.ekit.relayout()

                for x in xrange(len(footnodes)):
                    fnood = footnodes [x]
                    jmi = swing.JMenuItem(fnood[0])
                    jmi.actionPerformed = lambda event, item = fnood: rmv(item)
                    self.menu.add(jmi)

</t>
<t tx="ekr.20071102163001.146">@
class keywordInserter(sevent.MenuListener):
    def __init__ (self,menu,c):
        self.menu = menu
        self.c = c
        self.lastlanguage = None
    def setLanguageName (self):
        cp = self.c.currentPosition()
        self.language = language = g.scanForAtLanguage(self.c,cp)
        self.menu.setText(language)
    def menuCanceled (self,event):
        pass
    def menuDeselected (self,event):
        pass
    def menuSelected (self,event):
        #cp = self.c.currentPosition()
        #language = g.scanForAtLanguage( self.c, cp )
        language = self.language
        if language == self.lastlanguage: return
        self.lastlanguage = language
        print dir(leoLanguageManager.LanguageManager)
        if language == None:
            m = leoLanguageManager.LanguageManager.python_tokens
        else:
            m = getattr(leoLanguageManager.LanguageManager,"%s_tokens" % language)

        m.sort()
        self.menu.removeAll()
        for z in m:
            self._addInserter(z)
    def _addInserter (self,name):
        self.menu.add(leoSwingBody.Editor.InsertTextIntoBody(self.c,name))

class languageSetter(sevent.MenuListener):
    def __init__ (self,kWI):
        self._kWI = kWI
    def menuCanceled (self,event):
        pass
    def menuDeselected (self,event):
        pass
    def menuSelected (self,event):
        self._kWI.setLanguageName()
</t>
<t tx="ekr.20071102163001.147">class smacs_help(swing.AbstractAction):

    class clz(swing.AbstractAction):
        def __init__ (self,tl):
            swing.AbstractAction.__init__(self,"Close")
            self.tl = tl


        def actionPerformed (self,event):
            self.tl.visible = 0
            self.tl.dispose()

    def __init__ (self,c,emacs,which):

        if which == 'Keystrokes':
            swing.AbstractAction.__init__(self,"Emacs Keystrokes")
        else:
            swing.AbstractAction.__init__(self,"Emacs Commands")

        self.emacs = weakref.proxy(emacs)
        self.which = which
        fg = g.app.config.getColor(c,'body_text_foreground_color')
        bg = g.app.config.getColor(c,'body_text_background_color')
        sc = g.app.config.getColor(c,'body_selection_color')
        stc = g.app.config.getColor(c,'body_text_selected_color')

        self.fg = getColorInstance(fg,awt.Color.GRAY)
        self.bg = getColorInstance(bg,awt.Color.WHITE)
        self.sc = getColorInstance(sc,awt.Color.GREEN)
        self.stc = getColorInstance(stc,awt.Color.WHITE)

    def actionPerformed (self,event):

        tl = swing.JFrame(title=self.which)
        ta = swing.JTextArea()
        ta.setForeground(self.fg)
        ta.setBackground(self.bg)
        ta.setSelectionColor(self.sc)
        ta.setSelectedTextColor(self.stc)
        ta.setEditable(False)
        ta.setLineWrap(True)
        sp = swing.JScrollPane(ta)
        tl.getContentPane().add(sp)
        if self.which == 'Keystrokes':
            ta.setText(self.emacs.getHelp())
        else:

            ta.setText(self.emacs.ax.getCommandHelp())
        gui = g.app.gui


        cbutt = swing.JButton(self.clz(tl))
        tl.getContentPane().add(cbutt,awt.BorderLayout.SOUTH)
        tkit = awt.Toolkit.getDefaultToolkit()
        size = tkit.getScreenSize()
        tl.setSize(size.width/2,size.height/2)
        tl.setPreferredSize(tl.getSize())
        x, y = g.app.gui._calculateCenteredPosition(tl)
        tl.setLocation(x,y)
        ta.setCaretPosition(0)
        tl.visible = 1


</t>
<t tx="ekr.20071102163001.148">class autocompleter_help(swing.AbstractAction):

    def __init__ (self):
        swing.AbstractAction.__init__(self,"How to use the Autocompleter")

    def getText (self):

        htext = '''
        The Autcompleter appears upon typing of the '.' character.  Upon
        typing this character an in memory database is searched for the matching prefix.
        For example:
            object.toString  appears in a node.
            Typing 'object.' will bring the autocompleter box up with 'toString' as an option.

            Keystrokes that manipulate the autobox:
            Ctrl - this inserts the currently selected word
            Alt-Up, Alt-Down - these move the selection up and down.
            Esc - desummons the autobox

        The autobox will select the best prefix you have typed so far.  To extend the last example:
        typing 'to' will select 'toString'.  It will not enter the text until the user types 'Ctrl'
        or selects an item with the mouse.'''

        return htext

    def actionPerformed (self,event):
        tl = swing.JFrame(title='Autocompleter Help')
        ta = swing.JTextArea()
        ta.setEditable(False)
        sp = swing.JScrollPane(ta)
        tl.getContentPane().add(sp)
        #ta.setText( self.emacs.getHelp() )
        ta.setText(self.getText())
        gui = g.app.gui
        tl.setSize(600,400)
        spot = gui._calculateCenteredPosition(tl)
        tl.setLocation(spot[0],spot[1])
        class clz(swing.AbstractAction):
            def __init__ (self):
                swing.AbstractAction.__init__(self,"Close")
            def actionPerformed (self,event):
                tl.visible = 0
                tl.dispose()
        cbutt = swing.JButton(clz())
        tl.getContentPane().add(cbutt,awt.BorderLayout.SOUTH)
        tl.visible = 1</t>
<t tx="ekr.20071102163001.149">class FoldProtector(stext.DocumentFilter):

    cachedfolds = {}

    def __init__ (self,editor,ekit):
        stext.DocumentFilter.__init__(self)
        self.folds = []
        self.ekit = ekit
        self.editor = editor
        self.doc = editor.getDocument()
        self.editor.addMouseListener(self.Defolder(self))

    def cacheFolds (self,t):
        if self.folds:
            for z in self.folds:
                z.persist(self.doc)
            self.cachedfolds [t] = self.folds

    def defoldViews (self):
        self.ekit.defoldViews()

    def restoreFolds (self,t):
        if self.cachedfolds.has_key(t):
            self.folds = self.cachedfolds [t]
            doc = self.editor.getDocument()
            for x in xrange(len(self.folds)):
                z = self.folds [x]
                if z.restore(doc):
                    self.foldWithoutAdding(z.pos1,z.pos2)
                else:
                    self.folds.remove(z)
                    g.es("Removing Fold(%s,%s), no longer valid" % (z.pos1,z.pos2),color="red")
        else:
            self.folds = []

    def foldSelection (self):

        start = self.editor.getSelectionStart()
        end = self.editor.getSelectionEnd()
        if start == end: return
        if start &gt; end:
            s1 = start
            start = end
            end = s1
        cp = self.editor.getCaretPosition()
        self.editor.setCaretPosition(cp)
        self.editor.moveCaretPosition(cp)
        paragraph1 = stext.Utilities.getParagraphElement(self.editor,start)
        paragraph2 = stext.Utilities.getParagraphElement(self.editor,end)
        self.fold(paragraph1.getStartOffset(),paragraph2.getEndOffset()-1)


    def fold (self,start,end):

        fold = self.addFold(start,end,self.editor)
        self.ekit.fold(fold.pos1,fold.pos2)
        start = fold.pos1.getOffset() ; end = fold.pos2.getOffset()
        for z in copy.copy(self.folds):
            if z == fold: continue
            test1 = z.pos1.getOffset()
            test2 = z.pos2.getOffset()
            if start &lt;= test1 and end &gt; test1:
                self.folds.remove(z) #the folds are now the same


    def foldWithoutAdding (self,pos1,pos2):
        self.ekit.fold(pos1,pos2)

    def areLinesInFold (self,start,end):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start2 &lt;= start and end2 &gt;= end: return True
        return False

    def doLinesIntersectFold (self,start,end):

        doc = self.doc
        s = doc.getParagraphElement(start)
        e = doc.getParagraphElement(end)
        for z in self.folds:
            p1 = doc.getParagraphElement(z.pos1.getOffset())
            p2 = doc.getParagraphElement(z.pos2.getOffset())
            while p1 != p2:
                if p1 == e or p1 == s: return True
                p1 = doc.getParagraphElement(p1.getEndOffset())
            else:
                if p1 == e or p1 == s: return True
        return False

    def areLinesSurroundingFold (self,start,end):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start &lt;= start2 and end &gt;= end2: return True
        return False

    def getFold (self,start,end):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start2 &lt;= start and end2 &gt;= end: return z
        return None

    def isFolded (self,x,y):
        return self.ekit.isFolded(x,y)

    def isXInIconArea (self,x):

        i = self.ekit.getFoldIconX()
        if i &gt;= x: return True
        return False

    def removeFold (self,fold):
        self.unfold(fold.pos1,fold.pos2)
        self.folds.remove(fold)

    def unfold (self,pos1,pos2):
        self.ekit.unfold(pos1,pos2)

    def unfoldSpot (self,x,y):

        i = self.editor.viewToModel(awt.Point(x,y))
        for x in xrange(len(self.folds)):
            z = self.folds [x]
            if i &gt;= z.pos1.getOffset() and i &lt;= z.pos2.getOffset():
                self.unfold(z.pos1,z.pos2)
                self.folds.remove(z)
                break

    def addFold (self,start,end,editor):

        doc = editor.getDocument()
        pos1 = doc.createPosition(start)
        pos2 = doc.createPosition(end)
        fold = self.Fold(pos1,pos2)
        self.folds.append(fold)
        return fold

    def clearFolds (self):
        self.folds = []


    @others





</t>
<t tx="ekr.20071102163001.150">def insertString (self,fb,offset,data,attr):

    if self.folds:
        for x in xrange(len(self.folds)):
            z = self.folds [x]
            if not z.isInsertLegal(offset,fb.getDocument()):
                return

    fb.insertString(offset,data,attr)

def remove (self,fb,offset,length):

    if self.folds:
        for z in self.folds:
            if not z.isRemoveLegal(offset,length,fb.getDocument()):
                return
    fb.remove(offset,length)

def replace (self,fb,offset,length,text,attrs):

    if self.folds:
        for x in xrange(len(self.folds)):
            z = self.folds [x]
            if not z.isRemoveLegal(offset,length,fb.getDocument()):
                return
    fb.replace(offset,length,text,attrs)</t>
<t tx="ekr.20071102163001.151">def moveSelectionUp (self):

    start = self.editor.getSelectionStart()
    end = self.editor.getSelectionEnd()
    if (self.areLinesSurroundingFold(start,end) or self.doLinesIntersectFold(start,end)): return
    if start &gt; end:
        s1 = start
        start = end
        end = start
    doc = self.editor.getDocument()
    p1 = doc.getParagraphElement(start)
    p2 = doc.getParagraphElement(end)
    above = doc.getParagraphElement(p1.getStartOffset()-1)
    &lt;&lt; move partial selection &gt;&gt;

    if (self.areLinesInFold(above.getStartOffset(),above.getEndOffset()-1)):
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        fold = self.getFold(above.getStartOffset(),above.getEndOffset()-1)
        self.removeFold(fold)
        fstart = fold.pos1.getOffset()
        fend = fold.pos2.getOffset()
        txt = doc.getText(start,end-start)
        txt2 = doc.getText(fstart,fend-fstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(fstart,end-fstart)
        nwtxt = "%s\n%s" % (txt,txt2)
        doc.insertString(fstart,nwtxt,None)
        self.fold(fstart+len(txt)+1,end)
        para = doc.getParagraphElement(fstart)
        para2 = doc.getParagraphElement(fstart+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)

    else:
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        txt = doc.getText(start,end-start)
        sstart = above.getStartOffset()
        txt2 = doc.getText(sstart,above.getEndOffset()-sstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(sstart,end-sstart)
        txt3 = "%s\n%s" % (txt,txt2)
        doc.insertString(sstart,txt3,None)
        para = doc.getParagraphElement(sstart)
        para2 = doc.getParagraphElement(sstart+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)


</t>
<t tx="ekr.20071102163001.152">if p1.getStartOffset() != start or p2.getEndOffset() -1 != end:
    cp = self.editor.getCaretPosition()
    cpstart = True
    if cp == end:
        cpstart = False
    txt = doc.getText(start,end-start)
    if not txt.endswith("\n"): txt = txt + "\n"
    self.editor.replaceSelection("")
    pstart = p1.getStartOffset()
    doc.insertString(p1.getStartOffset(),txt,None)
    para = doc.getParagraphElement(pstart)
    para2 = doc.getParagraphElement(pstart+len(txt)-1)
    if cpstart:
        self.editor.setCaretPosition(para2.getEndOffset()-1)
        self.editor.moveCaretPosition(para.getStartOffset())
    else:
        self.editor.setCaretPosition(para.getStartOffset())
        self.editor.moveCaretPosition(para2.getEndOffset()-1)
    return</t>
<t tx="ekr.20071102163001.153">def moveSelectionDown (self):

    start = self.editor.getSelectionStart()
    end = self.editor.getSelectionEnd()
    if (self.areLinesSurroundingFold(start,end) or self.doLinesIntersectFold(start,end)): return
    if start &gt; end:
        s1 = start
        start = end
        end = start
    doc = self.editor.getDocument()
    p1 = doc.getParagraphElement(start)
    p2 = doc.getParagraphElement(end)
    below = doc.getParagraphElement(p2.getEndOffset())
    &lt;&lt; move partial selection &gt;&gt;
    if (self.areLinesInFold(below.getStartOffset(),below.getEndOffset())):
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        fold = self.getFold(below.getStartOffset(),below.getEndOffset())
        self.removeFold(fold)
        fstart = fold.pos1.getOffset()
        fend = fold.pos2.getOffset()
        txt = doc.getText(start,end-start)
        txt2 = doc.getText(fstart,fend-fstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(start,(fold.pos2.getOffset()-start))
        nwtxt = "%s\n%s" % (txt2,txt)
        doc.insertString(start,nwtxt,None)
        self.fold(start,start+len(txt2))
        para = doc.getParagraphElement(start+len(txt2)+1)
        para2 = doc.getParagraphElement(start+len(txt2)+1+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)
    else:
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        txt = doc.getText(start,end-start)
        sstart = below.getStartOffset()
        txt2 = doc.getText(sstart,below.getEndOffset()-sstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(start,(below.getEndOffset()-start)-1)
        txt3 = "%s\n%s" % (txt2,txt)
        doc.insertString(start,txt3,None)
        para = doc.getParagraphElement(start+len(txt2)+1)
        para2 = doc.getParagraphElement(start+len(txt2)+1+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)</t>
<t tx="ekr.20071102163001.154">if p1.getStartOffset() != start or p2.getEndOffset() -1 != end:
    cp = self.editor.getCaretPosition()
    cpstart = True
    if cp == end:
        cpstart = False
    txt = doc.getText(start,end-start)
    if not txt.endswith("\n"): txt = txt + "\n"
    self.editor.replaceSelection("")
    pend = p2.getEndOffset()
    doc.insertString(p2.getEndOffset(),txt,None)
    para = doc.getParagraphElement(pend+1)
    para2 = doc.getParagraphElement(pend+len(txt)-1)
    if cpstart:
        self.editor.setCaretPosition(para2.getEndOffset()-1)
        self.editor.moveCaretPosition(para.getStartOffset())
    else:
        self.editor.setCaretPosition(para.getStartOffset())
        self.editor.moveCaretPosition(para2.getEndOffset()-1)

    return</t>
<t tx="ekr.20071102163001.155">class Fold:
    def __init__ (self,pos1,pos2):
        self.pos1 = pos1
        self.pos2 = pos2
        self.text = None

    def persist (self,doc):
        self.pos1 = self.pos1.getOffset()
        self.pos2 = self.pos2.getOffset()
        self.text = doc.getText(self.pos1,self.pos2-self.pos1)

    def restore (self,doc):
        p1, p2 = self.pos1, self.pos2
        if doc.getLength() &lt; p2:
            return False
        self.pos1 = doc.createPosition(self.pos1)
        self.pos2 = doc.createPosition(self.pos2)
        pelement1 = doc.getParagraphElement(p1)
        pelement2 = doc.getParagraphElement(p2)
        if pelement1.getStartOffset() != p1 or pelement2.getEndOffset() -1 != p2:
            return False
        testtext = doc.getText(p1,p2-p1)
        text = self.text ; self.text = None
        return text == testtext

    def isInsertLegal (self,offset,doc):

        e = doc.getParagraphElement(offset)
        p1 = doc.getParagraphElement(self.pos1.getOffset())
        p2 = doc.getParagraphElement(self.pos2.getOffset())
        if p1 == e or p2 == e: return False
        while p1 != p2:
            if p1 == e: return False
            p1 = doc.getParagraphElement(p1.getEndOffset())
        else:
            if p1 == e: return False
        return True

    def isRemoveLegal (self,offset,length,doc):

        p1 = doc.getParagraphElement(self.pos1.getOffset())
        p2 = doc.getParagraphElement(self.pos2.getOffset())
        start = doc.getParagraphElement(offset)
        end = doc.getParagraphElement(offset+length)
        if start == p1 or start == p2: return False
        if end == p1 or end == p2: return False
        while start != end:
            if start == p1 or start == p2: return False
            start = doc.getParagraphElement(start.getEndOffset())
        else:
            if start == p1 or start == p2: return False

        return True
</t>
<t tx="ekr.20071102163001.156">class Defolder(aevent.MouseAdapter):
    def __init__ (self,fp):
        aevent.MouseAdapter.__init__(self)
        self.fp = fp

    def mouseClicked (self,event):

        x = event.getX()
        y = event.getY()
        if event.getButton() == event.BUTTON1:
            if self.fp.isFolded(x,y) and self.fp.isXInIconArea(x):
                self.fp.unfoldSpot(x,y)</t>
<t tx="ekr.20071102163001.157">class CommanderCommander:

    def __init__ (self,c,emacs,menu):

        self.c = c
        self.emacs = weakref.proxy(emacs)
        f = c.frame
        self.nodes = {}
        self.mode = 0
        self.tab_completer = None
        self.last_command = None
        self.name = "CommanderCommander"
        self.setupCommands(menu)
        self.addHelp()


    def getAltXCommands (self):
        return self.commands.keys()

    def __call__ (self,event,command):

        if self.mode == 1:
            if command == 'Enter':
                self.gotoNode2(event)
                self.last_command = None
                #self.emacs.keyboardQuit( event )
                return True
            elif command == 'Tab' and self.tab_completer:

                txt = self.emacs.minibuffer.getText()
                if self.last_command == None or not txt.startswith(self.last_command):
                    txt = self.emacs.minibuffer.getText()
                    fnd = self.tab_completer.lookFor(txt)
                    if fnd:
                        self.last_command = txt
                        self.emacs.minibuffer.setText(self.tab_completer.getNext())
                else:
                    self.emacs.minibuffer.setText(self.tab_completer.getNext())
                return True
            else:
                self.emacs.eventToMinibuffer(event)
                return True

        quit = self.commands [command] ()
        if quit == None:
            self.emacs.keyboardQuit(event)
        return True

    def getName (self):
        return self.name

    @others

</t>
<t tx="ekr.20071102163001.158">def setupCommands (self,menu):

    c = self.c
    f = c.frame
    self.commands = menu.names_and_commands
    self.commands ["goto node"] = self.gotoNode1



def addHelp (self):

    addhelp = ['Menu Commands:',
                 '-----------------',
    		         'You can execute any Menu command by entering its text',
                 'in the minibuffer.  For example:',
                 'Alt-x',
                 'Open Python Window',
                 '',
                 'will open a Python Window.  See Menus for complete list.',
                 '',
                 '',
                 'Additional Commands:',
                 '---------------------',
                 'These are Leo based commands.',
                 '',
                 'goto node --- will ask the user for which node to goto',
                 'and will take the user to it.'] #we don't do triple strings because it doesn't format right because of Leo output
    addhelp = "\n".join(addhelp)
    self.emacs.addCommandHelp(addhelp)</t>
<t tx="ekr.20071102163001.159">def gotoNode1 (self):

    self.nodes = {}
    cp = self.c.currentPosition()
    for z in cp.allNodes_iter(copy=True):
        hs = z.headString()
        if self.nodes.has_key(hs):
            self.nodes [hs].append(z)
        else:
            self.nodes [hs] = [z,]
    self.tab_completer = self.emacs.TabCompleter(self.nodes.keys())

    self.emacs.setCommandText("Goto Which Node:")
    self.emacs.minibuffer.setText("")
    self.emacs._stateManager.setState(self)
    self.mode = 1
    return True</t>
<t tx="ekr.20071102163001.160">def gotoNode2 (self,event):

    self.mode = 0
    self.tab_completer = None
    node = self.emacs.minibuffer.getText()
    self.emacs.keyboardQuit(event)
    if self.nodes.has_key(node):
        c = self.c
        c.beginUpdate()
        nlist = self.nodes [node]
        if len(nlist) &gt; 1:
            jf = swing.JDialog()
            jf.setLayout(awt.BorderLayout())
            jf.setModal(True)
            jf.title = "Choose a Node"
            table = swing.JTable()
            table.setSelectionMode(swing.ListSelectionModel.SINGLE_SELECTION)
            table.setAutoResizeMode(table.AUTO_RESIZE_OFF)
            class kl(aevent.KeyAdapter):
                def keyPressed (self,event):
                    if event.getKeyCode() == event.VK_ENTER:
                        jf.dispose()

            table.addKeyListener(kl())
            jsp = swing.JScrollPane(table)
            jf.add(jsp,awt.BorderLayout.CENTER)
            dtm = table.getModel()
            dtm.addColumn("Node")
            dtm.addColumn("Level")
            dtm.addColumn("Parents")
            longest_parents = "Parents"
            for z in nlist:
                row = []
                row.append(z.headString())
                row.append(z.level())
                ps = ""
                p = z.getParent()
                while p:
                    ps = "%s --&gt;%s" % (p.headString(),ps)
                    p = p.getParent()
                row.append(ps)
                if len(ps) &gt; len(longest_parents): longest_parents = ps
                dtm.addRow(row)

            table.setColumnSelectionAllowed(False)
            table.setRowSelectionInterval(0,0)
            cm = table.getColumn("Node")
            fm = table.getFontMetrics(table.getFont())
            w = fm.stringWidth(z.headString())
            cm.setPreferredWidth(w)

            cm = table.getColumn("Level")
            w = fm.stringWidth("Level")
            cm.setPreferredWidth(w)

            cm = table.getColumn("Parents")
            w = fm.stringWidth(longest_parents)
            cm.setPreferredWidth(w)


            height = table.getRowHeight()
            size = jsp.getPreferredSize()
            size.height = height * 6
            jsp.setPreferredSize(size)
            cb = swing.JButton("Select")
            cb.actionPerformed = lambda event: jf.dispose()
            p = swing.JPanel()
            p.add(cb)
            jf.add(p,awt.BorderLayout.SOUTH)
            jf.pack()
            g.app.gui.center_dialog(jf)
            jf.show()
            sr = table.getSelectedRow()
            if sr != -1:
                c.selectPosition(nlist[sr])


        else:
            c.selectPosition(nlist[0])
        c.endUpdate()
    else:
        self.emacs.setCommandText("%s does not exits" % node)
    self.nodes = {}</t>
<t tx="ekr.20071102163001.161">class BracketHighlighter(sevent.ChangeListener,sevent.DocumentListener):

    @others



</t>
<t tx="ekr.20071102163001.162">def __init__ (self,editor,c): #, color ):

    self._jtc = editor
    self.c = c
    self._jtc.getDocument().addDocumentListener(self)
    self.highlight_painter = None #stext.DefaultHighlighter.DefaultHighlightPainter( color )
    self.highlighting = False
    self.tag = None
    self.iFind = False
    self.matchers = {'{': ('{','}'),
                          '}': ('{','}'),
                          '(': ('(',')'),
                          ')': ('(',')'),
                          '[': ('[',']'),
                          ']': ('[',']'),
                          '&lt;': ('&lt;','&gt;'),
                          '&gt;': ('&lt;','&gt;'),
                          }

    self._nomatch = (None,None)
    self.match_bracket = 0
    self.setBracketMatch()
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setBracketMatch")
    manager.addNotificationDef("highlight_brackets",wm1)
    manager.addNotificationDef("highlight_brackets_color",wm1)


</t>
<t tx="ekr.20071102163001.163">def changedUpdate (self,event):
    pass

def insertUpdate (self,event):

    doc = event.getDocument()
    len = event.getLength()
    where = event.getOffset()
    self.findBracket(where,doc,doc.getLength())
    self.iFind = True

def removeUpdate (self,event):
    pass</t>
<t tx="ekr.20071102163001.164">def stateChanged (self,event):

    jtc = self._jtc
    dot = jtc.getCaretPosition()
    doc = jtc.getDocument()
    dlen = doc.getLength()
    self.findBracket(dot,doc,dlen)</t>
<t tx="ekr.20071102163001.165">def findBracket (self,dot,doc,dlen):

    if not self.match_bracket: return
    jtc = self._jtc
    highlighter = jtc.getHighlighter()
    if self.iFind:
        self.iFind = False
        return
    if self.highlighting:
        highlighter.removeHighlight(self.tag)
        self.highlighting = False

    if dot &gt;= dlen:
        return
    else:
        c = doc.getText(dot,1)
        first, last = self.matchers.get(c,self._nomatch)
        if not first: return
        if c == first:
            txt = jtc.getText()
            i = self.forwardFind(txt[dot:],first,last) #we must include the first bracket for the find functions
            if i != -1:
                self.tag = highlighter.addHighlight(dot+i,dot+i+1,self.highlight_painter)
                self.highlighting = True
        elif c == last:

            txt = jtc.getText(0,dot+1) #we must include the first bracket for the find functions
            i = self.backwardFind(txt,first,last)
            if i != -1:
                self.tag = highlighter.addHighlight(i,i+1,self.highlight_painter)
                self.highlighting = True
</t>
<t tx="ekr.20071102163001.166">def forwardFind (self,txt,first,last):

    fbc = 0
    for z in xrange(len(txt)):
        c = txt [z]
        if c == first:
            fbc += 1
            continue
        elif c == last:
            if fbc:
                fbc -= 1
            if not fbc:
                return z

    return-1</t>
<t tx="ekr.20071102163001.167">def backwardFind (self,txt,first,last):

    fbc = 0
    tlen = len(txt)
    tnum = tlen-1
    for z in xrange(tlen):
        c = txt [tnum]
        if c == last:
            fbc += 1
        elif c == first:
            if fbc:
                fbc -= 1
            if not fbc:
                return tnum
        tnum -= 1
    return-1</t>
<t tx="ekr.20071102163001.168">def setBracketMatch (self,notification=None,handback=None):

    c = self.c
    if g.app.config.getBool(c,"highlight_brackets"):
        col = g.app.config.getColor(c,"highlight_brackets_color")
        color = getColorInstance(col,awt.Color.GREEN)
        self.highlight_painter = stext.DefaultHighlighter.DefaultHighlightPainter(color)
        self.match_bracket = 1
    else:
        self.match_bracket = 0
</t>
<t tx="ekr.20071102163001.169"></t>
<t tx="ekr.20071102163001.170">class autolistener(sevent.DocumentListener,aevent.KeyAdapter):

    watchwords = {}

    def __init__ (self,editor):
        self.watchwords = leoSwingBody.Editor.autolistener.watchwords
        self.watchitems = ('.',')')
        self.txt_template = '%s%s%s'
        okchars = {}
        for z in string.ascii_letters:
            okchars [z] = z
        okchars ['_'] = '_'
        self.okchars = okchars
        self.editor = editor
        self.jeditor = editor.editor
        self.popup = None
        #self.layeredpane = editor.layeredpane
        self.haveseen = {}
        #self.autobox = None
        self.constructAutobox()
        self.on = 0
        wm1 = WeakMethod(self,"initialScan")
        leoPlugins.registerHandler(('start2','open2'),wm1)


    @others

</t>
<t tx="ekr.20071102163001.171"></t>
<t tx="ekr.20071102163001.172">class inserter(aevent.MouseAdapter):

    def __init__ (self,autolistener):
        self.autolistener = autolistener

    def mouseReleased (self,event):
        self.autolistener.insertFromAutoBox()


class hider(aevent.MouseWheelListener):

    def __init__ (self,autolistener):
        self.autolistener = autolistener

    def mouseWheelMoved (self,event):
        if self.autolistener.autobase.isShowing():
            self.autolistener.hideAutoBox()


</t>
<t tx="ekr.20071102163001.173">def constructAutobox (self):

    #import AutoPanel
    jp = swing.JPanel()
    #jp = AutoPanel()
    gbl = awt.GridBagLayout()
    gbc = awt.GridBagConstraints()
    gbc.fill = 1
    jp.setLayout(gbl)
    jlist = swing.JList(swing.DefaultListModel())
    jlist.setName("Autolist")
    jlist.setFont(self.editor.editor.getFont())
    self.jsp = jsp = swing.JScrollPane(jlist)
    gbl.setConstraints(jsp,gbc)
    jp.add(jsp)
    self.autobox = jlist
    self.autobase = jp
    self.autobox.addMouseListener(self.inserter(self))
    self.jeditor.addMouseWheelListener(self.hider(self))

</t>
<t tx="ekr.20071102163001.174">def keyPressed (self,event): #aka key process keyStroke
    '''c in this def is not a commander but a Tk Canvas.  This def determine what action to take dependent upon
       the state of the canvas and what information is in the Event'''
    #if not c.on:return None #nothing on, might as well return

    if not self.on: return
    if not self.autobase.isShowing(): return #isVisible just determines if the thing should be visible, not if it is.  isShowing does.


    modifiers = event.getModifiers()
    mtxt = event.getKeyModifiersText(modifiers)
    ktxt = event.getKeyText(event.getKeyCode())
    keysym = '%s %s' % (mtxt,ktxt)
    keysym = keysym.strip()
    if keysym == "shift":
        return

    elif keysym == "Backspace":
        pos = self.jeditor.getCaretPosition()
        doc = self.jeditor.getDocument()
        if pos != 0:
            c = doc.getText(pos-1,1)
            if c == '.':
                return self.hideAutoBox()


    elif self.testForUnbind(keysym): #all of the commented out code is being tested in the new testForUnbind def or moved above.
        #unbind( context )
        self.hideAutoBox()
        return None
    #elif event.keysym in("Shift_L","Shift_R"):
    #    #so the user can use capital letters.
    #    return None 
    #elif not c.which and event.char in ripout:
    #    unbind( c )
    #elif context.which==1:
    #    #no need to add text if its calltip time.
    #    return None 
    #ind = body.index('insert-1c wordstart')
    #pat = body.get(ind,'insert')+event.char 
    #pat = pat.lstrip('.')
    doc = self.jeditor.getDocument()
    pos = self.jeditor.getCaretPosition()
    try:
        txt = doc.getText(0,pos)
    except:
        return
    txt_lines = txt.splitlines()

    if len(txt_lines) &gt; 1:
        txt_line = txt_lines [ -1]
    else:
        txt_line = txt_lines [0]
    pat = txt_line.split('.')
    if len(pat) &gt; 1:
        pat = pat [ -1]
    else:
        pat = pat [0]

    #print keysym
    if keysym == 'Ctrl Ctrl':
       return self.processAutoBox(event,pat)

    if keysym in ("Alt Up","Alt Down"):
        event.consume()
        return self.moveUpDown(keysym)

    kchar = event.getKeyChar()
    if kchar == event.CHAR_UNDEFINED: return
    else:
        pat = pat + kchar
    autobox = self.autobox
    lm = autobox.getModel()
    ww = []
    index = None
    for z in xrange(lm.getSize()):
        item = lm.getElementAt(z)
        if item.startswith(pat):
                index = z
                break
        #ww.append( lm.getElementAt( z ) )

    #autobox = context.autobox
    #ww = list( autobox.get( 0, 'end' ) )
    #lis = self.reducer(ww,pat)
    #if len(lis)==0:return None #in this section we are selecting which item to select based on what the user has typed.
    #i = ww.index(lis[0])

    #lm.clear()
    #autobox.setListData( lis )
    if index != None:
        autobox.clearSelection()
        autobox.setSelectedIndex(index)
        autobox.ensureIndexIsVisible(index)

    #autobox.select_clear( 0, 'end' ) #This section sets the current selection to match what the user has typed
    #autobox.select_set( i )
    #autobox.see( i )
    #return 'break'

</t>
<t tx="ekr.20071102163001.175">def processAutoBox (self,event,pat):
    '''This method processes the selection from the autobox.'''
    #if event.keysym in("Alt_L","Alt_R"):
    #    return None 

    #a = context.autobox.getvalue()
    a = self.autobox.getSelectedValue()
    #if len(a)==0:return None 
    if not a: self.hideAutoBox()
    try:
        #a = a[0]
        #ind = body.index('insert-1c wordstart')
        #pat = body.get(ind,'insert')
        #pat = pat.lstrip('.')

        if a.startswith(pat): a = a [len(pat):]
        doc = self.jeditor.getDocument()
        doc.insertString(self.jeditor.getCaretPosition(),a,None)
        self.hideAutoBox()
        #self.editor.insert 
        #body.insert('insert',a)
        #body.event_generate("&lt;Key&gt;")
        #body.update_idletasks()
    except java.lang.Exception, x:
        x.printStackTrace()
        #self.editor.hideAutoBox()
        #unbind( context )
</t>
<t tx="ekr.20071102163001.176">def moveUpDown (self,code):

    autobox = self.autobox
    i = autobox.getSelectedIndex()
    if code == 'Alt Up':
        i2 = i-1
    else:
        i2 = i + 1

    lm = autobox.getModel()
    if i2 &lt; 0 or i2 + 1 &gt; lm.getSize():
        return
    else:
        autobox.setSelectedIndex(i2)
        autobox.ensureIndexIsVisible(i2)</t>
<t tx="ekr.20071102163001.177">def testForUnbind (self,keysym):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if keysym in ('parenright','parenleft','Escape','Space','Enter','Tab','Up','Down') or keysym.isspace():
        return True
    #elif not context.which and event.char in ripout:
    #    return True
    return False
</t>
<t tx="ekr.20071102163001.178">@others</t>
<t tx="ekr.20071102163001.179">def changedUpdate (self,event):
    pass

</t>
<t tx="ekr.20071102163001.180">def insertUpdate (self,event):

    if not self.on: return
    doc = event.getDocument()
    change = doc.getText(event.getOffset(),event.getLength())
    if change == '.':
        self.watcher(event)



</t>
<t tx="ekr.20071102163001.181">def removeUpdate (self,event):
    '''originally I wanted to do a remove of the autobox on a backspace of '.' but this couldnt be detected adequately
    and had to be put in the Key handling code of the autocompleter.'''
    pass

</t>
<t tx="ekr.20071102163001.182">watchitems = ('.',')')
txt_template = '%s%s%s'
def watcher (self,event):
    '''A function that tracks what chars are typed in the Text Editor.  Certain chars activate the text scanning
       code.'''
    #global lang 
    doc = event.getDocument()
    txt = doc.getText(event.getOffset(),event.getLength())
    if txt.isspace() or txt in self.watchitems:
        #bCtrl = event.widget
        #This if statement ensures that attributes set in another node
        #are put in the database.  Of course the user has to type a whitespace
        # to make sure it happens.  We try to be selective so that we dont burn
        # through the scanText def for every whitespace char entered.  This will
        # help when the nodes become big.
        #if event.char.isspace():
        #    if bCtrl.get( 'insert -1c' ).isspace(): return #We dont want to do anything if the previous char was a whitespace
        #    if bCtrl.get( 'insert -1c wordstart -1c') != '.': return

        #c = bCtrl.commander
        #lang = c.frame.body.getColorizer().language 
        #txt = txt_template %( bCtrl.get( "1.0", 'insert' ), 
        #                     event.char, 
        #                     bCtrl.get( 'insert', "end" ) ) #We have to add the newest char, its not in the bCtrl yet
        txt = doc.getText(0,doc.getLength())
        self.scanText(txt)
        self.determineToShow(event)

</t>
<t tx="ekr.20071102163001.183">def scanText (self,txt):
    '''This function guides what gets scanned.'''

    #if useauto:
    self.scanForAutoCompleter(txt)
    #if usecall:
    #    scanForCallTip(txt)
</t>
<t tx="ekr.20071102163001.184">def scanForAutoCompleter (self,txt):
    '''This function scans text for the autocompleter database.'''
    t1 = txt.split('.')
    g = []
    reduce(lambda a,b: self.makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            if self.watchwords.has_key(a):
                self.watchwords [a] [b] = None
            else:
                self.watchwords [a] = {b: None}
                #watchwords[a] = sets.Set([b])
                #watchwords[ a ] = util.Hash
            #watchwords[ a ].add( b ) # we are using the experimental DictSet class here, usage removed the above statements
            #notice we have cut it down to one line of code here!</t>
<t tx="ekr.20071102163001.185">def makeAutocompletionList (self,a,b,glist):
    '''A helper function for autocompletion'''
    a1 = self._reverseFindWhitespace(a)
    if a1:
        b2 = self._getCleanString(b)
        if b2 != '':
            glist.append((a1,b2))
    return b
</t>
<t tx="ekr.20071102163001.186">def _getCleanString (self,s):
    '''a helper for autocompletion scanning'''
    if s.isalpha(): return s

    #for n, l in enumerate(s):
    for n in xrange(len(s)):
        l = s [n]
        if l in self.okchars: pass
        else: return s [: n]
    return s
</t>
<t tx="ekr.20071102163001.187">def _reverseFindWhitespace (self,s):
    '''A helper for autocompletion scan'''
    #for n, l in enumerate(s):
    for n in xrange(len(s)):
        l = s [n]
        n = (n+1) * -1
        if s [n].isspace() or s [n] == '.': return s [n + 1:]
    return s
</t>
<t tx="ekr.20071102163001.188">def reducer (self,lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return [x for x in lis if x.startswith(pat)]
</t>
<t tx="ekr.20071102163001.189">def determineToShow (self,event):

    doc = event.getDocument()
    txt = doc.getText(0,event.getOffset())
    txt_list = txt.splitlines()
    if not txt_list: return
    txt_line = txt_list [ -1]
    txt_splitdots = txt_line.split('.') [ -1]
    txt_final = txt_splitdots.split()
    if txt_final:
        txt_final = txt_final [ -1]
    if txt_final and self.watchwords.has_key(txt_final):
        completers = self.watchwords [txt_final].keys()
        completers.sort()
        self.getAutoBox(completers)

</t>
<t tx="ekr.20071102163001.190">@others</t>
<t tx="ekr.20071102163001.191">def initialScan (self,tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c") or keywords.get("new_c")
    haveseen = self.haveseen
    if haveseen.has_key(c):
        return

    haveseen [c] = None

    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    #pth = os.path.split(g.app.loadDir)  
    #aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    #if not os.path.exists(aini):
    #    createConfigFile( aini )
    #try:
    #    if not hasReadConfig():
    #        if os.path.exists(aini):
    #            readConfigFile(aini) 
    #
    #        bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
    #        readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    #finally:
    #    setReadConfig()

    # Use a thread to do the initial scan so as not to interfere with the user.
    #_self = self
    #class scanner( java.lang.Thread ):          
    #def run( self ):
    #    _self.readOutline( c )
    #    #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
    #    #readOutline( c )

    dc = DefCallable(lambda: self.readOutline(c))
    g.app.gui.addStartupTask(dc)



</t>
<t tx="ekr.20071102163001.192">def readOutline (self,c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    #global lang
    #if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
    #    import chapters 
    #    it = chapters.walkChapters()
    #     for x in it:
    #        lang = None 
    #        setLanguage(x)
    #        scanText(x.bodyString())
    #else:
    for z in c.rootPosition().allNodes_iter(copy=True):
        #self.scanText( z.bodyString() )
        rvalues = LeoUtilities.scanForAutoCompleter(z.v.t._bodyString)
        if rvalues:
            for z in rvalues:
                a, b = z
                if self.watchwords.has_key(a):
                    self.watchwords [a] [b] = None
                else:
                    self.watchwords [a] = {b: None}



    g.es("Autocompleter ready")
</t>
<t tx="ekr.20071102163001.193">@others</t>
<t tx="ekr.20071102163001.194">def getAutoBox (self,completers):

    jlist = self.autobox
    jp = self.autobase
    if len(completers) &lt; 5:
        jlist.setVisibleRowCount(len(completers))
    else:
        jlist.setVisibleRowCount(5)

    model = jlist.getModel()
    model.removeAllElements() #by working with the model we dont burn a new object each time.
    for z in completers:
        model.addElement(z)
    jlist.setSelectedIndex(0)
    jlist.ensureIndexIsVisible(0)
    jlist.setValueIsAdjusting(True)


    cur = self.jeditor.getCaretPosition()
    pos = self.jeditor.modelToView(cur)
    size = self.editor.view.getViewport().getViewRect()
    pos = swing.SwingUtilities.convertRectangle(self.jeditor,pos,self.editor.epane)
    size.x = 0 ; size.y = 0 ;


    jlist.setSize(jlist.getPreferredSize()) #the discrepency between the two was causing weird drawing bugs.  This appears to have rectified it.
    #Its very important that the setSize call happens before the self.jsp.getPreferredSize call, or it may not calculate right.
    jsps = self.jsp.getPreferredSize()
    jp.setSize(jsps)
    rx = ry = 0
    if pos.x &gt; (size.x+size.height) / 2:
        rx = pos.x- jsps.width
    else: rx = pos.x

    if pos.y &gt; (size.y+size.height) / 2:
        ry = pos.y- jsps.height
    else: ry = pos.y + pos.height

    point = awt.Point(rx,ry)
    swing.SwingUtilities.convertPointToScreen(point,self.editor.view.getViewport())
    popupfactory = swing.PopupFactory().getSharedInstance()
    self.popup = popup = popupfactory.getPopup(self.editor.editor,jp,point.x,point.y)
    popup.show()






</t>
<t tx="ekr.20071102163001.195">def hideAutoBox (self):

    if self.popup:
        self.popup.hide() ; self.popup = None


</t>
<t tx="ekr.20071102163001.196">def insertFromAutoBox (self):

    autobox = self.autobox
    value = autobox.getSelectedValue()
    pos = self.jeditor.getCaretPosition()
    self.jeditor.getDocument().insertString(pos,value,None)
    self.hideAutoBox()</t>
<t tx="ekr.20071102163001.197"></t>
<t tx="ekr.20071102163001.198">class UnderlinerCaret(stext.DefaultCaret):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__ (self,color):
        stext.DefaultCaret.__init__(self)
        #ti = java.lang.Integer.decode( "#FFFFC6" );
        #c = awt.Color( ti );
        #self._bg = awt.Color.RED
        self._bg = color
        #self._bg = awt.Color( c.getRed(), c.getGreen(), c.getBlue(), 50 ); 
        self.setBlinkRate(0) #no blinking please


    def paint (self,g):

        com = self.super__getComponent()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)

        if (self.x!=view.x or self.y!=view.y):
            self.super__repaint()
            self.x = view.x
            self.y = view.y
            self.width = self.calculateCharacterWidth(g) + 1 #Its important to be a little wider
            self.height = view.height + 1 #And a little taller than the box, or redraws will leave traces


        if self.isVisible():
            g.setColor(self._bg)
            #g.fillRect( self.x, self.y, self.width - 1, view.height )
            g.drawLine(self.x,self.y+self.height-1,self.x+self.width-1,self.y+self.height-1)
        self.setMagicCaretPosition(awt.Point(self.x,self.y))

    def calculateCharacterWidth (self,g):
        '''This method allows the see-through box to have the same width as the character'''

        com = self.super__getComponent()
        fm = g.getFontMetrics()

        pos = com.getCaretPosition()
        len = com.getDocument().getLength()
        if pos &gt;= len:
            c = ' '
        else:
            c = com.getText(pos,1)
        if java.lang.Character.isWhitespace(c): c = ' '

        return swing.SwingUtilities.computeStringWidth(fm,c)





    def damage (self,r):

        if r == None: return

        self.x = r.x
        self.y = r.y
        com = self.super__getComponent()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)
        graphics = com.getGraphics()
        self.width = self.calculateCharacterWidth(graphics) + 1
        graphics.dispose()
        self.height = view.height + 1 ;
        self.super__repaint()
        self.setMagicCaretPosition(awt.Point(self.x,self.y))</t>
<t tx="ekr.20071102163001.199">class SeeThroughBoxCaret(stext.DefaultCaret):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__ (self,color):
        stext.DefaultCaret.__init__(self)
        #ti = java.lang.Integer.decode( "#FFFFC6" );
        #c = awt.Color( ti );
        #c = awt.Color.RED
        self._bg = awt.Color(color.getRed(),color.getGreen(),color.getBlue(),50) ;
        self.setBlinkRate(0) #no blinking please


    def paint (self,g):

        com = self.super__getComponent()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)
        if (self.x!=view.x or self.y!=view.y):
            self.super__repaint()
            self.x = view.x
            self.y = view.y
            self.width = self.calculateCharacterWidth(g) + 1 #Its important to be a little wider
            self.height = view.height + 1 #And a little taller than the box, or redraws will leave traces


        if self.isVisible():
            g.setColor(self._bg)
            g.fillRect(self.x,self.y,self.width-1,view.height)

        self.setMagicCaretPosition(awt.Point(self.x,self.y))

    def calculateCharacterWidth (self,g):
        '''This method allows the see-through box to have the same width as the character'''

        if not g: return 0
        com = self.super__getComponent()
        doc = com.getDocument()
        pos = com.getCaretPosition()
        len = doc.getLength()
        if pos &gt;= len:
            c = ' '
        else:
            c = com.getText(pos,1)

        e = doc.getCharacterElement(pos)
        atts = e.getAttributes()
        f = doc.getFont(atts)
        if f:
            g.setFont(f)
        fm = g.getFontMetrics()

        if java.lang.Character.isWhitespace(c): c = ' '

        return swing.SwingUtilities.computeStringWidth(fm,c)





    def damage (self,r):

        if r == None: return

        self.x = r.x
        self.y = r.y
        com = self.super__getComponent()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)
        graphics = com.getGraphics()
        self.width = self.calculateCharacterWidth(graphics) + 1
        if graphics:
            graphics.dispose()
        self.height = view.height + 1 ;
        self.super__repaint()
        self.setMagicCaretPosition(awt.Point(self.x,self.y))

</t>
<t tx="ekr.20071102163001.200">import java.awt.image as aim
class GhostlyLeoCaret(stext.DefaultCaret):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__ (self):
        stext.DefaultCaret.__init__(self)

        self.setBlinkRate(0) #no blinking please
        self._image = leoSwingBody.Editor.icon.getImage()
        self._im_height = self._image.getHeight() + 1
        self._im_width = self._image.getWidth() + 1
        self._ac = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,.2)
        self._bgc = None


    def paint (self,g):

        com = self.super__getComponent()
        if self._bgc == None:
            self._bgc == g.getColor()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)

        if (self.x!=view.x or self.y!=view.y):
            self.super__repaint()
            self.x = view.x
            self.y = view.y
            self.width = self._im_width
            self.height = self._im_height


        if self.isVisible():

            if not self.isWhiteSpace(g):
                g.setComposite(self._ac)
            g.drawImage(self._image,self.x,self.y,self._bgc,None)
        self.setMagicCaretPosition(awt.Point(self.x,self.y))

    def isWhiteSpace (self,g):
        '''This method allows the see-through box to have the same width as the character'''

        com = self.super__getComponent()
        v1 = com.viewToModel(awt.Point(self.x,self.y))
        v2 = com.viewToModel(awt.Point(self.x+self.width,self.y))
        vlen = v2- v1
        len = com.getDocument().getLength()
        if v1 &gt;= len:
            c = ' '
        else:
            c = com.getText(v1,vlen)
        if c.isspace() or c == '': c = ' '
        return c == ' '





    def damage (self,r):

        if r == None: return

        self.x = r.x
        self.y = r.y
        self.height = self._im_height
        self.width = self._im_width
        self.super__repaint()
        self.setMagicCaretPosition(awt.Point(self.x,self.y))
</t>
<t tx="ekr.20071102163001.201">class ImageCaret(GhostlyLeoCaret):

    def __init__ (self,image):
        leoSwingBody.Editor.GhostlyLeoCaret.__init__(self)
        self._image = image
        self._im_height = self._image.getHeight() + 1
        self._im_width = self._image.getWidth() + 1


</t>
<t tx="ekr.20071102163001.202">class leoJTextPane(swing.JTextPane):

    def __init__ (self,c):
        swing.JTextPane.__init__(self)
        self.c = c
        self.last_rec = None
        self._bg = None

    def setLineColor (self,notification=None,handback=None):

        c = self.c
        if g.app.config.getBool(c,"highlight_current_line"):
            hc = g.app.config.getColor(c,"current_line_highlight_color")
            color = getColorInstance(hc,awt.Color.ORANGE)
            self._bg = awt.Color(color.getRed(),color.getGreen(),color.getBlue(),50)
        else:
            self._bg = None
            self._last_rec = None
        self.repaint()

@
    def paintComponent (self,graphics):
        if 0:
            paint = graphics.getPaint()
            color = self.getBackground()
            c1 = awt.Color.RED
            c2 = awt.Color.GREEN
            vrect = self.getVisibleRect()
            gp = awt.GradientPaint(vrect.x,vrect.y,c1,vrect.x+vrect.width,vrect.y+vrect.height,c2)
            graphics.setPaint(gp)
            graphics.fillRect(vrect.x,vrect.y,vrect.width,vrect.height)
            graphics.setPaint(paint)
@c

    def paintComponent (self,graphics):

        self.super__paintComponent(graphics)
        if self._bg:
            cpos = self.getCaretPosition() #from here
            try:
                rec = self.modelToView(cpos)
            except java.lang.Exception, x:
                x.printStackTrace()
                return
            sz = self.getVisibleRect()
            rec = awt.Rectangle(sz.x,rec.y,sz.width,rec.height) #to here: these calculate the colored background.
            if self.last_rec and not self.last_rec.equals(rec): #its not the same spot we must repaint!
                if self.last_rec.width &lt; rec.width:
                    self.last_rec.width = rec.width
                self.repaint(self.last_rec)


            c = graphics.getClip()
            rintersect = rec.intersects(c)
            if not rec.equals(self.last_rec) or rintersect:
                if self.last_rec:
                    if rec.y != self.last_rec.y or rec.height != self.last_rec.height:
                        rintersect = 0
                if rintersect:
                    graphics.setColor(self._bg) #if we intersect we only repaint a small portion. This reduces flicker.
                    graphics.fill(rec)
                else:
                    g2 = self.getGraphics()
                    g2.setColor(self._bg) #if we dont we repaint all of it.
                    g2.fill(rec)
                    g2.dispose()


            self.last_rec = rec


</t>
<t tx="ekr.20071102163001.203">class leoImageJPanel(swing.JPanel):

    def __init__ (self,layoutmanager):
        swing.JPanel.__init__(self,layoutmanager)
        self.image = None
        self.backedWidget = None
        self.last_image = None
        self.alpha = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,1.0)
        self.lastDimensions = awt.Rectangle(0,0,0,0)

    def setBackedWidget (self,widget):
        self.backedWidget = widget

    def setImage (self,image):
        self.image = image

    def setAlpha (self,alpha):
        self.alpha = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,alpha)

    def paintComponent (self,graphics):

        self.super__paintComponent(graphics)
        if self.backedWidget and self.image:
            vrec = self.backedWidget.getVisibleRect()
            rec2 = swing.SwingUtilities.convertRectangle(self.backedWidget,vrec,self)
            if not self.lastDimensions.equals(vrec):
                self.lastDimensions = vrec
                self.last_image = self.image.getScaledInstance(rec2.width,rec2.height,awt.Image.SCALE_REPLICATE)
            composite = graphics.getComposite()
            graphics.setComposite(self.alpha)
            graphics.drawImage(self.last_image,rec2.x,rec2.y,awt.Color.WHITE,None)
            graphics.setComposite(composite)
</t>
<t tx="ekr.20071102163001.204">class leoLayoutManager(awt.LayoutManager):


    def __init__ (self):
        self.jscrollpane = None
        self.minibuffer = None
        self.media = None



    def addLayoutComponent (self,name,component):
        pass


    def layoutContainer (self,container):

        size = container.getSize()
        if self.minibuffer:
            mbpsize = self.minibuffer.getPreferredSize()
        else:
            mbpsize = awt.Rectangle(0,0,0,0)

        if self.jscrollpane:
            self.jscrollpane.setBounds(0,0,size.width,size.height-mbpsize.height)
            if self.minibuffer:
                self.minibuffer.setBounds(0,size.height-mbpsize.height,size.width,mbpsize.height)

        if self.media and self.jscrollpane:
            vp = self.jscrollpane.getViewport()
            vr = vp.getBounds()
            self.media.setBounds(vr)

    def layoutMedia (self):
        if self.media and self.jscrollpane:
            vp = self.jscrollpane.getViewport()
            vr = vp.getBounds()
            self.media.setBounds(vr)

    def minimumLayoutSize (self,container):
        return container.getMinimumSize()


    def preferredLayoutSize (self,container):
        return container.getPreferredSize()


    def removeLayoutComponent (self,container):
        pass
</t>
<t tx="ekr.20071102163001.205">class UtilityRightClick( aevent.MouseAdapter ):


    def __init__( self, c, detach_retach = False, editor = None ):
        aevent.MouseAdapter.__init__( self )
        self.c = c
        self.editor = weakref.proxy( editor )
        self._detach_retach = detach_retach


    @others


</t>
<t tx="ekr.20071102163001.206">def mousePressed( self, mE ):

    if mE.getClickCount() == 1:
        if mE.getButton() == mE.BUTTON3:
            x = mE.getX()
            y = mE.getY()

            popup = swing.JPopupMenu()

            UtilityAction = leoSwingBody.UtilityAction
            AddEditor = leoSwingBody.AddEditor
            InsertNode = leoSwingBody.InsertNode            
            frame = self.c.frame
            for z in ( ( "Cut", self.editor.editor.cut ), ( "Copy", self.editor.editor.copy ), 
                        ( "Paste", self.editor.editor.paste ), # frame.OnPaste ), 
                        ( "Delete", self.c.delete  ),
                        ):
                popup.add( UtilityAction( z[ 0 ], z[ 1 ] ) )

            popup.addSeparator()
            popup.add( UtilityAction( "Turn Selection Into Node", self.editor.turnSelectionIntoNode ))
            inmenu = swing.JMenu( "Insert Node Into Body" )
            inmenu.addMenuListener( InsertNode( inmenu, self.c, UtilityAction ) )
            popup.add( inmenu )

            popup.add( UtilityAction( "Split Node", frame.body.editor.splitNode ) )

            if( mE.getComponent() == self.editor ):
                popup.add( UtilityAction( "Select All", self.editor.selectAll ) )

            popup.addSeparator()  
            body = frame.body
            popup.add( AddEditor( body , x, y ) )
            popup.addSeparator()               
            if self._detach_retach:
                if self.editor._attached:
                    s = "Detach Editor"
                    act = self.editor.detach
                else:
                    s = "Retach Editor"
                    act = self.editor.retach 
                ji = swing.JMenuItem( s )
                ji.actionPerformed =  act
                popup.add( ji )

            folded = self.editor.foldprotection.isFolded( x, y )
            if self.editor.editor.getSelectionStart() != self.editor.editor.getSelectionEnd() or folded:
                popup.addSeparator()
                if not folded:
                    jmi = swing.JMenuItem( "Fold Selection" )
                    jmi.actionPerformed = lambda event, fp = self.editor.foldprotection: fp.foldSelection()
                else:
                    jmi = swing.JMenuItem( "Unfold Fold" )
                    jmi.actionPerformed = lambda event, fp = self.editor.foldprotection, x = x, y= y: fp.unfoldSpot( x, y )

                popup.add( jmi )

            source = mE.getSource()    
            popup.show( source, x, y )</t>
<t tx="ekr.20071102163001.207">def addTab( self, name, widget ):

    self.tab_manager.add( name, widget )



def removeTab( self, widget ):

    self.tab_manager.remove( widget )

</t>
<t tx="ekr.20071102163001.208">def nextEditor (self,reverse=False):

    editor = self.editor
    next = False
    editors = list(self.editors)
    if reverse:
        editors.reverse()
    for z in editors:
        z = z.get()
        if next:
            tl = z.editor.getTopLevelAncestor()
            tl.toFront()
            z.editor.requestFocus()
            return
        if z == editor: next = True
    if next:
        for z in editors:
            z = z.get()
            if z:
                tl = z.editor.getTopLevelAncestor()
                tl.toFront()
                z.editor.requestFocus()
                return

def previousEditor (self):
    self.nextEditor(reverse=True)
</t>
<t tx="ekr.20071102163001.209">@others</t>
<t tx="ekr.20071102163001.210">class SimplifiedUtilityRightClick( aevent.MouseAdapter ):


    def __init__( self, body ):
        aevent.MouseAdapter.__init__( self )
        self.body = body



    @others


</t>
<t tx="ekr.20071102163001.211">def mousePressed( self, mE ):

    if mE.getClickCount() == 1:
        if mE.getButton() == mE.BUTTON3:
            x = mE.getX()
            y = mE.getY()

            popup = swing.JPopupMenu()
            AddEditor = leoSwingBody.AddEditor
            popup.add( AddEditor( self.body , x, y ) )                
            source = mE.getSource()                
            popup.show( source, x, y )</t>
<t tx="ekr.20071102163001.212">class AddEditor( swing.AbstractAction ):

    def __init__( self, body, x,y ):
        swing.AbstractAction.__init__( self, "Add Editor" )
        self.body = body
        self.x = x
        self.y = y

    def actionPerformed( self, event ):
        leoSwingBody.Editor( self.body.jdp , self.body.c, self.body , x = self.x, y = self.y )</t>
<t tx="ekr.20071102163001.213">class UtilityAction( swing.AbstractAction ):
    def __init__( self, name, command ):
        swing.AbstractAction.__init__( self, name )
        self.command = command

    def actionPerformed( self, event ):
        self.command()</t>
<t tx="ekr.20071102163001.214">class InsertNode( sevent.MenuListener ):

    def __init__( self, menu, c, utilityaction ):
        self.menu = menu
        self.c = c
        self.UtilityAction = utilityaction
        #self.insert = insert

    def menuCanceled( self, event ):
        pass

    def menuDeselected( self, event ):
        pass

    def menuSelected( self, event ):

        menu = self.menu       
        menu.removeAll()
        cp = self.c.currentPosition()
        for z in cp.children_iter( copy = True ):
            action = lambda node = z: self.insertNode( node )
            ua = self.UtilityAction( z.headString(), action )
            menu.add( ua )

    def insertNode( self, node ):

        c = self.c
        at = c.atFileCommands
        at.write(node.copy(),nosentinels=True,toString=True,scriptWrite=True)
        data = at.stringOutput
        c.frame.body.editor.insertTextIntoBody( data )
        c.beginUpdate()
        cpos = c.currentPosition()
        node.doDelete( cpos )
        c.endUpdate()




</t>
<t tx="ekr.20071102163001.215">def undoableEditHappened( self, event ):

    if self.ignore_insert: return
    c = self.c
    cp = c.currentPosition().copy()
    edit = event.getEdit()
    #dec_edit = leoSwingUndo.UndoableEditDecorator( c, cp, edit )
    #c.undoer.addUndo( dec_edit )

    #undoType = "undo_edit_class"
    #c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
</t>
<t tx="ekr.20071102163001.216">def keyPressed( self, event ):

    editor = self.editor.editor
    self.oldText = editor.getText()
    self.oldSel = editor.getSelectedText()
    self.ch = event.getKeyChar()
    cpos = editor.getCaretPosition()
    rec = editor.modelToView( cpos )
    self.oldYview = rec.y 
</t>
<t tx="ekr.20071102163001.217">def getAllText( self ):

    return self.editor.editor.getText()</t>
<t tx="ekr.20071102163001.218">class leoSwingFrame(leoFrame.leoFrame):

    """The base class for all Leo windows."""

    instances = 0

    @others</t>
<t tx="ekr.20071102163001.219">def __init__ (self,gui):

    leoFrame.leoFrame.__init__(self,gui)
    self.gui = gui
    #import RepaintManager2
    #rpm2 = RepaintManager2()
    #swing.RepaintManager.setCurrentManager( rpm2 )
    # Objects attached to this frame.
    self.menu = None
    self.keys = None
    self.colorPanel = None
    self.fontPanel = None
    self.prefsPanel = None
    self.comparePanel = None
    self.title = ""
    self._menu_init_callbacks = []
    self.receiver = None
    self.canresize = True

    #import Chapters
    #self.chapters = Chapters.Chapters( self.c )
    #if g.app.config.getBool( self.c, "lock_open_files" ):
    #    receiver = self.Receiver( self, self.c )
    #    thread = java.lang.Thread( receiver )
    #    thread.setDaemon( True )
    #    thread.start()

    #self.c = None # Must be created by subclasses.
    #self.title = None # Must be created by subclasses.

    # Objects attached to this frame.
    #self.menu = None
    #self.keys = None
    #self.colorPanel = None 
    #self.fontPanel = None 
    #self.prefsPanel = None
    #self.comparePanel = None

    # Gui-independent data
    #self.es_newlines = 0 # newline count for this log stream
    #self.openDirectory = ""
    #self.saved=False # True if ever saved
    #self.splitVerticalFlag,self.ratio, self.secondary_ratio = self.initialRatios()
    #self.startupWindow=False # True if initially opened window
    #self.stylesheet = None # The contents of &lt;?xml-stylesheet...?&gt; line.

    # Colors of log pane.
    #self.statusColorTags = [] # list of color names used as tags in status window.

    # Previous row and column shown in the status area.
    #self.lastStatusRow = self.lastStatusCol = 0
    #self.tab_width = 0 # The tab width in effect in this pane.</t>
<t tx="ekr.20071102163001.220">def finishCreate (self,c):

    self.c = c
    self.setSkin()
    #swing.plaf.metal.MetalLookAndFeel.setCurrentTheme( self.LeoMetalTheme( self.c ) )
    wm1 = WeakMethod(self,"setSkin")
    g.app.config.manager.addNotificationDef("type_of_skin",wm1)
    self.top = swing.JFrame() #Must add close question
    self.gp2 = self.GlassPane2()
    self.top.setGlassPane(self.gp2)
    self.top.addWindowListener(self.WindowClosingWatcher(self))

    self.ftp = self.leoFocusTraversalPolicy(c)
    self.top.setFocusTraversalPolicy(self.ftp)
    #if g.app.config.getBool( self.c, "lock_open_files" ) and self.c.mFileName != "":
    #    self.startReceiver()

    g.app.gui.addLAFListener(self.top)
    #self.setSkin()
    #g.app.config.manager.addNotificationDef( "type_of_skin", self.setSkin )


    ic = g.os_path_join(g.app.loadDir,"..","Icons","Leoapp.GIF")
    ifile = io.File(ic)
    if ifile.exists():
        try:
            icimage = imageio.ImageIO.read(ifile)
            self.top.setIconImage(icimage)
        except java.lang.Exception, x:
            pass
    self.top.setDefaultCloseOperation(swing.JFrame.DO_NOTHING_ON_CLOSE)
    self.setTitle(c.mFileName)
    pf = self.top.getContentPane()

    self.jcp = self.top.getContentPane()
    self.toolbar = swing.JPanel(java.awt.BorderLayout()) #swing.JToolBar()
    #self.toolbar.setFloatable( False )
    nodebar = swing.JToolBar()
    self.NodeBar(c,nodebar)
    nodebar.setFloatable(True)
    self.toolbar.add(nodebar,java.awt.BorderLayout.NORTH)
    self.toolbar2 = swing.JToolBar()
    #g.doHook( "toolbar2-in-place", c = self.c , toolbar = self.toolbar2 )
    self.toolbar.add(self.toolbar2,java.awt.BorderLayout.SOUTH)

    self.jsp1 = swing.JSplitPane()
    self.jsp1.continuousLayout = True

    #pf.add( self.jif3 )
    self.jsp2 = swing.JSplitPane(swing.JSplitPane.VERTICAL_SPLIT,True)
    self.jsp2.topComponent = self.jsp1
    #self.jtab = swing.JTabbedPane()
    #self.tree_tabs = TabManager()
    #self.jsp1.leftComponent = self.tree_tabs.base #self.jtab
    self.jcp.add(self.jsp2,awt.BorderLayout.CENTER)
    self.top.add(self.toolbar,awt.BorderLayout.NORTH)
    #self.jif.getContentPane().add( self.jtab )
    #import Chapters
    #self.chapters = Chapters.Chapters( self.c )
    self.jsp1.leftComponent = self.c.chapters.getWidget()
    #self.tree = leoSwingTree(frame=self)
    self.tree = self.c.chapters.addChapter("New Chapter",p=c.rootPosition())
    #self.jsp1.leftComponent = self.tree.getWidget()
    self.menu = leoSwingMenu.leoSwingMenu(frame=self)
    #self.menu.createMenuBar( self )
    self.body = leoSwingBody(frame=self,parentFrame=self.jsp2)
    self.log = leoSwingLog(frame=self,parentFrame=self.jsp1)
    import leoSwingFind
    self.findPanel = leoSwingFind.leoSwingFind(c)
    g.app.log = self.log
    self.bodyCtrl = self.body.editor.editor

    tk = self.top.getToolkit()
    size = tk.getScreenSize()
    self.top.bounds = (0,0,size.width,size.height)
    #self.jsp1.setDividerLocation( .75 )
    #self.jsp2.setDividerLocation( .5 )
    self.jsp1.setOneTouchExpandable(True)
    self.jsp2.setOneTouchExpandable(True)
    &lt;&lt; create the first tree node &gt;&gt;
    #self.menu = leoSwingMenu.leoSwingMenu(frame=self)
    self.menu.createMenuBar(self)
    #self.top.visible = True
    #self.jsp1.setDividerLocation( .75 )
    #self.jsp2.setDividerLocation( .5 )

    g.app.windowList.append(self)
    c.initVersion()
    c.signOnWithVersion()
    self.menuInitialized()
    placement = g.app.config.getString(c,'tree_editor_placement')
    if placement == "Top/Bottom":
        pass
    else:
        self.toggleSplitDirection()</t>
<t tx="ekr.20071102163001.221">import leoNodes
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

c.beginUpdate()
try:
    p.moveToRoot()
    c.selectPosition(p)
    c.editPosition(p)
finally:
    c.endUpdate(False)


</t>
<t tx="ekr.20071102163001.222"></t>
<t tx="ekr.20071102163001.223">def abortEditLabelCommand (self):

    self.c.frame.tree.jtree.cancelEditing()

def endEditLabelCommand (self):
    self.c.frame.tree.endEditLabel()

def insertHeadlineTime (self):
    time = self.c.getTime(body=False)
    cp = self.c.currentPosition()
    hs = cp.headString()
    nhs = '%s %s' % (time,hs)
    cp.setHeadString(nhs)

# In the Window menu...
def cascade (self): self.oops()

def equalSizedPanes (self):
    self.jsp2.setDividerLocation(.5)

def hideLogWindow (self): self.oops()

def minimizeAll (self):

    self.top.setState(self.top.ICONIFIED)

def resizeToScreen (self):

    tk = self.top.getToolkit()
    ss = tk.getScreenSize()
    self.top.setBounds(0,0,ss.width,ss.height)

def toggleActivePane (self): self.oops()

def toggleSplitDirection (self):

    self._toggle(self.jsp1)
    self._toggle(self.jsp2)
    self.jsp2.setDividerLocation(.50)
    self.jsp1.setDividerLocation(.75)

def _toggle (self,jsp):

    orient = jsp.getOrientation()
    if orient == jsp.HORIZONTAL_SPLIT:
        jsp.setOrientation(jsp.VERTICAL_SPLIT)
    else:
        jsp.setOrientation(jsp.HORIZONTAL_SPLIT)

# In help menu...
def leoHelp (self): self.oops()

</t>
<t tx="ekr.20071102163001.224"># In the Edit menu...
def OnCopy (self,event=None): self.OnCopyFromMenu()
def OnCut (self,event=None): self.OnCutFromMenu()
def OnPaste (self,event=None): self.OnPasteFromMenu()

def OnCutFromMenu (self):
    self.OnCopyFromMenu()
    self.body.editor.editor.replaceSelection("")

def OnCopyFromMenu (self):

    gui = g.app.gui
    editor = self.body.editor.editor
    txt = editor.getSelectedText()
    gui.replaceClipboardWith(txt)

def OnPasteFromMenu (self):

    txt = g.app.gui.getTextFromClipboard()
    editor = self.body.editor.editor
    document = self.body.editor.editor.getStyledDocument()
    if txt:
        pos = editor.getCaretPosition()
        document.insertString(pos,txt,None)
</t>
<t tx="ekr.20071102163001.225">def bringToFront (self):

    self.top.toFront()

def deiconify (self):

    self.top.setVisible(True)

def lift (self):

    self.top.toFront()

def update (self):

    self.top.repaint()

</t>
<t tx="ekr.20071102163001.226"></t>
<t tx="ekr.20071102163001.227">def resizePanesToRatio (self,ratio,secondary_ratio):

    def resize ():
        self.jsp1.setDividerLocation(ratio)
        self.jsp2.setDividerLocation(secondary_ratio)

    dc = DefCallable(resize)
    java.awt.EventQueue.invokeLater(java.util.concurrent.FutureTask(dc))
</t>
<t tx="ekr.20071102163001.228">def setInitialWindowGeometry (self):
    """Set the position and size of the frame to config params."""
    #config = g.app.config
    c = self.c
    h = c.config.getInt("initial_window_height")
    w = c.config.getInt("initial_window_width")
    x = c.config.getInt("initial_window_left")
    y = c.config.getInt("initial_window_top")

    if h and w and x and y:
        self.setTopGeometry(w,h,x,y)

    #was:
    #h = config.getIntWindowPref("initial_window_height")
    #w = config.getIntWindowPref("initial_window_width")
    #x = config.getIntWindowPref("initial_window_left")
    #y = config.getIntWindowPref("initial_window_top")
    #if h and w and x and y:
    #    self.setTopGeometry(w,h,x,y)</t>
<t tx="ekr.20071102163001.229">def setTopGeometry (self,w,h,x,y,adjustSize=True):

    if self.canresize:
        self.top.setBounds(x,y,w,h)

def disableResizing (self):

    self.canresize = False

def enableResizing (self):

    self.canresize = True</t>
<t tx="ekr.20071102163001.230">def get_window_info (self):

    bounds = self.top.getBounds()
    return (bounds.width,bounds.height,bounds.x,bounds.y)
</t>
<t tx="ekr.20071102163001.231"></t>
<t tx="ekr.20071102163001.232">def setTabWidth (self,w):

    # Subclasses may override this to affect drawing.
    self.tab_width = w</t>
<t tx="ekr.20071102163001.233">def getTitle (self):
    return self.title

def setTitle (self,title):
    self.top.title = title</t>
<t tx="ekr.20071102163001.234">def initialRatios (self):

    config = g.app.config

    s = config.getWindowPref("initial_splitter_orientation")
    verticalFlag = s == None or (s!="h" and s!="horizontal")

    if verticalFlag:
        r = config.getFloatWindowPref("initial_vertical_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
        r2 = config.getFloatWindowPref("initial_vertical_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
    else:
        r = config.getFloatWindowPref("initial_horizontal_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
        r2 = config.getFloatWindowPref("initial_horizontal_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

    # print r,r2
    return verticalFlag, r, r2</t>
<t tx="ekr.20071102163001.235">def longFileName (self):

    return self.c.mFileName

def shortFileName (self):

    return g.shortFileName(self.c.mFileName)</t>
<t tx="ekr.20071102163001.236">def oops (self):

    print "leoFrame oops:", g.callerName(2), "should be overridden in subclass"
</t>
<t tx="ekr.20071102163001.237">def promptForSave (self):

    """Prompt the user to save changes.

    Return True if the user vetos the quit or save operation."""

    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    type = g.choose(g.app.quitting,"quitting?","closing?")
    answer = g.app.gui.runAskYesNoCancelDialog(
        "Confirm",
        'Save changes to %s before %s' % (name,type))
    # print answer	
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            &lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.</t>
<t tx="ekr.20071102163001.238"># Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title = "Save",
    filetypes = [("Leo files","*.leo")],
    defaultextension = ".leo")</t>
<t tx="ekr.20071102163001.239"># Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        &lt;&lt; set w and break on @tabwidth &gt;&gt;

    c.frame.setTabWidth(w)</t>
<t tx="ekr.20071102163001.240">if dict.has_key("tabwidth"):

    val = g.scanAtTabwidthDirective(s,dict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break</t>
<t tx="ekr.20071102163001.241"></t>
<t tx="ekr.20071102163001.242">def destroySelf (self):

    self.top.setVisible(False)
    self.top.dispose()
    self.top = None

</t>
<t tx="ekr.20071102163001.243">def clearStatusLine (self):
    pass

def putStatusLine (self,s,**kwords):
    pass</t>
<t tx="ekr.20071102163001.244">def finishCreateForSettings (self,c,controller):

    self.c = c
    self.top = swing.JFrame()
    self.ftp = self.leoFocusTraversalPolicy(c)
    self.top.setFocusTraversalPolicy(self.ftp)
    self.top.setTitle("Leo Settings")

    ic = g.os_path_join(g.app.loadDir,"..","Icons","Leoapp.GIF")
    ifile = java.io.File(ic)
    if ifile.exists():
        iimage = imageio.ImageIO.read(ifile)
        self.top.setIconImage(iimage)
    self.top.setDefaultCloseOperation(swing.JFrame.EXIT_ON_CLOSE)
    self.setTitle(c.mFileName)
    pf = self.top.getContentPane()
    gbl = awt.GridBagLayout()
    pf.setLayout(gbl)
    gbc = awt.GridBagConstraints()
    gbc.weightx = 1
    gbc.weighty = 1
    gbc.fill = 1


    self.jcp = self.top.getContentPane()
    self.jsp1 = swing.JSplitPane(swing.JSplitPane.VERTICAL_SPLIT)
    gbl.setConstraints(self.jsp1,gbc)
    self.jsp1.continuousLayout = True
    pf.add(self.jsp1)
    self.jtab = self.c.chapters.getWidget()
    c.chapters.disablePopup()
    self.jsp1.leftComponent = self.jtab
    self.jsp1.rightComponent = swing.JPanel()
    self.tree = c.chapters.addChapterForSettingsTree("Settings",p=c.rootPosition(),controller=controller)
    self.tree.jtree.setEditable(False)
    class fkBody:

        class ed:
            def __init__ (self):
                self.editor = swing.JTextPane()

            def sync (self,*args):
                pass

        def __init__ (self):
            self.editor = self.ed()

        def setFocus (self):
            pass

        def setSelectionAreas (self,*args):
            pass

        def setTextSelection (self,*args):
            pass

        def recolor (self,*args):
            pass

        def setColorFromConfig (self,*args):
            pass

    self.body = fkBody()
    self.jsp1.setOneTouchExpandable(True)
    &lt;&lt; create the first tree node &gt;&gt;
    self.jsp1.setDividerLocation(.5)
    g.app.windowList.append(self)
    c.initVersion()
    c.signOnWithVersion()
    self.tree.jtree.setDragEnabled(False)


</t>
<t tx="ekr.20071102163001.245">import leoNodes
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")
c.beginUpdate()
p.moveToRoot()
#c.beginUpdate()
#c.selectVnode(p)
c.selectPosition(p)
#c.redraw()
#c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)


</t>
<t tx="ekr.20071102163001.246">def setSkin (self,notification=None,handback=None):

    c = self.c
    toskin = g.app.config.getString(c,'type_of_skin')
    if toskin == 'native':

        nlafname = swing.UIManager.getSystemLookAndFeelClassName()
        if nlafname:
            import java.lang.Class
            nlaf = java.lang.Class.forName(nlafname).newInstance()
            swing.UIManager.setLookAndFeel(nlaf)
    elif toskin == 'synth':
        try:
            slaf = synth.SynthLookAndFeel()
            sname = g.app.config.getString(c,'custom_skin')
            ldir1 = io.File(g.app.loadDir)
            ldir2 = ldir1.getParent()
            ldir3 = io.File(ldir2,"skins")
            ldir4 = io.File(ldir2,"skinimages")
            synthfile = io.File(ldir3,sname)
            fis = io.FileInputStream(synthfile)
            import JyLeoResourceClassLoader as jlrc
            cloader = jlrc(ldir4,ldir1)
            clazz = cloader.getFakeClass()
            slaf.load(fis,clazz)
            swing.UIManager.setLookAndFeel(slaf)
        except java.lang.Exception, x:
            x.printStackTrace()
            g.es("Could not load custom skin")
    else:
        swing.UIManager.setLookAndFeel("javax.swing.plaf.metal.MetalLookAndFeel")




</t>
<t tx="ekr.20071102163001.247">def addIconButton (self,*args,**kwords):

    toolbar = self.toolbar2
    text = kwords ['text']
    button = swing.JButton(text)
    toolbar.add(button)
    return button
</t>
<t tx="ekr.20071102163001.248">def toggleActivePane (self):

    kfm = awt.KeyboardFocusManager.getCurrentKeyboardFocusManager()
    kfm.focusNextComponent()



</t>
<t tx="ekr.20071102163001.249">def isMenuInitialized (self,callback):

    if self.menu != None:
        callback(self.menu)
    else:
        self._menu_init_callbacks.append(callback)


def menuInitialized (self):

    for z in self._menu_init_callbacks:
        z(self.menu)

    self._menu_init_callbacks = []</t>
<t tx="ekr.20071102163001.250">def startReceiver (self):

    import java
    self.receiver = receiver = self.Receiver(self,self.c)
    thread = java.lang.Thread(receiver)
    thread.setDaemon(True)
    thread.start()

def hasReceiver (self):

    if self.receiver:
        return True
    else:
        return False</t>
<t tx="ekr.20071102163001.251">@others
</t>
<t tx="ekr.20071102163001.252">class leoFocusTraversalPolicy(awt.FocusTraversalPolicy):
    """This class implements the Traversale Policy for a Leo instance,
    Ctrl-T moves from widget to widget.  The Policy moves the Widgets like so:
    Editor --&gt; Tree --&gt; Log --&gt; (Back to Editor)"""

    def __init__ (self,c):
        awt.FocusTraversalPolicy.__init__(self)
        self.c = c

    @others

</t>
<t tx="ekr.20071102163001.253">def getComponentAfter (self,aContainer,aComponent):

    try:
        c = self.c
        if str(c.frame.tree.__class__) == "leoConfig.settingsTree":
            return c.frame.tree.jtree

        editor = c.frame.body.editor.editor
        logCtrl = c.frame.log.getCurrentTab()
        tree = c.frame.tree.jtree
        tree_editor = c.frame.tree.tcEdi.editor._jta

        if aComponent == editor:
            return tree
        elif aComponent == tree:

            return logCtrl

        elif aComponent == tree_editor:
            return logCtrl

        else:
            return editor
    except java.lang.Exception, x:
        x.printStackTrace()
        return editor

</t>
<t tx="ekr.20071102163001.254">def getComponentBefore (self,aContainer,aComponent):

    logCtrl = self.c.frame.log.getCurrentTab()
    editor = self.c.frame.body.editor.editor
    tree = self.c.frame.tree.jtree
    tree_editor = self.c.frame.tree.tcEdi.editor._jta

    if aComponent == editor:
        return logCtrl
    elif aComponent == tree:
        return editor

    elif aComponent == tree_editor:
        return editor
    else:
        return tree

</t>
<t tx="ekr.20071102163001.255">def getDefaultComponent (self,container):

    return self.c.frame.body.editor.editor

</t>
<t tx="ekr.20071102163001.256">def getFirstComponent (self,aContainer):

    return self.c.frame.body.editor.editor</t>
<t tx="ekr.20071102163001.257">def getInitialComponent (self,window):

    return self.c.frame.body.editor.editor



</t>
<t tx="ekr.20071102163001.258">def getLastComponent (self,aContainer):

    return self.c.frame.log.getCurrentTab()

</t>
<t tx="ekr.20071102163001.259">class Receiver(java.lang.Runnable):
    '''A Class that receives UDP packets, and will bring the frame
       parameter to the front if the packet contains the open file name
       of the Commander instance passed in'''

    def __init__ (self,frame,c):
        self.frame = frame
        self.c = c



</t>
<t tx="ekr.20071102163001.260">def run (self):

    s = java.lang.String(self.c.mFileName)
    random = java.util.Random(s.hashCode())
    i = 0
    while i &lt;= 2000:
        i = random.nextInt(65535+1)

    ia = java.net.InetAddress.getByName("127.0.0.1")
    mcs = java.net.DatagramSocket(i,ia)

    import jarray
    s = java.lang.String(self.c.mFileName)
    bytes = s.getBytes()

    while 1:
        try:
            array = jarray.zeros(len(bytes),'b')
            dgp = java.net.DatagramPacket(array,len(bytes))
            dgp.setPort(i)
            dgp.setAddress(ia)
            mcs.receive(dgp)
            nexts = java.lang.String(dgp.getData())

            if nexts.equals(s):
                self.frame.top.setVisible(True)
                self.frame.top.setState(self.frame.top.NORMAL)
                self.frame.top.toFront()
                self.frame.body.editor.editor.requestFocusInWindow()
        except java.lang.Exception, x:
            x.printStackTrace()
</t>
<t tx="ekr.20071102163001.261">class GlassPane2(swing.JPanel):

    @others</t>
<t tx="ekr.20071102163001.262">def __init__ (self):

    swing.JPanel.__init__(self)

    self.setOpaque(False)
    self.alpha = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,float(0.5))
    self.image = None
    self.setLayout(None)


</t>
<t tx="ekr.20071102163001.263">def setImage (self,image):

    self.image = image
    self.setVisible(g.choose(image,True,False))
</t>
<t tx="ekr.20071102163001.264">def phaseIn (self,widget):

    psize = widget.getPreferredSize()
    self.add(widget)
    bi = awt.image.BufferedImage(psize.width,psize.height,awt.image.BufferedImage.TYPE_INT_RGB)
    g = bi.createGraphics()
    widget.paint(g)
    self.remove(widget)
    g.dispose()
    self.setVisible(True)
    self.Phaser(widget,bi,self)
</t>
<t tx="ekr.20071102163001.265">class Phaser(aevent.ActionListener):

    def __init__ (self,widget,image,parent):
        self.widget = widget
        self.parent = parent
        self.image = image
        self.increments = 20
        self.waitperiod = 1000 / self.increments
        self.timer = swing.Timer(self.waitperiod,self)
        self.timer.start()

    def actionPerformed (self,event):

        alpha = 1.0 / self.increments
        g = self.parent.getGraphics()
        spot = self.widget.getLocation()
        ac = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,alpha)
        g.setComposite(ac)
        g.drawImage(self.image,spot.x,spot.y,None)
        g.dispose()
        self.increments -= 1
        if self.increments == 0:
            self.timer.stop()
            self.parent.add(self.widget)
            self.parent.revalidate()</t>
<t tx="ekr.20071102163001.266">def paintComponent2 (self,g):

    if not self.image: return

    composite = g.getComposite()
    mpi = awt.MouseInfo.getPointerInfo()
    location = mpi.getLocation()
    swing.SwingUtilities.convertPointFromScreen(location,self)
    g.setComposite(self.alpha)
    g.drawImage(self.image,location.x,location.y,None)
    g.setComposite(composite)</t>
<t tx="ekr.20071102163001.267">import java.awt.datatransfer as dtfr

class NodeBar(dtfr.FlavorListener,java.lang.Runnable):
    '''This class creates a toolbar that offers the user the ability to manipulate nodes
        with a button press.'''

    @others

</t>
<t tx="ekr.20071102163001.268">def __init__ (self,c,toolbar):

    self.c = c
    bcommands = (
        (c.moveOutlineUp,"nodeup.gif",'Move Node Up',c.canMoveOutlineUp),
        (c.moveOutlineDown,"nodedown.gif",'Move Node Down',c.canMoveOutlineDown),
        (c.moveOutlineLeft,"nodeleft.gif",'Move Node Left',c.canMoveOutlineLeft),
        (c.moveOutlineRight,"noderight.gif",'Move Node Right',c.canMoveOutlineRight),
        (c.clone,"clone.gif",'Clone Node',c.canClone),
        (c.copyOutline,"copy.gif",'Copy Node',0),
        (c.cutOutline,"cut.gif",'Cut Node',c.canCutOutline),
        (c.deleteOutline,"delete.gif",'Delete Node',c.canDeleteHeadline),
        (c.pasteOutline,"paste.gif",'Paste Node',c.canPasteOutline),
        (c.pasteOutlineRetainingClones,"pasteclone.gif",'Paste Retaining Clones',c.canPasteOutline),
        (c.insertHeadline,"insert.gif",'Insert Node',0),
        (c.demote,"demote.gif",'Demote',c.canDemote),
        (c.promote,"promote.gif",'Promote',c.canPromote),
        (c.hoist,"hoist.gif",'Hoist',c.canHoist),
        (c.dehoist,"dehoist.gif",'De-Hoist',c.canDehoist),
        (c.sortChildren,"sortchildren.gif",'Sort Children',c.canSortChildren),
        (c.sortSiblings,"sortsiblings.gif",'Sort Siblings',c.canSortSiblings),
        (c.goToPrevSibling,"moveup.gif",'Goto Previous Sibling',self.canGotoPreviousSibling),
        (c.goToNextSibling,"movedown.gif",'Goto Next Sibling',self.canGotoNextSibling),
        (c.goToParent,"moveleft.gif",'Goto Parent',self.canGotoParent),
        (self.goToChild,"moveright.gif",'Goto Child',self.canGotoChild),
    )

    self.buttons_enabled = {}
    for z in bcommands:
        button = self.createButton(z[1])
        button.setToolTipText(z[2])
        button.actionPerformed = self.getCallback(z[0])
        if z [3]: self.buttons_enabled [button] = z [3]
        toolbar.add(button)

    wm1 = WeakMethod(self,"endUpdate")
    leoPlugins.registerHandler("select1",wm1)
    leoPlugins.registerHandler("chapter-changed",wm1)
    leoPlugins.registerHandler("chapter-removed",wm1)
    leoPlugins.registerHandler("hoist-executed",wm1)
    leoPlugins.registerHandler("dehoist-executed",wm1)
    #--&gt; disable for now, this seems to flaky behavorialy, but the idea is good
    #tk = java.awt.Toolkit.getDefaultToolkit()
    #clipboard = tk.getSystemClipboard()
    #clipboard.addFlavorListener( self )
    self.runs = 0

def getCallback (self,command):

    def callback (self,event=None,c=self.c):
        command()


    return callback

</t>
<t tx="ekr.20071102163001.269">def createButton (self,name):

    #bytes = java.lang.String( base64.decodestring( data ) ).getBytes()

    path = g.os_path_join(g.app.loadDir,"..","Icons/nodebar",name)
    ii = swing.ImageIcon(path)
    jb = swing.JButton(ii)
    #size = awt.Dimension( ii.getIconWidth(), ii.getIconHeight() )
    return jb

</t>
<t tx="ekr.20071102163001.270">def endUpdate (self,tag,*args,**kwords):

    c = args [0] ['c']
    #print tag
    if c == self.c:
        swing.SwingUtilities.invokeLater(self)
    else:
        print "C %s not == to %s" % (c,self.c)



</t>
<t tx="ekr.20071102163001.271">def flavorsChanged (self,event):

    #print event
    #print event.getSource()
    cb = event.getSource()
    #print cb.getName()
    #import java.awt.datatransfer as dtfr
    #print cb.getData( dtfr.DataFlavor.stringFlavor )
    #print cb.getAvailableDataFlavors()
    self.endUpdate("flavor-change",{'c': self.c})</t>
<t tx="ekr.20071102163001.272">def canGotoParent (self):

    cp = self.c.currentPosition()
    if not cp: return False
    parent = cp.getParent()
    if parent:
        return True
    return False


def canGotoChild (self):

    cp = self.c.currentPosition()
    if not cp: return False
    nc = cp.numberOfChildren()
    if nc != 0: return True
    return False

def canGotoPreviousSibling (self):

    cp = self.c.currentPosition()
    if not cp: return False
    psibling = cp.moveToBack()
    if psibling:
        return True
    return False

def canGotoNextSibling (self):

    cp = self.c.currentPosition()
    if not cp: return False
    nsibling = cp.moveToNext()
    if nsibling:
        return True
    return False</t>
<t tx="ekr.20071102163001.273">def goToChild (self):

    c = self.c ; p = c.currentPosition()

    if p.hasChildren():
        beginUpdate()
        try:
            c.selectPosition(p.firstChild())
        finally:
            endUpdate()</t>
<t tx="ekr.20071102163001.274">@
nodeup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhqM
j6nL7QDcgVBS2u5dWqfeTWA4lqYnpeqqFgA7'''
nodedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhuM
j6nL7Q2inLTaGW49Wqa+XBD1YE8GnOrKBgUAOw=='''
nodeleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiOM
jwDIqd3Ug0dOam/MC3JdfR0jjuRHBWjKpUbmvlIsm65WAAA7'''
noderight = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiGM
A3DLltrag/FMWi+WuiK9WWD4gdGYdenklUnrwqX8tQUAOw=='''
clone = r'''R0lGODlhEAAQAIABAP8AAP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhaM
j6nL7Q8jBDRWG8DThjvqSeJIlkgBADs='''
copy = r'''R0lGODlhEAAQAMIEAAAAAI9pLOcxcaCclf///////////////ywAAAAAEAAQAAADLEi63P5vSLiC
vYHiq6+wXSB8mQKcJ2GNLAssr0fCaOyB0IY/ekn9wKBwSEgAADs='''
cut = r'''R0lGODlhEAAQAKECAAAAAKCclf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiaUDad7yS8cnDNYi4A0t7vNaCLTXR/ZZSBFrZMLbaIWzhLczCxTAAA7'''
paste = r'''R0lGODlhEAAQAKECAAAAAB89vP///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUH3nLktHYm9HMV92FWfPugQcgjqVBnmm5dsD7gmsbwfEZFQA7'''
insert = r'''R0lGODlhEAAQAKECAAAAAB89vP///////ywAAAAAEAAQAAACKJRhqSvIDGJ8yjWa5MQ5BX4JwXdo
3RiYRyeSjRqKmGZRVv3Q4M73VAEAOw=='''
demote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiiUj2nBrNniW+G4eSmulqssgAgoduYWeZ+kANPkCsBM1/abxLih70gBADs='''
promote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUj6kX7cvcgy1CUU1ecvJ+YUGIbKSJAAlqqGQLxPI8t29650YBADs='''
pasteclone = r'''R0lGODlhEAAQAKEDACMj3v8AAP/9/f///ywAAAAAEAAQAAACOJSPaTPgoxBzgEVDM4yZbtU91/R8
ClkJzGqp7MK21rcG9tYedSCb7sDjwRLAGs7HsPF8khjzcigAADs='''
hoist = r'''R0lGODlhEAAQAKECAAAAAENMzf/9/f/9/SwAAAAAEAAQAAACI5SPaRCtypp7S9rw4sVwzwQYW4ZY
JAWhqYqE7OG+QvzSrI0WADs='''
dehoist = r'''R0lGODlhEAAQAKECAAAAACMj3v/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUj6lrwOteivLQKi4LXCcOegJIBmIZLminklbLISIzQ9hbAAA7'''
question = r'''R0lGODlhEAAQAIABAB89vP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiCM
DwnHrNrcgzFQGuGrMnGEfdtnjKRJpt2SsuxZqqgaFQA7'''
sortchildren = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SwAAAAAEAAQAAACJJSPKcGt2NwzbKpqYcg68oN9ITde
UQCkKgCeCvutsDXPk/wlBQA7'''
sortsiblings = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUFalxbatcS7IiZh3NE2L+fOAGXpknal4JlAIAw2Br0Fksu1YBADs='''
delete = r'''R0lGODlhEAAQAMIEAAAAAB89vKCclbq3sv///////////////yH+FUNyZWF0ZWQgd2l0aCBUaGUg
R0lNUAAsAAAAABAAEAAAAzJIutwKELoGVp02Xmy5294zDSSlBAupMleAEhoYuahaOq4yCPswvYQe
LyT0eYpEW8iRAAA7'''
moveup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh6M
j6nL7QDcgVDWcFfGUW3zfVPHPZHoUeq6Su4LwwUAOw=='''
movedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh+M
j6nL7Q2inFS+EDFw2XT1eVsSHmGJdChpXesFx00BADs='''
moveleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
jwDIqd3egueFSe2lF2+oGV41fkwoZmNJJlxXvbDJSbKI1l4BADs='''
moveright = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
A3DLltqaSpFBWt3BFTovWeAyIiUinSNnkaf2Zagpo2x343IBADs='''
@c



</t>
<t tx="ekr.20071102163001.275">def run (self):

    try:
        #print "RUN NUMBER %s" % self.runs
        self.runs += 1
        for z in self.buttons_enabled:
            button = z
            callback = self.buttons_enabled [z]
            #print callback
            if callback():
                button.setEnabled(1)
            else:
                button.setEnabled(0)
    except:
        print "BOOM!!"
</t>
<t tx="ekr.20071102163001.276">class WindowClosingWatcher(aevent.WindowAdapter):

    def __init__ (self,frame):
        aevent.WindowAdapter.__init__(self)
        self.frame = frame

    def windowClosing (self,event):

        g.app.closeLeoWindow(self.frame)
        if len(g.app.windowList) == 0:
            java.lang.System.exit(0)
</t>
<t tx="ekr.20071102163001.277">class LeoMetalTheme(swing.plaf.metal.DefaultMetalTheme):

    def __init__ (self,c):

        swing.plaf.metal.DefaultMetalTheme.__init__(self)
        self.c = c
        self.p1 = swing.plaf.ColorUIResource(awt.Color.YELLOW)
        self.p3 = swing.plaf.ColorUIResource(awt.Color.YELLOW)
        self.p2 = swing.plaf.ColorUIResource(awt.Color.YELLOW)
        self.s1 = swing.plaf.ColorUIResource(awt.Color.YELLOW)
        self.s2 = swing.plaf.ColorUIResource(awt.Color.YELLOW)
        self.s3 = swing.plaf.ColorUIResource(awt.Color.YELLOW)

        print self.p1, self.p2, self.p3, self.s1, self.s2, self.s3

    @others
</t>
<t tx="ekr.20071102163001.278">def getName (self):
    return "LeoMetalTheme"

</t>
<t tx="ekr.20071102163001.279">def getControlTextFont2 (self):
    pass

</t>
<t tx="ekr.20071102163001.280">def getMenuTextFont2 (self):
    pass

</t>
<t tx="ekr.20071102163001.281">def getPrimary1 (self):
    print 'p1'
    return self.p1

</t>
<t tx="ekr.20071102163001.282">def getPrimary2 (self):
    print 'p2'
    return self.p2

</t>
<t tx="ekr.20071102163001.283">def getPrimary3 (self):
    print 'p3'
    return self.p3

</t>
<t tx="ekr.20071102163001.284">def getSecondary1 (self):
    print "s1"
    return self.s1

</t>
<t tx="ekr.20071102163001.285">def getSecondary2 (self):
    print "s2"
    return self.s2

</t>
<t tx="ekr.20071102163001.286">def getSecondary3 (self):
    print "s3"
    return self.s3

</t>
<t tx="ekr.20071102163001.287">def getBlack2 (self):
    print "BLACK"
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

</t>
<t tx="ekr.20071102163001.288">def getMenuBackground (self):
    print "GMB"
    return self.getWhite()

</t>
<t tx="ekr.20071102163001.289">def getMenuForeground (self):
    print "MFG"
    return self.getBlack()

</t>
<t tx="ekr.20071102163001.290">def getMenuSelectedForeground (self):
    print "MSFG!"
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

</t>
<t tx="ekr.20071102163001.291">def getMenuSelectedBackground (self):
    print "MSBG"
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

</t>
<t tx="ekr.20071102163001.292">def getPrimaryControl (self):
    print "PCONTROL"
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

</t>
<t tx="ekr.20071102163001.293">def getControl (self):
    print "CONTROL"
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

</t>
<t tx="ekr.20071102163001.294">def getControlHighlight (self):
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

</t>
<t tx="ekr.20071102163001.295">def getPrimaryControlHighlight (self):
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

</t>
<t tx="ekr.20071102163001.296">def getSystemTextColor (self):
    return swing.plaf.ColorUIResource(awt.Color.WHITE)

</t>
<t tx="ekr.20071102163001.297">def getSubTextFont2 (self):
    pass

</t>
<t tx="ekr.20071102163001.298">def getSystemTextFont2 (self):
    pass

</t>
<t tx="ekr.20071102163001.299">def getUserTextFont2 (self):
    pass

</t>
<t tx="ekr.20071102163001.300">def getWindowTitleFont2 (self):
    pass
</t>
<t tx="ekr.20071102163001.301">class leoSwingGui:

    @others
</t>
<t tx="ekr.20071102163001.302"></t>
<t tx="ekr.20071102163001.303">def __init__ (self):

    # g.trace("leoGui",guiName)
    #leoGui.leoGui.__init__( self, "swing" )
    self.leoIcon = None
    self.mGuiName = "swing"
    self.mainLoop = None
    self.root = None
    self.utils = None
    self.isNullGui = False
    self.ex = java.util.concurrent.Executors.newSingleThreadScheduledExecutor()
    self.startup_tasks = java.util.ArrayList()
    self.laflistener = self.LAFChangeListener()
    swing.UIManager.addPropertyChangeListener( self.laflistener )
</t>
<t tx="ekr.20071102163001.304">def newLeoCommanderAndFrame(self,fileName, updateRecentFiles = True):

    """Create a commander and its view frame for the Leo main window."""

    import leoCommands

    if not fileName: fileName = ""
    &lt;&lt; compute the window title &gt;&gt;
@
    if not splashseen:
        #self.splash = splash = swing.JWindow()
        #splash.setBackground( awt.Color.ORANGE )
        #dimension = awt.Dimension( 500, 500 )
        #splash.setPreferredSize( dimension )
        #splash.setSize( 500, 500 )
        #ii = swing.ImageIcon( "../Icons/Leosplash.GIF" )
        #image = swing.JLabel( ii )
        #image.setBackground( awt.Color.ORANGE )
        #splash.add( image )
        #self.splashlabel = swing.JLabel( "BORKERS ar fUN" )
        #splash.add( self.splashlabel, awt.BorderLayout.SOUTH )
        w, h = self._calculateCenteredPosition( splash )
        splash.setLocation( w, h )
        splash.visible = True
@c
    # Create an unfinished frame to pass to the commanders.
    class Create( java.util.concurrent.Callable ):

        def call( self ):
            frame = g.app.gui.createLeoFrame(title)
            c = leoCommands.Commands( frame, fileName )
            frame.finishCreate( c )
            return c, frame

    creator = java.util.concurrent.FutureTask( Create() )
    java.awt.EventQueue.invokeAndWait( creator )
    c, frame = creator.get()
    self.c = c       
    # Create the commander and its subcommanders.
    #self.c = c = leoCommands.Commands(frame,fileName)

    # Finish creating the frame



    #frame.finishCreate(c)

    # Finish initing the subcommanders.
    #c.undoer.clearUndoState() # Menus must exist at this point.

    #c.updateRecentFiles(fileName) # 12/01/03
    c.undoer.clearUndoState() # Menus must exist at this point.

    if updateRecentFiles:
        c.updateRecentFiles(fileName)

    g.doHook("after-create-leo-frame",c=c)
    return c,frame</t>
<t tx="ekr.20071102163001.305"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

</t>
<t tx="ekr.20071102163001.306"></t>
<t tx="ekr.20071102163001.307">def createRootWindow(self):

    """Create the hidden root window for the gui.

    Nothing needs to be done if the root window need not exist."""

    jf = swing.JFrame()
    return jf


</t>
<t tx="ekr.20071102163001.308">def destroySelf (self):

    #self.oops()
    pass</t>
<t tx="ekr.20071102163001.309">def finishCreate (self):

    """Do any remaining chores after the root window has been created."""
    #pass
    #self.c.frame.setTitle( self.c.mFileName )
    pass


</t>
<t tx="ekr.20071102163001.310">def killGui(self,exitFlag=True):

    """Destroy the gui.

    The entire Leo application should terminate if exitFlag is True."""

    pass</t>
<t tx="ekr.20071102163001.311">def recreateRootWindow(self):

    """Create the hidden root window of the gui
    after a previous gui has terminated with killGui(False)."""

    pass</t>
<t tx="ekr.20071102163001.312">def runMainLoop(self):
    """Run the gui's main loop."""

    def rml():
        self.c.frame.tree.doneLoading()
        self.c.frame.top.visible = True
        self.c.frame.jsp1.setDividerLocation( .75 )
        self.c.frame.jsp2.setDividerLocation( .5 )
        self.c.selectPosition( self.c.currentPosition() )
        self.c.frame.body.editor.editor.setCaretPosition( 0 ) #otherwise the caret is at the end, yuck.
        dc = DefCallable( self.ex.shutdown )
        self.startup_tasks.add( dc )
        for z in self.startup_tasks:
            self.ex.submit( z )

        def hide():
            splash.hide()
        dc = DefCallable( hide )
        ft = dc.wrappedAsFutureTask()
        java.awt.EventQueue.invokeLater( ft )

    dc = DefCallable( rml )
    ft = dc.wrappedAsFutureTask()    
    java.awt.EventQueue.invokeLater( ft )
</t>
<t tx="ekr.20071102163001.313">def runAboutLeoDialog(self,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    dialog = self._getDialog( "About Leo" )
    cpane = dialog.getContentPane()
    data = "%s\n%s\n\n%s\n\n%s" % ( version, theCopyright, url, email )
    jtc = swing.JTextArea()
    jtc.setText( data )
    jtc.setEditable( False )
    dialog.add( jtc )
    class cl_act( swing.AbstractAction ):
        def __init__( self, dialog ):
            swing.AbstractAction.__init__( self, "Close" )
            self.dialog = dialog

        def actionPerformed( self, aE ):
            self.dialog.dispose()
    button = swing.JButton( cl_act( dialog ) )
    jbp = swing.JPanel()
    jbp.add( button )
    dialog.add( jbp, awt.BorderLayout.SOUTH )
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    dialog.visible = 1

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    message = (
        "leoID.txt not found\n\n" +
        "Please enter an id that identifies you uniquely.\n" +
        "Your cvs login name is a good choice.\n\n" +
        "Your id must contain only letters and numbers\n" +
        "and must be at least 3 characters in length.") 

    dialog = swing.JDialog()
    dialog.title = "Create a Leo ID"
    dialog.modal = 1
    cpane = dialog.getContentPane()
    jta = swing.JTextArea()
    jta.setText( message )
    jta.editable = 0
    cpane.add( jta, awt.BorderLayout.NORTH )
    jtf = swing.JTextField()
    jp = swing.JPanel()
    jp.setBorder( sborder.TitledBorder( "Your ID:" ) )
    gbl = awt.GridBagLayout()
    jp.setLayout( gbl )
    gbc = awt.GridBagConstraints()
    gbc.fill = 1
    gbc.weightx =1
    gbc.weighty = 1
    gbl.setConstraints( jtf, gbc )
    jp.add( jtf )
    cpane.add( jp, awt.BorderLayout.CENTER )
    class _OK( swing.AbstractAction ):
        def __init__( self ):
            swing.AbstractAction.__init__( self, "OK" )

        def actionPerformed( self, ae ):
            dialog.dispose()
    jb = swing.JButton( _OK()  )

    jb.setEnabled( False )
    jpanel2 = swing.JPanel()
    jpanel2.add(jb )
    cpane.add( jpanel2, awt.BorderLayout.SOUTH )
    class _Enabler( sevent.DocumentListener ):

        def __init__( self ):
            pass

        def changedUpdate( self, de ):
            pass

        def insertUpdate( self, de ):

            l = de.getDocument().getLength()
            if l &gt;= 3: jb.setEnabled( True )

        def removeUpdate( self, de ):

            l = de.getDocument().getLength()
            if l &lt;3: jb.setEnabled( False )
    jtf.getDocument().addDocumentListener( _Enabler() )       
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    splash.toBack()
    dialog.visible = 1
    g.app.leoID = jtf.getText()
    splash.toFront()

def runAskOkDialog(self,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,title,message):
    """Create and run askOkCancelNumber dialog ."""
    dialog = self._getDialog( title )
    cpane = dialog.getContentPane()
    holder = swing.JPanel()
    gbl = awt.GridBagLayout()
    holder.setLayout( gbl )
    gbc = awt.GridBagConstraints()
    gbc.fill = 1
    gbc.weightx = 1
    gbc.weighty = 1
    jtf = swing.JTextField()
    gbl.setConstraints( jtf, gbc )
    holder.add( jtf )
    tborder = sborder.TitledBorder( message )
    holder.setBorder( tborder )
    cpane.add( holder )
    class _Search( swing.AbstractAction ):
        source = None
        def __init__( self, dialog, message ):
            swing.AbstractAction.__init__( self, message )
            self.dialog= dialog
            self.message = message

        def actionPerformed( self, ae ):
            _Search.source = ae.getSource()
            self.dialog.dispose()

    jb = swing.JButton( _Search( dialog, "Ok" ) )
    jb2 = swing.JButton( _Search( dialog, "Cancel" ) )
    class _Enter( aevent.ActionListener ):
        def __init__( self, ok_but ):
            self.ok_but = ok_but

        def actionPerformed( self, aE ):
            _Search.source = self.ok_but
            dialog.dispose()

    jtf.addActionListener( _Enter( jb ) )
    class _AcceptOnlyNumbers( aevent.KeyAdapter ):

        def __init__( self  ):
            aevent.KeyAdapter.__init__( self )
            self.consume = False

        def keyPressed( self, ke ):

            kc = ke.getKeyCode()
            if kc in ( ke.VK_ENTER, ke.VK_BACK_SPACE ): return
            c = ke.getKeyChar()
            if not java.lang.Character.isDigit( c ):
                self.consume = True 
                ke.consume()

        def keyReleased( self, ke ):
            if self.consume:
                self.consume = False
                ke.consume()

        def keyTyped( self, ke ):
            if self.consume:
                ke.consume()

    jtf.addKeyListener( _AcceptOnlyNumbers() )
    bottom = swing.JPanel()
    bottom.add( jb, awt.BorderLayout.WEST )
    bottom.add( jb2, awt.BorderLayout.EAST )
    cpane.add( bottom, awt.BorderLayout.SOUTH )
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    dialog.setVisible( True )
    if _Search.source is jb:
        return int( jtf.getText() )
    else:
        return -1

def runAskYesNoDialog(self,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""

    dialog = self._getDialog( title )
    class yno( swing.AbstractAction ):

        source = None
        def __init__( self, dialog, name ):
            swing.AbstractAction.__init__( self, name )
            self.dialog = dialog

        def actionPerformed( self, aE ):
            yno.source = aE.getSource()
            self.dialog.dispose()

    cpane = dialog.getContentPane()
    cpane.add( swing.JLabel( message ), awt.BorderLayout.NORTH )
    jp = swing.JPanel()
    cpane.add( jp, awt.BorderLayout.SOUTH )

    yes = swing.JButton( yno( dialog, yesMessage ) )
    no = swing.JButton( yno( dialog, noMessage ) )
    cancel = swing.JButton( yno( dialog, "Cancel" ) )
    jp.add( yes )
    jp.add( no )
    jp.add( cancel )
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    dialog.setVisible( True )
    if yno.source is yes:
        return 'yes'
    elif yno.source is no:
        return 'no'
    elif yno.source is cancel:
        return "cancel"
    else:
        if defaultButton == 'Yes': return 'yes'
        else: return 'cancel'

def _getDialog( self, title ):

    jdialog = swing.JDialog( self.c.frame.top, title, True )
    jdialog.getContentPane().setName( "Leodialog" )
    return jdialog

def _getScreenPositionForDialog( self ):

    #tk = self.c.frame.top.getToolkit()
    tk = awt.Toolkit.getDefaultToolkit()
    dim = tk.getScreenSize()
    h = dim.height/2
    w = dim.width/2
    return h, w

def _calculateCenteredPosition( self, widget ):

    size = widget.getPreferredSize()
    height = size.height/2
    width = size.width/2
    h,w = self._getScreenPositionForDialog()
    height = h - height
    width = w - width
    return width, height



</t>
<t tx="ekr.20071102163001.314">class FileTypesFilter( swing.filechooser.FileFilter ):
    def __init__( self, filetypes ):
        swing.filechooser.FileFilter.__init__( self )
        self.filetypes = filetypes

    def accept( self, fvar ):
        name = fvar.getName()
        ftype = self.filetypes[ 1 ]
        ftype = ftype.strip( "*" )
        if name.endswith( ftype ): return True
        return False

    def getDescription( self ):
        return self.filetypes[ 0 ]


def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an open file dialog ."""

    import os
    fd = swing.JFileChooser( os.getcwd() )
    if filetypes:
        for x in fd.getChoosableFileFilters():
            fd.removeChoosableFileFilter( x )
    if filetypes:
        first = None
        for z in filetypes:
            filter = self.FileTypesFilter( z )
            if first is None: first = filter
            fd.addChoosableFileFilter( filter )
        if first:
            fd.setFileFilter( first )
    ok = fd.showOpenDialog( None )
    if ok == fd.APPROVE_OPTION:
        f = fd.getSelectedFile()
        st = f.toString()
        if multiple:
            st = ( st , )
        return st


def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run a save file dialog ."""
    import os
    #self.oops()
    fd = swing.JFileChooser( os.getcwd() )
    if filetypes:
        for x in fd.getChoosableFileFilters():
            fd.removeChoosableFileFilter( x )
    if filetypes:
        first = None
        for z in filetypes:
            filter = self.FileTypesFilter( z )
            if first is None: first = filter
            fd.addChoosableFileFilter( filter )
        if first:
            fd.setFileFilter( first )
    ok = fd.showSaveDialog( None )
    if ok == fd.APPROVE_OPTION:
        f = fd.getSelectedFile()
        st = f.toString()
        if not st.endswith( defaultextension ):
            st = st + defaultextension
        return st</t>
<t tx="ekr.20071102163001.315">def createColorPanel(self,c):
    """Create Color panel."""
    self.oops()

def createComparePanel(self,c):
    """Create Compare panel."""
    import leoSwingComparePanel
    return leoSwingComparePanel.leoSwingComparePanel( c )


def createFindPanel(self):
    """Create a hidden Find panel."""
    self.oops()

def createFontPanel(self,c):
    """Create a Font panel."""
    self.oops()

def createLeoFrame(self,title):
    """Create a new Leo frame."""
    import leoSwingFrame
    lsf = leoSwingFrame.leoSwingFrame( self )
    return lsf

def createPrefsPanel(self,c):
    """Create a Prefs panel."""
    return swing.JFrame()
</t>
<t tx="ekr.20071102163001.316">@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for None returns.

The type of commander passed to methods depends on the type of frame or dialog being created.  The commander may be a Commands instance or one of its subcommanders.</t>
<t tx="ekr.20071102163001.317">class cBoardOwner( dtfr.ClipboardOwner ):


    def lostOwnership( self, clipboard, contents ):
        pass



class LeoTransferable( dtfr.Transferable ): 
    '''This class exists primarily so that the system can detect when a valid
       leoxml tree has been placed in the system clipboard.  It enables the enabling/disabling
       of "paste node"'''
    def __init__( self, data, dataflavor ):

        self.data = data
        self.dataflavors = [ dtfr.DataFlavor.stringFlavor ]
        if dataflavor:
            self.dataflavors.append( dtfr.DataFlavor( dataflavor ) )
        self.dataflavor = dataflavor

    def getTransferData( self, dflavor ):

        if dflavor.getRepresentationClass() == java.lang.String:
            return java.lang.String( self.data )
        elif dflavor.getRepresentationClass() == java.io.InputStream:
            ba = java.lang.String( self.data ).getBytes()
            return java.io.ByteArrayInputStream( ba )

    def getTransferDataFlavors( self ):
        return self.dataflavors 

    def isDataFlavorSupported( self, flavor ):

        if flavor == dtfr.DataFlavor.stringFlavor: return True
        elif str( flavor.getMimeType() ) == self.dataflavor: return True
        return False    


def replaceClipboardWith (self,s, dflavor = None):

    #tk = self.c.frame.top.getToolkit()
    tk = java.awt.Toolkit.getDefaultToolkit()
    cp = tk.getSystemClipboard()
    cBO = self.cBoardOwner()
    #ss = dtfr.StringSelection( s )
    ss = self.LeoTransferable( s, dflavor )
    cp.setContents( ss, cBO )


def getTextFromClipboard (self):

    #tk = self.c.frame.top.getToolkit()
    tk = java.awt.Toolkit.getDefaultToolkit()
    cp = tk.getSystemClipboard()
    contents = cp.getContents( self )
    dflavor = dtfr.DataFlavor.selectBestTextFlavor( contents.getTransferDataFlavors() )
    if not dflavor:
        return None
    reader = dflavor.getReaderForText( contents )
    breader = java.io.BufferedReader( reader )
    txt = []
    try:
        while 1:
            stxt = breader.readLine()
            if stxt != None:
                txt.append( stxt )
            else:
                return '\n'.join( txt )
    except:
        return '\n'.join( txt )




</t>
<t tx="ekr.20071102163001.318">def attachLeoIcon (self,window):
    """Attach the Leo icon to a window."""

    sicon = g.os_path_join( g.app.loadDir,"..","Icons","Leoapp.GIF")
    #ii = swing.ImageIcon( "../Icons/Leosplash.GIF" )
    ii = swing.ImageIcon( sicon )
    window.setIconImage( ii.getImage() )

def center_dialog(self,dialog):
    """Center a dialog."""
    spot = self._calculateCenteredPosition( dialog )
    dialog.setLocation( spot[ 0 ], spot[ 1 ] )

def create_labeled_frame (self,parent,caption=None,relief="groove",bd=2,padx=0,pady=0):
    """Create a labeled frame."""

    w = swing.JPanel()
    parent.add( w )
    if caption:
        border = w.getBorder()
        tborder = sborder.TitledBorder( border )
        tborder.setTitle( caption )
        w.setBorder( tborder )

    sl = swing.SpringLayout()
    w.setLayout( sl )
    f = swing.JPanel()
    w.add( f )
    sl.putConstraint( sl.NORTH, f, 5, sl.NORTH, w )
    sl.putConstraint( sl.WEST, f, 5, sl.WEST, w )
    sl.putConstraint( sl.SOUTH, w, 5, sl.SOUTH, f )
    sl.putConstraint( sl.EAST, w, 5, sl.EAST, f )

    return w, f


def get_window_info (self,window):
    """Return the window information."""
    self.oops()

</t>
<t tx="ekr.20071102163001.319">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):

    pass
    # self.oops()</t>
<t tx="ekr.20071102163001.320">def get_focus(self,frame):

    """Return the widget that has focus, or the body widget if None."""

    self.oops()

def set_focus(self,commander,widget):

    """Set the focus of the widget in the given commander if it needs to be changed."""

    widget.requestFocusInWindow()</t>
<t tx="ekr.20071102163001.321">def firstIndex (self):

    self.oops()

def lastIndex (self):

    self.oops()

def moveIndexForward(self,t,index,n):

    self.oops()

def moveIndexToNextLine(self,t,index):

    self.oops()</t>
<t tx="ekr.20071102163001.322">def setIdleTimeHook (self,idleTimeHookHandler,*args,**keys):

    pass # Not an error.

def setIdleTimeHookAfterDelay (self,delay,idleTimeHookHandler,*args,**keys):

   pass # Not an error.
</t>
<t tx="ekr.20071102163001.323">def guiName(self):

    try:
        return self.mGuiName
    except:
        return "invalid gui name"</t>
<t tx="ekr.20071102163001.324">def oops (self):

    print "leoGui oops", g.callerName(2), "should be overridden in subclass"</t>
<t tx="ekr.20071102163001.325">def getInsertPoint( self, t ):

    return t.getCaretPosition()


def setInsertPoint( self, t, pos ):
    #pass
    #return t.setCaretPosition( pos )
    t.setCaretPosition( pos )

def getSelectionRange( self, t ):

    s = t.getSelectedText()
    s = "%s" % s
    return s

def setTextSelection( self, t, start, end ):

    t.setSelectionStart( start )
    t.setSelectionEnd( end )

def setSelectionRange(  self, t, n1, n2 ):
    return g.app.gui.setTextSelection( t, n1, n2 )


def getTextSelection( self, t ):


    return ( t.getSelectionStart(), t.getSelectionEnd() )</t>
<t tx="ekr.20071102163001.326">def makeIndexVisible(self,t,index):

    print t
    print index
    #return t.see(index) </t>
<t tx="ekr.20071102163001.327">def moveIndexForward(self,t,index,n):

    t = self.c.frame.body.editor.editor 
    #print index
    #print n
    #print t
    t.setCaretPosition( index[ 1 ] )
    #newpos = t.index("%s+%dc" % (index,n))
    if len( t.getText() ) &lt;= ( index[ 1 ] ): return None
    else:
        return index[ 1 ]
    #return g.choose(t.compare(newpos,"==","end"),None,newpos)

def moveIndexToNextLine(self,t,index):
    pass
    #newpos = t.index("%s linestart + 1lines" % (index))

    #return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20071102163001.328">def addStartupTask( self, task ):
    '''Adds a task to the collection of tasks that are
       executed upon startup'''

    self.startup_tasks.add( task )
</t>
<t tx="ekr.20071102163001.329">def getFontFromParams( self, family,size,slant,weight):

    #print family, size, slant, weight

    if size in ( 'None', None ):
        size = 12
    else:
        size = int( size )

    if weight in ( 'None', None):
        weight = awt.Font.PLAIN
    else:
        weight = weight
        weights = weight.split( "and" )
        nweight = None
        for z in weights:
            z = z.strip()
            #print z
            if not hasattr( awt.Font, z ): continue
            w2 = getattr( awt.Font, z )
            if nweight:
                nweight = nweight|w2
            else:
                nweight = w2
        weight = nweight

    if family in ( 'None', None ):
        family = 'Helvetica'
    else:
        #family = family[ 1 ]
        pass

    #print family, size, slant, weight    
    f = awt.Font( family, weight, size )
    return f    

</t>
<t tx="ekr.20071102163001.330">@others
</t>
<t tx="ekr.20071102163001.331">def addLAFListener( self, component ):
    self.laflistener.addComponent( component )

</t>
<t tx="ekr.20071102163001.332">class LAFChangeListener( java.beans.PropertyChangeListener ):

    def __init__( self ):
        self.changers = []


    def addComponent( self, component ):
        ref = java.lang.ref.WeakReference( component )
        self.changers.append( ref )

    def propertyChange( self, event ):
        if event.getPropertyName() == 'lookAndFeel':
            for z in self.changers:
                component = z.get()
                if component:
                    swing.SwingUtilities.updateComponentTreeUI( component )</t>
<t tx="ekr.20071102163001.333">@others
</t>
<t tx="ekr.20071102163001.334">def replaceSelectionRangeWithText( self, t, start, end, change ):


    if t:
        doc = t.getDocument()
        doc.replace( start, end - start, change, None )


</t>
<t tx="ekr.20071102163001.335">def setSelectionRangeWithLength( self, t, start, length ):


    if t:
        t.setSelectionStart( start )
        t.setSelectionEnd( start + length )
</t>
<t tx="ekr.20071102163001.336">def compareIndices( self, st, pos, which, pos2 ):

    if which == '&gt;':

        return int( pos ) &gt; int( pos2 )

    elif which == '&lt;':

        return int( pos ) &lt; int( pos2 )

</t>
<t tx="ekr.20071102163001.337">def getAllText( self,st ):

    print st
    doc = st.getDocument()
    return doc.getText( 0, doc.getLength() )</t>
<t tx="ekr.20071102163001.338">class leoSwingLog:

    @others</t>
<t tx="ekr.20071102163001.339">def __init__ (self,frame,parentFrame):

    self._font = None
    self.jta = None
    #leoFrame.leoLog.__init__( self, frame, parentFrame )
    self.frame = frame
    self.c = frame.c
    self.enabled = True
    self.newlines = 0

    # Note: self.logCtrl is None for nullLog's.
    self.logCtrl = self.createControl(parentFrame)
    self.setFontFromConfig()
    self.setColorFromConfig()

    #self.c = frame.c
    self._font = None

    manager = g.app.config.manager
    for z in ( "log_pane_background_color", "log_text_foreground_color", "log_text_background_color" ):
        manager.addNotificationDef( z, self.setColorFromConfig )
    for z in ( "log_text_font_family", "log_text_font_size" ,  "log_text_font_weight" ):
        manager.addNotificationDef( z, self.setFontFromConfig )


</t>
<t tx="ekr.20071102163001.340">def configure (self,*args,**keys):

    self.oops()</t>
<t tx="ekr.20071102163001.341">def configureBorder(self,border):

    self.oops()
</t>
<t tx="ekr.20071102163001.342">def createControl (self,parentFrame):

    self.tab_manager = TabManager( switch_on_add = 0 )
    self.tab_manager.tabsToBottom()
    self._jtp = jtp = self.tab_manager.base

    self.logCtrl = logCtrl = self.jta = self.LogControl()
    self.logCtrl.setFocusable( True );
    logCtrl.setName( "Log" )
    import utilities.CutCopyPaste as CCP
    CCP.CutCopyPaste( logCtrl )
    self.setColorFromConfig()

    if self._font:
        logCtrl.setFont( self._font )
    self.jsp = swing.JScrollPane( logCtrl )

    self.tab_manager.add( "Log", self.jsp )
    logCtrl.addFocusListener( leoJSPFocusListener( self.jsp, self.c ) )
    parentFrame.rightComponent = jtp
    self.setBackgroundImage()
    g.doHook( "leoswinglogcreated", c = self.c, log = self )




</t>
<t tx="ekr.20071102163001.343">def enable (self,enabled=True):

    self.enabled = enabled

def disable (self):

    self.enabled = False
</t>
<t tx="ekr.20071102163001.344">def oops (self):

    print "leoLog oops:", g.callerName(2), "should be overridden in subclass"</t>
<t tx="ekr.20071102163001.345">def setFontFromConfig (self, notification = None, handback = None):

    logCtrl = self.jta ; config = g.app.config

    font = config.getFontFromParams( self.c,
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        config.defaultLogFontSize)

    if font:
        #awt_font = awt.Font.decode( font )
        self._font = font
        if logCtrl:
            logCtrl.setFont( font )





</t>
<t tx="ekr.20071102163001.346">def onActivateLog (self,event=None):

    try:
        g.app.setLog(self,"OnActivateLog")
    except:
        g.es_event_exception("activate log")</t>
<t tx="ekr.20071102163001.347"># All output to the log stream eventually comes here.

def put (self,s,color=None):

    if self.jta:
        pos = self.jta.getCaretPosition()
        document = self.jta.getStyledDocument()
        attrset = None

        if color:
            if hasattr( awt.Color, color ):
                attrcolor = getattr( awt.Color, color )
                attrset = stext.SimpleAttributeSet()
                stext.StyleConstants.setForeground( attrset, attrcolor  )

        document.insertString( document.getLength(), s, attrset )
        npos = document.getLength() - len( s )
        self.jta.setCaretPosition( npos )
    else:
        g.app.logWaiting.append( ( s , color ) )

    if leoSwingGui.splash.isVisible():
        leoSwingGui.splash.setText( s )


def putnl (self):

    if self.jta:
        doc = self.jta.getStyledDocument()
        doc.insertString( doc.getLength(), "\n", None )
    else:
        g.app.logWaiting.append( '\n' )




</t>
<t tx="ekr.20071102163001.348">class LogControl( swing.JTextPane ):

    def __init__( self, *args ):
        swing.JTextPane.__init__( self, *args )
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, 1.0 )
        self.lastDimensions = awt.Rectangle( 0,0,0,0 )
        self.image = None
        self.last_image= None


    def setAlpha( self, alpha ):
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, alpha )


    def setImage( self, image ):
        self.image = image


    def paintComponent( self, graphics ):

        #self.super__paintComponent( graphics )
        if self.image:
            vrec = self.getVisibleRect()
            if not self.lastDimensions.equals( vrec ):
                self.lastDimensions = vrec
                self.last_image = self.image.getScaledInstance( vrec.width, vrec.height, awt.Image.SCALE_REPLICATE )
            composite = graphics.getComposite()
            graphics.setComposite( self.alpha )
            graphics.drawImage( self.last_image, vrec.x, vrec.y, awt.Color.WHITE, None )
            graphics.setComposite( composite )       
        self.super__paintComponent( graphics )

</t>
<t tx="ekr.20071102163001.349">def setBackgroundImage( self, notification = None, handback = None ):

    c = self.c


    use_background = g.app.config.getBool( c, "log_use_background_image" )    
    if not use_background:
        return

    alpha = g.app.config.getFloat( c, "log_background_alpha" )
    if alpha == None: alpha = 1.0
    image_path = g.app.config.getString( c, "log_image_location@as-filedialog" )
    if image_path:
        imfile = java.io.File( image_path ) 
        if imfile.exists():
            bimage = imageio.ImageIO.read( imfile )
            #if not hasattr( self, 'background' ): 
            #self.background = EditorBackground( bimage, bimage.getWidth(), bimage.getHeight(), alpha )
            #self.layeredpane.add( self.background, self.layeredpane.DEFAULT_LAYER )
            #self.logBackPane.add( self.background )
            #self.jsp.getViewport().addChangeListener( self.resizer( self.jsp, self.logBackPane ) )
            #self._vport.addChangeListener( self._resizer )
            #self.editor.setOpaque( False )
            #self.jtree.setOpaque( False )
            #self.jpanel.setOpaque( False )
            #self.jspane.setOpaque( False )
            #self.jspane.getViewport().setOpaque( False )
            #self.logCtrl.setOpaque( False )
            #self.jsp.getViewport().setOpaque( False )
            #self.jsp.setOpaque( False )
            self.logCtrl.setOpaque( False )
            self.logCtrl.setImage( bimage )
            self.logCtrl.setAlpha( alpha )
            g.app.config.manager.addNotificationDef( "log_background_alpha", self.setBackgroundImage )
            g.app.config.manager.addNotificationDef( "log_image_location@as-filedialog", self.setBackgroundImage )

            #else:
            #    self.background.setBackground( bimage, bimage.getWidth(), bimage.getHeight(), alpha )
            #    self.background.repaint()



</t>
<t tx="ekr.20071102163001.350">def setColorFromConfig( self, notification = None, handback = None ):

    logCtrl = self.jta
    if logCtrl:
        color = g.app.config.getColor( self.c , "log_pane_background_color" )
        logCtrl.setBackground( getColorInstance( color, awt.Color.WHITE ) )
        color = g.app.config.getColor( self.c, "log_text_foreground_color" )
        logCtrl.setForeground( getColorInstance( color, awt.Color.GRAY ) ) 
        color = g.app.config.getColor( self.c, "log_text_background_color" )
        logCtrl.setSelectionColor( getColorInstance( color, awt.Color.GREEN ) )

</t>
<t tx="ekr.20071102163001.351">def addTab( self, name, component ):

    self.tab_manager.add( name, component )


def selectTab( self, component ):
    self.tab_manager.select( component )

def removeTab( self, component ):

    self.tab_manager.remove( component )


def getCurrentTab( self ):

    ctab = self.tab_manager.getCurrentTab()
    if ctab is None:
        return self.jta
    else:
        size = ctab.getSize()
        x = size.width/2
        y = size.height/2
        component = swing.SwingUtilities.getDeepestComponentAt( ctab, x, y )
        return component
</t>
<t tx="ekr.20071102163001.352">class leoSwingMenu( leoMenu.leoMenu ):


    @others</t>
<t tx="ekr.20071102163001.353">def __init__ (self,frame):

    ld = io.File( g.app.loadDir )
    ijcl.addToSearchPath( ld )
    ijcl.beginLoading()
    self.font = frame.top.getFont()
    self.executor = java.util.concurrent.Executors.newCachedThreadPool()
    self.queue = java.util.concurrent.LinkedBlockingQueue()
    self.menu_changer = self.MenuChanger( self.queue )
    self.names_and_commands = {}
    self.keystrokes_and_actions = {}
    leoMenu.leoMenu.__init__( self, frame )
    #self.createLeoSwingPrint()
    #self.defineLeoSwingPrintTable()
    #self.addCommanderSupplemental()








</t>
<t tx="ekr.20071102163001.354">class MenuChanger( java.lang.Runnable, java.util.concurrent.Callable ):

    def __init__( self, queue ):
        self.queue = queue

    def run( self ):

        ft = java.util.concurrent.FutureTask( self )
        java.awt.EventQueue.invokeLater( ft )


    def call( self ):

        menu , name , label, enabled = self.queue.take() 
        target = None
        for z in menu.getMenuComponents():
            if hasattr( z, "getText" ) and z.getText() == name:
                target = z
                break


        if target:
            target.setText( label )
            target.setEnabled( enabled )
</t>
<t tx="ekr.20071102163001.355">
</t>
<t tx="ekr.20071102163001.356">def defineLeoSwingPrintTable( self ):

    self.printNodeTable= (

    ( "Print Current Node" , None, lambda event: self.lsp.printNode() ),
    ( "Print Current Node as HTML", None, lambda event: self.lsp.printNode( type = "HTML" ) ),
    ( "Print Marked Nodes", None, lambda event:  self.lsp.printMarkedNodes() ),
    ( "Print Marked Nodes as HTML", None, lambda event: self.lsp.printNode( type ="HTML" ) ),

    )

    for z in self.printNodeTable:
        self.names_and_commands[ z[ 0 ] ] = z[ 2 ]
</t>
<t tx="ekr.20071102163001.357">def createLeoSwingPrintMenu( self ):

    fmenu = self.getMenu( "File" )

    components = fmenu.getMenuComponents()

    x = 0
    for z in components:

        if hasattr( z, 'getText' ) and z.getText() == "Recent Files...":
            break
        x += 1


    spot = x + 1

    pmenu = swing.JMenu( "Printing" )

    pnodes = swing.JMenu( "Print Nodes" )
    pmenu.add( pnodes )
    for z in self.printNodeTable:
        item = swing.JMenuItem( z[ 0 ] )
        item.actionPerformed = z[ 2 ]
        pnodes.add( item )

    sep = swing.JSeparator()
    fmenu.add( sep, spot  )
    fmenu.add( pmenu, spot + 1 )

    print_tree = swing.JMenuItem( "Print Tree As Is" )
    print_tree.actionPerformed = self.lsp.printTreeAsIs
    pmenu.add( print_tree )
    self.names_and_commands[ "Print Tree As Is" ] = self.lsp.printTreeAsIs
    print_as_more = swing.JMenuItem( "Print Outline in More Format" )
    print_as_more.actionPerformed = self.lsp.printOutlineAsMore
    self.names_and_commands[ "Print Outline in More Formet" ] = self.lsp.printOutlineAsMore
    pmenu.add( print_as_more )











</t>
<t tx="ekr.20071102163001.358">def createLeoSwingPrint( self ):

    c = self.c
    import leoSwingPrint
    lsp = leoSwingPrint.leoSwingPrint( c )
    menu = lsp.getAsMenu()

    fmenu = self.getMenu( "File" )

    components = fmenu.getMenuComponents()

    x = 0
    for z in components:

        if hasattr( z, 'getText' ) and z.getText() == "Recent Files...":
            break
        x += 1


    spot = x + 1


    sep = swing.JSeparator()
    fmenu.add( sep, spot  )
    fmenu.add( menu, spot + 1 )


</t>
<t tx="ekr.20071102163001.359"></t>
<t tx="ekr.20071102163001.360">def createPluginMenu( self ):

    top = self.getMenu( 'top' )
    oline = self.getMenu( 'Outline' )
    ind = top.getComponentIndex( oline ) + 1
    import leoSwingPluginManager
    self.plugin_menu = pmenu = leoSwingPluginManager.createPluginsMenu()
    #self.plugin_menu = pmenu = swing.JMenu( "Plugins" )
    top.add( pmenu, ind )
    #cpm = swing.JMenuItem( "Plugin Manager" )
    #cpm.actionPerformed = self.createPluginManager
    #pmenu.add( cpm )
    #pmenu.addSeparator()


    #self.names_and_commands[ "Plugin Manager" ] = self.createPluginManager


</t>
<t tx="ekr.20071102163001.361">def createPluginManager( self, event ):

    import leoSwingPluginManager as lspm
    lspm.topLevelMenu()

</t>
<t tx="ekr.20071102163001.362">def getPluginMenu( self ):

    return self.plugin_menu
</t>
<t tx="ekr.20071102163001.363">
</t>
<t tx="ekr.20071102163001.364">def openJythonShell( self ):

    js = ijcl.getJythonShell()
    jd = js.getDelegate()
    config = g.app.config
    c = self.c

    import leoSwingFrame
    getColorInstance = leoSwingFrame.getColorInstance 

    colorconfig = js.getColorConfiguration()
    color = config.getColor( c, "jyshell_background" )
    colorconfig.setBackgroundColor( getColorInstance( color, awt.Color.WHITE ) )

    color = config.getColor( c, "jyshell_foreground" )
    colorconfig.setForegroundColor( getColorInstance( color, awt.Color.GRAY ) )

    color = config.getColor( c, "jyshell_keyword" )
    colorconfig.setKeywordColor( getColorInstance( color, awt.Color.GREEN ) )

    color = config.getColor( c, "jyshell_local" )
    colorconfig.setLocalColor( getColorInstance( color, awt.Color.ORANGE ) )

    color = config.getColor( c, "jyshell_ps1color" )
    colorconfig.setPromptOneColor( getColorInstance( color, awt.Color.BLUE ) )

    color = config.getColor( c, "jyshell_ps2color" )
    colorconfig.setPromptTwoColor( getColorInstance( color, awt.Color.GREEN ) )

    color = config.getColor( c, "jyshell_syntax" )
    colorconfig.setSyntaxColor( getColorInstance( color, awt.Color.RED ) )

    color = config.getColor( c, "jyshell_output" )
    colorconfig.setOutColor( getColorInstance( color, awt.Color.GRAY ) )

    color = config.getColor( c, "jyshell_error" )
    colorconfig.setErrColor( getColorInstance( color, awt.Color.RED ) )

    family = config.get( c, "jyshell_text_font_family", "family" )
    size = config.get( c, "jyshell_text_font_size", "size" )
    weight = config.get( c, "jyshell_text_font_weight", "weight" )
    slant = None
    font = config.getFontFromParams( c, "jyshell_text_font_family", "jyshell_text_font_size", None, "jyshell_text_font_weight")

    use_bgimage = g.app.config.getBool( c, "jyshell_background_image" )
    if use_bgimage:

        image_location = g.app.config.getString( c, "jyshell_image_location@as-filedialog" )
        test_if_exists = java.io.File( image_location )
        if test_if_exists.exists():
            ii = swing.ImageIcon( image_location )
            alpha = g.app.config.getFloat( c, "jyshell_background_alpha" )
            js.setBackgroundImage( ii.getImage(), float( alpha ) )

    if font:
        js.setFont( font )

    js.setVisible( True )
    widget = js.getWidget()
    log = self.c.frame.log    
    self.addMenuToJythonShell( js )
    log.addTab( "JythonShell", widget )
    log.selectTab( widget )


</t>
<t tx="ekr.20071102163001.365">def addMenuToJythonShell( self, js ):

    c = self.c
    jd = js.getDelegate()
    jmenu = swing.JMenu( "Leo" )
    jd.addToMenu( jmenu )

    e = swing.JMenuItem( "Execute Node As Script" )  
    e.actionPerformed = lambda event, jd = jd: self.fireNodeAsScript( event, jd )
    jmenu.add( e )

    p = swing.JMenuItem( "Run Node in Pdb" )
    p.actionPerformed = self.getRunNodeInPdb( c, jd )
    jmenu.add( p )

    captext = "Capture Shell Input In Node"
    totext = "Turn Off Shell Input Capture"
    sc = swing.JMenuItem( captext )
    import org.leo.JTextComponentOutputStream as jtcos
    class logcontrol:
        def __init__( self, menu ):
            self.menu = menu
            self.loging = False
            self.ostream = jtcos( c.frame.body.editor.editor )

        def __call__( self, event ):  
            menu = self.menu
            loging = self.loging
            if not loging:
                js.addLogger( self.ostream )
                menu.setText( totext )
                self.loging = True
            else:
                js.removeLogger( self.ostream )
                menu.setText( captext )
                self.loging = False

    sc.actionPerformed = logcontrol( sc )           
    jmenu.add( sc )

    d = swing.JMenuItem( "Detach Shell" )
    class detacher( java.util.concurrent.Callable ):

        def __init__( self, menu ):
            self.menu = menu
            self.embeded = True
            js.setCloser( self )

        def call( self ):

            if self.embeded:
                log = c.frame.log
                widget = js.getWidget()
                log.removeTab( widget )
            else:
                widget = js.getWidget()
                parent = widget.getTopLevelAncestor()
                parent.dispose();

        def __call__( self, event ):
            d = self.menu
            text = d.getText()
            if( text == "Detach Shell" ):
                d.setText( "Retach Shell" )
                jf = swing.JFrame( "JythonShell" )
                widget = js.getWidget()
                log = c.frame.log 
                log.removeTab( widget )
                jf.add( widget )
                jf.setSize( 500, 500 )
                jf.visible = 1
                self.embeded = False
            else:
                d.setText( "Detach Shell" )
                widget = js.getWidget()
                parent = widget.getTopLevelAncestor()
                parent.dispose();
                log = c.frame.log
                log.addTab( "JythonShell", widget  )
                log.selectTab( widget ) 
                self.embeded = True

    d.actionPerformed = detacher( d )
    jmenu.add( d )    


</t>
<t tx="ekr.20071102163001.366">def getInsertNodeIntoShell( self, c, jd ):

    jm = swing.JMenuItem( "Write Node Into Shell as Reference" )
    def writeNode( event ):

        cp = c.currentPosition()
        at = c.atFileCommands 
        c.fileCommands.assignFileIndices()
        at.write(cp.copy(),nosentinels=True,toString=True,scriptWrite=True)
        data = at.stringOutput

        jtf = self._GetReferenceName( jd, data )
        jtf.rmv_spot = jd.insertWidget( jtf )
        jtf.requestFocusInWindow()



    jm.actionPerformed = writeNode
    return jm
</t>
<t tx="ekr.20071102163001.367">def getInsertReferenceIntoLeo( self, jd ):

    jmi = swing.JMenuItem( "Insert Reference As Node" )

    def action( event ):

        jtf = self._GetReferenceAsObject( jd, self.c )
        jtf.rmv_spot = jd.insertWidget( jtf )
        jtf.requestFocusInWindow()

    jmi.actionPerformed = action
    return jmi</t>
<t tx="ekr.20071102163001.368">def getRunNodeInPdb( self, c, jd ):

    def runInPdb( event ):

        cp = c.currentPosition()
        name = cp.headString()
        name = name.split()[ 0 ]
        at = c.atFileCommands 
        c.fileCommands.assignFileIndices()
        at.write(cp.copy(),nosentinels=True,toString=True,scriptWrite=True)
        data = at.stringOutput

        f = java.io.File.createTempFile( "leopdbrun", None )
        pw = java.io.PrintWriter( f )
        pw.println( "import pdb" )
        pw.println( "pdb.set_trace()" )
        for z in data.split( "\n" ):
            pw.println( z )            
        pw.close()
        f.deleteOnExit()       
        l = java.util.Vector()
        l.add( "execfile( '%s', globals(), locals())" % f.getAbsolutePath() )
        jd.processAsScript( l )


    return runInPdb      
</t>
<t tx="ekr.20071102163001.369">def fireNodeAsScript( self, event, jd ):

    c = self.c        
    cp = c.currentPosition()    
    at = c.atFileCommands 
    c.fileCommands.assignFileIndices()
    at.write(cp.copy(),nosentinels=True,toString=True,scriptWrite=True)
    data = at.stringOutput.split( '\n' ) 


    l = java.util.Vector()
    for z in data:
        l.add( java.lang.String( z ) )

    jd.processAsScript( l )</t>
<t tx="ekr.20071102163001.370">class _GetReferenceName( swing.JTextField, aevent.KeyListener ):


    def __init__( self, jd, data ):
        swing.JTextField.__init__( self )
        self.jd = jd
        self.data = data
        border = self.getBorder()
        tborder = sborder.TitledBorder( border )
        tborder.setTitle( "Choose Reference Name:" )
        self.setBorder( tborder )
        self.addKeyListener( self )
        self.rmv_spot = None

    def keyPressed( self, event ):

        kc = event.getKeyChar();
        if kc == '\n':
            self.execute()
        elif java.lang.Character.isWhitespace( kc ):
            event.consume

    def execute( self ):

        self.jd.setReference( self.getText(), self.data )
        if self.rmv_spot:
            self.jd.remove( self.rmv_spot)
        self.jd.requestFocusInWindow()

    def keyTyped( self, event ):

        kc = event.getKeyChar()
        if kc == '\n': return
        elif java.lang.Character.isWhitespace( kc ):
            event.consume()

    def keyReleased( self, event ):

        kc = event.getKeyChar()
        if kc == '\n': return
        elif java.lang.Character.isWhitespace( kc ):
            event.consume()


class _GetReferenceAsObject( _GetReferenceName ):

    def __init__( self, jd, c ):
        leoSwingMenu._GetReferenceName.__init__( self, jd, None )
        self.c = c
        border = self.getBorder()
        border.setTitle( "Which Reference To Insert:" )


    def execute( self ):

        ref = self.jd.getReference( self.getText() )
        if ref:
            self.c.beginUpdate()
            pos = self.c.currentPosition()
            npos = pos.insertAfter()
            npos.setHeadString( "Reference: %s" % self.getText() )
            npos.setTnodeText( str( ref ) )
            self.c.endUpdate()
        if self.rmv_spot:
            self.jd.remove( self.rmv_spot )
</t>
<t tx="ekr.20071102163001.371">def addUserGuide( self ):

    help = self.getMenu( 'Help' )
    c = self.c
    help.addSeparator()
    jmi = swing.JCheckBoxMenuItem( "View User Guide" )
    widgets = []
    def showUserGuide( event ):
        if jmi.getState() and not widgets:
            import leoSwingLeoTutorial
            lswlt = leoSwingLeoTutorial.leoSwingLeoTutorial()
            widget = lswlt.getWidget()
            widgets.append( widget )
            c.frame.body.addTab( "User Guide", widget )
        elif jmi.getState() and widgets:
            widget = widgets[ 0 ]
            c.frame.body.addTab( "User Guide", widget )
        else:
            widget = widgets[ 0 ]
            c.frame.body.removeTab( widget )


    jmi.actionPerformed = showUserGuide
    help.add( jmi )
</t>
<t tx="ekr.20071102163001.372">def createRecentFilesMenuItems (self):

    c = self.c ; frame = c.frame
    recentFilesMenu = self.getMenu("Recent Files...")

    # Delete all previous entries.
    if len( recentFilesMenu.getMenuComponents() ) != 0:
        deferable = lambda :self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
        if not swing.SwingUtilities.isEventDispatchThread():
            dc = DefCallable( deferable )
            ft = dc.wrappedAsFutureTask()
            swing.SwingUtilities.invokeAndWait( ft )
        else:
            deferable()
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table,init=True)

    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def callback (event=None,c=c,name=name): # 12/9/03
            c.openRecentFile(name)
        label = "%d %s" % (i-2,g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=callback,underline=0)
        i += 1</t>
<t tx="ekr.20071102163001.373">def oops (self):

    print "leoMenu oops:", g.callerName(2), "should be overridden in subclass"</t>
<t tx="ekr.20071102163001.374"></t>
<t tx="ekr.20071102163001.375">def add_cascade (self,parent,label,menu,underline):

    menu.setText( label )

def add_command (self,menu,**keys):

    if keys[ 'label' ] == "Open Python Window":
        keys[ 'command' ] = self.openJythonShell

    self.names_and_commands[ keys[ 'label' ] ] = keys[ 'command' ]

    action = self.MenuRunnable( keys[ 'label' ], keys[ 'command' ], self.c, self.executor )
    jmenu = swing.JMenuItem( action )
    if keys.has_key( 'accelerator' ) and keys[ 'accelerator' ]:
        accel = keys[ 'accelerator' ]
        acc_list = accel.split( '+' )
        changeTo = { 'Alt': 'alt', 'Shift':'shift', #translation table
                     'Ctrl':'ctrl', 'UpArrow':'UP', 'DnArrow':'DOWN',
                     '-':'MINUS', '+':'PLUS', '=':'EQUALS',
                     '[':'typed [', ']':'typed ]', '{':'typed {',
                     '}':'typed }', 'Esc':'ESCAPE', '.':'typed .',
                      "`":"typed `", "BkSp":"BACK_SPACE"} #SEE java.awt.event.KeyEvent for further translations
        chg_list = []
        for z in acc_list:
            if z in changeTo:
                chg_list.append( changeTo[ z ] )
            else:
                chg_list.append( z )
        accelerator = " ".join( chg_list )
        ks = swing.KeyStroke.getKeyStroke( accelerator )
        if ks:
            self.keystrokes_and_actions[ ks ] = action
            jmenu.setAccelerator( ks )
        else:
            pass
    menu.add( jmenu )
    label = keys[ 'label' ]
    return jmenu

def add_separator(self,menu):
    menu.addSeparator()

def bind (self,bind_shortcut,callback):
    #self.oops() 
    pass

def delete (self,menu,realItemName):
    self.oops()

def delete_range (self,menu,n1,n2):


    items = menu.getMenuComponents()
    n3 = n1
    components = []
    while 1:
        if n3 == n2:
            break
        item = menu.getMenuComponent( n3 )
        components.append( item )
        n3 += 1

    for z in components:
        menu.remove( z )


def destroy (self,menu):
    self.oops()

def insert_cascade (self,parent,index,label,menu,underline):
    self.oops()

def new_menu(self,parent,tearoff=0):
    jm = swing.JMenu( "1" )
    #jm = self.LeoMenu( "1" )
    parent.add( jm )
    #jm.setFont( self.font)
    return jm</t>
<t tx="ekr.20071102163001.376">def createMenuBar (self,frame):

    top = frame.top
    self.defineMenuTables()
    topMenu = swing.JMenuBar()
    top.setJMenuBar( topMenu )
    topMenu.setFont( self.font )
    # Do gui-independent stuff.
    self.setMenu("top",topMenu)
    self.createMenusFromTables()
    self.createLeoSwingPrint()
    self.createPluginMenu()
    self.addUserGuide()

def createOpenWithMenuFromTable (self,table):
    self.oops()

def defineMenuCallback(self,command,name):
    return command

def defineOpenWithMenuCallback(self,command):
    self.oops()

def disableMenu (self,menu,name):
    for z in menu.getMenuComponents():
        if hasattr( z, "getText" ) and z.getText() == name:
            z.setEnabled( False )

def enableMenu (self,menu,name,val):
    for z in menu.getMenuComponents():
        if hasattr( z, "getText" ) and z.getText() == name:
            z.setEnabled( bool( val ) )

def setMenuLabel (self,menu,name,label,underline=-1, enabled = 1):

    item = ( menu, name, label, enabled )
    self.queue.offer( item )
    self.executor.submit( self.menu_changer )
</t>
<t tx="ekr.20071102163001.377">class MenuRunnable( swing.AbstractAction, java.lang.Runnable): 

    def __init__( self, name, command, c , executor):
        swing.AbstractAction.__init__( self, name )
        self.command = command
        self.c = c
        self.name = name
        self.executor = executor

    def run( self ):
        self.c.doCommand( self.command, self.name ) #command()

    def actionPerformed( self, aE ):

        #print self.command
        #if self.name == 'Save':
        self.executor.submit( self )

        #else:        
        #    se</t>
<t tx="ekr.20071102163001.378">class MenuExecuteOnSelect( sevent.MenuListener ):

    def __init__( self, method ):
        self.method = method

    def menuSelected( self, me ):
        self.method()

    def menuCanceled( self, me ):
        pass

    def menuDeselected( self, me ):
        pass</t>
<t tx="ekr.20071102163001.379">class LeoMenu( swing.JMenu ):

    def __init__( self, *args ):
        swing.JMenu.__init__( self, *args )

    def add( self, *items ):
        if hasattr( items[ 0 ], "setFont" ):
            items[ 0 ].setFont( self.getFont() )
        return self.super__add( *items )

</t>
<t tx="ekr.20071102163001.380"># This would be useful if we removed all the tree redirection routines.
# However, those routines are pretty ingrained into Leo...

class leoSwingTree( sevent.TreeSelectionListener, java.lang.Runnable, aevent.FocusListener ):   

    """The base class for the outline pane in Leo windows."""

    positions = java.util.WeakHashMap() #For storing where a node has last been edited
    icons = jarray.zeros( 16, swing.ImageIcon )
    for z in xrange( 16 ):
        num = '%s' % z
        if z &lt; 10: num = '%s%s' %( 0, num )
        ipath = g.os_path_join( g.app.loadDir,"..","Icons","box%s.GIF" % num )
        icons[ z ] = swing.ImageIcon( ipath )

    commenticon = swing.ImageIcon( g.os_path_join( g.app.loadDir, "..", "Icons", "Cloud24.gif" ) )

# for( int i = 0; i &lt; _icons.length; i++ ){
            # String num = String.valueOf( i );
            # if( i &lt; 10 ) num = "0" + num;
# _icons[ i ] = new ImageIcon( String.format( "../Icons/box%s.GIF" , num ) );
    # }

    @others</t>
<t tx="ekr.20071102163001.381">def __init__ (self,frame, model = None, chapter = None ):

    #leoFrame.leoTree.__init__( self, frame )
    self.frame = frame
    self.c = c = frame.c

    # "public" ivars: correspond to setters &amp; getters.
    self._editPosition = None

    # Controlling redraws
    self.updateCount = 0 # self.redraw does nothing unless this is zero.
    self.chapter = chapter
    self.loaded = False
    self._op = None
    self.skip_reload = 0
    self.view_controls = self.ViewControls()
    self.center = center = self.view_controls.addControl( "Outline", lambda : 1, None, checkmark = 1 )



    if model:
        self.posTM = model
    else:
        self.posTM = self.posTreeModel( self.c )
    self.jtree = jtree = self.JTree2( self.posTM )
    jtree.setFocusable( True )
    jtree.setRowHeight( -1 )#ensures that the renderer component's size is used
    self.setBackgroundColor()
    #self.setFontFromConfig()
    g.app.config.manager.addNotificationDef( "outline_pane_background_color", self.setBackgroundColor )
    config = g.app.config
    color = g.app.config.getColor( self.c, "headline_text_unselected_foreground_color" )
    tfg = getColorInstance( color, awt.Color.BLACK )
    color = g.app.config.getColor( self.c, "headline_text_unselected_background_color" )
    tbg = getColorInstance( color, awt.Color.WHITE )
    do_brackets = config.getBool( self.c, "headline_do_bracket_color" )
    color = config.getColor( self.c, "headline_bracket_color" )
    bracket_color = getColorInstance( color, awt.Color.BLUE )
    do_directives = config.getBool( self.c, "headline_do_directive_color" )
    color = config.getColor( self.c, "headline_directive_color" )
    directive_color = getColorInstance( color, awt.Color.GREEN )

    import leoNodes
    tnode = leoNodes.tnode()
    v = leoNodes.vnode( self.c, tnode )
    def getValue( names, self = v ):
        return names
    olFindAtFileName = v.findAtFileName
    v.findAtFileName = getValue
    names = v.anyAtFileNodeName()
    v.findAtFileName = olFindAtFileName
    names = list( names )
    hmap = java.util.HashMap()
    for z in names: hmap.put( z, None )

    self.renderer = leoIconTreeRenderer( self.posTM._root, self.icons,
                                         tfg, tbg,
                                         do_brackets, bracket_color,
                                         do_directives, directive_color,
                                         hmap
                                         )

    self.renderer.setCommentIcon( self.commenticon )
    xxx = lambda : self.jtree.setCellRenderer( self.renderer )
    dc = DefCallable( xxx )
    ft = dc.wrappedAsFutureTask()
    swing.SwingUtilities.invokeLater( ft )
    self.setFontFromConfig()
    self.renderer.setFont( self.jtree.getFont() )

    color = g.app.config.getColor( self.c, "headline_text_editing_foreground_color" )
    tefg = getColorInstance( color, awt.Color.BLACK )
    color = g.app.config.getColor( self.c, "headline_text_editing_background_color" )
    tebg = getColorInstance( color, awt.Color.WHITE )
    self.headlineEditor = leoHeadlineTreeCellEditor( self.c, tefg, tebg, leoSwingBody.Editor.icon )
    self.headlineEditor.setFont( self.jtree.getFont() )
    self.tcEdi = tcllEditor = self.tcellEditor( jtree, self.renderer, 
                                                self.headlineEditor,
                                                self.c )
    tcllEditor.addCellEditorListener( self.cellEditorListener( self.c ) )
    jtree.setCellEditor( tcllEditor )
    jtree.setRootVisible( False )
    jtree.setShowsRootHandles( True )
    jtree.getSelectionModel().setSelectionMode( stree.DefaultTreeSelectionModel.SINGLE_TREE_SELECTION )
    jtree.setScrollsOnExpand( True )

    self.jtree = jtree
    jtree.setTransferHandler( self.TreeTransferHandler( self.c, jtree ) )
    jtree.setDragEnabled( True ) 
    jtree.addTreeSelectionListener( self )
    jtree.editable = True
    self.jspane = swing.JScrollPane()
    #self.jspane.setViewport( JViewPort2() )

    #self.jspane = self.ZoomJSP()#swing.JScrollPane()
    #self.jspane.setViewport( self.ZoomView() )
    self.jspane.setViewportView( self.jtree )
    #self.jspane.getViewport().setOpaque( False )
    #self.jspane.setBackground( self.jtree.getBackground() )
    center.add( self.jspane )
    jtree.addFocusListener( leoJSPFocusListener( self.jspane, self.c ) )
    self.main_widget = parentpanel = swing.JRootPane()# swing.JPanel( awt.BorderLayout() )
    base = self.view_controls.getBase()
    parentpanel.getContentPane().add( base )
    parentpanel.getGlassPane().setLayout( None )


@
    zoom = swing.JMenu( "Zoom" )
    def setScale( scale, jtree = jtree ): #zoomer = zoomer, jtree = jtree ):
        double = java.lang.Double( scale )
        sval = double.doubleValue()/100
        #zoomer.setScale( sval )
        jtree.setScale( sval )
    buttongroup = swing.ButtonGroup()
    for z in ( 25, 50, 75, 100, 150, 200, 300, 400 ):
        jmi = swing.JCheckBoxMenuItem( str( z ) + "%" )
        zoom.add( jmi )
        buttongroup.add( jmi )
        if z == 100: jmi.setState( True )
        jmi.actionPerformed = lambda event, scale = z: setScale( scale )
    jmb.add( zoom )
@c

    self.current = self.jspane
    cpane = frame.jsp1

    self._dragging = False
    self._editPosition = None


    self.reloading = False
    self.paths = False
    self.settingPosition = False
    self.lastHoistStackLength = 0
    self.configureMedia()
    g.doHook("swingtreecreated", tree = self, view_controls = self.view_controls, c = self.c) 




</t>
<t tx="ekr.20071102163001.382">class posTreeModel( stree.TreeModel, java.lang.Runnable ):

    def __init__( self, c ):

        self.c = c
        self.tmlisteners = java.util.ArrayList();
        self._root = self._rootN( c )
        self._rTreePath = stree.TreePath( self._root )       


    def getRoot( self ):
        return self._root

    def reload( self, full_reload = False ):


        if full_reload:
            t_r = self.c.frame.tree.tree_reloader
            for z in self.c.rootPosition().allNodes_iter( copy = True ):
                if z.isExpanded():
                    t_r.expand( z )

        import jarray
        a = jarray.zeros( 1, stree.TreeNode )
        a[ 0 ] = self._root
        e = sevent.TreeModelEvent( self._root, a )
        for z in self.tmlisteners:
            z.treeStructureChanged( e )



    def addTreeModelListener( self, listener ):
        self.tmlisteners.add( listener )

    def removeTreeModelListener( self, listener ):
        self.tmlisteners.remove( listener )

    def getChild( self, parent, ind ):
        if parent is self._root:
            return parent.getChildAt( ind ).copy()
        return parent.getNthChild( ind ).copy()

    def getChildCount( self, parent ):

        if parent is self._root:
            return parent.getChildCount()
        if parent:
            return parent.numberOfChildren()
        else:
            return 0

    def getIndexOfChild( self, parent, child ):
        if parent is self._root:
            return self._root.getIndex( child )
        else:
            return child.childIndex()



    def valueForPathChanged( self, path, value ):

        pos = path.getLastPathComponent()
        pos.setHeadString( value )

    def isLeaf( self, node ):
        if node is self._root: return False
        if node:
            if node.numberOfChildren(): return False
            else: return True
        else:
            return True

    def getPathToRoot( self, node ):

        path = []
        #if not node:
        #    node = self.c.rootPosition()

        while node and node.level() != 0:
            path.append( node.copy() )
            node = node.getParent()
        else:
            path.append( node.copy() )
            path.append( self._root )

        path.reverse()
        tp = stree.TreePath( path )
        return tp

    class _rootN( stree.TreeNode ):

        def __init__( self, c ):
            self.c = c

        def getChildAt(self, childIndex):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0: #Hoist Code
                rp = self.c.hoistStack[ -1 ].p.copy()
                def getParent( root = self ): #This slight modification to a copy allows the Tree to keep its expanded state
                    return root
                rp.getParent = getParent
                return rp #End of Hoist Code
            if not rp: return None
            i = 0
            for z in rp.siblings_iter():
                if i == childIndex:
                    return z
                i = i + 1
            return None       

        def getChildCount( self ):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0:
                return 1
            i = 0
            for z in rp.siblings_iter():
                i = i + 1
            return i

        def getParent( self ):
            return None

        def getIndex( self, node):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0:
                #rp = self.c.hoistStack[ -1 ][ 0 ].copy()
                return 0
            i = 0
            for z in rp.siblings_iter():
                if z == node: return i
                i = i + 1
            return -1

        def getAllowsChildren( self ):
            return True

        def isLeaf( self ):
            return False

        def equal( self, x ):
            if self is x: return True
            else: return False

        def equals( self, x ):
            if self is x: return True
            else:
                return False

        def copy( self ):
            return self

        def bodyString( self ):
            return ""

        def headString( self ):
            return ""

        def children( self ):

            class _enum( util.Enumeration ):

                def __init__( self, iter ):
                    self.iter = iter
                    try:
                        self.next = iter.next()
                    except:
                        self.next = None

                def hasMoreElements( self ):
                    if self.next: return True
                    else: return False

                def nextElement( self ):

                    try:
                        rt = self.next
                        self.next = iter.next()
                    finally:
                        return rt
            return _enum( self.c.rootPosition.siblings_iter( copy = True ) )        









</t>
<t tx="ekr.20071102163001.383">def doneLoading( self ):

    self.loaded = True
    c = self.c
    #awt.EventQueue.invokeLater( self.__reloader( self.posTM, self.tree_reloader ) )
    #swing.SwingUtilities.invokeLater( self.tree_reloader )
    #g.es( "Expanding tree( last startup operation )..." )
    c.frame.body.editor.sync()
    #c.frame.body.editor.cdertminer.last_p = None
    c.frame.body.jdp.repaint()


class __reloader( java.lang.Runnable ):

    def __init__( self, model , tree_reloader ):
        self.model = model
        self.tree_reloader = tree_reloader

    def run( self ):
        self.model.reload( full_reload = False );
        self.tree_reloader.run()
        #awt.EventQueue.invokeLater( self.tree_reloader ) </t>
<t tx="ekr.20071102163001.384">def valueChanged( self, event ):

    path = event.getPath()
    o = path.getLastPathComponent()
    #if not self.c.currentPosition().equal( o ):
    if not self.chapter.getCurrentPosition().equal( o ):
        self.settingPosition = True
        #cp = self.c.currentPosition()
        cp = self.chapter.getCurrentPosition()
        #if hasattr( cp ,'v' ):
        #    leoSwingTree.positions.put( cp.v, self.c.frame.body.editor.editor.getCaretPosition() )
        #self.c.setCurrentPosition( o )
        self.select( o )
        #self.frame.body.editor.sync()
        self.settingPosition = False
        #if hasattr( o, 'v' ) and leoSwingTree.positions.containsKey( o.v ):
        #    spot = leoSwingTree.positions.get( o.v )
        #    editor = self.c.frame.body.editor
        #    doc = editor.editor.getStyledDocument()
        #    if doc.getLength() &lt; spot: return
        #    
        #    editor.editor.setCaretPosition( spot )
        #    rec = editor.editor.modelToView( spot )
        #    if rec:
        #        editor.view.getViewport().scrollRectToVisible( rec )
        #else:
        #    self.c.frame.body.editor.editor.setCaretPosition( 0 )</t>
<t tx="ekr.20071102163001.385"></t>
<t tx="ekr.20071102163001.386">def drawIcon(self,v,x=None,y=None):
    self.oops()


def _redraw( self, event = None ):
    pass

def redraw(self,event=None): # May be bound to an event.

    if len( self.c.hoistStack ) or self.lastHoistStackLength: #This ensures the correct Hoisted part of the tree is displayed
        if self.lastHoistStackLength != len( self.c.hoistStack ):
            self.lastHoistStackLength = len( self.c.hoistStack )
            #self.posTM.reload()
            #swing.SwingUtilities.invokeLater( self.tree_reloader )

    #self.jtree.repaint()
    self.jtree.repaint( 10 )


def _redraw_now( self, scroll = False ):
    pass

def redraw_now(self, scroll = False):
    self.jtree.repaint()

def redrawAfterException (self):
    self.redraw()

def alterationInTreeNodes( self ):
    #self.jtree.getParent().revalidate()
    #self.posTM.reload( full_reload = True )
    self.beginUpdate()
    self.endUpdate()

def nodeDidChange( self, pos ):
    self.jtree.treeDidChange()





</t>
<t tx="ekr.20071102163001.387">def editLabel(self,v):

  if self.loaded: #If the system isnt loaded this can result in a different root than what is in the Leo File!.
    self._EditLabelEnabler.setNodeToEdit( v )
  if self.updateCount == 0:
      self._EditLabelEnabler.addToEventQueue()



def endEditLabel(self):

    if self.jtree.isEditing():
        dc = DefCallable( self.__stopediting )
        ft = dc.wrappedAsFutureTask()
        java.awt.EventQueue.invokeLater( ft )
        #self.jtree.stopEditing()

def __stopediting( self ): 
    self.jtree.stopEditing()
    g.doHook( "headline-editing-finished", p = self.chapter.getCurrentPosition(), chapter = self.chapter )

def setNormalLabelState(self,v):
    pass</t>
<t tx="ekr.20071102163001.388"># These should all be internal to the tkinter.frame class.

def OnActivateHeadline(self,v):
    self.oops()

def onHeadChanged(self,v):
    self.oops()

def OnHeadlineKey(self,v,event):
    self.oops()

def idle_head_key(self,v,ch=None):
    self.oops()</t>
<t tx="ekr.20071102163001.389">def scrollTo(self,v):
    self.oops()

def scrollRight( self, increment = 0 ):

    sbar = self.jspane.getHorizontalScrollBar()
    max = sbar.getMaximum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value += increment
    if value &gt; max:
        value = max
    sbar.setValue( value )

def scrollLeft( self, increment = 0 ):
    sbar = self.jspane.getHorizontalScrollBar()
    min = sbar.getMinimum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value -= increment
    if value &lt; min:
        value = min
    sbar.setValue( value )

def scrollUp( self, increment = 0 ):

    sbar = self.jspane.getVerticalScrollBar()
    min = sbar.getMinimum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value -= increment
    if value &lt; min:
        value = min
    sbar.setValue( value )

def scrollDown( self, increment = 0 ):

    sbar = self.jspane.getVerticalScrollBar()
    max = sbar.getMaximum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value += increment
    if value &gt; max:
        value = max
    sbar.setValue( value )    

def idle_scrollTo(self,v):

    self.oops()



</t>
<t tx="ekr.20071102163001.390">def select(self,p,updateBeadList=True):

    c = self.c
    jtree = self.jtree
    editor = c.frame.body.editor.editor

    cpy = p.copy()
    tp = self.posTM.getPathToRoot( cpy )
    if tp.getPath():
        jtree.setSelectionPath( tp )
        jtree.scrollPathToVisible( tp )

    #old_p = c.currentPosition()
    old_p = self.chapter.getCurrentPosition()
    if hasattr( old_p ,'v' ):
        leoSwingTree.positions.put( old_p.v, editor.getCaretPosition() )

    #c.setCurrentPosition( cpy )
    self.chapter.setCurrentPosition( cpy )
    if c.frame.body.editor.lastPosition == cpy:
        g.doHook("select1",c=self.c,new_p=cpy,old_p=old_p,new_v=cpy,old_v=old_p)
        return

    c.frame.body.editor.sync( pos = cpy)

    if hasattr( cpy, 'v' ) and leoSwingTree.positions.containsKey( cpy.v ):

        spot = leoSwingTree.positions.get( cpy.v )
        doc = editor.getStyledDocument()
        if doc.getLength() &lt; spot: return

        editor.setCaretPosition( spot )
        try:
            rec = editor.modelToView( spot )
            if rec:
                c.frame.body.editor.view.getViewport().scrollRectToVisible( rec )
        except: #the darn thing blows up here if not enough of the editor is showing...
            pass
    else:
        editor.setCaretPosition( 0 )

    g.doHook("select1",c=self.c,new_p=cpy,old_p=old_p,new_v=cpy,old_v=old_p)
</t>
<t tx="ekr.20071102163001.391">def expandAllAncestors(self,p):


    tp = self.posTM.getPathToRoot( p.copy() )
    self.jtree.expandPath( tp )
</t>
<t tx="ekr.20071102163001.392">def beginUpdate (self):

    self.updateCount += 1
    self.endEditLabel()
    if not self.settingPosition:
        self.paths = True</t>
<t tx="ekr.20071102163001.393">def endUpdate (self,flag=True ):

    #print java.lang.Thread.currentThread() , self.updateCount
    #try:
    assert(self.updateCount &gt; 0)
    self.updateCount -= 1

    # g.trace(self.updateCount)
    #if flag and self.updateCount == 0:
    #    self.redraw()
    if self.paths:
        self.reloading = True
        #posTM = self.posTM
        #c = self.c
        if not self.skip_reload and self.updateCount == 0:
            #cp = c.currentPosition().copy()
            #cp = self.chapter.getCurrentPosition().copy()
            self.posTM.dRun()
            #tp = self.posTM.getPathToRoot( cp )
            #self.tree_reloader.setCurrentPosition( tp )
            #swing.SwingUtilities.invokeLater( self.tree_reloader )               
            self._op = None
            self.paths = False
            self.reloading = False
            if hasattr( self, "_EditLabelEnabler" ):
                self._EditLabelEnabler.addToEventQueue()

</t>
<t tx="ekr.20071102163001.394">def dragging(self):
    return self._dragging

def getEditTextDict(self,v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v,[])

def editPosition(self):
    return self._editPosition

def setDragging(self,flag):
    self._dragging = flag

def setEditPosition(self,p):
    self._editPosition = p</t>
<t tx="ekr.20071102163001.395">def oops(self):

    print "leoTree oops:", g.callerName(2), "should be overridden in subclass"</t>
<t tx="ekr.20071102163001.396">def OnIconDoubleClick (self,v,event=None):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = v.headString().strip()
    if g.match_word(s,0,"@url"):
        if not g.doHook("@url1",c=c,v=v):
            url = s[4:].strip()
            &lt;&lt; stop the url after any whitespace &gt;&gt;
            &lt;&lt; check the url; return if bad &gt;&gt;
            &lt;&lt; pass the url to the web browser &gt;&gt;
        g.doHook("@url2",c=c,v=v)</t>
<t tx="ekr.20071102163001.397"># For safety, the URL string should end at the first whitespace.

url = url.replace('\t',' ')
i = url.find(' ')
if i &gt; -1:
    if 0: # No need for a warning.  Assume everything else is a comment.
        g.es("ignoring characters after space in url:"+url[i:])
        g.es("use %20 instead of spaces")
    url = url[:i]
</t>
<t tx="ekr.20071102163001.398">if not url or len(url) == 0:
    g.es("no url following @url")
    return

@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"
import re
# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
</t>
<t tx="ekr.20071102163001.399">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser

        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()

</t>
<t tx="ekr.20071102163001.400">def enableDrawingAfterException (self):
    pass</t>
<t tx="ekr.20071102163001.401">class tcellEditor( stree.DefaultTreeCellEditor ): #so the tree will start editing on 1 click!

    def __init__( self , jtree, renderer, editor, c ):
        stree.DefaultTreeCellEditor.__init__( self, jtree, renderer , editor )
        self.editor = editor
        self.editor.setFocusTraversalPolicy( c.frame.ftp )
        self.timer = None
        self.c = c
        self.tree = jtree

    def getTreeCellEditorComponent(self, tree, value, isSelected, expanded, leaf, row):
        return self.editor.getTreeCellEditorComponent( tree, value, isSelected, expanded, leaf, row )     

    def requestFocusInWindow( self ):
        self.editor.requestFocusInWindow()

    def shouldStartEditingTimer( self, event ):

        if event.getClickCount() &gt;= 1 and self.inHitRegion( event.getX(), event.getY() ):
            #self.tree.stopEditing() 
            return True
        else:
            return False

    def canEditImmediately( self, event ):

        if event == None or event.getClickCount() == 2:
            return True
        else:
            return False

    def startEditingTimer( self ):

        #self.htext = None
        if self.timer == None:
            self.timer = swing.Timer( 10, self )
            self.timer.setRepeats( False )
        self.timer.start()

    #def cancelCellEditing( self ):
    #
    #    self.super__cancelCellEditing()
    #cp = self.c.currentPosition()
    #htext = self.tree.getCellEditor().getCellEditorValue()
    #cp.setHeadString(  )
    #self.htext = None

    #def prepareForEditing( self ):
    #    
    #    self.super__prepareForEditing()
    #cp = self.c.currentPosition()
    #self.htext = cp.headString()

</t>
<t tx="ekr.20071102163001.402">class cellEditorListener( sevent.CellEditorListener, java.lang.Runnable ):

    def __init__( self, c ):
        self.c = c

    def editingCanceled( self, event ): 
        #Called when the headline edit has been aborted, do nothing... results in headline reverting.
        pass
        #self.sync( event )

    def editingStopped( self, event ):
        self.sync( event )

    def run( self ):

        self.c.frame.body.editor.editor.requestFocusInWindow()


    def sync( self , event ):

        source = event.getSource()
        value = source.getCellEditorValue()
        cp = self.c.currentPosition()
        cp.setHeadString( value )
        awt.EventQueue.invokeLater( self )
</t>
<t tx="ekr.20071102163001.403">def edit_text( self, p ):

    return self.c.frame.body.editor.editor

</t>
<t tx="ekr.20071102163001.404">def createAuxilaryWidgets( self ):

    parentpanel = self.main_widget
    jtree = self.jtree
    c = self.c
    jmb = swing.JMenuBar()
    self.view_controls.setMenuBar( jmb )
    parentpanel.add( jmb, java.awt.BorderLayout.NORTH )    
    pue = self.PopupEnabler( c )
    jtree.addMouseListener( pue )
    self._EditLabelEnabler = self.EditLabelEnabler( self.jtree , self.headlineEditor)
    jtree.addFocusListener( self )
</t>
<t tx="ekr.20071102163001.405">def getWidget( self ):

    return self.main_widget

</t>
<t tx="ekr.20071102163001.406">def configureMedia( self ):

    c = self.c 
    use_background = g.app.config.getBool( c, "tree_use_background_image" )    
    if use_background:
        self.setBackgroundImage()
</t>
<t tx="ekr.20071102163001.407">def setBackgroundImage( self, notification = None, handback = None ):

    c = self.c
    alpha = g.app.config.getFloat( c, "tree_background_alpha" )
    if alpha == None: alpha = 1.0
    image_path = g.app.config.getString( c, "tree_image_location@as-filedialog" )
    if image_path:
        imfile = java.io.File( image_path ) 
        if imfile.exists():
            bimage = imageio.ImageIO.read( imfile )
            self.jtree.setImage( bimage )
            self.jtree.setAlpha( alpha )
            self.jtree.setOpaque( False )
            g.app.config.manager.addNotificationDef( "tree_background_alpha", self.setBackgroundImage )
            g.app.config.manager.addNotificationDef( "tree_image_location@as-filedialog", self.setBackgroundImage )



</t>
<t tx="ekr.20071102163001.408">@others
</t>
<t tx="ekr.20071102163001.409">class JTree2( swing.JTree ):

    def __init__( self, model ):
        self.posTM = model
        swing.JTree.__init__( self, model )
        self.lastDimensions = awt.Rectangle( 0, 0,0,0 )
        self.last_image = None
        self.image = None
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, 1.0 ) 
        #self.setOpaque( False )
        self.canPaint = True


    def setImage( self, image ):
        self.image = image

    def setAlpha( self, alpha ):
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, alpha )



    def paintComponent( self, graphics ):

        if self.image:
            vrec = self.getVisibleRect()
            if not self.lastDimensions.equals( vrec ):
                self.lastDimensions = vrec
                self.last_image = self.image.getScaledInstance( vrec.width, vrec.height, awt.Image.SCALE_REPLICATE )
            composite = graphics.getComposite()
            graphics.setComposite( self.alpha )

            graphics.drawImage( self.last_image, vrec.x, vrec.y, awt.Color.WHITE, None )
            graphics.setComposite( composite ) 
@
        else:
            #clip = graphics.getClip();
            #bounds = clip.getBounds()
            paint = graphics.getPaint()
            color = self.getBackground()
            c1 = color.brighter()
            c2 = color.darker()
            vrect = self.getVisibleRect()
            gp = awt.GradientPaint( vrect.x, vrect.y, c1, vrect.x + vrect.width, vrect.y + vrect.height, c2, True )
            graphics.setPaint( gp )
            graphics.fillRect( vrect.x, vrect.y, vrect.width, vrect.height )
            graphics.setPaint( paint )
@c       
        self.super__paintComponent( graphics )#comes last, or no tree!!!



    def isExpanded( self, path ):

        if path.__class__ != stree.TreePath:
            path = self.getPathForRow( path )

        lc = path.getLastPathComponent()
        if lc == self.posTM._root:
            return True
        else:
            return lc.isExpanded()

    def setExpandedState( self, path, boolean ):

        if boolean:
            lc = path.getLastPathComponent()
            try:
                self.fireTreeWillExpand( path )
            except:
                return
            lc.expand()
            self.fireTreeExpanded( path )
        else:
            lc = path.getLastPathComponent()
            try:
                self.fireTreeWillCollapse( path )
            except:
                return
            lc.contract()
            self.fireTreeCollapsed( path )


    def getExpandedDescendants( self, path ):


        lc = path.getLastPathComponent()
        paths = java.util.Vector()
        expanders = []

        if lc == self.posTM._root:
            p = self.posTM.chapter.getRootPosition()
            cp = self.posTM.chapter.getCurrentPosition()
        else:
            p = lc.copy()
        rp = self.posTM.chapter.getRootPosition()
        stop_p = p.copy()

        while p:                
            expanded = p.isExpanded()
            #if p == stop_p and p != rp: expanded = True
            #elif stop_p == rp and not self.posTM.drunning: expanded = True
            #elif self.posTM.drunning and p == rp:
            #    expanded = True

            if expanded:
                expanders.append( p.copy() )

            if expanded:
                if p.v.t._firstChild:
                    p.moveToFirstChild()
                elif p and p.v._next:
                    p.moveToNext()
                else:
                    while p:
                        p.moveToParent()
                        if p == stop_p and not p.isRoot(): 
                            p = None
                            break
                        if p and p.v._next:
                            p.moveToNext()
                            break
                        elif not p: break
            else:
                if p.v._next:
                    p.moveToNext()
                else:
                    while p:
                        p.moveToParent()
                        if p == stop_p and not p.isRoot(): 
                            p = None
                            break
                        if p and p.v._next:
                            p.moveToNext()
                            break
                        elif not p: break

        expanders.sort( self.sortNodes )
        while expanders:
            z = expanders.pop()
            path = self.posTM.getPathToRoot( z.copy(), masterlist = expanders )
            paths.add( path )
        return paths.elements()


    def sortNodes( self, node1, node2 ):

        l1 = node2.level()
        l2 = node2.level()
        if l1 &gt; l2: return 1
        elif l1 &lt; l2: return -1
        else: return 0


</t>
<t tx="ekr.20071102163001.410">class EditLabelEnabler( java.lang.Runnable ):
    '''This class enables a label to be edited within the context of
       beginUpdate and endUpdate.  Doing the operation between these two
       calls resulted in NullPointer Exceptins to be thrown.  This does the work
       safely after those calls have been made, actually this is how it is used
       in endUpate, not with the EditLabelEnabler.  It is a policy on top of this
       classes mechanism'''

    def __init__( self, jtree, headlineEditor ):

        self._jtree = jtree
        self.headlineEditor = headlineEditor
        #We use an AtomicReference to ensure that the node is fresh.
        #We use 2 Semaphores so we can correctly time the execution of an insert
        #and the beginning of a label edit.  Without this we can move too quickly 
        #and produce  NullPointerExceptions, or something like that.
        self.edit_v = atomic.AtomicReference()
        self.semaphore = concurrent.Semaphore( 1 ) 
        self.add_to_queue = concurrent.Semaphore( 1 )


    def setNodeToEdit( self, node ):

        if node:
            self.semaphore.acquire()
            self.edit_v.set( node.copy() )
            self.semaphore.release()

    def addToEventQueue( self ):
        #java.lang.Thread.dumpStack()
        if self.edit_v.get() and self.add_to_queue.availablePermits():
            self.add_to_queue.acquire()
            awt.EventQueue.invokeLater( self )


    def run( self ):

        self.semaphore.acquire()
        posTM = self._jtree.getModel()
        ev = self.edit_v.getAndSet( None )
        self.semaphore.release()
        ptr = posTM.getPathToRoot( ev )
        #self.edit_v = None
        #self._jtree.requestFocusInWindow()
        self._jtree.startEditingAtPath( ptr )
        self.headlineEditor.requestFocusInWindow()
        self.add_to_queue.release()


</t>
<t tx="ekr.20071102163001.411">class ViewControls:

    def __init__( self ):
        self.menu = swing.JMenu( "Views" )
        self.bgroup = swing.ButtonGroup()
        self.layout = java.awt.CardLayout()
        self.base = swing.JPanel( self.layout )
        self.methods = {}
        self.detacher = None
        self.menu_bar = None
        self.count = 0

    def setMenuBar( self, bar ):
        self.menu_bar = bar
        if self.count &gt; 1:
            self.menu_bar.add( self.menu, 0 )

    def getMenu( self ):
        return self.menu

    def getBase( self ):
        return self.base

    def addControl( self, name, attachmethod, detachmethod, checkmark = 0 ):

        jmi = swing.JCheckBoxMenuItem( name )
        if checkmark:
            jmi.setSelected( 1 )
        self.methods[ name ] = ( attachmethod, detachmethod )
        jmi.actionPerformed = lambda event: self.__action(  name  )
        self.bgroup.add( jmi )
        self.menu.add( jmi )
        nwbase = swing.JPanel()
        nwbase.setLayout( awt.GridLayout( 1,1 )) 
        self.base.add( nwbase, name )
        if self.menu_bar and ( self.count &gt; 1 and self.menu.getParent() == None ):
            self.menu_bar.add( self.menu, 0 )
        self.count += 1
        return nwbase

    def __action( self, name ):

        if self.detacher: self.detacher()
        attach, detach = self.methods[ name ]
        self.layout.show( self.base, name )
        attach()
        self.detacher = detach


</t>
<t tx="ekr.20071102163001.412">class PopupEnabler( aevent.MouseAdapter ):

    def __init__( self, c ):
        aevent.MouseAdapter.__init__( self )
        self.node = None
        self.c = c
        #self.cursor = None
        #self.imagesetter = leoSwingTree.ImageSetter( c.frame.gp2, c )

    def mouseDragged( self, event ):
        self.c.frame.gp2.repaint()

    def mouseMoved( self, event ):
        pass

    def mousePressed( self, mevent ):

        button = mevent.getButton()
@
        if button == mevent.BUTTON1:
            tree = mevent.getSource()
            path = tree.getPathForLocation( mevent.x, mevent.y )
            if path:
                row = tree.getRowForLocation( mevent.x, mevent.y )
                self.node = path.getLastPathComponent().copy()
                bi2 = self.c.frame.tree.getRendererImageOfNode( self.node )
                self.cursor = tree.getCursor()
                ncursor = awt.Cursor.getPredefinedCursor( awt.Cursor.HAND_CURSOR )
                #tk = awt.Toolkit.getDefaultToolkit()
                #ccursor = tk.createCustomCursor( bi2, awt.Point(0,0 ), "ccursor" )
                self.imagesetter.setTargets( bi2, ncursor, path )
                swing.SwingUtilities.invokeLater( self.imagesetter )
@c
        if button == mevent.BUTTON3:
            self.showMenu( mevent )
@        
    def mouseReleased2( self, mevent ):
        tree = mevent.getSource()
        path = tree.getPathForLocation( mevent.x, mevent.y )
        updatestarted = False
        self.imagesetter.reset()
        try:
            if path and self.node:
                endpoint = path.getLastPathComponent().copy()
                if self.node.v.t != endpoint.v.t and not self.node.isAncestorOf( endpoint ):
                    try:
                        self.c.beginUpdate()
                        updatestarted = True
                    except:
                        pass
                    if endpoint.numberOfChildren():
                        self.c.dragToNthChildOf(self.node,endpoint,0)
                    else:
                        self.c.dragAfter(self.node,endpoint)
        finally:
            self.node = None
            if self.cursor:
                tree.setCursor( self.cursor )
                self.cursor = None
            if updatestarted:
                updatestarted = False
                self.c.endUpdate()
@c

    def showMenu( self, event ):

        popup = swing.JPopupMenu()
        class aa( swing.AbstractAction ):
            def __init__( self, name, command ):
                swing.AbstractAction.__init__( self, name )
                self.command = command

            def actionPerformed( self, event ):
                self.command()

        c = self.c
        commandlist = (  
                        ( "Read @file Nodes", c.readAtFileNodes, 0 ),
                        ( "Write @file Nodes", c.fileCommands.writeAtFileNodes, 0 ), 
                        (),
                        ( "Tangle", c.tangle, 0 ),
                        ( "Untangle", c.untangle, 0 ),
                        (),
                        ("Toggle Angle Brackets", c.toggleAngleBrackets, 0 ),
                        (),
                        ( "Cut Node", c.cutOutline, c.canCutOutline ),
                         (  "Copy Node", c.copyOutline, 0 ),
                         ( "Paste Node", c.pasteOutline, c.canPasteOutline ),
                         ( "Delete Node", c.deleteOutline, c.canDeleteHeadline ),
                         (),
                         ( "Insert Node", c.insertHeadline, 0 ),
                         ( "Clone Node", c.clone, 0 ),
                         ( "Sort Children", c.sortChildren, c.canSortChildren ),
                         ( "Sort Siblings", c.sortSiblings, c.canSortSiblings ),
                         (),
                         ( "Contract Parent", c.contractParent, c.canContractParent ),
                         )

        for z in commandlist:
            if len(z) == 0:
                popup.addSeparator()
            else:
                if z[ 2 ]:
                    ok = z[ 2 ]()
                else:
                    ok = True
                if ok:
                    popup.add( aa( z[ 0 ], z[ 1 ] ) )




        x = event.getX()
        y = event.getY()
        popup.show( event.getSource(), x, y )

</t>
<t tx="ekr.20071102163001.413">class ImageSetter( java.lang.Runnable, aevent.MouseMotionListener  ):
    def __init__( self , gp2, c, jtree):
        self.image = None
        self.gp2 = gp2
        self.c = c
        self.path = None
        jtree.addMouseMotionListener( self )

    def mouseDragged( self, event ):
        if self.image:
            self.gp2.repaint()

    def mouseMoved( self, event ):
        pass

    def setImage( self, image ):
        self.image = image


    def setPath( self, path ):
        self.path = path

    def setTargets( self, image , path ):
        self.image = image
        self.path = path

    def reset( self ):
        self.gp2.setImage( None ); self.gp2.setCursor( None )
        self.image  = self.path = None

    def run( self ):

        if self.image:# and self.cursor:
            tree = self.c.frame.tree.jtree
            epath = tree.getEditingPath()
            spath = tree.getSelectionPath()
            if not self.path.equals( epath ):
                self.gp2.setImage( self.image )
                #self.gp2.setCursor( self.cursor )
            else:
                self.reset()
</t>
<t tx="ekr.20071102163001.414">class TreeTransferHandler( swing.TransferHandler ):

    transferservice = java.util.concurrent.Executors.newSingleThreadExecutor()

    def __init__( self, c, jtree ):
        swing.TransferHandler.__init__( self )
        self.flavors = []
        DataFlavor = datatransfer.DataFlavor
        self.flavors.append( DataFlavor.javaFileListFlavor )
        self.uri = DataFlavor( "text/uri-list;class=java.lang.String" )
        self.smarker = DataFlavor( "text/internal-transfer;class=java.lang.String" )
        self.pspecflavor = DataFlavor( DataFlavor.javaJVMLocalObjectMimeType, 
                                       "class=%s" % PositionSpecification, 
                                       PositionSpecification.getClassLoader() ) #We use this one or the system can't find the PS class!
        self.flavors.append( self.uri )
        self.c = c
        self.jtree = jtree

    def createTransferable( self, jc ):
        pi = awt.MouseInfo.getPointerInfo()
        spot = pi.getLocation()
        swing.SwingUtilities.convertPointFromScreen( spot, self.jtree )
        path = self.jtree.getPathForLocation( spot.x, spot.y )
        rv = self.TreeTransferable( self.c, list( self.flavors ) )
        if path:
            p = path.getLastPathComponent().copy()
            rv.setPosition( p, self.pspecflavor )
            bi2 = self.c.frame.tree.getRendererImageOfNode( p.copy() ) 
        else:
            rv.addDataFlavor( self.smarker )
        return rv

    def getSourceActions( self, jc ):
        return self.COPY_OR_MOVE

    @others

</t>
<t tx="ekr.20071102163001.415">def canImport( self, jc, df ):

    for z in df:
        if z.equals( self.smarker ): return False

    for z in df:
        if z.isFlavorJavaFileListType(): return True
        elif z.equals( self.uri ): return True
        elif z.equals( self.pspecflavor ): return True

    return False</t>
<t tx="ekr.20071102163001.416">def importData( self, jc, trans ):

    c = self.c
    try:
        if trans.isDataFlavorSupported( self.pspecflavor ):
            pi = awt.MouseInfo.getPointerInfo()
            spot = pi.getLocation()
            swing.SwingUtilities.convertPointFromScreen( spot, self.jtree )
            path = self.jtree.getPathForLocation( spot.x, spot.y )
            if path:
                node = trans.getTransferData( self.pspecflavor )
                endpoint = path.getLastPathComponent().copy()
                if node.v.t != endpoint.v.t and not node.isAncestorOf( endpoint ):
                    try:
                        c.beginUpdate()
                        if endpoint.numberOfChildren(): 
                            self.c.dragToNthChildOf( node,endpoint,0)
                        else:
                            self.c.dragAfter( node,endpoint)
                    finally:
                        c.endUpdate()
            return True
        elif trans.isDataFlavorSupported( datatransfer.DataFlavor.javaFileListFlavor ):
            files = trans.getTransferData( datatransfer.DataFlavor.javaFileListFlavor )
            ifiles = self.ImportFiles( files, self )
            self.transferservice.submit( ifiles )
            return True
        elif trans.isDataFlavorSupported( self.uri ):
            uri = trans.getTransferData( self.uri )
            iurls = self.ImportUrls( uri, self )
            self.transferservice.submit( iurls )
            return True
    finally:
        pass

    return False</t>
<t tx="ekr.20071102163001.417">def importFile( self, filename ):

    c = self.c
    at = c.atFileCommands
    io = java.io
    filename = java.net.URLDecoder.decode( filename, "UTF-8" )
    if filename.endswith( ".leo" ):
        try:
            c.chapters.loadFileAsChapter( filename )
        except:
            g.es( "Error loading %s" % filename )            
    else:
        isDerived = False
        thin = False
        try:
            theFile = open(filename,'rb')
            firstLines , readNew, thin = at.scanHeader(theFile,filename)
            isDerived = ( readNew or thin )
            theFile.close()
        except IOError:
            g.es( "Could not import %s" % filename )
            return
        if isDerived:
            c.importCommands.importDerivedFiles( c.currentPosition().copy(), [ filename, ] )
        else:
            c.importCommands.importFilesCommand( [ filename, ], "@file" )
        try:
            nwname = io.File( filename ).getName()
            if nwname:
                cp = c.currentPosition()
                cp.setHeadStringOrHeadline( nwname )

        except:
            pass

</t>
<t tx="ekr.20071102163001.418">def getVisualRepresentation( self, transf ):

    tree = self.c.frame.tree
    icon = tree.getRendererImageOfNode( self.c.currentPosition() )
    return icon</t>
<t tx="ekr.20071102163001.419">class TreeTransferable( datatransfer.Transferable ):

    def __init__( self, c, flavors ):
        self.c = c
        self.flavors = flavors
        self.uri = datatransfer.DataFlavor( "text/uri-list;class=java.lang.String" )
        self.position = None
        self.pflavor = None
        self.writen = False
        self.nwfile = None

    def addDataFlavor( self, flavor ):
        self.flavors.append( flavor )

    def setPosition( self, position, flavor ):
        self.position = position
        self.pflavor = flavor
        self.flavors.append( flavor )

    def getTransferDataFlavors( self ):
        return self.flavors 

    def isDataFlavorSupported( self, flavor ):

        for z in self.flavors:
            if flavor.equals( z ): return True
        return False

    @others
</t>
<t tx="ekr.20071102163001.420">def getTransferData( self, df ):

    if df.equals( datatransfer.DataFlavor.javaFileListFlavor ):
        rv = util.ArrayList()
        if not self.writen:
            tmpfile = io.File.createTempFile( "Node", "Drop" )
            self.nwfile = self.writeNodeToFile( tmpfile )
            self.written = True

        rv.add( self.nwfile )
        return rv
    elif df.equals( self.uri ):
        if not self.writen:
            tmpfile = io.File.createTempFile( "Node", "Drop" )
            self.nwfile = self.writeNodeToFile( tmpfile )
            self.writen = True

        rv = self.nwfile.toURI().toString()
        return rv
    elif self.pflavor and df.equals( self.pflavor ):
        return self.position
    else:
        raise datatransfer.UnsupportedFlavorException( df )</t>
<t tx="ekr.20071102163001.421">def writeNodeToFile( self, tmpfile ):

    c = self.c
    cp = c.currentPosition()
    at = c.atFileCommands
    c.fileCommands.assignFileIndices()
    fn = cp.v.anyAtFileNodeName()
    if fn:
        nosentinels = cp.v.atNoSentinelsFileNodeName()
        if nosentinels: nosentinels = True
        else: nosentinels = False
        thinFile = cp.v.atThinFileNodeName()
        if thinFile: thinFile = True
        else: thinFile = False
        at.write( cp.copy(), thinFile = thinFile, nosentinels = nosentinels, toString = True, scriptWrite = False )
    else:
        at.write( cp.copy(), thinFile = True, toString = True, scriptWrite = False )
    data = at.stringOutput 
    ps = None
    io = java.io
    encoding = "UTF-8"
    try:
        try:
            fos = io.FileOutputStream( tmpfile )
            ps = io.PrintWriter( io.OutputStreamWriter( fos ) ) 
            for z in data.split( "\n" ):
                ps.println( z )
            ps.close()
            ps = None
            frd = io.FileReader( tmpfile )
            encoding = frd.getEncoding()
            frd.close()
            frd = None       
        except io.IOException, io:
            io.printStackTrace()
    finally:
        if ps: ps.close()
        if frd: frd.close()
    hstring = cp.headString()
    if cp.v.anyAtFileNodeName():
        hstring = cp.v.anyAtFileNodeName()
    language = LeoUtilities.scanForLanguage( cp.copy() ) 
    if g.app.language_extension_dict.has_key( language ):
        ext = g.app.language_extension_dict[ language ]
    else:
        ext = language

    import binascii
    hstring = list( hstring )
    for i in xrange( len( hstring ) ):
        ch = hstring[ i ]
        if not ch.isalnum() and not ch.isspace() and ch not in ( "." ):
            hstring[ i ] = binascii.hexlify( ch )

    hstring = "".join( hstring )

    if not hstring.endswith( ext ):
        nwname = "%s.%s" %( hstring, ext )
    else:
        nwname = hstring
    nwname = java.net.URLEncoder.encode( nwname, encoding )
    pdirectory = tmpfile.getParent()
    try:
        if fn:
            fn2 = io.File( fn )
            nwfile = io.File( pdirectory, fn2.getName() )
        else:
            nwfile = io.File( pdirectory, nwname )
    except io.IOException, ix:
        ix.printStackTrace()
    tmpfile.renameTo( nwfile )
    nwfile.deleteOnExit()
    return nwfile
</t>
<t tx="ekr.20071102163001.422">class ImportUrls( java.lang.Runnable ):

    def __init__( self, uri, tth ):
        self.uri = uri
        self.tth = tth

    def run( self ):
        uris = self.uri.split( "\r\n" )
        for z in uris:
            try:
                if z:
                    f = java.net.URL( z ).getFile()
                    self.tth.importFile( f )
            except java.lang.Exception, x:
                x.printStackTrace()
</t>
<t tx="ekr.20071102163001.423">class ImportFiles( java.lang.Runnable ):

    def __init__( self, files, tth ):
        self.files = files
        self.tth = tth

    def run( self ):

        for z in self.files:
            try:
                fname = z.getAbsolutePath()
                if fname:
                    self.tth.importFile( fname )
            except java.lang.Exception, x:
                x.printStackTrace()
</t>
<t tx="ekr.20071102163001.424">def focusGained( self, event ):

    if self.jtree.isEditing():
        self.jtree.getCellEditor().requestFocusInWindow()

def focusLost( self, event ):
    pass
</t>
<t tx="ekr.20071102163001.425">def getEditorImageOfNode( self, p ):

    path = self.posTM.getPathToRoot( p )
    row = self.jtree.getRowForPath( path )
    comp = self.tcEdi.getTreeCellEditorComponent( self.jtree, p, p.isCurrentPosition(), p.isExpanded(), p.numberOfChildren(), row )
    return self.__createImage( comp )    



def getRendererImageOfNode( self, p ):

    path = self.posTM.getPathToRoot( p )
    row = self.jtree.getRowForPath( path ) 
    comp = self.renderer.getTreeCellRendererComponent( self.jtree, p, p.isCurrentPosition(), 
                                                       p.isExpanded(), p.numberOfChildren(), row, True ) 
    return self.__createImage( comp )

def __createImage( self, component ):

    psize = component.getPreferredSize()
    bi = awt.image.BufferedImage( psize.width, psize.height, awt.image.BufferedImage.TYPE_INT_RGB )
    g = bi.createGraphics()

    #jw = swing.JWindow()
    #jw.toBack()
    #mpi = awt.MouseInfo.getPointerInfo()
    #location = mpi.getLocation()
    #jw.setLocation( location )
    #jw.add( component )
    #jw.setSize( psize )
    opaque = component.isOpaque()
    background = component.getBackground()
    component.setOpaque( True )
    component.setBackground( awt.Color.WHITE )
    #jw.visible = 1
    self.jtree.add( component )
    component.setSize( component.getPreferredSize() ) #this appears to work better then making a short lived window
    component.paint( g ) 
    self.jtree.remove( component )
    #jw.visible = 0
    component.setOpaque( opaque )
    component.setBackground( background )
    #jw.dispose()
    g.dispose()
    return bi          



</t>
<t tx="ekr.20071102163001.426">def getFont (self):

    return self.font

# Called by leoFontPanel.
def setFont(self,font=None, fontName=None):

    # ESSENTIAL: retain a link to font.
    if fontName:
        self.fontName = fontName
        #self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font
    print "SETTING FONT!!!!"

    self.setLineHeight(self.font)

# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):

    c = self.c
    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize, tag = "tree")


    #    font = config.getFontFromParams( self.c,
    #    "log_text_font_family", "log_text_font_size",
    #    "log_text_font_slant",  "log_text_font_weight",
    #    config.defaultLogFontSize)

    #font2 = c.config.getFontFromParams( self.c,
    #    "headline_text_font_family", "headline_text_font_size",
    #    "headline_text_font_slant",  "headline_text_font_weight",
    #    c.config.defaultTreeFontSize )#, tag = "tree")


    #self.setFont(font)
    self.jtree.setFont( font )</t>
<t tx="ekr.20071102163001.427">def setBackgroundColor (self, notification = None, handback = None ):

    c = self.c

    color = c.config.getColor("outline_pane_background_color")
    bg = getColorInstance( color, awt.Color.WHITE )

    try:
        #self.canvas.configure(bg=bg)
        self.jtree.setBackground( bg )
    except:
        g.es("exception setting outline pane background color")
        g.es_exception()</t>
<t tx="ekr.20071102163001.428"></t>
<t tx="ekr.20071102163001.429">def getColorInstance( val, OnNone=None ):

    if hasattr( awt.Color, val ):
        return getattr( awt.Color, val )
    else:
        try:
            l = java.lang.Long.parseLong( val, 16 )
            l2 = java.lang.Long( l )
            color = awt.Color.decode( "%s" % l2.intValue() )
            return color

        except java.lang.Exception, x:
            #print 'WHATDA!!!!  %s' % x
            pass

    return OnNone</t>
<t tx="ekr.20071102163001.430">class leoJSPFocusListener( aevent.FocusListener ):
    '''A Class that changes the border of a focused JViewPort'''

    _listeners = {}

    def __init__( self, jsp, c ):
        self.jsp = jsp
        self.c = c
        color = g.app.config.getColor( c, "component_focused_bordor_color" )
        self.fcolor = getColorInstance( color, awt.Color.RED )
        color = g.app.config.getColor( c, "component_unfocused_bordor_color" )
        self.ucolor = getColorInstance( color, awt.Color.GREEN )

        self.border = self.LineBorder2( self.ucolor )
        jsp.setViewportBorder( self.border )
        if not leoJSPFocusListener._listeners.has_key( c ):
            group =  leoJSPFocusListener._listeners[ c ] = []
        else:
            group = leoJSPFocusListener._listeners[ c ]
        group.append( self )

    def focusGained( self, event ):

        self.border.setColor( self.fcolor )
        self.jsp.repaint()
        group = leoJSPFocusListener._listeners[ self.c ] 
        for x in group:
            if x == self: continue
            else:
                x.border.setColor( self.ucolor )
                x.jsp.repaint()

    def focusLost( self, event ):
        pass 


    class LineBorder2( sborder.LineBorder ):

        def __init__( self, color ):
            sborder.LineBorder.__init__( self, color )
            self.color = color


        def setColor( self, color ):
            self.color = color


        def paintBorder( self, c, g, x,y,w,h ):

            g.setColor( self.color )
            g.drawRect( x, y, w -1, h -1 )
</t>
<t tx="ekr.20071102163001.431">class VisibleInformer( sevent.ChangeListener ):
    '''A class that allows a change in the tab of a tabbed pane to
       be used as a notification to registered callbacks.'''

    def __init__( self, tabbedpane ):
        self.tabbedpane = tabbedpane #should be a JTabbedPane, or at least a component that has:
                                     #getSelectedComponent and an addChangeListener method
        tabbedpane.addChangeListener( self )
        self.callbacks = {}

    def addCallback( self, component, callback ):
        self.callbacks[ component ] = callback

    def stateChanged( self, event ):

        component = self.tabbedpane.getSelectedComponent()
        if self.callbacks.has_key( component ):
            self.callbacks[ component ]()    
</t>
<t tx="ekr.20071102163001.432">import leoGlobals as g 
import leoFind  
import javax.swing as swing
import javax.swing.border as sborder
import javax.swing.table as stable
import javax.swing.event as sevent
import java.util.HashSet as hset
import java.awt as awt   
import java.awt.event as aevent
import java.lang


class leoSwingFind (leoFind.leoFind ):

    """A class that implements Leo's tkinter find dialog."""

    @others</t>
<t tx="ekr.20071102163001.433"></t>
<t tx="ekr.20071102163001.434">def __init__(self,c, title="Find/Change",resizeable=False ):

    # Init the base classes...

    leoFind.leoFind.__init__(self, c)
    self.title = title
    g.app.findFrame = self
    #leoTkinterDialog.leoTkinterDialog.__init__(self,title,resizeable)

    &lt;&lt; init the tkinter ivars &gt;&gt;
    self.c = c
    #self.createTopFrame() # Create the outer tkinter dialog frame.
    self.createFrame()
    self.lasPos = None
    self.reverse_flag = False
    self.selection = False

</t>
<t tx="ekr.20071102163001.435">self.dict = {}



for key in self.intKeys:
    self.dict[key] = self.fakeIntTkVar()

for key in self.newStringKeys:
    self.dict[key] = self.fakeStringTkVar()

#self.s_text = Tk.Text() # Used by find.search()
self.s_text = "HI" #AssertionError without</t>
<t tx="ekr.20071102163001.436">class fakeStringTkVar:

    def __init__( self ):

        self.sb = ""

    def get( self ):
        return self.sb

    def set( self, value ):  

        self.sb = value

class fakeIntTkVar:

    def __init__( self ):
        self.val = 0

    def get( self ):
        return self.val

    def set( self, value ):
        self.val = value</t>
<t tx="ekr.20071102163001.437">def destroySelf (self):

    self.top.destroy()</t>
<t tx="ekr.20071102163001.438">def createFrame (self):

    # Create the find panel...
    #outer = Tk.Frame(self.frame,relief="groove",bd=2)
    #outer.pack(padx=2,pady=2)
    self.top = swing.JFrame()
    g.app.gui.addLAFListener( self.top )
    #self.top.setDefaultCloseOperation( swing.JFrame.EXIT_ON_CLOSE )
    self.top.title = self.title
    jtab = swing.JTabbedPane()
    self.top.add( jtab )
    cpane = swing.JPanel()
    jtab.addTab( "regular search", cpane )
    clnsearch = swing.JPanel()
    clnsearch.setName( "Leodialog" )
    jtab.addTab( "node search", clnsearch )
    #cpane = outer.getContentPane()
    cpane.setName( "Leodialog" )
    cpane.setLayout( awt.GridLayout( 3, 1 ) )


    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create four columns of radio and checkboxes &gt;&gt;
    &lt;&lt; Create two rows of buttons &gt;&gt;

    self.createNodeSearchFrame( clnsearch )
    #self.top.setSize( 500, 500 )
    self.top.pack()
    size = self.top.getSize()
    size.width = size.width + 50
    self.top.setSize( size )
    splitpane.setDividerLocation( .5 )
    #outer.visible = True

    #for widget in (self.find_text, self.change_text):
    #    widget.bind ("&lt;1&gt;",  self.resetWrap)
    #    widget.bind("&lt;Key&gt;", self.resetWrap)
    #    widget.bind("&lt;Control-a&gt;",self.selectAll)
    #    #widget.bind(g.virtual_event_name("SelectAll"),self.selectAll)

    #for widget in (outer, self.find_text, self.change_text):
    #    widget.bind("&lt;Key-Return&gt;", self.findButton)
    #    widget.bind("&lt;Key-Escape&gt;", self.onCloseWindow)

    #self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)


</t>
<t tx="ekr.20071102163001.439">#fc = Tk.Frame(outer, bd="1m")
#fc.pack(anchor="n", fill="x", expand=1)
findPanel = self.findPanel = swing.JTextArea()
self.CutCopyPaste( findPanel )
fspane = swing.JScrollPane( findPanel )

self.changePanel = changePanel = swing.JTextArea()
self.CutCopyPaste( changePanel )
cpane2 = swing.JScrollPane( changePanel )
splitpane = swing.JSplitPane( swing.JSplitPane.VERTICAL_SPLIT, fspane, cpane2 )
splitpane.setDividerLocation( .5 )
#outer.getContentPane().add( splitpane )
cpane.add( splitpane )
#outer.pack()


# Removed unused height/width params: using fractions causes problems in some locales!
#fpane = Tk.Frame(fc, bd=1)
#cpane = Tk.Frame(fc, bd=1)

#fpane.pack(anchor="n", expand=1, fill="x")
#cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
#flab = Tk.Label(fpane, width=8, text="Find:")
#clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
#self.find_text   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=4,width=20)
#3self.change_text = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=4,width=20)

#fBar = Tk.Scrollbar(fpane,name='findBar')
#cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
#for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
#    txt['yscrollcommand'] = bar.set
#    bar['command'] = txt.yview
#    bar.pack(side="right", fill="y")

#flab.pack(side="left")
#clab.pack(side="left")
#ctxt.pack(side="right", expand=1, fill="both")
#ftxt.pack(side="right", expand=1, fill="both")</t>
<t tx="ekr.20071102163001.440">#columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
#columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.
columnsFrame = swing.JPanel()
columnsFrame.setLayout( swing.BoxLayout( columnsFrame, swing.BoxLayout.X_AXIS ) )
cpane.add( columnsFrame, awt.BorderLayout.SOUTH )

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []; buttonGroups = []
for i in xrange(numberOfColumns):
    #columns.append(Tk.Frame(columnsFrame,bd=1))
    jp = swing.JPanel()
    jp.setLayout( swing.BoxLayout( jp, swing.BoxLayout.Y_AXIS ) )
    columns.append( jp )
    radioLists.append([])
    checkLists.append([])
    buttonGroups.append( swing.ButtonGroup() )

for i in xrange(numberOfColumns):
    columnsFrame.add( columns[ i ] )
    #columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = [
    (self.dict["radio-find-type"],"Plain Search","plain-search"),  
    (self.dict["radio-find-type"],"Pattern Match Search","pattern-search"),
    (self.dict["radio-find-type"],"Script Search","script-search")]
checkLists[0] = [
    ("Script Change",self.dict["script_change"])]
checkLists[1] = [
    ("Whole Word",  self.dict["whole_word"]),
    ("Ignore Case", self.dict["ignore_case"]),
    ("Wrap Around", self.dict["wrap"]),
    ("Reverse",     self.dict["reverse"])]
radioLists[2] = [
    (self.dict["radio-search-scope"],"Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only","selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search Headline Text", self.dict["search_headline"]),
    ("Search Body Text",     self.dict["search_body"]),
    ("Mark Finds",           self.dict["mark_finds"]),
    ("Mark Changes",         self.dict["mark_changes"])]


class rAction( swing.AbstractAction ):

    def __init__( self, name, var , val ):
        swing.AbstractAction.__init__( self, name )
        self.name = name
        self.var = var
        self.val = val

    def actionPerformed( self, aE ):
        self.var.set( self.val )

class jcbAction( swing.AbstractAction ):

    def __init__( self, name, var ):
        swing.AbstractAction.__init__( self, name )
        self.var = var

    def actionPerformed( self, ae ):

        val = self.var.get()
        if val:
            self.var.set( 0 )
        else:
            self.var.set( 1 )

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        aa = rAction( name, var, val )
        but = swing.JRadioButton( aa )
        columns[ i ].add( but )
        buttonGroups[ i ].add( but )
        #box = Tk.Radiobutton(columns[i],anchor="w",text=name,variable=var,value=val)
        #box.pack(fill="x")
        #box.bind("&lt;1&gt;", self.resetWrap)
        #if val == None: box.configure(state="disabled")
    for name, var in checkLists[i]:
        cbut = swing.JCheckBox( jcbAction( name, var ) )
        columns[ i ].add( cbut )
        #box = Tk.Checkbutton(columns[i],anchor="w",text=name,variable=var)
        #box.pack(fill="x")
        #box.bind("&lt;1&gt;", self.resetWrap)
        #if var is None: box.configure(state="disabled")

for z in buttonGroups:

    elements = z.getElements()
    for x in elements:
        x.setSelected( True )
        break
</t>
<t tx="ekr.20071102163001.441"># Create the button panes
secondGroup = swing.JPanel()
secondGroup.setLayout( awt.GridLayout( 2, 3 , 10, 10 ) )
cpane.add( secondGroup )
#buttons  = Tk.Frame(outer,bd=1)
#buttons2 = Tk.Frame(outer,bd=1)
#buttons.pack (anchor="n",expand=1,fill="x")
#buttons2.pack(anchor="n",expand=1,fill="x")
class commandAA( swing.AbstractAction ):

    def __init__( self, name, command ):
        swing.AbstractAction.__init__( self, name )
        self.command = command

    def actionPerformed( self, aE ):
        self.command()


# Create the first row of buttons
#findButton=Tk.Button(buttons,width=8,text="Find",bd=4,command=self.findButton) # The default.
#contextBox=Tk.Checkbutton(buttons,anchor="w",text="Show Context",variable=self.dict["batch"])
#findAllButton=Tk.Button(buttons,width=8,text="Find All",command=self.findAllButton)
findButton = swing.JButton( commandAA( "Find", self.findButton ) )
contextBox = swing.JCheckBox( "Show Context" )
findAllButton = swing.JButton( commandAA( "Find All", self.findAllButton ) )
secondGroup.add( findButton )
secondGroup.add( contextBox )
secondGroup.add( findAllButton )

#findButton.pack   (pady="1p",padx="25p",side="left")
#contextBox.pack   (pady="1p",           side="left",expand=1)
#findAllButton.pack(pady="1p",padx="25p",side="right",fill="x",)

# Create the second row of buttons
#changeButton    =Tk.Button(buttons2,width=8,text="Change",command=self.changeButton)
#changeFindButton=Tk.Button(buttons2,        text="Change, Then Find",command=self.changeThenFindButton)
#changeAllButton =Tk.Button(buttons2,width=8,text="Change All",command=self.changeAllButton)
changeButton = swing.JButton( commandAA( "Change", self.changeButton ) )
changeFindButton = swing.JButton( commandAA( "Change, Then Find", self.changeThenFindButton ) )
changeAllButton = swing.JButton( commandAA( "Change All", self.changeAllButton ) )
secondGroup.add( changeButton )
secondGroup.add( changeFindButton )
secondGroup.add( changeAllButton )

#changeButton.pack    (pady="1p",padx="25p",side="left")
#changeFindButton.pack(pady="1p",           side="left",expand=1)
#changeAllButton.pack (pady="1p",padx="25p",side="right")</t>
<t tx="ekr.20071102163001.442">def createNodeSearchFrame( self, clnpanel ):

    clnpanel.setLayout( awt.BorderLayout() )
    oclnpanel = clnpanel
    clnpanel = swing.Box.createHorizontalBox()
    oclnpanel.add( clnpanel, awt.BorderLayout.CENTER )


    jta = swing.JTextArea()
    self.CutCopyPaste( jta )
    tp = swing.JPanel( awt.GridLayout( 1, 1 ))
    self.nstext = jta
    sp = swing.JScrollPane( jta )

    border = sp.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Base Text" )
    sp.setBorder( tborder )
    tp.add( sp )
    clnpanel.add( tp )


    bpanel = swing.JPanel()
    spl = swing.SpringLayout()
    bpanel.setLayout( spl )  
    executebox = swing.Box.createHorizontalBox()
    border = executebox.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Searching" )
    executebox.setBorder( tborder )
    bpanel.add( executebox )
    spl.putConstraint( spl.NORTH, executebox, 5, spl.NORTH, bpanel )
    clnsearch = swing.JButton( "Clone Search" )
    clnsearch.actionPerformed = self.nodeSearch
    executebox.add( clnsearch )
    #spl.putConstraint( spl.NORTH, clnsearch, 5, spl.NORTH, bpanel )
    cpysearch = swing.JButton( "Copy Search" )
    cpysearch.actionPerformed = lambda event: self.nodeSearch( event, type='copy' ) 
    #bpanel.add( cpysearch )
    #spl.putConstraint( spl.NORTH, cpysearch, 5, spl.SOUTH, clnsearch )
    executebox.add( cpysearch )

    self.all_searches = rb1 = swing.JCheckBox( "Match Searches" )
    mtext = """Selecting causes the search system to only recognize a node if all searches match"""
    rb1.setToolTipText( mtext ) 
    bpanel.add( rb1 )
    spl.putConstraint( spl.NORTH, rb1, 5, spl.NORTH, bpanel )
    spl.putConstraint( spl.WEST, rb1, 5, spl.EAST, executebox )


    self.all_filters = rb2 = swing.JCheckBox( "Match Filters" )
    mtext = """Selecting causes the filter system to only filter out a node if all searches match"""
    rb2.setToolTipText( mtext )
    bpanel.add( rb2 )
    spl.putConstraint( spl.NORTH, rb2, 5, spl.SOUTH, rb1 )
    spl.putConstraint( spl.WEST, rb2, 5, spl.EAST, executebox )

    spl2 = swing.SpringLayout()
    sandf = swing.JPanel( spl2 )
    sandf.setPreferredSize( awt.Dimension( 275, 85 ) )
    border = sandf.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Derive Searches and Filters" )
    sandf.setBorder( tborder )
    bpanel.add( sandf )
    spl.putConstraint( spl.NORTH, sandf, 5, spl.SOUTH, executebox )

    b1 = swing.JButton( "+ as Search" )
    b1.setActionCommand( "search" )
    b1.actionPerformed = self.addAsSearchOrExclude
    b2 = swing.JButton( "+ as Filter" )
    b2.setActionCommand( "filter" )
    b2.actionPerformed = self.addAsSearchOrExclude
    sandf.add( b1 ); sandf.add( b2 )
    spl2.putConstraint( spl2.NORTH, b1, 5, spl2.NORTH, executebox )
    spl2.putConstraint( spl2.NORTH, b2, 5, spl2.SOUTH, b1 )
    b3 = swing.JButton( "+ as Regex-Search" )
    b3.setActionCommand( "regex-search" )
    b3.actionPerformed = self.addAsSearchOrExclude
    sandf.add( b3 )
    spl2.putConstraint( spl2.NORTH, b3,5, spl2.NORTH, executebox )
    spl2.putConstraint( spl2.WEST, b3,5, spl2.EAST, b1 )
    #spl2.putConstraint( spl2.EAST, b3, 5, spl2.EAST, executebox )
    b4 = swing.JButton( "+ as Regex-Filter" )
    b4.setActionCommand( "regex-filter" )
    b4.actionPerformed = self.addAsSearchOrExclude
    sandf.add( b4 )
    spl2.putConstraint( spl2.NORTH, b4, 5, spl2.SOUTH, b1 )
    spl2.putConstraint( spl2.WEST, b4, 5, spl2.EAST, b2 )
    clear = swing.JButton( "Clear Text" )
    def clear_txt( event, text = jta ):

        jta.setText( "" )
    clear.actionPerformed = clear_txt
    bpanel.add( clear )
    spl.putConstraint( spl.NORTH, clear, 5, spl.SOUTH, sandf )


    clnpanel.add( bpanel )
    tp.setPreferredSize( awt.Dimension( 200, 100 ) )
    clnpanel.setPreferredSize( awt.Dimension( 200, 100 )) 

    class dtm2( stable.DefaultTableModel ):

        def __int__( self ):
            stable.DefaultTableModel.__init__( self )

        def isCellEditable( self, a, b ):
            if b == 1:
                return False
            return True

    self.dtm = dtm = dtm2()
    dtm.addColumn( "Text" )
    dtm.addColumn( "Type" )
    jp = swing.JPanel( awt.BorderLayout() )
    self.table = jt = swing.JTable( dtm )
    jt.getColumn( "Text" ).setCellEditor( self._LeoTableCellEditor() )
    jt.getColumn( "Text" ).setCellRenderer( self._LeoTableCellRenderer() )

    rmv = swing.JButton( "Remove" )
    def rmv_row( event, jt = jt, dtm = dtm ):

        row = jt.getSelectedRow()
        if row != -1:
            dtm.removeRow( row )

    rmv.actionPerformed = rmv_row
    rmva = swing.JButton( "Clear" )
    def rmv_all( event, jt = jt, dtm = dtm ):

        rc = dtm.getRowCount()
        for z in xrange( rc ):
            dtm.removeRow( 0 )       

    rmva.actionPerformed = rmv_all   
    rmvp = swing.Box.createVerticalBox()
    rmvp.add( rmv )
    rmvp.add( rmva )
    jp.add( rmvp, awt.BorderLayout.EAST )
    jtsp = swing.JScrollPane( jt )
    border = jtsp.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Searchers and Filters" )
    jtsp.setBorder( tborder )
    jp.add( jtsp )

    jp.setPreferredSize( clnpanel.getPreferredSize() )
    oclnpanel.add( jp, awt.BorderLayout.SOUTH )
</t>
<t tx="ekr.20071102163001.443">def addAsSearchOrExclude( self, event ):

    source = event.getSource()
    ac = source.getActionCommand()

    doc = self.nstext.getDocument()
    txt = doc.getText( 0, doc.getLength() )

    self.dtm.addRow( ( java.lang.String( txt ), ac ) )</t>
<t tx="ekr.20071102163001.444">def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        val = getattr(c, key + "_flag")
        val = g.choose(val,1,0) # 2/1/04: work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20071102163001.445">self.find_text.delete("1.0","end")
self.find_text.insert("end",c.find_text)

self.change_text.delete("1.0","end")
self.change_text.insert("end",c.change_text)</t>
<t tx="ekr.20071102163001.446">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")

found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")</t>
<t tx="ekr.20071102163001.447">def update_ivars2 (self ): #was called set_ivars

    # N.B.: separate c.ivars are much more convenient than a dict.
    c = self.c
    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(c, key + "_flag", val)
        # g.trace(key,val)

    # Set ivars from radio buttons. 10/2/01: convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    c.pattern_match_flag = g.choose(find_type == "pattern-search",1,0)
    c.script_search_flag = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    c.suboutline_only_flag = g.choose(search_scope == "suboutline-only",1,0)
    c.node_only_flag       = g.choose(search_scope == "node-only",1,0)
    c.selection_only_flag  = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    #s = self.find_text.get("1.0","end - 1c") # Remove trailing newline
    #s = g.toUnicode(s,g.app.tkEncoding) # 2/25/03
    #c.find_text = s
    s = self.findPanel.getText()
    c.find_text = s

    #s = self.change_text.get("1.0","end - 1c") # Remove trailing newline
    #s = g.toUnicode(s,g.app.tkEncoding) # 2/25/03
    #c.change_text = s
    s = self.changePanel.getText()
    c.change_text = s</t>
<t tx="ekr.20071102163001.448">def update_ivars (self):

    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0) 
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    self.reverse_flag = self.dict[ 'reverse' ].get()

    #s = self.find_ctrl.get("1.0","end - 1c") # Remove trailing newline
    s = self.findPanel.getText()
    s = g.toUnicode(s,g.app.tkEncoding)
    self.find_text = s

    #s = self.change_ctrl.get("1.0","end - 1c") # Remove trailing newline
    s = self.changePanel.getText()
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20071102163001.449">def onCloseWindow(self,event=None):

    self.top.dispose()
    self.top = None</t>
<t tx="ekr.20071102163001.450">def bringToFront (self):

    """Bring the tkinter Find Panel to the front."""

    c = g.top() ; #t = self.find_text ; 
    gui = g.app.gui
    t = self.findPanel
    width, height = gui._calculateCenteredPosition( self.top )
    self.top.setLocation( width, height )        
    #self.top.withdraw() # Helps bring the window to the front.
    #self.top.deiconify()
    #self.top.lift()
    self.top.visible = 1

    gui.set_focus(c,t)
    gui.setTextSelection (t, 0, len( t.getText() )) # Thanks Rich.
</t>
<t tx="ekr.20071102163001.451">def selectAll (self,event=None):

    try:
        w = self.frame.focus_get()
        g.app.gui.setTextSelection(w,"1.0","end")
        return "break"
    except:
        return None # To keep pychecker happy.</t>
<t tx="ekr.20071102163001.452">def gui_search (self,t,*args,**keys):
    nocase = keys[ 'nocase' ]
    backwards = keys[ 'backwards' ]
    regexp = keys[ 'regexp' ]
    stopindex = keys[ 'stopindex' ]

    if self.pattern_match:
        import java.util.regex as reg
        flags = 0
        if not regexp:
            flags = flags|reg.Pattern.LITERAL
        if nocase:
            flags = flags|reg.Pattern.CASE_INSENSITIVE
        flags = java.lang.Integer( flags )

        pat = args[ 0 ]
        pat = reg.Pattern.compile( pat, flags.intValue() )
        match = pat.matcher( java.lang.String( t ) )
        if stopindex:
            match = match.region( 0, stopindex )

        if backwards:
            start = -1
            end = -1
            while match.find():
                start = match.start()
                end = match.end()
            return start, end
        else:
            found = match.find()
            if found:
                return ( match.start(), match.end() )
            else: return None, None
    else:
        if backwards:
            where = t.rfind( args[ 0 ] )
            if where != -1:
                return where, where + len( args[ 0 ] )
            else:
                return None, None
        else:
            match = java.lang.String( t ).indexOf( args[ 0 ] )
            if match != -1:
                return match, match + len( args[ 0 ] )
            else:
                return None, None
    #return t.search(*args,**keys)

def init_s_ctrl (self,s):
    c = self.c ; #t = self.s_text	
    return c.frame.body.editor.editor
    #t.delete("1.0","end")
    #t.insert("end",s)
    #t.mark_set("insert",g.choose(c.reverse_flag,"end","1.0"))
    #return t
</t>
<t tx="ekr.20071102163001.453">def search (self):

    """Searches the present headline or body text for c.find_text and returns True if found.

    c.whole_word_flag, c.ignore_case_flag, and c.pattern_match_flag control the search."""

    __pychecker__ = '--no-implicitreturns' # Suppress bad warning.

    self.p = self.c.currentPosition()
    c = self.c ; p = self.p 
    self.v = p
    se = 0
    index = 0
    stopindex = 0
    editor = self.c.frame.body.editor.editor
    caret_pos = editor.getCaretPosition()
    doc = editor.getDocument()

    if self.selection:
        txt = editor.getSelectedText()
    else:
        if self.reverse_flag:
            txt = doc.getText( 0, caret_pos )
        else:
            txt = doc.getText( caret_pos, doc.getLength() - caret_pos )
    #xt = editor.getText( caret_pos, len( txt ) )
    find_text = self.findPanel.getText()
    pos = self.gui_search(txt ,find_text,index,
                            stopindex=stopindex,backwards=self.reverse_flag,
                            regexp=self.pattern_match,nocase=self.ignore_case)

    notin = ( None, -1 )        
    if self.node_only: 
        if pos[ 0 ] in notin and pos[ 1 ] in notin:
            return pos
        else:
            return pos[ 0 ] + caret_pos, pos[ 1 ] + caret_pos
    if self.selection:
        if pos[ 0 ] in notin and pos[ 1 ] in notin: return pos
        else:
            return pos[ 0 ] + caret_pos, pos[ 1 ] + caret_pos

    if pos[ 0 ] in notin and pos[ 1 ] in notin:
        #if self.suboutline_only:
        #    iterator = self.p.children_iter()
        #else:
        #    iterator = self.p.allNodes_iter()
        #    for z in iterator:
        #        if z == p: break

        self.v = z = self.selectNextVnode()
        while z:
            #if z == p: continue
            txt = z.bodyString()
            pos = self.gui_search(txt ,find_text,index,
                            stopindex=stopindex,backwards=self.reverse_flag,
                            regexp=self.pattern_match,nocase=self.ignore_case)
            if pos[ 0 ] not in ( None, -1 ) and pos[ 1 ] not in ( None, -1 ):
                c.beginUpdate()
                c.selectPosition( z )
                c.endUpdate()
                return pos
            else:
                self.v = z = self.selectNextVnode()     
    else:
        if self.reverse_flag:
            npos = pos[ 1 ], pos[ 0 ]
        else:
            npos = pos[ 0 ] + caret_pos, pos[ 1 ] + caret_pos
        return npos

    return None, None        

@
    if self.lasPos and self.lasPos == v:
        ed = self.c.frame.body.editor.editor
        se = ed.getCaretPosition()
        t = ed.getText()
        t = t[ se: ]
        #t = ed.getText( se, len( ed.getText() ) - se  )
    else:
        t = v.bodyString()
        self.lasPos = v.copy()
    gui = g.app.gui

    assert(c and v)
    if c.selection_only_flag: # 11/9/03
        index,stopindex = self.selStart, self.selEnd
        # g.trace(index,stopindex,v)
        if index == stopindex:
            return None, None
    else:
        #index = gui.getInsertPoint(t)
        index = v.v.t.insertSpot
        stopindex = g.choose(c.reverse_flag,gui.firstIndex(),gui.lastIndex())
    sub_iter = self.v.allNodes_iter( copy = True )
    sub_iter.first = self.v.copy()
    for z in sub_iter:
        if self.lasPos and self.lasPos == z:
            ed = self.c.frame.body.editor.editor
            se = ed.getCaretPosition()
            t = ed.getText()
            t = t[ se: ]
        else:
            se = 0
            t = z.bodyString()
        try:
            pos = self.gui_search(t,c.find_text,index,
                stopindex=stopindex,backwards=c.reverse_flag,
                regexp=c.pattern_match_flag,nocase=c.ignore_case_flag)
        except:
            g.es_exception(full=False)
            self.errors += 1
            return None, None
        if not pos:
            continue

        t = self.c.frame.body.editor.editor
        self.c.beginUpdate()
        self.c.frame.tree.select( z )
        self.c.endUpdate()
        t.requestFocusInWindow()
        t.select( pos[ 0 ] + se  , pos[ 1 ] + se )
        return pos[ 0 ] + se, pos[ 1 ] + se

</t>
<t tx="ekr.20071102163001.454">def findButton( self ):

    self.setup_button()
    self.executeSearch()
@
    pos = self.search()
    if pos[ 0 ] and pos[ 1 ]:
        editor = self.c.frame.body.editor.editor
        editor.select( pos[ 0 ], pos[ 1 ] )
        #editor.setSelectionStart( pos[ 0 ] )
        #editor.setSelectionEnd( pos[ 1 ] )
        if len(self.change_text ) != 0:
            editor.replaceSelection( self.change_text )

</t>
<t tx="ekr.20071102163001.455">def executeSearch( self ):

    pos = self.search()
    if pos[ 0 ] not in ( None, -1 ) and pos[ 1 ] not in ( None, -1 ):
        editor = self.c.frame.body.editor.editor
        editor.setCaretPosition( pos[ 0 ] )
        editor.moveCaretPosition( pos[ 1 ] )

        if self.mark_finds:

            cp = self.c.currentPosition()
            cp.setMarked()
            self.c.frame.tree.redraw()

</t>
<t tx="ekr.20071102163001.456">def findNextCommand( self, c ):

    self.executeSearch()</t>
<t tx="ekr.20071102163001.457">def changeAll( self ):

    cp = self.c.currentPosition().copy()

    fdoc = self.findPanel.getDocument()
    cdoc = self.changePanel.getDocument()
    ftxt = self.findPanel.getText( 0, fdoc.getLength() )
    ctxt = self.changePanel.getText( 0, cdoc.getLength() )
    if self.pattern_match:
        import java.util.regex as reg
        pattern = reg.Pattern.compile( ftxt )
        matcher = pattern.matcher( java.lang.String( "" ) )
    for z in cp.allNodes_iter( copy = True ):

        changed = False
        txt = z.bodyString()
        if self.pattern_match:
            matcher.reset( java.lang.String( txt ) )
            ntxt = matcher.replaceAll( java.lang.String( ctxt ) )
        else:
            ntxt = txt.replace( ftxt, ctxt )

        if txt != ntxt: changed = True
        if changed:
            z.setBodyStringOrPane( ntxt )
            if self.mark_changes:
                z.setMarked()

    self.c.frame.tree.redraw()


</t>
<t tx="ekr.20071102163001.458"></t>
<t tx="ekr.20071102163001.459">def nodeSearch( self, event, type = 'clone' ):

    all_searches = self.all_searches.isSelected()
    all_filters = self.all_filters.isSelected()
    dvector = self.dtm.getDataVector()
    if dvector.size() == 0: return
    search = []
    rsearch = []
    filter = []
    rfilter = []
    addto = { 'search': search, 'regex-search': rsearch,
              'filter': filter, 'regex-filter': rfilter }
    for z in dvector:
        addto[ z[ 1 ] ].append( z[ 0 ] )

    bstring = 'Used All Searches: %s   Used All Filters: %s' %( all_searches, all_filters )
    bstring = bstring + '\n\nsearches: \n%s' % '\n'.join( search )
    bstring = bstring + '\n\nregex-searches: \n%s' % '\n'.join( rsearch )
    bstring = bstring + '\n\nfilters: \n%s' % '\n'.join( filter )
    bstring = bstring + '\n\nregex-filters: \n%s' % '\n'.join( rfilter )
    bstring = bstring + '\n\n@' + 'others'

    import java.util.regex as reg        
    for z in xrange( len( rfilter ) ):
        pat = reg.Pattern.compile( rfilter[ z ] )
        matcher = pat.matcher( java.lang.String( "" )) 
        rfilter[ z ] = matcher

    for z in xrange( len( rsearch ) ):
        pat = reg.Pattern.compile( rsearch[ z ] )
        matcher = pat.matcher( java.lang.String( "" ) )
        rsearch[ z ] = matcher






    c = self.c
    cp = self.c.currentPosition()
    if not cp.isValid(): return
    c.beginUpdate()
    if type == 'clone':
        chstring = "Clone Search Results:"
    else:
        chstring = "Copy Search Results:"
    container = self.createContainerNode( chstring, bstring )
    haveseen = {}
    haveseen[ container ] = None
    for z in cp.allNodes_iter( copy = True ):
        if z in haveseen: continue
        else:
            haveseen[ z ] = None

        if z.getParent() == container: continue
        elif z == container: continue
        bstring = z.bodyString()
        hstring = z.headString()
        found = False

        searchmatches = hset()
        if not found:
            for z2 in search:
                if bstring.find( z2 ) != -1:
                    found = True
                    if not all_searches:
                        break
                elif all_searches:
                    found = False
                    searchmatches.add( False )
                    break


        if not found or ( all_searches and False not in searchmatches ):
            for z2 in rsearch:
                matcher = z2
                matcher.reset( java.lang.String( bstring ) )
                if matcher.find():
                    found = True
                    if not all_searches:
                        break
                elif all_searches:
                    found = False
                    break    

        filtermatches = hset()
        if found:
            for z2 in filter:
                if bstring.find( z2 ) != -1:
                    filtermatches.add( True )
                    if not all_filters:
                        found = False
                        break
                elif all_filters:
                    filtermatches.add( False )
                    break



        filtermatches2 = hset()       
        if found:
            for z2 in rfilter:
                matcher = z2
                matcher.reset( java.lang.String( bstring ) )
                if matcher.find():
                    filtermatches2.add( True )
                    if not all_filters:
                        found = False
                        break
                elif all_filters:
                    filtermatches2.add( False )
                    break

        if all_filters and filtermatches.size() != 0 and filtermatches2.size() != 0 and  (
         ( False not in filtermatches ) and ( False not in filtermatches2 ) ):
            found = False

        if found:
            if type == 'clone':
                cln = z.clone( z )
                cln.moveToLastChildOf( container )
            else:
                pos = container.insertAsLastChild()
                cln = z.copyTreeFromSelfTo( pos )

    c.frame.tree.tree_reloader.expand( container )
    c.selectPosition( container )  
    c.endUpdate()     
</t>
<t tx="ekr.20071102163001.460">def createContainerNode( self, hs, bs ):

    c = self.c
    cp = c.currentPosition()
    np = cp.insertAfter()
    np.v.t.headString = hs
    np.v.t.bodyString = bs
    return np</t>
<t tx="ekr.20071102163001.461">class CutCopyPaste( aevent.MouseAdapter ):

    def __init__( self, jtcomponent ):

        self.jtcomponent = jtcomponent
        self.popup = popup = swing.JPopupMenu()
        i1 = swing.JMenuItem( "Cut" )
        i1.actionPerformed = lambda event: jtcomponent.cut()
        popup.add( i1 )
        i2 = swing.JMenuItem( "Copy" )
        i2.actionPerformed = lambda event: jtcomponent.copy()
        popup.add( i2 )
        i3 = swing.JMenuItem( "Paste" )
        i3.actionPerformed = lambda event: jtcomponent.paste()
        popup.add( i3 )
        i4 = swing.JMenuItem( "Select All" )
        i4.actionPerformed = lambda event: jtcomponent.selectAll()
        popup.add( i4 )
        jtcomponent.addMouseListener( self )

    def mousePressed( self, mevent ):

        if mevent.getButton() == mevent.BUTTON3:
            self.popup.show( self.jtcomponent, mevent.getX(), mevent.getY() )

</t>
<t tx="ekr.20071102163001.462">class _LeoTableCellEditor( swing.AbstractCellEditor, stable.TableCellEditor ):

    def __init__( self ):
        swing.AbstractCellEditor.__init__( self )  
        self._row = None      
        self._rowh = None   
        self._table = None    
        self.to_be_reset = []
        self.lsners = []

    class _deselector( sevent.PopupMenuListener ):

        def __init__( self, ced ):
            self.ced = ced

        def popupMenuCanceled( self, e):
            self.ced.fireEditingStopped()

        def popupMenuWillBecomeInvisible( self, e):
            self.ced.fireEditingStopped()

        def popupMenuWillBecomeVisible( self, e):
            pass  

    class _lcr( swing.DefaultListCellRenderer ):

        def __init__( self , data):
            swing.DefaultListCellRenderer.__init__( self )
            self.data = data

        def getListCellRendererComponent( self, list, value, index, isSelected, cellHasFocus):

            jta = swing.JTextArea()
            jta.setLineWrap( True )
            jta.setText( self.data ) 
            return jta

    def getTableCellEditorComponent( self, table, value, isSelected, row, column):


            values = value.split( '\n' )
            self._value = value
            jcb = swing.JComboBox( ( values[ 0 ], ) )
            jcb.addPopupMenuListener( self._deselector( self ) )
            jcb.setEditable( False )
            jcb.setRenderer( self._lcr( value ) )
            if len( values ) &gt; 5:
                jcb.setMaximumRowCount( 0 )
            else:
                jcb.setMaximumRowCount( 1 )
            if isSelected:
                jcb.setForeground( table.getSelectionForeground() )
                jcb.setBackground( table.getSelectionBackground() )
            else:
                jcb.setForeground( table.getForeground() )
                jcb.setBackground( table.getBackground() )
            return jcb


    def removeCellEditorListener( self, arg ):

        self.lsners.remove( arg )

    def addCellEditorListener( self, arg ):

        self.lsners.append( arg )

    def fireEditingStopped( self ):

        ce = sevent.ChangeEvent( self )
        for z in self.lsners:
            z.editingStopped( ce )

    def isCellEditable( self, evobj ):
        return True

    def shouldSelectCell( self, evobj ):

        return True

    def getCellEditorValue( self ):
        return self._value


    def stopCellEditing( self ):

        self.fireEditingStopped()
        return True

</t>
<t tx="ekr.20071102163001.463">class _LeoTableCellRenderer( stable.DefaultTableCellRenderer ):

    def __init__( self ):
        stable.DefaultTableCellRenderer.__init__( self )

    def getTableCellRendererComponent( self, table, value, isSelected, hasFocus, row, column):

        jcb = swing.JComboBox( ( value.split( '\n' )[ 0 ], ) )
        if isSelected:
            jcb.setForeground( table.getSelectionForeground() )
            jcb.setBackground( table.getSelectionBackground() )
        else:
            jcb.setForeground( table.getForeground() )
            jcb.setBackground( table.getBackground() )

        return jcb


</t>
<t tx="ekr.20071102163001.464">@language python  
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import leoCompare
import javax.swing as swing
import java.awt as awt
import java.awt.event as aevent
import java
import javax.swing.border as sborder
import javax.swing.table as stable


class leoSwingComparePanel (leoCompare.leoCompare):

    """A class that creates Leo's compare panel."""

    @others</t>
<t tx="ekr.20071102163001.465"></t>
<t tx="ekr.20071102163001.466">def __init__ (self,c):

    # Init the base class.
    leoCompare.leoCompare.__init__ (self,c)
    #leoTkinterDialog.leoTkinterDialog.__init__(self,"Compare files and directories",resizeable=False)
    self.c = c

    &lt;&lt; init tkinter compare ivars &gt;&gt;

    # These ivars are set from Entry widgets.
    self.limitCount = 0
    self.limitToExtension = None
    self._dtm = self._DTM( [  "","Mismatches", ], 0 )
    # The default file name in the "output file name" browsers.
    self.defaultOutputFileName = "CompareResults.txt"

    self.createTopFrame()
    self.createFrame()
</t>
<t tx="ekr.20071102163001.467"># Ivars pointing to Tk elements.
self.browseEntries = []
self.extensionEntry = None
self.countEntry = None
self.printButtons = []

# No corresponding ivar in the leoCompare class.
self.useOutputFileVar = self.IntVar()

# These all correspond to ivars in leoCompare	
self.appendOutputVar             = self.IntVar()

self.ignoreBlankLinesVar         = self.IntVar()
self.ignoreFirstLine1Var         = self.IntVar()
self.ignoreFirstLine2Var         = self.IntVar()
self.ignoreInteriorWhitespaceVar = self.IntVar()
self.ignoreLeadingWhitespaceVar  = self.IntVar()
self.ignoreSentinelLinesVar      = self.IntVar()

self.limitToExtensionVar         = self.IntVar()
self.makeWhitespaceVisibleVar    = self.IntVar()

self.printBothMatchesVar         = self.IntVar()
self.printMatchesVar             = self.IntVar()
self.printMismatchesVar          = self.IntVar()
self.printTrailingMismatchesVar  = self.IntVar()
self.stopAfterMismatchVar        = self.IntVar()</t>
<t tx="ekr.20071102163001.468">class IntVar:

    def __init__( self ):

        self._val = 0

    def get( self ):
        return self._val

    def set( self, val ):
        self._val = val
</t>
<t tx="ekr.20071102163001.469">class _DTM( stable.DefaultTableModel ):

    def __init__( self, *args ):
        stable.DefaultTableModel.__init__( self, *args )

    def isCellEditable( self, row, column ):
        return False

</t>
<t tx="ekr.20071102163001.470"># Initialize ivars from config parameters.

def finishCreate (self):

    c = self.c

    # File names.
    for i,option in (
        (0,"compare_file_1"),
        (1,"compare_file_2"),
        (2,"output_file") ):

        name = c.config.getString(option)
        if name and len(name) &gt; 0:
            e = self.browseEntries[i]
            e.delete(0,"end")
            e.insert(0,name)

    name = c.config.getString("output_file")
    b = g.choose(name and len(name) &gt; 0,1,0)
    self.useOutputFileVar.set(b)

    # File options.
    b = c.config.getBool("ignore_first_line_of_file_1")
    if b == None: b = 0
    self.ignoreFirstLine1Var.set(b)

    b = c.config.getBool("ignore_first_line_of_file_2")
    if b == None: b = 0
    self.ignoreFirstLine2Var.set(b)

    b = c.config.getBool("append_output_to_output_file")
    if b == None: b = 0
    self.appendOutputVar.set(b)

    ext = c.config.getString("limit_directory_search_extension")
    b = ext and len(ext) &gt; 0
    b = g.choose(b and b != 0,1,0)
    self.limitToExtensionVar.set(b)
    if b:
        e = self.extensionEntry
        #e.delete(0,"end")
        e.setText( ext )
        #e.insert(0,ext)

    # Print options.
    b = c.config.getBool("print_both_lines_for_matches")
    if b == None: b = 0
    self.printBothMatchesVar.set(b)

    b = c.config.getBool("print_matching_lines")
    if b == None: b = 0
    self.printMatchesVar.set(b)

    b = c.config.getBool("print_mismatching_lines")
    if b == None: b = 0
    self.printMismatchesVar.set(b)

    b = c.config.getBool("print_trailing_lines")
    if b == None: b = 0
    self.printTrailingMismatchesVar.set(b)

    n = c.config.getInt("limit_count")
    b = n and n &gt; 0
    b = g.choose(b and b != 0,1,0)
    self.stopAfterMismatchVar.set(b)
    if b:
        e = self.countEntry
        e.setText( str( n ) )
        #e.delete(0,"end")
        #e.insert(0,str(n))

    # bool options...
    for option,var,default in (
        # Whitespace options.
        ("ignore_blank_lines",self.ignoreBlankLinesVar,1),
        ("ignore_interior_whitespace",self.ignoreInteriorWhitespaceVar,0),
        ("ignore_leading_whitespace",self.ignoreLeadingWhitespaceVar,0),
        ("ignore_sentinel_lines",self.ignoreSentinelLinesVar,0),
        ("make_whitespace_visible", self.makeWhitespaceVisibleVar,0),
    ):
        b = c.config.getBool(option)
        if b is None: b = default
        var.set(b)

    if 0: # old code
        b = c.config.getBool("ignore_blank_lines")
        if b == None: b = 1 # unusual default.
        self.ignoreBlankLinesVar.set(b)

        b = c.config.getBool("ignore_interior_whitespace")
        if b == None: b = 0
        self.ignoreInteriorWhitespaceVar.set(b)

        b = c.config.getBool("ignore_leading_whitespace")
        if b == None: b = 0
        self.ignoreLeadingWhitespaceVar.set(b)

        b = c.config.getBool("ignore_sentinel_lines")
        if b == None: b = 0
        self.ignoreSentinelLinesVar.set(b)

        b = c.config.getBool("make_whitespace_visible")
        if b == None: b = 0
        self.makeWhitespaceVisibleVar.set(b)</t>
<t tx="ekr.20071102163001.471">def createTopFrame( self ):

    self.frame = self.top = swing.JDialog()
    g.app.gui.addLAFListener( self.frame )
    self.top.title = "Compare files and directories"</t>
<t tx="ekr.20071102163001.472">def createFrame (self):

    gui = g.app.gui ; top = self.top

    &lt;&lt; create the organizer frames &gt;&gt;
    &lt;&lt; create the browser rows &gt;&gt;
    &lt;&lt; create the extension row &gt;&gt;
    &lt;&lt; create the whitespace options frame &gt;&gt;
    &lt;&lt; create the print options frame &gt;&gt;
    &lt;&lt; create the compare buttons &gt;&gt;


    top.pack()
    gui.center_dialog(top) # Do this _after_ building the dialog!
    self.finishCreate()</t>
<t tx="ekr.20071102163001.473">#outer = Tk.Frame(self.frame, bd=2,relief="groove")
#outer.pack(pady=4)

sl = swing.SpringLayout()
outer = self.top.getContentPane() #swing.JPanel()
outer.setLayout( sl )
#self.frame.add( outer )

#row1 = Tk.Frame(outer)
#row1.pack(pady=4)
row1 = swing.JPanel( awt.GridLayout( 3, 4 ) )
outer.add( row1 )
sl.putConstraint( sl.NORTH, row1, 5, sl.NORTH, outer )


row4 = swing.JPanel()
outer.add( row4 )
sl.putConstraint( sl.NORTH, row4, 5, sl.SOUTH, row1 )


sl2 = swing.SpringLayout()
options =  swing.JPanel( sl2 )#swing.Box.createHorizontalBox() #swing.JPanel( sl2 );

outer.add( options )
sl.putConstraint( sl.NORTH, options, 5, sl.SOUTH, row4 )

#ws = Tk.Frame(options)
#ws.pack(side="left",padx=4)
ws = swing.JPanel()
ws.setLayout( awt.GridLayout( 1, 1 ) )
options.add( ws )
sl2.putConstraint( sl2.NORTH, ws, 2, sl2.NORTH, options )
sl2.putConstraint( sl2.WEST, ws, 5, sl2.WEST, options )

pr = swing.JPanel()
pr.setLayout( awt.GridLayout( 1, 1 ) )
options.add( pr )
sl2.putConstraint( sl2.NORTH, pr, 2, sl2.NORTH, options )
sl2.putConstraint( sl2.WEST, pr, 10, sl2.EAST, ws )
sl2.putConstraint( sl2.SOUTH, options, 5, sl2.SOUTH, pr )
sl2.putConstraint( sl2.EAST, options, 5, sl2.EAST, pr )

lower = swing.JPanel()
outer.add( lower )
sl.putConstraint( sl.NORTH, lower, 5, sl.SOUTH, options )
sl.putConstraint( sl.EAST, lower, 0, sl.EAST, options )

sl.putConstraint( sl.SOUTH, outer, 5, sl.SOUTH, lower )
sl.putConstraint( sl.EAST, outer, 5, sl.EAST, row1 )
</t>
<t tx="ekr.20071102163001.474">for row,text,text2,command,var in (
    (row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
    (row1,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
    (row1,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

    #lab = Tk.Label(row,anchor="e",text=text,width=13)
    #lab.pack(side="left",padx=4)
    lab = swing.JLabel( text )
    row.add( lab )

    #e = Tk.Entry(row)
    #e.pack(side="left",padx=2)
    e = swing.JTextField( 15 )
    row.add( e )
    self.browseEntries.append(e)

    #b = Tk.Button(row,text="browse...",command=command)
    #b.pack(side="left",padx=6)
    b = swing.JButton( "browse..." )
    b.actionPerformed = lambda event, command = command: command()
    row.add( b )

    #b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
    #b.pack(side="left")
    b = swing.JCheckBox( text2 )
    b.actionPerformed = lambda event, b=b, var=var: var.set( b.getModel().isSelected() )
    row.add( b )</t>
<t tx="ekr.20071102163001.475">#b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
#    text="Limit directory compares to type:")
#b.pack(side="left",padx=4)
b = swing.JCheckBox( "Limit directory compares to type:" )
b.actionPerformed = lambda event, b=b, var=self.limitToExtensionVar: var.set( b.getModel().isSelected() )
row4.add( b )


#self.extensionEntry = e = Tk.Entry(row4,width=6)
#e.pack(side="left",padx=2)
self.extensionEntry = e = swing.JTextField(5)
row4.add( e )

#b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
#    text="Append output to output file")
#b.pack(side="left",padx=4)

b = swing.JCheckBox( "Append output to outputfile" )
b.actionPerformed = lambda event, b = b, var = self.appendOutputVar: var.set( b.getModel().isSelected() )
row4.add( b )
</t>
<t tx="ekr.20071102163001.476">w,f = gui.create_labeled_frame(ws,caption="Whitespace options",relief="groove")


f.setLayout( awt.GridLayout( 5, 1 ) )

for text,var in (
    ("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
    ("Ignore blank lines",        self.ignoreBlankLinesVar),
    ("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
    ("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
    ("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):

    #b = Tk.Checkbutton(f,text=text,variable=var)
    #b.pack(side="top",anchor="w")
    b = swing.JCheckBox( text )
    b.actionPerformed = lambda event, b=b, var=var: var.set( b.getModel().isSelected() )
    f.add( b )


</t>
<t tx="ekr.20071102163001.477">w,f = gui.create_labeled_frame(pr,caption="Print options",relief="groove")
f.setLayout( awt.GridLayout( 5, 1 ) )

#row = Tk.Frame(f)
#row.pack(expand=1,fill="x")
row = swing.JPanel()
sl3 = swing.SpringLayout()
row.setLayout( sl3 )
f.add( row )
pwidth = 0


#b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
#b.pack(side="left",anchor="w")
b = swing.JCheckBox( "Stop after" )
b.actionPerformed = lambda event, var = self.stopAfterMismatchVar, b = b: var.set( b.getModel().isSelected() )
row.add( b )
sl3.putConstraint( sl3.NORTH, b, 1, sl3.NORTH, row )
sl3.putConstraint( sl3.WEST, b, 1, sl3.WEST, row )

#self.countEntry = e = Tk.Entry(row,width=4)
#e.pack(side="left",padx=2)
#e.insert(01,"1")
self.countEntry = e = swing.JTextField(5)
row.add( e )
sl3.putConstraint( sl3.NORTH, e, 1, sl3.NORTH, row )
sl3.putConstraint( sl3.WEST, e, 1, sl3.EAST, b )

#lab = Tk.Label(row,text="mismatches")
#lab.pack(side="left",padx=2)
lab = swing.JLabel( "mismatches" )
row.add( lab )
sl3.putConstraint( sl3.NORTH, lab, 1, sl3.NORTH, row )
sl3.putConstraint( sl3.WEST, lab, 1, sl3.EAST, e )
sl3.putConstraint( sl3.SOUTH, row, 1, sl3.SOUTH, e )
sl3.putConstraint( sl3.EAST, row, 1, sl3.EAST, lab )




for padx,text,var in (    
    (0,  "Print matched lines",           self.printMatchesVar),
    (20, "Show both matching lines",      self.printBothMatchesVar),
    (0,  "Print mismatched lines",        self.printMismatchesVar),
    (0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):

    #b = Tk.Checkbutton(f,text=text,variable=var)
    #b.pack(side="top",anchor="w",padx=padx)
    b = swing.JCheckBox( text )
    b.actionPerformed = lambda event, b=b, var=var: var.set( b.getModel().isSelected() )
    f.add( b )
    self.printButtons.append(b)



# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
#b.configure(command=self.onPrintMatchedLines)

#spacer = Tk.Frame(f)
#spacer.pack(padx="1i")</t>
<t tx="ekr.20071102163001.478">for text,command in (
    ("Compare files",      self.onCompareFiles),
    ("Compare directories",self.onCompareDirectories) ):

    #b = Tk.Button(lower,text=text,command=command,width=18)
    #b.pack(side="left",padx=6)
    b = swing.JButton( text )
    b.actionPerformed = lambda event, command=command: command()
    lower.add( b )

</t>
<t tx="ekr.20071102163001.479">def setIvarsFromWidgets (self):

    # File paths: checks for valid file name.
    e = self.browseEntries[0]
    self.fileName1 = e.getText()

    e = self.browseEntries[1]
    self.fileName2 = e.getText()

    # Ignore first line settings.
    self.ignoreFirstLine1 = self.ignoreFirstLine1Var.get()
    self.ignoreFirstLine2 = self.ignoreFirstLine2Var.get()

    # Output file: checks for valid file name.
    if self.useOutputFileVar.get():
        e = self.browseEntries[2]
        name = e.getText()
        if name != None and len(name) == 0:
            name = None
        self.outputFileName = name
    else:
        #self._dtm.setRowCount( 0 )
        self.outputFileName = None

    # Extension settings.
    if self.limitToExtensionVar.get():
        self.limitToExtension = self.extensionEntry.getText()
        if len(self.limitToExtension) == 0:
            self.limitToExtension = None
    else:
        self.limitToExtension = None

    self.appendOutput = self.appendOutputVar.get()

    # Whitespace options.
    self.ignoreBlankLines         = self.ignoreBlankLinesVar.get()
    self.ignoreInteriorWhitespace = self.ignoreInteriorWhitespaceVar.get()
    self.ignoreLeadingWhitespace  = self.ignoreLeadingWhitespaceVar.get()
    self.ignoreSentinelLines      = self.ignoreSentinelLinesVar.get()
    self.makeWhitespaceVisible    = self.makeWhitespaceVisibleVar.get()

    # Print options.
    self.printMatches            = self.printMatchesVar.get()
    self.printMismatches         = self.printMismatchesVar.get()
    self.printTrailingMismatches = self.printTrailingMismatchesVar.get()

    if self.printMatches:
        self.printBothMatches = self.printBothMatchesVar.get()
    else:
        self.printBothMatches = False

    if self.stopAfterMismatchVar.get():
        try:
            count = self.countEntry.get()
            self.limitCount = int(count)
        except: self.limitCount = 0
    else:
        self.limitCount = 0</t>
<t tx="ekr.20071102163001.480">def bringToFront(self):

    #self.top.deiconify()
    #self.top.lift()
    self.top.visible = 1
    self.top.toFront()

</t>
<t tx="ekr.20071102163001.481">def browser (self,n):

    types = [
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py"),
        ("Text files","*.txt"),
        ("All files","*") ]


    import java.io as io
    f = io.File( "tmp" )
    parent = f.getParentFile()
    f = None

    fc = swing.JFileChooser( parent )
    fc.setDialogTitle( "Choose compare file" + n )


    haveseen = {}
    for z in types:
        if z[ 0 ] in haveseen:
            haveseen[ z[ 0 ] ].extend( z[1] )
        else:
            bf = self.brwsfilter( z )
            fc.addChoosableFileFilter( bf )
            haveseen[ z[ 0 ] ] = bf

    result = fc.showOpenDialog( self.top )
    if result == fc.APPROVE_OPTION:
        fileName = fc.getSelectedFile().getAbsolutePath()
    else:
        fileName = None

    #fileName = tkFileDialog.askopenfilename(
    #    title="Choose compare file" + n,
    #    filetypes=types,
    #    defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        # The dialog also warns about this, so this may never happen.
        if not g.os_path_exists(fileName):
            self.show("not found: " + fileName)
            fileName = None
    else: fileName = None

    return fileName</t>
<t tx="ekr.20071102163001.482"># We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):

    # Ignore everything except the directory name.
    dir1 = g.os_path_dirname(path1)
    dir2 = g.os_path_dirname(path2)
    dir1 = g.os_path_normpath(dir1)
    dir2 = g.os_path_normpath(dir2)

    if dir1 == dir2:
        self.show("Directory names are identical.\nPlease pick distinct directories.")
        return

    try:
        list1 = os.listdir(dir1)
    except:
        self.show("invalid directory:" + dir1)
        return
    try:
        list2 = os.listdir(dir2)
    except:
        self.show("invalid directory:" + dir2)
        return

    if self.outputFileName:
        self.openOutputFile()
    ok = self.outputFileName == None or self.outputFile
    if not ok:
        return

    # Create files and files2, the lists of files to be compared.
    files1 = []
    files2 = []
    for f in list1:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files1.append(f)
        else:
            files1.append(f)
    for f in list2:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files2.append(f)
        else:
            files2.append(f)

    # Compare the files and set the yes, no and fail lists.
    yes = [] ; no = [] ; fail = []
    for f1 in files1:
        head,f2 = g.os_path_split(f1)
        if f2 in files2:
            try:
                name1 = g.os_path_join(dir1,f1)
                name2 = g.os_path_join(dir2,f2)
                _file1 = java.io.File( name1 )
                _file2 = java.io.File( name2 )
                if _file1.length() == _file2.length():
                    val = self._filecmp( name1, name2 )                    
                else:
                    val = False
                #val = filecmp.cmp(name1,name2,0)
                if val: yes.append(f1)
                else:    no.append(f1)
            except:
                self.show("exception in filecmp.cmp")
                g.es_exception()
                fail.append(f1)
        else:
            fail.append(f1)

    # Print the results.
    for kind, files in (
        ("----- matches --------",yes),
        ("----- mismatches -----",no),
        ("----- not found ------",fail)):
        self.show(kind)
        for f in files:
            self.show(f)

    if self.outputFile:
        self.outputFile.close()
        self.outputFile = None</t>
<t tx="ekr.20071102163001.483">def filecmp (self,f1,f2):

    #val = filecmp.cmp(f1,f2)
    val = self._filecmp( f1, f2 )
    if 1:
        if val: self.show("equal")
        else:   self.show("*** not equal")
    else:
        self.show("filecmp.cmp returns:")
        if val: self.show(str(val)+ " (equal)")
        else:   self.show(str(val) + " (not equal)")
    return val


def _filecmp( self, f1, f2 ):

    _file1 = java.io.File( f1 )
    _file2 = java.io.File( f2 )
    _fc1 = java.io.FileInputStream( _file1 ).getChannel()
    _fc2 = java.io.FileInputStream( _file2 ).getChannel()
    _bb1 = java.nio.ByteBuffer.allocateDirect( _fi1e1.length() )
    _bb2 = java.nio.ByteBuffer.allocateDirect( _file2.length() )
    _fc1.read( _bb1 )
    _fc2.read( _bb2 )
    _fc1.close(); _fc2.close()
    _bb1.position( 0 ); _bb2.position( 0 )
    c_result = _bb1.compareTo( _bb2 )
    if c_result == 0:
        val = True
    else:
        val = False

    return val</t>
<t tx="ekr.20071102163001.484">import javax.swing.filechooser as ff
class brwsfilter( ff.FileFilter ):

    def __init__( self, items ):
        self.items = items
        self.filters = []
        self.extend( items[ 1 ] )

    def accept( self, fvar ):
        name = fvar.getName()
        for ending in self.filters:
            if name.endswith( ending ): return True

        return False

    def extend( self, item ):
        self.filters.append( item.strip( '*' ) )

    def getDescription( self ):
        return self.items[ 0 ]</t>
<t tx="ekr.20071102163001.485"></t>
<t tx="ekr.20071102163001.486">def onBrowse1 (self):

    fileName = self.browser("1")
    if fileName:
        e = self.browseEntries[0]
        e.setText( fileName )
        #e.delete(0,"end")
        #e.insert(0,fileName)
    #self.top.deiconify()

def onBrowse2 (self):

    fileName = self.browser("2")
    if fileName:
        e = self.browseEntries[1]
        e.setText( fileName )
        #e.delete(0,"end")
        #e.insert(0,fileName)
    #self.top.deiconify()

def onBrowse3 (self): # Get the name of the output file.

    #fileName = tkFileDialog.asksaveasfilename(
    #    initialfile = self.defaultOutputFileName,
    #    title="Set output file",
    #    filetypes=[("Text files", "*.txt")],
    #    defaultextension=".txt")
    import java.io as io
    f = io.File( "tmp" )
    parent = f.getParentFile()
    f = None

    fc = swing.JFileChooser( parent )
    result = fc.showSaveDialog( self.top )
    if result == fc.APPROVE_OPTION:
        fileName = fc.getSelectedFile().getAbsolutePath()
    else:
        fileName = None


    if fileName and len(fileName) &gt; 0:
        self.defaultOutputFileName = fileName
        self.useOutputFileVar.set(1) # The user will expect this.
        e = self.browseEntries[2]
        e.setText( fileName )
        #e.delete(0,"end")
        #e.insert(0,fileName)</t>
<t tx="ekr.20071102163001.487">def onClose (self):

    self.top.withdraw()</t>
<t tx="ekr.20071102163001.488">def onCompareDirectories (self):

    self.setIvarsFromWidgets()
    self._dtm.setRowCount( 0 )
    self.compare_directories(self.fileName1,self.fileName2)
    if self._dtm.getRowCount() &gt; 0:
        self.showMismatchTable()

def onCompareFiles (self):

    self.setIvarsFromWidgets()
    self._dtm.setRowCount( 0 )
    self.compare_files(self.fileName1,self.fileName2)
    if self._dtm.getRowCount() &gt; 0:
        self.showMismatchTable()</t>
<t tx="ekr.20071102163001.489">def onPrintMatchedLines (self):

    v = self.printMatchesVar.get()
    b = self.printButtons[1]
    state = g.choose(v,"normal","disabled")
    b.configure(state=state)</t>
<t tx="ekr.20071102163001.490"></t>
<t tx="ekr.20071102163001.491">def show (self,s):

    # print s
    if self.outputFile:
        self.outputFile.write(s + '\n')
    elif self.c:
        #g.es(s)
        self._dtm.addRow( [ self._dtm.getRowCount() + 1 ,s ] )
    else:
        print s
        print</t>
<t tx="ekr.20071102163001.492">def showMismatchTable( self ):

    jf = swing.JFrame()

    jf.setDefaultCloseOperation( jf.DISPOSE_ON_CLOSE )
    cp = jf.getContentPane()
    cp.setLayout( awt.BorderLayout() )
    jt = swing.JTable( self._dtm )
    jt.setAutoResizeMode( jt.AUTO_RESIZE_ALL_COLUMNS )
    drend = self._dftcr()
    jt.setDefaultRenderer( java.lang.Object, drend )
    count = self._dtm.getRowCount()
    tmp_label = swing.JLabel( java.lang.String.valueOf( count ) )
    psize = tmp_label.getPreferredSize()
    column = jt.getColumn( "" )
    column.setPreferredWidth( psize.width + 10 )
    column.setMaxWidth( psize.width + 10 )
    sp = swing.JScrollPane( jt )
    sp.addComponentListener( drend )
    cp.add( sp, awt.BorderLayout.CENTER )
    jb = swing.JButton( "Close" )
    jb.actionPerformed = lambda event: jf.dispose()
    cp.add( jb, awt.BorderLayout.SOUTH )
    jf.pack()
    g.app.gui.center_dialog( jf )
    jf.visible = 1

class _dftcr( stable.DefaultTableCellRenderer, aevent.ComponentListener ):

    def __init__( self ):
        stable.DefaultTableCellRenderer.__init__( self )
        self._component = swing.JTextArea()
        self._component.setLineWrap( True )
        self._label = swing.JTextField()
        self._label.setMargin( awt.Insets( 0, 0, 0, 0 ) )


    def getTableCellRendererComponent( self, table, value,isSelected, hasFocus, row, column):

        if column == 1:
            vrect = table.getVisibleRect()
            self._component.setText( value )
            size = self._component.getSize()
            size.width = vrect.width
            self._component.setSize( size )
            if isSelected:
                self._component.setForeground( table.getSelectionForeground() )
                self._component.setBackground( table.getSelectionBackground() )
            else:
                self._component.setForeground( table.getForeground()) 
                self._component.setBackground( table.getBackground() )

            table.setRowHeight( row, self._component.getPreferredSize().height )
            return self._component
        else:

            row = java.lang.String.valueOf( row + 1 )
            self._label.setText( row )
            if isSelected:
                self._label.setForeground( table.getSelectionForeground() )
                self._label.setBackground( table.getSelectionBackground() )
            else:
                self._label.setForeground( table.getForeground()) 
                self._label.setBackground( table.getBackground() ) 
            return self._label

    def componentHidden( self, event ):
        pass

    def componentMoved( self, event ):
        pass

    def componentResized( self, event ):

        pass
        #source = event.getSource()
        #vrect = source.getVisibleRect()
        #model = source.getModel()
        #csize = self._component.getSize()
        #csize.width = vrect.width
        #print self._component.getPreferredSize()
        #print self._component.getSize()
        #for z in xrange( model.getRowCount() ):
        #    value = model.getValueAt( z, 0 )
        #    self._component.setText( value )
        #    print self._component.getPreferredSize()
        #    print self._component.getSize()
        #    source.setRowHeight( z, self._component.getPreferredSize().height )




    def componentShown( self, event ):

        event.getSource().repaint()</t>
<t tx="ekr.20071102163001.493"># Subclassing from wx.EvtHandler allows methods of this and derived class to be event handlers.

class baseTextWidget:

    '''The base class for all wrapper classes for leo Text widgets.'''

    @others
</t>
<t tx="ekr.20071102163001.494">def __init__ (self,c,baseClassName,name,widget):

    self.baseClassName = baseClassName
    self.c = c
    self.name = name
    self.virtualInsertPoint = None
    self.widget = widget # Not used at present.

def __repr__(self):
    return '%s: %s' % (self.baseClassName,id(self))

</t>
<t tx="ekr.20071102163001.495"># Don't even think of using key up/down events.
# They don't work reliably and don't support auto-repeat.

def onChar (self, event):

    c = self.c
    keycode = event.GetKeyCode()
    event.leoWidget = self
    keysym = g.app.gui.eventKeysym(event)
    #g.trace('text: keycode %3s keysym %s' % (keycode,keysym))
    if keysym:
        c.k.masterKeyHandler(event,stroke=keysym)</t>
<t tx="ekr.20071102163001.496">def update (self,*args,**keys):             pass
def update_idletasks (self,*args,**keys):   pass
</t>
<t tx="ekr.20071102163001.497"># def _appendText(self,s):            self.oops()
# def _get(self,i,j):                 self.oops()
# def _getAllText(self):              self.oops()
# def _getFocus(self):                self.oops()
# def _getInsertPoint(self):          self.oops()
# def _getLastPosition(self):         self.oops()
# def _getSelectedText(self):         self.oops()
# def _getSelectionRange(self):       self.oops()
# def _hitTest(self,pos):             self.oops()
# def _insertText(self,i,s):          self.oops()
# def _scrollLines(self,n):           self.oops()
# def _see(self,i):                   self.oops()
# def _setAllText(self,s):            self.oops()
# def _setBackgroundColor(self,color): self.oops()
# def _setFocus(self):                self.oops()
# def _setInsertPoint(self,i):        self.oops()
# def _setSelectionRange(self,i,j):   self.oops()

# _findFocus = _getFocus
</t>
<t tx="ekr.20071102163001.498">def oops (self):

    print('wxGui baseTextWidget oops:',self,g.callers(),
        'must be overridden in subclass')
</t>
<t tx="ekr.20071102163001.499"></t>
<t tx="ekr.20071102163001.500">def toPythonIndex (self,index):

    w = self

    if type(index) == type(99):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return w._getLastPosition()
    else:
        # g.trace(repr(index))
        s = w._getAllText()
        row,col = index.split('.')
        row,col = int(row),int(col)
        i = g.convertRowColToPythonIndex(s,row-1,col)
        # g.trace(index,row,col,i,g.callers(6))
        return i

toGuiIndex = toPythonIndex</t>
<t tx="ekr.20071102163001.501"># This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):

    return g.convertRowColToPythonIndex(s,row,col)    
</t>
<t tx="ekr.20071102163001.502"># These methods are widget-independent because they call the corresponding _xxx methods.</t>
<t tx="ekr.20071102163001.503">def appendText (self,s):

    w = self
    w._appendText(s)
</t>
<t tx="ekr.20071102163001.504">def bind (self,kind,*args,**keys):

    w = self

    pass # g.trace('wxLeoText',kind,args[0].__name__)</t>
<t tx="ekr.20071102163001.505">def clipboard_clear (self):

    g.app.gui.replaceClipboardWith('')

def clipboard_append(self,s):

    s1 = g.app.gui.getTextFromClipboard()

    g.app.gui.replaceClipboardWith(s1 + s)
</t>
<t tx="ekr.20071102163001.506">def delete(self,i,j=None):

    w = self
    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    # g.trace(i,j,len(s),repr(s[:20]))
    s = w.getAllText()
    w.setAllText(s[:i] + s[j:])
</t>
<t tx="ekr.20071102163001.507">def deleteTextSelection (self):

    w = self
    i,j = w._getSelectionRange()
    if i == j: return

    s = w._getAllText()
    s = s[i:] + s[j:]

    # g.trace(len(s),repr(s[:20]))
    w._setAllText(s)
</t>
<t tx="ekr.20071102163001.508">def event_generate(self,stroke):

    w = self ; c = self.c ; char = stroke

    # Canonicalize the setting.
    stroke = c.k.shortcutFromSetting(stroke)

    # g.trace('baseTextWidget','char',char,'stroke',stroke)

    class eventGenerateEvent:
        def __init__ (self,c,w,char,keysym):
            self.c = c
            self.char = char
            self.keysym = keysym
            self.leoWidget = w
            self.widget = w

    event = eventGenerateEvent(c,w,char,stroke)
    c.k.masterKeyHandler(event,stroke=stroke)
</t>
<t tx="ekr.20071102163001.509">def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75): # tkTextWidget.

    w = self

    return ###

    def addFlashCallback(w,count,index):
        # g.trace(count,index)
        i,j = w.toPythonIndex(index),w.toPythonIndex(index+1)
        Tk.Text.tag_add(w,'flash',i,j)
        Tk.Text.after(w,delay,removeFlashCallback,w,count-1,index)

    def removeFlashCallback(w,count,index):
        # g.trace(count,index)
        Tk.Text.tag_remove(w,'flash','1.0','end')
        if count &gt; 0:
            Tk.Text.after(w,delay,addFlashCallback,w,count,index)

    try:
        Tk.Text.tag_configure(w,'flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass ; g.es_exception()</t>
<t tx="ekr.20071102163001.510">def getFocus (self):

    w = self
    w2 = w._getFocus()
    # g.trace('w',w,'focus',w2)
    return w2

findFocus = getFocus
</t>
<t tx="ekr.20071102163001.511">def get(self,i,j=None):

    w = self

    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    s = w._get(i,j)
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20071102163001.512">def getAllText (self):

    w = self

    s = w._getAllText()
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20071102163001.513">def getInsertPoint(self):

    w = self
    i = w._getInsertPoint()

    # g.trace(self,'baseWidget: i:',i,'virtual',w.virtualInsertPoint)

    if i is None:
        if w.virtualInsertPoint is None:
            i = 0
        else:
            i = w.virtualInsertPoint

    w.virtualInsertPoint = i

    return i
</t>
<t tx="ekr.20071102163001.514">def GetName(self):
    return self.name

getName = GetName</t>
<t tx="ekr.20071102163001.515">def getSelectedText (self):

    w = self
    s = w._getSelectedText()
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20071102163001.516">def getSelectionRange (self,sort=True):

    """Return a tuple representing the selected range of the widget.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self

    sel = w._getSelectionRange() # wx.richtext.RichTextCtrl returns (-1,-1) on no selection.
    if len(sel) == 2 and sel[0] &gt;= 0 and sel[1] &gt;= 0:
        #g.trace(self,'baseWidget: sel',repr(sel),g.callers(6))
        i,j = sel
        if sort and i &gt; j: sel = j,i # Bug fix: 10/5/07
        return sel
    else:
        # Return the insertion point if there is no selected text.
        i =  w._getInsertPoint()
        #g.trace(self,'baseWidget: i',i,g.callers(6))
        return i,i
</t>
<t tx="ekr.20071102163001.517">def getYScrollPosition (self):

     w = self
     return w._getYScrollPosition()
</t>
<t tx="ekr.20071102163001.518">def getWidth (self):

    '''Return the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    return 0
</t>
<t tx="ekr.20071102163001.519">def hasSelection (self):

    w = self
    i,j = w.getSelectionRange()
    return i != j
</t>
<t tx="ekr.20071102163001.520"># The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toPythonIndex(i)
    # w._setInsertPoint(i)
    w._insertText(i,s)
</t>
<t tx="ekr.20071102163001.521">def indexIsVisible (self,i):

    return False # Code will loop if this returns True forever.</t>
<t tx="ekr.20071102163001.522">def replace (self,i,j,s):

    w = self
    w.delete(i,j)
    w.insert(i,s)
</t>
<t tx="ekr.20071102163001.523">def scrollLines (self,n):

    w = self
    w._scrollLines(n)</t>
<t tx="ekr.20071102163001.524">def see(self,index):

    w = self
    i = self.toPythonIndex(index)
    w._see(i)

def seeInsertPoint(self):

    w = self
    i = w._getInsertPoint()
    w._see(i)
</t>
<t tx="ekr.20071102163001.525">def selectAllText (self,insert=None):

    '''Select all text of the widget.'''

    w = self
    w.setSelectionRange(0,'end',insert=insert)
</t>
<t tx="ekr.20071102163001.526">def setAllText (self,s):

    w = self
    w._setAllText(s)</t>
<t tx="ekr.20071102163001.527">def setBackgroundColor (self,color):

    w = self

    # Translate tk colors to wx colors.
    d = { 'lightgrey': 'light grey', 'lightblue': 'leo blue',}

    color = d.get(color,color)

    return w._setBackgroundColor(color)

SetBackgroundColour = setBackgroundColor</t>
<t tx="ekr.20071102163001.528">def setFocus (self):

    w = self
    # g.trace('baseText')
    return w._setFocus()

SetFocus = setFocus
</t>
<t tx="ekr.20071102163001.529">def setInsertPoint (self,pos):

    w = self
    w.virtualInsertPoint = i = w.toPythonIndex(pos)
    # g.trace(self,i)
    w._setInsertPoint(i)
</t>
<t tx="ekr.20071102163001.530">def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    # g.trace(self,'baseWidget',repr(i1),'=',repr(i),repr(j1),'=',repr(j),repr(insert1),'=',repr(insert),g.callers(4))

    if i == j:
        w._setInsertPoint(j)
    else:
        w._setSelectionRange(i,j)

    if insert is not None and insert in (i,j):
        ins = w.toPythonIndex(insert)
        if ins in (i,j):
            self.virtualInsertPoint = ins
</t>
<t tx="ekr.20071102163001.531">def setWidth (self,width):

    '''Set the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    pass
</t>
<t tx="ekr.20071102163001.532">def setYScrollPosition (self,i):

     w = self
     w._setYScrollPosition(i)</t>
<t tx="ekr.20071102163001.533"></t>
<t tx="ekr.20071102163001.534">def mark_set(self,markName,i):

    w = self
    i = self.toPythonIndex(i)

    ### Tk.Text.mark_set(w,markName,i)
</t>
<t tx="ekr.20071102163001.535"># The signature is slightly different than the Tk.Text.insert method.

def tag_add(self,tagName,i,j=None,*args):

    w = self
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)

    return ###

    if not hasattr(w,'leo_styles'):
        w.leo_styles = {}

    style = w.leo_styles.get(tagName)

    if style is not None:
        # g.trace(i,j,tagName)
        w.textBaseClass.SetStyle(w,i,j,style)</t>
<t tx="ekr.20071102163001.536">def tag_configure (self,colorName,**keys):
    pass

tag_config = tag_configure</t>
<t tx="ekr.20071102163001.537">def tkColorToWxColor (self, color):

    d = {
        'black':        wx.BLACK,
        "red":          wx.RED,
        "blue":         wx.BLUE,
        "#00aa00":      wx.GREEN,
        "firebrick3":   wx.RED,
        'white':        wx.WHITE,
    }

    return d.get(color)</t>
<t tx="ekr.20071102163001.538">def tag_delete (self,tagName,*args,**keys):

    pass # g.trace(tagName,args,keys)</t>
<t tx="ekr.20071102163001.539">def tag_names (self, *args):

    return []
</t>
<t tx="ekr.20071102163001.540">def tag_ranges(self,tagName):

    return tuple() ###

    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
</t>
<t tx="ekr.20071102163001.541">def tag_remove(self,tagName,i,j=None,*args):

    w = self
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)

    return ### Not ready yet.

    if not hasattr(w,'leo_styles'):
        w.leo_styles = {}

    style = w.leo_styles.get(tagName)

    if style is not None:
        # g.trace(i,j,tagName)
        w.textBaseClass.SetStyle(w,i,j,style)</t>
<t tx="ekr.20071102163001.542">def yview (self,*args):

    '''w.yview('moveto',y) or w.yview()'''

    return 0,0</t>
<t tx="ekr.20071102163001.543">def xyToPythonIndex (self,x,y):
    return 0
</t>
<t tx="ekr.20071102163001.544"></t>
<t tx="ekr.20071102163001.545">@nocolor

- The following modules do not exist in Jython.  The imports must be protected in try/except blocks:

    filecmp
    gettext
    tabnanny

- Python does not support generators.  Several seldom-used iterators will be written to avoid the 'yield' statement.

- Added the jyLeo keyword argument to the run function in leo.py.

- g.cantImport now does not warn when the gui is not tkinter and the moduleName is either tkinter or Pmw.
  This suppresses unnecessary import warnings from several plugins.

- Hacked the navButtons plugin to suppress a weird call to onCreate when the gui is swing.  It is a mystery why this is being called.

- changed toUnicodeFileEncoding to test for 'java' platform.</t>
<t tx="ekr.20071102163001.546"># They are not valid in jython.
# At present, Leo's core does not use them.</t>
<t tx="ekr.20071102163001.547"></t>
<t tx="ekr.20071102163001.548">class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):

    c = self
    return self.allNodes_iter_class(c,copy)

all_positions_iter = allNodes_iter</t>
<t tx="ekr.20071102163001.549">def __init__(self,c,copy):

    # g.trace('c.allNodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None
    self.copy = copy

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.550">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p

    else: raise StopIteration
</t>
<t tx="ekr.20071102163001.551"># def all_tnodes_iter(self):

    # c = self
    # for p in c.all_positions_iter():
        # yield p.v.t

    # # return c.rootPosition().all_tnodes_iter(all=True)

class all_tnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_tnodes_iter (self):

    c = self
    return self.all_tnodes_iter_class(c)
</t>
<t tx="ekr.20071102163001.552">def __init__(self,c):

    # g.trace('c.all_tnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.553">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v.t

    else: raise StopIteration
</t>
<t tx="ekr.20071102163001.554"># def all_unique_tnodes_iter(self):

    # c = self ; marks = {}

    # for p in c.all_positions_iter():
        # if not p.v.t in marks:
            # marks[p.v.t] = p.v.t
            # yield p.v.t

class all_unique_tnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_unique_tnodes_iter (self):

    c = self
    return self.all_unique_tnodes_iter_class(c)
</t>
<t tx="ekr.20071102163001.555">def __init__(self,c):

    # g.trace('c.all_uniquetnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.d = {}
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.556">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v.t):
            self.d [self.p.v.t] = True
            return self.p.v.t

    else: raise StopIteration
</t>
<t tx="ekr.20071102163001.557"># def all_vnodes_iter(self):

    # c = self
    # for p in c.all_positions_iter():
        # yield p.v

class all_vnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_vnodes_iter (self):

    c = self
    return self.all_vnodes_iter_class(c)
</t>
<t tx="ekr.20071102163001.558">def __init__(self,c):

    # g.trace('c.all_tnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.559">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v

    else: raise StopIteration
</t>
<t tx="ekr.20071102163001.560"># def all_unique_vnodes_iter(self):

    # c = self ; marks = {}
    # for p in c.all_positions_iter():
        # if not p.v in marks:
            # marks[p.v] = p.v
            # yield p.v

class all_unique_vnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_unique_vnodes_iter (self):

    c = self
    return self.all_unique_vnodes_iter_class(c)
</t>
<t tx="ekr.20071102163001.561">def __init__(self,c):

    # g.trace('c.all_uniquetnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.d = {}
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.562">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v.t):
            self.d [self.p.v.t] = True
            return self.p.v

    else: raise StopIteration
</t>
<t tx="ekr.20071102163001.563">if g.unitTesting:
    &lt;&lt; coverage tests &gt;&gt;
    &lt;&lt; duplicate tests &gt;&gt;

    if 0:
        print "vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()])
        print "tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()])

    if 0: # all nodes
        for v in c.all_vnodes_iter(): print v
        for t in c.all_tnodes_iter(): print t

    if 0: # unique nodes
        for v in c.all_unique_vnodes_iter(): print v
        for t in c.all_unique_tnodes_iter(): print t
</t>
<t tx="ekr.20071102163001.564">v1 = [p.v for p in c.all_positions_iter()]
v2 = [v for v in c.all_vnodes_iter()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

t1 = [p.v.t for p in c.all_positions_iter()]
t2 = [t for t in c.all_tnodes_iter()]
for t in t2: assert(t in t1)
for t in t1: assert(t in t2)

# print "coverage tests pass"</t>
<t tx="ekr.20071102163001.565">nodes = []
for v in c.all_unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)

nodes = []
for t in c.all_unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)

# print "duplicate tests pass"</t>
<t tx="ekr.20071102163001.566">@ A crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
</t>
<t tx="ekr.20071102163001.567"># def tnodes_iter(self):

    # """Return all tnode's in a positions subtree."""

    # p = self
    # for p in p.self_and_subtree_iter():
        # yield p.v.t

class tnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def tnodes_iter (self):

    p = self
    return self.tnodes_iter_class(p)
</t>
<t tx="ekr.20071102163001.568">def __init__(self,p):

    # g.trace('p.tnodes_iter.__init','p',p)

    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.569">def next(self):

    if self.first:
        self.p = self.first
        self.first = None
    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v.t

    else: raise StopIteration
</t>
<t tx="ekr.20071102163001.570"># def unique_tnodes_iter(self):

    # """Return all unique tnode's in a positions subtree."""

    # p = self
    # marks = {}
    # for p in p.self_and_subtree_iter():
        # if p.v.t not in marks:
            # marks[p.v.t] = p.v.t
            # yield p.v.t

class unique_tnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def unique_tnodes_iter (self):

    p = self
    return self.unique_tnodes_iter_class(p)
</t>
<t tx="ekr.20071102163001.571">def __init__(self,p):

    # g.trace('p.unique_tnodes_iter.__init','p',p,)

    self.d = {}
    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.572">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v.t):
            self.d [self.p.v.t] = True
            return self.p.v.t

    else: raise StopIteration
</t>
<t tx="ekr.20071102163001.573"># def vnodes_iter(self):

    # """Return all vnode's in a positions subtree."""

    # p = self
    # for p in p.self_and_subtree_iter():
        # yield p.v

class vnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def vnodes_iter (self):

    p = self
    return self.vnodes_iter_class(p)


</t>
<t tx="ekr.20071102163001.574">def __init__(self,p):

    # g.trace('p.tnodes_iter.__init','p',p)

    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.575">def next(self):

    if self.first:
        self.p = self.first
        self.first = None
    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v

    else: raise StopIteration
</t>
<t tx="ekr.20071102163001.576"># def unique_vnodes_iter(self):

    # """Return all unique vnode's in a positions subtree."""

    # p = self
    # marks = {}
    # for p in p.self_and_subtree_iter():
        # if p.v not in marks:
            # marks[p.v] = p.v
            # yield p.v

class unique_vnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def unique_vnodes_iter (self):

    p = self
    return self.unique_vnodes_iter_class(p)
</t>
<t tx="ekr.20071102163001.577">def __init__(self,p):

    # g.trace('p.unique_tnodes_iter.__init','p',p,)

    self.d = {}
    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.578">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v.t):
            self.d [self.p.v.t] = True
            return self.p.v

    else: raise StopIteration
</t>
<t tx="ekr.20071102163001.579">class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=False)

def self_and_subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=True)
</t>
<t tx="ekr.20071102163001.580">def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.581">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
</t>
<t tx="ekr.20071102163001.582">class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):

    return self.children_iter_class(self,copy)
</t>
<t tx="ekr.20071102163001.583">def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.584">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
</t>
<t tx="ekr.20071102163001.585">class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=False)

def self_and_parents_iter(self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=True)
</t>
<t tx="ekr.20071102163001.586">def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.587">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
</t>
<t tx="ekr.20071102163001.588">class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):

    return self.siblings_iter_class(self,copy,following)

self_and_siblings_iter = siblings_iter

def following_siblings_iter (self,copy=False):

    return self.siblings_iter_class(self,copy,following=True)
</t>
<t tx="ekr.20071102163001.589">def __init__(self,p,copy,following):

    # We always include p, even if following is True.

    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.590">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
</t>
<t tx="ekr.20071102163001.591"></t>
<t tx="ekr.20071102163001.592">class killBuffer_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def iterateKillBuffer (self):

    return self.killBuffer_iter_class(self.c)
</t>
<t tx="ekr.20071102163001.593">def __init__(self,c):

    # g.trace('iterateKillBuffer.__init')
    self.c = c
    self.index = 0 # The index of the next item to be returned.

def __iter__(self):

    return self
</t>
<t tx="ekr.20071102163001.594">def next(self):

    commands = self.c.killBufferCommands
    aList = commands.killBuffer

    # g.trace(g.listToString([repr(z) for z in aList]))

    if not aList:
        self.index = 0
        return None

    if commands.reset is None:
        i = self.index
    else:
        i = commands.reset
        commands.reset = None

    if i &lt; 0 or i &gt;= len(aList): i = 0
    # g.trace(i)
    val = aList[i]
    self.index = i + 1
    return val
</t>
<t tx="ekr.20071102163001.595"># @ This is a generator (it contains a yield).
# To make this work we must define a new generator for each call to regionalExpandAbbrev.
# @c
# def searchXR (i1,i2,ins,event):
    # k = self.k
    # w = self.editWidget(event)
    # if not w: return

    # w.tag_add('sXR',i1,i2)
    # while i1:
        # tr = w.tag_ranges('sXR')
        # if not tr: break
        # i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        # if i1:
            # word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            # w.tag_delete('found')
            # w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            # w.tag_config('found',background='yellow')
            # if self.abbrevs.has_key(word):
                # k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                # yield None
                # if k.regXKey == 'y':
                    # ind = w.index('%s wordstart' % i1)
                    # w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    # w.insert(ind,self.abbrevs[word])
            # i1 = '%s wordend' % i1
    # w.setInsertPoint(ins,ins,insert=ins)
    # w.tag_delete('sXR')
    # w.tag_delete('found')
    # k.setLabelGrey('')
    # self.k.regx = g.bunch(iter=None,key=None)
</t>
<t tx="ekr.20071102163001.596">def toUnicodeFileEncoding(path,encoding):

    if path: path = path.replace('\\', os.sep)

    if not encoding:
        if sys.platform == "win32" or sys.platform.lower().startswith('java'):
            # encoding = "mbcs" # Leo 4.2 and previous.
            encoding = 'utf-8' # New in Leo 4.3
        else:
            encoding = app.tkEncoding

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path,encoding)
</t>
<t tx="ekr.20071102163001.597">import swing.border as sborder</t>
<t tx="ekr.20071102163001.598"></t>
<t tx="ekr.20071102163001.599"></t>
<t tx="ekr.20071102163001.600">def dump(s):

    out = ""
    for i in s:
        out += str(ord(i)) + ","
    return out

def oldDump(s):

    out = ""
    for i in s:
        if i=='\n':
            out += "[" ; out += "n" ; out += "]"
        if i=='\t':
            out += "[" ; out += "t" ; out += "]"
        elif i==' ':
            out += "[" ; out += " " ; out += "]"
        else: out += i
    return out
</t>
<t tx="ekr.20071102163001.601">def es_dump (s,n = 30,title=None):

    if title:
        g.es_print(title)

    i = 0
    while i &lt; len(s):
        g.es_print(''.join(['%2x ' % (ord(ch)) for ch in s[i:i+n]]))
        i += n</t>
<t tx="ekr.20071102163001.602">def es_error (s,color=None):

    if color is None and g.app.config: # May not exist during initialization.
        color = g.app.config.getColor(None,"log_error_color")

    g.es(s,color=color)
</t>
<t tx="ekr.20071102163001.603">def es_event_exception (eventName,full=False):

    g.es("exception handling ", eventName, " event")
    typ,val,tb = sys.exc_info()

    if full:
        errList = traceback.format_exception(typ,val,tb)
    else:
        errList = traceback.format_exception_only(typ,val)

    for i in errList:
        g.es(i)

    if not g.stdErrIsRedirected(): # 2/16/04
        traceback.print_exc()
</t>
<t tx="ekr.20071102163001.604">def es_exception (full=True,c=None,color="red"):

    __pychecker__ = '--no-argsused' # c not used. retained for compatibility.

    typ,val,tb = sys.exc_info()

    # g.trace(full,typ,tb)

    fileName,n = g.getLastTracebackFileAndLineNumber()

    if full or g.app.debugSwitch &gt; 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        if 0: # We might as well print the entire SyntaxError message.
            lines = lines[-1:] # Usually only one line, but more for Syntax errors!

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            try:
                print line
            except Exception:
                print g.toEncodedString(s,'ascii')

    if g.app.debugSwitch &gt; 1:
        import pdb # Be careful: g.pdb may or may not have been defined.
        pdb.set_trace()

    return fileName,n
</t>
<t tx="ekr.20071102163001.605">if g.unitTesting:

    c,p = g.getTestVars() # Optional: prevents pychecker warnings.

    if c.config.redirect_execute_script_output_to_log_pane:
        pass # Test doesn't work when redirection is on.
    else:
        try:
            import sys
            # Catch the output of g.es_exception.
            # We catch the AssertionError, so nothing gets written to stderr.
            sys.stdout = fo = g.fileLikeObject()
            try: # Create an exception to catch.
                assert False, 'Assert False in test_g_es_exception'
            except AssertionError:
                g.es_exception(color='suppress')
                result = fo.get()
                s1 = 'Traceback (most recent call last):'
                s2 = 'AssertionError: Assert False in test_g_es_exception'
                assert result.find(s1) &gt; -1, 'No traceback line: %s' % repr(result)
                assert result.find(s2) &gt; -1, 'No AssertionError line: %s' % repr(result)
        finally:
            # Not needed unless we execute this script as selected text.
            sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20071102163001.606">def es_exception_type (c=None,color="red"):

    # exctype is a Exception class object; value is the error message.
    exctype, value = sys.exc_info()[:2]

    g.es_print('%s, %s' % (exctype.__name__, value),color=color)
</t>
<t tx="ekr.20071102163001.607">def getLastTracebackFileAndLineNumber():

    typ,val,tb = sys.exc_info()

    if typ in (exceptions.SyntaxError,exceptions.IndentationError):
        # Syntax and indentation errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code is similar to the code in format_exception_only(!!)
        try:
            # g.es_print(repr(val))
            msg,(filename, lineno, offset, line) = val
            return filename,lineno
        except:
            g.trace("bad line number")
            return None,0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        if data:
            # g.es_print(repr(data))
            item = data[-1]
            filename = item[0]
            n = item[1]
            return filename,n
        else:
            return None,0
</t>
<t tx="ekr.20071102163001.608">def print_bindings (name,window):

    bindings = window.bind()
    print
    print "Bindings for", name
    for b in bindings:
        print b
</t>
<t tx="ekr.20071102163001.609">def printGlobals(message=None):

    # Get the list of globals.
    globs = list(globals())
    globs.sort()

    # Print the list.
    if message:
        leader = "-" * 10
        print leader, ' ', message, ' ', leader
    for glob in globs:
        print glob
</t>
<t tx="ekr.20071102163001.610">def printEntireTree(c,tag=''):

    print 'printEntireTree','=' * 50
    print 'printEntireTree',tag,'root',c.rootPosition()
    for p in c.allNodes_iter():
        print '..'*p.level(),p.v</t>
<t tx="ekr.20071102163001.611">def printLeoModules(message=None):

    # Create the list.
    mods = []
    for name in sys.modules.keys():
        if name and name[0:3] == "leo":
            mods.append(name)

    # Print the list.
    if message:
        leader = "-" * 10
        print leader, ' ', message, ' ', leader
    mods.sort()
    for m in mods:
        print m,
    print
</t>
<t tx="ekr.20071102163001.612"></t>
<t tx="ekr.20071102163001.613">if jyLeo:

    print '*** starting jyLeo',sys.platform # will be something like java1.6.0_02

    ### This is a hack.
    ### The jyleo script in test.leo sets the cwd to g.app.loadDir
    ### Eventually, we will have to compute the equivalent here.

    path = os.path.join(os.getcwd()) ### ,'..','src')
    if path not in sys.path:
        print 'appending %s to sys.path' % path
        sys.path.append(path)
    if 0:
        print 'sys.path...'
        for s in sys.path: print s

# Import leoGlobals, but do NOT set g.
import leoGlobals
import leoApp

# Create the app.
leoGlobals.app = leoApp.LeoApp()

# **now** we can set g.
g = leoGlobals
assert(g.app)

if jyLeo:
    startJyleo(g)
</t>
<t tx="ekr.20071102163001.614">def startJyleo (g):

    import leoSwingFrame
    import leoSwingUtils
    import java.awt as awt

    if 1:
        g.app.splash = None
    else:
        g.app.splash = splash = leoSwingFrame.leoSplash()
        awt.EventQueue.invokeAndWait(splash)

    gct = leoSwingUtils.GCEveryOneMinute()
    gct.start()

    tk = awt.Toolkit.getDefaultToolkit()
    tk.setDynamicLayout(True)
</t>
<t tx="ekr.20071102163001.615">class leoSplash ( java.lang.Runnable ):

    @others
</t>
<t tx="ekr.20071102163001.616">def run (self):

    g.trace(g.callers())

    self.splash = splash = swing.JWindow()
    splash.setAlwaysOnTop(1)
    cpane = splash.getContentPane()
    rp = splash.getRootPane()
    tb = swing.border.TitledBorder('Leo')
    tb.setTitleJustification(tb.CENTER)
    rp.setBorder(tb)
    splash.setBackground(awt.Color.ORANGE)
    dimension = awt.Dimension(400,400)
    splash.setPreferredSize(dimension)
    splash.setSize(400,400)

    sicon = g.os_path_join(g.app.loadDir,"..","Icons","Leosplash.GIF")
    ii = swing.ImageIcon(sicon)
    image = swing.JLabel(ii)
    image.setBackground(awt.Color.ORANGE)
    cpane.add(image)
    self.splashlabel = splashlabel = swing.JLabel("Leo is starting....")
    splashlabel.setBackground(awt.Color.ORANGE)
    splashlabel.setForeground(awt.Color.BLUE)
    cpane.add(splashlabel,awt.BorderLayout.SOUTH)
    w, h = self._calculateCenteredPosition(splash)
    splash.setLocation(w,h)
    splash.visible = True
</t>
<t tx="ekr.20071102163001.617">def _calculateCenteredPosition( self, widget ):

    size = widget.getPreferredSize()
    height = size.height/2
    width = size.width/2
    h,w = self._getScreenPositionForDialog()
    height = h - height
    width = w - width
    return width, height

def _getScreenPositionForDialog( self ):

    tk = awt.Toolkit.getDefaultToolkit()
    dim = tk.getScreenSize()
    h = dim.height/2
    w = dim.width/2
    return h, w   

def setText( self, text ):  
    self.splashlabel.setText( text )

def hide( self ):
    self.splash.visible = 0

def toBack( self ):
    if self.splash.visible:
        self.splash.toBack()

def toFront( self ):
    if self.splash.visible:
        self.splash.setAlwaysOnTop( 1 )
        self.splash.toFront()

def isVisible( self ):
    return self.splash.visible
</t>
<t tx="ekr.20071105090148"></t>
<t tx="ekr.20071105090148.1">print c.frame.tree.bindingWidget
print c.frame.tree.bindingWidget.bind()</t>
<t tx="ekr.20071105090148.2">import dis

def f():
    return 'foo'
    
print '-' * 10
dis.dis(f)</t>
<t tx="ekr.20071105090148.3">path = g.os_path_abspath('.')
print path</t>
<t tx="ekr.20071105090148.4"></t>
<t tx="ekr.20071105090148.5">bunch = c.undoer.beforeChangeNodeContents(p)
#print 'before',bunch
c.setBodyString(p, "New text")
#print 'p.bodyString()',p.bodyString()
c.undoer.afterChangeNodeContents(p,'xyzzy', bunch)
</t>
<t tx="ekr.20071105090148.6"># root line

    @others

# last root line</t>
<t tx="ekr.20071105090148.7"># node a, only line</t>
<t tx="ekr.20071105090148.8"># This is a test</t>
<t tx="ekr.20071105090148.9"></t>
<t tx="ekr.20071105090148.10">import sys
version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
print g.CheckVersion(version,'2.3')</t>
<t tx="ekr.20071105090148.11">import re

s = '''
abc::
    line1
    line2

after'''

# Paul Paterson
pattern = r'.*(::.*?\n)(\W*?)(?P&lt;indent&gt;\s+)(?P&lt;line1&gt;.*?$\n)((?P=indent)\s*(.*?$\n))*'

# comp.lang.python
pattern = r"(::\s*\n(\s*\n)*((\s+).*?\n)(((\4).*?\n)|(\s*\n))*)"

flags = re.MULTILINE | re.VERBOSE | re.DOTALL
# if nocase: flags |= re.IGNORECASE
re_obj = re.compile(pattern,flags)
mo = re_obj.search(s,0,len(s))
if mo:
    i,j = mo.start(),mo.end()
    print i,j,repr(s[i:j])
else:
    print 'failed'</t>
<t tx="ekr.20071105090148.12"></t>
<t tx="ekr.20071105090148.13">#filename = r'c:\prog\tigris-cvs\leo\test\import-bug.cpp'
filename = r'c:\prog\tigris-cvs\leo\test\longer-test.cpp'
files = [filename]
c.importCommands.importFilesCommand(files=files,treeType='@file',perfectImport=True,testing=False,verbose=False)</t>
<t tx="ekr.20071105090148.14">namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others


namespace arb
{&lt;&lt; namespace arb declarations &gt;&gt;
@others
</t>
<t tx="ekr.20071105090148.15">

class a: public dbm::X
{
public:
a(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.16">}

arb::a::a
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.17">

class b: public dbm::X
{
public:
b(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.18">}

arb::a::b
(
int c
)
{
m_b = c**2;
}
</t>
<t tx="ekr.20071105090148.19">

class c: public dbm::X
{
public:
c(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.20">}

arb::a::c
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.21">

class d: public dbm::X
{
public:
d(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.22">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.23">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.24">}

arb::a::c
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.25">

class d: public dbm::X
{
public:
d(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.26">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.27">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.28">}

arb::a::b
(
int c
)
{
m_b = c**2;
}
</t>
<t tx="ekr.20071105090148.29">

class c: public dbm::X
{
public:
c(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.30">}

arb::a::c
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.31">

class d: public dbm::X
{
public:
d(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.32">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.33">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.34">}

arb::a::c
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.35">

class d: public dbm::X
{
public:
d(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.36">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.37">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.38">}

arb::a::a
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.39">

class b: public dbm::X
{
public:
b(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.40">}

arb::a::b
(
int c
)
{
m_b = c**2;
}
</t>
<t tx="ekr.20071105090148.41">

class c: public dbm::X
{
public:
c(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.42">}

arb::a::c
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.43">

class d: public dbm::X
{
public:
d(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.44">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.45">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.46">}

arb::a::c
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.47">

class d: public dbm::X
{
public:
d(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.48">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.49">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.50">}

arb::a::b
(
int c
)
{
m_b = c**2;
}
</t>
<t tx="ekr.20071105090148.51">

class c: public dbm::X
{
public:
c(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.52">}

arb::a::c
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.53">

class d: public dbm::X
{
public:
d(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.54">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.55">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.56">}

arb::a::c
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.57">

class d: public dbm::X
{
public:
d(int c);
private:
int m_a;
};
</t>
<t tx="ekr.20071105090148.58">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.59">}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20071105090148.60">import subprocess
output = subprocess.Popen(["script.cmd"],
stdout=subprocess.PIPE).communicate()[0]
print output</t>
<t tx="ekr.20071105090148.61">for p in c.allNodes_iter():
    print hash(g.app.nodeIndices.toString(p.v.t.fileIndex))</t>
<t tx="ekr.20071105090148.62">    
    
b
</t>
<t tx="ekr.20071105090148.63">a
    
    b
c

    
</t>
<t tx="ekr.20071105090148.64">    
    a
b
    
    

    </t>
<t tx="ekr.20071105090148.65">print '-'*40

n = 5
for p in c.allNodes_iter():
    n = max(n,len(str(p.archivedPosition())))
    
for p in c.allNodes_iter():
    print '%-*s' % (n,p.archivedPosition()), p.headString()[:40]</t>
<t tx="ekr.20071105090148.66"># unlike as advertised in the documentation, these indices do correspond to Python indices.

import wx
w = c.frame.body.bodyCtrl
s = w.getAllText()
print repr(s)
for i in xrange(len(s)):
    print i,repr(w.textBaseClass.GetRange(w,i,i+1))</t>
<t tx="ekr.20071105090148.67">abc
def

ab</t>
<t tx="ekr.20071105090148.68">@language html

&lt;link rel="stylesheet" type="text/css" href="&lt;&lt;relpath&gt;&gt;files/site.css"&gt; 
</t>
<t tx="ekr.20071105090148.69">/store/</t>
<t tx="ekr.20071105090148.70"></t>
<t tx="ekr.20071105090148.71"></t>
<t tx="ekr.20071105090148.72">print 'a-\u0233-\u798d-z'

print 'a-é-폤-z'

# print u'a-é-폤-z'</t>
<t tx="ekr.20071105090148.73">fileName = r'c:\prog\test\utf-8.txt'

out = g.findNodeAnywhere(c,'out utf-8')
if out:
    u = out.bodyString()
    u8 = g.toEncodedString(u,'utf-8',reportErrors=True)
    g.es_dump(u8,title='wrote utf-8.txt')
    f = file(fileName,'w+b')
    try:
        f.write(u8)
    finally:
        f.close()</t>
<t tx="ekr.20071105090148.74">a-é-폤-z</t>
<t tx="ekr.20071105090148.75">fileName = r'c:\prog\test\utf-8.txt'
f = file(fileName)
s = f.read()
f.close()

in2 = g.findNodeAnywhere(c,'in utf-8')
if in2:
    s = g.toUnicode(s,'utf-8')
    c.setBodyString(in2,s)
    c.selectPosition(in2)
    c.redraw()

g.es_dump(s,title='dump of %s\n' % (fileName))</t>
<t tx="ekr.20071105090148.76">a-é-폤-z</t>
<t tx="ekr.20071105090148.77">fileName = r'c:\prog\test\utf-16.txt'

out = g.findNodeAnywhere(c,'out utf-16')
if out:
    u = out.bodyString()
    u16 = g.toEncodedString(u,'utf-16',reportErrors=True)
    g.es_dump(u16,title='wrote utf-16.txt')
    f = file(fileName,'w+b')
    try:
        f.write(u16)
    finally:
        f.close()</t>
<t tx="ekr.20071105090148.78">a-é-폤-z</t>
<t tx="ekr.20071105090148.79">fileName = r'c:\prog\test\utf-16.txt'
f = file(fileName)
s = f.read()
f.close()

in2 = g.findNodeAnywhere(c,'in utf-16')
if in2:
    s = g.toUnicode(s,'utf-16')
    c.setBodyString(in2,s)
    c.selectPosition(in2)
    c.redraw()

g.es_dump(s,title='dump of %s\n' % (fileName))</t>
<t tx="ekr.20071105090148.80">a-é-폤-z</t>
<t tx="ekr.20071105090148.81">ch = '脖'
ch = unicode(ch,'utf-8')
print '%x' % ord(ch)
print '脖'</t>
<t tx="ekr.20071105090148.82">@ 
80-е годы, ГДР. abc Один немецкий переводчик хвастался, что идеально знает\
русский язык, переведет любую фразу. Ну, ему и предложили перевести на\
немецкий:«Косил Косой косой косой». До сих пор мучается.
@c

import string
print '-'*40
for ch in p.bodyString():
    if ch not in (string.letters+string.punctuation+string.whitespace):
        print repr(ch),g.isWordChar(ch)</t>
<t tx="ekr.20071105090148.83">abc Stéphane xyz</t>
<t tx="ekr.20071105090148.84">@ Did not recognize word boundaries.

80-е годы, ГДР. abc Один немецкий переводчик хвастался, что идеально знает
русский язык, переведет любую фразу. Ну, ему и предложили перевести на
немецкий:«Косил Косой косой косой». До сих пор мучается.
@c

# g.es_print(repr(p.bodyString()))

if 1:

    import unicodedata as u
    
    for ch in (
        u'a',
        u'\u0020',
        u'\u00c4',
        u'\ufeb1',
        u'\u0439',
        u'\u040A',
    ):
        g.es_print(type(ch),ch,'%9s' % (repr(ch)),u.category(ch)) # Don't use print here!
    </t>
<t tx="ekr.20071105090148.85">Ę

This is a test of the mod_http plugin.</t>
<t tx="ekr.20071105090148.86"></t>
<t tx="ekr.20071105090148.87">@first # -*- coding: utf-8 -*-

@language python

# Lasidoré</t>
<t tx="ekr.20071105090148.88">@first # -*- coding: utf-8 -*-

for s in (
    '---',
    u'La Pe\xf1a',
    'La Peña',
    u'La Peña',
):
    # print s
    g.es_print(s)
</t>
<t tx="ekr.20071105090148.89">@first # -*- coding: utf-8 -*-

a = 'ټ'

print 'done'</t>
<t tx="ekr.20071105090148.90"></t>
<t tx="ekr.20071105090148.91"></t>
<t tx="ekr.20071105090148.92"></t>
<t tx="ekr.20071105090148.93">@ It is possible to link to nodes within the same file.  However clones might be better.
</t>
<t tx="ekr.20071105090148.94">http://webpages.charter.net/edreamleo/front.html</t>
<t tx="ekr.20071105090148.95"></t>
<t tx="ekr.20071105090148.96"></t>
<t tx="ekr.20071105090148.97"></t>
<t tx="ekr.20071105090148.98"></t>
<t tx="ekr.20071105090148.99">@path 'c:/prog/temp'</t>
<t tx="ekr.20071105090148.100">test</t>
<t tx="ekr.20071105090148.101">aaa
xxxxxxxxxxxxxxxxxxxxxx yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy zzzzzzzzzzzzzzzzzzzzzzzzzzzzz wwwwwwwwwwwwwwwwwwwwwww cccccccccccccccccccccccc dddddddddddddddddddd eeeeeeeeeeeeeeeeeeeee one
xxxxxxxxxxxxxxxxxxxxxx yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy zzzzzzzzzzzzzzzzzzzzzzzzzzzzz wwwwwwwwwwwwwwwwwwwwwww cccccccccccccccccccccccc dddddddddddddddddddd eeeeeeeeeeeeeeeeeeeee two
bbb
short line
short line
</t>
<t tx="ekr.20071105090148.102">At least three bugs.

- Place cursor on last (blank) line.  Cursor up goes one line too far.
- Place cursor at end of line 8.  Second cursor down does nothing.
- Place cursor at end of xxxx line.  Second cursor down goes one line too far.

xxxxxxxxx
line 8
line 9
</t>
<t tx="ekr.20071105090148.103">#
'this' is 'a' 'test'
g.es(r'abc')
g.es('hello')
dir('abc')
#changed 3</t>
<t tx="ekr.20071105090148.104">abc
xyz
a      # end

This sentence
spans two lines.

This sentence
spans
three lines.

Last line.</t>
<t tx="ekr.20071105090148.105">def one():
    print 'one'
    two()

def two():
    print 'two'
    g.trace(g.callers(20))

one()

import sys
# print sys._getframe(8) # The stack frame, n levels up.</t>
<t tx="ekr.20071105090148.106"></t>
<t tx="ekr.20071105090148.107">@language vbscript

rem comment
dim i, x, y 
x = 100 
y = 10 

do while i &lt; x 
if int(i/y) = 0 then 
wscript.echo "." 
end if 
i = i + 1 
loop 
wscript.echo "Finished"
</t>
<t tx="ekr.20071105090148.108">@language python
# killcolor. This is a test.

pass

'string'

'another string'

import leoGlobals as g
import leoTest # Support for unit tests.

import parser
import re
import string
import tabnanny
import tokenize

class baseLeoImportCommands:
    """The base class for Leo's import commands."""
    def __init__ (self,c):

        self.c = c

        # New in 4.3: honor any tabwidth directive in effect when importing files.
        self.tabwidth = c.tab_width

        # Set by ImportFilesFommand.
        self.treeType = "@file" # "@root" or "@file"
        # Set by ImportWebCommand.
        self.webType = "@noweb" # "cweb" or "noweb"

        # Set by create_outline.
        self.fileName = None # The original file name, say x.cpp
        self.methodName = None # x, as in &lt; &lt; x methods &gt; &gt; =
        self.fileType = None # ".py", ".c", etc.
        self.rootLine = "" # Empty or @root + self.fileName

        # Support of output_newline option
        self.output_newline = g.getOutputNewline(c=c)

        # Used by Importers.
        self.web_st = []
        self.encoding = g.app.tkEncoding # 2/25/03: was "utf-8"
        self._forcedGnxPositionList = []
        
# This is 'abc' a test of deleting a comment delim.</t>
<t tx="ekr.20071105090148.109">@color

if self.matchTag("a=\""):
    &lt;&lt; Handle vnode attribute bits &gt;&gt;
elif self.matchTag("t="):
    # New for 4.1.  Read either "Tnnn" or "gnx".
    tref = index = self.getDqString()
else:
    a = "abc\"ab"</t>
<t tx="ekr.20071105090148.110">@markup wiki
@
__abc__

http://webpages.charter.net/edreamleo/front.html

{picture file=C:\prog\tigris-cvs\leo\Icons\leo_inst.ico}

__after__</t>
<t tx="ekr.20071105090148.111">@nocolor

'string

@color</t>
<t tx="ekr.20071105090148.112">@language fortran

a = .false.

C comment

D comment


! Comment

amod
modulo
</t>
<t tx="ekr.20071105090148.113">a = .false.

C comment

D comment


! Comment

amod
modulo</t>
<t tx="ekr.20071105090148.114">@language python
# @killcolor.

# This is a test.

import leoGlobals as g
import leoTest # Support for unit tests.

import parser
import re
import string
import tabnanny
import tokenize

# This is a test. 

class baseLeoImportCommands:
    """The base class for Leo's import commands."""
    def __init__ (self,c):

        self.c = c

        # New in 4.3: honor any tabwidth directive in effect when importing files.
        self.tabwidth = c.tab_width

        # Set by ImportFilesFommand.
        self.treeType = "@file" # "@root" or "@file"
        # Set by ImportWebCommand.
        self.webType = "@noweb" # "cweb" or "noweb"

        # Set by create_outline.
        self.fileName = None # The original file name, say x.cpp
        self.methodName = None # x, as in &lt; &lt; x methods &gt; &gt; =
        self.fileType = None # ".py", ".c", etc.
        self.rootLine = "" # Empty or @root + self.fileName

        # Support of output_newline option
        self.output_newline = g.getOutputNewline(c=c)

        # Used by Importers.
        self.web_st = []
        self.encoding = g.app.tkEncoding # 2/25/03: was "utf-8"
        self._forcedGnxPositionList = []
    def createOutline (self,fileName,parent):

        c = self.c ; u = c.undoer
        junk,self.fileName = g.os_path_split(fileName)
        self.methodName,ext = g.os_path_splitext(self.fileName)
        self.fileType = ext
        self.setEncoding()
        # g.trace(self.fileName,self.fileType)
        # All file types except the following just get copied to the parent node.
        ext = ext.lower()
        appendFileFlag = ext not in (
            ".c", ".cpp", ".cxx", ".el", ".java", ".lua", ".pas", ".py", ".pyw", ".php")
        try:
            theFile = open(fileName)
            s = theFile.read()
            s = g.toUnicode(s,self.encoding)
            theFile.close()
        except IOError:
            g.es("can not open " + fileName)
            leoTest.fail()
            return None
        # Create the top-level headline.
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

        self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

        if appendFileFlag:
            body = "@ignore\n"
            if ext in (".html",".htm"): body += "@language html\n"
            if ext in (".txt",".text"): body += "@nocolor\n"
            c.setBodyString(p,body + self.rootLine + s)
        elif ext in (".c", ".cpp", ".cxx"):
            self.scanCText(s,p)
        elif ext == ".el":
            self.scanElispText(s,p)
        elif ext in (".fs", ".fi"):
            self.scanForthText(s,p)
        elif ext == ".java":
            self.scanJavaText(s,p,True) #outer level
        elif ext == ".lua":
            self.scanLuaText(s,p)
        elif ext == ".pas":
            self.scanPascalText(s,p)
        elif ext in (".py", ".pyw"):
            self.scanPythonText(s,p)
        elif ext == ".php":
            self.scanPHPText(s,p) # 08-SEP-2002 DTHEIN
        else:
            g.es("createOutline: can't happen")
        return p
    def getTabWidth (self):

        d = g.scanDirectives(self.c)
        w = d.get("tabwidth")
        if w not in (0,None):
            return w
        else:
            return self.c.tab_width
    def importDerivedFiles (self,parent=None,paths=None):
        # Not a command.  It must *not* have an event arg.

        c = self.c ; u = c.undoer ; command = 'Import'
        at = c.atFileCommands ; current = c.currentPosition()
        self.tab_width = self.getTabWidth()
        if not paths: return
        c.beginUpdate()
        try:
            u.beforeChangeGroup(current,command)
            for fileName in paths:
                g.setGlobalOpenDir(fileName)
                fileName = g.os_path_normpath(fileName)

                try:
                    theFile = open(fileName,'rb')
                    isThin = at.scanHeaderForThin(theFile,fileName)
                    theFile.close()
                except IOError:
                    isThin = False
                undoData = u.beforeInsertNode(parent)
                p = parent.insertAfter()
                if isThin:
                    at.forceGnxOnPosition(p)
                    p.initHeadString("@thin " + fileName)
                    at.read(p,thinFile=True)
                else:
                    p.initHeadString("Imported @file " + fileName)
                    at.read(p,importFileName=fileName)
                p.contract()
                u.afterInsertNode(p,command,undoData)
            current.expand()
            c.selectPosition(current)
            c.setChanged(True)
            u.afterChangeGroup(p,command)
        finally:
            c.endUpdate()
    def forceGnxOnPosition (self,p):

        self._forcedGnxPositionList.append(p.v)
    def importFilesCommand (self,files=None,treeType=None,
        perfectImport=True,testing=False,verbose=False):
            # Not a command.  It must *not* have an event arg.

        c = self.c
        if c == None: return
        v = current = c.currentVnode()
        if current == None: return
        if len(files) &lt; 1: return
        self.tab_width = self.getTabWidth() # New in 4.3.
        self.treeType = treeType
        c.beginUpdate()
        try: # range of update...
            if len(files) == 2:
                # The two filenames have a common prefix everything before the 
                # last period is the same.  For example, x.h and x.cpp.

                name0 = files[0]
                name1 = files[1]
                prefix0, junk = g.os_path_splitext(name0)
                prefix1, junk = g.os_path_splitext(name1)
                if len(prefix0) &gt; 0 and prefix0 == prefix1:
                    current = current.insertAsLastChild()
                    junk, nameExt = g.os_path_split(prefix1)
                    name,ext = g.os_path_splitext(prefix1)
                    current.initHeadString(name)
            for fileName in files:
                g.setGlobalOpenDir(fileName)
                v = self.createOutline(fileName,current)
                if v: # createOutline may fail.
                    perfectImport = False ###
                    testing = True; verbose = True
                    if perfectImport and treeType == "@file": # Can't correct @root trees.
                        self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                    else:
                        if not g.unitTesting:
                            g.es("imported " + fileName,color="blue")
                    v.contract()
                    v.setDirty()
                    c.setChanged(True)
            c.validateOutline()
            current.expand()
        finally:
            c.endUpdate()
        c.selectVnode(current)
    # Used by paste logic.

    def convertMoreStringToOutlineAfter (self,s,firstVnode):
        s = string.replace(s,"\r","")
        strings = string.split(s,"\n")
        return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

    # Almost all the time spent in this command is spent here.

    def convertMoreStringsToOutlineAfter (self,strings,firstVnode):

        __pychecker__ = '--no-objattrs' # suppress bad warnings re lastVnode.

        c = self.c
        if len(strings) == 0: return None
        if not self.stringsAreValidMoreFile(strings): return None
        c.beginUpdate()
        try: # range of update...
            firstLevel, junk = self.moreHeadlineLevel(strings[0])
            lastLevel = -1 ; theRoot = lastVnode = None
            index = 0
            while index &lt; len(strings):
                progress = index
                s = strings[index]
                level, newFlag = self.moreHeadlineLevel(s)
                level -= firstLevel
                if level &gt;= 0:
                    assert(level &gt;= 0)
                    if lastVnode is None:
                        # g.trace(firstVnode)
                        theRoot = v = firstVnode.insertAfter()
                    elif level == lastLevel:
                        v = lastVnode.insertAfter()
                    elif level == lastLevel + 1:
                        v = lastVnode.insertAsNthChild(0)
                    else:
                        assert(level &lt; lastLevel)
                        while level &lt; lastLevel:
                            lastLevel -= 1
                            lastVnode = lastVnode.parent()
                            assert(lastVnode)
                            assert(lastLevel &gt;= 0)
                        v = lastVnode.insertAfter()
                    lastVnode = v
                    lastLevel = level
                    j = 0
                    while g.match(s,j,'\t'):
                        j += 1
                    if g.match(s,j,"+ ") or g.match(s,j,"- "):
                        j += 2

                    v.initHeadString(s[j:])
                    bodyLines = 0
                    index += 1 # Skip the headline.
                    while index &lt; len(strings):
                        s = strings[index]
                        level, junk = self.moreHeadlineLevel(s)
                        level -= firstLevel
                        if level &gt;= 0:
                            break
                        # Remove first backslash of the body line.
                        if g.match(s,0,'\\'):
                            strings[index] = s[1:]
                        bodyLines += 1
                        index += 1
                    if bodyLines &gt; 0:
                        body = ""
                        n = index - bodyLines
                        while n &lt; index:
                            body += strings[n]
                            if n != index - 1:
                                body += "\n"
                            n += 1
                        v.setTnodeText(body)
                    v.setDirty()
                else: index += 1
                assert progress &lt; index
            if theRoot:
                theRoot.setDirty()
                c.setChanged(True)
        finally:
            c.endUpdate()
        return theRoot
    def importFlattenedOutline (self,files): # Not a command, so no event arg.

        c = self.c ; u = c.undoer ; current = c.currentPosition()
        if current == None: return
        if len(files) &lt; 1: return

        self.setEncoding()
        fileName = files[0] # files contains at most one file.
        g.setGlobalOpenDir(fileName)
        try:
            theFile = open(fileName)
            s = theFile.read()
            s = string.replace(s,"\r","")
            s = g.toUnicode(s,self.encoding)
            array = string.split(s,"\n")
            theFile.close()
        except IOError:
            g.es("Can not open " + fileName, color="blue")
            leoTest.fail()
            return

        # Convert the string to an outline and insert it after the current node.
        undoData = u.beforeInsertNode(current)
        p = self.convertMoreStringsToOutlineAfter(array,current)
        if p:
            c.endEditing()
            c.validateOutline()
            c.editPosition(p)
            p.setDirty()
            c.setChanged(True)
            u.afterInsertNode(p,'Import',undoData)
        else:
            g.es(fileName + " is not a valid MORE file.")
    # return the headline level of s,or -1 if the string is not a MORE headline.
    def moreHeadlineLevel (self,s):

        level = 0 ; i = 0
        while g.match(s,i,'\t'):
            level += 1
            i += 1
        plusFlag = g.choose(g.match(s,i,"+"),True,False)
        if g.match(s,i,"+ ") or g.match(s,i,"- "):
            return level, plusFlag
        else:
            return -1, plusFlag
    # Used by paste logic.

    def stringIsValidMoreFile (self,s):

        s = string.replace(s,"\r","")
        strings = string.split(s,"\n")
        return self.stringsAreValidMoreFile(strings)

    def stringsAreValidMoreFile (self,strings):

        if len(strings) &lt; 1: return False
        level1, plusFlag = self.moreHeadlineLevel(strings[0])
        if level1 == -1: return False
        # Check the level of all headlines.
        i = 0 ; lastLevel = level1
        while i &lt; len(strings):
            s = strings[i] ; i += 1
            level, newFlag = self.moreHeadlineLevel(s)
            if level &gt; 0:
                if level &lt; level1 or level &gt; lastLevel + 1:
                    return False # improper level.
                elif level &gt; lastLevel and not plusFlag:
                    return False # parent of this node has no children.
                elif level == lastLevel and plusFlag:
                    return False # last node has missing child.
                else:
                    lastLevel = level
                    plusFlag = newFlag
        return True
    def createOutlineFromWeb (self,path,parent):

        c = self.c ; u = c.undoer
        junk,fileName = g.os_path_split(path)

        undoData = u.beforeInsertNode(parent)

        # Create the top-level headline.
        p = parent.insertAsLastChild()
        p.initHeadString(fileName)
        if self.webType=="cweb":
            c.setBodyString(p,"@ignore\n" + self.rootLine + "@language cweb")

        # Scan the file, creating one section for each function definition.
        self.scanWebFile(path,p)

        u.afterInsertNode(p,'Import',undoData)

        return p
    def importWebCommand (self,files,webType):

        c = self.c ; current = c.currentVnode()
        if current == None: return
        if not files: return
        self.tab_width = self.getTabWidth() # New in 4.3.
        self.webType = webType

        c.beginUpdate()
        try:
            for fileName in files:
                g.setGlobalOpenDir(fileName)
                v = self.createOutlineFromWeb(fileName,current)
                v.contract()
                v.setDirty()
                c.setChanged(True)
            c.selectVnode(current)
        finally:
            c.endUpdate()
    def findFunctionDef (self,s,i):

        # Look at the next non-blank line for a function name.
        i = g.skip_ws_and_nl(s,i)
        k = g.skip_line(s,i)
        name = None
        while i &lt; k:
            if g.is_c_id(s[i]):
                j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
            elif s[i] == '(':
                if name: return name
                else: break
            else: i += 1
        return None
    # This method returns the proper headline text.
    # 
    # 1. If s contains a section def, return the section ref.
    # 2. cweb only: if s contains @c, return the function name following the 
    # @c.
    # 3. cweb only: if s contains @d name, returns @d name.
    # 4. Otherwise, returns "@"

    def scanBodyForHeadline (self,s):

        if self.webType == "cweb":
            i = 0
            while i &lt; len(s):
                i = g.skip_ws_and_nl(s,i)
                # line = g.get_line(s,i) ; g.trace(line)
                # Allow constructs such as @ @c, or @ @&lt;.
                if self.isDocStart(s,i):
                    i += 2 ; i = g.skip_ws(s,i)
                if g.match(s,i,"@d") or g.match(s,i,"@f"):
                    # Look for a macro name.
                    directive = s[i:i+2]
                    i = g.skip_ws(s,i+2) # skip the @d or @f
                    if i &lt; len(s) and g.is_c_id(s[i]):
                        j = i ; g.skip_c_id(s,i) ; return s[j:i]
                    else: return directive
                elif g.match(s,i,"@c") or g.match(s,i,"@p"):
                    # Look for a function def.
                    name = self.findFunctionDef(s,i+2)
                    return g.choose(name,name,"outer function")
                elif g.match(s,i,"@&lt;"):
                    # Look for a section def.
                    # A small bug: the section def must end on this line.
                    j = i ; k = g.find_on_line(s,i,"@&gt;")
                    if k &gt; -1 and (g.match(s,k+2,"+=") or g.match(s,k+2,"=")):
                        return s[j:k+2] # return the section ref.
                i = g.skip_line(s,i)
        else:
            i = 0
            while i &lt; len(s):
                i = g.skip_ws_and_nl(s,i)
                # line = g.get_line(s,i) ; g.trace(line)
                if g.match(s,i,"&lt;&lt;"):
                    k = g.find_on_line(s,i,"&gt;&gt;=")
                    if k &gt; -1:
                        ref = s[i:k+2]
                        name = string.strip(s[i+2:k])
                        if name != "@others":
                            return ref
                else:
                    name = self.findFunctionDef(s,i)
                    if name:
                        return name
                i = g.skip_line(s,i)
        return "@" # default.
    def scanWebFile (self,fileName,parent):

        theType = self.webType
        lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
        rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")

        try: # Read the file into s.
            f = open(fileName)
            s = f.read()
        except:
            g.es("Can not import " + fileName, color="blue")
            return

        i = 0 ; self.web_st = []

        while i &lt; len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            # line = g.get_line(s,i) ; g.trace(line)
            if self.isDocStart(s,i):
                if theType == "cweb": i += 2
                else: i = g.skip_line(s,i)
            elif theType == "cweb" and g.match(s,i,"@@"):
                i += 2
            elif g.match(s,i,lb):
                i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
                if k &gt; -1: self.cstEnter(s[j:k])
            else: i += 1
            assert (i &gt; progress)

        # g.trace(self.cstDump())
        i = 0
        while i &lt; len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i) or g.match(s,i,lb):
                break
            else: i = g.skip_line(s,i)
            assert(i &gt; progress)

        j = g.skip_ws(s,0)
        if j &lt; i:
            self.createHeadline(parent,"@ " + s[j:i],"Limbo")

        j = i
        if g.match(s,i,lb):
            while i &lt; len(s):
                progress = i
                i = g.skip_ws_and_nl(s,i)
                if self.isModuleStart(s,i):
                    break
                else: i = g.skip_line(s,i)
                assert(i &gt; progress)
            self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

        # g.trace(g.get_line(s,i))
        while i &lt; len(s):
            outer_progress = i
            if theType=="cweb":
                assert(self.isModuleStart(s,i))
                start = i
                if self.isDocStart(s,i):
                    i += 2
                    while i &lt; len(s):
                        progress = i
                        i = g.skip_ws_and_nl(s,i)
                        if self.isModuleStart(s,i): break
                        else: i = g.skip_line(s,i)
                        assert (i &gt; progress)
                if g.match(s,i,"@d") or g.match(s,i,"@f"):
                    i += 2 ; i = g.skip_line(s,i)
                    # Place all @d and @f directives in the same node.
                    while i &lt; len(s):
                        progress = i
                        i = g.skip_ws_and_nl(s,i)
                        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
                        else: break
                        assert (i &gt; progress)
                    i = g.skip_ws_and_nl(s,i)

                while i &lt; len(s) and not self.isModuleStart(s,i):
                    progress = i
                    i = g.skip_line(s,i)
                    i = g.skip_ws_and_nl(s,i)
                    assert (i &gt; progress)

                if g.match(s,i,"@c") or g.match(s,i,"@p"):
                    i += 2
                    while i &lt; len(s):
                        progress = i
                        i = g.skip_line(s,i)
                        i = g.skip_ws_and_nl(s,i)
                        if self.isModuleStart(s,i):
                            break
                        assert (i &gt; progress)
            else:
                assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
                start = i ; i = g.skip_line(s,i)
                while i &lt; len(s):
                    progress = i
                    i = g.skip_ws_and_nl(s,i)
                    if self.isDocStart(s,i): break
                    else: i = g.skip_line(s,i)
                    assert (i &gt; progress)

            body = s[start:i]
            body = self.massageWebBody(body)
            headline = self.scanBodyForHeadline(body)
            self.createHeadline(parent,body,headline)
            assert(i &gt; outer_progress)
    # We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.

    def cstCanonicalize (self,s,lower=True):

        if lower:
            s = string.lower(s)
        s = string.replace(s,"\t"," ")
        s = string.replace(s,"\r","")
        s = string.replace(s,"\n"," ")
        s = string.replace(s,"  "," ")
        s = string.strip(s)
        return s
    def cstDump (self):

        self.web_st.sort()
        s = "Web Symbol Table...\n\n"
        for name in self.web_st:
            s += name + "\n"
        return s
    # We only enter the section name into the symbol table if the ... convention is not used.

    def cstEnter (self,s):

        # Don't enter names that end in "..."
        s = string.rstrip(s)
        if s.endswith("..."): return

        # Put the section name in the symbol table, retaining capitalization.
        lower = self.cstCanonicalize(s,True)  # do lower
        upper = self.cstCanonicalize(s,False) # don't lower.
        for name in self.web_st:
            if string.lower(name) == lower:
                return
        self.web_st.append(upper)
    # This method returns a string if the indicated string is a prefix of an entry in the web_st.

    def cstLookup (self,target):

        # Do nothing if the ... convention is not used.
        target = string.strip(target)
        if not target.endswith("..."): return target
        # Canonicalize the target name, and remove the trailing "..."
        ctarget = target[:-3]
        ctarget = self.cstCanonicalize(ctarget)
        ctarget = string.strip(ctarget)
        found = False ; result = target
        for s in self.web_st:
            cs = self.cstCanonicalize(s)
            if cs[:len(ctarget)] == ctarget:
                if found:
                    g.es("****** " + target + ": is also a prefix of: " + s)
                else:
                    found = True ; result = s
                    # g.es("replacing: " + target + " with: " + s)
        return result
    def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):

        __pychecker__ = 'maxlines=500'

        # 
        # This algorithm corrects the result of an Import To @file command so 
        # that it is guaranteed that the result of writing the imported file 
        # will be identical to the original file except for any sentinels that 
        # have been inserted.
        # 
        # On entry, p points to the newly imported outline.
        # 
        # We correct the outline by applying Bernhard Mulder's algorithm.
        # 
        # 1.  We use the atFile.write code to write the newly imported outline 
        # to a string s.  This string contains represents a thin derived file, 
        # so it can be used to recreate then entire outline structure without 
        # any other information.
        # 
        # Splitting s into lines creates the fat_lines argument to mu methods.
        # 
        # 2. We make corrections to fat_lines using Mulder's algorithm.  The 
        # corrected fat_lines represents the corrected outline.  To do this, 
        # we set the arguments as follows:
        # 
        # - i_lines: fat_lines stripped of sentinels
        # - j_lines to the lines of the original imported file.
        # 
        # The algorithm updates fat_lines using diffs between i_lines and 
        # j_lines.
        # 
        # 3. Mulder's algorithm doesn't specify which nodes have been 
        # changed.  In fact, it Mulder's algorithm doesn't really understand 
        # nodes at all.  Therefore, if we want to mark changed nodes we do so 
        # by comparing the original version of the imported outline with the 
        # corrected version of the outline.
        c = self.c
        root = p.copy()
        at = c.atFileCommands
        if testing:
            for p2 in p.self_and_subtree_iter():
                p2.clearDirty()
        nodeIndices = g.app.nodeIndices

        nodeIndices.setTimestamp()

        for p2 in root.self_and_subtree_iter():
            try: # Will fail for None or any pre 4.1 file index.
                theId,time,n = p2.v.t.fileIndex
            except TypeError:
                p2.v.t.fileIndex = nodeIndices.getNewIndex()
        at.write(root,thinFile=True,toString=True)
        s = at.stringOutput
        if not s: return

        # Set up the data for the algorithm.
        mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
        delims = g.comment_delims_from_extension(fileName)
        fat_lines = g.splitLines(s) # Keep the line endings.
        i_lines,mapping = mu.create_mapping(fat_lines,delims)
        j_lines = file(fileName).readlines()

        # Correct write_lines using the algorihm.
        if i_lines != j_lines:
            if verbose:
                g.es("Running Perfect Import",color="blue")
            write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
            if 1: # For testing.
                write_lines_node = root.insertAfter()
                write_lines_node.initHeadString("write_lines")
                s = ''.join(write_lines)
                write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)
            # Notes:
            # 1. This code must overwrite the newly-imported tree because the 
            # gnx's in
            # write_lines refer to those nodes.
            # 
            # 2. The code in readEndNode now reports when nodes change during 
            # importing. This
            # code also marks changed nodes.

            try:
                at.correctedLines = 0
                at.targetFileName = "&lt;perfectImport string-file&gt;"
                at.inputFile = fo = g.fileLikeObject()
                at.file = fo # Strange, that this is needed.  Should be cleaned up.
                for line in write_lines:
                    fo.write(line)
                firstLines,junk,junk = c.atFileCommands.scanHeader(fo,at.targetFileName)
                # To do: pass params to readEndNode.
                at.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
                n = at.correctedLines
                if verbose:
                    g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
            except:
                g.es("Exception in Perfect Import",color="red")
                g.es_exception()
                s = None
        if verify:
            try:
                # Read the original file into before_lines.
                before = file(fileName)
                before_lines = before.readlines()
                before.close()

                # Write the tree into after_lines.
                at.write(root,thinFile=True,toString=True)
                after_lines1 = g.splitLines(at.stringOutput)

                # Strip sentinels from after_lines and compare.
                after_lines = mu.removeSentinelsFromLines(after_lines1,delims)

                # A major kludge: Leo can not represent unindented blank lines in indented nodes!
                # We ignore the problem here by stripping whitespace from blank lines.
                # We shall need output options to handle such lines.
                if convertBlankLines:
                    mu.stripWhitespaceFromBlankLines(before_lines)
                    mu.stripWhitespaceFromBlankLines(after_lines)
                if before_lines == after_lines:
                    if verbose:
                        g.es("Perfect Import verified",color="blue")
                else:
                    leoTest.fail()
                    if verbose:
                        g.es("Perfect Import failed verification test!",color="red")
                        print len(before_lines),len(after_lines)

                        if len(before_lines)==len(after_lines):
                            for i in xrange(len(before_lines)):
                                extra = 3
                                if before_lines[i] != after_lines[i]:
                                    j = max(0,i-extra)
                                    print '-' * 20
                                    while j &lt; i + extra + 1:
                                        leader = g.choose(i == j,"* ","  ")
                                        print "%s%3d" % (leader,j), repr(before_lines[j])
                                        print "%s%3d" % (leader,j), repr(after_lines[j])
                                        j += 1
                        else:
                            for i in xrange(min(len(before_lines),len(after_lines))):
                                if before_lines[i] != after_lines[i]:
                                    extra = 5
                                    print "first mismatch at line %d" % i
                                    print "printing %d lines after mismatch" % extra
                                    print "before..."
                                    for j in xrange(i+1+extra):
                                        print "%3d" % j, repr(before_lines[j])
                                    print
                                    print "after..."
                                    for k in xrange(1+extra):
                                        print "%3d" % (i+k), repr(after_lines[i+k])
                                    print
                                    print "with sentinels"
                                    j = 0 ; k = 0
                                    while k &lt; i + 1 + extra:
                                        print "%3d" % k,repr(after_lines1[j])
                                        if not g.is_sentinel(after_lines1[j],delims):
                                            k += 1
                                        j += 1
                                    break
            except IOError:
                g.es("Can not reopen %s!" % fileName,color="red")
                leoTest.fail()
    class baseScannerClass:

        '''
        The base class for all import scanner classes.
        This class contains common utility methods.
        '''

        def __init__ (self,importCommands,atAuto,language,strict):

            # Copy arguments.
            self.atAuto = atAuto
            self.language = language
            self.strict = strict

            # Copy ivars from the importCommands class.
            self.importCommands = ic = importCommands
            self.c = ic.c
            self.encoding = ic.encoding
            self.fileName = ic.fileName
            self.fileType = ic.fileType
            # self._forcedGnxPositionList = []
            self.methodName = ic.methodName
            self.output_newline = ic.output_newline
            self.root = None # The top-level node of the generated tree.
            self.rootLine = ic.rootLine
            self.tab_width = ic.getTabWidth()
            self.treeType = ic.treeType
            # self.web_st = []
            self.webType = ic.webType

            # Compute language ivars.
            delim1,delim2,delim3 = g.set_delims_from_language(language)
            self.comment_delim = delim1

            # Create the ws equivalent to one tab.
            if self.tab_width &lt; 0:
                self.tab_ws = ' '*abs(self.tab_width)
            else:
                self.tab_ws = '\t'

            # May be overridden in subclasses.
            self.lineCommentDelim = None
            self.blockCommentDelim1 = None
            self.blockCommentDelim2 = None
            self.signatureDelim = '{'
        def run (self,s,parent):

            scanner = self
            scanner.root = parent
            scanner.file_s = s

            # Step 1: generate the nodes,
            # including all directive and section references.
            scanner.scan(s,parent)

            # Step 2: check the generated nodes.
            # Return True if the result is equivalent to the original file.
            ok = scanner.check(parent)

            # Step 3: insert an @ignore directive if there are any problems.
            if not ok:
                scanner.insertIgnoreDirectives(parent)
        def check (self,parent):

            '''
            Make sure the generated nodes are equivalent to the original file.

            1. Regularize and check leading whitespace.
            2. Check that a trial write produces the original file.

            Return True if the nodes are equivalent to the original file.
            '''

            return self.checkWhitespace(parent) and self.checkTrialWrite()
        # Similar to c.tabNannyNode

        def checkTab (self,p):

            """Check indentation using tabnanny."""

            h = p.headString() ; body = p.bodyString()

            try:
                readline = g.readLinesClass(body).next
                tabnanny.process_tokens(tokenize.generate_tokens(readline))
                return True

            except IndentationError, err:
                # Instances of this class have attributes filename, lineno, offset and text.
                g.es_print("IndentationError in %s at line %d" % (h,err.lineno),color="blue")
                # g.es_print(str(err)) # str(err.text))

            except parser.ParserError, msg:
                g.es_print("ParserError in %s" % h,color="blue")
                g.es_print(str(msg))

            except tokenize.TokenError, msg:
                g.es_print("TokenError in %s" % h,color="blue")
                g.es_print(str(msg))

            except tabnanny.NannyNag, nag:
                badline = nag.get_lineno()
                line    = nag.get_line()
                message = nag.get_msg()
                g.es_print("Indentation error in %s, line %d" % (h, badline),color="blue")
                g.es_print(message)
                g.es_print("offending line:\n%s" % repr(str(line))[1:-1])

            except:
                g.trace("unexpected exception")
                g.es_exception()

            return False
        def checkWhitespace(self,parent):

            '''Check and normalize the leading whitespace of all nodes.

            - The original sources may fail Python's tabNanny checks.  

            - Leading whitespace in the original sources may be inconsistent with the
              @tabwidth setting in effect in the @auto tree.

            - The original sources may contain underindented comments. 

            If an indentation problem is found, issue a warning and return False.
            Otherwise, normalize the indentation of all pieces so that it is indeed
            consistent with the indentation specified by the present @tabwidth setting.
            Normalizing underindented comments means shifting the comments right.
            '''

            # Check that whitespace passes TabNanny.
            # Check that whitespace is compatible with @tabwidth.
            # Check for underindented lines.
            g.trace(self.tab_width)
            ok = True
            for p in parent.self_and_subtree_iter():
                ok = ok and self.checkTab(p)
            return ok
        def checkTrialWrite (self):

            '''
            Return True if a trial write produces the original file.
            '''

            # Probably not: For @auto, verify that no node contains any Leo directives or section references.

            c = self.c ; at = c.atFileCommands

            at.write(self.root,
                nosentinels=True,thinFile=False,
                scriptWrite=False,toString=True,
                write_strips_blank_lines=False,
            )
            s1 = self.file_s
            s2 = at.stringOutput
            ok = s1 == s2
            if ok:
                pass
                g.trace('***success***')
            else:
                lines1 = g.splitLines(s1)
                lines2 = g.splitLines(s2)
                if not self.strict: # ignore blank lines.
                    lines1 = [z for z in lines1 if z.strip()]
                    lines2 = [z for z in lines2 if z.strip()]
                g.trace('***mismatch',
                    'lines1',len(lines1),'lines2',len(lines2),
                    'len(s1)',len(s1),'len(s2)',len(s2))
                n = min(len(lines1),len(lines2))
                for i in xrange(n):
                    if lines1[i] != lines2[i]:
                        print 'first mismatch at line %d' % (i)
                        print 'original line: ', repr(lines1[i])
                        print 'generated line:', repr(lines2[i])
                        break
                else:
                    if len(lines2) &lt; len(lines1):
                         print 'missing lines'
                         i = n
                         while i &lt; len(lines1):
                             print repr(lines1[i])
                             i += 1
                    else:
                        print 'extra lines'
                        i = n
                        while i &lt; len(lines2):
                            print repr(lines1[2])
                            i += 1
                if 0:
                    print
                    for i in xrange(len(lines2)):
                        print '%3d: %s' % (i,repr(lines2[i]))
            return ok
        def error (self,s):
            g.es_print(s,color='red')

        scanError = error
        def getLeadingIndent (self,s,i):

            """Return the leading whitespace of a line, ignoring blank and comment lines."""

            width = 0 ; i = g.find_line_start(s,i)
            while i &lt; len(s):
                # g.trace(g.get_line(s,i))
                j = g.skip_ws(s,i)
                if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                    i = g.skip_line(s,i) # ignore blank lines and comment lines.
                else:
                    i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                    break

            # g.trace("returns:",width)
            return width
        # The start of a document part or module in a noweb or cweb file.
        # Exporters may have to test for @doc as well.

        def isDocStart (self,s,i):

            if not g.match(s,i,"@"):
                return False

            j = g.skip_ws(s,i+1)
            if g.match(s,j,"%defs"):
                return False
            elif self.webType == "cweb" and g.match(s,i,"@*"):
                return True
            else:
                return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

        def isModuleStart (self,s,i):

            if self.isDocStart(s,i):
                return True
            else:
                return self.webType == "cweb" and (
                    g.match(s,i,"@c") or g.match(s,i,"@p") or
                    g.match(s,i,"@d") or g.match(s,i,"@f"))
        def oops (self):
            print ("baseScannerClass oops:",
                g.callers(),
                "must be overridden in subclass")
        def setEncoding (self):

            # scanDirectives checks the encoding: may return None.
            theDict = g.scanDirectives(self.c)
            encoding = theDict.get("encoding")
            if encoding and g.isValidEncoding(encoding):
                self.encoding = encoding
            else:
                self.encoding = g.app.tkEncoding # 2/25/03

            # print self.encoding
        def scan (self,s,parent):

            '''A language independent scanner: it uses language-specific helpers.

            Create a child of self.root for:
            - Leading outer-level declarations.
            - Outer-level classes.
            - Outer-level functions.
            '''
            i = start = self.skipDecls(s,0,len(s))
            decls = s[:i]
            if decls: self.createDeclsNode(parent,decls)
            needRef = False
            while i &lt; len(s):
                progress = i
                if g.match(s,i,self.lineCommentDelim):
                    i = g.skip_line(s,i)
                elif g.match(s,i,self.blockCommentDelim1):
                    i = self.skipBlockComment(s,i)
                elif self.startsString(s,i):
                    i = self.skipString(s,i)
                elif self.startsClass(s,i):
                    end2 = self.skipClass(s,i)
                    self.putClass(s,i,end2,start,parent)
                    i = start = end2
                    needRef = True
                elif self.startsFunction(s,i):
                    end2 = self.skipFunction(s,i)
                    self.putFunction(s,i,end2,start,parent)
                    i = start = end2
                elif self.startsId(s,i):
                    i = self.skipId(s,i);
                else: i += 1
                assert(progress &lt; i)
            self.addRef(parent)
        def addRef (self,parent):

            '''Create an unindented the @others or section reference in the parent node.'''

            c = self.c

            if self.treeType == "@file":
                c.appendStringToBody(parent,"@others\n")

            if self.treeType == "@root" and self.methodsSeen:
                c.appendStringToBody(parent,
                    g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
        def skipDecls (self,s,i,end):

            '''
            Carefully skip everything until the start of the next class or function.
            '''

            while i &lt; end:
                progress = i
                if g.match(s,i,self.lineCommentDelim):
                    i = g.skip_line(s,i)
                elif g.match(s,i,self.blockCommentDelim1):
                    i = self.skipBlockComment(s,i)
                elif self.startsString(s,i):
                    i = self.skipString(s,i)
                elif self.startsClass(s,i):
                    # Important: do not include leading ws in the decls.
                    i = self.adjustClassOrFunctionStart(s,i,'class')
                    break
                elif self.startsFunction(s,i):
                    # Important: do not include leading ws in the decls.
                    i = self.adjustClassOrFunctionStart(s,i,'function')
                    break
                elif self.startsId(s,i):
                    i = self.skipId(s,i);
                else: i += 1
                assert(progress &lt; i)

            return min(i,end)
        def adjustClassOrFunctionStart(self,s,i,tag):

            '''
            s[i:] starts a class or function.
            Adjust i so it points at the start of the line.

            Issue a warning if anything except whitespace appears.
            '''

            j = g.find_line_start(s,i)
            if s[j:i].strip():
                message = '% definition does not start a line. Leo must insert a newline.' % tag
                self.error(message)
                return i
            else:
                return j
        def extendSignature(self,s,i,start):

            '''
            Extend the signature line if appropriate.
            The text *must* end with a newline.

            For example, the Python scanner appends docstrings if they exist.
            '''

            return i
        def getClassID (self,s,i):

            '''
            Return the class id if s[i:] starts a class definition.
            '''

            return self.startsClass(s,i)

        def getFunctionID (self,s,i):

            '''
            Return the function id if s[i:] starts a function definition.
            '''

            return self.startsFunction(s,i)
        def skipBlock(self,s,i,delim1='{',delim2='}'):

            """Skips from the opening delim to the matching closing delim.

            If no matching is found i is set to len(s)"""

            # start = g.get_line(s,i)
            assert g.match(s,i,delim1)
            level = 0 ; n = len(s)
            while i &lt; n:
                c = s[i]
                if c == delim1:
                    level += 1 ; i += 1
                elif c == delim2:
                    level -= 1 ; i += 1
                    if level &lt;= 0: return i
                elif g.match(s,i,self.lineCommentDelim):
                    i = g.skip_line(s,i)
                elif g.match(s,i,self.blockCommentDelim1):
                    i = self.skipBlockComment(s,i)
                elif self.startsString(s,i):
                    i = self.skipString(s,i)
                # Only for C++.
                # elif g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
                    # i,delta = g.skip_pp_if(s,i)
                    # level += delta
                else: i += 1
            return i
        def skipBlockComment (self,s,i):

            '''Skip past a block comment.'''

            # Skip the opening delim.
            assert(g.match(s,i,self.blockCommentDelim1))
            start = i ; i += len(self.blockCommentDelim1)

            # Find the closing delim.
            k = string.find(s,self.blockCommentDelim2,i)
            if k == -1:
                self.scanError("Run on block comment: " + s[start:i])
                return len(s)
            else:
                return k + len(self.blockCommentDelim2)
        def skipId (self,s,i):

            return g.skip_c_id(s,i)
        def skipString (self,s,i):

            # Returns len(s) on unterminated string.
            return g.skip_string(s,i,verbose=False)
        def startsId(self,s,i):

            return g.is_c_id(s[i])
        def startsString(self,s,i):

            return g.match(s,i,'"') or g.match(s,i,"'")
        def getClassId (self,s,i):
            self.oops()

        def getFunctionId (self,s,i):
            self.oops()

        def putClass (self,s,i,end,start,parent):
            self.oops()

        def putFunction (self,s,i,end,start,parent):
            self.oops()

        def skipClass (self,s,i):
            self.oops()

        def skipFunction (self,s,i):
            self.oops()

        def skipSignature (self,s,i):
            self.oops()

        def startsClass (self,s,i):
            self.oops()

        def startsFunction (self,s,i):
            self.oops()
        def createDeclsNode (self,parent,s):

            '''Create a child node of parent containing s.'''

            # Create the node for the decls.
            headline = self.methodName + ' declarations'
            body = self.undentBody(s)
            self.createHeadline(parent,body,headline)
        def createFunctionNode (self,headline,body,parent):

            # Create the prefix line for @root trees.
            if self.treeType == "@file":
                prefix = ""
            else:
                prefix = g.angleBrackets(" " + headline + " methods ") + "=\n\n"
                self.methodsSeen = True

            body = self.undentBody(body)

            # Create the node.
            self.createHeadline(parent,prefix + body,headline)

        def createHeadline (self,parent,body,headline):

            # g.trace("parent,headline:",parent,headline)

            # Create the vnode.
            p = parent.insertAsLastChild()
            p.initHeadString(headline,self.encoding)

            # Set the body.
            if body:
                self.c.setBodyString(p,body,self.encoding)
            return p
        def insertIgnoreDirectives (self,parent):

            g.trace(parent)
        def massageComment (self,s):

            """Returns s with all runs of whitespace and newlines converted to a single blank.

            Also removes leading and trailing whitespace."""

            s = s.strip()
            s = s.replace("\n"," ")
            s = s.replace("\r"," ")
            s = s.replace("\t"," ")
            s = s.replace("  "," ")
            s = s.strip()
            return s
        def putClass (self,s,i,end,start,parent):

            """Creates a child node c of parent for the class, and children of c for each def in the class."""

            # g.trace('start',start,'i',i,g.get_line(s,i))

            c = self.c
            classStart = g.find_line_start(s,i)
            class_name = self.getClassID(s,i)
            headline = "class " + class_name

            prefix = self.createClassNodePrefix()
            j = self.skipSignature(s,i)
            i = self.extendSignature(s,j)
            body = s[start:j]
            extend = s[j:i]
            if extend:
                extend = self.undentBody(extend)
                extend = self.indentBody(extend)
                g.trace(class_name,'extend',repr(extend))
                body = body + extend

            class_node = self.createHeadline(parent,prefix + body,headline)

            savedMethodName = self.methodName
            self.methodName = headline

            self.putClassHelper(s,i,end,class_name,class_node)
            self.methodName = savedMethodName
        def appendRefToClassNode (self,class_name,class_node):

            '''Insert the proper body text in the class_vnode.'''

            if self.treeType == "@file":
                s = '@others'
            else:
                s = g.angleBrackets(' class %s methods ' % (class_name))

            self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
        def appendTextToClassNode (self,class_node,s):

            c = self.c
            c.appendStringToBody(class_node,s) 
        def createClassNodePrefix (self):

            '''Create the class node prefix.'''

            if  self.treeType == "@file":
                prefix = ""
            else:
                prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
                self.methodsSeen = True

            return prefix
        def putClassHelper(self,s,i,end,class_name,class_node):

            assert(i &lt;= end)
            # Put any leading decls in the class node.
            start = i
            i = self.skipDecls(s,i,end)
            decls = s[start:i]
            if decls:
                # We must regularize the indentation to match the @others
                decls = self.undentBody(decls)
                decls = self.indentBody(decls)
                g.trace(class_name,'decls',repr(decls))
                self.appendTextToClassNode(class_node,decls)
            start = i ; putRef = False
            while i &lt; end:
                progress = i
                if g.match(s,i,self.lineCommentDelim):
                    i = g.skip_line(s,i)
                elif g.match(s,i,self.blockCommentDelim1):
                    i = self.skipBlockComment(s,i)
                elif self.startsString(s,i):
                    i = self.skipString(s,i)
                elif self.startsClass(s,i):
                    putRef = True
                    end2 = self.skipClass(s,i)
                    self.putClass(s,i,end2,start,class_node)
                    i = start = end2
                elif self.startsFunction(s,i):
                    putRef = True
                    end2 = self.skipFunction(s,i)
                    self.putFunction(s,i,end2,start,class_node)
                    i = start = end2
                elif self.startsId(s,i):
                    i = self.skipId(s,i);
                else: i += 1
                assert(progress &lt; i)

            if putRef:
                self.appendRefToClassNode(class_name,class_node)

            if start &lt; end:
                trailing = s[start:end]
                self.appendTextToClassNode(class_node,trailing)
        def putFunction (self,s,i,end,start,parent):

            '''
            Create a node of parent for a function defintion.
            '''

            headline = self.getFunctionID(s,i)
            body = s[start:end]
            self.createFunctionNode(headline,body,parent)
        def putRootText (self,p):

            c = self.c

            if self.atAuto:
                c.appendStringToBody(p,self.rootLine + '@language python\n')
            else:
                c.appendStringToBody(p,'@ignore\n' + self.rootLine + '@language python\n')
        def undentBody (self,s):

            '''Remove the leading indentation of line 1 from all lines of s.'''

            i = 0 ; result = ''

            # Copy an @code line as is.
            if g.match(s,i,"@code"):
                j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
                result += s[j:i]

            # Calculate the amount to be removed from each line.
            undent = self.getLeadingIndent(s,i)
            if undent == 0: return s

            result = []
            for line in g.splitLines(s):
                line = g.removeLeadingWhitespace(line,undent,self.tab_width)
                result.append(line)
            return ''.join(result)
        def indentBody (self,s):

            '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

            result = []

            for line in g.splitLines(s):
                if line.strip():
                    result.append(self.tab_ws + line)
                elif line.endswith('\n'):
                    result.append('\n')

            return ''.join(result)
    if g.unitTesting:

        ic = c.importCommands
        c,p = g.getTestVars()

        if 1:
            fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'leoTest.py'))
            # print '@test scanPythonText: path',path
            f = file(fileName)
            s = f.read()
            f.close()
        else:
            s = '''\
    def spam():
        pass
    '''

        # Duplicate processing in ic command
        junk,ic.fileName = g.os_path_split(fileName)
        ic.methodName,ic.fileType = g.os_path_splitext(ic.fileName)
        ic.setEncoding()

        ic.scanPythonText (s=s,parent=p.copy(),atAuto=True)

        if 1:
            nodes = [z for z in p.subtree_iter()]
            print 'Generated tree has %d nodes' % len(nodes)
        else:
            g.trace('***** generated tree...')
            for z in p.subtree_iter():
                print '.'*z.level(),z.headString()
    if g.unitTesting:

        c,p = g.getTestVars()
        self = c.importCommands
        scanner = pythonScanner(self,atAuto)

        # global c # Get syntax warning if this is not first.
        # if self: c = self.c             # Run from @test node: c not global
        # else: self = c.importCommands   # Run from @suite: c *is* global
        d = g.scanDirectives(c)
        self.tab_width = d.get("tabwidth")
        verbose = False
        s = '''\
        def test1():
            aList = (a,
        b,c)
        # underindented comment.
            return 1

        def test2():
        # underindented comment.
            pass
        '''

        s = g.adjustTripleString(s,self.tab_width)
        start = 0
        i = self.skipPythonDef(s,i=0,start=start)
        result = s[start:i].strip()
        if verbose: g.trace(result)
        assert result.startswith('def test1') and result.endswith('return 1'),'result:\n%s' % result
        start = i
        i = self.skipPythonDef(s,i=i,start=start)
        result = s[start:i].strip()
        if verbose: g.trace(result)
        assert result.startswith('def test2') and result.endswith('pass'),'result:\n%s' % result
    if g.unitTesting:

        c,p = g.getTestVars()
        self = c.importCommands
        scanner = pythonScanner(self,atAuto)

        # global c # Get syntax warning if this is not first.
        # if self: c = self.c             # Run from @test node: c not global
        # else: self = c.importCommands   # Run from @suite: c *is* global

        d = g.scanDirectives(c)
        self.tab_width = d.get("tabwidth")
        verbose = False
        s = '''\
        def test1(
                a=2):
            return 1

        def test2(
        a=3):
            return 2
        '''

        s = g.adjustTripleString(s,self.tab_width)
        start = 0
        i = self.skipPythonDef(s,i=0,start=start)
        result = s[start:i].strip()
        if verbose: g.trace(result)
        assert result.startswith('def test1') and result.endswith('return 1'),'result:\n%s' % result
        start = i
        i = self.skipPythonDef(s,i=i,start=start)
        result = s[start:i].strip()
        if verbose: g.trace(result)
        assert result.startswith('def test2') and result.endswith('return 2'),'result:\n%s' % result
    if g.unitTesting:

        c,p = g.getTestVars()
        self = c.importCommands
        scanner = pythonScanner(self,atAuto)

        # global c # Get syntax warning if this is not first.
        # if self: c = self.c             # Run from @test node: c not global
        # else: self = c.importCommands   # Run from @suite: c *is* global

        d = g.scanDirectives(c)
        self.tab_width = d.get("tabwidth")
        verbose = False
        s = '''\
        class aClass:
            def spam():
                return 'spam'
        # underindented comment line
            def eggs():
                return 'eggs'

        class aClass2:
            def twit():
                return 'twit'
        '''

        s = g.adjustTripleString(s,self.tab_width)
        start = 0
        i = self.skipPythonDef(s,i=0,start=start)
        result = s[start:i].strip()
        if verbose: g.trace(result)
        assert result.startswith('class aClass') and result.endswith("'eggs'"),'result:\n%s' % result
        start = i
        i = self.skipPythonDef(s,i=i,start=start)
        result = s[start:i].strip()
        if verbose: g.trace(result)
        assert result.startswith('class aClass2') and result.endswith("'twit'"),'result:\n%s' % result
    def scanElispText(self,s,p):

        c = self.c
        c.appendStringToBody(p,"@ignore\n@language elisp\n")
        i = 0 ; start = 0
        while i &lt; len(s):
            progress = i
            ch = s[i] ; # g.trace(g.get_line(s,i))
            if ch == ';':
                i = g.skip_line(s,i)
            elif ch == '(':
                j = self.skipElispParens(s,i)
                k = g.skip_ws(s,i+1)
                if g.match_word(s,k,"defun") or g.match_word(s,k,"defconst") or g.match_word(s,k,"defvar"):
                    data = s[start:i]
                    if data.strip():
                        self.createElispDataNode(p,data)
                    self.createElispFunction(p,s[i:j+1])
                    start = j+1
                i = j
            else:
                i += 1
            assert(progress &lt; i)
        data = s[start:len(s)]
        if data.strip():
            self.createElispDataNode(p,data)
    def skipElispParens (self,s,i):

        level = 0 ; n = len(s)
        assert(g.match(s,i,'('))

        while i &lt; n:
            c = s[i]
            if c == '(':
                level += 1 ; i += 1
            elif c == ')':
                level -= 1
                if level &lt;= 0:
                    return i
                i += 1
            elif c == '"': i = g.skip_string(s,i) # Single-quotes are not strings.
            elif g.match(s,i,";"):  i = g.skip_line(s,i)
            else: i += 1
        return i
    def skipElispId (self,s,i):

        n = len(s)
        while i &lt; n and g.isWordChar(s[i]):
            i += 1
        return i
    def createElispFunction (self,p,s):

        body = s
        i = 1 # Skip the '('
        i = g.skip_ws(s,i)

        # Set the prefix in the headline.
        assert(g.match(s,i,"defun") or g.match_word(s,i,"defconst") or g.match_word(s,i,"defvar"))
        if g.match_word(s,i,"defconst"):
            prefix = "const "
        elif g.match_word(s,i,"defvar"):
            prefix = "var "
        else:
            prefix = ""

        # Skip the "defun" or "defconst" or "defvar"
        i = self.skipElispId(s,i)

        # Get the following id.
        i = g.skip_ws(s,i)
        j = self.skipElispId(s,i)
        theId = prefix + s[i:j]

        self.createHeadline(p,body,theId)
    def createElispDataNode (self,p,s):

        data = s
        # g.trace(len(data))

        # Skip blank lines and comment lines.
        i = 0
        while i &lt; len(s):
            i = g.skip_ws_and_nl(s,i)
            if g.match(s,i,';'):
                i = g.skip_line(s,i)
            else: break

        # Find the next id, probably prefixed by an open paren.
        if g.match(s,i,"("):
            i = g.skip_ws(s,i+1)
        j = self.skipElispId(s,i)
        theId = s[i:j]
        if not theId:
            theId = "unnamed data"

        self.createHeadline(p,data,theId)
    def scanForthText (self,s,parent):

        """Minimal forth scanner - leave it to user to create nodes as they see fit."""

        self.c.setBodyString(parent,"@ignore\n" + "@language forth\n" + self.rootLine + s)
    # Creates a child of parent for each Java function definition seen.

    def scanJavaText (self,s,parent,outerFlag): # True if at outer level.

        __pychecker__ = 'maxlines=500'

        c = self.c
        method_seen = False
        class_seen = False # True: class keyword seen at outer level.
        interface_seen = False # True: interface keyword seen at outer level.
        lparen = None  # not None if '(' seen at outer level.
        scan_start = 0
        name = None
        function_start = 0 # g.choose(outerFlag, None, 0)
        i = 0
        # if not outerFlag: g.trace("inner:",s)
        while i &lt; len(s):
            # g.trace(g.get_line(s,i))
            ch = s[i]
            # These cases skip tokens.
            if ch == '/':
                if g.match(s,i,"//"):
                    i = g.skip_line(s,i)
                elif g.match(s,i,"/*"):
                    i = g.skip_block_comment(s,i)
                else:
                    i += 1
            elif ch == '"' or ch == '\'': i = g.skip_string(s,i)
            # These cases help determine where functions start.
            elif ch == '=':
                # We can not be seeing a function definition when we find an 
                # equal sign at the top level. Equal signs inside parentheses 
                # are handled by the open paren logic.

                i += 1 # skip the '='
                function_start = 0 # 3/23/03: (bug fix: was None) We can't be in a function.
                lparen = None   # We have not seen an argument list yet.
                if g.match(s,i,'='):
                    i = g.skip_braces(s,i)
            elif ch == '(':
                lparen = i
                # This will skip any equal signs inside the paren.
                i = g.skip_parens(s,i)
                if g.match(s,i,')'):
                    i += 1
                    i = g.skip_ws_and_nl(s,i)
                    if g.match(s,i,';'):
                        lparen = None # not a function definition.
                else: lparen = None
            elif ch == ';':
                # A semicolon signals the end of a declaration, thereby 
                # potentially starting the _next_ function defintion.   
                # Declarations end a function definition unless we have 
                # already seen a parenthesis, in which case we are seeing an 
                # old-style function definition.

                i += 1 # skip the semicolon.
                if lparen == None:
                    function_start = i + 1 # The semicolon ends the declaration.
                class_seen = False
            # These cases can create child nodes.
            elif ch == '{':
                brace_ip1 = i
                i = g.skip_braces(s,i) # Skip all inner blocks.
                brace_ip2 = i

                if not g.match (s,i,'}'):
                    g.es("unmatched '{'")
                elif not name:
                    i += 1
                elif (outerFlag and (class_seen or interface_seen)) or (not outerFlag and lparen):
                    # g.trace("starting:",name)
                    # g.trace("outerFlag:",outerFlag)
                    # g.trace("lparen:",lparen)
                    # g.trace("class_seen:",class_seen)
                    # g.trace("scan_start:",g.get_line_after(s,scan_start))
                    # g.trace("func_start:",g.get_line_after(s,function_start))
                    # g.trace("s:",g.get_line(s,i))

                    # Point i _after_ the last character of the method.
                    i += 1
                    if g.is_nl(s,i):
                        i = g.skip_nl(s,i)
                    function_end = i
                    headline = name
                    if outerFlag:
                        leader = "" ; decl_leader = ""
                        if class_seen:
                            headline = "class " + headline
                            methodKind = "classes"
                        else:
                            headline = "interface " + headline
                            methodKind = "interfaces"
                    else:
                        leader = "\t" # Indent only inner references.
                        decl_leader = "\n"  # Declaration leader for inner references.
                        methodKind = "methods"
                    if method_seen:
                        # Include everything after the last fucntion.
                        function_start = scan_start
                    else:
                        save_ip = i
                        i = scan_start
                        while i &lt; function_start and g.is_ws_or_nl(s,i):
                            i += 1

                        if outerFlag:
                            c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language java\n")

                        if i &lt; function_start:
                            decl_headline = g.angleBrackets(" " + self.methodName + " declarations ")

                            # Append the headline to the parent's body.
                            c.appendStringToBody(parent,decl_leader + leader + decl_headline + "\n")
                            scan_start = g.find_line_start(s,scan_start) # Backtrack so we remove leading whitespace.
                            decls = s[scan_start:function_start]
                            decls = self.undentBody(decls)
                            body = g.choose(self.treeType == "@file",decls,"@code\n\n" + decls)
                            self.createHeadline(parent,body,decl_headline)

                        i = save_ip
                        scan_start = i
                        if self.treeType == "@file":
                            if outerFlag:
                                c.appendStringToBody(parent,"\n@others\n")
                            else:
                                c.appendStringToBody(parent,"\n\t@others\n")
                        else:
                            kind = g.choose(outerFlag,"classes","methods")
                            ref_name = g.angleBrackets(" " + self.methodName + " " + kind + " ")
                            c.appendStringToBody(parent,leader + ref_name + "\n")
                    if outerFlag: # Create a class.
                        # Backtrack so we remove leading whitespace.
                        function_start = g.find_line_start(s,function_start)
                        body = s[function_start:brace_ip1+1]
                        body = self.massageBody(body,methodKind)
                        v = self.createHeadline(parent,body,headline)
                        # These mark the points in the present function.
                        # g.trace("recursive scan:",g.get_line(s,brace_ip1+ 1))
                        oldMethodName = self.methodName
                        self.methodName = headline
                        self.scanJavaText(s[brace_ip1+1:brace_ip2], # Don't include either brace.
                            v,False) # inner level
                        self.methodName = oldMethodName
                        # Append the brace to the parent.
                        c.appendStringToBody(v,"}")
                        i = brace_ip2 + 1 # Start after the closing brace.
                    else: # Create a method.
                        # Backtrack so we remove leading whitespace.
                        function_start = g.find_line_start(s,function_start)
                        body = s[function_start:function_end]
                        body = self.massageBody(body,methodKind)
                        self.createHeadline(parent,body,headline)
                        i = function_end
                    method_seen = True
                    scan_start = function_start = i # Set the start of the _next_ function.
                    lparen = None ; class_seen = False
                else: i += 1
            elif g.is_c_id(s[i]):
                if g.match_c_word(s,i,"class") or g.match_c_word(s,i,"interface"):
                    if g.match_c_word(s,i,"class"):
                        class_seen = True
                    else:
                        interface_seen = True
                    i = g.skip_c_id(s,i) # Skip the class or interface keyword.
                    i = g.skip_ws_and_nl(s,i)
                    if i &lt; len(s) and g.is_c_id(s[i]):
                        # Remember the class or interface name.
                        j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
                else:
                    j = i ; i = g.skip_c_id(s,i)
                    if not lparen and not class_seen:
                        name = s[j:i] # Remember the name.
            else: i += 1
        # Used by the Java and Pascal scanners.

        i = g.skip_ws_and_nl(s,scan_start)
        if i &lt; len(s):
            c.appendStringToBody(parent,s[scan_start:])
    def scanLuaText (self,s,parent):

        """Minimal Lua scanner - leave it to user to create nodes as they see fit."""

        self.c.setBodyString(parent,"@ignore\n" + "@language lua\n" + self.rootLine + s)
    # Creates a child of parent for each Pascal function definition seen.

    def scanPascalText (self,s,parent):

        c = self.c
        method_seen = False ; methodKind = "methods"
        scan_start = function_start = i = 0
        name = None
        while i &lt; len(s):
            # line = g.get_line(s,i) ; g.trace(line)
            ch = s[i]
            if ch == '{': i = g.skip_pascal_braces(s,i)
            elif ch == '"' or ch == '\'': i = g.skip_pascal_string(s,i)
            elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
            elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
            elif g.is_c_id(s[i]):
                if g.match_c_word(s,i,"begin"):
                    i = g.skip_pascal_begin_end(s,i)
                    if g.match_c_word(s,i,"end"):
                        i = g.skip_c_id(s,i)
                elif (g.match_c_word(s,i,"function")  or g.match_c_word(s,i,"procedure") or
                    g.match_c_word(s,i,"constructor") or g.match_c_word(s,i,"destructor")):

                    # line = g.get_line(s,i) ; g.trace(line)

                    start = i
                    i = g.skip_c_id(s,i)
                    i = g.skip_ws_and_nl(s,i)
                    if i &lt; len(s) and g.is_c_id(s[i]):
                        j = i ; i = g.skip_c_id(s,i)
                        while i + 1 &lt; len(s) and s[i] == '.' and g.is_c_id(s[i+1]):
                            i += 1 ; j = i
                            i = g.skip_c_id(s,i)
                        name = s[j:i]
                    else: continue
                    while i &lt; len(s) and s[i] != ';':
                        # The paremeter list may contain "inner" semicolons.
                        if s[i] == '(':
                            i = g.skip_parens(s,i)
                            if g.match(s,i,')'):
                                i += 1
                            else: break
                        else: i += 1
                    if g.match(s,i,';'):
                        i += 1
                    i = g.skip_ws_and_nl(s,i)

                    if g.match_c_word(s,i,"var"):
                        # Skip to the next begin.
                        i = g.skip_c_id(s,i)
                        done = False
                        while i &lt; len(s) and not done:
                            ch = s[i]
                            if ch == '{': i = g.skip_pascal_braces(s,i)
                            elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
                            elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
                            elif g.is_c_id(ch):
                                if g.match_c_word(s,i,"begin"): done = True
                                else: i = g.skip_c_id(s,i)
                            elif ch == '"' or ch == '\'': i = g.skip_pascal_string(s,i)
                            else: i += 1

                    if not g.match_c_word(s,i,"begin"):
                        continue
                    # Skip to the matching end.
                    i = g.skip_pascal_begin_end(s,i)
                    if g.match_c_word(s,i,"end"):
                        i = g.skip_c_id(s,i)
                        i = g.skip_ws_and_nl(s,i)
                        if g.match(s,i,';'):
                            i += 1
                        i = g.skip_ws(s,i)
                        if g.is_nl(s,i):
                            i = g.skip_nl(s,i)
                    else: continue
                    if not method_seen:
                        method_seen = True
                        save_ip = i
                        i = scan_start
                        while i &lt; start and g.is_ws_or_nl(s,i):
                            i += 1
                        if i &lt; start:
                            c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language pascal\n")
                            headline = g.angleBrackets(self.methodName + " declarations ")
                            # Append the headline to the parent's body.
                            c.appendStringToBody(parent,headline + "\n")
                            if self.treeType == "@file":
                                body = s[scan_start:start]
                            else:
                                body = "@code\n\n" + s[scan_start:start]
                            body = self.undentBody(body)
                            self.createHeadline(parent,body,headline)
                        i = save_ip
                        scan_start = i
                        # Append the headline to the parent's body.
                        if self.treeType == "@file":
                            c.appendStringToBody(parent,"@others\n")
                        else:
                            c.appendStringToBody(parent,
                                g.angleBrackets(" " + self.methodName + " methods ") + "\n")
                        function_start = start
                    else: function_start = scan_start
                    # Point i _after_ the last character of the function.
                    i = g.skip_ws(s,i)
                    if g.is_nl(s,i):
                        i = g.skip_nl(s,i)
                    function_end = i
                    headline = name
                    body = s[function_start:function_end]
                    body = self.massageBody(body,methodKind)
                    self.createHeadline(parent,body,headline)
                    scan_start = i
                else: i = g.skip_c_id(s,i)
            else: i += 1
        # Used by the Java and Pascal scanners.

        i = g.skip_ws_and_nl(s,scan_start)
        if i &lt; len(s):
            c.appendStringToBody(parent,s[scan_start:])
    # 08-SEP-2002 DTHEIN: Added for PHP import support.
    #
    # PHP uses both # and // as line comments, and /* */ as block comments

    def scanPHPText (self,s,parent):

        __pychecker__ = 'maxlines=500'

        """Creates a child of parent for each class and function definition seen."""

        c = self.c
        scan_start = 0
        class_start = 0
        function_start = 0
        i = 0
        class_body = ""
        class_node = ""
        phpClassName = re.compile("class\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")
        phpFunctionName = re.compile("function\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")

        # 14-SEP-2002 DTHEIN: added these 2 variables to allow use of @first/last
        startOfCode = s.find("\n") + 1 # this should be the line containing the initial &lt;?php
        endOfCode = s.rfind("?&gt;") # this should be the line containing the last ?&gt;
        # If the file does not begin with &lt;?php or end with ?&gt; then
        # it is simply appended like a generic import would do.

        s.strip() # Remove inadvertent whitespace.

        if (
            not (
                s.startswith("&lt;?P") or
                s.startswith("&lt;?p") or
                s.startswith("&lt;?=") or
                s.startswith("&lt;?\n") or
                s.startswith("&lt;?\r") or
                s.startswith("&lt;? ") or
                s.startswith("&lt;?\t")
            ) or not (
                s.endswith("?&gt;\n") or
                s.endswith("?&gt;\r") or
                s.endswith("?&gt;\r\n")
            )
        ):
            g.es("File seems to be mixed HTML and PHP; importing as plain text file.")
            c.setBodyString(parent,"@ignore\n" + self.rootLine + s)
            return

        # 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
        c.appendStringToBody(parent,"@first ")
        c.appendStringToBody(parent,s[:startOfCode])
        scan_start = i = startOfCode
        while i &lt; endOfCode:
            # line = g.get_line(s,i) ; g.trace(line)
            ch = s[i]
            # These cases skip tokens.
            if ch == '/' or ch == '#':
                if g.match(s,i,"//"):
                    i = g.skip_line(s,i)
                elif g.match(s,i,"#"):
                    i = g.skip_line(s,i)
                elif g.match(s,i,"/*"):
                    i = g.skip_block_comment(s,i)
                else:
                    i += 1
            elif ch == '&lt;':
                if g.match(s,i,"&lt;&lt;&lt;"):
                    i = g.skip_heredoc_string(s,i)
                else:
                    i += 1
            elif ch == '"' or ch == '\'':
                i = g.skip_string(s,i)
            # These cases help determine where functions start.
            # FIXME: probably want to capture 'var's as class member data
            elif ch == 'f' or ch =='c':
                # In PHP, all functions are typeless and start with the 
                # keyword "function;  all classes start with the keyword 
                # class.
                # 
                # Functions can be nested, but we don't handle that right now 
                # (I don't think it is a common practice anyway).
                if g.match(s,i,"function "):
                    #we want to make the function a subnode of either the @file node or a class node
                    # 1. get the function name
                    # 2. make a reference in the parent
                    # 3. create the child node, and dump the function in it.
                    function_start = i
                    m = phpFunctionName.match(s[i:])
                    if (None == m): # function keyword without function name
                        i += len("function ")
                    else:
                        headline = g.angleBrackets(" function " + m.group(1) + " ")
                        # find the end of the function
                        openingBrace = s.find('{',i)
                        function_end = g.skip_php_braces(s,openingBrace)
                        function_end = g.skip_to_end_of_line(s,function_end - 1) + 1 # include the line end
                        # Insert skipped text into parent's body.
                        if class_start:
                            class_body += s[scan_start:function_start]
                        else:
                            c.appendStringToBody(parent,s[scan_start:function_start])
                        # Append the headline to the parent's body.
                        if class_start:
                            class_body += (headline + "\n")
                        else:
                            c.appendStringToBody(parent,headline + "\n")
                        # Backup to capture leading whitespace (for undent purposes)
                        while (function_start &gt; 0) and (s[function_start - 1] in [" ", "\t"]):
                            function_start -= 1
                        # Get the body and undent it
                        function_body = s[function_start:function_end]
                        function_body = self.undentBody(function_body)
                        if self.treeType != "@file":
                            function_body = "@code\n\n" + function_body
                        # Create the new node
                        if class_start:
                            self.createHeadline(class_node,function_body,headline)
                        else:
                            self.createHeadline(parent,function_body,headline)
                        i = function_end
                        scan_start = i
                        function_end = 0
                        function_start = 0 #done with this function
                        function_body = ""

                elif g.match(s,i,"class "):
                    # we want to make the class a subnode of the @file node
                    # 1. get the class name
                    # 2. make a reference in the parent
                    # 3. create the child node and dump the function in it
                    class_start = i
                    class_body = ""
                    m = phpClassName.match(s[i:])
                    if (None == m): # class keyword without class name
                        i += len("class ")
                    else:
                        # Insert skipped text into parent's body.
                        c.appendStringToBody(parent,s[scan_start:class_start])
                        # create the headline name
                        headline = g.angleBrackets(" class " + m.group(1) + " ")
                        # find the place to start looking for methods (functions)
                        openingBrace = s.find('{',i)
                        # find the end of the class
                        class_end = g.skip_php_braces(s,openingBrace)
                        class_end = g.skip_to_end_of_line(s,class_end - 1) + 1 # include the line end
                        # Append the headline to the parent's body.
                        c.appendStringToBody(parent,headline + "\n")
                        # Backup to capture leading whitespace (for undent purposes)
                        while (class_start &gt; 0) and (s[class_start - 1] in [" ", "\t"]):
                            class_start -= 1
                        scan_start = class_start
                        # Create the new node
                        class_node = self.createHeadline(parent,"",headline)
                        i = openingBrace

                else:
                    i += 1
            elif class_start and (ch == '}'):
                # Capture the rest of the body
                class_body += s[scan_start:class_end]
                # insert the class node's body
                if self.treeType != "@file":
                    class_body = "@code\n\n" + class_body
                class_body = self.undentBody(class_body)
                c.appendStringToBody(class_node,class_body)
                # reset the indices
                i = class_end
                scan_start = i
                class_end = 0
                class_start = 0 #done with this class
                class_body=""
            else: i += 1
        c.appendStringToBody(parent,s[scan_start:endOfCode])
        # 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
        c.appendStringToBody(parent,"@last ")
        c.appendStringToBody(parent,s[endOfCode:])
 
    def pythonUnitTest (self,p,s,fileName,atAuto=False,strict=False):

        '''
        Run a unit test of the Python parser,
        i.e., create a tree from string s at location p.
        The caller is responsible for asserting properties of the tree.
        '''

        # Duplicate processing in ic command
        ic = self ; c = ic.c
        if fileName.startswith('@test'):
            fileName = fileName[5:].strip()
        junk,ic.fileName = g.os_path_split(fileName)
        ic.methodName,ic.fileType = g.os_path_splitext(ic.fileName)
        ic.setEncoding()

        c.beginUpdate()
        try:
            # Create a child
            child = p.insertAsLastChild()
            assert child
            h = g.choose(atAuto,'@auto ' + fileName,fileName)
            child.initHeadString(h)
            ic.scanPythonText (s=s,parent=child.copy(),atAuto=atAuto,strict=strict)
        finally:
            c.endUpdate()
        if 0:
            g.trace('***** generated tree...')
            for z in p.subtree_iter():
                print '.'*z.level(),z.headString()

        return child
    def scanPythonText (self,s,parent,atAuto=False,strict=False):

        scanner = self.pythonScanner(importCommands=self,atAuto=atAuto,strict=strict)
        scanner.run(s,parent)
    class pythonScanner (baseScannerClass):

        def __init__ (self,importCommands,atAuto,strict):

            importCommands.baseScannerClass.__init__(self,importCommands,
                atAuto=atAuto,
                language='python',
                strict=strict,
            )

            # Set the parser delims.
            self.blockCommentDelim1 = None
            self.blockCommentDelim2 = None
            self.lineCommentDelim = '#'
            self.signatureDelim = ':'
        def extendSignature(self,s,i):

            '''
            Extend the text to added to the class node following the signature.

            The text *must* end with a newline.
            '''

            # Add a docstring to the class node,
            # And everything on the line following it
            j = g.skip_ws_and_nl(s,i)
            if g.match(s,j,'"""') or g.match(s,j,"'''"):
                j = g.skip_python_string(s,j)
                if j &lt; len(s): # No scanning error.
                    # Return the docstring only if nothing but whitespace follows.
                    j = g.skip_ws(s,j)
                    if g.is_nl(s,j):
                        return j + 1

            return i
        def skipClass (self,s,i):
            return self.skipHelper(s,i)

        def skipFunction (self,s,i):
            return self.skipHelper(s,i)
        def skipHelper (self,s,i):

            # g.trace(g.get_line(s,i))

            startIndent = self.getLeadingIndent(s,i)
            i = self.skipSignature(s,i)
            i = g.skip_ws_and_nl(s,i)
            indent = self.getLeadingIndent(s,i)
            parenCount = 0
            while i &lt; len(s):
                progress = i
                ch = s[i]
                if g.is_nl(s,i):
                    backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
                    i = g.skip_nl(s,i)
                    if not backslashNewline:
                        # Don't set indent for comment lines.
                        j = g.skip_ws(s,i)
                        if not g.match(s,j,'#'):
                            indent = self.getLeadingIndent(s,i)
                            if indent &lt;= startIndent and parenCount == 0:
                                break
                elif ch == '#':
                    i = g.skip_to_end_of_line(s,i)
                elif ch == '"' or ch == '\'':
                    i = g.skip_python_string(s,i)
                elif ch in '[{(':
                    i += 1 ; parenCount += 1
                    # g.trace('ch',ch,parenCount)
                elif ch in ']})':
                    i += 1 ; parenCount -= 1
                    # g.trace('ch',ch,parenCount)
                else: i += 1
                assert(progress &lt; i)

            return i
        def skipSignature (self,s,i):

            '''Skip the signature line of a class or function.
            The text must end with a newline.'''

            start = i
            message = 'Warning: improper signature: %s' % g.get_line(s,start)

            # g.trace(g.getLine(s,i))

            # Skip the def or class.
            for tag in ('def','class'):
                if g.match_word(s,i,tag):
                    i += len(tag)
                    break
            else:
                self.error(message)
                return start

            # Skip the class or function name.
            i = g.skip_ws_and_nl(s,i)
            j = g.skip_c_id(s,i)
            if j == i:
                self.error(message)
                return start

            # Skip the optional argument or base-class list.
            i = g.skip_ws_and_nl(s,j)
            if g.match(s,i,'('):
                i = self.skipBlock(s,i,delim1='(',delim2=')')
                i = g.skip_ws_and_nl(s,i)

            if g.match(s,i,self.signatureDelim):
                return g.skip_line(s,i+1)
            else:
                self.error(message)
                return start
        def skipString (self,s,i):

            # Returns len(s) on unterminated string.
            return g.skip_python_string(s,i,verbose=False)
        def startsClass (self,s,i):
            '''Return the class id if s[i:] starts a class definition.'''
            return self.startsHelper(s,i,'class')

        def startsFunction (self,s,i):
            '''Return the function id if s[i:] starts a function definition.'''
            return self.startsHelper(s,i,'def')

        def startsHelper(self,s,i,tag):

            '''Return the id following the tag, or the empty string.'''

            if g.match_word(s,i,tag):
                i += len(tag)
                i = g.skip_ws_and_nl(s,i)
                j = g.skip_c_id(s,i)
                return s[i:j]
            else:
                return ''
    # Headlines not containing a section reference are ignored in noweb and generate index index in cweb.

    def convertCodePartToWeb (self,s,i,v,result):

        # g.trace(g.get_line(s,i))
        c = self.c ; nl = self.output_newline
        lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
        rb = g.choose(self.webType=="cweb","@&gt;","&gt;&gt;")
        h = string.strip(v.headString())
        # We look for either noweb or cweb brackets. head_ref does not include 
        # these brackets.

        head_ref = None
        j = 0
        if g.match(h,j,"&lt;&lt;"):
            k = string.find(h,"&gt;&gt;",j)
        elif g.match(h,j,"&lt;@"):
            k = string.find(h,"@&gt;",j)
        else:
            k = -1

        if k &gt; -1:
            head_ref = string.strip(h[j+2:k])
            if len(head_ref) == 0:
                head_ref = None
        if g.match(h,0,"@file") or g.match(h,0,"@root"):
            line = h[5:]
            line = string.strip(line)
            # set j &amp; k so line[j:k] is the file name.
            # g.trace(line)

            if g.match(line,0,"&lt;"):
                j = 1 ; k = string.find(line,"&gt;",1)
            elif g.match(line,0,'"'):
                j = 1 ; k = string.find(line,'"',1)
            else:
                j = 0 ; k = string.find(line," ",0)
            if k == -1:
                k = len(line)

            file_name = string.strip(line[j:k])
            if file_name and len(file_name) == 0:
                file_name = None
        else:
            file_name = line = None
        if g.match_word(s,i,"@root"):
            i = g.skip_line(s,i)
            if self.webType == "cweb":
                if not file_name:
                    result += "@&lt;root@&gt;=" + nl
                else:
                    result += "@(" + file_name + "@&gt;" + nl # @(...@&gt; denotes a file.
            else:
                if not file_name:
                    file_name = "*"
                result += lb + file_name + rb + "=" + nl
        elif g.match_word(s,i,"@c") or g.match_word(s,i,"@code"):
            i = g.skip_line(s,i)
            if self.webType == "cweb":
                if not head_ref:
                    result += "@^" + h + "@&gt;" + nl # Convert the headline to an index entry.
                    result += "@c" + nl # @c denotes a new section.
                else: 
                    escaped_head_ref = string.replace(head_ref,"@","@@")
                    result += "@&lt;" + escaped_head_ref + "@&gt;=" + nl
            else:
                if not head_ref:
                    if v == c.currentVnode():
                        head_ref = g.choose(file_name,file_name,"*")
                    else:
                        head_ref = "@others"

                result += lb + head_ref + rb + "=" + nl
        elif g.match_word(h,0,"@file"):
            # Only do this if nothing else matches.
            if self.webType == "cweb":
                if not file_name:
                    result += "@&lt;root@&gt;=" + nl
                else:
                    result += "@(" + file_name + "@&gt;" + nl # @(...@&gt; denotes a file.
            else:
                if not file_name:
                    file_name = "*"
                result += lb + file_name + rb + "=" + nl
            i = g.skip_line(s,i) # 4/28/02
        else:
            if self.webType == "cweb":
                if not head_ref:
                    result += "@^" + h + "@&gt;" + nl # Convert the headline to an index entry.
                    result += "@c" + nl # @c denotes a new section.
                else: 
                    escaped_head_ref = string.replace(head_ref,"@","@@")
                    result += "@&lt;" + escaped_head_ref + "@&gt;=" + nl
            else:
                if not head_ref:
                    if v == c.currentVnode():
                        head_ref = g.choose(file_name,file_name,"*")
                    else:
                        head_ref = "@others"

                result += lb + head_ref + rb + "=" + nl
        i,result = self.copyPart(s,i,result)
        return i, string.strip(result) + nl

    # %defs a b c
    def convertDocPartToWeb (self,s,i,result):

        nl = self.output_newline

        # g.trace(g.get_line(s,i))
        if g.match_word(s,i,"@doc"):
            i = g.skip_line(s,i)
        elif g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@*"):
            i += 2
        elif g.match(s,i,"@\n"):
            i += 1
        i = g.skip_ws_and_nl(s,i)
        i, result2 = self.copyPart(s,i,"")
        if len(result2) &gt; 0:
            # Break lines after periods.
            result2 = string.replace(result2,".  ","." + nl)
            result2 = string.replace(result2,". ","." + nl)
            result += nl+"@"+nl+string.strip(result2)+nl+nl
        else:
            # All nodes should start with '@', even if the doc part is empty.
            result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
        return i, result
    # This code converts a vnode to noweb text as follows:
    # 
    # Convert @doc to @
    # Convert @root or @code to &lt; &lt; name &gt; &gt;=, assuming the headline contains 
    # &lt; &lt; name &gt; &gt;
    # Ignore other directives
    # Format doc parts so they fit in pagewidth columns.
    # Output code parts as is.

    def convertVnodeToWeb (self,v):

        c = self.c
        if not v or not c: return ""
        startInCode = not c.config.at_root_bodies_start_in_doc_mode
        nl = self.output_newline
        s = v.bodyString()
        lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
        i = 0 ; result = "" ; docSeen = False
        while i &lt; len(s):
            progress = i
            # g.trace(g.get_line(s,i))
            i = g.skip_ws_and_nl(s,i)
            if self.isDocStart(s,i) or g.match_word(s,i,"@doc"):
                i,result = self.convertDocPartToWeb(s,i,result)
                docSeen = True
            elif (g.match_word(s,i,"@code") or g.match_word(s,i,"@root") or
                g.match_word(s,i,"@c") or g.match(s,i,lb)):
                if not docSeen:
                    docSeen = True
                    result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
                i,result = self.convertCodePartToWeb(s,i,v,result)
            elif self.treeType == "@file" or startInCode:
                if not docSeen:
                    docSeen = True
                    result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
                i,result = self.convertCodePartToWeb(s,i,v,result)
            else:
                i,result = self.convertDocPartToWeb(s,i,result)
                docSeen = True
            assert(progress &lt; i)
        result = string.strip(result)
        if len(result) &gt; 0:
            result += nl
        return result
    # Copies characters to result until the end of the present section is seen.

    def copyPart (self,s,i,result):

        # g.trace(g.get_line(s,i))
        lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
        rb = g.choose(self.webType=="cweb","@&gt;","&gt;&gt;")
        theType = self.webType
        while i &lt; len(s):
            progress = j = i # We should be at the start of a line here.
            i = g.skip_nl(s,i) ; i = g.skip_ws(s,i)
            if self.isDocStart(s,i):
                return i, result
            if (g.match_word(s,i,"@doc") or
                g.match_word(s,i,"@c") or
                g.match_word(s,i,"@root") or
                g.match_word(s,i,"@code")): # 2/25/03
                return i, result
            elif (g.match(s,i,"&lt;&lt;") and # must be on separate lines.
                g.find_on_line(s,i,"&gt;&gt;=") &gt; -1):
                return i, result
            else:
                # Copy the entire line, escaping '@' and
                # Converting @others to &lt; &lt; @ others &gt; &gt;
                i = g.skip_line(s,j) ; line = s[j:i]
                if theType == "cweb":
                    line = string.replace(line,"@","@@")
                else:
                    j = g.skip_ws(line,0)
                    if g.match(line,j,"@others"):
                        line = string.replace(line,"@others",lb + "@others" + rb)
                    elif g.match(line,0,"@"):
                        # Special case: do not escape @ %defs.
                        k = g.skip_ws(line,1)
                        if not g.match(line,k,"%defs"):
                            line = "@" + line
                result += line
            assert(progress &lt; i)
        return i, string.rstrip(result)
    def exportHeadlines (self,fileName):

        c = self.c ; nl = self.output_newline
        p = c.currentPosition()
        if not p: return
        self.setEncoding()
        firstLevel = p.level()
        mode = c.config.output_newline
        mode = g.choose(mode=="platform",'w','wb')
        try:
            theFile = open(fileName,mode)
        except IOError:
            g.es("Can not open " + fileName,color="blue")
            leoTest.fail()
            return
        for p in p.self_and_subtree_iter():
            head = p.moreHead(firstLevel,useVerticalBar=True)
            head = g.toEncodedString(head,self.encoding,reportErrors=True)
            theFile.write(head + nl)
        theFile.close()
    def flattenOutline (self,fileName):

        c = self.c ; nl = self.output_newline
        p = c.currentVnode()
        if not p: return
        self.setEncoding()
        firstLevel = p.level()

        # 10/14/02: support for output_newline setting.
        mode = c.config.output_newline
        mode = g.choose(mode=="platform",'w','wb')
        try:
            theFile = open(fileName,mode)
        except IOError:
            g.es("Can not open " + fileName,color="blue")
            leoTest.fail()
            return

        for p in p.self_and_subtree_iter():
            head = p.moreHead(firstLevel)
            head = g.toEncodedString(head,self.encoding,reportErrors=True)
            theFile.write(head + nl)
            body = p.moreBody() # Inserts escapes.
            if len(body) &gt; 0:
                body = g.toEncodedString(body,self.encoding,reportErrors=True)
                theFile.write(body + nl)
        theFile.close()
    def outlineToWeb (self,fileName,webType):

        c = self.c ; nl = self.output_newline
        current = c.currentPosition()
        if not current: return
        self.setEncoding()
        self.webType = webType
        # 10/14/02: support for output_newline setting.
        mode = c.config.output_newline
        mode = g.choose(mode=="platform",'w','wb')
        try:
            theFile = open(fileName,mode)
        except IOError:
            g.es("Can not open " + fileName,color="blue")
            leoTest.fail()
            return

        self.treeType = "@file"
        # Set self.treeType to @root if p or an ancestor is an @root node.
        for p in current.parents_iter():
            flag,junk = g.is_special(p.bodyString(),0,"@root")
            if flag:
                self.treeType = "@root"
                break
        for p in current.self_and_subtree_iter():
            s = self.convertVnodeToWeb(p)
            if len(s) &gt; 0:
                s = g.toEncodedString(s,self.encoding,reportErrors=True)
                theFile.write(s)
                if s[-1] != '\n': theFile.write(nl)
        theFile.close()
    def removeSentinelsCommand (self,paths):

        c = self.c

        self.setEncoding()

        for fileName in paths:
            g.setGlobalOpenDir(fileName)
            path, self.fileName = g.os_path_split(fileName)
            try:
                theFile = open(fileName)
                s = theFile.read()
                s = g.toUnicode(s,self.encoding)
                theFile.close()
            except IOError:
                g.es("can not open " + fileName, color="blue")
                leoTest.fail()
                return
            # Skip any non @+leo lines.
            i = 0
            while i &lt; len(s) and not g.find_on_line(s,i,"@+leo"):
                i = g.skip_line(s,i)

            # Get the comment delims from the @+leo sentinel line.
            at = self.c.atFileCommands
            j = g.skip_line(s,i) ; line = s[i:j]

            valid,new_df,start_delim,end_delim,derivedFileIsThin = at.parseLeoSentinel(line)
            if not valid:
                g.es("invalid @+leo sentinel in " + fileName)
                return

            if end_delim:
                line_delim = None
            else:
                line_delim,start_delim = start_delim,None
            # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
            s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
            ext = c.config.remove_sentinels_extension
            if not ext:
                ext = ".txt"
            if ext[0] == '.':
                newFileName = g.os_path_join(path,fileName+ext)
            else:
                head,ext2 = g.os_path_splitext(fileName) 
                newFileName = g.os_path_join(path,head+ext+ext2)
            try:
                mode = c.config.output_newline
                mode = g.choose(mode=="platform",'w','wb')
                theFile = open(newFileName,mode)
                s = g.toEncodedString(s,self.encoding,reportErrors=True)
                theFile.write(s)
                theFile.close()
                if not g.unitTesting:
                    g.es("created: " + newFileName)
            except:
                g.es("exception creating: " + newFileName)
                g.es_exception()
    # This does not handle @nonl properly, but that's a nit...

    def removeSentinelLines(self,s,line_delim,start_delim,end_delim):

        '''Properly remove all sentinle lines in s.'''

        __pychecker__ = '--no-argsused' # end_delim.

        delim = (line_delim or start_delim or '') + '@'
        verbatim = delim + 'verbatim' ; verbatimFlag = False
        result = [] ; lines = g.splitLines(s)
        for line in lines:
            i = g.skip_ws(line,0)
            if not verbatimFlag and g.match(line,i,delim):
                if g.match(line,i,verbatim):
                    verbatimFlag = True # Force the next line to be in the result.
                # g.trace(repr(line))
            else:
                result.append(line)
                verbatimFlag = False
        result = ''.join(result)
        return result
    def weave (self,filename):

        c = self.c ; nl = self.output_newline
        p = c.currentPosition()
        if not p: return
        self.setEncoding()
        try:
            # 10/14/02: support for output_newline setting.
            mode = c.config.output_newline
            mode = g.choose(mode=="platform",'w','wb')
            f = open(filename,mode)
            if not f: return
        except:
            g.es("exception opening:" + filename)
            g.es_exception()
            return
        for p in p.self_and_subtree_iter():
            s = p.bodyString()
            s2 = string.strip(s)
            if s2 and len(s2) &gt; 0:
                f.write("-" * 60) ; f.write(nl)
                # write the headlines of p, p's parent and p's grandparent.
                context = [] ; p2 = p.copy() ; i = 0
                while i &lt; 3:
                    i += 1
                    if not p2: break
                    context.append(p2.headString())
                    p2.moveToParent()

                context.reverse()
                indent = ""
                for line in context:
                    f.write(indent)
                    indent += '\t'
                    line = g.toEncodedString(line,self.encoding,reportErrors=True)
                    f.write(line)
                    f.write(nl)
                f.write("-" * 60) ; f.write(nl)
                s = g.toEncodedString(s,self.encoding,reportErrors=True)
                f.write(string.rstrip(s) + nl)
        f.flush()
        f.close()
    def createHeadline (self,parent,body,headline):

        # g.trace("parent,headline:",parent,headline)
        # Create the vnode.
        v = parent.insertAsLastChild()
        v.initHeadString(headline,self.encoding)
        # Set the body.
        if len(body) &gt; 0:
            self.c.setBodyString(v,body,self.encoding)
        return v
    def error (self,s): g.es(s)
    def getLeadingIndent (self,s,i):

        """Return the leading whitespace of a line, ignoring blank and comment lines."""

        i = g.find_line_start(s,i)
        while i &lt; len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i) # Bug fix: 2/14/03
            if g.is_nl(s,j) or g.match(s,j,"#"): # Bug fix: 2/14/03
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                # g.trace("returns:",width)
                return width
        # g.trace("returns:0")
        return 0
    # The start of a document part or module in a noweb or cweb file.
    # Exporters may have to test for @doc as well.

    def isDocStart (self,s,i):

        if not g.match(s,i,"@"):
            return False

        j = g.skip_ws(s,i+1)
        if g.match(s,j,"%defs"):
            return False
        elif self.webType == "cweb" and g.match(s,i,"@*"):
            return True
        else:
            return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

    def isModuleStart (self,s,i):

        if self.isDocStart(s,i):
            return True
        else:
            return self.webType == "cweb" and (
                g.match(s,i,"@c") or g.match(s,i,"@p") or
                g.match(s,i,"@d") or g.match(s,i,"@f"))
    def massageBody (self,s,methodKind):

        # g.trace(s)
        # g.trace(g.get_line(s,0))
        c = self.c
        if self.treeType == "@file":
            if self.fileType == ".py": # 7/31/02: was "py"
                return self.undentBody(s)
            else:
                newBody, comment = self.skipLeadingComments(s)
                newBody = self.undentBody(newBody)
                newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
                if len(comment) &gt; 0:
                    return comment + "\n@c" + newLine + newBody
                else:
                    return newBody
        else:
            # Inserts &lt; &lt; self.methodName methodKind &gt; &gt; =
            cweb = self.fileType == "c" and not c.use_noweb_flag
            lb = g.choose(cweb,"@&lt;","&lt;&lt;")
            rb = g.choose(cweb,"@&gt;=","&gt;&gt;=")
            intro = lb + " " + self.methodName + " " + methodKind + " " + rb
            if self.fileType == ".py": # 7/31/02: was "py"
                newBody = self.undentBody(s)
                newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
                return intro + newLine + newBody
            else:
                newBody, comment = self.skipLeadingComments(s)
                newBody = self.undentBody(newBody)
                newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
                if len(comment) &gt; 0:
                    return comment + "\n" + intro + newLine + newBody
                else:
                    return intro + newLine + newBody
    def skipLeadingComments (self,s):

        """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

        Returns (body, comment)"""

        # g.trace(g.get_line(s,0))
        s_original = s
        s = s.lstrip()
        i = 0 ; comment = ""
        if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
            while i &lt; len(s):
                if g.match(s,i,"//"): # Handle a C++ comment.
                    while g.match(s,i,'/'):
                        i += 1
                    j = i ; i = g.skip_line(s,i)
                    comment = comment + self.massageComment(s[j:i]) + "\n"
                    # 8/2/02: Preserve leading whitespace for undentBody
                    i = g.skip_ws(s,i)
                    i = g.skip_blank_lines(s,i)
                elif g.match(s,i,"/*"): # Handle a block C comment.
                    j = i + 2 ; i = g.skip_block_comment (s,i)
                    k = g.choose(g.match(s,i-2,"*/"),i-2,i)
                    if self.fileType == ".java":
                        # 8/2/02: a hack: add leading whitespace then remove it.
                        comment = self.undentBody(comment)
                        comment2 = ' ' * 2 + s[j:k]
                        comment2 = self.undentBody(comment2)
                        comment = comment + comment2 + "\n"
                    else:
                        comment = comment + self.massageComment(s[j:k]) + "\n"
                    # 8/2/02: Preserve leading whitespace for undentBody
                    i = g.skip_ws(s,i)
                    i = g.skip_blank_lines(s,i)
                else: break
        elif self.fileType == ".lua":
            while i &lt; len(s):
                if g.match(s,i,"--"): # Handle a Lua line comment.
                    while g.match(s,i,'/'):
                        i += 1
                    j = i ; i = g.skip_line(s,i)
                    comment = comment + self.massageComment(s[j:i]) + "\n"
                    # 8/2/02: Preserve leading whitespace for undentBody
                    i = g.skip_ws(s,i)
                    i = g.skip_blank_lines(s,i)
                else: break
        elif self.fileType == ".pas":
            while i &lt; len(s):
                if g.match(s,i,"//"): # Handle a Pascal line comment.
                    while g.match(s,i,'/'):
                        i += 1
                    j = i ; i = g.skip_line(s,i)
                    comment = comment + self.massageComment(s[j:i]) + "\n"
                    # 8/2/02: Preserve leading whitespace for undentBody
                    i = g.skip_ws(s,i)
                    i = g.skip_blank_lines(s,i)
                elif g.match(s,i,'(*'):
                    j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
                    comment = comment + self.massageComment(s[j:i]) + "\n"
                    # 8/2/02: Preserve leading whitespace for undentBody
                    i = g.skip_ws(s,i)
                    i = g.skip_blank_lines(s,i)
                else: break
        elif self.fileType == ".py":
            while i &lt; len(s) and g.match(s,i,'#'):
                j = i + 1 ; i = g.skip_line(s,i)
                comment = self.undentBody(comment)
                comment = comment + self.massageComment(s[j:i]) + "\n"
                # 8/2/02: Preserve leading whitespace for undentBody
                i = g.skip_ws(s,i)
                i = g.skip_blank_lines(s,i)
        comment = string.strip(comment)
        if len(comment) == 0:
            return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
        elif self.treeType == "@file":
            return s[i:], "@ " + comment
        else:
            return s[i:], "@ " + comment + "\n"
    def massageComment (self,s):

        """Returns s with all runs of whitespace and newlines converted to a single blank.

        Also removes leading and trailing whitespace."""

        # g.trace(g.get_line(s,0))
        s = string.strip(s)
        s = string.replace(s,"\n"," ")
        s = string.replace(s,"\r"," ")
        s = string.replace(s,"\t"," ")
        s = string.replace(s,"  "," ")
        s = string.strip(s)
        return s
    def massageWebBody (self,s):

        theType = self.webType
        lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
        rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")
        i = 0
        while i &lt; len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isDocStart(s,i):
                # Scan to end of the doc part.
                if g.match(s,i,"@ %def"):
                    # Don't remove the newline following %def
                    i = g.skip_line(s,i) ; start = end = i
                else:
                    start = end = i ; i += 2
                while i &lt; len(s):
                    progress2 = i
                    i = g.skip_ws_and_nl(s,i)
                    if self.isModuleStart(s,i) or g.match(s,i,lb):
                        end = i ; break
                    elif theType == "cweb": i += 1
                    else: i = g.skip_to_end_of_line(s,i)
                    assert (i &gt; progress2)
                # Remove newlines from start to end.
                doc = s[start:end]
                doc = string.replace(doc,"\n"," ")
                doc = string.replace(doc,"\r","")
                doc = string.strip(doc)
                if doc and len(doc) &gt; 0:
                    if doc == "@":
                        doc = g.choose(self.webType=="cweb", "@ ","@\n")
                    else:
                        doc += "\n\n"
                    # g.trace("new doc:",doc)
                    s = s[:start] + doc + s[end:]
                    i = start + len(doc)
            else: i = g.skip_line(s,i)
            assert (i &gt; progress)
        i = 0
        while i &lt; len(s):
            progress = i
            # g.trace(g.get_line(s,i))
            if g.match(s,i,lb):
                i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
                if k &gt; -1:
                    name = s[j:k]
                    name2 = self.cstLookup(name)
                    if name != name2:
                        # Replace name by name2 in s.
                        # g.trace("replacing %s by %s" % (name,name2))
                        s = s[:j] + name2 + s[k:]
                        i = j + len(name2)
            i = g.skip_line(s,i)
            assert (i &gt; progress)
        s = string.rstrip(s)
        return s
    def setEncoding (self):

        # scanDirectives checks the encoding: may return None.
        theDict = g.scanDirectives(self.c)
        encoding = theDict.get("encoding")
        if encoding and g.isValidEncoding(encoding):
            self.encoding = encoding
        else:
            self.encoding = g.app.tkEncoding # 2/25/03

        # print self.encoding
    # We look at the first line to determine how much leading whitespace to delete.

    def undentBody (self,s):

        """Removes extra leading indentation from all lines."""

        # g.trace(s)
        i = 0 ; result = ""
        # Copy an @code line as is.
        if g.match(s,i,"@code"):
            j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
            result += s[j:i]
        # Calculate the amount to be removed from each line.
        undent = self.getLeadingIndent(s,i)
        if undent == 0: return s
        while i &lt; len(s):
            j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
            line = s[j:i]
            # g.trace(line)
            line = g.removeLeadingWhitespace(line,undent,self.tab_width)
            result += line
        return result

class leoImportCommands (baseLeoImportCommands):
    """A class that implements Leo's import commands."""
    pass  # This is a test.
</t>
<t tx="ekr.20071105090148.115">def callers (n=8,excludeCaller=True,files=False):

    '''Return a list containing the callers of the function that called g.callers.

    If the files keyword argument is True, filenames are included in the list.
    '''

    # sys._getframe throws ValueError in both cpython and jython if there are less than i entries.
    # The jython stack often has less than 8 entries,
    # so we must be careful to call g._callerName with smaller values of i first.
    result = []
    i = g.choose(excludeCaller,3,2)
    while 1:
        s = g._callerName(i,files=files)
        if s:
            result.append(s)
        if not s or len(result) &gt;= n: break
        i += 1

    result.reverse()
    sep = g.choose(files,'\n',',')
    return sep.join(result)
    
</t>
<t tx="ekr.20071105090148.116">@language python

# comment
'string''abdd'
    
if a == b:
    pass
    
a = []

# </t>
<t tx="ekr.20071105090148.117">@language csharp

// csharpfriends.com c# community.

// CLASS1.CS -- Syntax-at-a-Glance for the C# programming language.
// A quick code reference for programmers who work in many languages.
// Executable code, minimal comments document the essence of the language.
// Copyright (C) 2001 StructureByDesign.  All Rights Reserved.

using System;
using System.Collections;
using System.IO;

namespace StructureByDesign.Syntax
{
/********************************************************************/
public class Class1: Object
{
    public static int Main(string[] args)       // Entry point.
    {
        System.Console.WriteLine("Hello");
        Class2 aclass2 = new Class2();
        aclass2.run();
        return 0;
    }
}

/********************************************************************/
interface Interface1
{
    void run();
}

/********************************************************************/
class Class2: Class1, Interface1
{
    public const int CONSTANT = 1;          // Access not restricted, implicitly static.
    private int m_intPrivateField;          // Access limited to containing type.
    //////////////////////////////////////////////////////////////
    public Class2() : base()                // Constructor.
    {
        initialize();
    }
    //////////////////////////////////////////////////////////////
    protected void initialize()             // Object initialization.
    {                                       // Access limited to containing class or types derived.
        Number = 1;
    }
    //////////////////////////////////////////////////////////////
    protected int Number                    // Language property feature.
    {
        get
        {
            return m_intPrivateField;
        }
        set
        {
            m_intPrivateField = value;      // Implicit parameter.
        }
    }
    //////////////////////////////////////////////////////////////
    public void run()
    {
        anonymousCode();
        arrays();
        collections();
        comparison();
        control();
        filesStreamsAndExceptions();
        numbersAndMath();
        primitivesAndConstants();
        runtimeTyping();
        strings();
    }
    //////////////////////////////////////////////////////////////
    void anonymousCode()
    {
        Delegate adelegate = new Delegate(Run);
        adelegate();
    }
    delegate void Delegate();
    void Run()
    {
        Console.WriteLine("Run");
    }
    //////////////////////////////////////////////////////////////
    void arrays()
    {
        int[] arrayOfInts = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        arrayOfInts[0] = 9;
        assert(arrayOfInts[0] == arrayOfInts[9]);

        String[] arrayOfStrings = new String[10];
        assert(arrayOfStrings[0] == null);
        assert(arrayOfStrings.Length == 10);

        arrayOfStrings = new String[] { "one", "two" };

        byte[,] arrayOfBytes = { {0,0,0},
                                 {0,1,2},
                                 {0,2,4}};
        assert(arrayOfBytes[2,2] == 4);
    }
    //////////////////////////////////////////////////////////////
    void collections()
    {
        IList ailist = new ArrayList();
        ailist.Add("zero"); ailist.Add("one"); ailist.Add("three");
        ailist[2] = "two";
        assert(ailist[2].Equals("two"));
        ailist.Remove("two");
        ((ArrayList)ailist).Sort();
        for(IEnumerator aie = ((ArrayList)ailist).GetEnumerator(); aie.MoveNext(); )
            ;
        foreach(String astring in ailist)
            ;

        IDictionary aidictionary = new Hashtable();
        aidictionary.Add("key", "value");
        assert(aidictionary["key"].Equals("value"));

        // Set not available.
    }
    //////////////////////////////////////////////////////////////
    void comparison()
    {
        int aint1 = 1;
        int aint2 = 2;
        int aint = 1;
        String astring1 = "one";
        String astring2 = "two";
        String astring = astring1;

        assert(aint == aint1);
        assert(aint1 != aint2);
        assert(astring == astring1);
        assert(astring1 == String.Copy("one"));         // For strings == is overloaded to compare values.
        assert(!astring1.Equals(astring2));
        assert(astring1.Equals(String.Copy("one")));

        astring = null;
        if (astring != null &amp;&amp; astring.Length &gt; 0)      // Conditional evaluation.
            assert(false);

        if (aint2 &lt; 0 || 1 &lt; aint2)
            assert(true);
    }
    //////////////////////////////////////////////////////////////
    void control()
    {
        if (true)
            assert(true);
        else
            assert(false);
        /////
        switch ('b') {
            case 'a':
                assert(false);
                break;
            case 'b':
                assert(true);
                break;
            default:
                assert(false);
                break;
        }
        /////
        for (int ai1 = 0; ai1 &lt; 10; ai1++)
            assert(true);
        /////
        int ai = 0;
        while (ai &lt; 10) {
            assert(true);
            ai++;
        }
        /////
        do
            ai--;
        while (ai &gt; 0);
        /////
        for (int x = 0; x &lt; 10; x++)        // Labeled break/continue not available.
            for (int y = 0; y &lt; 10; y++)
                if (x == 9)
                    break;
                else
                    continue;
    }
    //////////////////////////////////////////////////////////////
    void filesStreamsAndExceptions()
    {
        FileInfo afileinfo = new FileInfo("list.txt");
        try {
            StreamWriter asw = new StreamWriter("list.txt");
            asw.WriteLine("line");
            asw.WriteLine("line");
            asw.Close();

            assert(afileinfo.Exists);

            StreamReader asr = new StreamReader("list.txt");
            String astringLine;
            while ((astringLine = asr.ReadLine()) != null)
                assert(astringLine.Equals("line"));
            asr.Close();
        } catch (IOException aexception) {
            System.Console.WriteLine(aexception.Message);
            throw new NotSupportedException();
        }
        finally {
            afileinfo.Delete();
        }
    }
    //////////////////////////////////////////////////////////////
    void numbersAndMath()
    {
        assert(Int32.Parse("123") == 123);
        assert(123.ToString().Equals("123"));

        assert(Math.PI.ToString("n3").Equals("3.142"));

        assert(Int32.MaxValue &lt; Int64.MaxValue);

        assert(Math.Abs(Math.Sin(0) - 0) &lt;= Double.Epsilon);
        assert(Math.Abs(Math.Cos(0) - 1) &lt;= Double.Epsilon);
        assert(Math.Abs(Math.Tan(0) - 0) &lt;= Double.Epsilon);

        assert(Math.Abs(Math.Sqrt(4) - 2) &lt;= Double.Epsilon);
        assert(Math.Abs(Math.Pow(3,3) - 27) &lt;= Double.Epsilon);

        assert(Math.Max(0,1) == 1);
        assert(Math.Min(0,1) == 0);

        assert(Math.Abs(Math.Ceiling(9.87) - 10.0) &lt;= Double.Epsilon);
        assert(Math.Abs(Math.Floor(9.87) - 9.0) &lt;= Double.Epsilon);
        assert(Math.Round(9.87) == 10);

        Random arandom = new Random();
        double adouble = arandom.NextDouble();
        assert(0.0 &lt;= adouble &amp;&amp; adouble &lt; 1.0);
        int aint = arandom.Next(10);
        assert(0 &lt;= aint &amp;&amp; aint &lt; 10);
    }
    //////////////////////////////////////////////////////////////
    enum Season: byte { Spring=0, Summer, Fall, Winter };

    void primitivesAndConstants()
    {
        bool abool = false;
        char achar = 'A';           // 16 bits, Unicode

        byte abyte = 0x0;           // 8 bits, unsigned, hex constant
        sbyte asbyte = 0;           // 8 bits, signed

        short ashort = 0;           // 16 bits, signed
        ushort aushort = 0;         // 16 bits, unsigned

        int aint = 0;               // 32 bits, signed
        uint aunit = 0;             // 32 bits, unsigned

        long along = 0L;            // 64 bits, signed
        ulong aulong = 0;           // 64 bits, unsigned

        float afloat = 0.0F;        // 32 bits
        double adouble = 0.0;       // 64 bits

        decimal adecimal = 0;       // 128 bits, financial calculations

        Season aseason = Season.Fall;
        assert((byte)aseason == 2);
    }
    //////////////////////////////////////////////////////////////
    void runtimeTyping()
    {
        assert(new int[] { 1 } is int[]);
        assert(new ArrayList() is ArrayList);

        assert((new ArrayList()).GetType() == typeof(ArrayList));
        assert(typeof(Int32) is Type);      // Type of primitive type.

        assert(Type.GetType("System.Collections.ArrayList") == typeof(ArrayList));
    }
    //////////////////////////////////////////////////////////////
    void strings()
    {
        String astring1 = "one";
        String astring2 = "TWO";

        assert((astring1 + "/" + astring2).Equals("one/TWO"));
        assert(astring2.ToLower().Equals("two"));   // Equals ignoring case not available.
        assert(astring1.Length == 3);
        assert(astring1.Substring(0,2).Equals("on"));
        assert(astring1[2] == 'e');
        assert(astring1.ToUpper().Equals("ONE"));
        assert(astring2.ToLower().Equals("two"));
        assert(astring1.CompareTo("p") &lt; 0);
        assert(astring1.IndexOf('e') == 2);
        assert(astring1.IndexOf("ne") == 1);
        assert(astring1.Trim().Length == astring1.Length);

        assert(Char.IsDigit('1'));
        assert(Char.IsLetter('a'));
        assert(Char.IsWhiteSpace('\t'));
        assert(Char.ToLower('A') == 'a');
        assert(Char.ToUpper('a') == 'A');
    }
    //////////////////////////////////////////////////////////////
    private void assert(bool abool)
    {
        if (!abool)
            throw new Exception("assert failed");
    }
}
// end of namespace.
}

// test</t>
<t tx="ekr.20071105090148.118">print g.app.gui.runAskYesNoCancelDialog(c,'Crash and Burn?','Crash and burn for positive identification?')

</t>
<t tx="ekr.20071105090148.119">@nocolor

A cool feature: In code mode, rST markup in ordinary doc parts will be rendered properly when the show_doc_parts_as_paragraphs option is in effect. Important: Regardless of the show_doc_parts_as_paragraphs option, doc parts have no special significance in rst mode. That is, the entire doc part from the opening '@' to the closing '@c and everything in between are treated normal rST markup.

@color</t>
<t tx="ekr.20071105090148.120">@language c

@others</t>
<t tx="ekr.20071105090148.121"></t>
<t tx="ekr.20071105090148.122">@ @rst-markup

This is my rst comment::

    Literal line 1
    Literal line 2

This should be **bold** and *italic*.
And this line should be part of the same paragraph,
properly filled.
@c

import  sys
</t>
<t tx="ekr.20071105090148.123">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=False
strip_at_file_prefixes=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
show_doc_parts_as_paragraphs = True
@c

test</t>
<t tx="ekr.20071105090148.124"></t>
<t tx="ekr.20071105090148.125"># This is nosent_file_test.py</t>
<t tx="ekr.20071105090148.126">@ @rst-options
code_mode=True
doc_only_mode=False
default_path =
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=False
..stylesheet_path=./
write_intermediate_file = True
verbose=True
show_doc_parts_as_paragraphs=True
show_markup_doc_parts=True
underline_characters = #=+*^~"'`-:&gt;&lt;_
@c

.. code-block::
    
    def spam():
        pass</t>
<t tx="ekr.20071105090148.127">@language c

.. code-block::
    
    int foo ():
        ;
    
    long bar ():
        ;</t>
<t tx="ekr.20071105090148.128">@markup wiki

@
__bold__

~~#80ff00:~~~~#80ff80:this is a test~~

The wiki text must be in the range of an @markup wiki directive **and** in a Leo
doc part (starting with '@') **or** a Python triple-quoted string.

Important: this plugin does not work with the threading colorizer (at present).</t>
<t tx="ekr.20071105090148.129">This is a code block.

.. code-block:: Python
  
  def hello( name ):
    print "Hello,",name
</t>
<t tx="ekr.20071105090148.130"></t>
<t tx="ekr.20071105090148.131">@language python
@tabwidth -4
@others
#changed 2
</t>
<t tx="ekr.20071105090148.132">
import leoGlobals as g
import leoTest # Support for unit tests.

import parser
import re
import string
import tabnanny
import tokenize

</t>
<t tx="ekr.20071105090148.133">class baseLeoImportCommands:
    """The base class for Leo's import commands."""
    @others
</t>
<t tx="ekr.20071105090148.134">def __init__ (self,c):

    self.c = c
    self._forcedGnxPositionList = []
    self.encoding = g.app.tkEncoding # 2/25/03: was "utf-8"
    self.fileName = None # The original file name, say x.cpp
    self.fileType = None # ".py", ".c", etc.
    self.methodName = None # x, as in &lt; &lt; x methods &gt; &gt; =
    self.output_newline = g.getOutputNewline(c=c) # Value of @bool output_newline
    self.rootLine = "" # Empty or @root + self.fileName
    self.tabwidth = c.tab_width # The tab width in effect in the c.currentPosition.
    self.trace = c.config.getBool('trace_import')
    self.treeType = "@file" # "@root" or "@file"
    self.webType = "@noweb" # "cweb" or "noweb"
    self.web_st = [] # noweb symbol table.
</t>
<t tx="ekr.20071105090148.135"># Headlines not containing a section reference are ignored in noweb and generate index index in cweb.

def convertCodePartToWeb (self,s,i,v,result):

    # g.trace(g.get_line(s,i))
    c = self.c ; nl = self.output_newline
    lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(self.webType=="cweb","@&gt;","&gt;&gt;")
    h = string.strip(v.headString())
    # We look for either noweb or cweb brackets. head_ref does not include 
    # these brackets.

    head_ref = None
    j = 0
    if g.match(h,j,"&lt;&lt;"):
        k = string.find(h,"&gt;&gt;",j)
    elif g.match(h,j,"&lt;@"):
        k = string.find(h,"@&gt;",j)
    else:
        k = -1

    if k &gt; -1:
        head_ref = string.strip(h[j+2:k])
        if len(head_ref) == 0:
            head_ref = None
    if g.match(h,0,"@file") or g.match(h,0,"@root"):
        line = h[5:]
        line = string.strip(line)
        # set j &amp; k so line[j:k] is the file name.
        # g.trace(line)

        if g.match(line,0,"&lt;"):
            j = 1 ; k = string.find(line,"&gt;",1)
        elif g.match(line,0,'"'):
            j = 1 ; k = string.find(line,'"',1)
        else:
            j = 0 ; k = string.find(line," ",0)
        if k == -1:
            k = len(line)

        file_name = string.strip(line[j:k])
        if file_name and len(file_name) == 0:
            file_name = None
    else:
        file_name = line = None
    if g.match_word(s,i,"@root"):
        i = g.skip_line(s,i)
        if self.webType == "cweb":
            if not file_name:
                result += "@&lt;root@&gt;=" + nl
            else:
                result += "@(" + file_name + "@&gt;" + nl # @(...@&gt; denotes a file.
        else:
            if not file_name:
                file_name = "*"
            result += lb + file_name + rb + "=" + nl
    elif g.match_word(s,i,"@c") or g.match_word(s,i,"@code"):
        i = g.skip_line(s,i)
        if self.webType == "cweb":
            if not head_ref:
                result += "@^" + h + "@&gt;" + nl # Convert the headline to an index entry.
                result += "@c" + nl # @c denotes a new section.
            else: 
                escaped_head_ref = string.replace(head_ref,"@","@@")
                result += "@&lt;" + escaped_head_ref + "@&gt;=" + nl
        else:
            if not head_ref:
                if v == c.currentVnode():
                    head_ref = g.choose(file_name,file_name,"*")
                else:
                    head_ref = "@others"

            result += lb + head_ref + rb + "=" + nl
    elif g.match_word(h,0,"@file"):
        # Only do this if nothing else matches.
        if self.webType == "cweb":
            if not file_name:
                result += "@&lt;root@&gt;=" + nl
            else:
                result += "@(" + file_name + "@&gt;" + nl # @(...@&gt; denotes a file.
        else:
            if not file_name:
                file_name = "*"
            result += lb + file_name + rb + "=" + nl
        i = g.skip_line(s,i) # 4/28/02
    else:
        if self.webType == "cweb":
            if not head_ref:
                result += "@^" + h + "@&gt;" + nl # Convert the headline to an index entry.
                result += "@c" + nl # @c denotes a new section.
            else: 
                escaped_head_ref = string.replace(head_ref,"@","@@")
                result += "@&lt;" + escaped_head_ref + "@&gt;=" + nl
        else:
            if not head_ref:
                if v == c.currentVnode():
                    head_ref = g.choose(file_name,file_name,"*")
                else:
                    head_ref = "@others"

            result += lb + head_ref + rb + "=" + nl
    i,result = self.copyPart(s,i,result)
    return i, string.strip(result) + nl

</t>
<t tx="ekr.20071105090148.136"># %defs a b c
def convertDocPartToWeb (self,s,i,result):

    nl = self.output_newline

    # g.trace(g.get_line(s,i))
    if g.match_word(s,i,"@doc"):
        i = g.skip_line(s,i)
    elif g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@*"):
        i += 2
    elif g.match(s,i,"@\n"):
        i += 1
    i = g.skip_ws_and_nl(s,i)
    i, result2 = self.copyPart(s,i,"")
    if len(result2) &gt; 0:
        # Break lines after periods.
        result2 = string.replace(result2,".  ","." + nl)
        result2 = string.replace(result2,". ","." + nl)
        result += nl+"@"+nl+string.strip(result2)+nl+nl
    else:
        # All nodes should start with '@', even if the doc part is empty.
        result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
    return i, result
</t>
<t tx="ekr.20071105090148.137"># This code converts a vnode to noweb text as follows:
# 
# Convert @doc to @
# Convert @root or @code to &lt; &lt; name &gt; &gt;=, assuming the headline contains 
# &lt; &lt; name &gt; &gt;
# Ignore other directives
# Format doc parts so they fit in pagewidth columns.
# Output code parts as is.

def convertVnodeToWeb (self,v):

    c = self.c
    if not v or not c: return ""
    startInCode = not c.config.at_root_bodies_start_in_doc_mode
    nl = self.output_newline
    s = v.bodyString()
    lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
    i = 0 ; result = "" ; docSeen = False
    while i &lt; len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i) or g.match_word(s,i,"@doc"):
            i,result = self.convertDocPartToWeb(s,i,result)
            docSeen = True
        elif (g.match_word(s,i,"@code") or g.match_word(s,i,"@root") or
            g.match_word(s,i,"@c") or g.match(s,i,lb)):
            if not docSeen:
                docSeen = True
                result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
            i,result = self.convertCodePartToWeb(s,i,v,result)
        elif self.treeType == "@file" or startInCode:
            if not docSeen:
                docSeen = True
                result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
            i,result = self.convertCodePartToWeb(s,i,v,result)
        else:
            i,result = self.convertDocPartToWeb(s,i,result)
            docSeen = True
        assert(progress &lt; i)
    result = string.strip(result)
    if len(result) &gt; 0:
        result += nl
    return result
</t>
<t tx="ekr.20071105090148.138"># Copies characters to result until the end of the present section is seen.

def copyPart (self,s,i,result):

    # g.trace(g.get_line(s,i))
    lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(self.webType=="cweb","@&gt;","&gt;&gt;")
    theType = self.webType
    while i &lt; len(s):
        progress = j = i # We should be at the start of a line here.
        i = g.skip_nl(s,i) ; i = g.skip_ws(s,i)
        if self.isDocStart(s,i):
            return i, result
        if (g.match_word(s,i,"@doc") or
            g.match_word(s,i,"@c") or
            g.match_word(s,i,"@root") or
            g.match_word(s,i,"@code")): # 2/25/03
            return i, result
        elif (g.match(s,i,"&lt;&lt;") and # must be on separate lines.
            g.find_on_line(s,i,"&gt;&gt;=") &gt; -1):
            return i, result
        else:
            # Copy the entire line, escaping '@' and
            # Converting @others to &lt; &lt; @ others &gt; &gt;
            i = g.skip_line(s,j) ; line = s[j:i]
            if theType == "cweb":
                line = string.replace(line,"@","@@")
            else:
                j = g.skip_ws(line,0)
                if g.match(line,j,"@others"):
                    line = string.replace(line,"@others",lb + "@others" + rb)
                elif g.match(line,0,"@"):
                    # Special case: do not escape @ %defs.
                    k = g.skip_ws(line,1)
                    if not g.match(line,k,"%defs"):
                        line = "@" + line
            result += line
        assert(progress &lt; i)
    return i, string.rstrip(result)
</t>
<t tx="ekr.20071105090148.139">def exportHeadlines (self,fileName):

    c = self.c ; nl = self.output_newline
    p = c.currentPosition()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("Can not open " + fileName,color="blue")
        leoTest.fail()
        return
    for p in p.self_and_subtree_iter():
        head = p.moreHead(firstLevel,useVerticalBar=True)
        head = g.toEncodedString(head,self.encoding,reportErrors=True)
        theFile.write(head + nl)
    theFile.close()
</t>
<t tx="ekr.20071105090148.140">def flattenOutline (self,fileName):

    c = self.c ; nl = self.output_newline
    p = c.currentVnode()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()

    # 10/14/02: support for output_newline setting.
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("Can not open " + fileName,color="blue")
        leoTest.fail()
        return

    for p in p.self_and_subtree_iter():
        head = p.moreHead(firstLevel)
        head = g.toEncodedString(head,self.encoding,reportErrors=True)
        theFile.write(head + nl)
        body = p.moreBody() # Inserts escapes.
        if len(body) &gt; 0:
            body = g.toEncodedString(body,self.encoding,reportErrors=True)
            theFile.write(body + nl)
    theFile.close()
</t>
<t tx="ekr.20071105090148.141">def outlineToWeb (self,fileName,webType):

    c = self.c ; nl = self.output_newline
    current = c.currentPosition()
    if not current: return
    self.setEncoding()
    self.webType = webType
    # 10/14/02: support for output_newline setting.
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("Can not open " + fileName,color="blue")
        leoTest.fail()
        return

    self.treeType = "@file"
    # Set self.treeType to @root if p or an ancestor is an @root node.
    for p in current.parents_iter():
        flag,junk = g.is_special(p.bodyString(),0,"@root")
        if flag:
            self.treeType = "@root"
            break
    for p in current.self_and_subtree_iter():
        s = self.convertVnodeToWeb(p)
        if len(s) &gt; 0:
            s = g.toEncodedString(s,self.encoding,reportErrors=True)
            theFile.write(s)
            if s[-1] != '\n': theFile.write(nl)
    theFile.close()
</t>
<t tx="ekr.20071105090148.142">def removeSentinelsCommand (self,paths,toString=False):

    c = self.c

    self.setEncoding()

    for fileName in paths:
        g.setGlobalOpenDir(fileName)
        path, self.fileName = g.os_path_split(fileName)
        try:
            theFile = open(fileName)
            s = theFile.read()
            s = g.toUnicode(s,self.encoding)
            theFile.close()
        except IOError:
            g.es("can not open " + fileName, color="blue")
            leoTest.fail()
            return
        # Skip any non @+leo lines.
        i = 0
        while i &lt; len(s) and not g.find_on_line(s,i,"@+leo"):
            i = g.skip_line(s,i)

        # Get the comment delims from the @+leo sentinel line.
        at = self.c.atFileCommands
        j = g.skip_line(s,i) ; line = s[i:j]

        valid,new_df,start_delim,end_delim,derivedFileIsThin = at.parseLeoSentinel(line)
        if not valid:
            g.es("invalid @+leo sentinel in " + fileName)
            return

        if end_delim:
            line_delim = None
        else:
            line_delim,start_delim = start_delim,None
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = c.config.remove_sentinels_extension
        if not ext:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        if toString:
            return s
        else:
            try:
                mode = c.config.output_newline
                mode = g.choose(mode=="platform",'w','wb')
                theFile = open(newFileName,mode)
                s = g.toEncodedString(s,self.encoding,reportErrors=True)
                theFile.write(s)
                theFile.close()
                if not g.unitTesting:
                    g.es("created: " + newFileName)
            except:
                g.es("exception creating: " + newFileName)
                g.es_exception()
            return None
</t>
<t tx="ekr.20071105090148.143"># This does not handle @nonl properly, but that's a nit...

def removeSentinelLines(self,s,line_delim,start_delim,end_delim):

    '''Properly remove all sentinle lines in s.'''

    __pychecker__ = '--no-argsused' # end_delim.

    delim = (line_delim or start_delim or '') + '@'
    verbatim = delim + 'verbatim' ; verbatimFlag = False
    result = [] ; lines = g.splitLines(s)
    for line in lines:
        i = g.skip_ws(line,0)
        if not verbatimFlag and g.match(line,i,delim):
            if g.match(line,i,verbatim):
                verbatimFlag = True # Force the next line to be in the result.
            # g.trace(repr(line))
        else:
            result.append(line)
            verbatimFlag = False
    result = ''.join(result)
    return result
</t>
<t tx="ekr.20071105090148.144">def weave (self,filename):

    c = self.c ; nl = self.output_newline
    p = c.currentPosition()
    if not p: return
    self.setEncoding()
    try:
        # 10/14/02: support for output_newline setting.
        mode = c.config.output_newline
        mode = g.choose(mode=="platform",'w','wb')
        f = open(filename,mode)
        if not f: return
    except:
        g.es("exception opening:" + filename)
        g.es_exception()
        return
    for p in p.self_and_subtree_iter():
        s = p.bodyString()
        s2 = string.strip(s)
        if s2 and len(s2) &gt; 0:
            f.write("-" * 60) ; f.write(nl)
            # write the headlines of p, p's parent and p's grandparent.
            context = [] ; p2 = p.copy() ; i = 0
            while i &lt; 3:
                i += 1
                if not p2: break
                context.append(p2.headString())
                p2.moveToParent()

            context.reverse()
            indent = ""
            for line in context:
                f.write(indent)
                indent += '\t'
                line = g.toEncodedString(line,self.encoding,reportErrors=True)
                f.write(line)
                f.write(nl)
            f.write("-" * 60) ; f.write(nl)
            s = g.toEncodedString(s,self.encoding,reportErrors=True)
            f.write(string.rstrip(s) + nl)
    f.flush()
    f.close()
</t>
<t tx="ekr.20071105090148.145">def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)
    # Create the vnode.
    v = parent.insertAsLastChild()
    v.initHeadString(headline,self.encoding)
    # Set the body.
    if len(body) &gt; 0:
        self.c.setBodyString(v,body,self.encoding)
    return v
</t>
<t tx="ekr.20071105090148.146">def error (self,s): g.es(s)
</t>
<t tx="ekr.20071105090148.147">def getTabWidth (self):

    d = g.scanDirectives(self.c)
    w = d.get("tabwidth")
    if w not in (0,None):
        return w
    else:
        return self.c.tab_width
</t>
<t tx="ekr.20071105090148.148"># The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):

    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

</t>
<t tx="ekr.20071105090148.149">def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
</t>
<t tx="ekr.20071105090148.150">def massageComment (self,s):

    '''Returns s with all runs of whitespace and newlines converted to a single blank.

    Also removes leading and trailing whitespace.'''

    # g.trace(g.get_line(s,0))
    s = string.strip(s)
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"\r"," ")
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
</t>
<t tx="ekr.20071105090148.151">def massageWebBody (self,s):

    theType = self.webType
    lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")
    i = 0
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i):
            # Scan to end of the doc part.
            if g.match(s,i,"@ %def"):
                # Don't remove the newline following %def
                i = g.skip_line(s,i) ; start = end = i
            else:
                start = end = i ; i += 2
            while i &lt; len(s):
                progress2 = i
                i = g.skip_ws_and_nl(s,i)
                if self.isModuleStart(s,i) or g.match(s,i,lb):
                    end = i ; break
                elif theType == "cweb": i += 1
                else: i = g.skip_to_end_of_line(s,i)
                assert (i &gt; progress2)
            # Remove newlines from start to end.
            doc = s[start:end]
            doc = string.replace(doc,"\n"," ")
            doc = string.replace(doc,"\r","")
            doc = string.strip(doc)
            if doc and len(doc) &gt; 0:
                if doc == "@":
                    doc = g.choose(self.webType=="cweb", "@ ","@\n")
                else:
                    doc += "\n\n"
                # g.trace("new doc:",doc)
                s = s[:start] + doc + s[end:]
                i = start + len(doc)
        else: i = g.skip_line(s,i)
        assert (i &gt; progress)
    i = 0
    while i &lt; len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        if g.match(s,i,lb):
            i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
            if k &gt; -1:
                name = s[j:k]
                name2 = self.cstLookup(name)
                if name != name2:
                    # Replace name by name2 in s.
                    # g.trace("replacing %s by %s" % (name,name2))
                    s = s[:j] + name2 + s[k:]
                    i = j + len(name2)
        i = g.skip_line(s,i)
        assert (i &gt; progress)
    s = string.rstrip(s)
    return s
</t>
<t tx="ekr.20071105090148.152">def setEncoding (self):

    # scanDirectives checks the encoding: may return None.
    theDict = g.scanDirectives(self.c)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
</t>
<t tx="ekr.20071105090148.153">def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        try:
            theFile = open(fileName)
            s = theFile.read()
            s = g.toUnicode(s,self.encoding)
            theFile.close()
        except IOError:
            g.es("can not open " + fileName)
            leoTest.fail()
            return None

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        p.setTnodeText('')
        # It is too dangerous not to write @auto trees to the .leo file,
        # so we must delete all children here.
        try:
            while p.hasChildren():
                # g.trace('deleting',p.headString())
                p.firstChild().doDelete()
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@file " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext)

    if atAuto: p.contract()
    return p
</t>
<t tx="ekr.20071105090148.154">def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            g.setGlobalOpenDir(fileName)
            fileName = g.os_path_normpath(fileName)

            try:
                theFile = open(fileName,'rb')
                isThin = at.scanHeaderForThin(theFile,fileName)
                theFile.close()
            except IOError:
                isThin = False
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20071105090148.155">def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)
</t>
<t tx="ekr.20071105090148.156">def importFilesCommand (self,files=None,treeType=None,
    perfectImport=True,testing=False,verbose=False):
        # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) &lt; 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    c.beginUpdate()
    try: # range of update...
        if len(files) == 2:
            # The two filenames have a common prefix everything before the 
            # last period is the same.  For example, x.h and x.cpp.

            name0 = files[0]
            name1 = files[1]
            prefix0, junk = g.os_path_splitext(name0)
            prefix1, junk = g.os_path_splitext(name1)
            if len(prefix0) &gt; 0 and prefix0 == prefix1:
                current = current.insertAsLastChild()
                junk, nameExt = g.os_path_split(prefix1)
                name,ext = g.os_path_splitext(prefix1)
                current.initHeadString(name)
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                perfectImport = False ###
                testing = True; verbose = True
                if perfectImport and treeType == "@file": # Can't correct @root trees.
                    self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                else:
                    if not g.unitTesting:
                        g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    finally:
        c.endUpdate()
    c.selectVnode(current)
</t>
<t tx="ekr.20071105090148.157"># Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,firstVnode):
    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

</t>
<t tx="ekr.20071105090148.158"># Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,firstVnode):

    __pychecker__ = '--no-objattrs' # suppress bad warnings re lastVnode.

    c = self.c
    if len(strings) == 0: return None
    if not self.stringsAreValidMoreFile(strings): return None
    c.beginUpdate()
    try: # range of update...
        firstLevel, junk = self.moreHeadlineLevel(strings[0])
        lastLevel = -1 ; theRoot = lastVnode = None
        index = 0
        while index &lt; len(strings):
            progress = index
            s = strings[index]
            level, newFlag = self.moreHeadlineLevel(s)
            level -= firstLevel
            if level &gt;= 0:
                assert(level &gt;= 0)
                if lastVnode is None:
                    # g.trace(firstVnode)
                    theRoot = v = firstVnode.insertAfter()
                elif level == lastLevel:
                    v = lastVnode.insertAfter()
                elif level == lastLevel + 1:
                    v = lastVnode.insertAsNthChild(0)
                else:
                    assert(level &lt; lastLevel)
                    while level &lt; lastLevel:
                        lastLevel -= 1
                        lastVnode = lastVnode.parent()
                        assert(lastVnode)
                        assert(lastLevel &gt;= 0)
                    v = lastVnode.insertAfter()
                lastVnode = v
                lastLevel = level
                j = 0
                while g.match(s,j,'\t'):
                    j += 1
                if g.match(s,j,"+ ") or g.match(s,j,"- "):
                    j += 2

                v.initHeadString(s[j:])
                bodyLines = 0
                index += 1 # Skip the headline.
                while index &lt; len(strings):
                    s = strings[index]
                    level, junk = self.moreHeadlineLevel(s)
                    level -= firstLevel
                    if level &gt;= 0:
                        break
                    # Remove first backslash of the body line.
                    if g.match(s,0,'\\'):
                        strings[index] = s[1:]
                    bodyLines += 1
                    index += 1
                if bodyLines &gt; 0:
                    body = ""
                    n = index - bodyLines
                    while n &lt; index:
                        body += strings[n]
                        if n != index - 1:
                            body += "\n"
                        n += 1
                    v.setTnodeText(body)
                v.setDirty()
            else: index += 1
            assert progress &lt; index
        if theRoot:
            theRoot.setDirty()
            c.setChanged(True)
    finally:
        c.endUpdate()
    return theRoot
</t>
<t tx="ekr.20071105090148.159">def importFlattenedOutline (self,files): # Not a command, so no event arg.

    c = self.c ; u = c.undoer ; current = c.currentPosition()
    if current == None: return
    if len(files) &lt; 1: return

    self.setEncoding()
    fileName = files[0] # files contains at most one file.
    g.setGlobalOpenDir(fileName)
    try:
        theFile = open(fileName)
        s = theFile.read()
        s = string.replace(s,"\r","")
        s = g.toUnicode(s,self.encoding)
        array = string.split(s,"\n")
        theFile.close()
    except IOError:
        g.es("Can not open " + fileName, color="blue")
        leoTest.fail()
        return

    # Convert the string to an outline and insert it after the current node.
    undoData = u.beforeInsertNode(current)
    p = self.convertMoreStringsToOutlineAfter(array,current)
    if p:
        c.endEditing()
        c.validateOutline()
        c.editPosition(p)
        p.setDirty()
        c.setChanged(True)
        u.afterInsertNode(p,'Import',undoData)
    else:
        g.es(fileName + " is not a valid MORE file.")
</t>
<t tx="ekr.20071105090148.160"># return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel (self,s):

    level = 0 ; i = 0
    while g.match(s,i,'\t'):
        level += 1
        i += 1
    plusFlag = g.choose(g.match(s,i,"+"),True,False)
    if g.match(s,i,"+ ") or g.match(s,i,"- "):
        return level, plusFlag
    else:
        return -1, plusFlag
</t>
<t tx="ekr.20071105090148.161"># Used by paste logic.

def stringIsValidMoreFile (self,s):

    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.stringsAreValidMoreFile(strings)

</t>
<t tx="ekr.20071105090148.162">def stringsAreValidMoreFile (self,strings):

    if len(strings) &lt; 1: return False
    level1, plusFlag = self.moreHeadlineLevel(strings[0])
    if level1 == -1: return False
    # Check the level of all headlines.
    i = 0 ; lastLevel = level1
    while i &lt; len(strings):
        s = strings[i] ; i += 1
        level, newFlag = self.moreHeadlineLevel(s)
        if level &gt; 0:
            if level &lt; level1 or level &gt; lastLevel + 1:
                return False # improper level.
            elif level &gt; lastLevel and not plusFlag:
                return False # parent of this node has no children.
            elif level == lastLevel and plusFlag:
                return False # last node has missing child.
            else:
                lastLevel = level
                plusFlag = newFlag
    return True
</t>
<t tx="ekr.20071105090148.163">def createOutlineFromWeb (self,path,parent):

    c = self.c ; u = c.undoer
    junk,fileName = g.os_path_split(path)

    undoData = u.beforeInsertNode(parent)

    # Create the top-level headline.
    p = parent.insertAsLastChild()
    p.initHeadString(fileName)
    if self.webType=="cweb":
        c.setBodyString(p,"@ignore\n" + self.rootLine + "@language cweb")

    # Scan the file, creating one section for each function definition.
    self.scanWebFile(path,p)

    u.afterInsertNode(p,'Import',undoData)

    return p
</t>
<t tx="ekr.20071105090148.164">def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.webType = webType

    c.beginUpdate()
    try:
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutlineFromWeb(fileName,current)
            v.contract()
            v.setDirty()
            c.setChanged(True)
        c.selectVnode(current)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20071105090148.165">def findFunctionDef (self,s,i):

    # Look at the next non-blank line for a function name.
    i = g.skip_ws_and_nl(s,i)
    k = g.skip_line(s,i)
    name = None
    while i &lt; k:
        if g.is_c_id(s[i]):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
        elif s[i] == '(':
            if name: return name
            else: break
        else: i += 1
    return None
</t>
<t tx="ekr.20071105090148.166"># This method returns the proper headline text.
# 
# 1. If s contains a section def, return the section ref.
# 2. cweb only: if s contains @c, return the function name following the 
# @c.
# 3. cweb only: if s contains @d name, returns @d name.
# 4. Otherwise, returns "@"

def scanBodyForHeadline (self,s):

    if self.webType == "cweb":
        i = 0
        while i &lt; len(s):
            i = g.skip_ws_and_nl(s,i)
            # line = g.get_line(s,i) ; g.trace(line)
            # Allow constructs such as @ @c, or @ @&lt;.
            if self.isDocStart(s,i):
                i += 2 ; i = g.skip_ws(s,i)
            if g.match(s,i,"@d") or g.match(s,i,"@f"):
                # Look for a macro name.
                directive = s[i:i+2]
                i = g.skip_ws(s,i+2) # skip the @d or @f
                if i &lt; len(s) and g.is_c_id(s[i]):
                    j = i ; g.skip_c_id(s,i) ; return s[j:i]
                else: return directive
            elif g.match(s,i,"@c") or g.match(s,i,"@p"):
                # Look for a function def.
                name = self.findFunctionDef(s,i+2)
                return g.choose(name,name,"outer function")
            elif g.match(s,i,"@&lt;"):
                # Look for a section def.
                # A small bug: the section def must end on this line.
                j = i ; k = g.find_on_line(s,i,"@&gt;")
                if k &gt; -1 and (g.match(s,k+2,"+=") or g.match(s,k+2,"=")):
                    return s[j:k+2] # return the section ref.
            i = g.skip_line(s,i)
    else:
        i = 0
        while i &lt; len(s):
            i = g.skip_ws_and_nl(s,i)
            # line = g.get_line(s,i) ; g.trace(line)
            if g.match(s,i,"&lt;&lt;"):
                k = g.find_on_line(s,i,"&gt;&gt;=")
                if k &gt; -1:
                    ref = s[i:k+2]
                    name = string.strip(s[i+2:k])
                    if name != "@others":
                        return ref
            else:
                name = self.findFunctionDef(s,i)
                if name:
                    return name
            i = g.skip_line(s,i)
    return "@" # default.
</t>
<t tx="ekr.20071105090148.167">def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")

    try: # Read the file into s.
        f = open(fileName)
        s = f.read()
    except:
        g.es("Can not import " + fileName, color="blue")
        return

    i = 0 ; self.web_st = []

    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        # line = g.get_line(s,i) ; g.trace(line)
        if self.isDocStart(s,i):
            if theType == "cweb": i += 2
            else: i = g.skip_line(s,i)
        elif theType == "cweb" and g.match(s,i,"@@"):
            i += 2
        elif g.match(s,i,lb):
            i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
            if k &gt; -1: self.cstEnter(s[j:k])
        else: i += 1
        assert (i &gt; progress)

    # g.trace(self.cstDump())
    i = 0
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i) or g.match(s,i,lb):
            break
        else: i = g.skip_line(s,i)
        assert(i &gt; progress)

    j = g.skip_ws(s,0)
    if j &lt; i:
        self.createHeadline(parent,"@ " + s[j:i],"Limbo")

    j = i
    if g.match(s,i,lb):
        while i &lt; len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i):
                break
            else: i = g.skip_line(s,i)
            assert(i &gt; progress)
        self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

    # g.trace(g.get_line(s,i))
    while i &lt; len(s):
        outer_progress = i
        if theType=="cweb":
            assert(self.isModuleStart(s,i))
            start = i
            if self.isDocStart(s,i):
                i += 2
                while i &lt; len(s):
                    progress = i
                    i = g.skip_ws_and_nl(s,i)
                    if self.isModuleStart(s,i): break
                    else: i = g.skip_line(s,i)
                    assert (i &gt; progress)
            if g.match(s,i,"@d") or g.match(s,i,"@f"):
                i += 2 ; i = g.skip_line(s,i)
                # Place all @d and @f directives in the same node.
                while i &lt; len(s):
                    progress = i
                    i = g.skip_ws_and_nl(s,i)
                    if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
                    else: break
                    assert (i &gt; progress)
                i = g.skip_ws_and_nl(s,i)

            while i &lt; len(s) and not self.isModuleStart(s,i):
                progress = i
                i = g.skip_line(s,i)
                i = g.skip_ws_and_nl(s,i)
                assert (i &gt; progress)

            if g.match(s,i,"@c") or g.match(s,i,"@p"):
                i += 2
                while i &lt; len(s):
                    progress = i
                    i = g.skip_line(s,i)
                    i = g.skip_ws_and_nl(s,i)
                    if self.isModuleStart(s,i):
                        break
                    assert (i &gt; progress)
        else:
            assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
            start = i ; i = g.skip_line(s,i)
            while i &lt; len(s):
                progress = i
                i = g.skip_ws_and_nl(s,i)
                if self.isDocStart(s,i): break
                else: i = g.skip_line(s,i)
                assert (i &gt; progress)

        body = s[start:i]
        body = self.massageWebBody(body)
        headline = self.scanBodyForHeadline(body)
        self.createHeadline(parent,body,headline)
        assert(i &gt; outer_progress)
</t>
<t tx="ekr.20071105090148.168"># We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.

def cstCanonicalize (self,s,lower=True):

    if lower:
        s = string.lower(s)
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"\r","")
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
</t>
<t tx="ekr.20071105090148.169">def cstDump (self):

    self.web_st.sort()
    s = "Web Symbol Table...\n\n"
    for name in self.web_st:
        s += name + "\n"
    return s
</t>
<t tx="ekr.20071105090148.170"># We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

    # Don't enter names that end in "..."
    s = string.rstrip(s)
    if s.endswith("..."): return

    # Put the section name in the symbol table, retaining capitalization.
    lower = self.cstCanonicalize(s,True)  # do lower
    upper = self.cstCanonicalize(s,False) # don't lower.
    for name in self.web_st:
        if string.lower(name) == lower:
            return
    self.web_st.append(upper)
</t>
<t tx="ekr.20071105090148.171"># This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):

    # Do nothing if the ... convention is not used.
    target = string.strip(target)
    if not target.endswith("..."): return target
    # Canonicalize the target name, and remove the trailing "..."
    ctarget = target[:-3]
    ctarget = self.cstCanonicalize(ctarget)
    ctarget = string.strip(ctarget)
    found = False ; result = target
    for s in self.web_st:
        cs = self.cstCanonicalize(s)
        if cs[:len(ctarget)] == ctarget:
            if found:
                g.es("****** " + target + ": is also a prefix of: " + s)
            else:
                found = True ; result = s
                # g.es("replacing: " + target + " with: " + s)
    return result
</t>
<t tx="ekr.20071105090148.172">def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):

    __pychecker__ = 'maxlines=500'

    # 
    # This algorithm corrects the result of an Import To @file command so 
    # that it is guaranteed that the result of writing the imported file 
    # will be identical to the original file except for any sentinels that 
    # have been inserted.
    # 
    # On entry, p points to the newly imported outline.
    # 
    # We correct the outline by applying Bernhard Mulder's algorithm.
    # 
    # 1.  We use the atFile.write code to write the newly imported outline 
    # to a string s.  This string contains represents a thin derived file, 
    # so it can be used to recreate then entire outline structure without 
    # any other information.
    # 
    # Splitting s into lines creates the fat_lines argument to mu methods.
    # 
    # 2. We make corrections to fat_lines using Mulder's algorithm.  The 
    # corrected fat_lines represents the corrected outline.  To do this, 
    # we set the arguments as follows:
    # 
    # - i_lines: fat_lines stripped of sentinels
    # - j_lines to the lines of the original imported file.
    # 
    # The algorithm updates fat_lines using diffs between i_lines and 
    # j_lines.
    # 
    # 3. Mulder's algorithm doesn't specify which nodes have been 
    # changed.  In fact, it Mulder's algorithm doesn't really understand 
    # nodes at all.  Therefore, if we want to mark changed nodes we do so 
    # by comparing the original version of the imported outline with the 
    # corrected version of the outline.
    c = self.c
    root = p.copy()
    at = c.atFileCommands
    if testing:
        for p2 in p.self_and_subtree_iter():
            p2.clearDirty()
    nodeIndices = g.app.nodeIndices

    nodeIndices.setTimestamp()

    for p2 in root.self_and_subtree_iter():
        try: # Will fail for None or any pre 4.1 file index.
            theId,time,n = p2.v.t.fileIndex
        except TypeError:
            p2.v.t.fileIndex = nodeIndices.getNewIndex()
    at.write(root,thinFile=True,toString=True)
    s = at.stringOutput
    if not s: return

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()

    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 1: # For testing.
            write_lines_node = root.insertAfter()
            write_lines_node.initHeadString("write_lines")
            s = ''.join(write_lines)
            write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)
        # Notes:
        # 1. This code must overwrite the newly-imported tree because the 
        # gnx's in
        # write_lines refer to those nodes.
        # 
        # 2. The code in readEndNode now reports when nodes change during 
        # importing. This
        # code also marks changed nodes.

        try:
            at.correctedLines = 0
            at.targetFileName = "&lt;perfectImport string-file&gt;"
            at.inputFile = fo = g.fileLikeObject()
            at.file = fo # Strange, that this is needed.  Should be cleaned up.
            for line in write_lines:
                fo.write(line)
            firstLines,junk,junk = c.atFileCommands.scanHeader(fo,at.targetFileName)
            # To do: pass params to readEndNode.
            at.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
            n = at.correctedLines
            if verbose:
                g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
        except:
            g.es("Exception in Perfect Import",color="red")
            g.es_exception()
            s = None
    if verify:
        try:
            # Read the original file into before_lines.
            before = file(fileName)
            before_lines = before.readlines()
            before.close()

            # Write the tree into after_lines.
            at.write(root,thinFile=True,toString=True)
            after_lines1 = g.splitLines(at.stringOutput)

            # Strip sentinels from after_lines and compare.
            after_lines = mu.removeSentinelsFromLines(after_lines1,delims)

            # A major kludge: Leo can not represent unindented blank lines in indented nodes!
            # We ignore the problem here by stripping whitespace from blank lines.
            # We shall need output options to handle such lines.
            if convertBlankLines:
                mu.stripWhitespaceFromBlankLines(before_lines)
                mu.stripWhitespaceFromBlankLines(after_lines)
            if before_lines == after_lines:
                if verbose:
                    g.es("Perfect Import verified",color="blue")
            else:
                leoTest.fail()
                if verbose:
                    g.es("Perfect Import failed verification test!",color="red")
                    print len(before_lines),len(after_lines)

                    if len(before_lines)==len(after_lines):
                        for i in xrange(len(before_lines)):
                            extra = 3
                            if before_lines[i] != after_lines[i]:
                                j = max(0,i-extra)
                                print '-' * 20
                                while j &lt; i + extra + 1:
                                    leader = g.choose(i == j,"* ","  ")
                                    print "%s%3d" % (leader,j), repr(before_lines[j])
                                    print "%s%3d" % (leader,j), repr(after_lines[j])
                                    j += 1
                    else:
                        for i in xrange(min(len(before_lines),len(after_lines))):
                            if before_lines[i] != after_lines[i]:
                                extra = 5
                                print "first mismatch at line %d" % i
                                print "printing %d lines after mismatch" % extra
                                print "before..."
                                for j in xrange(i+1+extra):
                                    print "%3d" % j, repr(before_lines[j])
                                print
                                print "after..."
                                for k in xrange(1+extra):
                                    print "%3d" % (i+k), repr(after_lines[i+k])
                                print
                                print "with sentinels"
                                j = 0 ; k = 0
                                while k &lt; i + 1 + extra:
                                    print "%3d" % k,repr(after_lines1[j])
                                    if not g.is_sentinel(after_lines1[j],delims):
                                        k += 1
                                    j += 1
                                break
        except IOError:
            g.es("Can not reopen %s!" % fileName,color="red")
            leoTest.fail()
</t>
<t tx="ekr.20071105090148.173">class baseScannerClass:

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''
    @others
</t>
<t tx="ekr.20071105090148.174">
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = ic.c
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.importCommands = ic
    self.language = language
    self.methodName = ic.methodName # x, as in &lt; &lt; x methods &gt; &gt; =
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigID = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = ic.getTabWidth() # The tab width in effect in the c.currentPosition.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'  

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # Create the ws equivalent to one tab.
    if self.tab_width &lt; 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # May be overridden in subclasses.
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',]
        # tags that start a tag.
    self.functionTags = []
    self.sigTailFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.
    self.strict = False # True if leading whitespace is very significant.
</t>
<t tx="ekr.20071105090148.175">def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    result = self.checkWhitespace(s,parent) and self.checkTrialWrite()
    g.app.unitTestDict ['result'] = result
    return result
</t>
<t tx="ekr.20071105090148.176"># Similar to c.tabNannyNode

def checkTabWithTabNanny (self,p):

    '''Check indentation using tabnanny.'''

    h = p.headString() ; body = p.bodyString()

    try:
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
        return True

    except IndentationError, err:
        # Instances of this class have attributes filename, lineno, offset and text.
        g.es_print('IndentationError in %s at line %d' % (h,err.lineno),color='blue')
        # g.es_print(str(err)) # str(err.text))

    except parser.ParserError, msg:
        g.es_print('ParserError in %s' % h,color='blue')
        g.es_print(str(msg))

    except tokenize.TokenError, msg:
        g.es_print('TokenError in %s' % h,color='blue')
        g.es_print(str(msg))

    except tabnanny.NannyNag, nag:
        badline = nag.get_lineno()
        line    = nag.get_line()
        message = nag.get_msg()
        g.es_print('Indentation error in %s, line %d' % (h, badline),color='blue')
        g.es_print(message)
        g.es_print('offending line:\n%s' % repr(str(line))[1:-1])

    except:
        g.trace('unexpected exception')
        g.es_exception()

    return False
</t>
<t tx="ekr.20071105090148.177">def checkWhitespace(self,s,parent):

    '''Check and normalize the leading whitespace of all nodes.

    - The original sources may fail Python's tabNanny checks.  

    - Leading whitespace in the original sources may be inconsistent with the
      @tabwidth setting in effect in the @auto tree.

    - The original sources may contain underindented comments. 

    If an indentation problem is found, issue a warning and return False.
    Otherwise, normalize the indentation of all pieces so that it is indeed
    consistent with the indentation specified by the present @tabwidth setting.
    Normalizing underindented comments means shifting the comments right.
    '''

    if 1: # Do a quick check for mixed leading tabs/blanks.
        blanks = tabs = 0
        for line in g.splitLines(s):
            lws = line[0:g.skip_ws(line,0)]
            blanks += lws.count(' ')
            tabs += lws.count('\t')
        # g.trace('blanks',blanks,'tabs',tabs)
        ok = blanks == 0 or tabs == 0
        if not ok:
            self.error('File contains intermixed blanks and tabs')
        return ok
    else:
        # Check that whitespace passes TabNanny.
        # Check that whitespace is compatible with @tabwidth.
        # Check for underindented lines.
        ok = True
        for p in parent.self_and_subtree_iter():
            ok = ok and self.checkTabWithTabNanny(p)
        return ok
</t>
<t tx="ekr.20071105090148.178">def checkTrialWrite (self):

    '''Return True if a trial write produces the original file.'''

    c = self.c ; at = c.atFileCommands
    at.write(self.root,
        nosentinels=True,thinFile=False,
        scriptWrite=False,toString=True,
        write_strips_blank_lines=False,
    )

    ignoreBlankLines = True
    s1,s2 = self.file_s, at.stringOutput
    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    ok = True
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok: break

    d = g.app.unitTestDict
    expectedMismatch =  d.get('expectedMismatchLine')
    actualMismatch = d.get('actualMismatchLine')
    ok = ok or (g.app.unitTesting and expectedMismatch == actualMismatch)
    if not ok:
        if g.app.unitTesting:
            g.trace('expected mismatch line',expectedMismatch,'actualMismatch',actualMismatch)
        if len(lines1) &lt; 30:
            print 'input...'
            for i in xrange(len(lines1)):
                print '%3d' % (i),lines1[i],
            print 'output...'
            for i in xrange(len(lines2)):
                print '%3d' % (i),lines2[i],
    return ok
</t>
<t tx="ekr.20071105090148.179">def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i &gt;= len(lines1):
        if i != expectedMismatch:
            print 'extra lines'
            for line in lines2[i:]:
                print repr(line)
        d ['actualMismatchLine'] = i
        return False

    if i &gt;= len(lines2):
        if i != expectedMismatch:
            print 'missing lines'
            for line in lines2[i:]:
                print repr(line)
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # All blank lines compare equal.
    elif not strict and line1.lstrip() == line2.lstrip():
        return True # A match excluding leading whitespace.
    else:
        if i+1 != expectedMismatch:
            print '*** first mismatch at line %d' % (i+1)
            print 'original line: ', repr(line1)
            print 'generated line:', repr(line2)
        d ['actualMismatchLine'] = i+1
        return False
</t>
<t tx="ekr.20071105090148.180"># None of these methods should ever need to be overridden in 
# subclasses.
# 
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
</t>
<t tx="ekr.20071105090148.181">def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20071105090148.182">def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

</t>
<t tx="ekr.20071105090148.183">def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
</t>
<t tx="ekr.20071105090148.184">def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i &lt; len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
</t>
<t tx="ekr.20071105090148.185">def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
</t>
<t tx="ekr.20071105090148.186">def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')
</t>
<t tx="ekr.20071105090148.187">def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
</t>
<t tx="ekr.20071105090148.188">def putClass (self,s,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and children of c for each def in the class.'''

    prefix = self.createClassNodePrefix()
    if not self.sigID:
        g.trace('Can not happen: no sigID')
        sigID = 'Unknown class name'
    class_name = self.sigID
    headline = 'class ' + class_name
    body = s[start:sigEnd]
    body = self.undentBody(body)
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        extend = self.undentBody(extend)
        extend = self.indentBody(extend)
        body = body + extend

    class_node = self.createHeadline(parent,prefix + body,headline)
    savedMethodName = self.methodName
    self.methodName = headline
    self.putClassHelper(s,i,codeEnd,class_name,class_node)
    self.methodName = savedMethodName
</t>
<t tx="ekr.20071105090148.189">def appendRefToClassNode (self,class_name,class_node):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
</t>
<t tx="ekr.20071105090148.190">def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
</t>
<t tx="ekr.20071105090148.191">def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
</t>
<t tx="ekr.20071105090148.192">def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Put any leading decls in the class node.
    trace = False
    start = i
    i = self.skipDecls(s,i,end)
    decls = s[start:i]
    if decls:
        # We must regularize the indentation to match the @others
        decls = self.undentBody(decls)
        decls = self.indentBody(decls)
        if self.trace: g.trace('decls\n%s' % decls)
        # g.trace(class_name,'decls',repr(decls))
        self.appendTextToClassNode(class_node,decls)
    start = i ; putRef = False
    while i &lt; end:
        progress = i
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd &amp; codeEnd ivars.
            putRef = True
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,self.sigStart,self.sigEnd,self.codeEnd,start,class_node)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd &amp; codeEnd ivars.
            putRef = True
            self.putFunction(s,self.sigStart,self.codeEnd,start,class_node)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

    if putRef:
        self.appendRefToClassNode(class_name,class_node)

    if start &lt; end:
        trailing = s[start:end]
        if trace or self.trace: g.trace('trailing\n%s' % trailing)
        self.appendTextToClassNode(class_node,trailing)
</t>
<t tx="ekr.20071105090148.193">def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    if self.sigID:
        headline = self.sigID
    else:
        g.trace('Can not happen: no sigID')
        headline = 'unknown function'

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if self.trace:
        g.trace('body\n%s' % repr(body))
        g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error('function does not end with a newline.  A newline will be added.')
        g.es(g.get_line(s,codeEnd),color='blue')

    self.createFunctionNode(headline,body,parent)
</t>
<t tx="ekr.20071105090148.194">def putRootText (self,p):

    c = self.c

    line1 = g.choose(self.atAuto,'','@ignore\n')

    c.appendStringToBody(p,'%s%s@language %s\n' % (
        line1,self.rootLine,self.language))
</t>
<t tx="ekr.20071105090148.195">def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    #g.trace('before',repr(s))

    # Copy an @code line as is.
    i = 0
    if g.match(s,i,'@code'):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]

    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i,ignoreComments=ignoreComments)
    if undent == 0:
        return s
    else:
        result = ''.join([
            g.removeLeadingWhitespace(line,undent,self.tab_width)
                for line in g.splitLines(s)])
        #g.trace('after',repr(result))
        return result
</t>
<t tx="ekr.20071105090148.196">def underindentedComment (self,line):

    self.error('underindented python comments.\nExtra leading whitespace will be added')
    g.es(line,color='blue')

</t>
<t tx="ekr.20071105090148.197">def underindentedLine (self,line):

    self.error('underindented line.\nExtra leading whitespace will be added')
    g.es(line,color='blue')

</t>
<t tx="ekr.20071105090148.198">def error (self,s):
    g.es_print(s,color='red')
    self.errors += 1
    g.app.unitTestDict['actualErrors'] = self.errors

</t>
<t tx="ekr.20071105090148.199">def oops (self):
    print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()
</t>
<t tx="ekr.20071105090148.200"># Scan and skipDecls would typically not be overridden.
def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
</t>
<t tx="ekr.20071105090148.201">def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''
    i = start = self.skipDecls(s,0,len(s))
    decls = s[:i]
    if decls: self.createDeclsNode(parent,decls)
    needRef = False
    while i &lt; len(s):
        progress = i
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i): # Sets sigStart,sigEnd &amp; codeEnd ivars.
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
            needRef = True
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd &amp; codeEnd ivars.
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))
    self.addRef(parent)
</t>
<t tx="ekr.20071105090148.202">def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i &gt;= len(s):
        return start,False
    else:
        return i,True 
</t>
<t tx="ekr.20071105090148.203">def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i &lt; len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline:
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent &lt; startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 0 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level &lt;= 0: break
        else: i += 1
        assert progress &lt; i

    if trace: g.trace('returns\n',s[start:i])
    return i
</t>
<t tx="ekr.20071105090148.204">def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    i = self.skipBlock(s,i,delim1=None,delim2=None)
    i = self.skipNewline(s,i,kind)

    return i
</t>
<t tx="ekr.20071105090148.205">def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
</t>
<t tx="ekr.20071105090148.206">def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
</t>
<t tx="ekr.20071105090148.207">def skipDecls (self,s,i,end):

    '''Skip everything until the start of the next class or function.'''

    start = i
    while i &lt; end:
        progress = i
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            i = self.adjustClassOrFunctionStart(s,i,'class')
            break
        elif self.startsFunction(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert(progress &lt; i)

    # Ignore empty decls.
    if s[start:i].strip():
        if self.trace: g.trace('\n'+s[start:i])
        return i
    else:
        return start
</t>
<t tx="ekr.20071105090148.208">def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    if s[j:i].strip():
        message = '%s definition does not start a line. Leo must insert a newline.' % tag
        self.error(message)
        return i
    else:
        return j
</t>
<t tx="ekr.20071105090148.209">def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
</t>
<t tx="ekr.20071105090148.210">def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while 1:
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error('%s does not end in a newline.  A newline will be added.' % kind)
        g.es(g.get_line(s,i),color='blue')

    return i
</t>
<t tx="ekr.20071105090148.211">def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
</t>
<t tx="ekr.20071105090148.212">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
</t>
<t tx="ekr.20071105090148.213"># We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i,quick=False):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
    return i

</t>
<t tx="ekr.20071105090148.214">def startsFunction (self,s,i,quick=False):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
    return i
</t>
<t tx="ekr.20071105090148.215">def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''

    trace = False
    self.codeEnd = self.sigEnd = self.sigID = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    i, ids = self.skipSigStart(s,i,tags)
    if tags:
        for id in ids:
            if id in tags:
                break
        else: return False

    if quick: return True

    if trace: g.trace('kind',kind)

    # Get the class/function id
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace: g.trace('no sigId',g.get_line(s,i))
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    # Skip the block.
    i = g.skip_ws_and_nl(s,i)
    if self.blockDelim1 and not g.match(s,i,self.blockDelim1):
        if trace: g.trace('no block',g.get_line(s,i))
        return False

    i = self.skipCodeBlock(s,i,kind)
    # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigID = sigId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if s[self.sigStart:k].strip():
        self.error('%s definition does not start a line' % kind)
        g.es(g.get_line(s,k),color='blue')

    if trace or self.trace: g.trace(kind,'\n'+s[self.sigStart:i])
    return True
</t>
<t tx="ekr.20071105090148.216">def skipSigStart (self,s,i,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    __pychecker__ = '--no-argsused' # tags not used in the base class.

    ids = []
    while 1:
        j = g.skip_ws_and_nl(s,i)
        i = self.skipId(s,j)
        id = s[j:i]
        if id: ids.append(id)
        else: break

    # g.trace(ids)

    return i, ids
</t>
<t tx="ekr.20071105090148.217">def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
</t>
<t tx="ekr.20071105090148.218">def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    while i &lt; len(s) and not g.match(s,i,self.blockDelim1):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.sigTailFailTokens:
            for z in self.failTokens:
                if g.match(s,i,z):
                    return i,False
            else:
                i += 1
        else:
            i += 1

    return i,True
</t>
<t tx="ekr.20071105090148.219">def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
</t>
<t tx="ekr.20071105090148.220">def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
</t>
<t tx="ekr.20071105090148.221">def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
</t>
<t tx="ekr.20071105090148.222">def run (self,s,parent):

    scanner = self
    scanner.root = parent
    scanner.file_s = s

    # Step 1: generate the nodes,
    # including all directive and section references.
    self.errors = 0
    self.errorLines = []
    scanner.scan(s,parent)

    # Step 2: check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)

    # Step 3: insert an @ignore directive if there are any problems.
    if not ok:
        scanner.insertIgnoreDirective(parent)
</t>
<t tx="ekr.20071105090148.223">def scanCText (self,s,parent,atAuto=False):

    scanner = self.cScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071105090148.224">class cScanner (baseScannerClass):
    @others
</t>
<t tx="ekr.20071105090148.225">
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='c')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',]
    self.extraIdChars = ':'
    self.functionTags = []
    sigTailFailTokens = [';','=']
</t>
<t tx="ekr.20071105090148.226">def scanElispText (self,s,parent,atAuto=False):

    scanner = self.elispScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071105090148.227">class elispScanner (baseScannerClass):
    @others
</t>
<t tx="ekr.20071105090148.228">
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

</t>
<t tx="ekr.20071105090148.229"># skipClass/Function/Signature are defined in the base class.
def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
    return False

</t>
<t tx="ekr.20071105090148.230">def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''

    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigID = None
    if not g.match(s,i,'('): return False
    end = self.skipBlock(s,i)
    if not g.match(s,end,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len(key)
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = g.skip_id(s,i)
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
</t>
<t tx="ekr.20071105090148.231">def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
</t>
<t tx="ekr.20071105090148.232">def scanJavaText (self,s,parent,atAuto=False):

    scanner = self.javaScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071105090148.233">class javaScanner (baseScannerClass):
    @others
</t>
<t tx="ekr.20071105090148.234">
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.classTags = ['class','interface',]
</t>
<t tx="ekr.20071105090148.235">def scanPascalText (self,s,parent,atAuto=False):

    scanner = self.pascalScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071105090148.236">class pascalScanner (baseScannerClass):
    @others
</t>
<t tx="ekr.20071105090148.237">
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='pascal')

    # Set the parser delims.
    self.blockCommentDelim1 = '(*'
    self.blockCommentDelim2 = '*)'
    self.lineCommentDelim = '//'
    self.blockDelim1 = 'begin'
    self.blockDelim2 = 'end'
    self.classTags = []
    self.functionTags = ['function','procedure','constructor','destructor',]
</t>
<t tx="ekr.20071105090148.238">def scanPHPText (self,s,parent,atAuto=False):

    scanner = self.phpScanner(importCommands=self,atAuto=atAuto)

    if scanner.isPurePHP(s):
        scanner.run(s,parent)
    else:
        fileName = scanner.fileName
        if not atAuto:
            g.es_print('%s seems to be mixed HTML and PHP.' % fileName)
        scanner.createHeadline(
            parent,body=s,headline=fileName)
</t>
<t tx="ekr.20071105090148.239">class phpScanner (baseScannerClass):
    @others
</t>
<t tx="ekr.20071105090148.240">
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
</t>
<t tx="ekr.20071105090148.241">def isPurePHP (self,s):

    '''Return True if the file begins with &lt;?php or ends with ?&gt;'''

    s = s.strip()

    return (
        s.startswith('&lt;?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?&gt;'))

</t>
<t tx="ekr.20071105090148.242"># Does not create @first/@last nodes
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'&lt;&lt;&lt;')

</t>
<t tx="ekr.20071105090148.243">def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return self.skipString()
    else:
        return g.skip_heredoc_string(s,i)
</t>
<t tx="ekr.20071105090148.244">def scanPythonText (self,s,parent,atAuto=False):

    scanner = self.pythonScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071105090148.245">class pythonScanner (baseScannerClass):
    @others
</t>
<t tx="ekr.20071105090148.246">
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='python')

    # Set the parser delims.
    self.lineCommentDelim = '#'
    self.classTags = ['class',]
    self.functionTags = ['def',]
    self.blockDelim1 = None
        # Suppress the check for the block delim.
        # The check is done in skipSigTail.
    self.blockDelim2 = None
    self.strict = True

</t>
<t tx="ekr.20071105090148.247">def extendSignature(self,s,i):

    '''Extend the text to be added to the class node following the signature.

    The text *must* end with a newline.'''

    # Add a docstring to the class node,
    # And everything on the line following it
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j &lt; len(s): # No scanning error.
            # Return the docstring only if nothing but whitespace follows.
            j = g.skip_ws(s,j)
            if g.is_nl(s,j):
                return j + 1

    return i
</t>
<t tx="ekr.20071105090148.248">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_python_string(s,i,verbose=False)
</t>
<t tx="ekr.20071105090148.249">def skipCodeBlock (self,s,i,kind):

    trace = False
    if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if trace: g.trace(g.get_line(s,i))
            if not backslashNewline:
                i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                    s,i,parenCount,startIndent,underIndentedStart)
                if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress &lt; i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 &lt; i &lt; len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
    if (trace or self.trace) and s[start:i].strip():
        g.trace(g.callers())
        g.trace('\n'+s[start:i])
    return i
</t>
<t tx="ekr.20071105090148.250">def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if indent &lt;= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent &lt;= startIndent:
                        self.underindentedComment(line)
            underIndentedStart = None
    return i,underIndentedStart,breakFlag
</t>
<t tx="ekr.20071105090148.251">def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    # Must override so we can skip the ':' properly and issue better warnings.

    start = i
    while i &lt; len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            break
        elif g.match(s,i,':'):
            i = g.skip_line(s,i+1)
            if self.trace and s[start:i].strip(): g.trace('\n'+s[start:i])
            return i,True
        else:
            i += 1

    self.error('Warning: improper signature: %s' % g.get_line(s,start))
    return start,False
</t>
<t tx="ekr.20071105090148.252">def scanUnknownFileType (self,s,p,ext,atAuto=False):

    c = self.c
    body = g.choose(atAuto,'','@ignore\n')
    if ext in ('.html','.htm'): body += '@language html\n'
    if ext in ('.txt','.text'): body += '@nocolor\n'
    c.setBodyString(p,body + self.rootLine + s)
    g.app.unitTestDict = {'result':True}
</t>
<t tx="ekr.20071105090148.253">def cUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest(p,atAuto=atAuto,fileName=None,s=s,showTree=showTree,ext='.c')

</t>
<t tx="ekr.20071105090148.254">def elispUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.el')

</t>
<t tx="ekr.20071105090148.255">def htmlUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.htm')

</t>
<t tx="ekr.20071105090148.256">def javaUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.java')

</t>
<t tx="ekr.20071105090148.257">def pascalUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.pas')

</t>
<t tx="ekr.20071105090148.258">def phpUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.php')

</t>
<t tx="ekr.20071105090148.259">def pythonUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.py')

</t>
<t tx="ekr.20071105090148.260">def textUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.txt')

</t>
<t tx="ekr.20071105090148.261">def defaultImporterUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,ext='.xxx')
</t>
<t tx="ekr.20071105090148.262">def scannerUnitTest (self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):

    '''Run a unit test of an import scanner,
    i.e., create a tree from string s at location p.'''

    c = self.c
    oldChanged = c.changed
    c.beginUpdate()
    try:
        expectedErrors = g.app.unitTestDict.get('expectedErrors')
        expectedMismatchLine = g.app.unitTestDict.get('expectedMismatchLine')
        g.app.unitTestDict = {
            'expectedErrors':expectedErrors,
            'expectedMismatchLine':expectedMismatchLine,
        }
        if not fileName: fileName = p.headString()
        if not s: s = self.removeSentinelsCommand([fileName],toString=True)
        self.createOutline(fileName,p.copy(),atAuto=False,s=s,ext=ext)
        d = g.app.unitTestDict
        ok = d.get('result') or (
            d.get('actualErrors') == d.get('expectedErrors') and
            d.get('actualMismatchLine') == d.get('expectedMismatchLine'))
        if not ok:
            g.trace('result',d.get('result'),
                'actualErrors',d.get('actualErrors'),
                'expectedErrors',d.get('expectedErrors'),
                'actualMismatchLine',d.get('actualMismatchLine'),
                'expectedMismatchLine', d.get('expectedMismatchLine'),)
        if not showTree and ok:
            while p.hasChildren():
                p.firstChild().doDelete()
            c.setChanged(oldChanged)
    finally:
        c.endUpdate()

    if g.app.unitTesting:
        d = g.app.unitTestDict
        assert d.get('result') or (
            d.get('actualErrors') == d.get('expectedErrors') and
            d.get('actualMismatchLine') == d.get('expectedMismatchLine'))

</t>
<t tx="ekr.20071105090148.263">class leoImportCommands (baseLeoImportCommands):
    """A class that implements Leo's import commands."""
    pass
</t>
<t tx="ekr.20071105090148.264">@language c
@tabwidth -4
@others
@ignore</t>
<t tx="ekr.20071105090148.265">/* 
 * tclDate.c --
 *
 *	This file is generated from a yacc grammar defined in
 *	the file tclGetDate.y.  It should not be edited directly.
 *
 * Copyright (c) 1992-1995 Karl Lehenbauer and Mark Diekhans.
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: oldLeoProjects.leo,v 1.21 2007/12/11 17:42:26 edream Exp $
 */
</t>
<t tx="ekr.20071105090148.266">
#include "tclInt.h"
#include "tclPort.h"

#if defined(MAC_TCL) &amp;&amp; !defined(TCL_MAC_USE_MSL_EPOCH)
#   define EPOCH           1904
#   define START_OF_TIME   1904
#   define END_OF_TIME     2039
#else
#   define EPOCH           1970
#   define START_OF_TIME   1902
#   define END_OF_TIME     2037
#endif

/*
 * The offset of tm_year of struct tm returned by localtime, gmtime, etc.
 * I don't know how universal this is; K&amp;R II, the NetBSD manpages, and
 * ../compat/strftime.c all agree that tm_year is the year-1900.  However,
 * some systems may have a different value.  This #define should be the
 * same as in ../compat/strftime.c.
 */
#define TM_YEAR_BASE 1900

#define HOUR(x)         ((int) (60 * x))
#define SECSPERDAY      (24L * 60L * 60L)
#define IsLeapYear(x)   ((x % 4 == 0) &amp;&amp; (x % 100 != 0 || x % 400 == 0))

/*
 *  An entry in the lexical lookup table.
 */
typedef struct _TABLE {
    char        *name;
    int         type;
    time_t      value;
} TABLE;


/*
 *  Daylight-savings mode:  on, off, or not yet known.
 */
typedef enum _DSTMODE {
    DSTon, DSToff, DSTmaybe
} DSTMODE;

/*
 *  Meridian:  am, pm, or 24-hour style.
 */
typedef enum _MERIDIAN {
    MERam, MERpm, MER24
} MERIDIAN;


/*
 *  Global variables.  We could get rid of most of these by using a good
 *  union as the yacc stack.  (This routine was originally written before
 *  yacc had the %union construct.)  Maybe someday; right now we only use
 *  the %union very rarely.
 */
static char     *TclDateInput;
static DSTMODE  TclDateDSTmode;
static time_t   TclDateDayOrdinal;
static time_t   TclDateDayNumber;
static time_t   TclDateMonthOrdinal;
static int      TclDateHaveDate;
static int      TclDateHaveDay;
static int      TclDateHaveOrdinalMonth;
static int      TclDateHaveRel;
static int      TclDateHaveTime;
static int      TclDateHaveZone;
static time_t   TclDateTimezone;
static time_t   TclDateDay;
static time_t   TclDateHour;
static time_t   TclDateMinutes;
static time_t   TclDateMonth;
static time_t   TclDateSeconds;
static time_t   TclDateYear;
static MERIDIAN TclDateMeridian;
static time_t   TclDateRelMonth;
static time_t   TclDateRelDay;
static time_t   TclDateRelSeconds;
static time_t  *TclDateRelPointer;

/*
 * Prototypes of internal functions.
 */
static void	TclDateerror _ANSI_ARGS_((char *s));
static time_t	ToSeconds _ANSI_ARGS_((time_t Hours, time_t Minutes,
		    time_t Seconds, MERIDIAN Meridian));
static int	Convert _ANSI_ARGS_((time_t Month, time_t Day, time_t Year,
		    time_t Hours, time_t Minutes, time_t Seconds,
		    MERIDIAN Meridia, DSTMODE DSTmode, time_t *TimePtr));
static time_t	DSTcorrect _ANSI_ARGS_((time_t Start, time_t Future));
static time_t	NamedDay _ANSI_ARGS_((time_t Start, time_t DayOrdinal,
		    time_t DayNumber));
static time_t   NamedMonth _ANSI_ARGS_((time_t Start, time_t MonthOrdinal,
                    time_t MonthNumber));
static int	RelativeMonth _ANSI_ARGS_((time_t Start, time_t RelMonth,
		    time_t *TimePtr));
static int	RelativeDay _ANSI_ARGS_((time_t Start, time_t RelDay,
		    time_t *TimePtr));
static int	LookupWord _ANSI_ARGS_((char *buff));
static int	TclDatelex _ANSI_ARGS_((void));

int
TclDateparse _ANSI_ARGS_((void));
typedef union
#ifdef __cplusplus
	YYSTYPE
#endif
 {
    time_t              Number;
    enum _MERIDIAN      Meridian;
} YYSTYPE;
# define tAGO 257
# define tDAY 258
# define tDAYZONE 259
# define tID 260
# define tMERIDIAN 261
# define tMINUTE_UNIT 262
# define tMONTH 263
# define tMONTH_UNIT 264
# define tSTARDATE 265
# define tSEC_UNIT 266
# define tSNUMBER 267
# define tUNUMBER 268
# define tZONE 269
# define tEPOCH 270
# define tDST 271
# define tISOBASE 272
# define tDAY_UNIT 273
# define tNEXT 274




#if defined(__cplusplus) || defined(__STDC__)

#if defined(__cplusplus) &amp;&amp; defined(__EXTERN_C__)
extern "C" {
#endif
#ifndef TclDateerror
#if defined(__cplusplus)
	void TclDateerror(CONST char *);
#endif
#endif
#ifndef TclDatelex
	int TclDatelex(void);
#endif
	int TclDateparse(void);
#if defined(__cplusplus) &amp;&amp; defined(__EXTERN_C__)
}
#endif

#endif

#define TclDateclearin TclDatechar = -1
#define TclDateerrok TclDateerrflag = 0
extern int TclDatechar;
extern int TclDateerrflag;
YYSTYPE TclDatelval;
YYSTYPE TclDateval;
typedef int TclDatetabelem;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
#if YYMAXDEPTH &gt; 0
int TclDate_TclDates[YYMAXDEPTH], *TclDates = TclDate_TclDates;
YYSTYPE TclDate_TclDatev[YYMAXDEPTH], *TclDatev = TclDate_TclDatev;
#else	/* user does initial allocation */
int *TclDates;
YYSTYPE *TclDatev;
#endif
static int TclDatemaxdepth = YYMAXDEPTH;
# define YYERRCODE 256


/*
 * Month and day table.
 */
static TABLE    MonthDayTable[] = {
    { "january",        tMONTH,  1 },
    { "february",       tMONTH,  2 },
    { "march",          tMONTH,  3 },
    { "april",          tMONTH,  4 },
    { "may",            tMONTH,  5 },
    { "june",           tMONTH,  6 },
    { "july",           tMONTH,  7 },
    { "august",         tMONTH,  8 },
    { "september",      tMONTH,  9 },
    { "sept",           tMONTH,  9 },
    { "october",        tMONTH, 10 },
    { "november",       tMONTH, 11 },
    { "december",       tMONTH, 12 },
    { "sunday",         tDAY, 0 },
    { "monday",         tDAY, 1 },
    { "tuesday",        tDAY, 2 },
    { "tues",           tDAY, 2 },
    { "wednesday",      tDAY, 3 },
    { "wednes",         tDAY, 3 },
    { "thursday",       tDAY, 4 },
    { "thur",           tDAY, 4 },
    { "thurs",          tDAY, 4 },
    { "friday",         tDAY, 5 },
    { "saturday",       tDAY, 6 },
    { NULL }
};

/*
 * Time units table.
 */
static TABLE    UnitsTable[] = {
    { "year",           tMONTH_UNIT,    12 },
    { "month",          tMONTH_UNIT,     1 },
    { "fortnight",      tDAY_UNIT,      14 },
    { "week",           tDAY_UNIT,       7 },
    { "day",            tDAY_UNIT,       1 },
    { "hour",           tSEC_UNIT, 60 * 60 },
    { "minute",         tSEC_UNIT,      60 },
    { "min",            tSEC_UNIT,      60 },
    { "second",         tSEC_UNIT,       1 },
    { "sec",            tSEC_UNIT,       1 },
    { NULL }
};

/*
 * Assorted relative-time words.
 */
static TABLE    OtherTable[] = {
    { "tomorrow",       tDAY_UNIT,      1 },
    { "yesterday",      tDAY_UNIT,     -1 },
    { "today",          tDAY_UNIT,      0 },
    { "now",            tSEC_UNIT,      0 },
    { "last",           tUNUMBER,      -1 },
    { "this",           tSEC_UNIT,      0 },
    { "next",           tNEXT,          1 },
#if 0
    { "first",          tUNUMBER,       1 },
    { "second",         tUNUMBER,       2 },
    { "third",          tUNUMBER,       3 },
    { "fourth",         tUNUMBER,       4 },
    { "fifth",          tUNUMBER,       5 },
    { "sixth",          tUNUMBER,       6 },
    { "seventh",        tUNUMBER,       7 },
    { "eighth",         tUNUMBER,       8 },
    { "ninth",          tUNUMBER,       9 },
    { "tenth",          tUNUMBER,       10 },
    { "eleventh",       tUNUMBER,       11 },
    { "twelfth",        tUNUMBER,       12 },
#endif
    { "ago",            tAGO,   1 },
    { "epoch",          tEPOCH,   0 },
    { "stardate",       tSTARDATE, 0},
    { NULL }
};

/*
 * The timezone table.  (Note: This table was modified to not use any floating
 * point constants to work around an SGI compiler bug).
 */
static TABLE    TimezoneTable[] = {
    { "gmt",    tZONE,     HOUR( 0) },      /* Greenwich Mean */
    { "ut",     tZONE,     HOUR( 0) },      /* Universal (Coordinated) */
    { "utc",    tZONE,     HOUR( 0) },
    { "uct",    tZONE,     HOUR( 0) },      /* Universal Coordinated Time */
    { "wet",    tZONE,     HOUR( 0) },      /* Western European */
    { "bst",    tDAYZONE,  HOUR( 0) },      /* British Summer */
    { "wat",    tZONE,     HOUR( 1) },      /* West Africa */
    { "at",     tZONE,     HOUR( 2) },      /* Azores */
#if     0
    /* For completeness.  BST is also British Summer, and GST is
     * also Guam Standard. */
    { "bst",    tZONE,     HOUR( 3) },      /* Brazil Standard */
    { "gst",    tZONE,     HOUR( 3) },      /* Greenland Standard */
#endif
    { "nft",    tZONE,     HOUR( 7/2) },    /* Newfoundland */
    { "nst",    tZONE,     HOUR( 7/2) },    /* Newfoundland Standard */
    { "ndt",    tDAYZONE,  HOUR( 7/2) },    /* Newfoundland Daylight */
    { "ast",    tZONE,     HOUR( 4) },      /* Atlantic Standard */
    { "adt",    tDAYZONE,  HOUR( 4) },      /* Atlantic Daylight */
    { "est",    tZONE,     HOUR( 5) },      /* Eastern Standard */
    { "edt",    tDAYZONE,  HOUR( 5) },      /* Eastern Daylight */
    { "cst",    tZONE,     HOUR( 6) },      /* Central Standard */
    { "cdt",    tDAYZONE,  HOUR( 6) },      /* Central Daylight */
    { "mst",    tZONE,     HOUR( 7) },      /* Mountain Standard */
    { "mdt",    tDAYZONE,  HOUR( 7) },      /* Mountain Daylight */
    { "pst",    tZONE,     HOUR( 8) },      /* Pacific Standard */
    { "pdt",    tDAYZONE,  HOUR( 8) },      /* Pacific Daylight */
    { "yst",    tZONE,     HOUR( 9) },      /* Yukon Standard */
    { "ydt",    tDAYZONE,  HOUR( 9) },      /* Yukon Daylight */
    { "hst",    tZONE,     HOUR(10) },      /* Hawaii Standard */
    { "hdt",    tDAYZONE,  HOUR(10) },      /* Hawaii Daylight */
    { "cat",    tZONE,     HOUR(10) },      /* Central Alaska */
    { "ahst",   tZONE,     HOUR(10) },      /* Alaska-Hawaii Standard */
    { "nt",     tZONE,     HOUR(11) },      /* Nome */
    { "idlw",   tZONE,     HOUR(12) },      /* International Date Line West */
    { "cet",    tZONE,    -HOUR( 1) },      /* Central European */
    { "cest",   tDAYZONE, -HOUR( 1) },      /* Central European Summer */
    { "met",    tZONE,    -HOUR( 1) },      /* Middle European */
    { "mewt",   tZONE,    -HOUR( 1) },      /* Middle European Winter */
    { "mest",   tDAYZONE, -HOUR( 1) },      /* Middle European Summer */
    { "swt",    tZONE,    -HOUR( 1) },      /* Swedish Winter */
    { "sst",    tDAYZONE, -HOUR( 1) },      /* Swedish Summer */
    { "fwt",    tZONE,    -HOUR( 1) },      /* French Winter */
    { "fst",    tDAYZONE, -HOUR( 1) },      /* French Summer */
    { "eet",    tZONE,    -HOUR( 2) },      /* Eastern Europe, USSR Zone 1 */
    { "bt",     tZONE,    -HOUR( 3) },      /* Baghdad, USSR Zone 2 */
    { "it",     tZONE,    -HOUR( 7/2) },    /* Iran */
    { "zp4",    tZONE,    -HOUR( 4) },      /* USSR Zone 3 */
    { "zp5",    tZONE,    -HOUR( 5) },      /* USSR Zone 4 */
    { "ist",    tZONE,    -HOUR(11/2) },    /* Indian Standard */
    { "zp6",    tZONE,    -HOUR( 6) },      /* USSR Zone 5 */
#if     0
    /* For completeness.  NST is also Newfoundland Stanard, nad SST is
     * also Swedish Summer. */
    { "nst",    tZONE,    -HOUR(13/2) },    /* North Sumatra */
    { "sst",    tZONE,    -HOUR( 7) },      /* South Sumatra, USSR Zone 6 */
#endif  /* 0 */
    { "wast",   tZONE,    -HOUR( 7) },      /* West Australian Standard */
    { "wadt",   tDAYZONE, -HOUR( 7) },      /* West Australian Daylight */
    { "jt",     tZONE,    -HOUR(15/2) },    /* Java (3pm in Cronusland!) */
    { "cct",    tZONE,    -HOUR( 8) },      /* China Coast, USSR Zone 7 */
    { "jst",    tZONE,    -HOUR( 9) },      /* Japan Standard, USSR Zone 8 */
    { "jdt",    tDAYZONE, -HOUR( 9) },      /* Japan Daylight */
    { "kst",    tZONE,    -HOUR( 9) },      /* Korea Standard */
    { "kdt",    tDAYZONE, -HOUR( 9) },      /* Korea Daylight */
    { "cast",   tZONE,    -HOUR(19/2) },    /* Central Australian Standard */
    { "cadt",   tDAYZONE, -HOUR(19/2) },    /* Central Australian Daylight */
    { "east",   tZONE,    -HOUR(10) },      /* Eastern Australian Standard */
    { "eadt",   tDAYZONE, -HOUR(10) },      /* Eastern Australian Daylight */
    { "gst",    tZONE,    -HOUR(10) },      /* Guam Standard, USSR Zone 9 */
    { "nzt",    tZONE,    -HOUR(12) },      /* New Zealand */
    { "nzst",   tZONE,    -HOUR(12) },      /* New Zealand Standard */
    { "nzdt",   tDAYZONE, -HOUR(12) },      /* New Zealand Daylight */
    { "idle",   tZONE,    -HOUR(12) },      /* International Date Line East */
    /* ADDED BY Marco Nijdam */
    { "dst",    tDST,     HOUR( 0) },       /* DST on (hour is ignored) */
    /* End ADDED */
    {  NULL  }
};

/*
 * Military timezone table.
 */
static TABLE    MilitaryTable[] = {
    { "a",      tZONE,  HOUR(  1) },
    { "b",      tZONE,  HOUR(  2) },
    { "c",      tZONE,  HOUR(  3) },
    { "d",      tZONE,  HOUR(  4) },
    { "e",      tZONE,  HOUR(  5) },
    { "f",      tZONE,  HOUR(  6) },
    { "g",      tZONE,  HOUR(  7) },
    { "h",      tZONE,  HOUR(  8) },
    { "i",      tZONE,  HOUR(  9) },
    { "k",      tZONE,  HOUR( 10) },
    { "l",      tZONE,  HOUR( 11) },
    { "m",      tZONE,  HOUR( 12) },
    { "n",      tZONE,  HOUR(- 1) },
    { "o",      tZONE,  HOUR(- 2) },
    { "p",      tZONE,  HOUR(- 3) },
    { "q",      tZONE,  HOUR(- 4) },
    { "r",      tZONE,  HOUR(- 5) },
    { "s",      tZONE,  HOUR(- 6) },
    { "t",      tZONE,  HOUR(- 7) },
    { "u",      tZONE,  HOUR(- 8) },
    { "v",      tZONE,  HOUR(- 9) },
    { "w",      tZONE,  HOUR(-10) },
    { "x",      tZONE,  HOUR(-11) },
    { "y",      tZONE,  HOUR(-12) },
    { "z",      tZONE,  HOUR(  0) },
    { NULL }
};


/*
 * Dump error messages in the bit bucket.
 */
static void
TclDateerror(s)
    char  *s;
{
}


static time_t
ToSeconds(Hours, Minutes, Seconds, Meridian)
    time_t      Hours;
    time_t      Minutes;
    time_t      Seconds;
    MERIDIAN    Meridian;
{
    if (Minutes &lt; 0 || Minutes &gt; 59 || Seconds &lt; 0 || Seconds &gt; 59)
        return -1;
    switch (Meridian) {
    case MER24:
        if (Hours &lt; 0 || Hours &gt; 23)
            return -1;
        return (Hours * 60L + Minutes) * 60L + Seconds;
    case MERam:
        if (Hours &lt; 1 || Hours &gt; 12)
            return -1;
        return ((Hours % 12) * 60L + Minutes) * 60L + Seconds;
    case MERpm:
        if (Hours &lt; 1 || Hours &gt; 12)
            return -1;
        return (((Hours % 12) + 12) * 60L + Minutes) * 60L + Seconds;
    }
    return -1;  /* Should never be reached */
}

/*
 *-----------------------------------------------------------------------------
 *
 * Convert --
 *
 *      Convert a {month, day, year, hours, minutes, seconds, meridian, dst}
 *      tuple into a clock seconds value.
 *
 * Results:
 *      0 or -1 indicating success or failure.
 *
 * Side effects:
 *      Fills TimePtr with the computed value.
 *
 *-----------------------------------------------------------------------------
 */
static int
Convert(Month, Day, Year, Hours, Minutes, Seconds, Meridian, DSTmode, TimePtr)
    time_t      Month;
    time_t      Day;
    time_t      Year;
    time_t      Hours;
    time_t      Minutes;
    time_t      Seconds;
    MERIDIAN    Meridian;
    DSTMODE     DSTmode;
    time_t     *TimePtr;
{
    static int  DaysInMonth[12] = {
        31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
    };
    time_t tod;
    time_t Julian;
    int i;

    /* Figure out how many days are in February for the given year.
     * Every year divisible by 4 is a leap year.
     * But, every year divisible by 100 is not a leap year.
     * But, every year divisible by 400 is a leap year after all.
     */
    DaysInMonth[1] = IsLeapYear(Year) ? 29 : 28;

    /* Check the inputs for validity */
    if (Month &lt; 1 || Month &gt; 12
	    || Year &lt; START_OF_TIME || Year &gt; END_OF_TIME
	    || Day &lt; 1 || Day &gt; DaysInMonth[(int)--Month])
        return -1;

    /* Start computing the value.  First determine the number of days
     * represented by the date, then multiply by the number of seconds/day.
     */
    for (Julian = Day - 1, i = 0; i &lt; Month; i++)
        Julian += DaysInMonth[i];
    if (Year &gt;= EPOCH) {
        for (i = EPOCH; i &lt; Year; i++)
            Julian += 365 + IsLeapYear(i);
    } else {
        for (i = (int)Year; i &lt; EPOCH; i++)
            Julian -= 365 + IsLeapYear(i);
    }
    Julian *= SECSPERDAY;

    /* Add the timezone offset ?? */
    Julian += TclDateTimezone * 60L;

    /* Add the number of seconds represented by the time component */
    if ((tod = ToSeconds(Hours, Minutes, Seconds, Meridian)) &lt; 0)
        return -1;
    Julian += tod;

    /* Perform a preliminary DST compensation ?? */
    if (DSTmode == DSTon
     || (DSTmode == DSTmaybe &amp;&amp; TclpGetDate((TclpTime_t)&amp;Julian, 0)-&gt;tm_isdst))
        Julian -= 60 * 60;
    *TimePtr = Julian;
    return 0;
}


static time_t
DSTcorrect(Start, Future)
    time_t      Start;
    time_t      Future;
{
    time_t      StartDay;
    time_t      FutureDay;
    StartDay = (TclpGetDate((TclpTime_t)&amp;Start, 0)-&gt;tm_hour + 1) % 24;
    FutureDay = (TclpGetDate((TclpTime_t)&amp;Future, 0)-&gt;tm_hour + 1) % 24;
    return (Future - Start) + (StartDay - FutureDay) * 60L * 60L;
}


static time_t
NamedDay(Start, DayOrdinal, DayNumber)
    time_t      Start;
    time_t      DayOrdinal;
    time_t      DayNumber;
{
    struct tm   *tm;
    time_t      now;

    now = Start;
    tm = TclpGetDate((TclpTime_t)&amp;now, 0);
    now += SECSPERDAY * ((DayNumber - tm-&gt;tm_wday + 7) % 7);
    now += 7 * SECSPERDAY * (DayOrdinal &lt;= 0 ? DayOrdinal : DayOrdinal - 1);
    return DSTcorrect(Start, now);
}

static time_t
NamedMonth(Start, MonthOrdinal, MonthNumber)
    time_t Start;
    time_t MonthOrdinal;
    time_t MonthNumber;
{
    struct tm *tm;
    time_t now;
    int result;
    
    now = Start;
    tm = TclpGetDate((TclpTime_t)&amp;now, 0);
    /* To compute the next n'th month, we use this alg:
     * add n to year value
     * if currentMonth &lt; requestedMonth decrement year value by 1 (so that
     *  doing next february from january gives us february of the current year)
     * set day to 1, time to 0
     */
    tm-&gt;tm_year += (int)MonthOrdinal;
    if (tm-&gt;tm_mon &lt; MonthNumber - 1) {
	tm-&gt;tm_year--;
    }
    result = Convert(MonthNumber, (time_t) 1, tm-&gt;tm_year + TM_YEAR_BASE,
	    (time_t) 0, (time_t) 0, (time_t) 0, MER24, DSTmaybe, &amp;now);
    if (result &lt; 0) {
	return 0;
    }
    return DSTcorrect(Start, now);
}

static int
RelativeMonth(Start, RelMonth, TimePtr)
    time_t Start;
    time_t RelMonth;
    time_t *TimePtr;
{
    struct tm *tm;
    time_t Month;
    time_t Year;
    time_t Julian;
    int result;

    if (RelMonth == 0) {
        *TimePtr = 0;
        return 0;
    }
    tm = TclpGetDate((TclpTime_t)&amp;Start, 0);
    Month = 12 * (tm-&gt;tm_year + TM_YEAR_BASE) + tm-&gt;tm_mon + RelMonth;
    Year = Month / 12;
    Month = Month % 12 + 1;
    result = Convert(Month, (time_t) tm-&gt;tm_mday, Year,
	    (time_t) tm-&gt;tm_hour, (time_t) tm-&gt;tm_min, (time_t) tm-&gt;tm_sec,
	    MER24, DSTmaybe, &amp;Julian);

    /*
     * The Julian time returned above is behind by one day, if "month" 
     * or "year" is used to specify relative time and the GMT flag is true.
     * This problem occurs only when the current time is closer to
     * midnight, the difference being not more than its time difference
     * with GMT. For example, in US/Pacific time zone, the problem occurs
     * whenever the current time is between midnight to 8:00am or 7:00amDST.
     * See Bug# 413397 for more details and sample script.
     * To resolve this bug, we simply add the number of seconds corresponding
     * to timezone difference with GMT to Julian time, if GMT flag is true.
     */

    if (TclDateTimezone == 0) {
        Julian += TclpGetTimeZone((unsigned long) Start) * 60L;
    }

    /*
     * The following iteration takes into account the case were we jump
     * into a "short month".  Far example, "one month from Jan 31" will
     * fail because there is no Feb 31.  The code below will reduce the
     * day and try converting the date until we succed or the date equals
     * 28 (which always works unless the date is bad in another way).
     */

    while ((result != 0) &amp;&amp; (tm-&gt;tm_mday &gt; 28)) {
	tm-&gt;tm_mday--;
	result = Convert(Month, (time_t) tm-&gt;tm_mday, Year,
		(time_t) tm-&gt;tm_hour, (time_t) tm-&gt;tm_min, (time_t) tm-&gt;tm_sec,
		MER24, DSTmaybe, &amp;Julian);
    }
    if (result != 0) {
	return -1;
    }
    *TimePtr = DSTcorrect(Start, Julian);
    return 0;
}


/*
 *-----------------------------------------------------------------------------
 *
 * RelativeDay --
 *
 *      Given a starting time and a number of days before or after, compute the
 *      DST corrected difference between those dates.
 *
 * Results:
 *     1 or -1 indicating success or failure.
 *
 * Side effects:
 *      Fills TimePtr with the computed value.
 *
 *-----------------------------------------------------------------------------
 */

static int
RelativeDay(Start, RelDay, TimePtr)
    time_t Start;
    time_t RelDay;
    time_t *TimePtr;
{
    time_t new;

    new = Start + (RelDay * 60 * 60 * 24);
    *TimePtr = DSTcorrect(Start, new);
    return 1;
}

static int
LookupWord(buff)
    char                *buff;
{
    register char *p;
    register char *q;
    register TABLE *tp;
    int i;
    int abbrev;

    /*
     * Make it lowercase.
     */

    Tcl_UtfToLower(buff);

    if (strcmp(buff, "am") == 0 || strcmp(buff, "a.m.") == 0) {
        TclDatelval.Meridian = MERam;
        return tMERIDIAN;
    }
    if (strcmp(buff, "pm") == 0 || strcmp(buff, "p.m.") == 0) {
        TclDatelval.Meridian = MERpm;
        return tMERIDIAN;
    }

    /*
     * See if we have an abbreviation for a month.
     */
    if (strlen(buff) == 3) {
        abbrev = 1;
    } else if (strlen(buff) == 4 &amp;&amp; buff[3] == '.') {
        abbrev = 1;
        buff[3] = '\0';
    } else {
        abbrev = 0;
    }

    for (tp = MonthDayTable; tp-&gt;name; tp++) {
        if (abbrev) {
            if (strncmp(buff, tp-&gt;name, 3) == 0) {
                TclDatelval.Number = tp-&gt;value;
                return tp-&gt;type;
            }
        } else if (strcmp(buff, tp-&gt;name) == 0) {
            TclDatelval.Number = tp-&gt;value;
            return tp-&gt;type;
        }
    }

    for (tp = TimezoneTable; tp-&gt;name; tp++) {
        if (strcmp(buff, tp-&gt;name) == 0) {
            TclDatelval.Number = tp-&gt;value;
            return tp-&gt;type;
        }
    }

    for (tp = UnitsTable; tp-&gt;name; tp++) {
        if (strcmp(buff, tp-&gt;name) == 0) {
            TclDatelval.Number = tp-&gt;value;
            return tp-&gt;type;
        }
    }

    /*
     * Strip off any plural and try the units table again.
     */
    i = strlen(buff) - 1;
    if (buff[i] == 's') {
        buff[i] = '\0';
        for (tp = UnitsTable; tp-&gt;name; tp++) {
            if (strcmp(buff, tp-&gt;name) == 0) {
                TclDatelval.Number = tp-&gt;value;
                return tp-&gt;type;
            }
	}
    }

    for (tp = OtherTable; tp-&gt;name; tp++) {
        if (strcmp(buff, tp-&gt;name) == 0) {
            TclDatelval.Number = tp-&gt;value;
            return tp-&gt;type;
        }
    }

    /*
     * Military timezones.
     */
    if (buff[1] == '\0' &amp;&amp; !(*buff &amp; 0x80)
	    &amp;&amp; isalpha(UCHAR(*buff))) {	/* INTL: ISO only */
        for (tp = MilitaryTable; tp-&gt;name; tp++) {
            if (strcmp(buff, tp-&gt;name) == 0) {
                TclDatelval.Number = tp-&gt;value;
                return tp-&gt;type;
            }
	}
    }

    /*
     * Drop out any periods and try the timezone table again.
     */
    for (i = 0, p = q = buff; *q; q++)
        if (*q != '.') {
            *p++ = *q;
        } else {
            i++;
	}
    *p = '\0';
    if (i) {
        for (tp = TimezoneTable; tp-&gt;name; tp++) {
            if (strcmp(buff, tp-&gt;name) == 0) {
                TclDatelval.Number = tp-&gt;value;
                return tp-&gt;type;
            }
	}
    }
    
    return tID;
}


static int
TclDatelex()
{
    register char       c;
    register char       *p;
    char                buff[20];
    int                 Count;

    for ( ; ; ) {
        while (isspace(UCHAR(*TclDateInput))) {
            TclDateInput++;
	}

        if (isdigit(UCHAR(c = *TclDateInput))) { /* INTL: digit */
	    /* convert the string into a number; count the number of digits */
	    Count = 0;
            for (TclDatelval.Number = 0;
		    isdigit(UCHAR(c = *TclDateInput++)); ) { /* INTL: digit */
                TclDatelval.Number = 10 * TclDatelval.Number + c - '0';
		Count++;
	    }
            TclDateInput--;
	    /* A number with 6 or more digits is considered an ISO 8601 base */
	    if (Count &gt;= 6) {
		return tISOBASE;
	    } else {
		return tUNUMBER;
	    }
        }
        if (!(c &amp; 0x80) &amp;&amp; isalpha(UCHAR(c))) {	/* INTL: ISO only. */
            for (p = buff; isalpha(UCHAR(c = *TclDateInput++)) /* INTL: ISO only. */
		     || c == '.'; ) {
                if (p &lt; &amp;buff[sizeof buff - 1]) {
                    *p++ = c;
		}
	    }
            *p = '\0';
            TclDateInput--;
            return LookupWord(buff);
        }
        if (c != '(') {
            return *TclDateInput++;
	}
        Count = 0;
        do {
            c = *TclDateInput++;
            if (c == '\0') {
                return c;
	    } else if (c == '(') {
                Count++;
	    } else if (c == ')') {
                Count--;
	    }
        } while (Count &gt; 0);
    }
}
</t>
<t tx="ekr.20071105090148.267">
/*
 * Specify zone is of -50000 to force GMT.  (This allows BST to work).
 */

int
TclGetDate(p, now, zone, timePtr)
    char *p;
    Tcl_WideInt now;
    long zone;
    Tcl_WideInt *timePtr;
{
    struct tm *tm;
    time_t Start;
    time_t Time;
    time_t tod;
    int thisyear;

    TclDateInput = p;
    /* now has to be cast to a time_t for 64bit compliance */
    Start = (time_t) now;
    tm = TclpGetDate((TclpTime_t) &amp;Start, (zone == -50000));
    thisyear = tm-&gt;tm_year + TM_YEAR_BASE;
    TclDateYear = thisyear;
    TclDateMonth = tm-&gt;tm_mon + 1;
    TclDateDay = tm-&gt;tm_mday;
    TclDateTimezone = zone;
    if (zone == -50000) {
        TclDateDSTmode = DSToff;  /* assume GMT */
        TclDateTimezone = 0;
    } else {
        TclDateDSTmode = DSTmaybe;
    }
    TclDateHour = 0;
    TclDateMinutes = 0;
    TclDateSeconds = 0;
    TclDateMeridian = MER24;
    TclDateRelSeconds = 0;
    TclDateRelMonth = 0;
    TclDateRelDay = 0;
    TclDateRelPointer = NULL;

    TclDateHaveDate = 0;
    TclDateHaveDay = 0;
    TclDateHaveOrdinalMonth = 0;
    TclDateHaveRel = 0;
    TclDateHaveTime = 0;
    TclDateHaveZone = 0;

    if (TclDateparse() || TclDateHaveTime &gt; 1 || TclDateHaveZone &gt; 1 || TclDateHaveDate &gt; 1 ||
	    TclDateHaveDay &gt; 1 || TclDateHaveOrdinalMonth &gt; 1) {
        return -1;
    }
    
    if (TclDateHaveDate || TclDateHaveTime || TclDateHaveDay) {
	if (TclDateYear &lt; 0) {
	    TclDateYear = -TclDateYear;
	}
	/*
	 * The following line handles years that are specified using
	 * only two digits.  The line of code below implements a policy
	 * defined by the X/Open workgroup on the millinium rollover.
	 * Note: some of those dates may not actually be valid on some
	 * platforms.  The POSIX standard startes that the dates 70-99
	 * shall refer to 1970-1999 and 00-38 shall refer to 2000-2038.
	 * This later definition should work on all platforms.
	 */

	if (TclDateYear &lt; 100) {
	    if (TclDateYear &gt;= 69) {
		TclDateYear += 1900;
	    } else {
		TclDateYear += 2000;
	    }
	}
	if (Convert(TclDateMonth, TclDateDay, TclDateYear, TclDateHour, TclDateMinutes, TclDateSeconds,
		TclDateMeridian, TclDateDSTmode, &amp;Start) &lt; 0) {
            return -1;
	}
    } else {
        Start = (time_t) now;
        if (!TclDateHaveRel) {
            Start -= ((tm-&gt;tm_hour * 60L * 60L) +
		    tm-&gt;tm_min * 60L) +	tm-&gt;tm_sec;
	}
    }

    Start += TclDateRelSeconds;
    if (RelativeMonth(Start, TclDateRelMonth, &amp;Time) &lt; 0) {
        return -1;
    }
    Start += Time;

    if (RelativeDay(Start, TclDateRelDay, &amp;Time) &lt; 0) {
	return -1;
    }
    Start += Time;
    
    if (TclDateHaveDay &amp;&amp; !TclDateHaveDate) {
        tod = NamedDay(Start, TclDateDayOrdinal, TclDateDayNumber);
        Start += tod;
    }

    if (TclDateHaveOrdinalMonth) {
	tod = NamedMonth(Start, TclDateMonthOrdinal, TclDateMonth);
	Start += tod;
    }
    
    *timePtr = Start;
    return 0;
}
static CONST TclDatetabelem TclDateexca[] ={
-1, 1,
	0, -1,
	-2, 0,
	};
# define YYNPROD 56
# define YYLAST 261
static CONST TclDatetabelem TclDateact[]={

    24,    40,    23,    36,    54,    81,    41,    28,    53,    26,
    37,    42,    58,    38,    56,    28,    27,    26,    28,    33,
    26,    32,    61,    50,    27,    80,    76,    27,    51,    75,
    74,    73,    30,    72,    71,    70,    69,    52,    49,    48,
    47,    45,    39,    62,    78,    46,    79,    68,    25,    65,
    60,    67,    66,    55,    44,    21,    63,    11,    10,     9,
     8,    35,     7,     6,     5,     4,     3,    43,     2,     1,
    20,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,    57,     0,     0,    59,    77,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,    19,    14,     0,     0,     0,
    16,    28,    22,    26,     0,    12,    13,    17,     0,    15,
    27,    18,    31,     0,     0,    29,     0,    34,    28,     0,
    26,     0,     0,     0,     0,     0,     0,    27,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,    64,
    64 };
static CONST TclDatetabelem TclDatepact[]={

-10000000,   -43,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,   -26,  -268,-10000000,  -259,  -226,-10000000,  -257,    10,
  -227,  -212,  -228,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
  -229,-10000000,  -230,  -240,  -231,-10000000,-10000000,  -264,-10000000,     9,
-10000000,-10000000,  -249,-10000000,-10000000,  -246,-10000000,     4,    -2,     2,
     7,     6,-10000000,-10000000,   -11,  -232,-10000000,-10000000,-10000000,-10000000,
  -233,-10000000,  -234,  -235,-10000000,  -237,  -238,  -239,  -242,-10000000,
-10000000,-10000000,    -1,-10000000,-10000000,-10000000,   -12,-10000000,  -243,  -263,
-10000000,-10000000 };
static CONST TclDatetabelem TclDatepgo[]={

     0,    48,    70,    22,    69,    68,    66,    65,    64,    63,
    62,    60,    59,    58,    57,    55 };
static CONST TclDatetabelem TclDater1[]={

     0,     4,     4,     5,     5,     5,     5,     5,     5,     5,
     5,     5,     6,     6,     6,     6,     6,     7,     7,     7,
    10,    10,    10,    10,    10,     8,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     9,     9,    12,    12,    12,
    13,    11,    11,    15,    15,    15,    15,    15,     2,     2,
     1,     1,     1,    14,     3,     3 };
static CONST TclDatetabelem TclDater2[]={

     0,     0,     4,     3,     3,     3,     3,     3,     3,     3,
     3,     2,     5,     9,    11,    13,    15,     5,     3,     3,
     3,     5,     5,     7,     5,     7,    11,     3,    11,    11,
     5,     9,     5,     3,     7,     5,     7,     7,    15,     5,
     9,     5,     2,     7,     5,     5,     7,     3,     3,     3,
     3,     3,     3,     3,     1,     3 };
static CONST TclDatetabelem TclDatechk[]={

-10000000,    -4,    -5,    -6,    -7,    -8,    -9,   -10,   -11,   -12,
   -13,   -14,   268,   269,   259,   272,   263,   270,   274,   258,
    -2,   -15,   265,    45,    43,    -1,   266,   273,   264,   261,
    58,   258,    47,    45,   263,    -1,   271,   269,   272,   268,
   258,   263,   268,    -1,    44,   268,   257,   268,   268,   268,
   263,   268,   268,   272,   268,    44,   263,    -1,   258,    -1,
    46,    -3,    45,    58,   261,    47,    45,    45,    58,   268,
   268,   268,   268,   268,   268,   268,   268,    -3,    45,    58,
   268,   268 };
static CONST TclDatetabelem TclDatedef[]={

     1,    -2,     2,     3,     4,     5,     6,     7,     8,     9,
    10,    11,    53,    18,    19,    27,     0,    33,     0,    20,
     0,    42,     0,    48,    49,    47,    50,    51,    52,    12,
     0,    22,     0,     0,    32,    44,    17,     0,    39,    30,
    24,    35,     0,    45,    21,     0,    41,     0,    54,    25,
     0,     0,    34,    37,     0,     0,    36,    46,    23,    43,
     0,    13,     0,     0,    55,     0,     0,     0,     0,    31,
    40,    14,    54,    26,    28,    29,     0,    15,     0,     0,
    16,    38 };
typedef struct
#ifdef __cplusplus
	TclDatetoktype
#endif
{ char *t_name; int t_val; } TclDatetoktype;
#ifndef YYDEBUG
#	define YYDEBUG	0	/* don't allow debugging */
#endif

#if YYDEBUG

TclDatetoktype TclDatetoks[] =
{
	"tAGO",	257,
	"tDAY",	258,
	"tDAYZONE",	259,
	"tID",	260,
	"tMERIDIAN",	261,
	"tMINUTE_UNIT",	262,
	"tMONTH",	263,
	"tMONTH_UNIT",	264,
	"tSTARDATE",	265,
	"tSEC_UNIT",	266,
	"tSNUMBER",	267,
	"tUNUMBER",	268,
	"tZONE",	269,
	"tEPOCH",	270,
	"tDST",	271,
	"tISOBASE",	272,
	"tDAY_UNIT",	273,
	"tNEXT",	274,
	"-unknown-",	-1	/* ends search */
};

char * TclDatereds[] =
{
	"-no such reduction-",
	"spec : /* empty */",
	"spec : spec item",
	"item : time",
	"item : zone",
	"item : date",
	"item : ordMonth",
	"item : day",
	"item : relspec",
	"item : iso",
	"item : trek",
	"item : number",
	"time : tUNUMBER tMERIDIAN",
	"time : tUNUMBER ':' tUNUMBER o_merid",
	"time : tUNUMBER ':' tUNUMBER '-' tUNUMBER",
	"time : tUNUMBER ':' tUNUMBER ':' tUNUMBER o_merid",
	"time : tUNUMBER ':' tUNUMBER ':' tUNUMBER '-' tUNUMBER",
	"zone : tZONE tDST",
	"zone : tZONE",
	"zone : tDAYZONE",
	"day : tDAY",
	"day : tDAY ','",
	"day : tUNUMBER tDAY",
	"day : sign tUNUMBER tDAY",
	"day : tNEXT tDAY",
	"date : tUNUMBER '/' tUNUMBER",
	"date : tUNUMBER '/' tUNUMBER '/' tUNUMBER",
	"date : tISOBASE",
	"date : tUNUMBER '-' tMONTH '-' tUNUMBER",
	"date : tUNUMBER '-' tUNUMBER '-' tUNUMBER",
	"date : tMONTH tUNUMBER",
	"date : tMONTH tUNUMBER ',' tUNUMBER",
	"date : tUNUMBER tMONTH",
	"date : tEPOCH",
	"date : tUNUMBER tMONTH tUNUMBER",
	"ordMonth : tNEXT tMONTH",
	"ordMonth : tNEXT tUNUMBER tMONTH",
	"iso : tISOBASE tZONE tISOBASE",
	"iso : tISOBASE tZONE tUNUMBER ':' tUNUMBER ':' tUNUMBER",
	"iso : tISOBASE tISOBASE",
	"trek : tSTARDATE tUNUMBER '.' tUNUMBER",
	"relspec : relunits tAGO",
	"relspec : relunits",
	"relunits : sign tUNUMBER unit",
	"relunits : tUNUMBER unit",
	"relunits : tNEXT unit",
	"relunits : tNEXT tUNUMBER unit",
	"relunits : unit",
	"sign : '-'",
	"sign : '+'",
	"unit : tSEC_UNIT",
	"unit : tDAY_UNIT",
	"unit : tMONTH_UNIT",
	"number : tUNUMBER",
	"o_merid : /* empty */",
	"o_merid : tMERIDIAN",
};
#endif /* YYDEBUG */
/*
 * Copyright (c) 1993 by Sun Microsystems, Inc.
 */


/*
** Skeleton parser driver for yacc output
*/

/*
** yacc user known macros and defines
*/
#define YYERROR		goto TclDateerrlab
#define YYACCEPT	return(0)
#define YYABORT		return(1)
#define YYBACKUP( newtoken, newvalue )\
{\
	if ( TclDatechar &gt;= 0 || ( TclDater2[ TclDatetmp ] &gt;&gt; 1 ) != 1 )\
	{\
		TclDateerror( "syntax error - cannot backup" );\
		goto TclDateerrlab;\
	}\
	TclDatechar = newtoken;\
	TclDatestate = *TclDateps;\
	TclDatelval = newvalue;\
	goto TclDatenewstate;\
}
#define YYRECOVERING()	(!!TclDateerrflag)
#define YYNEW(type)	malloc(sizeof(type) * TclDatenewmax)
#define YYCOPY(to, from, type) \
	(type *) memcpy(to, (char *) from, TclDatemaxdepth * sizeof (type))
#define YYENLARGE( from, type) \
	(type *) realloc((char *) from, TclDatenewmax * sizeof(type))
#ifndef YYDEBUG
#	define YYDEBUG	1	/* make debugging available */
#endif

/*
** user known globals
*/
int TclDatedebug;			/* set to 1 to get debugging */

/*
** driver internal defines
*/
#define YYFLAG		(-10000000)

/*
** global variables used by the parser
*/
YYSTYPE *TclDatepv;			/* top of value stack */
int *TclDateps;			/* top of state stack */

int TclDatestate;			/* current state */
int TclDatetmp;			/* extra var (lasts between blocks) */

int TclDatenerrs;			/* number of errors */
int TclDateerrflag;			/* error recovery flag */
int TclDatechar;			/* current input token number */



#ifdef YYNMBCHARS
#define YYLEX()		TclDatecvtok(TclDatelex())
/*
** TclDatecvtok - return a token if i is a wchar_t value that exceeds 255.
**	If i&lt;255, i itself is the token.  If i&gt;255 but the neither 
**	of the 30th or 31st bit is on, i is already a token.
*/
#if defined(__STDC__) || defined(__cplusplus)
int TclDatecvtok(int i)
#else
int TclDatecvtok(i) int i;
#endif
{
	int first = 0;
	int last = YYNMBCHARS - 1;
	int mid;
	wchar_t j;

	if(i&amp;0x60000000){/*Must convert to a token. */
		if( TclDatembchars[last].character &lt; i ){
			return i;/*Giving up*/
		}
		while ((last&gt;=first)&amp;&amp;(first&gt;=0)) {/*Binary search loop*/
			mid = (first+last)/2;
			j = TclDatembchars[mid].character;
			if( j==i ){/*Found*/ 
				return TclDatembchars[mid].tvalue;
			}else if( j&lt;i ){
				first = mid + 1;
			}else{
				last = mid -1;
			}
		}
		/*No entry in the table.*/
		return i;/* Giving up.*/
	}else{/* i is already a token. */
		return i;
	}
}
#else/*!YYNMBCHARS*/
#define YYLEX()		TclDatelex()
#endif/*!YYNMBCHARS*/

/*
** TclDateparse - return 0 if worked, 1 if syntax error not recovered from
*/
#if defined(__STDC__) || defined(__cplusplus)
int TclDateparse(void)
#else
int TclDateparse()
#endif
{
	register YYSTYPE *TclDatepvt = 0;	/* top of value stack for $vars */

#if defined(__cplusplus) || defined(lint)
/*
	hacks to please C++ and lint - goto's inside
	switch should never be executed
*/
	static int __yaccpar_lint_hack__ = 0;
	switch (__yaccpar_lint_hack__)
	{
		case 1: goto TclDateerrlab;
		case 2: goto TclDatenewstate;
	}
#endif

	/*
	** Initialize externals - TclDateparse may be called more than once
	*/
	TclDatepv = &amp;TclDatev[-1];
	TclDateps = &amp;TclDates[-1];
	TclDatestate = 0;
	TclDatetmp = 0;
	TclDatenerrs = 0;
	TclDateerrflag = 0;
	TclDatechar = -1;

#if YYMAXDEPTH &lt;= 0
	if (TclDatemaxdepth &lt;= 0)
	{
		if ((TclDatemaxdepth = YYEXPAND(0)) &lt;= 0)
		{
			TclDateerror("yacc initialization error");
			YYABORT;
		}
	}
#endif

	{
		register YYSTYPE *TclDate_pv;	/* top of value stack */
		register int *TclDate_ps;		/* top of state stack */
		register int TclDate_state;		/* current state */
		register int  TclDate_n;		/* internal state number info */
	goto TclDatestack;	/* moved from 6 lines above to here to please C++ */

		/*
		** get globals into registers.
		** branch to here only if YYBACKUP was called.
		*/
		TclDate_pv = TclDatepv;
		TclDate_ps = TclDateps;
		TclDate_state = TclDatestate;
		goto TclDate_newstate;

		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
	TclDatestack:
		TclDate_pv = TclDatepv;
		TclDate_ps = TclDateps;
		TclDate_state = TclDatestate;

		/*
		** top of for (;;) loop while no reductions done
		*/
	TclDate_stack:
		/*
		** put a state and value onto the stacks
		*/
#if YYDEBUG
		/*
		** if debugging, look up token value in list of value vs.
		** name pairs.  0 and negative (-1) are special values.
		** Note: linear search is used since time is not a real
		** consideration while debugging.
		*/
		if ( TclDatedebug )
		{
			register int TclDate_i;

			printf( "State %d, token ", TclDate_state );
			if ( TclDatechar == 0 )
				printf( "end-of-file\n" );
			else if ( TclDatechar &lt; 0 )
				printf( "-none-\n" );
			else
			{
				for ( TclDate_i = 0; TclDatetoks[TclDate_i].t_val &gt;= 0;
					TclDate_i++ )
				{
					if ( TclDatetoks[TclDate_i].t_val == TclDatechar )
						break;
				}
				printf( "%s\n", TclDatetoks[TclDate_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ++TclDate_ps &gt;= &amp;TclDates[ TclDatemaxdepth ] )	/* room on stack? */
		{
			/*
			** reallocate and recover.  Note that pointers
			** have to be reset, or bad things will happen
			*/
			long TclDateps_index = (TclDate_ps - TclDates);
			long TclDatepv_index = (TclDate_pv - TclDatev);
			long TclDatepvt_index = (TclDatepvt - TclDatev);
			int TclDatenewmax;
#ifdef YYEXPAND
			TclDatenewmax = YYEXPAND(TclDatemaxdepth);
#else
			TclDatenewmax = 2 * TclDatemaxdepth;	/* double table size */
			if (TclDatemaxdepth == YYMAXDEPTH)	/* first time growth */
			{
				char *newTclDates = (char *)YYNEW(int);
				char *newTclDatev = (char *)YYNEW(YYSTYPE);
				if (newTclDates != 0 &amp;&amp; newTclDatev != 0)
				{
					TclDates = YYCOPY(newTclDates, TclDates, int);
					TclDatev = YYCOPY(newTclDatev, TclDatev, YYSTYPE);
				}
				else
					TclDatenewmax = 0;	/* failed */
			}
			else				/* not first time */
			{
				TclDates = YYENLARGE(TclDates, int);
				TclDatev = YYENLARGE(TclDatev, YYSTYPE);
				if (TclDates == 0 || TclDatev == 0)
					TclDatenewmax = 0;	/* failed */
			}
#endif
			if (TclDatenewmax &lt;= TclDatemaxdepth)	/* tables not expanded */
			{
				TclDateerror( "yacc stack overflow" );
				YYABORT;
			}
			TclDatemaxdepth = TclDatenewmax;

			TclDate_ps = TclDates + TclDateps_index;
			TclDate_pv = TclDatev + TclDatepv_index;
			TclDatepvt = TclDatev + TclDatepvt_index;
		}
		*TclDate_ps = TclDate_state;
		*++TclDate_pv = TclDateval;

		/*
		** we have a new state - find out what to do
		*/
	TclDate_newstate:
		if ( ( TclDate_n = TclDatepact[ TclDate_state ] ) &lt;= YYFLAG )
			goto TclDatedefault;		/* simple state */
#if YYDEBUG
		/*
		** if debugging, need to mark whether new token grabbed
		*/
		TclDatetmp = TclDatechar &lt; 0;
#endif
		if ( ( TclDatechar &lt; 0 ) &amp;&amp; ( ( TclDatechar = YYLEX() ) &lt; 0 ) )
			TclDatechar = 0;		/* reached EOF */
#if YYDEBUG
		if ( TclDatedebug &amp;&amp; TclDatetmp )
		{
			register int TclDate_i;

			printf( "Received token " );
			if ( TclDatechar == 0 )
				printf( "end-of-file\n" );
			else if ( TclDatechar &lt; 0 )
				printf( "-none-\n" );
			else
			{
				for ( TclDate_i = 0; TclDatetoks[TclDate_i].t_val &gt;= 0;
					TclDate_i++ )
				{
					if ( TclDatetoks[TclDate_i].t_val == TclDatechar )
						break;
				}
				printf( "%s\n", TclDatetoks[TclDate_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ( ( TclDate_n += TclDatechar ) &lt; 0 ) || ( TclDate_n &gt;= YYLAST ) )
			goto TclDatedefault;
		if ( TclDatechk[ TclDate_n = TclDateact[ TclDate_n ] ] == TclDatechar )	/*valid shift*/
		{
			TclDatechar = -1;
			TclDateval = TclDatelval;
			TclDate_state = TclDate_n;
			if ( TclDateerrflag &gt; 0 )
				TclDateerrflag--;
			goto TclDate_stack;
		}

	TclDatedefault:
		if ( ( TclDate_n = TclDatedef[ TclDate_state ] ) == -2 )
		{
#if YYDEBUG
			TclDatetmp = TclDatechar &lt; 0;
#endif
			if ( ( TclDatechar &lt; 0 ) &amp;&amp; ( ( TclDatechar = YYLEX() ) &lt; 0 ) )
				TclDatechar = 0;		/* reached EOF */
#if YYDEBUG
			if ( TclDatedebug &amp;&amp; TclDatetmp )
			{
				register int TclDate_i;

				printf( "Received token " );
				if ( TclDatechar == 0 )
					printf( "end-of-file\n" );
				else if ( TclDatechar &lt; 0 )
					printf( "-none-\n" );
				else
				{
					for ( TclDate_i = 0;
						TclDatetoks[TclDate_i].t_val &gt;= 0;
						TclDate_i++ )
					{
						if ( TclDatetoks[TclDate_i].t_val
							== TclDatechar )
						{
							break;
						}
					}
					printf( "%s\n", TclDatetoks[TclDate_i].t_name );
				}
			}
#endif /* YYDEBUG */
			/*
			** look through exception table
			*/
			{
				register CONST int *TclDatexi = TclDateexca;

				while ( ( *TclDatexi != -1 ) ||
					( TclDatexi[1] != TclDate_state ) )
				{
					TclDatexi += 2;
				}
				while ( ( *(TclDatexi += 2) &gt;= 0 ) &amp;&amp;
					( *TclDatexi != TclDatechar ) )
					;
				if ( ( TclDate_n = TclDatexi[1] ) &lt; 0 )
					YYACCEPT;
			}
		}

		/*
		** check for syntax error
		*/
		if ( TclDate_n == 0 )	/* have an error */
		{
			/* no worry about speed here! */
			switch ( TclDateerrflag )
			{
			case 0:		/* new error */
				TclDateerror( "syntax error" );
				goto skip_init;
				/*
				** get globals into registers.
				** we have a user generated syntax type error
				*/
				TclDate_pv = TclDatepv;
				TclDate_ps = TclDateps;
				TclDate_state = TclDatestate;
			skip_init:
				TclDatenerrs++;
				/* FALLTHRU */
			case 1:
			case 2:		/* incompletely recovered error */
					/* try again... */
				TclDateerrflag = 3;
				/*
				** find state where "error" is a legal
				** shift action
				*/
				while ( TclDate_ps &gt;= TclDates )
				{
					TclDate_n = TclDatepact[ *TclDate_ps ] + YYERRCODE;
					if ( TclDate_n &gt;= 0 &amp;&amp; TclDate_n &lt; YYLAST &amp;&amp;
						TclDatechk[TclDateact[TclDate_n]] == YYERRCODE)					{
						/*
						** simulate shift of "error"
						*/
						TclDate_state = TclDateact[ TclDate_n ];
						goto TclDate_stack;
					}
					/*
					** current state has no shift on
					** "error", pop stack
					*/
#if YYDEBUG
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
					if ( TclDatedebug )
						printf( _POP_, *TclDate_ps,
							TclDate_ps[-1] );
#	undef _POP_
#endif
					TclDate_ps--;
					TclDate_pv--;
				}
				/*
				** there is no state on stack with "error" as
				** a valid shift.  give up.
				*/
				YYABORT;
			case 3:		/* no shift yet; eat a token */
#if YYDEBUG
				/*
				** if debugging, look up token in list of
				** pairs.  0 and negative shouldn't occur,
				** but since timing doesn't matter when
				** debugging, it doesn't hurt to leave the
				** tests here.
				*/
				if ( TclDatedebug )
				{
					register int TclDate_i;

					printf( "Error recovery discards " );
					if ( TclDatechar == 0 )
						printf( "token end-of-file\n" );
					else if ( TclDatechar &lt; 0 )
						printf( "token -none-\n" );
					else
					{
						for ( TclDate_i = 0;
							TclDatetoks[TclDate_i].t_val &gt;= 0;
							TclDate_i++ )
						{
							if ( TclDatetoks[TclDate_i].t_val
								== TclDatechar )
							{
								break;
							}
						}
						printf( "token %s\n",
							TclDatetoks[TclDate_i].t_name );
					}
				}
#endif /* YYDEBUG */
				if ( TclDatechar == 0 )	/* reached EOF. quit */
					YYABORT;
				TclDatechar = -1;
				goto TclDate_newstate;
			}
		}/* end if ( TclDate_n == 0 ) */
		/*
		** reduction by production TclDate_n
		** put stack tops, etc. so things right after switch
		*/
#if YYDEBUG
		/*
		** if debugging, print the string that is the user's
		** specification of the reduction which is just about
		** to be done.
		*/
		if ( TclDatedebug )
			printf( "Reduce by (%d) \"%s\"\n",
				TclDate_n, TclDatereds[ TclDate_n ] );
#endif
		TclDatetmp = TclDate_n;			/* value to switch over */
		TclDatepvt = TclDate_pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using TclDate_state here as temporary
		** register variable, but why not, if it works...
		** If TclDater2[ TclDate_n ] doesn't have the low order bit
		** set, then there is no action to be done for
		** this reduction.  So, no saving &amp; unsaving of
		** registers done.  The only difference between the
		** code just after the if and the body of the if is
		** the goto TclDate_stack in the body.  This way the test
		** can be made before the choice of what to do is needed.
		*/
		{
			/* length of production doubled with extra bit */
			register int TclDate_len = TclDater2[ TclDate_n ];

			if ( !( TclDate_len &amp; 01 ) )
			{
				TclDate_len &gt;&gt;= 1;
				TclDateval = ( TclDate_pv -= TclDate_len )[1];	/* $$ = $1 */
				TclDate_state = TclDatepgo[ TclDate_n = TclDater1[ TclDate_n ] ] +
					*( TclDate_ps -= TclDate_len ) + 1;
				if ( TclDate_state &gt;= YYLAST ||
					TclDatechk[ TclDate_state =
					TclDateact[ TclDate_state ] ] != -TclDate_n )
				{
					TclDate_state = TclDateact[ TclDatepgo[ TclDate_n ] ];
				}
				goto TclDate_stack;
			}
			TclDate_len &gt;&gt;= 1;
			TclDateval = ( TclDate_pv -= TclDate_len )[1];	/* $$ = $1 */
			TclDate_state = TclDatepgo[ TclDate_n = TclDater1[ TclDate_n ] ] +
				*( TclDate_ps -= TclDate_len ) + 1;
			if ( TclDate_state &gt;= YYLAST ||
				TclDatechk[ TclDate_state = TclDateact[ TclDate_state ] ] != -TclDate_n )
			{
				TclDate_state = TclDateact[ TclDatepgo[ TclDate_n ] ];
			}
		}
					/* save until reenter driver code */
		TclDatestate = TclDate_state;
		TclDateps = TclDate_ps;
		TclDatepv = TclDate_pv;
	}
	/*
	** code supplied by user is placed in this switch
	*/
	switch( TclDatetmp )
	{
		
case 3:{
            TclDateHaveTime++;
        } break;
case 4:{
            TclDateHaveZone++;
        } break;
case 5:{
            TclDateHaveDate++;
        } break;
case 6:{
            TclDateHaveOrdinalMonth++;
        } break;
case 7:{
            TclDateHaveDay++;
        } break;
case 8:{
            TclDateHaveRel++;
        } break;
case 9:{
	    TclDateHaveTime++;
	    TclDateHaveDate++;
	} break;
case 10:{
	    TclDateHaveTime++;
	    TclDateHaveDate++;
	    TclDateHaveRel++;
        } break;
case 12:{
            TclDateHour = TclDatepvt[-1].Number;
            TclDateMinutes = 0;
            TclDateSeconds = 0;
            TclDateMeridian = TclDatepvt[-0].Meridian;
        } break;
case 13:{
            TclDateHour = TclDatepvt[-3].Number;
            TclDateMinutes = TclDatepvt[-1].Number;
            TclDateSeconds = 0;
            TclDateMeridian = TclDatepvt[-0].Meridian;
        } break;
case 14:{
            TclDateHour = TclDatepvt[-4].Number;
            TclDateMinutes = TclDatepvt[-2].Number;
            TclDateMeridian = MER24;
            TclDateDSTmode = DSToff;
            TclDateTimezone = (TclDatepvt[-0].Number % 100 + (TclDatepvt[-0].Number / 100) * 60);
        } break;
case 15:{
            TclDateHour = TclDatepvt[-5].Number;
            TclDateMinutes = TclDatepvt[-3].Number;
            TclDateSeconds = TclDatepvt[-1].Number;
            TclDateMeridian = TclDatepvt[-0].Meridian;
        } break;
case 16:{
            TclDateHour = TclDatepvt[-6].Number;
            TclDateMinutes = TclDatepvt[-4].Number;
            TclDateSeconds = TclDatepvt[-2].Number;
            TclDateMeridian = MER24;
            TclDateDSTmode = DSToff;
            TclDateTimezone = (TclDatepvt[-0].Number % 100 + (TclDatepvt[-0].Number / 100) * 60);
        } break;
case 17:{
            TclDateTimezone = TclDatepvt[-1].Number;
            TclDateDSTmode = DSTon;
        } break;
case 18:{
            TclDateTimezone = TclDatepvt[-0].Number;
            TclDateDSTmode = DSToff;
        } break;
case 19:{
            TclDateTimezone = TclDatepvt[-0].Number;
            TclDateDSTmode = DSTon;
        } break;
case 20:{
            TclDateDayOrdinal = 1;
            TclDateDayNumber = TclDatepvt[-0].Number;
        } break;
case 21:{
            TclDateDayOrdinal = 1;
            TclDateDayNumber = TclDatepvt[-1].Number;
        } break;
case 22:{
            TclDateDayOrdinal = TclDatepvt[-1].Number;
            TclDateDayNumber = TclDatepvt[-0].Number;
        } break;
case 23:{
            TclDateDayOrdinal = TclDatepvt[-2].Number * TclDatepvt[-1].Number;
            TclDateDayNumber = TclDatepvt[-0].Number;
        } break;
case 24:{
            TclDateDayOrdinal = 2;
            TclDateDayNumber = TclDatepvt[-0].Number;
        } break;
case 25:{
            TclDateMonth = TclDatepvt[-2].Number;
            TclDateDay = TclDatepvt[-0].Number;
        } break;
case 26:{
            TclDateMonth = TclDatepvt[-4].Number;
            TclDateDay = TclDatepvt[-2].Number;
            TclDateYear = TclDatepvt[-0].Number;
        } break;
case 27:{
	    TclDateYear = TclDatepvt[-0].Number / 10000;
	    TclDateMonth = (TclDatepvt[-0].Number % 10000)/100;
	    TclDateDay = TclDatepvt[-0].Number % 100;
	} break;
case 28:{
	    TclDateDay = TclDatepvt[-4].Number;
	    TclDateMonth = TclDatepvt[-2].Number;
	    TclDateYear = TclDatepvt[-0].Number;
	} break;
case 29:{
            TclDateMonth = TclDatepvt[-2].Number;
            TclDateDay = TclDatepvt[-0].Number;
            TclDateYear = TclDatepvt[-4].Number;
        } break;
case 30:{
            TclDateMonth = TclDatepvt[-1].Number;
            TclDateDay = TclDatepvt[-0].Number;
        } break;
case 31:{
            TclDateMonth = TclDatepvt[-3].Number;
            TclDateDay = TclDatepvt[-2].Number;
            TclDateYear = TclDatepvt[-0].Number;
        } break;
case 32:{
            TclDateMonth = TclDatepvt[-0].Number;
            TclDateDay = TclDatepvt[-1].Number;
        } break;
case 33:{
	    TclDateMonth = 1;
	    TclDateDay = 1;
	    TclDateYear = EPOCH;
	} break;
case 34:{
            TclDateMonth = TclDatepvt[-1].Number;
            TclDateDay = TclDatepvt[-2].Number;
            TclDateYear = TclDatepvt[-0].Number;
        } break;
case 35:{
	    TclDateMonthOrdinal = 1;
	    TclDateMonth = TclDatepvt[-0].Number;
	} break;
case 36:{
	    TclDateMonthOrdinal = TclDatepvt[-1].Number;
	    TclDateMonth = TclDatepvt[-0].Number;
	} break;
case 37:{
            if (TclDatepvt[-1].Number != HOUR(- 7)) YYABORT;
	    TclDateYear = TclDatepvt[-2].Number / 10000;
	    TclDateMonth = (TclDatepvt[-2].Number % 10000)/100;
	    TclDateDay = TclDatepvt[-2].Number % 100;
	    TclDateHour = TclDatepvt[-0].Number / 10000;
	    TclDateMinutes = (TclDatepvt[-0].Number % 10000)/100;
	    TclDateSeconds = TclDatepvt[-0].Number % 100;
        } break;
case 38:{
            if (TclDatepvt[-5].Number != HOUR(- 7)) YYABORT;
	    TclDateYear = TclDatepvt[-6].Number / 10000;
	    TclDateMonth = (TclDatepvt[-6].Number % 10000)/100;
	    TclDateDay = TclDatepvt[-6].Number % 100;
	    TclDateHour = TclDatepvt[-4].Number;
	    TclDateMinutes = TclDatepvt[-2].Number;
	    TclDateSeconds = TclDatepvt[-0].Number;
        } break;
case 39:{
	    TclDateYear = TclDatepvt[-1].Number / 10000;
	    TclDateMonth = (TclDatepvt[-1].Number % 10000)/100;
	    TclDateDay = TclDatepvt[-1].Number % 100;
	    TclDateHour = TclDatepvt[-0].Number / 10000;
	    TclDateMinutes = (TclDatepvt[-0].Number % 10000)/100;
	    TclDateSeconds = TclDatepvt[-0].Number % 100;
        } break;
case 40:{
            /*
	     * Offset computed year by -377 so that the returned years will
	     * be in a range accessible with a 32 bit clock seconds value
	     */
            TclDateYear = TclDatepvt[-2].Number/1000 + 2323 - 377;
            TclDateDay  = 1;
	    TclDateMonth = 1;
	    TclDateRelDay += ((TclDatepvt[-2].Number%1000)*(365 + IsLeapYear(TclDateYear)))/1000;
	    TclDateRelSeconds += TclDatepvt[-0].Number * 144 * 60;
        } break;
case 41:{
	    TclDateRelSeconds *= -1;
	    TclDateRelMonth *= -1;
	    TclDateRelDay *= -1;
	} break;
case 43:{ *TclDateRelPointer += TclDatepvt[-2].Number * TclDatepvt[-1].Number * TclDatepvt[-0].Number; } break;
case 44:{ *TclDateRelPointer += TclDatepvt[-1].Number * TclDatepvt[-0].Number; } break;
case 45:{ *TclDateRelPointer += TclDatepvt[-0].Number; } break;
case 46:{ *TclDateRelPointer += TclDatepvt[-1].Number * TclDatepvt[-0].Number; } break;
case 47:{ *TclDateRelPointer += TclDatepvt[-0].Number; } break;
case 48:{ TclDateval.Number = -1; } break;
case 49:{ TclDateval.Number =  1; } break;
case 50:{ TclDateval.Number = TclDatepvt[-0].Number; TclDateRelPointer = &amp;TclDateRelSeconds; } break;
case 51:{ TclDateval.Number = TclDatepvt[-0].Number; TclDateRelPointer = &amp;TclDateRelDay; } break;
case 52:{ TclDateval.Number = TclDatepvt[-0].Number; TclDateRelPointer = &amp;TclDateRelMonth; } break;
case 53:{
	if (TclDateHaveTime &amp;&amp; TclDateHaveDate &amp;&amp; !TclDateHaveRel) {
	    TclDateYear = TclDatepvt[-0].Number;
	} else {
	    TclDateHaveTime++;
	    if (TclDatepvt[-0].Number &lt; 100) {
		TclDateHour = TclDatepvt[-0].Number;
		TclDateMinutes = 0;
	    } else {
		TclDateHour = TclDatepvt[-0].Number / 100;
		TclDateMinutes = TclDatepvt[-0].Number % 100;
	    }
	    TclDateSeconds = 0;
	    TclDateMeridian = MER24;
	}
    } break;
case 54:{
            TclDateval.Meridian = MER24;
        } break;
case 55:{
            TclDateval.Meridian = TclDatepvt[-0].Meridian;
        } break;
	}
	goto TclDatestack;		/* reset registers in driver code */
}
</t>
<t tx="ekr.20071105090148.268">@language python
@tabwidth -4
@others
toAdd = set([])
parseBox('/home/tbrown/mail/whitelistd', True, toAdd)
parseBox('/home/tbrown/mail/whitelisti', False, toAdd)

rcfile = '/home/tbrown/.procmailrc'
if toAdd:
    rc = file(rcfile).readlines()
    newfile = file(rcfile, 'w')
    while rc:
        line = rc.pop(0)
        newfile.write(line)
        if 'WHITELIST_MARKER' in line: break
    newfile.write(rc.pop(0)) # copy ':0:' line
    for addr in toAdd:
        newfile.write('* !^From:.*%s\n' % addr)
    while rc:
        line = rc.pop(0)
        newfile.write(line)

os.system("cp /home/tbrown/mail/empty /home/tbrown/mail/whitelistd")
os.system("cp /home/tbrown/mail/empty /home/tbrown/mail/whitelisti")
</t>
<t tx="ekr.20071105090148.269">"""
"""

# mailPerDay.py $Id: oldLeoProjects.leo,v 1.21 2007/12/11 17:42:26 edream Exp $
# Author: Terry Brown
# Created: Thu Jun 07 2007

import os, os.path
import email
import mailbox
import time, datetime
from collections import defaultdict
import sys
</t>
<t tx="ekr.20071105090148.270">
def parseBox(box, domainMode, toAdd):

    mbox = mailbox.UnixMailbox(file(box), email.message_from_file)

    mbox.next() # skip control message

    for msg in mbox:
        f = msg.get('From')
        if f:
            f = email.utils.parseaddr(f)[1]
            if domainMode:
                f = f.split('@')[1]
                f = '.'.join(f.split('.')[-2:])
            toAdd.add(f)

</t>
<t tx="ekr.20071105090148.271">@path c:\prog\test</t>
<t tx="ekr.20071105090148.272"># A test for missing files
</t>
<t tx="ekr.20071105090148.273">@path c:\prog\test</t>
<t tx="ekr.20071105090148.274">
import leoGlobals as g
import leoTest # Support for unit tests.

import parser
import re
import string
import tabnanny
import tokenize

class baseLeoImportCommands:
    """The base class for Leo's import commands."""
    def __init__ (self,c):

        self.c = c
        self._forcedGnxPositionList = []
        self.encoding = g.app.tkEncoding # 2/25/03: was "utf-8"
        self.fileName = None # The original file name, say x.cpp
        self.fileType = None # ".py", ".c", etc.
        self.methodName = None # x, as in &lt; &lt; x methods &gt; &gt; =
        self.output_newline = g.getOutputNewline(c=c) # Value of @bool output_newline
        self.rootLine = "" # Empty or @root + self.fileName
        self.tabwidth = c.tab_width # The tab width in effect in the c.currentPosition.
        self.trace = c.config.getBool('trace_import')
        self.treeType = "@file" # "@root" or "@file"
        self.webType = "@noweb" # "cweb" or "noweb"
        self.web_st = [] # noweb symbol table.
    # Headlines not containing a section reference are ignored in noweb and generate index index in cweb.

    def convertCodePartToWeb (self,s,i,v,result):

        # g.trace(g.get_line(s,i))
        c = self.c ; nl = self.output_newline
        lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
        rb = g.choose(self.webType=="cweb","@&gt;","&gt;&gt;")
        h = string.strip(v.headString())
        # We look for either noweb or cweb brackets. head_ref does not include 
        # these brackets.

        head_ref = None
        j = 0
        if g.match(h,j,"&lt;&lt;"):
            k = string.find(h,"&gt;&gt;",j)
        elif g.match(h,j,"&lt;@"):
            k = string.find(h,"@&gt;",j)
        else:
            k = -1

        if k &gt; -1:
            head_ref = string.strip(h[j+2:k])
            if len(head_ref) == 0:
                head_ref = None
        if g.match(h,0,"@file") or g.match(h,0,"@root"):
            line = h[5:]
            line = string.strip(line)
            # set j &amp; k so line[j:k] is the file name.
            # g.trace(line)

            if g.match(line,0,"&lt;"):
                j = 1 ; k = string.find(line,"&gt;",1)
            elif g.match(line,0,'"'):
                j = 1 ; k = string.find(line,'"',1)
            else:
                j = 0 ; k = string.find(line," ",0)
            if k == -1:
                k = len(line)

            file_name = string.strip(line[j:k])
            if file_name and len(file_name) == 0:
                file_name = None
        else:
            file_name = line = None
        if g.match_word(s,i,"@root"):
            i = g.skip_line(s,i)
            if self.webType == "cweb":
                if not file_name:
                    result += "@&lt;root@&gt;=" + nl
                else:
                    result += "@(" + file_name + "@&gt;" + nl # @(...@&gt; denotes a file.
            else:
                if not file_name:
                    file_name = "*"
                result += lb + file_name + rb + "=" + nl
        elif g.match_word(s,i,"@c") or g.match_word(s,i,"@code"):
            i = g.skip_line(s,i)
            if self.webType == "cweb":
                if not head_ref:
                    result += "@^" + h + "@&gt;" + nl # Convert the headline to an index entry.
                    result += "@c" + nl # @c denotes a new section.
                else: 
                    escaped_head_ref = string.replace(head_ref,"@","@@")
                    result += "@&lt;" + escaped_head_ref + "@&gt;=" + nl
            else:
                if not head_ref:
                    if v == c.currentVnode():
                        head_ref = g.choose(file_name,file_name,"*")
                    else:
                        head_ref = "@others"

                result += lb + head_ref + rb + "=" + nl
        elif g.match_word(h,0,"@file"):
            # Only do this if nothing else matches.
            if self.webType == "cweb":
                if not file_name:
                    result += "@&lt;root@&gt;=" + nl
                else:
                    result += "@(" + file_name + "@&gt;" + nl # @(...@&gt; denotes a file.
            else:
                if not file_name:
                    file_name = "*"
                result += lb + file_name + rb + "=" + nl
            i = g.skip_line(s,i) # 4/28/02
        else:
            if self.webType == "cweb":
                if not head_ref:
                    result += "@^" + h + "@&gt;" + nl # Convert the headline to an index entry.
                    result += "@c" + nl # @c denotes a new section.
                else: 
                    escaped_head_ref = string.replace(head_ref,"@","@@")
                    result += "@&lt;" + escaped_head_ref + "@&gt;=" + nl
            else:
                if not head_ref:
                    if v == c.currentVnode():
                        head_ref = g.choose(file_name,file_name,"*")
                    else:
                        head_ref = "@others"

                result += lb + head_ref + rb + "=" + nl
        i,result = self.copyPart(s,i,result)
        return i, string.strip(result) + nl

    # %defs a b c
    def convertDocPartToWeb (self,s,i,result):

        nl = self.output_newline

        # g.trace(g.get_line(s,i))
        if g.match_word(s,i,"@doc"):
            i = g.skip_line(s,i)
        elif g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@*"):
            i += 2
        elif g.match(s,i,"@\n"):
            i += 1
        i = g.skip_ws_and_nl(s,i)
        i, result2 = self.copyPart(s,i,"")
        if len(result2) &gt; 0:
            # Break lines after periods.
            result2 = string.replace(result2,".  ","." + nl)
            result2 = string.replace(result2,". ","." + nl)
            result += nl+"@"+nl+string.strip(result2)+nl+nl
        else:
            # All nodes should start with '@', even if the doc part is empty.
            result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
        return i, result
    # This code converts a vnode to noweb text as follows:
    # 
    # Convert @doc to @
    # Convert @root or @code to &lt; &lt; name &gt; &gt;=, assuming the headline contains 
    # &lt; &lt; name &gt; &gt;
    # Ignore other directives
    # Format doc parts so they fit in pagewidth columns.
    # Output code parts as is.

    def convertVnodeToWeb (self,v):

        c = self.c
        if not v or not c: return ""
        startInCode = not c.config.at_root_bodies_start_in_doc_mode
        nl = self.output_newline
        s = v.bodyString()
        lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
        i = 0 ; result = "" ; docSeen = False
        while i &lt; len(s):
            progress = i
            # g.trace(g.get_line(s,i))
            i = g.skip_ws_and_nl(s,i)
            if self.isDocStart(s,i) or g.match_word(s,i,"@doc"):
                i,result = self.convertDocPartToWeb(s,i,result)
                docSeen = True
            elif (g.match_word(s,i,"@code") or g.match_word(s,i,"@root") or
                g.match_word(s,i,"@c") or g.match(s,i,lb)):
                if not docSeen:
                    docSeen = True
                    result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
                i,result = self.convertCodePartToWeb(s,i,v,result)
            elif self.treeType == "@file" or startInCode:
                if not docSeen:
                    docSeen = True
                    result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
                i,result = self.convertCodePartToWeb(s,i,v,result)
            else:
                i,result = self.convertDocPartToWeb(s,i,result)
                docSeen = True
            assert(progress &lt; i)
        result = string.strip(result)
        if len(result) &gt; 0:
            result += nl
        return result
    # Copies characters to result until the end of the present section is seen.

    def copyPart (self,s,i,result):

        # g.trace(g.get_line(s,i))
        lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
        rb = g.choose(self.webType=="cweb","@&gt;","&gt;&gt;")
        theType = self.webType
        while i &lt; len(s):
            progress = j = i # We should be at the start of a line here.
            i = g.skip_nl(s,i) ; i = g.skip_ws(s,i)
            if self.isDocStart(s,i):
                return i, result
            if (g.match_word(s,i,"@doc") or
                g.match_word(s,i,"@c") or
                g.match_word(s,i,"@root") or
                g.match_word(s,i,"@code")): # 2/25/03
                return i, result
            elif (g.match(s,i,"&lt;&lt;") and # must be on separate lines.
                g.find_on_line(s,i,"&gt;&gt;=") &gt; -1):
                return i, result
            else:
                # Copy the entire line, escaping '@' and
                # Converting @others to &lt; &lt; @ others &gt; &gt;
                i = g.skip_line(s,j) ; line = s[j:i]
                if theType == "cweb":
                    line = string.replace(line,"@","@@")
                else:
                    j = g.skip_ws(line,0)
                    if g.match(line,j,"@others"):
                        line = string.replace(line,"@others",lb + "@others" + rb)
                    elif g.match(line,0,"@"):
                        # Special case: do not escape @ %defs.
                        k = g.skip_ws(line,1)
                        if not g.match(line,k,"%defs"):
                            line = "@" + line
                result += line
            assert(progress &lt; i)
        return i, string.rstrip(result)
    def exportHeadlines (self,fileName):

        c = self.c ; nl = self.output_newline
        p = c.currentPosition()
        if not p: return
        self.setEncoding()
        firstLevel = p.level()
        mode = c.config.output_newline
        mode = g.choose(mode=="platform",'w','wb')
        try:
            theFile = open(fileName,mode)
        except IOError:
            g.es("Can not open " + fileName,color="blue")
            leoTest.fail()
            return
        for p in p.self_and_subtree_iter():
            head = p.moreHead(firstLevel,useVerticalBar=True)
            head = g.toEncodedString(head,self.encoding,reportErrors=True)
            theFile.write(head + nl)
        theFile.close()
    def flattenOutline (self,fileName):

        c = self.c ; nl = self.output_newline
        p = c.currentVnode()
        if not p: return
        self.setEncoding()
        firstLevel = p.level()

        # 10/14/02: support for output_newline setting.
        mode = c.config.output_newline
        mode = g.choose(mode=="platform",'w','wb')
        try:
            theFile = open(fileName,mode)
        except IOError:
            g.es("Can not open " + fileName,color="blue")
            leoTest.fail()
            return

        for p in p.self_and_subtree_iter():
            head = p.moreHead(firstLevel)
            head = g.toEncodedString(head,self.encoding,reportErrors=True)
            theFile.write(head + nl)
            body = p.moreBody() # Inserts escapes.
            if len(body) &gt; 0:
                body = g.toEncodedString(body,self.encoding,reportErrors=True)
                theFile.write(body + nl)
        theFile.close()
    def outlineToWeb (self,fileName,webType):

        c = self.c ; nl = self.output_newline
        current = c.currentPosition()
        if not current: return
        self.setEncoding()
        self.webType = webType
        # 10/14/02: support for output_newline setting.
        mode = c.config.output_newline
        mode = g.choose(mode=="platform",'w','wb')
        try:
            theFile = open(fileName,mode)
        except IOError:
            g.es("Can not open " + fileName,color="blue")
            leoTest.fail()
            return

        self.treeType = "@file"
        # Set self.treeType to @root if p or an ancestor is an @root node.
        for p in current.parents_iter():
            flag,junk = g.is_special(p.bodyString(),0,"@root")
            if flag:
                self.treeType = "@root"
                break
        for p in current.self_and_subtree_iter():
            s = self.convertVnodeToWeb(p)
            if len(s) &gt; 0:
                s = g.toEncodedString(s,self.encoding,reportErrors=True)
                theFile.write(s)
                if s[-1] != '\n': theFile.write(nl)
        theFile.close()
    def removeSentinelsCommand (self,paths,toString=False):

        c = self.c

        self.setEncoding()

        for fileName in paths:
            g.setGlobalOpenDir(fileName)
            path, self.fileName = g.os_path_split(fileName)
            try:
                theFile = open(fileName)
                s = theFile.read()
                s = g.toUnicode(s,self.encoding)
                theFile.close()
            except IOError:
                g.es("can not open " + fileName, color="blue")
                leoTest.fail()
                return
            # Skip any non @+leo lines.
            i = 0
            while i &lt; len(s) and not g.find_on_line(s,i,"@+leo"):
                i = g.skip_line(s,i)

            # Get the comment delims from the @+leo sentinel line.
            at = self.c.atFileCommands
            j = g.skip_line(s,i) ; line = s[i:j]

            valid,new_df,start_delim,end_delim,derivedFileIsThin = at.parseLeoSentinel(line)
            if not valid:
                g.es("invalid @+leo sentinel in " + fileName)
                return

            if end_delim:
                line_delim = None
            else:
                line_delim,start_delim = start_delim,None
            # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
            s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
            ext = c.config.remove_sentinels_extension
            if not ext:
                ext = ".txt"
            if ext[0] == '.':
                newFileName = g.os_path_join(path,fileName+ext)
            else:
                head,ext2 = g.os_path_splitext(fileName) 
                newFileName = g.os_path_join(path,head+ext+ext2)
            if toString:
                return s
            else:
                try:
                    mode = c.config.output_newline
                    mode = g.choose(mode=="platform",'w','wb')
                    theFile = open(newFileName,mode)
                    s = g.toEncodedString(s,self.encoding,reportErrors=True)
                    theFile.write(s)
                    theFile.close()
                    if not g.unitTesting:
                        g.es("created: " + newFileName)
                except:
                    g.es("exception creating: " + newFileName)
                    g.es_exception()
                return None
    # This does not handle @nonl properly, but that's a nit...

    def removeSentinelLines(self,s,line_delim,start_delim,end_delim):

        '''Properly remove all sentinle lines in s.'''

        __pychecker__ = '--no-argsused' # end_delim.

        delim = (line_delim or start_delim or '') + '@'
        verbatim = delim + 'verbatim' ; verbatimFlag = False
        result = [] ; lines = g.splitLines(s)
        for line in lines:
            i = g.skip_ws(line,0)
            if not verbatimFlag and g.match(line,i,delim):
                if g.match(line,i,verbatim):
                    verbatimFlag = True # Force the next line to be in the result.
                # g.trace(repr(line))
            else:
                result.append(line)
                verbatimFlag = False
        result = ''.join(result)
        return result
    def weave (self,filename):

        c = self.c ; nl = self.output_newline
        p = c.currentPosition()
        if not p: return
        self.setEncoding()
        try:
            # 10/14/02: support for output_newline setting.
            mode = c.config.output_newline
            mode = g.choose(mode=="platform",'w','wb')
            f = open(filename,mode)
            if not f: return
        except:
            g.es("exception opening:" + filename)
            g.es_exception()
            return
        for p in p.self_and_subtree_iter():
            s = p.bodyString()
            s2 = string.strip(s)
            if s2 and len(s2) &gt; 0:
                f.write("-" * 60) ; f.write(nl)
                # write the headlines of p, p's parent and p's grandparent.
                context = [] ; p2 = p.copy() ; i = 0
                while i &lt; 3:
                    i += 1
                    if not p2: break
                    context.append(p2.headString())
                    p2.moveToParent()

                context.reverse()
                indent = ""
                for line in context:
                    f.write(indent)
                    indent += '\t'
                    line = g.toEncodedString(line,self.encoding,reportErrors=True)
                    f.write(line)
                    f.write(nl)
                f.write("-" * 60) ; f.write(nl)
                s = g.toEncodedString(s,self.encoding,reportErrors=True)
                f.write(string.rstrip(s) + nl)
        f.flush()
        f.close()
    def createHeadline (self,parent,body,headline):

        # g.trace("parent,headline:",parent,headline)
        # Create the vnode.
        v = parent.insertAsLastChild()
        v.initHeadString(headline,self.encoding)
        # Set the body.
        if len(body) &gt; 0:
            self.c.setBodyString(v,body,self.encoding)
        return v
    def error (self,s): g.es(s)
    def getTabWidth (self):

        d = g.scanDirectives(self.c)
        w = d.get("tabwidth")
        if w not in (0,None):
            return w
        else:
            return self.c.tab_width
    # The start of a document part or module in a noweb or cweb file.
    # Exporters may have to test for @doc as well.

    def isDocStart (self,s,i):

        if not g.match(s,i,"@"):
            return False

        j = g.skip_ws(s,i+1)
        if g.match(s,j,"%defs"):
            return False
        elif self.webType == "cweb" and g.match(s,i,"@*"):
            return True
        else:
            return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

    def isModuleStart (self,s,i):

        if self.isDocStart(s,i):
            return True
        else:
            return self.webType == "cweb" and (
                g.match(s,i,"@c") or g.match(s,i,"@p") or
                g.match(s,i,"@d") or g.match(s,i,"@f"))
    def massageComment (self,s):

        '''Returns s with all runs of whitespace and newlines converted to a single blank.

        Also removes leading and trailing whitespace.'''

        # g.trace(g.get_line(s,0))
        s = string.strip(s)
        s = string.replace(s,"\n"," ")
        s = string.replace(s,"\r"," ")
        s = string.replace(s,"\t"," ")
        s = string.replace(s,"  "," ")
        s = string.strip(s)
        return s
    def massageWebBody (self,s):

        theType = self.webType
        lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
        rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")
        i = 0
        while i &lt; len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isDocStart(s,i):
                # Scan to end of the doc part.
                if g.match(s,i,"@ %def"):
                    # Don't remove the newline following %def
                    i = g.skip_line(s,i) ; start = end = i
                else:
                    start = end = i ; i += 2
                while i &lt; len(s):
                    progress2 = i
                    i = g.skip_ws_and_nl(s,i)
                    if self.isModuleStart(s,i) or g.match(s,i,lb):
                        end = i ; break
                    elif theType == "cweb": i += 1
                    else: i = g.skip_to_end_of_line(s,i)
                    assert (i &gt; progress2)
                # Remove newlines from start to end.
                doc = s[start:end]
                doc = string.replace(doc,"\n"," ")
                doc = string.replace(doc,"\r","")
                doc = string.strip(doc)
                if doc and len(doc) &gt; 0:
                    if doc == "@":
                        doc = g.choose(self.webType=="cweb", "@ ","@\n")
                    else:
                        doc += "\n\n"
                    # g.trace("new doc:",doc)
                    s = s[:start] + doc + s[end:]
                    i = start + len(doc)
            else: i = g.skip_line(s,i)
            assert (i &gt; progress)
        i = 0
        while i &lt; len(s):
            progress = i
            # g.trace(g.get_line(s,i))
            if g.match(s,i,lb):
                i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
                if k &gt; -1:
                    name = s[j:k]
                    name2 = self.cstLookup(name)
                    if name != name2:
                        # Replace name by name2 in s.
                        # g.trace("replacing %s by %s" % (name,name2))
                        s = s[:j] + name2 + s[k:]
                        i = j + len(name2)
            i = g.skip_line(s,i)
            assert (i &gt; progress)
        s = string.rstrip(s)
        return s
    def setEncoding (self):

        # scanDirectives checks the encoding: may return None.
        theDict = g.scanDirectives(self.c)
        encoding = theDict.get("encoding")
        if encoding and g.isValidEncoding(encoding):
            self.encoding = encoding
        else:
            self.encoding = g.app.tkEncoding # 2/25/03

        # print self.encoding
    def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

        c = self.c ; u = c.undoer ; s1 = s
        junk,self.fileName = g.os_path_split(fileName)
        self.methodName,self.fileType = g.os_path_splitext(self.fileName)
        self.setEncoding()
        # g.trace(self.fileName,self.fileType)
        # All file types except the following just get copied to the parent node.
        if not ext: ext = self.fileType
        ext = ext.lower()
        if not s:
            try:
                theFile = open(fileName)
                s = theFile.read()
                s = g.toUnicode(s,self.encoding)
                theFile.close()
            except IOError:
                g.es("can not open " + fileName)
                leoTest.fail()
                return None

        # Create the top-level headline.
        if atAuto:
            p = parent.copy()
            c.beginUpdate()
            p.setTnodeText('')
            # It is too dangerous not to write @auto trees to the .leo file,
            # so we must delete all children here.
            try:
                while p.hasChildren():
                    # g.trace('deleting',p.headString())
                    p.firstChild().doDelete()
            finally:
                c.endUpdate(False)
        else:
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAsLastChild()
            if self.treeType == "@file" and not s1:
                p.initHeadString("@file " + fileName)
            else:
                p.initHeadString(fileName)
            u.afterInsertNode(p,'Import',undoData)

        self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

        if ext in (".c", ".cpp", ".cxx"):
            self.scanCText(s,p,atAuto=atAuto)
        elif ext == ".el":
            self.scanElispText(s,p,atAuto=atAuto)
        elif ext == ".java":
            self.scanJavaText(s,p,atAuto=atAuto)
        elif ext == ".pas":
            self.scanPascalText(s,p,atAuto=atAuto)
        elif ext in (".py", ".pyw"):
            self.scanPythonText(s,p,atAuto=atAuto)
        elif ext == ".php":
            self.scanPHPText(s,p,atAuto=atAuto)
        else:
            self.scanUnknownFileType(s,p,ext)

        if atAuto: p.contract()
        return p
    def importDerivedFiles (self,parent=None,paths=None):
        # Not a command.  It must *not* have an event arg.

        c = self.c ; u = c.undoer ; command = 'Import'
        at = c.atFileCommands ; current = c.currentPosition()
        self.tab_width = self.getTabWidth()
        if not paths: return
        c.beginUpdate()
        try:
            u.beforeChangeGroup(current,command)
            for fileName in paths:
                g.setGlobalOpenDir(fileName)
                fileName = g.os_path_normpath(fileName)

                try:
                    theFile = open(fileName,'rb')
                    isThin = at.scanHeaderForThin(theFile,fileName)
                    theFile.close()
                except IOError:
                    isThin = False
                undoData = u.beforeInsertNode(parent)
                p = parent.insertAfter()
                if isThin:
                    at.forceGnxOnPosition(p)
                    p.initHeadString("@thin " + fileName)
                    at.read(p,thinFile=True)
                else:
                    p.initHeadString("Imported @file " + fileName)
                    at.read(p,importFileName=fileName)
                p.contract()
                u.afterInsertNode(p,command,undoData)
            current.expand()
            c.selectPosition(current)
            c.setChanged(True)
            u.afterChangeGroup(p,command)
        finally:
            c.endUpdate()
    def forceGnxOnPosition (self,p):

        self._forcedGnxPositionList.append(p.v)
    def importFilesCommand (self,files=None,treeType=None,
        perfectImport=True,testing=False,verbose=False):
            # Not a command.  It must *not* have an event arg.

        c = self.c
        if c == None: return
        v = current = c.currentVnode()
        if current == None: return
        if len(files) &lt; 1: return
        self.tab_width = self.getTabWidth() # New in 4.3.
        self.treeType = treeType
        c.beginUpdate()
        try: # range of update...
            if len(files) == 2:
                # The two filenames have a common prefix everything before the 
                # last period is the same.  For example, x.h and x.cpp.

                name0 = files[0]
                name1 = files[1]
                prefix0, junk = g.os_path_splitext(name0)
                prefix1, junk = g.os_path_splitext(name1)
                if len(prefix0) &gt; 0 and prefix0 == prefix1:
                    current = current.insertAsLastChild()
                    junk, nameExt = g.os_path_split(prefix1)
                    name,ext = g.os_path_splitext(prefix1)
                    current.initHeadString(name)
            for fileName in files:
                g.setGlobalOpenDir(fileName)
                v = self.createOutline(fileName,current)
                if v: # createOutline may fail.
                    perfectImport = False ###
                    testing = True; verbose = True
                    if perfectImport and treeType == "@file": # Can't correct @root trees.
                        self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                    else:
                        if not g.unitTesting:
                            g.es("imported " + fileName,color="blue")
                    v.contract()
                    v.setDirty()
                    c.setChanged(True)
            c.validateOutline()
            current.expand()
        finally:
            c.endUpdate()
        c.selectVnode(current)
    # Used by paste logic.

    def convertMoreStringToOutlineAfter (self,s,firstVnode):
        s = string.replace(s,"\r","")
        strings = string.split(s,"\n")
        return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

    # Almost all the time spent in this command is spent here.

    def convertMoreStringsToOutlineAfter (self,strings,firstVnode):

        __pychecker__ = '--no-objattrs' # suppress bad warnings re lastVnode.

        c = self.c
        if len(strings) == 0: return None
        if not self.stringsAreValidMoreFile(strings): return None
        c.beginUpdate()
        try: # range of update...
            firstLevel, junk = self.moreHeadlineLevel(strings[0])
            lastLevel = -1 ; theRoot = lastVnode = None
            index = 0
            while index &lt; len(strings):
                progress = index
                s = strings[index]
                level, newFlag = self.moreHeadlineLevel(s)
                level -= firstLevel
                if level &gt;= 0:
                    assert(level &gt;= 0)
                    if lastVnode is None:
                        # g.trace(firstVnode)
                        theRoot = v = firstVnode.insertAfter()
                    elif level == lastLevel:
                        v = lastVnode.insertAfter()
                    elif level == lastLevel + 1:
                        v = lastVnode.insertAsNthChild(0)
                    else:
                        assert(level &lt; lastLevel)
                        while level &lt; lastLevel:
                            lastLevel -= 1
                            lastVnode = lastVnode.parent()
                            assert(lastVnode)
                            assert(lastLevel &gt;= 0)
                        v = lastVnode.insertAfter()
                    lastVnode = v
                    lastLevel = level
                    j = 0
                    while g.match(s,j,'\t'):
                        j += 1
                    if g.match(s,j,"+ ") or g.match(s,j,"- "):
                        j += 2

                    v.initHeadString(s[j:])
                    bodyLines = 0
                    index += 1 # Skip the headline.
                    while index &lt; len(strings):
                        s = strings[index]
                        level, junk = self.moreHeadlineLevel(s)
                        level -= firstLevel
                        if level &gt;= 0:
                            break
                        # Remove first backslash of the body line.
                        if g.match(s,0,'\\'):
                            strings[index] = s[1:]
                        bodyLines += 1
                        index += 1
                    if bodyLines &gt; 0:
                        body = ""
                        n = index - bodyLines
                        while n &lt; index:
                            body += strings[n]
                            if n != index - 1:
                                body += "\n"
                            n += 1
                        v.setTnodeText(body)
                    v.setDirty()
                else: index += 1
                assert progress &lt; index
            if theRoot:
                theRoot.setDirty()
                c.setChanged(True)
        finally:
            c.endUpdate()
        return theRoot
    def importFlattenedOutline (self,files): # Not a command, so no event arg.

        c = self.c ; u = c.undoer ; current = c.currentPosition()
        if current == None: return
        if len(files) &lt; 1: return

        self.setEncoding()
        fileName = files[0] # files contains at most one file.
        g.setGlobalOpenDir(fileName)
        try:
            theFile = open(fileName)
            s = theFile.read()
            s = string.replace(s,"\r","")
            s = g.toUnicode(s,self.encoding)
            array = string.split(s,"\n")
            theFile.close()
        except IOError:
            g.es("Can not open " + fileName, color="blue")
            leoTest.fail()
            return

        # Convert the string to an outline and insert it after the current node.
        undoData = u.beforeInsertNode(current)
        p = self.convertMoreStringsToOutlineAfter(array,current)
        if p:
            c.endEditing()
            c.validateOutline()
            c.editPosition(p)
            p.setDirty()
            c.setChanged(True)
            u.afterInsertNode(p,'Import',undoData)
        else:
            g.es(fileName + " is not a valid MORE file.")
    # return the headline level of s,or -1 if the string is not a MORE headline.
    def moreHeadlineLevel (self,s):

        level = 0 ; i = 0
        while g.match(s,i,'\t'):
            level += 1
            i += 1
        plusFlag = g.choose(g.match(s,i,"+"),True,False)
        if g.match(s,i,"+ ") or g.match(s,i,"- "):
            return level, plusFlag
        else:
            return -1, plusFlag
    # Used by paste logic.

    def stringIsValidMoreFile (self,s):

        s = string.replace(s,"\r","")
        strings = string.split(s,"\n")
        return self.stringsAreValidMoreFile(strings)

    def stringsAreValidMoreFile (self,strings):

        if len(strings) &lt; 1: return False
        level1, plusFlag = self.moreHeadlineLevel(strings[0])
        if level1 == -1: return False
        # Check the level of all headlines.
        i = 0 ; lastLevel = level1
        while i &lt; len(strings):
            s = strings[i] ; i += 1
            level, newFlag = self.moreHeadlineLevel(s)
            if level &gt; 0:
                if level &lt; level1 or level &gt; lastLevel + 1:
                    return False # improper level.
                elif level &gt; lastLevel and not plusFlag:
                    return False # parent of this node has no children.
                elif level == lastLevel and plusFlag:
                    return False # last node has missing child.
                else:
                    lastLevel = level
                    plusFlag = newFlag
        return True
    def createOutlineFromWeb (self,path,parent):

        c = self.c ; u = c.undoer
        junk,fileName = g.os_path_split(path)

        undoData = u.beforeInsertNode(parent)

        # Create the top-level headline.
        p = parent.insertAsLastChild()
        p.initHeadString(fileName)
        if self.webType=="cweb":
            c.setBodyString(p,"@ignore\n" + self.rootLine + "@language cweb")

        # Scan the file, creating one section for each function definition.
        self.scanWebFile(path,p)

        u.afterInsertNode(p,'Import',undoData)

        return p
    def importWebCommand (self,files,webType):

        c = self.c ; current = c.currentVnode()
        if current == None: return
        if not files: return
        self.tab_width = self.getTabWidth() # New in 4.3.
        self.webType = webType

        c.beginUpdate()
        try:
            for fileName in files:
                g.setGlobalOpenDir(fileName)
                v = self.createOutlineFromWeb(fileName,current)
                v.contract()
                v.setDirty()
                c.setChanged(True)
            c.selectVnode(current)
        finally:
            c.endUpdate()
    def findFunctionDef (self,s,i):

        # Look at the next non-blank line for a function name.
        i = g.skip_ws_and_nl(s,i)
        k = g.skip_line(s,i)
        name = None
        while i &lt; k:
            if g.is_c_id(s[i]):
                j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
            elif s[i] == '(':
                if name: return name
                else: break
            else: i += 1
        return None
    # This method returns the proper headline text.
    # 
    # 1. If s contains a section def, return the section ref.
    # 2. cweb only: if s contains @c, return the function name following the 
    # @c.
    # 3. cweb only: if s contains @d name, returns @d name.
    # 4. Otherwise, returns "@"

    def scanBodyForHeadline (self,s):

        if self.webType == "cweb":
            i = 0
            while i &lt; len(s):
                i = g.skip_ws_and_nl(s,i)
                # line = g.get_line(s,i) ; g.trace(line)
                # Allow constructs such as @ @c, or @ @&lt;.
                if self.isDocStart(s,i):
                    i += 2 ; i = g.skip_ws(s,i)
                if g.match(s,i,"@d") or g.match(s,i,"@f"):
                    # Look for a macro name.
                    directive = s[i:i+2]
                    i = g.skip_ws(s,i+2) # skip the @d or @f
                    if i &lt; len(s) and g.is_c_id(s[i]):
                        j = i ; g.skip_c_id(s,i) ; return s[j:i]
                    else: return directive
                elif g.match(s,i,"@c") or g.match(s,i,"@p"):
                    # Look for a function def.
                    name = self.findFunctionDef(s,i+2)
                    return g.choose(name,name,"outer function")
                elif g.match(s,i,"@&lt;"):
                    # Look for a section def.
                    # A small bug: the section def must end on this line.
                    j = i ; k = g.find_on_line(s,i,"@&gt;")
                    if k &gt; -1 and (g.match(s,k+2,"+=") or g.match(s,k+2,"=")):
                        return s[j:k+2] # return the section ref.
                i = g.skip_line(s,i)
        else:
            i = 0
            while i &lt; len(s):
                i = g.skip_ws_and_nl(s,i)
                # line = g.get_line(s,i) ; g.trace(line)
                if g.match(s,i,"&lt;&lt;"):
                    k = g.find_on_line(s,i,"&gt;&gt;=")
                    if k &gt; -1:
                        ref = s[i:k+2]
                        name = string.strip(s[i+2:k])
                        if name != "@others":
                            return ref
                else:
                    name = self.findFunctionDef(s,i)
                    if name:
                        return name
                i = g.skip_line(s,i)
        return "@" # default.
    def scanWebFile (self,fileName,parent):

        theType = self.webType
        lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
        rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")

        try: # Read the file into s.
            f = open(fileName)
            s = f.read()
        except:
            g.es("Can not import " + fileName, color="blue")
            return

        i = 0 ; self.web_st = []

        while i &lt; len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            # line = g.get_line(s,i) ; g.trace(line)
            if self.isDocStart(s,i):
                if theType == "cweb": i += 2
                else: i = g.skip_line(s,i)
            elif theType == "cweb" and g.match(s,i,"@@"):
                i += 2
            elif g.match(s,i,lb):
                i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
                if k &gt; -1: self.cstEnter(s[j:k])
            else: i += 1
            assert (i &gt; progress)

        # g.trace(self.cstDump())
        i = 0
        while i &lt; len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i) or g.match(s,i,lb):
                break
            else: i = g.skip_line(s,i)
            assert(i &gt; progress)

        j = g.skip_ws(s,0)
        if j &lt; i:
            self.createHeadline(parent,"@ " + s[j:i],"Limbo")

        j = i
        if g.match(s,i,lb):
            while i &lt; len(s):
                progress = i
                i = g.skip_ws_and_nl(s,i)
                if self.isModuleStart(s,i):
                    break
                else: i = g.skip_line(s,i)
                assert(i &gt; progress)
            self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

        # g.trace(g.get_line(s,i))
        while i &lt; len(s):
            outer_progress = i
            if theType=="cweb":
                assert(self.isModuleStart(s,i))
                start = i
                if self.isDocStart(s,i):
                    i += 2
                    while i &lt; len(s):
                        progress = i
                        i = g.skip_ws_and_nl(s,i)
                        if self.isModuleStart(s,i): break
                        else: i = g.skip_line(s,i)
                        assert (i &gt; progress)
                if g.match(s,i,"@d") or g.match(s,i,"@f"):
                    i += 2 ; i = g.skip_line(s,i)
                    # Place all @d and @f directives in the same node.
                    while i &lt; len(s):
                        progress = i
                        i = g.skip_ws_and_nl(s,i)
                        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
                        else: break
                        assert (i &gt; progress)
                    i = g.skip_ws_and_nl(s,i)

                while i &lt; len(s) and not self.isModuleStart(s,i):
                    progress = i
                    i = g.skip_line(s,i)
                    i = g.skip_ws_and_nl(s,i)
                    assert (i &gt; progress)

                if g.match(s,i,"@c") or g.match(s,i,"@p"):
                    i += 2
                    while i &lt; len(s):
                        progress = i
                        i = g.skip_line(s,i)
                        i = g.skip_ws_and_nl(s,i)
                        if self.isModuleStart(s,i):
                            break
                        assert (i &gt; progress)
            else:
                assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
                start = i ; i = g.skip_line(s,i)
                while i &lt; len(s):
                    progress = i
                    i = g.skip_ws_and_nl(s,i)
                    if self.isDocStart(s,i): break
                    else: i = g.skip_line(s,i)
                    assert (i &gt; progress)

            body = s[start:i]
            body = self.massageWebBody(body)
            headline = self.scanBodyForHeadline(body)
            self.createHeadline(parent,body,headline)
            assert(i &gt; outer_progress)
    # We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.

    def cstCanonicalize (self,s,lower=True):

        if lower:
            s = string.lower(s)
        s = string.replace(s,"\t"," ")
        s = string.replace(s,"\r","")
        s = string.replace(s,"\n"," ")
        s = string.replace(s,"  "," ")
        s = string.strip(s)
        return s
    def cstDump (self):

        self.web_st.sort()
        s = "Web Symbol Table...\n\n"
        for name in self.web_st:
            s += name + "\n"
        return s
    # We only enter the section name into the symbol table if the ... convention is not used.

    def cstEnter (self,s):

        # Don't enter names that end in "..."
        s = string.rstrip(s)
        if s.endswith("..."): return

        # Put the section name in the symbol table, retaining capitalization.
        lower = self.cstCanonicalize(s,True)  # do lower
        upper = self.cstCanonicalize(s,False) # don't lower.
        for name in self.web_st:
            if string.lower(name) == lower:
                return
        self.web_st.append(upper)
    # This method returns a string if the indicated string is a prefix of an entry in the web_st.

    def cstLookup (self,target):

        # Do nothing if the ... convention is not used.
        target = string.strip(target)
        if not target.endswith("..."): return target
        # Canonicalize the target name, and remove the trailing "..."
        ctarget = target[:-3]
        ctarget = self.cstCanonicalize(ctarget)
        ctarget = string.strip(ctarget)
        found = False ; result = target
        for s in self.web_st:
            cs = self.cstCanonicalize(s)
            if cs[:len(ctarget)] == ctarget:
                if found:
                    g.es("****** " + target + ": is also a prefix of: " + s)
                else:
                    found = True ; result = s
                    # g.es("replacing: " + target + " with: " + s)
        return result
    def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):

        __pychecker__ = 'maxlines=500'

        # 
        # This algorithm corrects the result of an Import To @file command so 
        # that it is guaranteed that the result of writing the imported file 
        # will be identical to the original file except for any sentinels that 
        # have been inserted.
        # 
        # On entry, p points to the newly imported outline.
        # 
        # We correct the outline by applying Bernhard Mulder's algorithm.
        # 
        # 1.  We use the atFile.write code to write the newly imported outline 
        # to a string s.  This string contains represents a thin derived file, 
        # so it can be used to recreate then entire outline structure without 
        # any other information.
        # 
        # Splitting s into lines creates the fat_lines argument to mu methods.
        # 
        # 2. We make corrections to fat_lines using Mulder's algorithm.  The 
        # corrected fat_lines represents the corrected outline.  To do this, 
        # we set the arguments as follows:
        # 
        # - i_lines: fat_lines stripped of sentinels
        # - j_lines to the lines of the original imported file.
        # 
        # The algorithm updates fat_lines using diffs between i_lines and 
        # j_lines.
        # 
        # 3. Mulder's algorithm doesn't specify which nodes have been 
        # changed.  In fact, it Mulder's algorithm doesn't really understand 
        # nodes at all.  Therefore, if we want to mark changed nodes we do so 
        # by comparing the original version of the imported outline with the 
        # corrected version of the outline.
        c = self.c
        root = p.copy()
        at = c.atFileCommands
        if testing:
            for p2 in p.self_and_subtree_iter():
                p2.clearDirty()
        nodeIndices = g.app.nodeIndices

        nodeIndices.setTimestamp()

        for p2 in root.self_and_subtree_iter():
            try: # Will fail for None or any pre 4.1 file index.
                theId,time,n = p2.v.t.fileIndex
            except TypeError:
                p2.v.t.fileIndex = nodeIndices.getNewIndex()
        at.write(root,thinFile=True,toString=True)
        s = at.stringOutput
        if not s: return

        # Set up the data for the algorithm.
        mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
        delims = g.comment_delims_from_extension(fileName)
        fat_lines = g.splitLines(s) # Keep the line endings.
        i_lines,mapping = mu.create_mapping(fat_lines,delims)
        j_lines = file(fileName).readlines()

        # Correct write_lines using the algorihm.
        if i_lines != j_lines:
            if verbose:
                g.es("Running Perfect Import",color="blue")
            write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
            if 1: # For testing.
                write_lines_node = root.insertAfter()
                write_lines_node.initHeadString("write_lines")
                s = ''.join(write_lines)
                write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)
            # Notes:
            # 1. This code must overwrite the newly-imported tree because the 
            # gnx's in
            # write_lines refer to those nodes.
            # 
            # 2. The code in readEndNode now reports when nodes change during 
            # importing. This
            # code also marks changed nodes.

            try:
                at.correctedLines = 0
                at.targetFileName = "&lt;perfectImport string-file&gt;"
                at.inputFile = fo = g.fileLikeObject()
                at.file = fo # Strange, that this is needed.  Should be cleaned up.
                for line in write_lines:
                    fo.write(line)
                firstLines,junk,junk = c.atFileCommands.scanHeader(fo,at.targetFileName)
                # To do: pass params to readEndNode.
                at.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
                n = at.correctedLines
                if verbose:
                    g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
            except:
                g.es("Exception in Perfect Import",color="red")
                g.es_exception()
                s = None
        if verify:
            try:
                # Read the original file into before_lines.
                before = file(fileName)
                before_lines = before.readlines()
                before.close()

                # Write the tree into after_lines.
                at.write(root,thinFile=True,toString=True)
                after_lines1 = g.splitLines(at.stringOutput)

                # Strip sentinels from after_lines and compare.
                after_lines = mu.removeSentinelsFromLines(after_lines1,delims)

                # A major kludge: Leo can not represent unindented blank lines in indented nodes!
                # We ignore the problem here by stripping whitespace from blank lines.
                # We shall need output options to handle such lines.
                if convertBlankLines:
                    mu.stripWhitespaceFromBlankLines(before_lines)
                    mu.stripWhitespaceFromBlankLines(after_lines)
                if before_lines == after_lines:
                    if verbose:
                        g.es("Perfect Import verified",color="blue")
                else:
                    leoTest.fail()
                    if verbose:
                        g.es("Perfect Import failed verification test!",color="red")
                        print len(before_lines),len(after_lines)

                        if len(before_lines)==len(after_lines):
                            for i in xrange(len(before_lines)):
                                extra = 3
                                if before_lines[i] != after_lines[i]:
                                    j = max(0,i-extra)
                                    print '-' * 20
                                    while j &lt; i + extra + 1:
                                        leader = g.choose(i == j,"* ","  ")
                                        print "%s%3d" % (leader,j), repr(before_lines[j])
                                        print "%s%3d" % (leader,j), repr(after_lines[j])
                                        j += 1
                        else:
                            for i in xrange(min(len(before_lines),len(after_lines))):
                                if before_lines[i] != after_lines[i]:
                                    extra = 5
                                    print "first mismatch at line %d" % i
                                    print "printing %d lines after mismatch" % extra
                                    print "before..."
                                    for j in xrange(i+1+extra):
                                        print "%3d" % j, repr(before_lines[j])
                                    print
                                    print "after..."
                                    for k in xrange(1+extra):
                                        print "%3d" % (i+k), repr(after_lines[i+k])
                                    print
                                    print "with sentinels"
                                    j = 0 ; k = 0
                                    while k &lt; i + 1 + extra:
                                        print "%3d" % k,repr(after_lines1[j])
                                        if not g.is_sentinel(after_lines1[j],delims):
                                            k += 1
                                        j += 1
                                    break
            except IOError:
                g.es("Can not reopen %s!" % fileName,color="red")
                leoTest.fail()
    class baseScannerClass:

        '''The base class for all import scanner classes.
        This class contains common utility methods.'''

        def __init__ (self,importCommands,atAuto,language):

            ic = importCommands

            self.atAuto = atAuto
            self.c = ic.c
            self.codeEnd = None
                # The character after the last character of the class, method or function.
                # An error will be given if this is not a newline.
            self.encoding = ic.encoding # g.app.tkEncoding
            self.errors = 0
            self.errorLines = []
            self.extraIdChars = ''
            self.fileName = ic.fileName # The original filename.
            self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
            self.importCommands = ic
            self.language = language
            self.methodName = ic.methodName # x, as in &lt; &lt; x methods &gt; &gt; =
            self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
            self.root = None # The top-level node of the generated tree.
            self.rootLine = ic.rootLine # '' or @root + self.fileName
            self.sigEnd = None # The index of the end of the signature.
            self.sigID = None # The identifier contained in the signature, i.e., the function or method name.
            self.sigStart = None
                # The start of the line containing the signature.
                # An error will be given if something other than whitespace precedes the signature.
            self.startSigIndent = None
            self.tab_width = ic.getTabWidth() # The tab width in effect in the c.currentPosition.
            self.trace = False or ic.trace # = c.config.getBool('trace_import')
            self.treeType = ic.treeType # '@root' or '@file'
            self.webType = ic.webType # 'cweb' or 'noweb'  

            # Compute language ivars.
            delim1,delim2,delim3 = g.set_delims_from_language(language)
            self.comment_delim = delim1

            # Create the ws equivalent to one tab.
            if self.tab_width &lt; 0:
                self.tab_ws = ' '*abs(self.tab_width)
            else:
                self.tab_ws = '\t'

            # May be overridden in subclasses.
            self.lineCommentDelim = None
            self.lineCommentDelim2 = None
            self.blockCommentDelim1 = None
            self.blockCommentDelim2 = None
            self.blockDelim1 = '{'
            self.blockDelim2 = '}'
            self.classTags = ['class',]
                # tags that start a tag.
            self.functionTags = []
            self.sigTailFailTokens = []
                # A list of strings that abort a signature when seen in a tail.
                # For example, ';' and '=' in C.
            self.strict = False # True if leading whitespace is very significant.
        def check (self,s,parent):

            '''Make sure the generated nodes are equivalent to the original file.

            1. Regularize and check leading whitespace.
            2. Check that a trial write produces the original file.

            Return True if the nodes are equivalent to the original file.
            '''

            result = self.checkWhitespace(s,parent) and self.checkTrialWrite()
            g.app.unitTestDict ['result'] = result
            return result
        # Similar to c.tabNannyNode

        def checkTabWithTabNanny (self,p):

            '''Check indentation using tabnanny.'''

            h = p.headString() ; body = p.bodyString()

            try:
                readline = g.readLinesClass(body).next
                tabnanny.process_tokens(tokenize.generate_tokens(readline))
                return True

            except IndentationError, err:
                # Instances of this class have attributes filename, lineno, offset and text.
                g.es_print('IndentationError in %s at line %d' % (h,err.lineno),color='blue')
                # g.es_print(str(err)) # str(err.text))

            except parser.ParserError, msg:
                g.es_print('ParserError in %s' % h,color='blue')
                g.es_print(str(msg))

            except tokenize.TokenError, msg:
                g.es_print('TokenError in %s' % h,color='blue')
                g.es_print(str(msg))

            except tabnanny.NannyNag, nag:
                badline = nag.get_lineno()
                line    = nag.get_line()
                message = nag.get_msg()
                g.es_print('Indentation error in %s, line %d' % (h, badline),color='blue')
                g.es_print(message)
                g.es_print('offending line:\n%s' % repr(str(line))[1:-1])

            except:
                g.trace('unexpected exception')
                g.es_exception()

            return False
        def checkWhitespace(self,s,parent):

            '''Check and normalize the leading whitespace of all nodes.

            - The original sources may fail Python's tabNanny checks.  

            - Leading whitespace in the original sources may be inconsistent with the
              @tabwidth setting in effect in the @auto tree.

            - The original sources may contain underindented comments. 

            If an indentation problem is found, issue a warning and return False.
            Otherwise, normalize the indentation of all pieces so that it is indeed
            consistent with the indentation specified by the present @tabwidth setting.
            Normalizing underindented comments means shifting the comments right.
            '''

            if 1: # Do a quick check for mixed leading tabs/blanks.
                blanks = tabs = 0
                for line in g.splitLines(s):
                    lws = line[0:g.skip_ws(line,0)]
                    blanks += lws.count(' ')
                    tabs += lws.count('\t')
                # g.trace('blanks',blanks,'tabs',tabs)
                ok = blanks == 0 or tabs == 0
                if not ok:
                    self.error('File contains intermixed blanks and tabs')
                return ok
            else:
                # Check that whitespace passes TabNanny.
                # Check that whitespace is compatible with @tabwidth.
                # Check for underindented lines.
                ok = True
                for p in parent.self_and_subtree_iter():
                    ok = ok and self.checkTabWithTabNanny(p)
                return ok
        def checkTrialWrite (self):

            '''Return True if a trial write produces the original file.'''

            c = self.c ; at = c.atFileCommands
            at.write(self.root,
                nosentinels=True,thinFile=False,
                scriptWrite=False,toString=True,
                write_strips_blank_lines=False,
            )

            ignoreBlankLines = True
            s1,s2 = self.file_s, at.stringOutput
            if s1 == s2: return True

            lines1 = g.splitLines(s1) ; n1 = len(lines1)
            lines2 = g.splitLines(s2) ; n2 = len(lines2)

            ok = True
            for i in xrange(max(n1,n2)):
                ok = self.compareHelper(lines1,lines2,i,self.strict)
                if not ok: break

            d = g.app.unitTestDict
            expectedMismatch =  d.get('expectedMismatchLine')
            actualMismatch = d.get('actualMismatchLine')
            ok = ok or (g.app.unitTesting and expectedMismatch == actualMismatch)
            if not ok:
                if g.app.unitTesting:
                    g.trace('expected mismatch line',expectedMismatch,'actualMismatch',actualMismatch)
                if len(lines1) &lt; 30:
                    print 'input...'
                    for i in xrange(len(lines1)):
                        print '%3d' % (i),lines1[i],
                    print 'output...'
                    for i in xrange(len(lines2)):
                        print '%3d' % (i),lines2[i],
            return ok
        def compareHelper (self,lines1,lines2,i,strict):

            '''Compare lines1[i] and lines2[i].
            strict is True if leading whitespace is very significant.'''

            d = g.app.unitTestDict
            expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

            if i &gt;= len(lines1):
                if i != expectedMismatch:
                    print 'extra lines'
                    for line in lines2[i:]:
                        print repr(line)
                d ['actualMismatchLine'] = i
                return False

            if i &gt;= len(lines2):
                if i != expectedMismatch:
                    print 'missing lines'
                    for line in lines2[i:]:
                        print repr(line)
                d ['actualMismatchLine'] = i
                return False

            line1,line2 = lines1[i],lines2[i]
            if line1 == line2:
                return True # An exact match.
            elif not line1.strip() and not line2.strip():
                return True # All blank lines compare equal.
            elif not strict and line1.lstrip() == line2.lstrip():
                return True # A match excluding leading whitespace.
            else:
                if i+1 != expectedMismatch:
                    print '*** first mismatch at line %d' % (i+1)
                    print 'original line: ', repr(line1)
                    print 'generated line:', repr(line2)
                d ['actualMismatchLine'] = i+1
                return False
        # None of these methods should ever need to be overridden in 
        # subclasses.
        # 
        def addRef (self,parent):

            '''Create an unindented @others or section reference in the parent node.'''

            c = self.c

            if self.treeType == '@file':
                c.appendStringToBody(parent,'@others\n')

            if self.treeType == '@root' and self.methodsSeen:
                c.appendStringToBody(parent,
                    g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
        def createDeclsNode (self,parent,s):

            '''Create a child node of parent containing s.'''

            # Create the node for the decls.
            headline = self.methodName + ' declarations'
            body = self.undentBody(s)
            self.createHeadline(parent,body,headline)
        def createFunctionNode (self,headline,body,parent):

            # Create the prefix line for @root trees.
            if self.treeType == '@file':
                prefix = ''
            else:
                prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
                self.methodsSeen = True

            # Create the node.
            self.createHeadline(parent,prefix + body,headline)

        def createHeadline (self,parent,body,headline):

            # g.trace('parent,headline:',parent,headline)

            # Create the node.
            p = parent.insertAsLastChild()
            p.initHeadString(headline,self.encoding)

            # Set the body.
            if body:
                self.c.setBodyString(p,body,self.encoding)
            return p
        def getLeadingIndent (self,s,i,ignoreComments=True):

            '''Return the leading whitespace of a line.
            Ignore blank and comment lines if ignoreComments is True'''

            width = 0
            i = g.find_line_start(s,i)
            if ignoreComments:
                while i &lt; len(s):
                    # g.trace(g.get_line(s,i))
                    j = g.skip_ws(s,i)
                    if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                        i = g.skip_line(s,i) # ignore blank lines and comment lines.
                    else:
                        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                        break      
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

            # g.trace('returns:',width)
            return width
        def indentBody (self,s,lws=None):

            '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

            result = []
            if not lws: lws = self.tab_ws

            for line in g.splitLines(s):
                if line.strip():
                    result.append(lws + line)
                elif line.endswith('\n'):
                    result.append('\n')

            result = ''.join(result)
            return result
        def insertIgnoreDirective (self,parent):

            self.c.appendStringToBody(parent,'@ignore')
        def massageComment (self,s):

            '''Return s with leading and trailing whitespace removed and all other
            runs of whitespace and newlines converted to a single blank.'''

            s = s.strip()
            s = s.replace('\n',' ')
            s = s.replace('\r',' ')
            s = s.replace('\t',' ')
            s = s.replace('  ',' ')
            s = s.strip()
            return s
        def putClass (self,s,sigStart,sigEnd,codeEnd,start,parent):

            '''Creates a child node c of parent for the class, and children of c for each def in the class.'''

            prefix = self.createClassNodePrefix()
            if not self.sigID:
                g.trace('Can not happen: no sigID')
                sigID = 'Unknown class name'
            class_name = self.sigID
            headline = 'class ' + class_name
            body = s[start:sigEnd]
            body = self.undentBody(body)
            i = self.extendSignature(s,sigEnd)
            extend = s[sigEnd:i]
            if extend:
                extend = self.undentBody(extend)
                extend = self.indentBody(extend)
                body = body + extend

            class_node = self.createHeadline(parent,prefix + body,headline)
            savedMethodName = self.methodName
            self.methodName = headline
            self.putClassHelper(s,i,codeEnd,class_name,class_node)
            self.methodName = savedMethodName
        def appendRefToClassNode (self,class_name,class_node):

            '''Insert the proper body text in the class_vnode.'''

            if self.treeType == '@file':
                s = '@others'
            else:
                s = g.angleBrackets(' class %s methods ' % (class_name))

            self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
        def appendTextToClassNode (self,class_node,s):

            c = self.c

            c.appendStringToBody(class_node,s) 
        def createClassNodePrefix (self):

            '''Create the class node prefix.'''

            if  self.treeType == '@file':
                prefix = ''
            else:
                prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
                self.methodsSeen = True

            return prefix
        def putClassHelper(self,s,i,end,class_name,class_node):

            '''s contains the body of a class, not including the signature.

            Parse s for inner methods and classes, and create nodes.'''

            # Put any leading decls in the class node.
            trace = False
            start = i
            i = self.skipDecls(s,i,end)
            decls = s[start:i]
            if decls:
                # We must regularize the indentation to match the @others
                decls = self.undentBody(decls)
                decls = self.indentBody(decls)
                if self.trace: g.trace('decls\n%s' % decls)
                # g.trace(class_name,'decls',repr(decls))
                self.appendTextToClassNode(class_node,decls)
            start = i ; putRef = False
            while i &lt; end:
                progress = i
                if self.startsComment(s,i):
                    i = self.skipComment(s,i)
                elif self.startsString(s,i):
                    i = self.skipString(s,i)
                elif self.startsClass(s,i):  # Sets sigStart,sigEnd &amp; codeEnd ivars.
                    putRef = True
                    end2 = self.codeEnd # putClass may change codeEnd ivar.
                    self.putClass(s,self.sigStart,self.sigEnd,self.codeEnd,start,class_node)
                    i = start = end2
                elif self.startsFunction(s,i): # Sets sigStart,sigEnd &amp; codeEnd ivars.
                    putRef = True
                    self.putFunction(s,self.sigStart,self.codeEnd,start,class_node)
                    i = start = self.codeEnd
                elif self.startsId(s,i):
                    i = self.skipId(s,i);
                else: i += 1
                assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

            if putRef:
                self.appendRefToClassNode(class_name,class_node)

            if start &lt; end:
                trailing = s[start:end]
                if trace or self.trace: g.trace('trailing\n%s' % trailing)
                self.appendTextToClassNode(class_node,trailing)
        def putFunction (self,s,sigStart,codeEnd,start,parent):

            '''Create a node of parent for a function defintion.'''

            if self.sigID:
                headline = self.sigID
            else:
                g.trace('Can not happen: no sigID')
                headline = 'unknown function'

            body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

            body2 = self.undentBody(s[sigStart:codeEnd])
            body = body1 + body2
            if self.trace:
                g.trace('body\n%s' % repr(body))
                g.trace('body\n%s' % body)

            if not body.endswith('\n'):
                self.error('function does not end with a newline.  A newline will be added.')
                g.es(g.get_line(s,codeEnd),color='blue')

            self.createFunctionNode(headline,body,parent)
        def putRootText (self,p):

            c = self.c

            line1 = g.choose(self.atAuto,'','@ignore\n')

            c.appendStringToBody(p,'%s%s@language %s\n' % (
                line1,self.rootLine,self.language))
        def undentBody (self,s,ignoreComments=True):

            '''Remove the first line's leading indentation from all lines of s.'''

            #g.trace('before',repr(s))

            # Copy an @code line as is.
            i = 0
            if g.match(s,i,'@code'):
                j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
                result += s[j:i]

            # Calculate the amount to be removed from each line.
            undent = self.getLeadingIndent(s,i,ignoreComments=ignoreComments)
            if undent == 0:
                return s
            else:
                result = ''.join([
                    g.removeLeadingWhitespace(line,undent,self.tab_width)
                        for line in g.splitLines(s)])
                #g.trace('after',repr(result))
                return result
        def underindentedComment (self,line):

            self.error('underindented python comments.\nExtra leading whitespace will be added')
            g.es(line,color='blue')

        def underindentedLine (self,line):

            self.error('underindented line.\nExtra leading whitespace will be added')
            g.es(line,color='blue')

        def error (self,s):
            g.es_print(s,color='red')
            self.errors += 1
            g.app.unitTestDict['actualErrors'] = self.errors

        def oops (self):
            print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()
        # Scan and skipDecls would typically not be overridden.
        def extendSignature(self,s,i):

            '''Extend the signature line if appropriate.
            The text *must* end with a newline.

            For example, the Python scanner appends docstrings if they exist.'''

            return i
        def scan (self,s,parent):

            '''A language independent scanner: it uses language-specific helpers.

            Create a child of self.root for:
            - Leading outer-level declarations.
            - Outer-level classes.
            - Outer-level functions.
            '''
            i = start = self.skipDecls(s,0,len(s))
            decls = s[:i]
            if decls: self.createDeclsNode(parent,decls)
            needRef = False
            while i &lt; len(s):
                progress = i
                if self.startsComment(s,i):
                    i = self.skipComment(s,i)
                elif self.startsString(s,i):
                    i = self.skipString(s,i)
                elif self.startsClass(s,i): # Sets sigStart,sigEnd &amp; codeEnd ivars.
                    end2 = self.codeEnd # putClass may change codeEnd ivar.
                    self.putClass(s,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
                    i = start = end2
                    needRef = True
                elif self.startsFunction(s,i): # Sets sigStart,sigEnd &amp; codeEnd ivars.
                    self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
                    i = start = self.codeEnd
                elif self.startsId(s,i):
                    i = self.skipId(s,i);
                else: i += 1
                assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))
            self.addRef(parent)
        def skipArgs (self,s,i,kind):

            '''Skip the argument or class list.  Return i, ok

            kind is in ('class','function')'''

            start = i
            i = g.skip_ws_and_nl(s,i)
            if not g.match(s,i,'('):
                return start,kind == 'class'

            i = self.skipParens(s,i)
            # skipParens skips the ')'
            if i &gt;= len(s):
                return start,False
            else:
                return i,True 
        def skipBlock(self,s,i,delim1=None,delim2=None):

            '''Skip from the opening delim to *past* the matching closing delim.

            If no matching is found i is set to len(s)'''

            trace = False
            if delim1 is None: delim1 = self.blockDelim1
            if delim2 is None: delim2 = self.blockDelim2
            match1 = g.choose(len(delim1)==1,g.match,g.match_word)
            match2 = g.choose(len(delim2)==1,g.match,g.match_word)
            assert match1(s,i,delim1)
            level = 0 ; start = i
            startIndent = self.startSigIndent
            if trace: g.trace('***','startIndent',startIndent,g.callers())
            while i &lt; len(s):
                progress = i
                if g.is_nl(s,i):
                    backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
                    i = g.skip_nl(s,i)
                    if not backslashNewline:
                        j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                        line = g.get_line(s,j)
                        if trace: g.trace('indent',indent,line)
                        if indent &lt; startIndent and line.strip():
                            # An non-empty underindented line.
                            # Issue an error unless it contains just the closing bracket.
                            if level == 0 and match2(s,j,delim2):
                                pass
                            else:
                                if j not in self.errorLines: # No error yet given.
                                    self.errorLines.append(j)
                                    self.underindentedLine(line)
                elif self.startsComment(s,i):
                    i = self.skipComment(s,i)
                elif self.startsString(s,i):
                    i = self.skipString(s,i)
                elif match1(s,i,delim1):
                    level += 1 ; i += len(delim1)
                elif match2(s,i,delim2):
                    level -= 1 ; i += len(delim2)
                    if level &lt;= 0: break
                else: i += 1
                assert progress &lt; i

            if trace: g.trace('returns\n',s[start:i])
            return i
        def skipCodeBlock (self,s,i,kind):

            '''Skip the code block in a function or class definition.'''

            i = self.skipBlock(s,i,delim1=None,delim2=None)
            i = self.skipNewline(s,i,kind)

            return i
        def skipComment (self,s,i):

            '''Skip a comment and return the index of the following character.'''

            if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
                return g.skip_to_end_of_line(s,i)
            else:
                return self.skipBlockComment(s,i)
        def skipBlockComment (self,s,i):

            '''Skip past a block comment.'''

            # Skip the opening delim.
            assert(g.match(s,i,self.blockCommentDelim1))
            start = i ; i += len(self.blockCommentDelim1)

            # Find the closing delim.
            k = string.find(s,self.blockCommentDelim2,i)
            if k == -1:
                self.error('Run on block comment: ' + s[start:i])
                return len(s)
            else:
                return k + len(self.blockCommentDelim2)
        def skipDecls (self,s,i,end):

            '''Skip everything until the start of the next class or function.'''

            start = i
            while i &lt; end:
                progress = i
                if self.startsComment(s,i):
                    i = self.skipComment(s,i)
                elif self.startsString(s,i):
                    i = self.skipString(s,i)
                elif self.startsClass(s,i,quick=True):
                    # Important: do not include leading ws in the decls.
                    i = self.adjustClassOrFunctionStart(s,i,'class')
                    break
                elif self.startsFunction(s,i,quick=True):
                    # Important: do not include leading ws in the decls.
                    i = self.adjustClassOrFunctionStart(s,i,'function')
                    break
                elif self.startsId(s,i):
                    i = self.skipId(s,i);
                else: i += 1
                assert(progress &lt; i)

            # Ignore empty decls.
            if s[start:i].strip():
                if self.trace: g.trace('\n'+s[start:i])
                return i
            else:
                return start
        def adjustClassOrFunctionStart(self,s,i,tag):

            '''
            s[i:] starts a class or function.
            Adjust i so it points at the start of the line.

            Issue a warning if anything except whitespace appears.
            '''

            j = g.find_line_start(s,i)
            if s[j:i].strip():
                message = '%s definition does not start a line. Leo must insert a newline.' % tag
                self.error(message)
                return i
            else:
                return j
        def skipId (self,s,i):

            return g.skip_id(s,i,chars=self.extraIdChars)
        def skipNewline(self,s,i,kind):

            '''Skip whitespace and comments up to a newline, then skip the newline.
            Issue an error if no newline is found.'''

            while 1:
                i = g.skip_ws(s,i)
                if self.startsComment(s,i):
                    i = self.skipComment(s,i)
                else: break

            if g.match(s,i,'\n'):
                i += 1
            else:
                self.error('%s does not end in a newline.  A newline will be added.' % kind)
                g.es(g.get_line(s,i),color='blue')

            return i
        def skipParens (self,s,i):

            '''Skip a parenthisized list, that might contain strings or comments.'''

            return self.skipBlock(s,i,delim1='(',delim2=')')
        def skipString (self,s,i):

            # Returns len(s) on unterminated string.
            return g.skip_string(s,i,verbose=False)
        # We don't expect to override this code, but subclasses may override the helpers.

        def startsClass (self,s,i,quick=False):
            '''Return True if s[i:] starts a class definition.
            Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
            i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
            return i

        def startsFunction (self,s,i,quick=False):
            '''Return True if s[i:] starts a function.
            Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
            i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
            return i
        def startsHelper(self,s,i,kind,quick,tags):
            '''return True if s[i:] starts a class or function.
            Sets sigStart, sigEnd, sigID and codeEnd ivars.'''

            trace = False
            self.codeEnd = self.sigEnd = self.sigID = None
            self.sigStart = i

            # Underindented lines can happen in any language, not just Python.
            # The skipBlock method of the base class checks for such lines.
            self.startSigIndent = self.getLeadingIndent(s,i)

            # Get the tag that starts the class or function.
            i, ids = self.skipSigStart(s,i,tags)
            if tags:
                for id in ids:
                    if id in tags:
                        break
                else: return False

            if quick: return True

            if trace: g.trace('kind',kind)

            # Get the class/function id
            i, sigId = self.skipSigId(s,i,ids)
            if not sigId:
                if trace: g.trace('no sigId',g.get_line(s,i))
                return False

            # Skip the argument list.
            i, ok = self.skipArgs(s,i,kind)
            if not ok:
                if trace: g.trace('no args',g.get_line(s,i))
                return False
            i = g.skip_ws_and_nl(s,i)

            # Skip the tail of the signature
            i, ok = self.skipSigTail(s,i)
            if not ok:
                if trace: g.trace('no tail',g.get_line(s,i))
                return False
            sigEnd = i

            # A trick: make sure the signature ends in a newline,
            # even if it overlaps the start of the block.
            if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
                if trace: g.trace('extending sigEnd')
                sigEnd = g.skip_line(s,sigEnd)

            # Skip the block.
            i = g.skip_ws_and_nl(s,i)
            if self.blockDelim1 and not g.match(s,i,self.blockDelim1):
                if trace: g.trace('no block',g.get_line(s,i))
                return False

            i = self.skipCodeBlock(s,i,kind)
            # skipCodeBlock skips the trailing delim.

            # Success: set the ivars.
            self.codeEnd = i
            self.sigEnd = sigEnd
            self.sigID = sigId

            # Note: backing up here is safe because
            # we won't back up past scan's 'start' point.
            # Thus, characters will never be output twice.
            k = self.sigStart
            if not g.match(s,k,'\n'):
                self.sigStart = g.find_line_start(s,k)

            # Isue this warning only if we have a real class or function.
            if s[self.sigStart:k].strip():
                self.error('%s definition does not start a line' % kind)
                g.es(g.get_line(s,k),color='blue')

            if trace or self.trace: g.trace(kind,'\n'+s[self.sigStart:i])
            return True
        def skipSigStart (self,s,i,tags):

            '''Skip over the start of a function/class signature.

            tags is in (self.classTags,self.functionTags).

            Return (i,ids) where ids is list of all ids found, in order.'''

            __pychecker__ = '--no-argsused' # tags not used in the base class.

            ids = []
            while 1:
                j = g.skip_ws_and_nl(s,i)
                i = self.skipId(s,j)
                id = s[j:i]
                if id: ids.append(id)
                else: break

            # g.trace(ids)

            return i, ids
        def skipSigId (self,s,i,ids):

            '''Return (i, id) where id is the signature's id.

            By default, this is the last id in the ids list.'''

            return i, ids and ids[-1]
        def skipSigTail(self,s,i):

            '''Skip from the end of the arg list to the start of the block.'''

            while i &lt; len(s) and not g.match(s,i,self.blockDelim1):
                if self.startsComment(s,i):
                    i = self.skipComment(s,i)
                elif self.startsString(s,i):
                    i = self.skipString(s,i)
                elif self.sigTailFailTokens:
                    for z in self.failTokens:
                        if g.match(s,i,z):
                            return i,False
                    else:
                        i += 1
                else:
                    i += 1

            return i,True
        def startsComment (self,s,i):

            return (
                g.match(s,i,self.lineCommentDelim) or
                g.match(s,i,self.lineCommentDelim2) or
                g.match(s,i,self.blockCommentDelim1))
        def startsId(self,s,i):

            return g.is_c_id(s[i:i+1])
        def startsString(self,s,i):

            return g.match(s,i,'"') or g.match(s,i,"'")
        def run (self,s,parent):

            scanner = self
            scanner.root = parent
            scanner.file_s = s

            # Step 1: generate the nodes,
            # including all directive and section references.
            self.errors = 0
            self.errorLines = []
            scanner.scan(s,parent)

            # Step 2: check the generated nodes.
            # Return True if the result is equivalent to the original file.
            ok = self.errors == 0 and scanner.check(s,parent)

            # Step 3: insert an @ignore directive if there are any problems.
            if not ok:
                scanner.insertIgnoreDirective(parent)
    def scanCText (self,s,parent,atAuto=False):

        scanner = self.cScanner(importCommands=self,atAuto=atAuto)

        scanner.run(s,parent)
    class cScanner (baseScannerClass):

        def __init__ (self,importCommands,atAuto):

            # Init the base class.
            importCommands.baseScannerClass.__init__(self,importCommands,
                atAuto=atAuto,language='c')

            # Set the parser delims.
            self.blockCommentDelim1 = '/*'
            self.blockCommentDelim2 = '*/'
            self.lineCommentDelim = '//'
            self.lineCommentDelim2 = None
            self.blockDelim1 = '{'
            self.blockDelim2 = '}'
            self.classTags = ['class',]
            self.extraIdChars = ':'
            self.functionTags = []
            sigTailFailTokens = [';','=']
    def scanElispText (self,s,parent,atAuto=False):

        scanner = self.elispScanner(importCommands=self,atAuto=atAuto)

        scanner.run(s,parent)
    class elispScanner (baseScannerClass):

        def __init__ (self,importCommands,atAuto):

            # Init the base class.
            importCommands.baseScannerClass.__init__(self,importCommands,
                atAuto=atAuto,language='elisp')

            # Set the parser delims.
            self.blockCommentDelim1 = None
            self.blockCommentDelim2 = None
            self.lineCommentDelim = ';'
            self.lineCommentDelim2 = None
            self.blockDelim1 = '('
            self.blockDelim2 = ')'
            self.extraIdChars = '-'

        # skipClass/Function/Signature are defined in the base class.
        def startsClass (self,s,i):
            '''Return True if s[i:] starts a class definition.
            Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
            return False

        def startsFunction(self,s,i):
            '''Return True if s[i:] starts a function.
            Sets sigStart, sigEnd, sigID and codeEnd ivars.'''

            self.sigStart = i
            self.codeEnd = self.sigEnd = self.sigID = None
            if not g.match(s,i,'('): return False
            end = self.skipBlock(s,i)
            if not g.match(s,end,')'): return False

            i = g.skip_ws(s,i+1)
            if not g.match_word(s,i,'defun'): return False

            i += len(key)
            sigEnd = i = g.skip_ws_and_nl(s,i)
            j = g.skip_id(s,i)
            word = s[i:j]
            if not word: return False

            self.codeEnd = end + 1
            self.sigEnd = sigEnd
            self.sigId = word
            return True
        def startsString(self,s,i):

            # Single quotes are not strings.
            return g.match(s,i,'"')
    def scanJavaText (self,s,parent,atAuto=False):

        scanner = self.javaScanner(importCommands=self,atAuto=atAuto)

        scanner.run(s,parent)
    class javaScanner (baseScannerClass):

        def __init__ (self,importCommands,atAuto):

            # Init the base class.
            importCommands.baseScannerClass.__init__(self,importCommands,
                atAuto=atAuto,language='java')

            # Set the parser delims.
            self.blockCommentDelim1 = '/*'
            self.blockCommentDelim2 = '*/'
            self.lineCommentDelim = '//'
            self.lineCommentDelim2 = None
            self.classTags = ['class','interface',]
    def scanPascalText (self,s,parent,atAuto=False):

        scanner = self.pascalScanner(importCommands=self,atAuto=atAuto)

        scanner.run(s,parent)
    class pascalScanner (baseScannerClass):

        def __init__ (self,importCommands,atAuto):

            # Init the base class.
            importCommands.baseScannerClass.__init__(self,importCommands,
                atAuto=atAuto,language='pascal')

            # Set the parser delims.
            self.blockCommentDelim1 = '(*'
            self.blockCommentDelim2 = '*)'
            self.lineCommentDelim = '//'
            self.blockDelim1 = 'begin'
            self.blockDelim2 = 'end'
            self.classTags = []
            self.functionTags = ['function','procedure','constructor','destructor',]
    def scanPHPText (self,s,parent,atAuto=False):

        scanner = self.phpScanner(importCommands=self,atAuto=atAuto)

        if scanner.isPurePHP(s):
            scanner.run(s,parent)
        else:
            fileName = scanner.fileName
            if not atAuto:
                g.es_print('%s seems to be mixed HTML and PHP.' % fileName)
            scanner.createHeadline(
                parent,body=s,headline=fileName)
    class phpScanner (baseScannerClass):

        def __init__ (self,importCommands,atAuto):

            # Init the base class.
            importCommands.baseScannerClass.__init__(self,importCommands,
                atAuto=atAuto,language='php')

            # Set the parser delims.
            self.blockCommentDelim1 = '/*'
            self.blockCommentDelim2 = '*/'
            self.lineCommentDelim = '//'
            self.lineCommentDelim2 = '#'

            # The valid characters in an id
            self.chars = list(string.ascii_letters + string.digits)
            extra = [chr(z) for z in xrange(127,256)]
            self.chars.extend(extra)
        def isPurePHP (self,s):

            '''Return True if the file begins with &lt;?php or ends with ?&gt;'''

            s = s.strip()

            return (
                s.startswith('&lt;?') and
                s[2:3] in ('P','p','=','\n','\r',' ','\t') and
                s.endswith('?&gt;'))

        # Does not create @first/@last nodes
        def startsString(self,s,i):
            return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'&lt;&lt;&lt;')

        def skipString (self,s,i):
            if g.match(s,i,'"') or g.match(s,i,"'"):
                return self.skipString()
            else:
                return g.skip_heredoc_string(s,i)
    def scanPythonText (self,s,parent,atAuto=False):

        scanner = self.pythonScanner(importCommands=self,atAuto=atAuto)

        scanner.run(s,parent)
    class pythonScanner (baseScannerClass):

        def __init__ (self,importCommands,atAuto):

            # Init the base class.
            importCommands.baseScannerClass.__init__(self,importCommands,
                atAuto=atAuto,language='python')

            # Set the parser delims.
            self.lineCommentDelim = '#'
            self.classTags = ['class',]
            self.functionTags = ['def',]
            self.blockDelim1 = None
                # Suppress the check for the block delim.
                # The check is done in skipSigTail.
            self.blockDelim2 = None
            self.strict = True

        def extendSignature(self,s,i):

            '''Extend the text to be added to the class node following the signature.

            The text *must* end with a newline.'''

            # Add a docstring to the class node,
            # And everything on the line following it
            j = g.skip_ws_and_nl(s,i)
            if g.match(s,j,'"""') or g.match(s,j,"'''"):
                j = g.skip_python_string(s,j)
                if j &lt; len(s): # No scanning error.
                    # Return the docstring only if nothing but whitespace follows.
                    j = g.skip_ws(s,j)
                    if g.is_nl(s,j):
                        return j + 1

            return i
        def skipString (self,s,i):

            # Returns len(s) on unterminated string.
            return g.skip_python_string(s,i,verbose=False)
        def skipCodeBlock (self,s,i,kind):

            trace = False
            if trace: g.trace('***',g.callers())
            startIndent = self.startSigIndent
            assert startIndent is not None
            i = start = g.skip_ws_and_nl(s,i)
            parenCount = 0
            underIndentedStart = None # The start of trailing underindented blank or comment lines.
            while i &lt; len(s):
                progress = i
                ch = s[i]
                if g.is_nl(s,i):
                    backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
                    i = g.skip_nl(s,i)
                    if trace: g.trace(g.get_line(s,i))
                    if not backslashNewline:
                        i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                            s,i,parenCount,startIndent,underIndentedStart)
                        if breakFlag: break
                elif ch == '#':
                    i = g.skip_to_end_of_line(s,i)
                elif ch == '"' or ch == '\'':
                    i = g.skip_python_string(s,i)
                elif ch in '[{(':
                    i += 1 ; parenCount += 1
                    # g.trace('ch',ch,parenCount)
                elif ch in ']})':
                    i += 1 ; parenCount -= 1
                    # g.trace('ch',ch,parenCount)
                else: i += 1
                assert(progress &lt; i)

            # The actual end of the block.
            if underIndentedStart is not None:
                i = underIndentedStart
                if trace: g.trace('***backtracking to underindent range')
                if trace: g.trace(g.get_line(s,i))

            if 0 &lt; i &lt; len(s) and not g.match(s,i-1,'\n'):
                g.trace('Can not happen: Python block does not end in a newline.')
                g.trace(g.get_line(s,i))
            if (trace or self.trace) and s[start:i].strip():
                g.trace(g.callers())
                g.trace('\n'+s[start:i])
            return i
        def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

            trace = False
            breakFlag = False
            j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
            if indent &lt;= startIndent and parenCount == 0:
                # An underindented line: it ends the block *unless*
                # it is a blank or comment line.
                if g.match(s,j,'#'):
                    if trace: g.trace('underindent: comment')
                    if underIndentedStart is None: underIndentedStart = i
                    i = j
                elif g.match(s,j,'\n'):
                    if trace: g.trace('underindent: blank line')
                    # Blank lines never start the range of underindented lines.
                    i = j
                else:
                    if trace: g.trace('underindent: end of block')
                    breakFlag = True # The actual end of the block.
            else:
                if underIndentedStart and g.match(s,j,'\n'):
                    # Add the blank line to the underindented range.
                    if trace: g.trace('properly indented blank line extends underindent range')
                elif underIndentedStart and g.match(s,j,'#'):
                    # Add the (properly indented!) comment line to the underindented range.
                    if trace: g.trace('properly indented comment line extends underindent range')
                elif underIndentedStart is None:
                    pass
                else:
                    # A properly indented non-comment line.
                    # Give a message for all underindented comments in underindented range.
                    if trace: g.trace('properly indented line generates underindent errors')
                    s2 = s[underIndentedStart:i]
                    lines = g.splitlines(s2)
                    for line in lines:
                        if line.strip():
                            junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                            if indent &lt;= startIndent:
                                self.underindentedComment(line)
                    underIndentedStart = None
            return i,underIndentedStart,breakFlag
        def skipSigTail(self,s,i):

            '''Skip from the end of the arg list to the start of the block.'''

            # Must override so we can skip the ':' properly and issue better warnings.

            start = i
            while i &lt; len(s):
                if self.startsComment(s,i):
                    i = self.skipComment(s,i)
                elif self.startsString(s,i):
                    break
                elif g.match(s,i,':'):
                    i = g.skip_line(s,i+1)
                    if self.trace and s[start:i].strip(): g.trace('\n'+s[start:i])
                    return i,True
                else:
                    i += 1

            self.error('Warning: improper signature: %s' % g.get_line(s,start))
            return start,False
    def scanUnknownFileType (self,s,p,ext,atAuto=False):

        c = self.c
        body = g.choose(atAuto,'','@ignore\n')
        if ext in ('.html','.htm'): body += '@language html\n'
        if ext in ('.txt','.text'): body += '@nocolor\n'
        c.setBodyString(p,body + self.rootLine + s)
        g.app.unitTestDict = {'result':True}
    def cUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
        return self.scannerUnitTest(p,atAuto=atAuto,fileName=None,s=s,showTree=showTree,ext='.c')

    def elispUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
        return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.el')

    def htmlUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
        return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.htm')

    def javaUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
        return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.java')

    def pascalUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
        return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.pas')

    def phpUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
        return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.php')

    def pythonUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
        return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.py')

    def textUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
        return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,showTree=showTree,ext='.txt')

    def defaultImporterUnitTest(self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):
        return self.scannerUnitTest (p,atAuto=atAuto,fileName=fileName,s=s,ext='.xxx')
    def scannerUnitTest (self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):

        '''Run a unit test of an import scanner,
        i.e., create a tree from string s at location p.'''

        c = self.c
        oldChanged = c.changed
        c.beginUpdate()
        try:
            expectedErrors = g.app.unitTestDict.get('expectedErrors')
            expectedMismatchLine = g.app.unitTestDict.get('expectedMismatchLine')
            g.app.unitTestDict = {
                'expectedErrors':expectedErrors,
                'expectedMismatchLine':expectedMismatchLine,
            }
            if not fileName: fileName = p.headString()
            if not s: s = self.removeSentinelsCommand([fileName],toString=True)
            self.createOutline(fileName,p.copy(),atAuto=False,s=s,ext=ext)
            d = g.app.unitTestDict
            ok = d.get('result') or (
                d.get('actualErrors') == d.get('expectedErrors') and
                d.get('actualMismatchLine') == d.get('expectedMismatchLine'))
            if not ok:
                g.trace('result',d.get('result'),
                    'actualErrors',d.get('actualErrors'),
                    'expectedErrors',d.get('expectedErrors'),
                    'actualMismatchLine',d.get('actualMismatchLine'),
                    'expectedMismatchLine', d.get('expectedMismatchLine'),)
            if not showTree and ok:
                while p.hasChildren():
                    p.firstChild().doDelete()
                c.setChanged(oldChanged)
        finally:
            c.endUpdate()

        if g.app.unitTesting:
            d = g.app.unitTestDict
            assert d.get('result') or (
                d.get('actualErrors') == d.get('expectedErrors') and
                d.get('actualMismatchLine') == d.get('expectedMismatchLine'))

class leoImportCommands (baseLeoImportCommands):
    """A class that implements Leo's import commands."""
    pass
</t>
<t tx="ekr.20071105090148.275">@language c
@tabwidth -4
@others

// changed 1
</t>
<t tx="ekr.20071105090148.276">/* changed 2
 * tclScan.c --
 *
 *	This file contains the implementation of the "scan" command.
 *
 * Copyright (c) 1998 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: oldLeoProjects.leo,v 1.21 2007/12/11 17:42:26 edream Exp $
 */

#include "tclInt.h"
/*
 * For strtoll() and strtoull() declarations on some platforms...
 */
#include "tclPort.h"

/*
 * Flag values used by Tcl_ScanObjCmd.
 */

#define SCAN_NOSKIP	0x1		  /* Don't skip blanks. */
#define SCAN_SUPPRESS	0x2		  /* Suppress assignment. */
#define SCAN_UNSIGNED	0x4		  /* Read an unsigned value. */
#define SCAN_WIDTH	0x8		  /* A width value was supplied. */

#define SCAN_SIGNOK	0x10		  /* A +/- character is allowed. */
#define SCAN_NODIGITS	0x20		  /* No digits have been scanned. */
#define SCAN_NOZERO	0x40		  /* No zero digits have been scanned. */
#define SCAN_XOK	0x80		  /* An 'x' is allowed. */
#define SCAN_PTOK	0x100		  /* Decimal point is allowed. */
#define SCAN_EXPOK	0x200		  /* An exponent is allowed. */

#define SCAN_LONGER	0x400		  /* Asked for a wide value. */

/*
 * The following structure contains the information associated with
 * a character set.
 */

typedef struct CharSet {
    int exclude;		/* 1 if this is an exclusion set. */
    int nchars;
    Tcl_UniChar *chars;
    int nranges;
    struct Range {
    Tcl_UniChar start;
    Tcl_UniChar end;
    } *ranges;
} CharSet;

/*
 * Declarations for functions used only in this file.
 */

static char *	BuildCharSet _ANSI_ARGS_((CharSet *cset, char *format));
static int	CharInSet _ANSI_ARGS_((CharSet *cset, int ch));
static void	ReleaseCharSet _ANSI_ARGS_((CharSet *cset));
static int	ValidateFormat _ANSI_ARGS_((Tcl_Interp *interp, char *format,
            int numVars, int *totalVars));

</t>
<t tx="ekr.20071105090148.277">/*
 *----------------------------------------------------------------------
 *
 * BuildCharSet --
 *
 *	This function examines a character set format specification
 *	and builds a CharSet containing the individual characters and
 *	character ranges specified.
 *
 * Results:
 *	Returns the next format position.
 *
 * Side effects:
 *	Initializes the charset.
 *
 *----------------------------------------------------------------------
 */

static char *
BuildCharSet(cset, format)
    CharSet *cset;
    char *format;		/* Points to first char of set. */
{
    Tcl_UniChar ch, start;
    int offset, nranges;
    char *end;

    memset(cset, 0, sizeof(CharSet));
    
    offset = Tcl_UtfToUniChar(format, &amp;ch);
    if (ch == '^') {
    cset-&gt;exclude = 1;
    format += offset;
    offset = Tcl_UtfToUniChar(format, &amp;ch);
    }
    end = format + offset;

    /*
     * Find the close bracket so we can overallocate the set.
     */

    if (ch == ']') {
    end += Tcl_UtfToUniChar(end, &amp;ch);
    }
    nranges = 0;
    while (ch != ']') {
    if (ch == '-') {
        nranges++;
    }
    end += Tcl_UtfToUniChar(end, &amp;ch);
    }

    cset-&gt;chars = (Tcl_UniChar *) ckalloc(sizeof(Tcl_UniChar)
        * (end - format - 1));
    if (nranges &gt; 0) {
    cset-&gt;ranges = (struct Range *) ckalloc(sizeof(struct Range)*nranges);
    } else {
    cset-&gt;ranges = NULL;
    }

    /*
     * Now build the character set.
     */

    cset-&gt;nchars = cset-&gt;nranges = 0;
    format += Tcl_UtfToUniChar(format, &amp;ch);
    start = ch;
    if (ch == ']' || ch == '-') {
    cset-&gt;chars[cset-&gt;nchars++] = ch;
    format += Tcl_UtfToUniChar(format, &amp;ch);
    }
    while (ch != ']') {
    if (*format == '-') {
        /*
         * This may be the first character of a range, so don't add
         * it yet.
         */

        start = ch;
    } else if (ch == '-') {
        /*
         * Check to see if this is the last character in the set, in which
         * case it is not a range and we should add the previous character
         * as well as the dash.
         */

        if (*format == ']') {
        cset-&gt;chars[cset-&gt;nchars++] = start;
        cset-&gt;chars[cset-&gt;nchars++] = ch;
        } else {
        format += Tcl_UtfToUniChar(format, &amp;ch);

        /*
         * Check to see if the range is in reverse order.
         */

        if (start &lt; ch) {
            cset-&gt;ranges[cset-&gt;nranges].start = start;
            cset-&gt;ranges[cset-&gt;nranges].end = ch;
        } else {
            cset-&gt;ranges[cset-&gt;nranges].start = ch;
            cset-&gt;ranges[cset-&gt;nranges].end = start;
        }		    
        cset-&gt;nranges++;
        }
    } else {
        cset-&gt;chars[cset-&gt;nchars++] = ch;
    }
    format += Tcl_UtfToUniChar(format, &amp;ch);
    }
    return format;
}
</t>
<t tx="ekr.20071105090148.278">
/*
 *----------------------------------------------------------------------
 *
 * CharInSet --
 *
 *	Check to see if a character matches the given set.
 *
 * Results:
 *	Returns non-zero if the character matches the given set.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
CharInSet(cset, c)
    CharSet *cset;
    int c;			/* Character to test, passed as int because
                 * of non-ANSI prototypes. */
{
    Tcl_UniChar ch = (Tcl_UniChar) c;
    int i, match = 0;
    for (i = 0; i &lt; cset-&gt;nchars; i++) {
    if (cset-&gt;chars[i] == ch) {
        match = 1;
        break;
    }
    }
    if (!match) {
    for (i = 0; i &lt; cset-&gt;nranges; i++) {
        if ((cset-&gt;ranges[i].start &lt;= ch)
            &amp;&amp; (ch &lt;= cset-&gt;ranges[i].end)) {
        match = 1;
        break;
        }
    }
    }
    return (cset-&gt;exclude ? !match : match);    
}
</t>
<t tx="ekr.20071105090148.279">
/*
 *----------------------------------------------------------------------
 *
 * ReleaseCharSet --
 *
 *	Free the storage associated with a character set.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
ReleaseCharSet(cset)
    CharSet *cset;
{
    ckfree((char *)cset-&gt;chars);
    if (cset-&gt;ranges) {
    ckfree((char *)cset-&gt;ranges);
    }
}
</t>
<t tx="ekr.20071105090148.280">
/*
 *----------------------------------------------------------------------
 *
 * ValidateFormat --
 *
 *	Parse the format string and verify that it is properly formed
 *	and that there are exactly enough variables on the command line.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	May place an error in the interpreter result.
 *
 *----------------------------------------------------------------------
 */

static int
ValidateFormat(interp, format, numVars, totalSubs)
    Tcl_Interp *interp;		/* Current interpreter. */
    char *format;		/* The format string. */
    int numVars;		/* The number of variables passed to the
                 * scan command. */
    int *totalSubs;		/* The number of variables that will be
                 * required. */
{
#define STATIC_LIST_SIZE 16
    int gotXpg, gotSequential, value, i, flags;
    char *end;
    Tcl_UniChar ch;
    int staticAssign[STATIC_LIST_SIZE];
    int *nassign = staticAssign;
    int objIndex, xpgSize, nspace = STATIC_LIST_SIZE;
    char buf[TCL_UTF_MAX+1];

    /*
     * Initialize an array that records the number of times a variable
     * is assigned to by the format string.  We use this to detect if
     * a variable is multiply assigned or left unassigned.
     */

    if (numVars &gt; nspace) {
    nassign = (int*)ckalloc(sizeof(int) * numVars);
    nspace = numVars;
    }
    for (i = 0; i &lt; nspace; i++) {
    nassign[i] = 0;
    }

    xpgSize = objIndex = gotXpg = gotSequential = 0;

    while (*format != '\0') {
    format += Tcl_UtfToUniChar(format, &amp;ch);

    flags = 0;

    if (ch != '%') {
        continue;
    }
    format += Tcl_UtfToUniChar(format, &amp;ch);
    if (ch == '%') {
        continue;
    }
    if (ch == '*') {
        flags |= SCAN_SUPPRESS;
        format += Tcl_UtfToUniChar(format, &amp;ch);
        goto xpgCheckDone;
    }

    if ((ch &lt; 0x80) &amp;&amp; isdigit(UCHAR(ch))) { /* INTL: "C" locale. */
        /*
         * Check for an XPG3-style %n$ specification.  Note: there
         * must not be a mixture of XPG3 specs and non-XPG3 specs
         * in the same format string.
         */

        value = strtoul(format-1, &amp;end, 10); /* INTL: "C" locale. */
        if (*end != '$') {
        goto notXpg;
        }
        format = end+1;
        format += Tcl_UtfToUniChar(format, &amp;ch);
        gotXpg = 1;
        if (gotSequential) {
        goto mixedXPG;
        }
        objIndex = value - 1;
        if ((objIndex &lt; 0) || (numVars &amp;&amp; (objIndex &gt;= numVars))) {
        goto badIndex;
        } else if (numVars == 0) {
        /*
         * In the case where no vars are specified, the user can
         * specify %9999$ legally, so we have to consider special
         * rules for growing the assign array.  'value' is
         * guaranteed to be &gt; 0.
         */
        xpgSize = (xpgSize &gt; value) ? xpgSize : value;
        }
        goto xpgCheckDone;
    }

    notXpg:
    gotSequential = 1;
    if (gotXpg) {
        mixedXPG:
        Tcl_SetResult(interp,
            "cannot mix \"%\" and \"%n$\" conversion specifiers",
            TCL_STATIC);
        goto error;
    }

    xpgCheckDone:
    /*
     * Parse any width specifier.
     */

    if ((ch &lt; 0x80) &amp;&amp; isdigit(UCHAR(ch))) { /* INTL: "C" locale. */
        value = strtoul(format-1, &amp;format, 10); /* INTL: "C" locale. */
        flags |= SCAN_WIDTH;
        format += Tcl_UtfToUniChar(format, &amp;ch);
    }

    /*
     * Handle any size specifier.
     */

    switch (ch) {
    case 'l':
    case 'L':
        flags |= SCAN_LONGER;
    case 'h':
        format += Tcl_UtfToUniChar(format, &amp;ch);
    }

    if (!(flags &amp; SCAN_SUPPRESS) &amp;&amp; numVars &amp;&amp; (objIndex &gt;= numVars)) {
        goto badIndex;
    }

    /*
     * Handle the various field types.
     */

    switch (ch) {
        case 'c':
                if (flags &amp; SCAN_WIDTH) {
            Tcl_SetResult(interp,
                "field width may not be specified in %c conversion",
                TCL_STATIC);
            goto error;
                }
        /*
         * Fall through!
         */
        case 'n':
        case 's':
        if (flags &amp; SCAN_LONGER) {
        invalidLonger:
            buf[Tcl_UniCharToUtf(ch, buf)] = '\0';
            Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
               "'l' modifier may not be specified in %", buf,
               " conversion", NULL);
            goto error;
        }
        /*
         * Fall through!
         */
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'i':
        case 'o':
        case 'u':
        case 'x':
        break;
        /*
         * Bracket terms need special checking
         */
        case '[':
        if (flags &amp; SCAN_LONGER) {
            goto invalidLonger;
        }
        if (*format == '\0') {
            goto badSet;
        }
        format += Tcl_UtfToUniChar(format, &amp;ch);
        if (ch == '^') {
            if (*format == '\0') {
            goto badSet;
            }
            format += Tcl_UtfToUniChar(format, &amp;ch);
        }
        if (ch == ']') {
            if (*format == '\0') {
            goto badSet;
            }
            format += Tcl_UtfToUniChar(format, &amp;ch);
        }
        while (ch != ']') {
            if (*format == '\0') {
            goto badSet;
            }
            format += Tcl_UtfToUniChar(format, &amp;ch);
        }
        break;
        badSet:
        Tcl_SetResult(interp, "unmatched [ in format string",
            TCL_STATIC);
        goto error;
        default:
        {
        char buf[TCL_UTF_MAX+1];

        buf[Tcl_UniCharToUtf(ch, buf)] = '\0';
        Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
            "bad scan conversion character \"", buf, "\"", NULL);
        goto error;
        }
    }
    if (!(flags &amp; SCAN_SUPPRESS)) {
        if (objIndex &gt;= nspace) {
        /*
         * Expand the nassign buffer.  If we are using XPG specifiers,
         * make sure that we grow to a large enough size.  xpgSize is
         * guaranteed to be at least one larger than objIndex.
         */
        value = nspace;
        if (xpgSize) {
            nspace = xpgSize;
        } else {
            nspace += STATIC_LIST_SIZE;
        }
        if (nassign == staticAssign) {
            nassign = (void *)ckalloc(nspace * sizeof(int));
            for (i = 0; i &lt; STATIC_LIST_SIZE; ++i) {
            nassign[i] = staticAssign[i];
            }
        } else {
            nassign = (void *)ckrealloc((void *)nassign,
                nspace * sizeof(int));
        }
        for (i = value; i &lt; nspace; i++) {
            nassign[i] = 0;
        }
        }
        nassign[objIndex]++;
        objIndex++;
    }
    }

    /*
     * Verify that all of the variable were assigned exactly once.
     */

    if (numVars == 0) {
    if (xpgSize) {
        numVars = xpgSize;
    } else {
        numVars = objIndex;
    }
    }
    if (totalSubs) {
    *totalSubs = numVars;
    }
    for (i = 0; i &lt; numVars; i++) {
    if (nassign[i] &gt; 1) {
        Tcl_SetResult(interp, "variable is assigned by multiple \"%n$\" conversion specifiers", TCL_STATIC);
        goto error;
    } else if (!xpgSize &amp;&amp; (nassign[i] == 0)) {
        /*
         * If the space is empty, and xpgSize is 0 (means XPG wasn't
         * used, and/or numVars != 0), then too many vars were given
         */
        Tcl_SetResult(interp, "variable is not assigned by any conversion specifiers", TCL_STATIC);
        goto error;
    }
    }

    if (nassign != staticAssign) {
    ckfree((char *)nassign);
    }
    return TCL_OK;

    badIndex:
    if (gotXpg) {
    Tcl_SetResult(interp, "\"%n$\" argument index out of range",
        TCL_STATIC);
    } else {
    Tcl_SetResult(interp, 
        "different numbers of variable names and field specifiers",
        TCL_STATIC);
    }

    error:
    if (nassign != staticAssign) {
    ckfree((char *)nassign);
    }
    return TCL_ERROR;
#undef STATIC_LIST_SIZE
}
</t>
<t tx="ekr.20071105090148.281">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_ScanObjCmd --
 *
 *	This procedure is invoked to process the "scan" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

    /* ARGSUSED */
int
Tcl_ScanObjCmd(dummy, interp, objc, objv)
    ClientData dummy;    	/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *format;
    int numVars, nconversions, totalVars = -1;
    int objIndex, offset, i, result, code;
    long value;
    char *string, *end, *baseString;
    char op = 0;
    int base = 0;
    int underflow = 0;
    size_t width;
    long (*fn)() = NULL;
#ifndef TCL_WIDE_INT_IS_LONG
    Tcl_WideInt (*lfn)() = NULL;
    Tcl_WideInt wideValue;
#endif
    Tcl_UniChar ch, sch;
    Tcl_Obj **objs = NULL, *objPtr = NULL;
    int flags;
    char buf[513];			  /* Temporary buffer to hold scanned
                       * number strings before they are
                       * passed to strtoul. */

    if (objc &lt; 3) {
        Tcl_WrongNumArgs(interp, 1, objv,
        "string format ?varName varName ...?");
    return TCL_ERROR;
    }

    format = Tcl_GetStringFromObj(objv[2], NULL);
    numVars = objc-3;

    /*
     * Check for errors in the format string.
     */
    
    if (ValidateFormat(interp, format, numVars, &amp;totalVars) == TCL_ERROR) {
    return TCL_ERROR;
    }

    /*
     * Allocate space for the result objects.
     */

    if (totalVars &gt; 0) {
    objs = (Tcl_Obj **) ckalloc(sizeof(Tcl_Obj*) * totalVars);
    for (i = 0; i &lt; totalVars; i++) {
        objs[i] = NULL;
    }
    }

    string = Tcl_GetStringFromObj(objv[1], NULL);
    baseString = string;

    /*
     * Iterate over the format string filling in the result objects until
     * we reach the end of input, the end of the format string, or there
     * is a mismatch.
     */

    objIndex = 0;
    nconversions = 0;
    while (*format != '\0') {
    format += Tcl_UtfToUniChar(format, &amp;ch);

    flags = 0;

    /*
     * If we see whitespace in the format, skip whitespace in the string.
     */

    if (Tcl_UniCharIsSpace(ch)) {
        offset = Tcl_UtfToUniChar(string, &amp;sch);
        while (Tcl_UniCharIsSpace(sch)) {
        if (*string == '\0') {
            goto done;
        }
        string += offset;
        offset = Tcl_UtfToUniChar(string, &amp;sch);
        }
        continue;
    }
        
    if (ch != '%') {
        literal:
        if (*string == '\0') {
        underflow = 1;
        goto done;
        }
        string += Tcl_UtfToUniChar(string, &amp;sch);
        if (ch != sch) {
        goto done;
        }
        continue;
    }

    format += Tcl_UtfToUniChar(format, &amp;ch);
    if (ch == '%') {
        goto literal;
    }

    /*
     * Check for assignment suppression ('*') or an XPG3-style
     * assignment ('%n$').
     */

    if (ch == '*') {
        flags |= SCAN_SUPPRESS;
        format += Tcl_UtfToUniChar(format, &amp;ch);
    } else if ((ch &lt; 0x80) &amp;&amp; isdigit(UCHAR(ch))) { /* INTL: "C" locale. */
        value = strtoul(format-1, &amp;end, 10); /* INTL: "C" locale. */
        if (*end == '$') {
        format = end+1;
        format += Tcl_UtfToUniChar(format, &amp;ch);
        objIndex = (int) value - 1;
        }
    }

    /*
     * Parse any width specifier.
     */

    if ((ch &lt; 0x80) &amp;&amp; isdigit(UCHAR(ch))) { /* INTL: "C" locale. */
        width = strtoul(format-1, &amp;format, 10); /* INTL: "C" locale. */
        format += Tcl_UtfToUniChar(format, &amp;ch);
    } else {
        width = 0;
    }

    /*
     * Handle any size specifier.
     */

    switch (ch) {
    case 'l':
    case 'L':
        flags |= SCAN_LONGER;
        /*
         * Fall through so we skip to the next character.
         */
    case 'h':
        format += Tcl_UtfToUniChar(format, &amp;ch);
    }

    /*
     * Handle the various field types.
     */

    switch (ch) {
        case 'n':
        if (!(flags &amp; SCAN_SUPPRESS)) {
            objPtr = Tcl_NewIntObj(string - baseString);
            Tcl_IncrRefCount(objPtr);
            objs[objIndex++] = objPtr;
        }
        nconversions++;
        continue;

        case 'd':
        op = 'i';
        base = 10;
        fn = (long (*)())strtol;
#ifndef TCL_WIDE_INT_IS_LONG
        lfn = (Tcl_WideInt (*)())strtoll;
#endif
        break;
        case 'i':
        op = 'i';
        base = 0;
        fn = (long (*)())strtol;
#ifndef TCL_WIDE_INT_IS_LONG
        lfn = (Tcl_WideInt (*)())strtoll;
#endif
        break;
        case 'o':
        op = 'i';
        base = 8;
        fn = (long (*)())strtoul;
#ifndef TCL_WIDE_INT_IS_LONG
        lfn = (Tcl_WideInt (*)())strtoull;
#endif
        break;
        case 'x':
        op = 'i';
        base = 16;
        fn = (long (*)())strtoul;
#ifndef TCL_WIDE_INT_IS_LONG
        lfn = (Tcl_WideInt (*)())strtoull;
#endif
        break;
        case 'u':
        op = 'i';
        base = 10;
        flags |= SCAN_UNSIGNED;
        fn = (long (*)())strtoul;
#ifndef TCL_WIDE_INT_IS_LONG
        lfn = (Tcl_WideInt (*)())strtoull;
#endif
        break;

        case 'f':
        case 'e':
        case 'g':
        op = 'f';
        break;

        case 's':
        op = 's';
        break;

        case 'c':
        op = 'c';
        flags |= SCAN_NOSKIP;
        break;
        case '[':
        op = '[';
        flags |= SCAN_NOSKIP;
        break;
    }

    /*
     * At this point, we will need additional characters from the
     * string to proceed.
     */

    if (*string == '\0') {
        underflow = 1;
        goto done;
    }
    
    /*
     * Skip any leading whitespace at the beginning of a field unless
     * the format suppresses this behavior.
     */

    if (!(flags &amp; SCAN_NOSKIP)) {
        while (*string != '\0') {
        offset = Tcl_UtfToUniChar(string, &amp;sch);
        if (!Tcl_UniCharIsSpace(sch)) {
            break;
        }
        string += offset;
        }
        if (*string == '\0') {
        underflow = 1;
        goto done;
        }
    }

    /*
     * Perform the requested scanning operation.
     */
    
    switch (op) {
        case 's':
        /*
         * Scan a string up to width characters or whitespace.
         */

        if (width == 0) {
            width = (size_t) ~0;
        }
        end = string;
        while (*end != '\0') {
            offset = Tcl_UtfToUniChar(end, &amp;sch);
            if (Tcl_UniCharIsSpace(sch)) {
            break;
            }
            end += offset;
            if (--width == 0) {
            break;
            }
        }
        if (!(flags &amp; SCAN_SUPPRESS)) {
            objPtr = Tcl_NewStringObj(string, end-string);
            Tcl_IncrRefCount(objPtr);
            objs[objIndex++] = objPtr;
        }
        string = end;
        break;

        case '[': {
        CharSet cset;

        if (width == 0) {
            width = (size_t) ~0;
        }
        end = string;

        format = BuildCharSet(&amp;cset, format);
        while (*end != '\0') {
            offset = Tcl_UtfToUniChar(end, &amp;sch);
            if (!CharInSet(&amp;cset, (int)sch)) {
            break;
            }
            end += offset;
            if (--width == 0) {
            break;
            }
        }
        ReleaseCharSet(&amp;cset);

        if (string == end) {
            /*
             * Nothing matched the range, stop processing
             */
            goto done;
        }
        if (!(flags &amp; SCAN_SUPPRESS)) {
            objPtr = Tcl_NewStringObj(string, end-string);
            Tcl_IncrRefCount(objPtr);
            objs[objIndex++] = objPtr;
        }
        string = end;
        
        break;
        }
        case 'c':
        /*
         * Scan a single Unicode character.
         */

        string += Tcl_UtfToUniChar(string, &amp;sch);
        if (!(flags &amp; SCAN_SUPPRESS)) {
            objPtr = Tcl_NewIntObj((int)sch);
            Tcl_IncrRefCount(objPtr);
            objs[objIndex++] = objPtr;
        }
        break;

        case 'i':
        /*
         * Scan an unsigned or signed integer.
         */

        if ((width == 0) || (width &gt; sizeof(buf) - 1)) {
            width = sizeof(buf) - 1;
        }
        flags |= SCAN_SIGNOK | SCAN_NODIGITS | SCAN_NOZERO;
        for (end = buf; width &gt; 0; width--) {
            switch (*string) {
            /*
             * The 0 digit has special meaning at the beginning of
             * a number.  If we are unsure of the base, it
             * indicates that we are in base 8 or base 16 (if it is
             * followed by an 'x').
             *
             * 8.1 - 8.3.4 incorrectly handled 0x... base-16
             * cases for %x by not reading the 0x as the
             * auto-prelude for base-16. [Bug #495213]
             */
            case '0':
                if (base == 0) {
                base = 8;
                flags |= SCAN_XOK;
                }
                if (base == 16) {
                flags |= SCAN_XOK;
                }
                if (flags &amp; SCAN_NOZERO) {
                flags &amp;= ~(SCAN_SIGNOK | SCAN_NODIGITS
                    | SCAN_NOZERO);
                } else {
                flags &amp;= ~(SCAN_SIGNOK | SCAN_XOK
                    | SCAN_NODIGITS);
                }
                goto addToInt;

            case '1': case '2': case '3': case '4':
            case '5': case '6': case '7':
                if (base == 0) {
                base = 10;
                }
                flags &amp;= ~(SCAN_SIGNOK | SCAN_XOK | SCAN_NODIGITS);
                goto addToInt;

            case '8': case '9':
                if (base == 0) {
                base = 10;
                }
                if (base &lt;= 8) {
                break;
                }
                flags &amp;= ~(SCAN_SIGNOK | SCAN_XOK | SCAN_NODIGITS);
                goto addToInt;

            case 'A': case 'B': case 'C':
            case 'D': case 'E': case 'F': 
            case 'a': case 'b': case 'c':
            case 'd': case 'e': case 'f':
                if (base &lt;= 10) {
                break;
                }
                flags &amp;= ~(SCAN_SIGNOK | SCAN_XOK | SCAN_NODIGITS);
                goto addToInt;

            case '+': case '-':
                if (flags &amp; SCAN_SIGNOK) {
                flags &amp;= ~SCAN_SIGNOK;
                goto addToInt;
                }
                break;

            case 'x': case 'X':
                if ((flags &amp; SCAN_XOK) &amp;&amp; (end == buf+1)) {
                base = 16;
                flags &amp;= ~SCAN_XOK;
                goto addToInt;
                }
                break;
            }

            /*
             * We got an illegal character so we are done accumulating.
             */

            break;

            addToInt:
            /*
             * Add the character to the temporary buffer.
             */

            *end++ = *string++;
            if (*string == '\0') {
            break;
            }
        }

        /*
         * Check to see if we need to back up because we only got a
         * sign or a trailing x after a 0.
         */

        if (flags &amp; SCAN_NODIGITS) {
            if (*string == '\0') {
            underflow = 1;
            }
            goto done;
        } else if (end[-1] == 'x' || end[-1] == 'X') {
            end--;
            string--;
        }


        /*
         * Scan the value from the temporary buffer.  If we are
         * returning a large unsigned value, we have to convert it back
         * to a string since Tcl only supports signed values.
         */

        if (!(flags &amp; SCAN_SUPPRESS)) {
            *end = '\0';
#ifndef TCL_WIDE_INT_IS_LONG
            if (flags &amp; SCAN_LONGER) {
            wideValue = (Tcl_WideInt) (*lfn)(buf, NULL, base);
            if ((flags &amp; SCAN_UNSIGNED) &amp;&amp; (wideValue &lt; 0)) {
                /* INTL: ISO digit */
                sprintf(buf, "%" TCL_LL_MODIFIER "u",
                    (Tcl_WideUInt)wideValue);
                objPtr = Tcl_NewStringObj(buf, -1);
            } else {
                objPtr = Tcl_NewWideIntObj(wideValue);
            }
            } else {
#endif /* !TCL_WIDE_INT_IS_LONG */
            value = (long) (*fn)(buf, NULL, base);
            if ((flags &amp; SCAN_UNSIGNED) &amp;&amp; (value &lt; 0)) {
                sprintf(buf, "%lu", value); /* INTL: ISO digit */
                objPtr = Tcl_NewStringObj(buf, -1);
            } else if ((flags &amp; SCAN_LONGER)
                || (unsigned long) value &gt; UINT_MAX) {
                objPtr = Tcl_NewLongObj(value);
            } else {
                objPtr = Tcl_NewIntObj(value);
            }
#ifndef TCL_WIDE_INT_IS_LONG
            }
#endif
            Tcl_IncrRefCount(objPtr);
            objs[objIndex++] = objPtr;
        }

        break;

        case 'f':
        /*
         * Scan a floating point number
         */

        if ((width == 0) || (width &gt; sizeof(buf) - 1)) {
            width = sizeof(buf) - 1;
        }
        flags &amp;= ~SCAN_LONGER;
        flags |= SCAN_SIGNOK | SCAN_NODIGITS | SCAN_PTOK | SCAN_EXPOK;
        for (end = buf; width &gt; 0; width--) {
            switch (*string) {
            case '0': case '1': case '2': case '3':
            case '4': case '5': case '6': case '7':
            case '8': case '9':
                flags &amp;= ~(SCAN_SIGNOK | SCAN_NODIGITS);
                goto addToFloat;
            case '+': case '-':
                if (flags &amp; SCAN_SIGNOK) {
                flags &amp;= ~SCAN_SIGNOK;
                goto addToFloat;
                }
                break;
            case '.':
                if (flags &amp; SCAN_PTOK) {
                flags &amp;= ~(SCAN_SIGNOK | SCAN_PTOK);
                goto addToFloat;
                }
                break;
            case 'e': case 'E':
                /*
                 * An exponent is not allowed until there has
                 * been at least one digit.
                 */

                if ((flags &amp; (SCAN_NODIGITS | SCAN_EXPOK))
                    == SCAN_EXPOK) {
                flags = (flags &amp; ~(SCAN_EXPOK|SCAN_PTOK))
                    | SCAN_SIGNOK | SCAN_NODIGITS;
                goto addToFloat;
                }
                break;
            }

            /*
             * We got an illegal character so we are done accumulating.
             */

            break;

            addToFloat:
            /*
             * Add the character to the temporary buffer.
             */

            *end++ = *string++;
            if (*string == '\0') {
            break;
            }
        }

        /*
         * Check to see if we need to back up because we saw a
         * trailing 'e' or sign.
         */

        if (flags &amp; SCAN_NODIGITS) {
            if (flags &amp; SCAN_EXPOK) {
            /*
             * There were no digits at all so scanning has
             * failed and we are done.
             */
            if (*string == '\0') {
                underflow = 1;
            }
            goto done;
            }

            /*
             * We got a bad exponent ('e' and maybe a sign).
             */

            end--;
            string--;
            if (*end != 'e' &amp;&amp; *end != 'E') {
            end--;
            string--;
            }
        }

        /*
         * Scan the value from the temporary buffer.
         */

        if (!(flags &amp; SCAN_SUPPRESS)) {
            double dvalue;
            *end = '\0';
            dvalue = strtod(buf, NULL);
            objPtr = Tcl_NewDoubleObj(dvalue);
            Tcl_IncrRefCount(objPtr);
            objs[objIndex++] = objPtr;
        }
        break;
    }
    nconversions++;
    }

    done:
    result = 0;
    code = TCL_OK;

    if (numVars) {
    /*
     * In this case, variables were specified (classic scan)
     */
    for (i = 0; i &lt; totalVars; i++) {
        if (objs[i] != NULL) {
        Tcl_Obj *tmpPtr;
        
        result++;
        tmpPtr = Tcl_ObjSetVar2(interp, objv[i+3], NULL, objs[i], 0);
        Tcl_DecrRefCount(objs[i]);
        if (tmpPtr == NULL) {
            Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
                "couldn't set variable \"",
                Tcl_GetString(objv[i+3]), "\"", (char *) NULL);
            code = TCL_ERROR;
        }
        }
    }
    } else {
    /*
     * Here no vars were specified, we want a list returned (inline scan)
     */
    objPtr = Tcl_NewObj();
    for (i = 0; i &lt; totalVars; i++) {
        if (objs[i] != NULL) {
        Tcl_ListObjAppendElement(NULL, objPtr, objs[i]);
        Tcl_DecrRefCount(objs[i]);
        } else {
        /*
         * More %-specifiers than matching chars, so we
         * just spit out empty strings for these
         */
        Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewObj());
        }
    }
    }
    if (objs != NULL) {
    ckfree((char*) objs);
    }
    if (code == TCL_OK) {
    if (underflow &amp;&amp; (nconversions == 0)) {
        if (numVars) {
        objPtr = Tcl_NewIntObj(-1);
        } else {
        if (objPtr) {
            Tcl_SetListObj(objPtr, 0, NULL);
        } else {
            objPtr = Tcl_NewObj();
        }
        }
    } else if (numVars) {
        objPtr = Tcl_NewIntObj(result);
    }
    Tcl_SetObjResult(interp, objPtr);
    }
    return code;
}
</t>
<t tx="ekr.20071105090148.282">@language c
@tabwidth -4
@others
@ignore</t>
<t tx="ekr.20071105090148.283">/* 
 * tclObj.c --
 *
 *	This file contains Tcl object-related procedures that are used by
 * 	many Tcl commands.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright (c) 1999 by Scriptics Corporation.
 * Copyright (c) 2001 by ActiveState Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id: oldLeoProjects.leo,v 1.21 2007/12/11 17:42:26 edream Exp $
 */

#include "tclInt.h"
#include "tclCompile.h"
#include "tclPort.h"

/*
 * Table of all object types.
 */

static Tcl_HashTable typeTable;
static int typeTableInitialized = 0;    /* 0 means not yet initialized. */
TCL_DECLARE_MUTEX(tableMutex)

/*
 * Head of the list of free Tcl_Obj structs we maintain.
 */

Tcl_Obj *tclFreeObjList = NULL;

/*
 * The object allocator is single threaded.  This mutex is referenced
 * by the TclNewObj macro, however, so must be visible.
 */

#ifdef TCL_THREADS
Tcl_Mutex tclObjMutex;
#endif

/*
 * Pointer to a heap-allocated string of length zero that the Tcl core uses
 * as the value of an empty string representation for an object. This value
 * is shared by all new objects allocated by Tcl_NewObj.
 */

char tclEmptyString = '\0';
char *tclEmptyStringRep = &amp;tclEmptyString;

/*
 * Prototypes for procedures defined later in this file:
 */

static int		SetBooleanFromAny _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));
static int		SetDoubleFromAny _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));
static int		SetIntFromAny _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));
static int		SetIntOrWideFromAny _ANSI_ARGS_((Tcl_Interp* interp,
							 Tcl_Obj *objPtr));
static void		UpdateStringOfBoolean _ANSI_ARGS_((Tcl_Obj *objPtr));
static void		UpdateStringOfDouble _ANSI_ARGS_((Tcl_Obj *objPtr));
static void		UpdateStringOfInt _ANSI_ARGS_((Tcl_Obj *objPtr));
static int		SetWideIntFromAny _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));

#ifndef TCL_WIDE_INT_IS_LONG
static void		UpdateStringOfWideInt _ANSI_ARGS_((Tcl_Obj *objPtr));
#endif

/*
 * Prototypes for the array hash key methods.
 */

static Tcl_HashEntry *	AllocObjEntry _ANSI_ARGS_((
			    Tcl_HashTable *tablePtr, VOID *keyPtr));
static int		CompareObjKeys _ANSI_ARGS_((
			    VOID *keyPtr, Tcl_HashEntry *hPtr));
static void		FreeObjEntry _ANSI_ARGS_((
			    Tcl_HashEntry *hPtr));
static unsigned int	HashObjKey _ANSI_ARGS_((
			    Tcl_HashTable *tablePtr,
			    VOID *keyPtr));

/*
 * Prototypes for the CommandName object type.
 */

static void		DupCmdNameInternalRep _ANSI_ARGS_((Tcl_Obj *objPtr,
			    Tcl_Obj *copyPtr));
static void		FreeCmdNameInternalRep _ANSI_ARGS_((
    			    Tcl_Obj *objPtr));
static int		SetCmdNameFromAny _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));


/*
 * The structures below defines the Tcl object types defined in this file by
 * means of procedures that can be invoked by generic object code. See also
 * tclStringObj.c, tclListObj.c, tclByteCode.c for other type manager
 * implementations.
 */

Tcl_ObjType tclBooleanType = {
    "boolean",				/* name */
    (Tcl_FreeInternalRepProc *) NULL,   /* freeIntRepProc */
    (Tcl_DupInternalRepProc *) NULL,	/* dupIntRepProc */
    UpdateStringOfBoolean,		/* updateStringProc */
    SetBooleanFromAny			/* setFromAnyProc */
};

Tcl_ObjType tclDoubleType = {
    "double",				/* name */
    (Tcl_FreeInternalRepProc *) NULL,   /* freeIntRepProc */
    (Tcl_DupInternalRepProc *) NULL,	/* dupIntRepProc */
    UpdateStringOfDouble,		/* updateStringProc */
    SetDoubleFromAny			/* setFromAnyProc */
};

Tcl_ObjType tclIntType = {
    "int",				/* name */
    (Tcl_FreeInternalRepProc *) NULL,   /* freeIntRepProc */
    (Tcl_DupInternalRepProc *) NULL,	/* dupIntRepProc */
    UpdateStringOfInt,			/* updateStringProc */
    SetIntFromAny			/* setFromAnyProc */
};

Tcl_ObjType tclWideIntType = {
    "wideInt",				/* name */
    (Tcl_FreeInternalRepProc *) NULL,   /* freeIntRepProc */
    (Tcl_DupInternalRepProc *) NULL,	/* dupIntRepProc */
#ifdef TCL_WIDE_INT_IS_LONG
    UpdateStringOfInt,			/* updateStringProc */
#else /* !TCL_WIDE_INT_IS_LONG */
    UpdateStringOfWideInt,		/* updateStringProc */
#endif
    SetWideIntFromAny			/* setFromAnyProc */
};

/*
 * The structure below defines the Tcl obj hash key type.
 */
Tcl_HashKeyType tclObjHashKeyType = {
    TCL_HASH_KEY_TYPE_VERSION,		/* version */
    0,					/* flags */
    HashObjKey,				/* hashKeyProc */
    CompareObjKeys,			/* compareKeysProc */
    AllocObjEntry,			/* allocEntryProc */
    FreeObjEntry			/* freeEntryProc */
};

/*
 * The structure below defines the command name Tcl object type by means of
 * procedures that can be invoked by generic object code. Objects of this
 * type cache the Command pointer that results from looking up command names
 * in the command hashtable. Such objects appear as the zeroth ("command
 * name") argument in a Tcl command.
 *
 * NOTE: the ResolvedCmdName that gets cached is stored in the
 * twoPtrValue.ptr1 field, and the twoPtrValue.ptr2 field is unused.
 * You might think you could use the simpler otherValuePtr field to
 * store the single ResolvedCmdName pointer, but DO NOT DO THIS.  It
 * seems that some extensions use the second internal pointer field
 * of the twoPtrValue field for their own purposes.
 */

static Tcl_ObjType tclCmdNameType = {
    "cmdName",				/* name */
    FreeCmdNameInternalRep,		/* freeIntRepProc */
    DupCmdNameInternalRep,		/* dupIntRepProc */
    (Tcl_UpdateStringProc *) NULL,	/* updateStringProc */
    SetCmdNameFromAny			/* setFromAnyProc */
};


/*
 * Structure containing a cached pointer to a command that is the result
 * of resolving the command's name in some namespace. It is the internal
 * representation for a cmdName object. It contains the pointer along
 * with some information that is used to check the pointer's validity.
 */

typedef struct ResolvedCmdName {
    Command *cmdPtr;		/* A cached Command pointer. */
    Namespace *refNsPtr;	/* Points to the namespace containing the
				 * reference (not the namespace that
				 * contains the referenced command). */
    long refNsId;		/* refNsPtr's unique namespace id. Used to
				 * verify that refNsPtr is still valid
				 * (e.g., it's possible that the cmd's
				 * containing namespace was deleted and a
				 * new one created at the same address). */
    int refNsCmdEpoch;		/* Value of the referencing namespace's
				 * cmdRefEpoch when the pointer was cached.
				 * Before using the cached pointer, we check
				 * if the namespace's epoch was incremented;
				 * if so, this cached pointer is invalid. */
    int cmdEpoch;		/* Value of the command's cmdEpoch when this
				 * pointer was cached. Before using the
				 * cached pointer, we check if the cmd's
				 * epoch was incremented; if so, the cmd was
				 * renamed, deleted, hidden, or exposed, and
				 * so the pointer is invalid. */
    int refCount;		/* Reference count: 1 for each cmdName
				 * object that has a pointer to this
				 * ResolvedCmdName structure as its internal
				 * rep. This structure can be freed when
				 * refCount becomes zero. */
} ResolvedCmdName;


</t>
<t tx="ekr.20071105090148.284">/*
 *-------------------------------------------------------------------------
 *
 * TclInitObjectSubsystem --
 *
 *	This procedure is invoked to perform once-only initialization of
 *	the type table. It also registers the object types defined in 
 *	this file.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Initializes the table of defined object types "typeTable" with
 *	builtin object types defined in this file.  
 *
 *-------------------------------------------------------------------------
 */

void
TclInitObjSubsystem()
{
    Tcl_MutexLock(&amp;tableMutex);
    typeTableInitialized = 1;
    Tcl_InitHashTable(&amp;typeTable, TCL_STRING_KEYS);
    Tcl_MutexUnlock(&amp;tableMutex);

    Tcl_RegisterObjType(&amp;tclBooleanType);
    Tcl_RegisterObjType(&amp;tclByteArrayType);
    Tcl_RegisterObjType(&amp;tclDoubleType);
    Tcl_RegisterObjType(&amp;tclEndOffsetType);
    Tcl_RegisterObjType(&amp;tclIntType);
    Tcl_RegisterObjType(&amp;tclWideIntType);
    Tcl_RegisterObjType(&amp;tclStringType);
    Tcl_RegisterObjType(&amp;tclListType);
    Tcl_RegisterObjType(&amp;tclByteCodeType);
    Tcl_RegisterObjType(&amp;tclProcBodyType);
    Tcl_RegisterObjType(&amp;tclArraySearchType);
    Tcl_RegisterObjType(&amp;tclIndexType);
    Tcl_RegisterObjType(&amp;tclNsNameType);
    Tcl_RegisterObjType(&amp;tclCmdNameType);

#ifdef TCL_COMPILE_STATS
    Tcl_MutexLock(&amp;tclObjMutex);
    tclObjsAlloced = 0;
    tclObjsFreed = 0;
    {
	int i;
	for (i = 0;  i &lt; TCL_MAX_SHARED_OBJ_STATS;  i++) {
	    tclObjsShared[i] = 0;
	}
    }
    Tcl_MutexUnlock(&amp;tclObjMutex);
#endif
}
</t>
<t tx="ekr.20071105090148.285">
/*
 *----------------------------------------------------------------------
 *
 * TclFinalizeObjects --
 *
 *	This procedure is called by Tcl_Finalize to clean up all
 *	registered Tcl_ObjType's and to reset the tclFreeObjList.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TclFinalizeObjects()
{
    Tcl_MutexLock(&amp;tableMutex);
    if (typeTableInitialized) {
        Tcl_DeleteHashTable(&amp;typeTable);
        typeTableInitialized = 0;
    }
    Tcl_MutexUnlock(&amp;tableMutex);

    /* 
     * All we do here is reset the head pointer of the linked list of
     * free Tcl_Obj's to NULL;  the memory finalization will take care
     * of releasing memory for us.
     */
    Tcl_MutexLock(&amp;tclObjMutex);
    tclFreeObjList = NULL;
    Tcl_MutexUnlock(&amp;tclObjMutex);
}
</t>
<t tx="ekr.20071105090148.286">
/*
 *--------------------------------------------------------------
 *
 * Tcl_RegisterObjType --
 *
 *	This procedure is called to register a new Tcl object type
 *	in the table of all object types supported by Tcl.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The type is registered in the Tcl type table. If there was already
 *	a type with the same name as in typePtr, it is replaced with the
 *	new type.
 *
 *--------------------------------------------------------------
 */

void
Tcl_RegisterObjType(typePtr)
    Tcl_ObjType *typePtr;	/* Information about object type;
				 * storage must be statically
				 * allocated (must live forever). */
{
    int new;
    Tcl_MutexLock(&amp;tableMutex);
    Tcl_SetHashValue(
	    Tcl_CreateHashEntry(&amp;typeTable, typePtr-&gt;name, &amp;new), typePtr);
    Tcl_MutexUnlock(&amp;tableMutex);
}
</t>
<t tx="ekr.20071105090148.287">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_AppendAllObjTypes --
 *
 *	This procedure appends onto the argument object the name of each
 *	object type as a list element. This includes the builtin object
 *	types (e.g. int, list) as well as those added using
 *	Tcl_NewObj. These names can be used, for example, with
 *	Tcl_GetObjType to get pointers to the corresponding Tcl_ObjType
 *	structures.
 *
 * Results:
 *	The return value is normally TCL_OK; in this case the object
 *	referenced by objPtr has each type name appended to it. If an
 *	error occurs, TCL_ERROR is returned and the interpreter's result
 *	holds an error message.
 *
 * Side effects:
 *	If necessary, the object referenced by objPtr is converted into
 *	a list object.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_AppendAllObjTypes(interp, objPtr)
    Tcl_Interp *interp;		/* Interpreter used for error reporting. */
    Tcl_Obj *objPtr;		/* Points to the Tcl object onto which the
				 * name of each registered type is appended
				 * as a list element. */
{
    register Tcl_HashEntry *hPtr;
    Tcl_HashSearch search;
    int objc;
    Tcl_Obj **objv;

    /*
     * Get the test for a valid list out of the way first.
     */

    if (Tcl_ListObjGetElements(interp, objPtr, &amp;objc, &amp;objv) != TCL_OK) {
	return TCL_ERROR;
    }

    /*
     * Type names are NUL-terminated, not counted strings.
     * This code relies on that.
     */

    Tcl_MutexLock(&amp;tableMutex);
    for (hPtr = Tcl_FirstHashEntry(&amp;typeTable, &amp;search);
	    hPtr != NULL;  hPtr = Tcl_NextHashEntry(&amp;search)) {
	Tcl_ListObjAppendElement(NULL, objPtr,
	        Tcl_NewStringObj(Tcl_GetHashKey(&amp;typeTable, hPtr), -1));
    }
    Tcl_MutexUnlock(&amp;tableMutex);
    return TCL_OK;
}
</t>
<t tx="ekr.20071105090148.288">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetObjType --
 *
 *	This procedure looks up an object type by name.
 *
 * Results:
 *	If an object type with name matching "typeName" is found, a pointer
 *	to its Tcl_ObjType structure is returned; otherwise, NULL is
 *	returned.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_ObjType *
Tcl_GetObjType(typeName)
    CONST char *typeName;	/* Name of Tcl object type to look up. */
{
    register Tcl_HashEntry *hPtr;
    Tcl_ObjType *typePtr = NULL;

    Tcl_MutexLock(&amp;tableMutex);
    hPtr = Tcl_FindHashEntry(&amp;typeTable, typeName);
    if (hPtr != (Tcl_HashEntry *) NULL) {
        typePtr = (Tcl_ObjType *) Tcl_GetHashValue(hPtr);
    }
    Tcl_MutexUnlock(&amp;tableMutex);
    return typePtr;
}
</t>
<t tx="ekr.20071105090148.289">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_ConvertToType --
 *
 *	Convert the Tcl object "objPtr" to have type "typePtr" if possible.
 *
 * Results:
 *	The return value is TCL_OK on success and TCL_ERROR on failure. If
 *	TCL_ERROR is returned, then the interpreter's result contains an
 *	error message unless "interp" is NULL. Passing a NULL "interp"
 *	allows this procedure to be used as a test whether the conversion
 *	could be done (and in fact was done).
 *
 * Side effects:
 *	Any internal representation for the old type is freed.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_ConvertToType(interp, objPtr, typePtr)
    Tcl_Interp *interp;		/* Used for error reporting if not NULL. */
    Tcl_Obj *objPtr;		/* The object to convert. */
    Tcl_ObjType *typePtr;	/* The target type. */
{
    if (objPtr-&gt;typePtr == typePtr) {
	return TCL_OK;
    }

    /*
     * Use the target type's Tcl_SetFromAnyProc to set "objPtr"s internal
     * form as appropriate for the target type. This frees the old internal
     * representation.
     */

    return typePtr-&gt;setFromAnyProc(interp, objPtr);
}
</t>
<t tx="ekr.20071105090148.290">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_NewObj --
 *
 *	This procedure is normally called when not debugging: i.e., when
 *	TCL_MEM_DEBUG is not defined. It creates new Tcl objects that denote
 *	the empty string. These objects have a NULL object type and NULL
 *	string representation byte pointer. Type managers call this routine
 *	to allocate new objects that they further initialize.
 *
 *	When TCL_MEM_DEBUG is defined, this procedure just returns the
 *	result of calling the debugging version Tcl_DbNewObj.
 *
 * Results:
 *	The result is a newly allocated object that represents the empty
 *	string. The new object's typePtr is set NULL and its ref count
 *	is set to 0.
 *
 * Side effects:
 *	If compiling with TCL_COMPILE_STATS, this procedure increments
 *	the global count of allocated objects (tclObjsAlloced).
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG
#undef Tcl_NewObj

Tcl_Obj *
Tcl_NewObj()
{
    return Tcl_DbNewObj("unknown", 0);
}
</t>
<t tx="ekr.20071105090148.291">
#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_NewObj()
{
    register Tcl_Obj *objPtr;

    /*
     * Use the macro defined in tclInt.h - it will use the
     * correct allocator.
     */

    TclNewObj(objPtr);
    return objPtr;
}
</t>
<t tx="ekr.20071105090148.292">#endif /* TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_DbNewObj --
 *
 *	This procedure is normally called when debugging: i.e., when
 *	TCL_MEM_DEBUG is defined. It creates new Tcl objects that denote the
 *	empty string. It is the same as the Tcl_NewObj procedure above
 *	except that it calls Tcl_DbCkalloc directly with the file name and
 *	line number from its caller. This simplifies debugging since then
 *	the [memory active] command will report the correct file name and line
 *	number when reporting objects that haven't been freed.
 *
 *	When TCL_MEM_DEBUG is not defined, this procedure just returns the
 *	result of calling Tcl_NewObj.
 *
 * Results:
 *	The result is a newly allocated that represents the empty string.
 *	The new object's typePtr is set NULL and its ref count is set to 0.
 *
 * Side effects:
 *	If compiling with TCL_COMPILE_STATS, this procedure increments
 *	the global count of allocated objects (tclObjsAlloced).
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG

Tcl_Obj *
Tcl_DbNewObj(file, line)
    register CONST char *file;	/* The name of the source file calling this
				 * procedure; used for debugging. */
    register int line;		/* Line number in the source file; used
				 * for debugging. */
{
    register Tcl_Obj *objPtr;

    /*
     * Use the macro defined in tclInt.h - it will use the
     * correct allocator.
     */

    TclDbNewObj(objPtr, file, line);
    return objPtr;
}
</t>
<t tx="ekr.20071105090148.293">#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_DbNewObj(file, line)
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
    return Tcl_NewObj();
}
</t>
<t tx="ekr.20071105090148.294">#endif /* TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * TclAllocateFreeObjects --
 *
 *	Procedure to allocate a number of free Tcl_Objs. This is done using
 *	a single ckalloc to reduce the overhead for Tcl_Obj allocation.
 *
 *	Assumes mutex is held.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	tclFreeObjList, the head of the list of free Tcl_Objs, is set to the
 *	first of a number of free Tcl_Obj's linked together by their
 *	internalRep.otherValuePtrs.
 *
 *----------------------------------------------------------------------
 */

#define OBJS_TO_ALLOC_EACH_TIME 100

void
TclAllocateFreeObjects()
{
    size_t bytesToAlloc = (OBJS_TO_ALLOC_EACH_TIME * sizeof(Tcl_Obj));
    char *basePtr;
    register Tcl_Obj *prevPtr, *objPtr;
    register int i;

    /*
     * This has been noted by Purify to be a potential leak.  The problem is
     * that Tcl, when not TCL_MEM_DEBUG compiled, keeps around all allocated
     * Tcl_Obj's, pointed to by tclFreeObjList, when freed instead of
     * actually freeing the memory.  TclFinalizeObjects() does not ckfree()
     * this memory, but leaves it to Tcl's memory subsystem finalziation to
     * release it.  Purify apparently can't figure that out, and fires a
     * false alarm.
     */

    basePtr = (char *) ckalloc(bytesToAlloc);
    memset(basePtr, 0, bytesToAlloc);

    prevPtr = NULL;
    objPtr = (Tcl_Obj *) basePtr;
    for (i = 0; i &lt; OBJS_TO_ALLOC_EACH_TIME; i++) {
	objPtr-&gt;internalRep.otherValuePtr = (VOID *) prevPtr;
	prevPtr = objPtr;
	objPtr++;
    }
    tclFreeObjList = prevPtr;
}
</t>
<t tx="ekr.20071105090148.295">#undef OBJS_TO_ALLOC_EACH_TIME

/*
 *----------------------------------------------------------------------
 *
 * TclFreeObj --
 *
 *	This procedure frees the memory associated with the argument
 *	object. It is called by the tcl.h macro Tcl_DecrRefCount when an
 *	object's ref count is zero. It is only "public" since it must
 *	be callable by that macro wherever the macro is used. It should not
 *	be directly called by clients.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Deallocates the storage for the object's Tcl_Obj structure
 *	after deallocating the string representation and calling the
 *	type-specific Tcl_FreeInternalRepProc to deallocate the object's
 *	internal representation. If compiling with TCL_COMPILE_STATS,
 *	this procedure increments the global count of freed objects
 *	(tclObjsFreed).
 *
 *----------------------------------------------------------------------
 */

void
TclFreeObj(objPtr)
    register Tcl_Obj *objPtr;	/* The object to be freed. */
{
    register Tcl_ObjType *typePtr = objPtr-&gt;typePtr;
    
#ifdef TCL_MEM_DEBUG
    if ((objPtr)-&gt;refCount &lt; -1) {
	panic("Reference count for %lx was negative", objPtr);
    }
#endif /* TCL_MEM_DEBUG */

    if ((typePtr != NULL) &amp;&amp; (typePtr-&gt;freeIntRepProc != NULL)) {
	typePtr-&gt;freeIntRepProc(objPtr);
    }
    Tcl_InvalidateStringRep(objPtr);

    /*
     * If debugging Tcl's memory usage, deallocate the object using ckfree.
     * Otherwise, deallocate it by adding it onto the list of free
     * Tcl_Obj structs we maintain.
     */

#if defined(TCL_MEM_DEBUG) || defined(PURIFY)
    Tcl_MutexLock(&amp;tclObjMutex);
    ckfree((char *) objPtr);
    Tcl_MutexUnlock(&amp;tclObjMutex);
#elif defined(TCL_THREADS) &amp;&amp; defined(USE_THREAD_ALLOC) 
    TclThreadFreeObj(objPtr); 
#else 
    Tcl_MutexLock(&amp;tclObjMutex);
    objPtr-&gt;internalRep.otherValuePtr = (VOID *) tclFreeObjList;
    tclFreeObjList = objPtr;
    Tcl_MutexUnlock(&amp;tclObjMutex);
#endif /* TCL_MEM_DEBUG */

#ifdef TCL_COMPILE_STATS
    tclObjsFreed++;
#endif /* TCL_COMPILE_STATS */
}
</t>
<t tx="ekr.20071105090148.296">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_DuplicateObj --
 *
 *	Create and return a new object that is a duplicate of the argument
 *	object.
 *
 * Results:
 *	The return value is a pointer to a newly created Tcl_Obj. This
 *	object has reference count 0 and the same type, if any, as the
 *	source object objPtr. Also:
 *	  1) If the source object has a valid string rep, we copy it;
 *	     otherwise, the duplicate's string rep is set NULL to mark
 *	     it invalid.
 *	  2) If the source object has an internal representation (i.e. its
 *	     typePtr is non-NULL), the new object's internal rep is set to
 *	     a copy; otherwise the new internal rep is marked invalid.
 *
 * Side effects:
 *      What constitutes "copying" the internal representation depends on
 *	the type. For example, if the argument object is a list,
 *	the element objects it points to will not actually be copied but
 *	will be shared with the duplicate list. That is, the ref counts of
 *	the element objects will be incremented.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_DuplicateObj(objPtr)
    register Tcl_Obj *objPtr;		/* The object to duplicate. */
{
    register Tcl_ObjType *typePtr = objPtr-&gt;typePtr;
    register Tcl_Obj *dupPtr;

    TclNewObj(dupPtr);

    if (objPtr-&gt;bytes == NULL) {
	dupPtr-&gt;bytes = NULL;
    } else if (objPtr-&gt;bytes != tclEmptyStringRep) {
	TclInitStringRep(dupPtr, objPtr-&gt;bytes, objPtr-&gt;length);
    }
    
    if (typePtr != NULL) {
	if (typePtr-&gt;dupIntRepProc == NULL) {
	    dupPtr-&gt;internalRep = objPtr-&gt;internalRep;
	    dupPtr-&gt;typePtr = typePtr;
	} else {
	    (*typePtr-&gt;dupIntRepProc)(objPtr, dupPtr);
	}
    }
    return dupPtr;
}
</t>
<t tx="ekr.20071105090148.297">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetString --
 *
 *	Returns the string representation byte array pointer for an object.
 *
 * Results:
 *	Returns a pointer to the string representation of objPtr. The byte
 *	array referenced by the returned pointer must not be modified by the
 *	caller. Furthermore, the caller must copy the bytes if they need to
 *	retain them since the object's string rep can change as a result of
 *	other operations.
 *
 * Side effects:
 *	May call the object's updateStringProc to update the string
 *	representation from the internal representation.
 *
 *----------------------------------------------------------------------
 */

char *
Tcl_GetString(objPtr)
    register Tcl_Obj *objPtr;	/* Object whose string rep byte pointer
				 * should be returned. */
{
    if (objPtr-&gt;bytes != NULL) {
	return objPtr-&gt;bytes;
    }

    if (objPtr-&gt;typePtr-&gt;updateStringProc == NULL) {
	panic("UpdateStringProc should not be invoked for type %s",
		objPtr-&gt;typePtr-&gt;name);
    }
    (*objPtr-&gt;typePtr-&gt;updateStringProc)(objPtr);
    return objPtr-&gt;bytes;
}
</t>
<t tx="ekr.20071105090148.298">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetStringFromObj --
 *
 *	Returns the string representation's byte array pointer and length
 *	for an object.
 *
 * Results:
 *	Returns a pointer to the string representation of objPtr. If
 *	lengthPtr isn't NULL, the length of the string representation is
 *	stored at *lengthPtr. The byte array referenced by the returned
 *	pointer must not be modified by the caller. Furthermore, the
 *	caller must copy the bytes if they need to retain them since the
 *	object's string rep can change as a result of other operations.
 *
 * Side effects:
 *	May call the object's updateStringProc to update the string
 *	representation from the internal representation.
 *
 *----------------------------------------------------------------------
 */

char *
Tcl_GetStringFromObj(objPtr, lengthPtr)
    register Tcl_Obj *objPtr;	/* Object whose string rep byte pointer should
				 * be returned. */
    register int *lengthPtr;	/* If non-NULL, the location where the string
				 * rep's byte array length should * be stored.
				 * If NULL, no length is stored. */
{
    if (objPtr-&gt;bytes == NULL) {
	if (objPtr-&gt;typePtr-&gt;updateStringProc == NULL) {
	    panic("UpdateStringProc should not be invoked for type %s",
		    objPtr-&gt;typePtr-&gt;name);
	}
	(*objPtr-&gt;typePtr-&gt;updateStringProc)(objPtr);
    }

    if (lengthPtr != NULL) {
	*lengthPtr = objPtr-&gt;length;
    }
    return objPtr-&gt;bytes;
}
</t>
<t tx="ekr.20071105090148.299">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_InvalidateStringRep --
 *
 *	This procedure is called to invalidate an object's string
 *	representation. 
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Deallocates the storage for any old string representation, then
 *	sets the string representation NULL to mark it invalid.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_InvalidateStringRep(objPtr)
     register Tcl_Obj *objPtr;	/* Object whose string rep byte pointer
				 * should be freed. */
{
    if (objPtr-&gt;bytes != NULL) {
	if (objPtr-&gt;bytes != tclEmptyStringRep) {
	    ckfree((char *) objPtr-&gt;bytes);
	}
	objPtr-&gt;bytes = NULL;
    }
}
</t>
<t tx="ekr.20071105090148.300">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_NewBooleanObj --
 *
 *	This procedure is normally called when not debugging: i.e., when
 *	TCL_MEM_DEBUG is not defined. It creates a new Tcl_Obj and
 *	initializes it from the argument boolean value. A nonzero
 *	"boolValue" is coerced to 1.
 *
 *	When TCL_MEM_DEBUG is defined, this procedure just returns the
 *	result of calling the debugging version Tcl_DbNewBooleanObj.
 *
 * Results:
 *	The newly created object is returned. This object will have an
 *	invalid string representation. The returned object has ref count 0.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG
#undef Tcl_NewBooleanObj

Tcl_Obj *
Tcl_NewBooleanObj(boolValue)
    register int boolValue;	/* Boolean used to initialize new object. */
{
    return Tcl_DbNewBooleanObj(boolValue, "unknown", 0);
}
</t>
<t tx="ekr.20071105090148.301">
#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_NewBooleanObj(boolValue)
    register int boolValue;	/* Boolean used to initialize new object. */
{
    register Tcl_Obj *objPtr;

    TclNewObj(objPtr);
    objPtr-&gt;bytes = NULL;
    
    objPtr-&gt;internalRep.longValue = (boolValue? 1 : 0);
    objPtr-&gt;typePtr = &amp;tclBooleanType;
    return objPtr;
}
</t>
<t tx="ekr.20071105090148.302">#endif /* TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_DbNewBooleanObj --
 *
 *	This procedure is normally called when debugging: i.e., when
 *	TCL_MEM_DEBUG is defined. It creates new boolean objects. It is the
 *	same as the Tcl_NewBooleanObj procedure above except that it calls
 *	Tcl_DbCkalloc directly with the file name and line number from its
 *	caller. This simplifies debugging since then the [memory active]
 *	command	will report the correct file name and line number when
 *	reporting objects that haven't been freed.
 *
 *	When TCL_MEM_DEBUG is not defined, this procedure just returns the
 *	result of calling Tcl_NewBooleanObj.
 *
 * Results:
 *	The newly created object is returned. This object will have an
 *	invalid string representation. The returned object has ref count 0.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG

Tcl_Obj *
Tcl_DbNewBooleanObj(boolValue, file, line)
    register int boolValue;	/* Boolean used to initialize new object. */
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
    register Tcl_Obj *objPtr;

    TclDbNewObj(objPtr, file, line);
    objPtr-&gt;bytes = NULL;
    
    objPtr-&gt;internalRep.longValue = (boolValue? 1 : 0);
    objPtr-&gt;typePtr = &amp;tclBooleanType;
    return objPtr;
}
</t>
<t tx="ekr.20071105090148.303">
#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_DbNewBooleanObj(boolValue, file, line)
    register int boolValue;	/* Boolean used to initialize new object. */
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
    return Tcl_NewBooleanObj(boolValue);
}
</t>
<t tx="ekr.20071105090148.304">#endif /* TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetBooleanObj --
 *
 *	Modify an object to be a boolean object and to have the specified
 *	boolean value. A nonzero "boolValue" is coerced to 1.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's old string rep, if any, is freed. Also, any old
 *	internal rep is freed.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SetBooleanObj(objPtr, boolValue)
    register Tcl_Obj *objPtr;	/* Object whose internal rep to init. */
    register int boolValue;	/* Boolean used to set object's value. */
{
    register Tcl_ObjType *oldTypePtr = objPtr-&gt;typePtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_SetBooleanObj called with shared object");
    }
    
    if ((oldTypePtr != NULL) &amp;&amp; (oldTypePtr-&gt;freeIntRepProc != NULL)) {
	oldTypePtr-&gt;freeIntRepProc(objPtr);
    }
    
    objPtr-&gt;internalRep.longValue = (boolValue? 1 : 0);
    objPtr-&gt;typePtr = &amp;tclBooleanType;
    Tcl_InvalidateStringRep(objPtr);
}
</t>
<t tx="ekr.20071105090148.305">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetBooleanFromObj --
 *
 *	Attempt to return a boolean from the Tcl object "objPtr". If the
 *	object is not already a boolean, an attempt will be made to convert
 *	it to one.
 *
 * Results:
 *	The return value is a standard Tcl object result. If an error occurs
 *	during conversion, an error message is left in the interpreter's
 *	result unless "interp" is NULL.
 *
 * Side effects:
 *	If the object is not already a boolean, the conversion will free
 *	any old internal representation. 
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetBooleanFromObj(interp, objPtr, boolPtr)
    Tcl_Interp *interp; 	/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object from which to get boolean. */
    register int *boolPtr;	/* Place to store resulting boolean. */
{
    register int result;

    if (objPtr-&gt;typePtr == &amp;tclBooleanType) {
	result = TCL_OK;
    } else {
	result = SetBooleanFromAny(interp, objPtr);
    }

    if (result == TCL_OK) {
	*boolPtr = (int) objPtr-&gt;internalRep.longValue;
    }
    return result;
}
</t>
<t tx="ekr.20071105090148.306">
/*
 *----------------------------------------------------------------------
 *
 * SetBooleanFromAny --
 *
 *	Attempt to generate a boolean internal form for the Tcl object
 *	"objPtr".
 *
 * Results:
 *	The return value is a standard Tcl result. If an error occurs during
 *	conversion, an error message is left in the interpreter's result
 *	unless "interp" is NULL.
 *
 * Side effects:
 *	If no error occurs, an integer 1 or 0 is stored as "objPtr"s
 *	internal representation and the type of "objPtr" is set to boolean.
 *
 *----------------------------------------------------------------------
 */

static int
SetBooleanFromAny(interp, objPtr)
    Tcl_Interp *interp;		/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object to convert. */
{
    Tcl_ObjType *oldTypePtr = objPtr-&gt;typePtr;
    char *string, *end;
    register char c;
    char lowerCase[10];
    int newBool, length;
    register int i;

    /*
     * Get the string representation. Make it up-to-date if necessary.
     */
    
    string = Tcl_GetStringFromObj(objPtr, &amp;length);

    /*
     * Use the obvious shortcuts for numerical values; if objPtr is not
     * of numerical type, parse its string rep.
     */
	
    if (objPtr-&gt;typePtr == &amp;tclIntType) {
	newBool = (objPtr-&gt;internalRep.longValue != 0);
    } else if (objPtr-&gt;typePtr == &amp;tclDoubleType) {
	newBool = (objPtr-&gt;internalRep.doubleValue != 0.0);
    } else if (objPtr-&gt;typePtr == &amp;tclWideIntType) {
	newBool = (objPtr-&gt;internalRep.wideValue != 0);
    } else {
	/*
	 * Copy the string converting its characters to lower case.
	 */
	
	for (i = 0;  (i &lt; 9) &amp;&amp; (i &lt; length);  i++) {
	    c = string[i];
	    /*
	     * Weed out international characters so we can safely operate
	     * on single bytes.
	     */
	    
	    if (c &amp; 0x80) {
		goto badBoolean;
	    }
	    if (Tcl_UniCharIsUpper(UCHAR(c))) {
		c = (char) Tcl_UniCharToLower(UCHAR(c));
	    }
	    lowerCase[i] = c;
	}
	lowerCase[i] = 0;
	
	/*
	 * Parse the string as a boolean. We use an implementation here that
	 * doesn't report errors in interp if interp is NULL.
	 */
	
	c = lowerCase[0];
	if ((c == '0') &amp;&amp; (lowerCase[1] == '\0')) {
	    newBool = 0;
	} else if ((c == '1') &amp;&amp; (lowerCase[1] == '\0')) {
	    newBool = 1;
	} else if ((c == 'y') &amp;&amp; (strncmp(lowerCase, "yes", (size_t) length) == 0)) {
	    newBool = 1;
	} else if ((c == 'n') &amp;&amp; (strncmp(lowerCase, "no", (size_t) length) == 0)) {
	    newBool = 0;
	} else if ((c == 't') &amp;&amp; (strncmp(lowerCase, "true", (size_t) length) == 0)) {
	    newBool = 1;
	} else if ((c == 'f') &amp;&amp; (strncmp(lowerCase, "false", (size_t) length) == 0)) {
	    newBool = 0;
	} else if ((c == 'o') &amp;&amp; (length &gt;= 2)) {
	    if (strncmp(lowerCase, "on", (size_t) length) == 0) {
		newBool = 1;
	    } else if (strncmp(lowerCase, "off", (size_t) length) == 0) {
		newBool = 0;
	    } else {
		goto badBoolean;
	    }
	} else {
	    double dbl;
	    /*
	     * Boolean values can be extracted from ints or doubles.  Note
	     * that we don't use strtoul or strtoull here because we don't
	     * care about what the value is, just whether it is equal to
	     * zero or not.
	     */
#ifdef TCL_WIDE_INT_IS_LONG
	    newBool = strtol(string, &amp;end, 0);
	    if (end != string) {
		/*
		 * Make sure the string has no garbage after the end of
		 * the int.
		 */
		while ((end &lt; (string+length))
		       &amp;&amp; isspace(UCHAR(*end))) { /* INTL: ISO only */
		    end++;
		}
		if (end == (string+length)) {
		    newBool = (newBool != 0);
		    goto goodBoolean;
		}
	    }
#else /* !TCL_WIDE_INT_IS_LONG */
	    Tcl_WideInt wide = strtoll(string, &amp;end, 0);
	    if (end != string) {
		/*
		 * Make sure the string has no garbage after the end of
		 * the wide int.
		 */
		while ((end &lt; (string+length))
		       &amp;&amp; isspace(UCHAR(*end))) { /* INTL: ISO only */
		    end++;
		}
		if (end == (string+length)) {
		    newBool = (wide != Tcl_LongAsWide(0));
		    goto goodBoolean;
		}
	    }
#endif /* TCL_WIDE_INT_IS_LONG */
	    /*
	     * Still might be a string containing the characters representing an
	     * int or double that wasn't handled above. This would be a string
	     * like "27" or "1.0" that is non-zero and not "1". Such a string
	     * would result in the boolean value true. We try converting to
	     * double. If that succeeds and the resulting double is non-zero, we
	     * have a "true". Note that numbers can't have embedded NULLs.
	     */
	    
	    dbl = strtod(string, &amp;end);
	    if (end == string) {
		goto badBoolean;
	    }
	    
	    /*
	     * Make sure the string has no garbage after the end of the double.
	     */
	    
	    while ((end &lt; (string+length))
		   &amp;&amp; isspace(UCHAR(*end))) { /* INTL: ISO only */
		end++;
	    }
	    if (end != (string+length)) {
		goto badBoolean;
	    }
	    newBool = (dbl != 0.0);
	}
    }

    /*
     * Free the old internalRep before setting the new one. We do this as
     * late as possible to allow the conversion code, in particular
     * Tcl_GetStringFromObj, to use that old internalRep.
     */

    goodBoolean:
    if ((oldTypePtr != NULL) &amp;&amp;	(oldTypePtr-&gt;freeIntRepProc != NULL)) {
	oldTypePtr-&gt;freeIntRepProc(objPtr);
    }

    objPtr-&gt;internalRep.longValue = newBool;
    objPtr-&gt;typePtr = &amp;tclBooleanType;
    return TCL_OK;

    badBoolean:
    if (interp != NULL) {
	/*
	 * Must copy string before resetting the result in case a caller
	 * is trying to convert the interpreter's result to a boolean.
	 */
	
	char buf[100];
	sprintf(buf, "expected boolean value but got \"%.50s\"", string);
	Tcl_ResetResult(interp);
	Tcl_AppendToObj(Tcl_GetObjResult(interp), buf, -1);
    }
    return TCL_ERROR;
}
</t>
<t tx="ekr.20071105090148.307">
/*
 *----------------------------------------------------------------------
 *
 * UpdateStringOfBoolean --
 *
 *	Update the string representation for a boolean object.
 *	Note: This procedure does not free an existing old string rep
 *	so storage will be lost if this has not already been done. 
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's string is set to a valid string that results from
 *	the boolean-to-string conversion.
 *
 *----------------------------------------------------------------------
 */

static void
UpdateStringOfBoolean(objPtr)
    register Tcl_Obj *objPtr;	/* Int object whose string rep to update. */
{
    char *s = ckalloc((unsigned) 2);
    
    s[0] = (char) (objPtr-&gt;internalRep.longValue? '1' : '0');
    s[1] = '\0';
    objPtr-&gt;bytes = s;
    objPtr-&gt;length = 1;
}
</t>
<t tx="ekr.20071105090148.308">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_NewDoubleObj --
 *
 *	This procedure is normally called when not debugging: i.e., when
 *	TCL_MEM_DEBUG is not defined. It creates a new double object and
 *	initializes it from the argument double value.
 *
 *	When TCL_MEM_DEBUG is defined, this procedure just returns the
 *	result of calling the debugging version Tcl_DbNewDoubleObj.
 *
 * Results:
 *	The newly created object is returned. This object will have an
 *	invalid string representation. The returned object has ref count 0.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG
#undef Tcl_NewDoubleObj

Tcl_Obj *
Tcl_NewDoubleObj(dblValue)
    register double dblValue;	/* Double used to initialize the object. */
{
    return Tcl_DbNewDoubleObj(dblValue, "unknown", 0);
}
</t>
<t tx="ekr.20071105090148.309">
#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_NewDoubleObj(dblValue)
    register double dblValue;	/* Double used to initialize the object. */
{
    register Tcl_Obj *objPtr;

    TclNewObj(objPtr);
    objPtr-&gt;bytes = NULL;
    
    objPtr-&gt;internalRep.doubleValue = dblValue;
    objPtr-&gt;typePtr = &amp;tclDoubleType;
    return objPtr;
}
</t>
<t tx="ekr.20071105090148.310">#endif /* if TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_DbNewDoubleObj --
 *
 *	This procedure is normally called when debugging: i.e., when
 *	TCL_MEM_DEBUG is defined. It creates new double objects. It is the
 *	same as the Tcl_NewDoubleObj procedure above except that it calls
 *	Tcl_DbCkalloc directly with the file name and line number from its
 *	caller. This simplifies debugging since then the [memory active]
 *	command	will report the correct file name and line number when
 *	reporting objects that haven't been freed.
 *
 *	When TCL_MEM_DEBUG is not defined, this procedure just returns the
 *	result of calling Tcl_NewDoubleObj.
 *
 * Results:
 *	The newly created object is returned. This object will have an
 *	invalid string representation. The returned object has ref count 0.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG

Tcl_Obj *
Tcl_DbNewDoubleObj(dblValue, file, line)
    register double dblValue;	/* Double used to initialize the object. */
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
    register Tcl_Obj *objPtr;

    TclDbNewObj(objPtr, file, line);
    objPtr-&gt;bytes = NULL;
    
    objPtr-&gt;internalRep.doubleValue = dblValue;
    objPtr-&gt;typePtr = &amp;tclDoubleType;
    return objPtr;
}
</t>
<t tx="ekr.20071105090148.311">
#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_DbNewDoubleObj(dblValue, file, line)
    register double dblValue;	/* Double used to initialize the object. */
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
    return Tcl_NewDoubleObj(dblValue);
}
</t>
<t tx="ekr.20071105090148.312">#endif /* TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetDoubleObj --
 *
 *	Modify an object to be a double object and to have the specified
 *	double value.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's old string rep, if any, is freed. Also, any old
 *	internal rep is freed.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SetDoubleObj(objPtr, dblValue)
    register Tcl_Obj *objPtr;	/* Object whose internal rep to init. */
    register double dblValue;	/* Double used to set the object's value. */
{
    register Tcl_ObjType *oldTypePtr = objPtr-&gt;typePtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_SetDoubleObj called with shared object");
    }

    if ((oldTypePtr != NULL) &amp;&amp; (oldTypePtr-&gt;freeIntRepProc != NULL)) {
	oldTypePtr-&gt;freeIntRepProc(objPtr);
    }
    
    objPtr-&gt;internalRep.doubleValue = dblValue;
    objPtr-&gt;typePtr = &amp;tclDoubleType;
    Tcl_InvalidateStringRep(objPtr);
}
</t>
<t tx="ekr.20071105090148.313">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetDoubleFromObj --
 *
 *	Attempt to return a double from the Tcl object "objPtr". If the
 *	object is not already a double, an attempt will be made to convert
 *	it to one.
 *
 * Results:
 *	The return value is a standard Tcl object result. If an error occurs
 *	during conversion, an error message is left in the interpreter's
 *	result unless "interp" is NULL.
 *
 * Side effects:
 *	If the object is not already a double, the conversion will free
 *	any old internal representation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetDoubleFromObj(interp, objPtr, dblPtr)
    Tcl_Interp *interp; 	/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object from which to get a double. */
    register double *dblPtr;	/* Place to store resulting double. */
{
    register int result;
    
    if (objPtr-&gt;typePtr == &amp;tclDoubleType) {
	*dblPtr = objPtr-&gt;internalRep.doubleValue;
	return TCL_OK;
    }

    result = SetDoubleFromAny(interp, objPtr);
    if (result == TCL_OK) {
	*dblPtr = objPtr-&gt;internalRep.doubleValue;
    }
    return result;
}
</t>
<t tx="ekr.20071105090148.314">
/*
 *----------------------------------------------------------------------
 *
 * SetDoubleFromAny --
 *
 *	Attempt to generate an double-precision floating point internal form
 *	for the Tcl object "objPtr".
 *
 * Results:
 *	The return value is a standard Tcl object result. If an error occurs
 *	during conversion, an error message is left in the interpreter's
 *	result unless "interp" is NULL.
 *
 * Side effects:
 *	If no error occurs, a double is stored as "objPtr"s internal
 *	representation.
 *
 *----------------------------------------------------------------------
 */

static int
SetDoubleFromAny(interp, objPtr)
    Tcl_Interp *interp;		/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object to convert. */
{
    Tcl_ObjType *oldTypePtr = objPtr-&gt;typePtr;
    char *string, *end;
    double newDouble;
    int length;

    /*
     * Get the string representation. Make it up-to-date if necessary.
     */

    string = Tcl_GetStringFromObj(objPtr, &amp;length);

    /*
     * Now parse "objPtr"s string as an double. Numbers can't have embedded
     * NULLs. We use an implementation here that doesn't report errors in
     * interp if interp is NULL.
     */

    errno = 0;
    newDouble = strtod(string, &amp;end);
    if (end == string) {
	badDouble:
	if (interp != NULL) {
	    /*
	     * Must copy string before resetting the result in case a caller
	     * is trying to convert the interpreter's result to an int.
	     */
	    
	    char buf[100];
	    sprintf(buf, "expected floating-point number but got \"%.50s\"",
	            string);
	    Tcl_ResetResult(interp);
	    Tcl_AppendToObj(Tcl_GetObjResult(interp), buf, -1);
	}
	return TCL_ERROR;
    }
    if (errno != 0) {
	if (interp != NULL) {
	    TclExprFloatError(interp, newDouble);
	}
	return TCL_ERROR;
    }

    /*
     * Make sure that the string has no garbage after the end of the double.
     */
    
    while ((end &lt; (string+length))
	    &amp;&amp; isspace(UCHAR(*end))) { /* INTL: ISO space. */
	end++;
    }
    if (end != (string+length)) {
	goto badDouble;
    }
    
    /*
     * The conversion to double succeeded. Free the old internalRep before
     * setting the new one. We do this as late as possible to allow the
     * conversion code, in particular Tcl_GetStringFromObj, to use that old
     * internalRep.
     */
    
    if ((oldTypePtr != NULL) &amp;&amp;	(oldTypePtr-&gt;freeIntRepProc != NULL)) {
	oldTypePtr-&gt;freeIntRepProc(objPtr);
    }

    objPtr-&gt;internalRep.doubleValue = newDouble;
    objPtr-&gt;typePtr = &amp;tclDoubleType;
    return TCL_OK;
}
</t>
<t tx="ekr.20071105090148.315">
/*
 *----------------------------------------------------------------------
 *
 * UpdateStringOfDouble --
 *
 *	Update the string representation for a double-precision floating
 *	point object. This must obey the current tcl_precision value for
 *	double-to-string conversions. Note: This procedure does not free an
 *	existing old string rep so storage will be lost if this has not
 *	already been done.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's string is set to a valid string that results from
 *	the double-to-string conversion.
 *
 *----------------------------------------------------------------------
 */

static void
UpdateStringOfDouble(objPtr)
    register Tcl_Obj *objPtr;	/* Double obj with string rep to update. */
{
    char buffer[TCL_DOUBLE_SPACE];
    register int len;
    
    Tcl_PrintDouble((Tcl_Interp *) NULL, objPtr-&gt;internalRep.doubleValue,
	    buffer);
    len = strlen(buffer);
    
    objPtr-&gt;bytes = (char *) ckalloc((unsigned) len + 1);
    strcpy(objPtr-&gt;bytes, buffer);
    objPtr-&gt;length = len;
}
</t>
<t tx="ekr.20071105090148.316">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_NewIntObj --
 *
 *	If a client is compiled with TCL_MEM_DEBUG defined, calls to
 *	Tcl_NewIntObj to create a new integer object end up calling the
 *	debugging procedure Tcl_DbNewLongObj instead.
 *
 *	Otherwise, if the client is compiled without TCL_MEM_DEBUG defined,
 *	calls to Tcl_NewIntObj result in a call to one of the two
 *	Tcl_NewIntObj implementations below. We provide two implementations
 *	so that the Tcl core can be compiled to do memory debugging of the 
 *	core even if a client does not request it for itself.
 *
 *	Integer and long integer objects share the same "integer" type
 *	implementation. We store all integers as longs and Tcl_GetIntFromObj
 *	checks whether the current value of the long can be represented by
 *	an int.
 *
 * Results:
 *	The newly created object is returned. This object will have an
 *	invalid string representation. The returned object has ref count 0.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG
#undef Tcl_NewIntObj

Tcl_Obj *
Tcl_NewIntObj(intValue)
    register int intValue;	/* Int used to initialize the new object. */
{
    return Tcl_DbNewLongObj((long)intValue, "unknown", 0);
}
</t>
<t tx="ekr.20071105090148.317">
#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_NewIntObj(intValue)
    register int intValue;	/* Int used to initialize the new object. */
{
    register Tcl_Obj *objPtr;

    TclNewObj(objPtr);
    objPtr-&gt;bytes = NULL;
    
    objPtr-&gt;internalRep.longValue = (long)intValue;
    objPtr-&gt;typePtr = &amp;tclIntType;
    return objPtr;
}
</t>
<t tx="ekr.20071105090148.318">#endif /* if TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetIntObj --
 *
 *	Modify an object to be an integer and to have the specified integer
 *	value.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's old string rep, if any, is freed. Also, any old
 *	internal rep is freed. 
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SetIntObj(objPtr, intValue)
    register Tcl_Obj *objPtr;	/* Object whose internal rep to init. */
    register int intValue;	/* Integer used to set object's value. */
{
    register Tcl_ObjType *oldTypePtr = objPtr-&gt;typePtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_SetIntObj called with shared object");
    }
    
    if ((oldTypePtr != NULL) &amp;&amp; (oldTypePtr-&gt;freeIntRepProc != NULL)) {
	oldTypePtr-&gt;freeIntRepProc(objPtr);
    }
    
    objPtr-&gt;internalRep.longValue = (long) intValue;
    objPtr-&gt;typePtr = &amp;tclIntType;
    Tcl_InvalidateStringRep(objPtr);
}
</t>
<t tx="ekr.20071105090148.319">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetIntFromObj --
 *
 *	Attempt to return an int from the Tcl object "objPtr". If the object
 *	is not already an int, an attempt will be made to convert it to one.
 *
 *	Integer and long integer objects share the same "integer" type
 *	implementation. We store all integers as longs and Tcl_GetIntFromObj
 *	checks whether the current value of the long can be represented by
 *	an int.
 *
 * Results:
 *	The return value is a standard Tcl object result. If an error occurs
 *	during conversion or if the long integer held by the object
 *	can not be represented by an int, an error message is left in
 *	the interpreter's result unless "interp" is NULL.
 *
 * Side effects:
 *	If the object is not already an int, the conversion will free
 *	any old internal representation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetIntFromObj(interp, objPtr, intPtr)
    Tcl_Interp *interp; 	/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object from which to get a int. */
    register int *intPtr;	/* Place to store resulting int. */
{
    int result;
    Tcl_WideInt w = 0;

    /*
     * If the object isn't already an integer of any width, try to
     * convert it to one.
     */

    if (objPtr-&gt;typePtr != &amp;tclIntType &amp;&amp; objPtr-&gt;typePtr != &amp;tclWideIntType) {
	result = SetIntOrWideFromAny(interp, objPtr);
	if (result != TCL_OK) {
	    return result;
	}
    }

    /*
     * Object should now be either int or wide. Get its value.
     */

#ifndef TCL_WIDE_INT_IS_LONG
    if (objPtr-&gt;typePtr == &amp;tclWideIntType) {
	w = objPtr-&gt;internalRep.wideValue;
    } else
#endif
    {
	w = Tcl_LongAsWide(objPtr-&gt;internalRep.longValue);
    }

    if ((LLONG_MAX &gt; UINT_MAX)
	    &amp;&amp; ((w &gt; UINT_MAX) || (w &lt; -(Tcl_WideInt)UINT_MAX))) {
	if (interp != NULL) {
	    Tcl_SetObjResult(interp, Tcl_NewStringObj(
		"integer value too large to represent as non-long integer",
		-1));
	}
	return TCL_ERROR;
    }
    *intPtr = (int)w;
    return TCL_OK;
}
</t>
<t tx="ekr.20071105090148.320">
/*
 *----------------------------------------------------------------------
 *
 * SetIntFromAny --
 *
 *	Attempts to force the internal representation for a Tcl object
 *	to tclIntType, specifically.
 *
 * Results:
 *	The return value is a standard object Tcl result.  If an
 *	error occurs during conversion, an error message is left in
 *	the interpreter's result unless "interp" is NULL.
 *
 *----------------------------------------------------------------------
 */

static int
SetIntFromAny( Tcl_Interp* interp, 
				/* Tcl interpreter */
	       Tcl_Obj* objPtr )
				/* Pointer to the object to convert */
{
    int result;

    result = SetIntOrWideFromAny( interp, objPtr );
    if ( result != TCL_OK ) {
	return result;
    }
    if ( objPtr-&gt;typePtr != &amp;tclIntType ) {
	if ( interp != NULL ) {
	    char *s = "integer value too large to represent";
	    Tcl_ResetResult(interp);
	    Tcl_AppendToObj(Tcl_GetObjResult(interp), s, -1);
	    Tcl_SetErrorCode(interp, "ARITH", "IOVERFLOW", s, (char *) NULL);
	}
	return TCL_ERROR;
    }
    return TCL_OK;
}
</t>
<t tx="ekr.20071105090148.321">
/*
 *----------------------------------------------------------------------
 *
 * SetIntOrWideFromAny --
 *
 *	Attempt to generate an integer internal form for the Tcl object
 *	"objPtr".
 *
 * Results:
 *	The return value is a standard object Tcl result. If an error occurs
 *	during conversion, an error message is left in the interpreter's
 *	result unless "interp" is NULL.
 *
 * Side effects:
 *	If no error occurs, an int is stored as "objPtr"s internal
 *	representation. 
 *
 *----------------------------------------------------------------------
 */

static int
SetIntOrWideFromAny(interp, objPtr)
    Tcl_Interp *interp;		/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object to convert. */
{
    Tcl_ObjType *oldTypePtr = objPtr-&gt;typePtr;
    char *string, *end;
    int length;
    register char *p;
    unsigned long newLong;
    int isNegative = 0;
    int isWide = 0;

    /*
     * Get the string representation. Make it up-to-date if necessary.
     */

    p = string = Tcl_GetStringFromObj(objPtr, &amp;length);

    /*
     * Now parse "objPtr"s string as an int. We use an implementation here
     * that doesn't report errors in interp if interp is NULL. Note: use
     * strtoul instead of strtol for integer conversions to allow full-size
     * unsigned numbers, but don't depend on strtoul to handle sign
     * characters; it won't in some implementations.
     */

    errno = 0;
    for ( ;  isspace(UCHAR(*p));  p++) { /* INTL: ISO space. */
	/* Empty loop body. */
    }
    if (*p == '-') {
	p++;
	isNegative = 1;
    } else if (*p == '+') {
	p++;
    }
    if (!isdigit(UCHAR(*p))) {
	badInteger:
	if (interp != NULL) {
	    /*
	     * Must copy string before resetting the result in case a caller
	     * is trying to convert the interpreter's result to an int.
	     */
	    
	    char buf[100];
	    sprintf(buf, "expected integer but got \"%.50s\"", string);
	    Tcl_ResetResult(interp);
	    Tcl_AppendToObj(Tcl_GetObjResult(interp), buf, -1);
	    TclCheckBadOctal(interp, string);
	}
	return TCL_ERROR;
    }
    newLong = strtoul(p, &amp;end, 0);
    if (end == p) {
	goto badInteger;
    }
    if (errno == ERANGE) {
	if (interp != NULL) {
	    char *s = "integer value too large to represent";
	    Tcl_ResetResult(interp);
	    Tcl_AppendToObj(Tcl_GetObjResult(interp), s, -1);
	    Tcl_SetErrorCode(interp, "ARITH", "IOVERFLOW", s, (char *) NULL);
	}
	return TCL_ERROR;
    }

    /*
     * Make sure that the string has no garbage after the end of the int.
     */
    
    while ((end &lt; (string+length))
	    &amp;&amp; isspace(UCHAR(*end))) { /* INTL: ISO space. */
	end++;
    }
    if (end != (string+length)) {
	goto badInteger;
    }

    /*
     * If the resulting integer will exceed the range of a long,
     * put it into a wide instead.  (Tcl Bug #868489)
     */

#ifndef TCL_WIDE_INT_IS_LONG
    if ((isNegative &amp;&amp; newLong &gt; (unsigned long) (LONG_MAX) + 1)
	    || (!isNegative &amp;&amp; newLong &gt; LONG_MAX)) {
	isWide = 1;
    }
#endif

    /*
     * The conversion to int succeeded. Free the old internalRep before
     * setting the new one. We do this as late as possible to allow the
     * conversion code, in particular Tcl_GetStringFromObj, to use that old
     * internalRep.
     */

    if ((oldTypePtr != NULL) &amp;&amp;	(oldTypePtr-&gt;freeIntRepProc != NULL)) {
	oldTypePtr-&gt;freeIntRepProc(objPtr);
    }

    if (isWide) {
	objPtr-&gt;internalRep.wideValue =
		(isNegative ? -(Tcl_WideInt)newLong : (Tcl_WideInt)newLong);
	objPtr-&gt;typePtr = &amp;tclWideIntType;
    } else {
	objPtr-&gt;internalRep.longValue =
		(isNegative ? -(long)newLong : (long)newLong);
	objPtr-&gt;typePtr = &amp;tclIntType;
    }
    return TCL_OK;
}
</t>
<t tx="ekr.20071105090148.322">
/*
 *----------------------------------------------------------------------
 *
 * UpdateStringOfInt --
 *
 *	Update the string representation for an integer object.
 *	Note: This procedure does not free an existing old string rep
 *	so storage will be lost if this has not already been done. 
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's string is set to a valid string that results from
 *	the int-to-string conversion.
 *
 *----------------------------------------------------------------------
 */

static void
UpdateStringOfInt(objPtr)
    register Tcl_Obj *objPtr;	/* Int object whose string rep to update. */
{
    char buffer[TCL_INTEGER_SPACE];
    register int len;
    
    len = TclFormatInt(buffer, objPtr-&gt;internalRep.longValue);
    
    objPtr-&gt;bytes = ckalloc((unsigned) len + 1);
    strcpy(objPtr-&gt;bytes, buffer);
    objPtr-&gt;length = len;
}
</t>
<t tx="ekr.20071105090148.323">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_NewLongObj --
 *
 *	If a client is compiled with TCL_MEM_DEBUG defined, calls to
 *	Tcl_NewLongObj to create a new long integer object end up calling
 *	the debugging procedure Tcl_DbNewLongObj instead.
 *
 *	Otherwise, if the client is compiled without TCL_MEM_DEBUG defined,
 *	calls to Tcl_NewLongObj result in a call to one of the two
 *	Tcl_NewLongObj implementations below. We provide two implementations
 *	so that the Tcl core can be compiled to do memory debugging of the 
 *	core even if a client does not request it for itself.
 *
 *	Integer and long integer objects share the same "integer" type
 *	implementation. We store all integers as longs and Tcl_GetIntFromObj
 *	checks whether the current value of the long can be represented by
 *	an int.
 *
 * Results:
 *	The newly created object is returned. This object will have an
 *	invalid string representation. The returned object has ref count 0.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG
#undef Tcl_NewLongObj

Tcl_Obj *
Tcl_NewLongObj(longValue)
    register long longValue;	/* Long integer used to initialize the
				 * new object. */
{
    return Tcl_DbNewLongObj(longValue, "unknown", 0);
}
</t>
<t tx="ekr.20071105090148.324">
#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_NewLongObj(longValue)
    register long longValue;	/* Long integer used to initialize the
				 * new object. */
{
    register Tcl_Obj *objPtr;

    TclNewObj(objPtr);
    objPtr-&gt;bytes = NULL;
    
    objPtr-&gt;internalRep.longValue = longValue;
    objPtr-&gt;typePtr = &amp;tclIntType;
    return objPtr;
}
</t>
<t tx="ekr.20071105090148.325">#endif /* if TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_DbNewLongObj --
 *
 *	If a client is compiled with TCL_MEM_DEBUG defined, calls to
 *	Tcl_NewIntObj and Tcl_NewLongObj to create new integer or
 *	long integer objects end up calling the debugging procedure
 *	Tcl_DbNewLongObj instead. We provide two implementations of
 *	Tcl_DbNewLongObj so that whether the Tcl core is compiled to do
 *	memory debugging of the core is independent of whether a client
 *	requests debugging for itself.
 *
 *	When the core is compiled with TCL_MEM_DEBUG defined,
 *	Tcl_DbNewLongObj calls Tcl_DbCkalloc directly with the file name and
 *	line number from its caller. This simplifies debugging since then
 *	the [memory active] command will report the caller's file name and
 *	line number when reporting objects that haven't been freed.
 *
 *	Otherwise, when the core is compiled without TCL_MEM_DEBUG defined,
 *	this procedure just returns the result of calling Tcl_NewLongObj.
 *
 * Results:
 *	The newly created long integer object is returned. This object
 *	will have an invalid string representation. The returned object has
 *	ref count 0.
 *
 * Side effects:
 *	Allocates memory.
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG

Tcl_Obj *
Tcl_DbNewLongObj(longValue, file, line)
    register long longValue;	/* Long integer used to initialize the
				 * new object. */
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
    register Tcl_Obj *objPtr;

    TclDbNewObj(objPtr, file, line);
    objPtr-&gt;bytes = NULL;
    
    objPtr-&gt;internalRep.longValue = longValue;
    objPtr-&gt;typePtr = &amp;tclIntType;
    return objPtr;
}
</t>
<t tx="ekr.20071105090148.326">
#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_DbNewLongObj(longValue, file, line)
    register long longValue;	/* Long integer used to initialize the
				 * new object. */
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
    return Tcl_NewLongObj(longValue);
}
</t>
<t tx="ekr.20071105090148.327">#endif /* TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetLongObj --
 *
 *	Modify an object to be an integer object and to have the specified
 *	long integer value.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's old string rep, if any, is freed. Also, any old
 *	internal rep is freed. 
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SetLongObj(objPtr, longValue)
    register Tcl_Obj *objPtr;	/* Object whose internal rep to init. */
    register long longValue;	/* Long integer used to initialize the
				 * object's value. */
{
    register Tcl_ObjType *oldTypePtr = objPtr-&gt;typePtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_SetLongObj called with shared object");
    }

    if ((oldTypePtr != NULL) &amp;&amp; (oldTypePtr-&gt;freeIntRepProc != NULL)) {
	oldTypePtr-&gt;freeIntRepProc(objPtr);
    }
    
    objPtr-&gt;internalRep.longValue = longValue;
    objPtr-&gt;typePtr = &amp;tclIntType;
    Tcl_InvalidateStringRep(objPtr);
}
</t>
<t tx="ekr.20071105090148.328">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetLongFromObj --
 *
 *	Attempt to return an long integer from the Tcl object "objPtr". If
 *	the object is not already an int object, an attempt will be made to
 *	convert it to one.
 *
 * Results:
 *	The return value is a standard Tcl object result. If an error occurs
 *	during conversion, an error message is left in the interpreter's
 *	result unless "interp" is NULL.
 *
 * Side effects:
 *	If the object is not already an int object, the conversion will free
 *	any old internal representation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetLongFromObj(interp, objPtr, longPtr)
    Tcl_Interp *interp; 	/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object from which to get a long. */
    register long *longPtr;	/* Place to store resulting long. */
{
    register int result;
    
    if (objPtr-&gt;typePtr != &amp;tclIntType &amp;&amp; objPtr-&gt;typePtr != &amp;tclWideIntType) {
	result = SetIntOrWideFromAny(interp, objPtr);
	if (result != TCL_OK) {
	    return result;
	}
    }

#ifndef TCL_WIDE_INT_IS_LONG
    if (objPtr-&gt;typePtr == &amp;tclWideIntType) {
	/*
	 * If the object is already a wide integer, don't convert it.
	 * This code allows for any integer in the range -ULONG_MAX to
	 * ULONG_MAX to be converted to a long, ignoring overflow.
	 * The rule preserves existing semantics for conversion of
	 * integers on input, but avoids inadvertent demotion of
	 * wide integers to 32-bit ones in the internal rep.
	 */

	Tcl_WideInt w = objPtr-&gt;internalRep.wideValue;
	if (w &gt;= -(Tcl_WideInt)(ULONG_MAX) &amp;&amp; w &lt;= (Tcl_WideInt)(ULONG_MAX)) {
	    *longPtr = Tcl_WideAsLong(w);
	    return TCL_OK;
	} else {
	    if (interp != NULL) {
		Tcl_ResetResult(interp);
		Tcl_AppendToObj(Tcl_GetObjResult(interp),
			"integer value too large to represent", -1);
	    }
	    return TCL_ERROR;
	}
    }
#endif

    *longPtr = objPtr-&gt;internalRep.longValue;
    return TCL_OK;
}
</t>
<t tx="ekr.20071105090148.329">
/*
 *----------------------------------------------------------------------
 *
 * SetWideIntFromAny --
 *
 *	Attempt to generate an integer internal form for the Tcl object
 *	"objPtr".
 *
 * Results:
 *	The return value is a standard object Tcl result. If an error occurs
 *	during conversion, an error message is left in the interpreter's
 *	result unless "interp" is NULL.
 *
 * Side effects:
 *	If no error occurs, an int is stored as "objPtr"s internal
 *	representation. 
 *
 *----------------------------------------------------------------------
 */

static int
SetWideIntFromAny(interp, objPtr)
    Tcl_Interp *interp;		/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object to convert. */
{
#ifndef TCL_WIDE_INT_IS_LONG
    Tcl_ObjType *oldTypePtr = objPtr-&gt;typePtr;
    char *string, *end;
    int length;
    register char *p;
    Tcl_WideInt newWide;

    /*
     * Get the string representation. Make it up-to-date if necessary.
     */

    p = string = Tcl_GetStringFromObj(objPtr, &amp;length);

    /*
     * Now parse "objPtr"s string as an int. We use an implementation here
     * that doesn't report errors in interp if interp is NULL. Note: use
     * strtoull instead of strtoll for integer conversions to allow full-size
     * unsigned numbers, but don't depend on strtoull to handle sign
     * characters; it won't in some implementations.
     */

    errno = 0;
#ifdef TCL_STRTOUL_SIGN_CHECK
    for ( ;  isspace(UCHAR(*p));  p++) { /* INTL: ISO space. */
	/* Empty loop body. */
    }
    if (*p == '-') {
	p++;
	newWide = -((Tcl_WideInt)strtoull(p, &amp;end, 0));
    } else if (*p == '+') {
	p++;
	newWide = strtoull(p, &amp;end, 0);
    } else
#else
	newWide = strtoull(p, &amp;end, 0);
#endif
    if (end == p) {
	badInteger:
	if (interp != NULL) {
	    /*
	     * Must copy string before resetting the result in case a caller
	     * is trying to convert the interpreter's result to an int.
	     */
	    
	    char buf[100];
	    sprintf(buf, "expected integer but got \"%.50s\"", string);
	    Tcl_ResetResult(interp);
	    Tcl_AppendToObj(Tcl_GetObjResult(interp), buf, -1);
	    TclCheckBadOctal(interp, string);
	}
	return TCL_ERROR;
    }
    if (errno == ERANGE) {
	if (interp != NULL) {
	    char *s = "integer value too large to represent";
	    Tcl_ResetResult(interp);
	    Tcl_AppendToObj(Tcl_GetObjResult(interp), s, -1);
	    Tcl_SetErrorCode(interp, "ARITH", "IOVERFLOW", s, (char *) NULL);
	}
	return TCL_ERROR;
    }

    /*
     * Make sure that the string has no garbage after the end of the int.
     */
    
    while ((end &lt; (string+length))
	    &amp;&amp; isspace(UCHAR(*end))) { /* INTL: ISO space. */
	end++;
    }
    if (end != (string+length)) {
	goto badInteger;
    }

    /*
     * The conversion to int succeeded. Free the old internalRep before
     * setting the new one. We do this as late as possible to allow the
     * conversion code, in particular Tcl_GetStringFromObj, to use that old
     * internalRep.
     */

    if ((oldTypePtr != NULL) &amp;&amp;	(oldTypePtr-&gt;freeIntRepProc != NULL)) {
	oldTypePtr-&gt;freeIntRepProc(objPtr);
    }
    
    objPtr-&gt;internalRep.wideValue = newWide;
#else 
    if (TCL_ERROR == SetIntFromAny(interp, objPtr)) {
	return TCL_ERROR;
    }
#endif
    objPtr-&gt;typePtr = &amp;tclWideIntType;
    return TCL_OK;
}
</t>
<t tx="ekr.20071105090148.330">
/*
 *----------------------------------------------------------------------
 *
 * UpdateStringOfWideInt --
 *
 *	Update the string representation for a wide integer object.
 *	Note: This procedure does not free an existing old string rep
 *	so storage will be lost if this has not already been done. 
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's string is set to a valid string that results from
 *	the wideInt-to-string conversion.
 *
 *----------------------------------------------------------------------
 */

#ifndef TCL_WIDE_INT_IS_LONG
static void
UpdateStringOfWideInt(objPtr)
    register Tcl_Obj *objPtr;	/* Int object whose string rep to update. */
{
    char buffer[TCL_INTEGER_SPACE+2];
    register unsigned len;
    register Tcl_WideInt wideVal = objPtr-&gt;internalRep.wideValue;

    /*
     * Note that sprintf will generate a compiler warning under
     * Mingw claiming %I64 is an unknown format specifier.
     * Just ignore this warning. We can't use %L as the format
     * specifier since that gets printed as a 32 bit value.
     */
    sprintf(buffer, "%" TCL_LL_MODIFIER "d", wideVal);
    len = strlen(buffer);
    objPtr-&gt;bytes = ckalloc((unsigned) len + 1);
    memcpy(objPtr-&gt;bytes, buffer, len + 1);
    objPtr-&gt;length = len;
}
</t>
<t tx="ekr.20071105090148.331">#endif /* TCL_WIDE_INT_IS_LONG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_NewWideIntObj --
 *
 *	If a client is compiled with TCL_MEM_DEBUG defined, calls to
 *	Tcl_NewWideIntObj to create a new 64-bit integer object end up calling
 *	the debugging procedure Tcl_DbNewWideIntObj instead.
 *
 *	Otherwise, if the client is compiled without TCL_MEM_DEBUG defined,
 *	calls to Tcl_NewWideIntObj result in a call to one of the two
 *	Tcl_NewWideIntObj implementations below. We provide two implementations
 *	so that the Tcl core can be compiled to do memory debugging of the 
 *	core even if a client does not request it for itself.
 *
 * Results:
 *	The newly created object is returned. This object will have an
 *	invalid string representation. The returned object has ref count 0.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG
#undef Tcl_NewWideIntObj

Tcl_Obj *
Tcl_NewWideIntObj(wideValue)
    register Tcl_WideInt wideValue;	/* Wide integer used to initialize
					 * the new object. */
{
    return Tcl_DbNewWideIntObj(wideValue, "unknown", 0);
}
</t>
<t tx="ekr.20071105090148.332">
#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_NewWideIntObj(wideValue)
    register Tcl_WideInt wideValue;	/* Wide integer used to initialize
					 * the new object. */
{
    register Tcl_Obj *objPtr;

    TclNewObj(objPtr);
    objPtr-&gt;bytes = NULL;
    
    objPtr-&gt;internalRep.wideValue = wideValue;
    objPtr-&gt;typePtr = &amp;tclWideIntType;
    return objPtr;
}
</t>
<t tx="ekr.20071105090148.333">#endif /* if TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_DbNewWideIntObj --
 *
 *	If a client is compiled with TCL_MEM_DEBUG defined, calls to
 *	Tcl_NewWideIntObj to create new wide integer end up calling
 *	the debugging procedure Tcl_DbNewWideIntObj instead. We
 *	provide two implementations of Tcl_DbNewWideIntObj so that
 *	whether the Tcl core is compiled to do memory debugging of the
 *	core is independent of whether a client requests debugging for
 *	itself.
 *
 *	When the core is compiled with TCL_MEM_DEBUG defined,
 *	Tcl_DbNewWideIntObj calls Tcl_DbCkalloc directly with the file
 *	name and line number from its caller. This simplifies
 *	debugging since then the checkmem command will report the
 *	caller's file name and line number when reporting objects that
 *	haven't been freed.
 *
 *	Otherwise, when the core is compiled without TCL_MEM_DEBUG defined,
 *	this procedure just returns the result of calling Tcl_NewWideIntObj.
 *
 * Results:
 *	The newly created wide integer object is returned. This object
 *	will have an invalid string representation. The returned object has
 *	ref count 0.
 *
 * Side effects:
 *	Allocates memory.
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG

Tcl_Obj *
Tcl_DbNewWideIntObj(wideValue, file, line)
    register Tcl_WideInt wideValue;	/* Wide integer used to initialize
					 * the new object. */
    CONST char *file;			/* The name of the source file
					 * calling this procedure; used for
					 * debugging. */
    int line;				/* Line number in the source file;
					 * used for debugging. */
{
    register Tcl_Obj *objPtr;

    TclDbNewObj(objPtr, file, line);
    objPtr-&gt;bytes = NULL;
    
    objPtr-&gt;internalRep.wideValue = wideValue;
    objPtr-&gt;typePtr = &amp;tclWideIntType;
    return objPtr;
}
</t>
<t tx="ekr.20071105090148.334">
#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_DbNewWideIntObj(wideValue, file, line)
    register Tcl_WideInt wideValue;	/* Long integer used to initialize
					 * the new object. */
    CONST char *file;			/* The name of the source file
					 * calling this procedure; used for
					 * debugging. */
    int line;				/* Line number in the source file;
					 * used for debugging. */
{
    return Tcl_NewWideIntObj(wideValue);
}
</t>
<t tx="ekr.20071105090148.335">#endif /* TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetWideIntObj --
 *
 *	Modify an object to be a wide integer object and to have the
 *	specified wide integer value.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's old string rep, if any, is freed. Also, any old
 *	internal rep is freed. 
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SetWideIntObj(objPtr, wideValue)
    register Tcl_Obj *objPtr;		/* Object w. internal rep to init. */
    register Tcl_WideInt wideValue;	/* Wide integer used to initialize
					 * the object's value. */
{
    register Tcl_ObjType *oldTypePtr = objPtr-&gt;typePtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_SetWideIntObj called with shared object");
    }

    if ((oldTypePtr != NULL) &amp;&amp; (oldTypePtr-&gt;freeIntRepProc != NULL)) {
	oldTypePtr-&gt;freeIntRepProc(objPtr);
    }
    
    objPtr-&gt;internalRep.wideValue = wideValue;
    objPtr-&gt;typePtr = &amp;tclWideIntType;
    Tcl_InvalidateStringRep(objPtr);
}
</t>
<t tx="ekr.20071105090148.336">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetWideIntFromObj --
 *
 *	Attempt to return a wide integer from the Tcl object "objPtr". If
 *	the object is not already a wide int object, an attempt will be made
 *	to convert it to one.
 *
 * Results:
 *	The return value is a standard Tcl object result. If an error occurs
 *	during conversion, an error message is left in the interpreter's
 *	result unless "interp" is NULL.
 *
 * Side effects:
 *	If the object is not already an int object, the conversion will free
 *	any old internal representation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetWideIntFromObj(interp, objPtr, wideIntPtr)
    Tcl_Interp *interp; 	/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* Object from which to get a wide int. */
    register Tcl_WideInt *wideIntPtr; /* Place to store resulting long. */
{
    register int result;

    if (objPtr-&gt;typePtr == &amp;tclWideIntType) {
    gotWide:
	*wideIntPtr = objPtr-&gt;internalRep.wideValue;
	return TCL_OK;
    }
    if (objPtr-&gt;typePtr == &amp;tclIntType) {
	/*
	 * This cast is safe; all valid ints/longs are wides.
	 */

	objPtr-&gt;internalRep.wideValue =
		Tcl_LongAsWide(objPtr-&gt;internalRep.longValue);
	objPtr-&gt;typePtr = &amp;tclWideIntType;
	goto gotWide;
    }
    result = SetWideIntFromAny(interp, objPtr);
    if (result == TCL_OK) {
	*wideIntPtr = objPtr-&gt;internalRep.wideValue;
    }
    return result;
}
</t>
<t tx="ekr.20071105090148.337">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_DbIncrRefCount --
 *
 *	This procedure is normally called when debugging: i.e., when
 *	TCL_MEM_DEBUG is defined. This checks to see whether or not
 *	the memory has been freed before incrementing the ref count.
 *
 *	When TCL_MEM_DEBUG is not defined, this procedure just increments
 *	the reference count of the object.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's ref count is incremented.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_DbIncrRefCount(objPtr, file, line)
    register Tcl_Obj *objPtr;	/* The object we are registering a
				 * reference to. */
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
#ifdef TCL_MEM_DEBUG
    if (objPtr-&gt;refCount == 0x61616161) {
	fprintf(stderr, "file = %s, line = %d\n", file, line);
	fflush(stderr);
	panic("Trying to increment refCount of previously disposed object.");
    }
#endif
    ++(objPtr)-&gt;refCount;
}
</t>
<t tx="ekr.20071105090148.338">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_DbDecrRefCount --
 *
 *	This procedure is normally called when debugging: i.e., when
 *	TCL_MEM_DEBUG is defined. This checks to see whether or not
 *	the memory has been freed before decrementing the ref count.
 *
 *	When TCL_MEM_DEBUG is not defined, this procedure just decrements
 *	the reference count of the object.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's ref count is incremented.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_DbDecrRefCount(objPtr, file, line)
    register Tcl_Obj *objPtr;	/* The object we are releasing a reference
				 * to. */
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
#ifdef TCL_MEM_DEBUG
    if (objPtr-&gt;refCount == 0x61616161) {
	fprintf(stderr, "file = %s, line = %d\n", file, line);
	fflush(stderr);
	panic("Trying to decrement refCount of previously disposed object.");
    }
#endif
    if (--(objPtr)-&gt;refCount &lt;= 0) {
	TclFreeObj(objPtr);
    }
}
</t>
<t tx="ekr.20071105090148.339">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_DbIsShared --
 *
 *	This procedure is normally called when debugging: i.e., when
 *	TCL_MEM_DEBUG is defined. It tests whether the object has a ref
 *	count greater than one.
 *
 *	When TCL_MEM_DEBUG is not defined, this procedure just tests
 *	if the object has a ref count greater than one.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_DbIsShared(objPtr, file, line)
    register Tcl_Obj *objPtr;	/* The object to test for being shared. */
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
#ifdef TCL_MEM_DEBUG
    if (objPtr-&gt;refCount == 0x61616161) {
	fprintf(stderr, "file = %s, line = %d\n", file, line);
	fflush(stderr);
	panic("Trying to check whether previously disposed object is shared.");
    }
#endif
#ifdef TCL_COMPILE_STATS
    Tcl_MutexLock(&amp;tclObjMutex);
    if ((objPtr)-&gt;refCount &lt;= 1) {
	tclObjsShared[1]++;
    } else if ((objPtr)-&gt;refCount &lt; TCL_MAX_SHARED_OBJ_STATS) {
	tclObjsShared[(objPtr)-&gt;refCount]++;
    } else {
	tclObjsShared[0]++;
    }
    Tcl_MutexUnlock(&amp;tclObjMutex);
#endif
    return ((objPtr)-&gt;refCount &gt; 1);
}
</t>
<t tx="ekr.20071105090148.340">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_InitObjHashTable --
 *
 *	Given storage for a hash table, set up the fields to prepare
 *	the hash table for use, the keys are Tcl_Obj *.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	TablePtr is now ready to be passed to Tcl_FindHashEntry and
 *	Tcl_CreateHashEntry.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_InitObjHashTable(tablePtr)
    register Tcl_HashTable *tablePtr;	/* Pointer to table record, which
					 * is supplied by the caller. */
{
    Tcl_InitCustomHashTable(tablePtr, TCL_CUSTOM_PTR_KEYS,
	    &amp;tclObjHashKeyType);
}
</t>
<t tx="ekr.20071105090148.341">
/*
 *----------------------------------------------------------------------
 *
 * AllocObjEntry --
 *
 *	Allocate space for a Tcl_HashEntry containing the Tcl_Obj * key.
 *
 * Results:
 *	The return value is a pointer to the created entry.
 *
 * Side effects:
 *	Increments the reference count on the object.
 *
 *----------------------------------------------------------------------
 */

static Tcl_HashEntry *
AllocObjEntry(tablePtr, keyPtr)
    Tcl_HashTable *tablePtr;	/* Hash table. */
    VOID *keyPtr;		/* Key to store in the hash table entry. */
{
    Tcl_Obj *objPtr = (Tcl_Obj *) keyPtr;
    Tcl_HashEntry *hPtr;

    hPtr = (Tcl_HashEntry *) ckalloc((unsigned) (sizeof(Tcl_HashEntry)));
    hPtr-&gt;key.oneWordValue = (char *) objPtr;
    Tcl_IncrRefCount (objPtr);

    return hPtr;
}
</t>
<t tx="ekr.20071105090148.342">
/*
 *----------------------------------------------------------------------
 *
 * CompareObjKeys --
 *
 *	Compares two Tcl_Obj * keys.
 *
 * Results:
 *	The return value is 0 if they are different and 1 if they are
 *	the same.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
CompareObjKeys(keyPtr, hPtr)
    VOID *keyPtr;		/* New key to compare. */
    Tcl_HashEntry *hPtr;		/* Existing key to compare. */
{
    Tcl_Obj *objPtr1 = (Tcl_Obj *) keyPtr;
    Tcl_Obj *objPtr2 = (Tcl_Obj *) hPtr-&gt;key.oneWordValue;
    register CONST char *p1, *p2;
    register int l1, l2;

    /*
     * If the object pointers are the same then they match.
     */
    if (objPtr1 == objPtr2) {
	return 1;
    }

    /*
     * Don't use Tcl_GetStringFromObj as it would prevent l1 and l2 being
     * in a register.
     */
    p1 = TclGetString(objPtr1);
    l1 = objPtr1-&gt;length;
    p2 = TclGetString(objPtr2);
    l2 = objPtr2-&gt;length;
    
    /*
     * Only compare if the string representations are of the same length.
     */
    if (l1 == l2) {
	for (;; p1++, p2++, l1--) {
	    if (*p1 != *p2) {
		break;
	    }
	    if (l1 == 0) {
		return 1;
	    }
	}
    }

    return 0;
}
</t>
<t tx="ekr.20071105090148.343">
/*
 *----------------------------------------------------------------------
 *
 * FreeObjEntry --
 *
 *	Frees space for a Tcl_HashEntry containing the Tcl_Obj * key.
 *
 * Results:
 *	The return value is a pointer to the created entry.
 *
 * Side effects:
 *	Decrements the reference count of the object.
 *
 *----------------------------------------------------------------------
 */

static void
FreeObjEntry(hPtr)
    Tcl_HashEntry *hPtr;	/* Hash entry to free. */
{
    Tcl_Obj *objPtr = (Tcl_Obj *) hPtr-&gt;key.oneWordValue;

    Tcl_DecrRefCount (objPtr);
    ckfree ((char *) hPtr);
}
</t>
<t tx="ekr.20071105090148.344">
/*
 *----------------------------------------------------------------------
 *
 * HashObjKey --
 *
 *	Compute a one-word summary of the string representation of the
 *	Tcl_Obj, which can be used to generate a hash index.
 *
 * Results:
 *	The return value is a one-word summary of the information in
 *	the string representation of the Tcl_Obj.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static unsigned int
HashObjKey(tablePtr, keyPtr)
    Tcl_HashTable *tablePtr;	/* Hash table. */
    VOID *keyPtr;		/* Key from which to compute hash value. */
{
    Tcl_Obj *objPtr = (Tcl_Obj *) keyPtr;
    CONST char *string = TclGetString(objPtr);
    int length = objPtr-&gt;length;
    unsigned int result;
    int i;

    /*
     * I tried a zillion different hash functions and asked many other
     * people for advice.  Many people had their own favorite functions,
     * all different, but no-one had much idea why they were good ones.
     * I chose the one below (multiply by 9 and add new character)
     * because of the following reasons:
     *
     * 1. Multiplying by 10 is perfect for keys that are decimal strings,
     *    and multiplying by 9 is just about as good.
     * 2. Times-9 is (shift-left-3) plus (old).  This means that each
     *    character's bits hang around in the low-order bits of the
     *    hash value for ever, plus they spread fairly rapidly up to
     *    the high-order bits to fill out the hash value.  This seems
     *    works well both for decimal and non-decimal strings.
     */

    result = 0;
    for (i=0 ; i&lt;length ; i++) {
	result += (result&lt;&lt;3) + string[i];
    }
    return result;
}
</t>
<t tx="ekr.20071105090148.345">
/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetCommandFromObj --
 *
 *      Returns the command specified by the name in a Tcl_Obj.
 *
 * Results:
 *	Returns a token for the command if it is found. Otherwise, if it
 *	can't be found or there is an error, returns NULL.
 *
 * Side effects:
 *      May update the internal representation for the object, caching
 *      the command reference so that the next time this procedure is
 *	called with the same object, the command can be found quickly.
 *
 *----------------------------------------------------------------------
 */

Tcl_Command
Tcl_GetCommandFromObj(interp, objPtr)
    Tcl_Interp *interp;		/* The interpreter in which to resolve the
				 * command and to report errors. */
    register Tcl_Obj *objPtr;	/* The object containing the command's
				 * name. If the name starts with "::", will
				 * be looked up in global namespace. Else,
				 * looked up first in the current namespace,
				 * then in global namespace. */
{
    Interp *iPtr = (Interp *) interp;
    register ResolvedCmdName *resPtr;
    register Command *cmdPtr;
    Namespace *currNsPtr;
    int result;
    CallFrame *savedFramePtr;
    char *name;

    /*
     * If the variable name is fully qualified, do as if the lookup were
     * done from the global namespace; this helps avoid repeated lookups 
     * of fully qualified names. It costs close to nothing, and may be very
     * helpful for OO applications which pass along a command name ("this"),
     * [Patch 456668]
     */

    savedFramePtr = iPtr-&gt;varFramePtr;
    name = Tcl_GetString(objPtr);
    if ((*name++ == ':') &amp;&amp; (*name == ':')) {
	iPtr-&gt;varFramePtr = NULL;
    }

    /*
     * Get the internal representation, converting to a command type if
     * needed. The internal representation is a ResolvedCmdName that points
     * to the actual command.
     */
    
    if (objPtr-&gt;typePtr != &amp;tclCmdNameType) {
        result = tclCmdNameType.setFromAnyProc(interp, objPtr);
        if (result != TCL_OK) {
	    iPtr-&gt;varFramePtr = savedFramePtr;
            return (Tcl_Command) NULL;
        }
    }
    resPtr = (ResolvedCmdName *) objPtr-&gt;internalRep.twoPtrValue.ptr1;

    /*
     * Get the current namespace.
     */
    
    if (iPtr-&gt;varFramePtr != NULL) {
	currNsPtr = iPtr-&gt;varFramePtr-&gt;nsPtr;
    } else {
	currNsPtr = iPtr-&gt;globalNsPtr;
    }

    /*
     * Check the context namespace and the namespace epoch of the resolved
     * symbol to make sure that it is fresh. If not, then force another
     * conversion to the command type, to discard the old rep and create a
     * new one. Note that we verify that the namespace id of the context
     * namespace is the same as the one we cached; this insures that the
     * namespace wasn't deleted and a new one created at the same address
     * with the same command epoch.
     */
    
    cmdPtr = NULL;
    if ((resPtr != NULL)
	    &amp;&amp; (resPtr-&gt;refNsPtr == currNsPtr)
	    &amp;&amp; (resPtr-&gt;refNsId == currNsPtr-&gt;nsId)
	    &amp;&amp; (resPtr-&gt;refNsCmdEpoch == currNsPtr-&gt;cmdRefEpoch)) {
        cmdPtr = resPtr-&gt;cmdPtr;
        if (cmdPtr-&gt;cmdEpoch != resPtr-&gt;cmdEpoch) {
            cmdPtr = NULL;
        }
    }

    if (cmdPtr == NULL) {
        result = tclCmdNameType.setFromAnyProc(interp, objPtr);
        if (result != TCL_OK) {
	    iPtr-&gt;varFramePtr = savedFramePtr;
            return (Tcl_Command) NULL;
        }
        resPtr = (ResolvedCmdName *) objPtr-&gt;internalRep.twoPtrValue.ptr1;
        if (resPtr != NULL) {
            cmdPtr = resPtr-&gt;cmdPtr;
        }
    }
    iPtr-&gt;varFramePtr = savedFramePtr;
    return (Tcl_Command) cmdPtr;
}
</t>
<t tx="ekr.20071105090148.346">
/*
 *----------------------------------------------------------------------
 *
 * TclSetCmdNameObj --
 *
 *	Modify an object to be an CmdName object that refers to the argument
 *	Command structure.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's old internal rep is freed. It's string rep is not
 *	changed. The refcount in the Command structure is incremented to
 *	keep it from being freed if the command is later deleted until
 *	TclExecuteByteCode has a chance to recognize that it was deleted.
 *
 *----------------------------------------------------------------------
 */

void
TclSetCmdNameObj(interp, objPtr, cmdPtr)
    Tcl_Interp *interp;		/* Points to interpreter containing command
				 * that should be cached in objPtr. */
    register Tcl_Obj *objPtr;	/* Points to Tcl object to be changed to
				 * a CmdName object. */
    Command *cmdPtr;		/* Points to Command structure that the
				 * CmdName object should refer to. */
{
    Interp *iPtr = (Interp *) interp;
    register ResolvedCmdName *resPtr;
    Tcl_ObjType *oldTypePtr = objPtr-&gt;typePtr;
    register Namespace *currNsPtr;

    if (oldTypePtr == &amp;tclCmdNameType) {
	return;
    }
    
    /*
     * Get the current namespace.
     */
    
    if (iPtr-&gt;varFramePtr != NULL) {
	currNsPtr = iPtr-&gt;varFramePtr-&gt;nsPtr;
    } else {
	currNsPtr = iPtr-&gt;globalNsPtr;
    }
    
    cmdPtr-&gt;refCount++;
    resPtr = (ResolvedCmdName *) ckalloc(sizeof(ResolvedCmdName));
    resPtr-&gt;cmdPtr = cmdPtr;
    resPtr-&gt;refNsPtr = currNsPtr;
    resPtr-&gt;refNsId  = currNsPtr-&gt;nsId;
    resPtr-&gt;refNsCmdEpoch = currNsPtr-&gt;cmdRefEpoch;
    resPtr-&gt;cmdEpoch = cmdPtr-&gt;cmdEpoch;
    resPtr-&gt;refCount = 1;
    
    if ((oldTypePtr != NULL) &amp;&amp; (oldTypePtr-&gt;freeIntRepProc != NULL)) {
	oldTypePtr-&gt;freeIntRepProc(objPtr);
    }
    objPtr-&gt;internalRep.twoPtrValue.ptr1 = (VOID *) resPtr;
    objPtr-&gt;internalRep.twoPtrValue.ptr2 = NULL;
    objPtr-&gt;typePtr = &amp;tclCmdNameType;
}
</t>
<t tx="ekr.20071105090148.347">
/*
 *----------------------------------------------------------------------
 *
 * FreeCmdNameInternalRep --
 *
 *	Frees the resources associated with a cmdName object's internal
 *	representation.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Decrements the ref count of any cached ResolvedCmdName structure
 *	pointed to by the cmdName's internal representation. If this is 
 *	the last use of the ResolvedCmdName, it is freed. This in turn
 *	decrements the ref count of the Command structure pointed to by 
 *	the ResolvedSymbol, which may free the Command structure.
 *
 *----------------------------------------------------------------------
 */

static void
FreeCmdNameInternalRep(objPtr)
    register Tcl_Obj *objPtr;	/* CmdName object with internal
				 * representation to free. */
{
    register ResolvedCmdName *resPtr =
	(ResolvedCmdName *) objPtr-&gt;internalRep.twoPtrValue.ptr1;

    if (resPtr != NULL) {
	/*
	 * Decrement the reference count of the ResolvedCmdName structure.
	 * If there are no more uses, free the ResolvedCmdName structure.
	 */
    
        resPtr-&gt;refCount--;
        if (resPtr-&gt;refCount == 0) {
            /*
	     * Now free the cached command, unless it is still in its
             * hash table or if there are other references to it
             * from other cmdName objects.
	     */
	    
            Command *cmdPtr = resPtr-&gt;cmdPtr;
            TclCleanupCommand(cmdPtr);
            ckfree((char *) resPtr);
        }
    }
}
</t>
<t tx="ekr.20071105090148.348">
/*
 *----------------------------------------------------------------------
 *
 * DupCmdNameInternalRep --
 *
 *	Initialize the internal representation of an cmdName Tcl_Obj to a
 *	copy of the internal representation of an existing cmdName object. 
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	"copyPtr"s internal rep is set to point to the ResolvedCmdName
 *	structure corresponding to "srcPtr"s internal rep. Increments the
 *	ref count of the ResolvedCmdName structure pointed to by the
 *	cmdName's internal representation.
 *
 *----------------------------------------------------------------------
 */

static void
DupCmdNameInternalRep(srcPtr, copyPtr)
    Tcl_Obj *srcPtr;		/* Object with internal rep to copy. */
    register Tcl_Obj *copyPtr;	/* Object with internal rep to set. */
{
    register ResolvedCmdName *resPtr =
        (ResolvedCmdName *) srcPtr-&gt;internalRep.twoPtrValue.ptr1;

    copyPtr-&gt;internalRep.twoPtrValue.ptr1 = (VOID *) resPtr;
    copyPtr-&gt;internalRep.twoPtrValue.ptr2 = NULL;
    if (resPtr != NULL) {
        resPtr-&gt;refCount++;
    }
    copyPtr-&gt;typePtr = &amp;tclCmdNameType;
}
</t>
<t tx="ekr.20071105090148.349">
/*
 *----------------------------------------------------------------------
 *
 * SetCmdNameFromAny --
 *
 *	Generate an cmdName internal form for the Tcl object "objPtr".
 *
 * Results:
 *	The return value is a standard Tcl result. The conversion always
 *	succeeds and TCL_OK is returned.
 *
 * Side effects:
 *	A pointer to a ResolvedCmdName structure that holds a cached pointer
 *	to the command with a name that matches objPtr's string rep is
 *	stored as objPtr's internal representation. This ResolvedCmdName
 *	pointer will be NULL if no matching command was found. The ref count
 *	of the cached Command's structure (if any) is also incremented.
 *
 *----------------------------------------------------------------------
 */

static int
SetCmdNameFromAny(interp, objPtr)
    Tcl_Interp *interp;		/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object to convert. */
{
    Interp *iPtr = (Interp *) interp;
    char *name;
    Tcl_Command cmd;
    register Command *cmdPtr;
    Namespace *currNsPtr;
    register ResolvedCmdName *resPtr;

    /*
     * Get "objPtr"s string representation. Make it up-to-date if necessary.
     */

    name = objPtr-&gt;bytes;
    if (name == NULL) {
	name = Tcl_GetString(objPtr);
    }

    /*
     * Find the Command structure, if any, that describes the command called
     * "name". Build a ResolvedCmdName that holds a cached pointer to this
     * Command, and bump the reference count in the referenced Command
     * structure. A Command structure will not be deleted as long as it is
     * referenced from a CmdName object.
     */

    cmd = Tcl_FindCommand(interp, name, (Tcl_Namespace *) NULL,
	    /*flags*/ 0);
    cmdPtr = (Command *) cmd;
    if (cmdPtr != NULL) {
	/*
	 * Get the current namespace.
	 */
	
	if (iPtr-&gt;varFramePtr != NULL) {
	    currNsPtr = iPtr-&gt;varFramePtr-&gt;nsPtr;
	} else {
	    currNsPtr = iPtr-&gt;globalNsPtr;
	}
	
	cmdPtr-&gt;refCount++;
        resPtr = (ResolvedCmdName *) ckalloc(sizeof(ResolvedCmdName));
        resPtr-&gt;cmdPtr        = cmdPtr;
        resPtr-&gt;refNsPtr      = currNsPtr;
        resPtr-&gt;refNsId       = currNsPtr-&gt;nsId;
        resPtr-&gt;refNsCmdEpoch = currNsPtr-&gt;cmdRefEpoch;
        resPtr-&gt;cmdEpoch      = cmdPtr-&gt;cmdEpoch;
        resPtr-&gt;refCount      = 1;
    } else {
	resPtr = NULL;	/* no command named "name" was found */
    }

    /*
     * Free the old internalRep before setting the new one. We do this as
     * late as possible to allow the conversion code, in particular
     * GetStringFromObj, to use that old internalRep. If no Command
     * structure was found, leave NULL as the cached value.
     */

    if ((objPtr-&gt;typePtr != NULL)
	    &amp;&amp; (objPtr-&gt;typePtr-&gt;freeIntRepProc != NULL)) {
	objPtr-&gt;typePtr-&gt;freeIntRepProc(objPtr);
    }
    
    objPtr-&gt;internalRep.twoPtrValue.ptr1 = (VOID *) resPtr;
    objPtr-&gt;internalRep.twoPtrValue.ptr2 = NULL;
    objPtr-&gt;typePtr = &amp;tclCmdNameType;
    return TCL_OK;
}
</t>
<t tx="ekr.20071105090148.350">@nocolor
# -*- coding: utf-8 -*-
#@+leo-ver=4-thin
#@+node:ekr.20031218072017.2608:@thin leoApp.py
#@@first

#@@language python
#@@tabwidth -4
#@@pagewidth 80

import leoGlobals as g
import os
import sys

class LeoApp:

    """A class representing the Leo application itself.

    Ivars of this class are Leo's global variables."""

    #@    @+others
    #@+node:ekr.20031218072017.1416:app.__init__
    def __init__(self):

        # These ivars are the global vars of this program.
        self.afterHandler = None
        self.batchMode = False # True: run in batch mode.
        self.commandName = None # The name of the command being executed.
        self.config = None # The leoConfig instance.
        self.count = 0 # General purpose debugging count.
        self.debug = False # True: enable extra debugging tests (not used at present).
            # WARNING: this could greatly slow things down.
        self.debugSwitch = 0
            # 0: default behavior
            # 1: full traces in g.es_exception.
            # 2: call pdb.set_trace in g.es_exception, etc.
        self.disableSave = False
        self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
        self.globalOpenDir = None # The directory last used to open a file.
        self.gui = None # The gui class.
        self.hasOpenWithMenu = False # True: open with plugin has been loaded.
        self.hookError = False # True: suppress further calls to hooks.
        self.hookFunction = None # Application wide hook function.
        self.homeDir = None # The user's home directory.
        self.idle_imported = False # True: we have done an import idle
        self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
        self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
        self.initing = True # True: we are initiing the app.
        self.killed = False # True: we are about to destroy the root window.
        self.leoID = None # The id part of gnx's.
        self.loadDir = None # The directory from which Leo was loaded.
        self.loadedPlugins = [] # List of loaded plugins that have signed on.
        self.log = None # The LeoFrame containing the present log.
        self.logIsLocked = False # True: no changes to log are allowed.
        self.logWaiting = [] # List of messages waiting to go to a log.
        self.menuWarningsGiven = False # True: supress warnings in menu code.
        self.nodeIndices = None # Singleton node indices instance.
        self.numberOfWindows = 0 # Number of opened windows.
        self.openWithFiles = [] # List of data used by Open With command.
        self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
        self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
        self.positions = 0 # Count of the number of positions generated.
        self.quitting = False # True if quitting.  Locks out some events.
        self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
        self.root = None # The hidden main window. Set later.
        self.searchDict = {} # For communication between find/change scripts.
        self.scanErrors = 0 # The number of errors seen by g.scanError.
        self.scriptDict = {} # For communication between Execute Script command and scripts.
        self.silentMode = False # True if signon is more silent.
        self.statsDict = {} # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
        self.trace = False # True: enable debugging traces.
        self.trace_gc = False # defined in run()
        self.trace_gc_calls = False # defined in run()
        self.trace_gc_verbose = False # defined in run()
        self.trace_gc_inited = False
        self.tracePositions = False
        self.trace_list = [] # "Sherlock" argument list for tracing().
        self.tkEncoding = "utf-8"
        self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
        self.unitTestDict = {} # For communication between unit tests and code.
        self.unitTesting = False # True if unit testing.
        self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
        self.user_xresources_path = None # Resource file for Tk/tcl.
        self.windowList = [] # Global list of all frames.  Does not include hidden root window.

        # Global panels.  Destroyed when Leo ends.
        self.pythonFrame = None

        #@    &lt;&lt; Define global constants &gt;&gt;
        #@+node:ekr.20031218072017.1417:&lt;&lt; define global constants &gt;&gt;
        self.prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

        # New in leo.py 3.0
        self.prolog_prefix_string = "&lt;?xml version=\"1.0\" encoding="
        self.prolog_postfix_string = "?&gt;"

        # leo.py 3.11
        self.use_unicode = True # True: use new unicode logic.
        #@-node:ekr.20031218072017.1417:&lt;&lt; define global constants &gt;&gt;
        #@nl
        #@    &lt;&lt; Define global data structures &gt;&gt;
        #@+node:ekr.20031218072017.368:&lt;&lt; define global data structures &gt;&gt; app
        # Internally, lower case is used for all language names.
        self.language_delims_dict = {
            "ada" : "--",
            "actionscript" : "// /* */", #jason 2003-07-03
            "c" : "// /* */", # C, C++ or objective C.
            "csharp" : "// /* */", # C#
            "cpp" : "// /* */",# C++.
            "css" : "/* */", # 4/1/04
            "cweb" : "@q@ @&gt;", # Use the "cweb hack"
            "elisp" : ";",
            "forth" : "\\_ _(_ _)", # Use the "REM hack"
            "fortran" : "C",
            "fortran90" : "!",
            "html" : "&lt;!-- --&gt;",
            "java" : "// /* */",
            "latex" : "%",
            "lua" : "--",  # ddm 13/02/06
            "pascal" : "// { }",
            "perl" : "#",
            "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
            "php" : "// /* */", # 6/23/07: was "//",
            "plain" : "#", # We must pick something.
            "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
            "python" : "#",
            "rapidq" : "'", # fil 2004-march-11
            "rebol" : ";",  # jason 2003-07-03
            "shell" : "#",  # shell scripts
            "tcltk" : "#",
            "unknown" : "#" } # Set when @comment is seen.

        self.language_extension_dict = {
            "ada" : "ads",
            "actionscript" : "as", #jason 2003-07-03
            "c" : "c",
            "cpp" : "cpp",
            "css" : "css", # 4/1/04
            "cweb" : "w",
            "elisp" : "el",
            "forth" : "forth",
            "fortran" : "f",
            "fortran90" : "f",
            "html" : "html",
            "java" : "java",
            "latex" : "tex", # 1/8/04
            "lua" : "lua",  # ddm 13/02/06
            "noweb" : "nw",
            "pascal" : "p",
            # "perl" : "perl",
            # "perlpod" : "perl",
            "perl" : "pl",      # 11/7/05
            "perlpod" : "pod",  # 11/7/05
            "php" : "php",
            "plain" : "txt",
            "python" : "py",
            "plsql" : "sql", # qt02537 2005-05-27
            "rapidq" : "bas", # fil 2004-march-11
            "rebol" : "r",    # jason 2003-07-03
            "shell" : "sh",   # DS 4/1/04
            "tex" : "tex",
            "tcltk" : "tcl",
            "unknown" : "txt" } # Set when @comment is seen.

        self.extension_dict = {
            "ads"   : "ada",
            "adb"   : "ada",
            "as"    : "actionscript",
            "bas"   : "rapidq",
            "c"     : "c",
            "cpp"   : "cpp",
            "css"   : "css",
            "el"    : "elisp",
            "forth" : "forth",
            "f"     : "fortran90", # or fortran ?
            "html"  : "html",
            "java"  : "java",
            "lua" : "lua",  # ddm 13/02/06
            "noweb" : "nw",
            "p"     : "pascal",
            # "perl"  : "perl",
            "pl"    : "perl",   # 11/7/05
            "pod"   : "perlpod", # 11/7/05
            "php"   : "php",
            "py"    : "python",
            "sql"   : "plsql", # qt02537 2005-05-27
            "r"     : "rebol",
            "sh"    : "shell",
            "tex"   : "tex",
            "txt"   : "plain",
            "tcl"   : "tcltk",
            "w"     : "cweb" }
        #@-node:ekr.20031218072017.368:&lt;&lt; define global data structures &gt;&gt; app
        #@nl
    #@-node:ekr.20031218072017.1416:app.__init__
    #@+node:ekr.20031218072017.2609:app.closeLeoWindow
    def closeLeoWindow (self,frame):

        """Attempt to close a Leo window.

        Return False if the user veto's the close."""

        c = frame.c

        if c.promptingForClose:
            # There is already a dialog open asking what to do.
            return False

        g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

        if c.changed:
            c.promptingForClose = True
            veto = frame.promptForSave()
            c.promptingForClose = False
            if veto: return False

        g.app.setLog(None) # no log until we reactive a window.

        g.doHook("close-frame",c=c) # This may remove frame from the window list.

        if frame in g.app.windowList:
            g.app.destroyWindow(frame)

        if g.app.windowList:
            # Pick a window to activate so we can set the log.
            frame = g.app.windowList[0]
            frame.deiconify()
            frame.lift()
            frame.c.setLog()
            frame.c.bodyWantsFocusNow()
        elif not g.app.unitTesting:
            g.app.finishQuit()

        return True # The window has been closed.
    #@-node:ekr.20031218072017.2609:app.closeLeoWindow
    #@+node:ekr.20031218072017.2610:app.createTkGui
    def createTkGui (self,fileName=None):

        # Do NOT omit fileName param: it is used in plugin code.
        __pychecker__ = '--no-argsused'

        """A convenience routines for plugins to create the default Tk gui class."""

        import leoTkinterGui # Do this import after app module is fully imported.

        g.app.gui = leoTkinterGui.tkinterGui()
        g.app.root = g.app.gui.createRootWindow()

        # Show a dialog and exit immediately if Pmw can not be imported.
        g.importExtension("Pmw",pluginName="Leo's core",verbose=False,required=True)
        g.app.gui.finishCreate()

        if 0:
            if fileName:
                print "Tk gui created in", g.shortFileName(fileName)
    #@-node:ekr.20031218072017.2610:app.createTkGui
    #@+node:ekr.20031218072017.2612:app.destroyAllOpenWithFiles
    def destroyAllOpenWithFiles (self):

        """Try to remove temp files created with the Open With command.

        This may fail if the files are still open."""

        # We can't use g.es here because the log stream no longer exists.

        for theDict in self.openWithFiles[:]: # 7/10/03.
            g.app.destroyOpenWithFileWithDict(theDict)

        # Delete the list so the gc can recycle Leo windows!
        g.app.openWithFiles = []
    #@-node:ekr.20031218072017.2612:app.destroyAllOpenWithFiles
    #@+node:ekr.20031218072017.2613:app.destroyOpenWithFilesForFrame
    def destroyOpenWithFilesForFrame (self,frame):

        """Close all "Open With" files associated with frame"""

        # Make a copy of the list: it may change in the loop.
        openWithFiles = g.app.openWithFiles

        for theDict in openWithFiles[:]: # 6/30/03
            c = theDict.get("c")
            if c.frame == frame:
                g.app.destroyOpenWithFileWithDict(theDict)
    #@-node:ekr.20031218072017.2613:app.destroyOpenWithFilesForFrame
    #@+node:ekr.20031218072017.2614:app.destroyOpenWithFileWithDict
    def destroyOpenWithFileWithDict (self,theDict):

        path = theDict.get("path")
        if path and g.os_path_exists(path):
            try:
                os.remove(path)
                print "deleting temp file:", g.shortFileName(path)
            except:
                print "can not delete temp file:", path

        # Remove theDict from the list so the gc can recycle the Leo window!
        g.app.openWithFiles.remove(theDict)
    #@-node:ekr.20031218072017.2614:app.destroyOpenWithFileWithDict
    #@+node:ekr.20031218072017.2615:app.destroyWindow
    def destroyWindow (self,frame):

        # g.trace(frame in g.app.windowList,frame)

        g.app.destroyOpenWithFilesForFrame(frame)

        if frame in g.app.windowList:
            g.app.windowList.remove(frame)
            # g.trace(g.app.windowList)

        # force the window to go away now.
        # Important: this also destroys all the objects of the commander.
        frame.destroySelf()
    #@-node:ekr.20031218072017.2615:app.destroyWindow
    #@+node:ekr.20031218072017.1732:app.finishQuit
    def finishQuit(self):

        # forceShutdown may already have fired the "end1" hook.
        if not g.app.killed:
            g.doHook("end1")

        self.destroyAllOpenWithFiles()

        if g.app.gui:
            g.app.gui.destroySelf()

        # Don't use g.trace!
        # print 'app.finishQuit: setting g.app.killed',g.callers()

        g.app.killed = True
            # Disable all further hooks and events.
            # Alas, "idle" events can still be called even after the following code.

        if g.app.afterHandler:
            # TK bug: This appears to have no effect, at least on Windows.
            # print "finishQuit: cancelling",g.app.afterHandler
            if g.app.gui and g.app.gui.guiName() == "tkinter":
                self.root.after_cancel(g.app.afterHandler)
            g.app.afterHandler = None
    #@-node:ekr.20031218072017.1732:app.finishQuit
    #@+node:ekr.20031218072017.2616:app.forceShutdown
    def forceShutdown (self):

        """Forces an immediate shutdown of Leo at any time.

        In particular, may be called from plugins during startup."""

        # Wait until everything is quiet before really quitting.
        g.doHook("end1")

        self.log = None # Disable writeWaitingLog
        self.killed = True # Disable all further hooks.

        for w in self.windowList[:]:
            self.destroyWindow(w)

        self.finishQuit()
    #@-node:ekr.20031218072017.2616:app.forceShutdown
    #@+node:ekr.20031218072017.2617:app.onQuit
    def onQuit (self,event=None):

        '''Exit Leo, prompting to save unsaved outlines first.'''

        g.app.quitting = True

        while g.app.windowList:
            w = g.app.windowList[0]
            if not g.app.closeLeoWindow(w):
                break

        if g.app.windowList:
            g.app.quitting = False # If we get here the quit has been disabled.
    #@-node:ekr.20031218072017.2617:app.onQuit
    #@+node:ekr.20031218072017.2618:app.setEncoding
    #@+at 
    #@nonl
    # According to Martin v. Löwis, getdefaultlocale() is broken, and cannot 
    # be fixed. The workaround is to copy the g.getpreferredencoding() 
    # function from locale.py in Python 2.3a2.  This function is now in 
    # leoGlobals.py.
    #@-at
    #@@c

    def setEncoding (self):

        """Set g.app.tkEncoding."""

        try: locale_encoding = g.getpreferredencoding()
        except Exception: locale_encoding = None

        try: sys_encoding = sys.getdefaultencoding()
        except Exception: sys_encoding = None

        for (encoding,src) in (
            (self.config.tkEncoding,"config"),
            (locale_encoding,"locale"),
            (sys_encoding,"sys"),
            ("utf-8","default")):

            if g.isValidEncoding (encoding):
                self.tkEncoding = encoding
                # g.trace(self.tkEncoding,src)
                break
            elif encoding:
                color = g.choose(self.tkEncoding=="ascii","red","blue")
                g.trace("ignoring invalid %s encoding: %s" % (src,encoding),color=color)
    #@-node:ekr.20031218072017.2618:app.setEncoding
    #@+node:ekr.20031218072017.1978:app.setLeoID
    def setLeoID (self,verbose=True):

        tag = ".leoID.txt"
        homeDir = g.app.homeDir
        globalConfigDir = g.app.globalConfigDir
        loadDir = g.app.loadDir

        verbose = not g.app.unitTesting
        #@    &lt;&lt; return if we can set leoID from sys.leoID &gt;&gt;
        #@+node:ekr.20031218072017.1979:&lt;&lt; return if we can set leoID from sys.leoID&gt;&gt;
        # This would be set by in Python's sitecustomize.py file.

        # 7/2/04: Use hasattr &amp; getattr to suppress pychecker warning.
        # We also have to use a "non-constant" attribute to suppress another warning!

        nonConstantAttr = "leoID"

        if hasattr(sys,nonConstantAttr):
            g.app.leoID = getattr(sys,nonConstantAttr)
            if verbose and not g.app.unitTesting:
                g.es_print("leoID = " + g.app.leoID, color='red')
            return
        else:
            g.app.leoID = None
        #@-node:ekr.20031218072017.1979:&lt;&lt; return if we can set leoID from sys.leoID&gt;&gt;
        #@nl
        #@    &lt;&lt; return if we can set leoID from "leoID.txt" &gt;&gt;
        #@+node:ekr.20031218072017.1980:&lt;&lt; return if we can set leoID from "leoID.txt" &gt;&gt;
        for theDir in (homeDir,globalConfigDir,loadDir):
            # N.B. We would use the _working_ directory if theDir is None!
            if theDir:
                try:
                    fn = g.os_path_join(theDir,tag)
                    f = open(fn,'r')
                    s = f.readline()
                    f.close()
                    if s and len(s) &gt; 0:
                        g.app.leoID = s.strip()
                        if verbose and not g.app.unitTesting:
                            g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                        return
                    elif verbose and not g.app.unitTesting:
                        g.es("empty %s (in %s)" % (tag,theDir), color = "red")
                except IOError:
                    g.app.leoID = None
                    # g.es("%s not found in %s" % (tag,theDir),color="red")
                except Exception:
                    g.app.leoID = None
                    g.es_print('Unexpected exception in app.setLeoID',color='red')
                    g.es_exception()
        #@-node:ekr.20031218072017.1980:&lt;&lt; return if we can set leoID from "leoID.txt" &gt;&gt;
        #@nl
        #@    &lt;&lt; return if we can set leoID from os.getenv('USER') &gt;&gt;
        #@+node:ekr.20060211140947.1:&lt;&lt; return if we can set leoID from os.getenv('USER') &gt;&gt;
        try:
            theId = os.getenv('USER')
            if theId:
                if verbose and not g.app.unitTesting:
                    g.es("using os.getenv('USER'): %s " % (repr(theId)),color='red')
                g.app.leoID = theId
                return

        except Exception:
            pass
        #@-node:ekr.20060211140947.1:&lt;&lt; return if we can set leoID from os.getenv('USER') &gt;&gt;
        #@nl
        #@    &lt;&lt; put up a dialog requiring a valid id &gt;&gt;
        #@+node:ekr.20031218072017.1981:&lt;&lt; put up a dialog requiring a valid id &gt;&gt;
        # New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

        # Create an emergency gui and a Tk root window.
        g.app.createTkGui("startup")

        # Bug fix: 2/6/05: put result in g.app.leoID.
        g.app.leoID = g.app.gui.runAskLeoIDDialog()

        # g.trace(g.app.leoID)
        g.es("leoID = %s" % (repr(g.app.leoID)),color="blue")
        #@-node:ekr.20031218072017.1981:&lt;&lt; put up a dialog requiring a valid id &gt;&gt;
        #@nl
        #@    &lt;&lt; attempt to create leoID.txt &gt;&gt;
        #@+node:ekr.20031218072017.1982:&lt;&lt; attempt to create leoID.txt &gt;&gt;
        for theDir in (homeDir,globalConfigDir,loadDir):
            # N.B. We would use the _working_ directory if theDir is None!
            if theDir:
                cant = "can not create %s in %s" % (tag,theDir)
                try:
                    fn = g.os_path_join(theDir,tag)
                    f = open(fn,'w')
                    f.write(g.app.leoID)
                    f.close()
                    if g.os_path_exists(fn):
                        s = "%s created in %s" % (tag,theDir)
                        g.es_print(s, color="red")
                        return
                    else:
                        g.es(cant,color='red')
                except IOError:
                    g.es(cant,color='red')
        #@-node:ekr.20031218072017.1982:&lt;&lt; attempt to create leoID.txt &gt;&gt;
        #@nl
    #@-node:ekr.20031218072017.1978:app.setLeoID
    #@+node:ekr.20031218072017.1847:app.setLog, lockLog, unlocklog
    def setLog (self,log):

        """set the frame to which log messages will go"""

        # print "setLog:",tag,"locked:",self.logIsLocked,log
        if not self.logIsLocked:
            self.log = log

    def lockLog(self):
        """Disable changes to the log"""
        self.logIsLocked = True

    def unlockLog(self):
        """Enable changes to the log"""
        self.logIsLocked = False
    #@-node:ekr.20031218072017.1847:app.setLog, lockLog, unlocklog
    #@+node:ekr.20031218072017.2619:app.writeWaitingLog
    def writeWaitingLog (self):

        # g.trace(g.app.gui,self.log)

        if self.log:
            if 1: # not self.log.isNull: # The test for isNull would probably interfere with batch mode.
                for s,color in self.logWaiting:
                    g.es(s,color=color,newline=0) # The caller must write the newlines.
                self.logWaiting = []
        else:
            print 'writeWaitingLog: still no log!'
    #@-node:ekr.20031218072017.2619:app.writeWaitingLog
    #@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
    def newLeoCommanderAndFrame(self,fileName=None,gui=None,initEditCommanders=True,updateRecentFiles=True):

        """Create a commander and its view frame for the Leo main window."""

        app = self

        import leoCommands

        if not fileName: fileName = ""
        if not gui: gui = g.app.gui
        #@    &lt;&lt; compute the window title &gt;&gt;
        #@+node:ekr.20031218072017.2189:&lt;&lt; compute the window title &gt;&gt;
        # Set the window title and fileName
        if fileName:
            title = g.computeWindowTitle(fileName)
        else:
            s = "untitled"
            n = g.app.numberOfWindows
            if n &gt; 0:
                s += str(n)
            title = g.computeWindowTitle(s)
            g.app.numberOfWindows = n+1
        #@-node:ekr.20031218072017.2189:&lt;&lt; compute the window title &gt;&gt;
        #@nl

        # Create an unfinished frame to pass to the commanders.
        frame = gui.createLeoFrame(title)

        # Create the commander and its subcommanders.
        c = leoCommands.Commands(frame,fileName)

        if not app.initing:
            g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

        frame.finishCreate(c)
        c.finishCreate(initEditCommanders)

        # Finish initing the subcommanders.
        c.undoer.clearUndoState() # Menus must exist at this point.

        if updateRecentFiles:
            c.updateRecentFiles(fileName)

        if not g.app.initing:
            g.doHook("after-create-leo-frame",c=c)

        return c,frame
    #@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
    #@-others
#@-node:ekr.20031218072017.2608:@thin leoApp.py
#@-leo
</t>
<t tx="ekr.20071105090148.351">@nocolor
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;?xml-stylesheet ekr_test?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/&gt;
&lt;globals body_outline_ratio="0.490613266583"&gt;
	&lt;global_window_position top="61" left="237" height="799" width="927"/&gt;
	&lt;global_log_window_position top="0" left="0" height="0" width="0"/&gt;
&lt;/globals&gt;
&lt;preferences/&gt;
&lt;find_panel_settings/&gt;
&lt;vnodes&gt;
&lt;v t="ekr.20060301122644"&gt;&lt;vh&gt;Buttons&lt;/vh&gt;
&lt;v t="ekr.20060301122618"&gt;&lt;vh&gt;@button Unit Test @key=Alt-4&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060301122644.1"&gt;&lt;vh&gt;@button Save&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103"&gt;&lt;vh&gt;Disabled buttons&lt;/vh&gt;
&lt;v t="ekr.20060626085103.1"&gt;&lt;vh&gt;Run tcl script&lt;/vh&gt;
&lt;v t="ekr.20060626085103.2"&gt;&lt;vh&gt;@@button Run tcl  script&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.3"&gt;&lt;vh&gt;My first tcl script&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.4"&gt;&lt;vh&gt;My second tcl scrip, organized with noweb markup&lt;/vh&gt;
&lt;v t="ekr.20060626085103.5"&gt;&lt;vh&gt;the actual script&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626085103.6"&gt;&lt;vh&gt;@@ button pydoc&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.7"&gt;&lt;vh&gt;@@ button jython&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.8"&gt;&lt;vh&gt;@@button Ipython&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.9"&gt;&lt;vh&gt;@@button Lines Up&lt;/vh&gt;
&lt;v t="ekr.20060626085103.10"&gt;&lt;vh&gt;moveLinesUp&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626085103.11"&gt;&lt;vh&gt;@@button Lines Down&lt;/vh&gt;
&lt;v t="ekr.20060626085103.12"&gt;&lt;vh&gt;moveLinesDown&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626085103.13"&gt;&lt;vh&gt;@@button outlineToClipboard&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.14"&gt;&lt;vh&gt;@@command dbl-click @key = Alt-Shift-C&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.15"&gt;&lt;vh&gt;@@button shorten-lines&lt;/vh&gt;
&lt;v t="ekr.20060626085103.16"&gt;&lt;vh&gt;to do&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.17"&gt;&lt;vh&gt;splitLongLine&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.18"&gt;&lt;vh&gt;chooseBreakPoint&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626085103.19"&gt;&lt;vh&gt;@@button file-mode&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.20"&gt;&lt;vh&gt;@@button Free-Tree&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.21"&gt;&lt;vh&gt;@@button *new-obj&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.22"&gt;&lt;vh&gt;@@button New-obj&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.23"&gt;&lt;vh&gt;@@button Gc&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.24"&gt;&lt;vh&gt;@@button No-Gc&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.25"&gt;&lt;vh&gt;@@button All-obj&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.26"&gt;&lt;vh&gt;@@button run timer&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.27"&gt;&lt;vh&gt;@@button Stats&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.28"&gt;&lt;vh&gt;@@button scripts.leo&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.29"&gt;&lt;vh&gt;@@button updateSettings&lt;/vh&gt;
&lt;v t="ekr.20060626085103.30"&gt;&lt;vh&gt;&amp;lt;&amp;lt;docstring&amp;gt;&amp;gt;&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.31"&gt;&lt;vh&gt;class updateParser (parserBaseClass)&lt;/vh&gt;
&lt;v t="ekr.20060626085103.32"&gt;&lt;vh&gt;ctor&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.33"&gt;&lt;vh&gt;visitNode&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.34"&gt;&lt;vh&gt;kind handlers (overrides only)&lt;/vh&gt;
&lt;v t="ekr.20060626085103.35"&gt;&lt;vh&gt;doFont&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.36"&gt;&lt;vh&gt;doShortcut&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.37"&gt;&lt;vh&gt;doShortcuts&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626085103.38"&gt;&lt;vh&gt;set&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626085103.39"&gt;&lt;vh&gt;class updateClass&lt;/vh&gt;
&lt;v t="ekr.20060626085103.40"&gt;&lt;vh&gt; ctor&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.41"&gt;&lt;vh&gt;add&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.42"&gt;&lt;vh&gt;change&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.43"&gt;&lt;vh&gt;error, message &amp;amp; warning&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.44"&gt;&lt;vh&gt;open&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.45"&gt;&lt;vh&gt;update&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626085103.46"&gt;&lt;vh&gt;@@button open-outline-by-name&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.47"&gt;&lt;vh&gt;@@button Show other clones&lt;/vh&gt;
&lt;v t="ekr.20060626085103.48"&gt;&lt;vh&gt;class cloneNavigator&lt;/vh&gt;
&lt;v t="ekr.20060626085103.49"&gt;&lt;vh&gt;init&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.50"&gt;&lt;vh&gt;getAllClones&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.51"&gt;&lt;vh&gt;displayClones&lt;/vh&gt;
&lt;v t="ekr.20060626085103.52"&gt;&lt;vh&gt;&amp;lt;&amp;lt;Fill listbox with clone parent headlines&amp;gt;&amp;gt;&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.53"&gt;&lt;vh&gt;&amp;lt;&amp;lt;Goto selected position when listbox selection changes&amp;gt;&amp;gt;&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626085246"&gt;&lt;vh&gt;@@button Unit Test&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.55"&gt;&lt;vh&gt;@@button dt&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.56"&gt;&lt;vh&gt;@@button debug-leo&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.57"&gt;&lt;vh&gt;@@button debug&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.58"&gt;&lt;vh&gt;@@button del-ed&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.59"&gt;&lt;vh&gt;@@button cycle-ed&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.60"&gt;&lt;vh&gt;@@button add-ed&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626085103.61"&gt;&lt;vh&gt;@@button rst3&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20051208082927"&gt;&lt;vh&gt;ut.leo&lt;/vh&gt;
&lt;v t="ekr.20051208083135"&gt;&lt;vh&gt;@asis ut.bat&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060124103819"&gt;&lt;vh&gt;@asis utw.bat&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20051208084010"&gt;&lt;vh&gt;@thin ut.py&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060129090836"&gt;&lt;vh&gt;@ignore&lt;/vh&gt;
&lt;v t="ekr.20051208085841.1"&gt;&lt;vh&gt;@test assert False&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060129185431"&gt;&lt;vh&gt;@test k.strokeFromEvent and k.strokeFromSetting&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20051208085841"&gt;&lt;vh&gt;@test 1&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060208071636"&gt;&lt;vh&gt;Test headline abc&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060914121042"&gt;&lt;vh&gt;Plugin-specific unit tests&lt;/vh&gt;
&lt;v t="ekr.20060914121042.1"&gt;&lt;vh&gt;@test leo_to_html&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060914123717"&gt;&lt;vh&gt;@test leo_to_rtf&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060914123949"&gt;&lt;vh&gt;@test chapter_hoist&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060914125424"&gt;&lt;vh&gt;@test mod_scripting&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060914125710"&gt;&lt;vh&gt;@test open_with&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060914130213"&gt;&lt;vh&gt;@test rst3&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060914130545"&gt;&lt;vh&gt;@test UNL&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060914130924"&gt;&lt;vh&gt;@test paste_as_headlines&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626084629"&gt;&lt;vh&gt;To do: convert to unit tests&lt;/vh&gt;
&lt;v t="ekr.20060626084629.11"&gt;&lt;vh&gt;remove-blank-lines&lt;/vh&gt;
&lt;v t="ekr.20060626084629.13"&gt;&lt;vh&gt;data&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626084629.12"&gt;&lt;vh&gt;indent-relative&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.15"&gt;&lt;vh&gt;autocompleter test&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.17"&gt;&lt;vh&gt;testClass (for test of self completion)&lt;/vh&gt;
&lt;v t="ekr.20060626084629.18"&gt;&lt;vh&gt;ctor&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.19"&gt;&lt;vh&gt;spam&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.20"&gt;&lt;vh&gt;eggs&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.21"&gt;&lt;vh&gt;bad&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.22"&gt;&lt;vh&gt;test of self&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626084629.49"&gt;&lt;vh&gt;test g.cantImportDialog&lt;/vh&gt;
&lt;v t="ekr.20060626084629.50"&gt;&lt;vh&gt;createFrame&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.51"&gt;&lt;vh&gt;createButtons&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626084629.52"&gt;&lt;vh&gt;test of clear-selected-text&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.53"&gt;&lt;vh&gt;test of clean-lines&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.55"&gt;&lt;vh&gt;Move lines up/down&lt;/vh&gt;
&lt;v t="ekr.20060626084629.56"&gt;&lt;vh&gt;add/remove tests&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.57"&gt;&lt;vh&gt;@@button move-lines-down&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.58"&gt;&lt;vh&gt;@@button move-lines-up&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.59"&gt;&lt;vh&gt;@@button toggle-show-invisibles&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.60"&gt;&lt;vh&gt;before&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.61"&gt;&lt;vh&gt;move test&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.62"&gt;&lt;vh&gt;after&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626084629.63"&gt;&lt;vh&gt;Incremental searches&lt;/vh&gt;
&lt;v t="ekr.20060626084629.64"&gt;&lt;vh&gt;@@button isearch-forward&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.65"&gt;&lt;vh&gt;@@button isearch-backward&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.66"&gt;&lt;vh&gt;Node 1&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.67"&gt;&lt;vh&gt;Node 2&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20060626084629.69"&gt;&lt;vh&gt;open-name &lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.75"&gt;&lt;vh&gt;@image c:/prog/test/PythonPowered.gif&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.89"&gt;&lt;vh&gt;call g.makeScriptButton&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.90"&gt;&lt;vh&gt;Indentation error&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.91"&gt;&lt;vh&gt;Test removeSentinelLines&lt;/vh&gt;
&lt;v t="ekr.20060626084629.92"&gt;&lt;vh&gt;@@file testRemoveSentinels.py&lt;/vh&gt;
&lt;v t="ekr.20060626084629.93"&gt;&lt;vh&gt;&amp;lt;&amp;lt; imports &amp;gt;&amp;gt;&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20060626084629.94"&gt;&lt;vh&gt;spam&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20061023080533" a="V"&gt;&lt;vh&gt;Scripts that make unit tests&lt;/vh&gt;
&lt;v t="ekr.20061023080533.1"&gt;&lt;vh&gt;@command make-test @key=Ctrl-1&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20061023080533.2"&gt;&lt;vh&gt;@command do-before @key=Ctrl-2&lt;/vh&gt;
&lt;v t="ekr.20061023080533.3"&gt;&lt;vh&gt;getSel&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20061023080533.4"&gt;&lt;vh&gt;findNodes&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20061023080533.5"&gt;&lt;vh&gt;putSelectionInHeadline&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20061023080533.6"&gt;&lt;vh&gt;@command do-after @key=Ctrl-3&lt;/vh&gt;
&lt;v t="ekr.20061023080533.7"&gt;&lt;vh&gt;getSel&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20061023080533.8"&gt;&lt;vh&gt;findNodes&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20061023080533.9"&gt;&lt;vh&gt;putSelectionInHeadline&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20061023080533.10"&gt;&lt;vh&gt;@test kill-line&lt;/vh&gt;
&lt;v t="ekr.20061023080533.11"&gt;&lt;vh&gt;work&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20061023080533.12"&gt;&lt;vh&gt;before sel=2.0,2.6&lt;/vh&gt;&lt;/v&gt;
&lt;v t="ekr.20061023080533.13"&gt;&lt;vh&gt;after sel=2.0,2.0&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20061023111426"&gt;&lt;vh&gt;create test buttons from list&lt;/vh&gt;
&lt;v t="ekr.20061023111426.1"&gt;&lt;vh&gt;&amp;lt;&amp;lt; define aList &amp;gt;&amp;gt;&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="ekr.20051208082927"&gt;@ This file is called from ut.batch.

It should contain quick unit tests to be run in Leo's batch mode.

It also defines ut.bat itself.&lt;/t&gt;
&lt;t tx="ekr.20051208083135"&gt;cd c:\prog\leoCVS\leo\test
python ..\src\leo.py -script ..\test\ut.py&lt;/t&gt;
&lt;t tx="ekr.20051208085841"&gt;assert True&lt;/t&gt;
&lt;t tx="ekr.20051208085841.1"&gt;assert False,'This should fail'&lt;/t&gt;
&lt;t tx="ekr.20060124103819"&gt;cd c:\prog\leoCVS\leo\test
python ..\src\leo.py -script-window ..\test\ut.py&lt;/t&gt;
&lt;t tx="ekr.20060129090836"&gt;&lt;/t&gt;
&lt;t tx="ekr.20060129185431"&gt;import string
k = c.k ; key = 0 ; shift = 1 ; ctrl = 4 ; alt = 0x20000

prefixes = (
    ('',0),('Alt-',alt),('Ctrl-',ctrl),
    ('Shift-',shift),('Alt-Shift-',alt+shift),('Alt-Ctrl-',alt+ctrl),
)

for prefix,state in prefixes:
    for ch in string.printable:
        if prefix.find('Shift-') &amp;gt; -1 and ch not in string.letters:
            continue # The shift would be ignored.
        ch2 = k.tkBindNamesDict.get(ch) or ch
        setting = prefix + ch2
        stroke = k.strokeFromSetting(setting)
        if not stroke: continue
        if (shift &amp;amp; state) != 0: ch = ch.upper()
        event = g.Bunch(char=ch,keysym=ch,state=state)
        stroke2 = k.strokeFromEvent(event)
        assert stroke2==stroke,\
            'strokefromSetting: %s, strokeFromEvent: %s' % (repr(stroke),repr(stroke2))&lt;/t&gt;
&lt;t tx="ekr.20060208071636"&gt;&lt;/t&gt;
&lt;t tx="ekr.20060301122618"&gt;# You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.doTests(c,all=False)&lt;/t&gt;
&lt;t tx="ekr.20060301122644"&gt;&lt;/t&gt;
&lt;t tx="ekr.20060301122644.1"&gt;c.save()
c.redraw_now() # Must be done here.&lt;/t&gt;
&lt;t tx="ekr.20060626084629"&gt;&lt;/t&gt;
&lt;t tx="ekr.20060626084629.11"&gt;c.executeMinibufferCommand('remove-blank-lines')&lt;/t&gt;
&lt;t tx="ekr.20060626084629.12"&gt;c.executeMinibufferCommand('indent-relative')&lt;/t&gt;
&lt;t tx="ekr.20060626084629.13"&gt;a
 
b

c
d

e

This is a test of navigation.
&lt;/t&gt;
&lt;t tx="ekr.20060626084629.15"&gt;@others

print '-' * 20

for s in (
    'a bc',
    'a.bc',
    'abc ',
    ' abc',
):
    print 's',repr(s), repr(reverseFindWhitespace(s))&lt;/t&gt;
&lt;t tx="ekr.20060626084629.17"&gt;class testClass:
    
    '''A class to test the forgiving parser.'''
    
    @others&lt;/t&gt;
&lt;t tx="ekr.20060626084629.18"&gt;def __init__ (self,c):
    self.c = c
    self.d = '1'
    self.e = '2'&lt;/t&gt;
&lt;t tx="ekr.20060626084629.19"&gt;def spam (self,s,p,a,m=[]):
    pass&lt;/t&gt;
&lt;t tx="ekr.20060626084629.20"&gt;def eggs(self,e,g,s):
    pass&lt;/t&gt;
&lt;t tx="ekr.20060626084629.21"&gt;def bad (self):
    self = &lt;/t&gt;
&lt;t tx="ekr.20060626084629.22"&gt;self.&lt;/t&gt;
&lt;t tx="ekr.20060626084629.49"&gt;g.cantImportDialog("Leo's core",'xyzzy')&lt;/t&gt;
&lt;t tx="ekr.20060626084629.50"&gt;def createFrame(root,title,message):
    
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    top = Tk.Toplevel(root)
    top.title(title)
    
    def onKey(event,top=top):
        if event.char.lower() in ('\n','\r'):
            top.destroy()
    top.bind("&amp;lt;Key&amp;gt;",onKey)

    f = Tk.Frame(top)
    f.pack(side="top",expand=1,fill="both")
    
    label = Tk.Label(f,text=message)
    label.pack(pady=10)
    
    def okButton(top=top):
        top.destroy()
    
    buttons = {"text":'OK',"command":okButton,"default":True}, # Singleton tuple.
    createButtons(top,buttons)
    
    # top.protocol("WM_DELETE_WINDOW",onClose)
    
    # Attach the icon at idle time.
    def attachIconCallback(top=top):
        g.app.gui.attachLeoIcon(top)
    top.after_idle(attachIconCallback)
    return top&lt;/t&gt;
&lt;t tx="ekr.20060626084629.51"&gt;def createButtons (top,buttons):
    
    """Create a row of buttons.
    
    buttons is a list of dictionaries containing the properties of each button."""
    
    f = Tk.Frame(top)
    f.pack(side="top",padx=30)

    buttonList = []
    for d in buttons:
        text = d.get("text","&amp;lt;missing button name&amp;gt;")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)&lt;/t&gt;
&lt;t tx="ekr.20060626084629.52"&gt;abc
xyz
pdq&lt;/t&gt;
&lt;t tx="ekr.20060626084629.53"&gt;before
first
    
b   
    c
        
last
after&lt;/t&gt;
&lt;t tx="ekr.20060626084629.55"&gt;&lt;/t&gt;
&lt;t tx="ekr.20060626084629.56"&gt;a
   b
c
 abcde
e
f&lt;/t&gt;
&lt;t tx="ekr.20060626084629.57"&gt;event = g.Bunch(widget = g.app.gui.get_focus(c))
c.editCommands.moveLinesDown(event)&lt;/t&gt;
&lt;t tx="ekr.20060626084629.58"&gt;event = g.Bunch(widget = g.app.gui.get_focus(c))
c.editCommands.moveLinesUp(event)&lt;/t&gt;
&lt;t tx="ekr.20060626084629.59"&gt;c.viewAllCharacters()&lt;/t&gt;
&lt;t tx="ekr.20060626084629.60"&gt;before1
before2&lt;/t&gt;
&lt;t tx="ekr.20060626084629.61"&gt;start1
start2
line a   xxx
line b   y
line c      z
end
end2&lt;/t&gt;
&lt;t tx="ekr.20060626084629.62"&gt;after1
after2&lt;/t&gt;
&lt;t tx="ekr.20060626084629.63"&gt;&lt;/t&gt;
&lt;t tx="ekr.20060626084629.64"&gt;event = g.Bunch(widget=g.app.gui.get_focus(c),char='',keysym='')

c.searchCommands.isearchForward(event)&lt;/t&gt;
&lt;t tx="ekr.20060626084629.65"&gt;event = g.Bunch(widget=g.app.gui.get_focus(c),char='',keysym='')

c.searchCommands.isearchBackward(event)&lt;/t&gt;
&lt;t tx="ekr.20060626084629.66"&gt;abcde&lt;/t&gt;
&lt;t tx="ekr.20060626084629.67"&gt;abzde&lt;/t&gt;
&lt;t tx="ekr.20060626084629.69"&gt;c.editFileCommands.openOutlineByName(event=None)&lt;/t&gt;
&lt;t tx="ekr.20060626084629.75"&gt;&lt;/t&gt;
&lt;t tx="ekr.20060626084629.89"&gt;# g.makeScriptButton(c,p=p)

g.makeScriptButton(c,buttonText='HelloWorld',script="g.es_print('Hello World',color='red')")&lt;/t&gt;
&lt;t tx="ekr.20060626084629.90"&gt;if 1:
    print c.k.mb_history
  #indentation error
  print 'oops'&lt;/t&gt;
&lt;t tx="ekr.20060626084629.91"&gt;f = file('testRemoveSentinels.py')
s = f.read()
f.close()

result = c.importCommands.removeSentinelLines(s,'#',None,None)
print '-' * 40
print s
print '-' * 40
print result&lt;/t&gt;
&lt;t tx="ekr.20060626084629.92"&gt;# Important: the execute-script command will insert @verbatim sentinels
# before anything that looks like a sentinel, so the test requires an external file.
'''docstring'''
&amp;lt;&amp;lt; imports &amp;gt;&amp;gt;
@others
# end&lt;/t&gt;
&lt;t tx="ekr.20060626084629.93"&gt;import sys&lt;/t&gt;
&lt;t tx="ekr.20060626084629.94"&gt;def spam ():
    pass&lt;/t&gt;
&lt;t tx="ekr.20060626085103"&gt;&lt;/t&gt;
&lt;t tx="ekr.20060626085103.1"&gt;@language tcltk&lt;/t&gt;
&lt;t tx="ekr.20060626085103.2"&gt;# To use this script, you must make this a script button, either with the
# 'Script Button' button or by making this an @button node.

# Executes body text of selected node as a tcl script.
# For more information, see http://wiki.tcl.tk/6878

# This statement allows you to organize your scripts using noweb markup.
s = g.getScript(c,p,forcePythonSentinels=False)
g.es(g.app.root.tk.eval(s))&lt;/t&gt;
&lt;t tx="ekr.20060626085103.3"&gt;# This is a comment
set x 50
return [expr $x*10]&lt;/t&gt;
&lt;t tx="ekr.20060626085103.4"&gt;@others&lt;/t&gt;
&lt;t tx="ekr.20060626085103.5"&gt;# This is a comment
set x 50 +
return [expr $x*10]&lt;/t&gt;
&lt;t tx="ekr.20060626085103.6"&gt;import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()&lt;/t&gt;
&lt;t tx="ekr.20060626085103.7"&gt;# **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.headString()
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
&lt;/t&gt;
&lt;t tx="ekr.20060626085103.8"&gt;from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()&lt;/t&gt;
&lt;t tx="ekr.20060626085103.9"&gt;# Move selected text of the body up one line.

@others

moveLinesUp(c,p)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.10"&gt;def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.11"&gt;# Move selected text of the body down one line.

@others

moveLinesDown(c,p)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.12"&gt;def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.13"&gt;result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.14"&gt;c.frame.tree.OnIconDoubleClick(p)
&lt;/t&gt;
&lt;t tx="ekr.20060626085103.15"&gt;@others

d = g.scanDirectives(c,p)
w = d.get('pagewidth',100)
tab_width = d.get('tabwidth',4)

print '*' * 60

if d.get('language','').lower() == 'python':
    result = [] ; inComment = False ; inString = False
    for line in g.splitlines(p.bodyString()):
        i,junk = g.skip_leading_ws_with_indent(line,0,tab_width)
        lws = line[:i]
        # g.trace('lws',repr(lws))
        result.extend(splitLongLine(line,lws,w,tab_width,inComment,inString))
    
    print ''.join(result)
else:
    print 'Not Python code'&lt;/t&gt;
&lt;t tx="ekr.20060626085103.16"&gt;@

Bug: can't split after opening quote.
* Handle-triple-quote strings properly.
** Skip @doc parts.
- Handle tabs properly when splitting.&lt;/t&gt;
&lt;t tx="ekr.20060626085103.17"&gt;def splitLongLine(s,lws,w,tab_width,inComment,inString):

    if not s or g.computeWidth (s,tab_width) &amp;lt; w:
        return [s]
        
    i,inComment,inString,backslash = chooseBreakPoint(s,w,tab_width,inComment,inString)
    if i is None: return [s]

    if inComment:
        tab = ''
    else:
        tab = g.choose(tab_width &amp;lt; 0,' ' * abs(tab_width),'\t')
    comment = g.choose(inComment,'# ','')
    list1 = [s[:i+1]]
    list2 = splitLongLine(s[i+1:],lws+tab,w,tab_width,inComment,inString)
    list1.append('%s\n%s%s%s' % (backslash,lws,comment,tab))
    list1.extend(list2)
    return list1&lt;/t&gt;
&lt;t tx="ekr.20060626085103.18"&gt;def chooseBreakPoint (s,w,tab_width,inComment,inString):
    
    '''Return (i,inComment,inString,backSlash) where::
    - i is the index at which to break the line.
    - inComment is True if we are in a comment.
    - inString is True if we are in a string.
    - backslash is '\\' if the broken line must end in a backslash'''

    i, i2 = -1,-1 # The index of the rightmost valid breakpoint.
    for k in xrange(len(s)):
        ch = s[k]
        if k &amp;gt;= w and i &amp;gt; -1:
            break
        elif inComment:
            if ch in (' ','\t'): i = k
        elif ch in ('"',"'"):
            inString = not inString
            if not inString:
                i = max(0,k-1) ; i2 = -1
        elif inString:
            if ch in (' ','\t'): i = k
        else:
            if ch in ('(','[')  and g.skip_ws(s,k+1) &amp;gt; abs(tab_width):
                i = k ;  g.trace(k,repr(ch),repr(s))
            if ch in (' ','\t') and g.skip_ws(s,k) &amp;gt; abs(tab_width):
                i2 = k ;  g.trace(k,repr(ch),repr(s))
            if ch == '#':
                inComment = True ; inString = False; i = k ; i2 = -1

    if i == -1 and i2 == -1:
        return None,inComment,inString,'' # No break is possible.
    elif i == -1:
        # Break at a blank.
        i2 = max(i2,g.skip_ws(s,i2)-1)
        return i2,inComment,inString,'\\'
    elif inComment:
        i = max(i,g.skip_ws(s,i)-1)
        return i,True,False,''
    elif inString:
        i = max(i,g.skip_ws(s,i)-1)
        return i,False,True,'\\'
    else:
        # Break at a bracket.
        i = max(i,g.skip_ws(s,i+1)-1)
        return i,False,False,''&lt;/t&gt;
&lt;t tx="ekr.20060626085103.19"&gt;c.keyHandler.simulateCommand('enter-file-mode')&lt;/t&gt;
&lt;t tx="ekr.20060626085103.20"&gt;c.debugCommands.freeTreeWidgets()&lt;/t&gt;
&lt;t tx="ekr.20060626085103.21"&gt;c.debugCommands.verboseDumpObjects()&lt;/t&gt;
&lt;t tx="ekr.20060626085103.22"&gt;c.debugCommands.dumpNewObjects()&lt;/t&gt;
&lt;t tx="ekr.20060626085103.23"&gt;c.debugCommands.enableGcTrace()
g.collectGarbage()&lt;/t&gt;
&lt;t tx="ekr.20060626085103.24"&gt;g.app.trace_gc = False&lt;/t&gt;
&lt;t tx="ekr.20060626085103.25"&gt;c.debugCommands.dumpAllObjects()&lt;/t&gt;
&lt;t tx="ekr.20060626085103.26"&gt;import leoTest
leoTest.runTimerOnNode(c,p,count=100)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.27"&gt;c.debugCommands.printStats()&lt;/t&gt;
&lt;t tx="ekr.20060626085103.28"&gt;name = "scripts.leo"
fileName = g.os_path_join(g.app.loadDir,"..","scripts",name)
ok,frame = g.openWithFileName(fileName,c)
if not ok:
    g.es("not found: %s" % name)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.29"&gt;&amp;lt;&amp;lt; docstring &amp;gt;&amp;gt;

import leoConfig

# The user's previous (and preferred) leoSettings.leo file.
path1 = r'c:\prog\leoCVS\leo\config\leoSettings.leo'

# The new distribution leoSettings.leo file.
path2 = r'c:\prog\leoCVS\leo\config\leoSettings2.leo'

@others

# print '*' * 40

updateClass(c,path1,path2).update()&lt;/t&gt;
&lt;t tx="ekr.20060626085103.30"&gt;'''Here is a **preliminary** script that updates a new leoSettings.leo file
(path2) from the settings in a previous leoSettings.leo file (path1).
Presumably, the path2 file is the leoSettings.leo file from a new distribution,
and the path1 file a leoSettings.leo file containing settings that you have
modified.  You must specify the full path of both files in the top-level @button node.

**Warning**: This script modifies the path2 file. Make sure that you don't mind
modifying this file.

**Warning**: This script is unsophisticated in its update algorithm. If if finds
corresponding nodes (node with the same settings name) in both outlines it simply
replaces the node in the path2 file with the node in the path1 file. In
particular, it does not keep track of individual shortcuts: it repaces the body
of one @shortcuts node with the body of the corresponding @shortcuts node.

**Note**: If the path1 file contains a settings node not in the path2 file it
attempts to create a new node in the corresponding place in the path2 file. If
this is not possible, say because the structures of the files are different, the
script places the new node as the last child of the @settings node in the path2
file. '''&lt;/t&gt;
&lt;t tx="ekr.20060626085103.31"&gt;class updateParser (leoConfig.parserBaseClass):
    
    '''A settings parser that returns bunches used for updates.'''
    
    @others&lt;/t&gt;
&lt;t tx="ekr.20060626085103.32"&gt;def __init__ (self,c,tag):

    # Init the base class.
    leoConfig.parserBaseClass.__init__(self,c)
    self.tag = tag&lt;/t&gt;
&lt;t tx="ekr.20060626085103.33"&gt;def visitNode (self,p):
    
        """Init any settings found in node p."""
        
        munge = g.app.config.munge
    
        kind,name,val = self.parseHeadline(p.headString())
        kind = munge(kind)
    
        if kind == "settings":
            pass
        elif kind not in self.control_types and val in (u'None',u'none','None','none','',None):
            # None is valid for all data types.
            self.set(p.copy(),kind,name,None)
        elif kind in self.control_types or kind in self.basic_types:
            kindHandler = self.dispatchDict.get(kind)
            try:
                return kindHandler(p.copy(),kind,name,val)
            except TypeError:
                g.es_exception()
                print "*** no handler",kind
        elif name:
            # self.error("unknown type %s for setting %s" % (kind,name))
            # Just assume the type is a string.
            self.set(p.copy(),kind,name,val)
        
        return None&lt;/t&gt;
&lt;t tx="ekr.20060626085103.34"&gt;&lt;/t&gt;
&lt;t tx="ekr.20060626085103.35"&gt;def doFont (self,p,kind,name,val):
    
    self.set(p,kind,name,val)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.36"&gt;def doShortcut(self,p,kind,name,val):

    self.set(p,kind,name,val)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.37"&gt;def doShortcuts(self,p,kind,name,val):
    
    self.set(p,kind,name,val)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.38"&gt;# Unlike in Leo's core, p and p.c are stable.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""

    c = self.c ; d = self.settingsDict 
    if not kind: return
    
    key = self.munge(name)
    if d.get(key):
        # This is a user error, and should be corrected before merging.
        g.es('*** ignoring duplicate setting for %s in %s' % (
            name,c.fileName()))
    else:
        d[key] = g.Bunch(p=p,kind=kind,name=name,val=val)
        if 0:
            if kind.startswith('strings'): kind = 'strings[]'
            g.trace('%s %10s %45s %s' %(self.tag,kind,name,val))
&lt;/t&gt;
&lt;t tx="ekr.20060626085103.39"&gt;class updateClass:
    
    '''Update path2 (distribution) leoSettings.leo from path1 (user's) leoSettings.leo file.'''
    
    @others&lt;/t&gt;
&lt;t tx="ekr.20060626085103.40"&gt;def __init__ (self,c,path1,path2):
    
    self.c = c
    self.path1 = path1 # The user's previous (and preferred) leoSettings.leo file.
    self.path2 = path2 # The new distribution leoSettings.leo file.&lt;/t&gt;
&lt;t tx="ekr.20060626085103.41"&gt;def add (self,bunch1,c1,c2):

    '''Add a node to c2 in the same position as bunch.p in c1.
    
    If this is not possible, put the node at the end of @settings tree.'''

    p1 = bunch1.p
    parent1 = p1.parent() # Must exist because p is in an @settings tree.
    n = p1.childIndex()
    h = parent1.headString()
    settings2 = g.findNodeAnywhere(c2,'@settings') 
    assert (settings2) # This has already been checked.

    # Create the node.
    if h.startswith('@settings'):
        p2 = parent2 = settings2.insertAsLastChild()
    else:
        parent2 = g.findNodeInTree(c2,settings2,h)
        if parent2:
            p2 = parent2.insertAsNthChild(n)
        else:
            self.warning('no corresponding parent node for %s' % h)
            p2 = settings2.insertAsLastChild()
            
    # Copy the head and body strings.
    p2.setBodyString(p1.bodyString())
    p2.setHeadString(p1.headString())&lt;/t&gt;
&lt;t tx="ekr.20060626085103.42"&gt;def change (self,bunch1,bunch2):
    
    '''Change the bunch2.p to match bunch1.p.'''

    p1 = bunch1.p ; p2 = bunch2.p
    p2.setBodyString(p1.bodyString())
    p2.setHeadString(p1.headString())&lt;/t&gt;
&lt;t tx="ekr.20060626085103.43"&gt;def error (self,s):
    
    g.es_print(s, color='red')
    
def message (self,s):
    
    g.es_print(s, color='blue')

def warning (self,s):
    
    g.es_print(s, color='red')&lt;/t&gt;
&lt;t tx="ekr.20060626085103.44"&gt;def open (self, path):
    
    if not g.os_path_exists(path):
        self.error('does not exist: %s' % s)
        return None
    
    c = g.app.config.openSettingsFile(path)

    if not c:
        return None
    elif g.findNodeAnywhere(c,'@settings'):
        return c
    else:
        self.error('no @settings node in %s' % path)
        return None&lt;/t&gt;
&lt;t tx="ekr.20060626085103.45"&gt;def update (self):

    c = self.c
    c1 = self.open(self.path1)
    c2 = self.open(self.path2)
    g.app.log = c.frame.log
    if not c1 or not c2: return
    # Update c2 from settings in c1.
    d1 = updateParser(c1,'1').traverse()
    d2 = updateParser(c2,'2').traverse()
    changed = False
    for key in d1.keys():
        b1 = d1.get(key) # A bunch created by set or None.
        b2 = d2.get(key) # A bunch created by set or None.
        if key not in d2.keys():
            self.message('%7s %s = %s' % ('added',b1.name,b1.val))
            self.add(b1,c1,c2) ; changed = True
        elif b1.val == b2.val:
            pass # ; self.message('%7s %40s %s' % ('equal',b1.name,b1.val))
        else:
            self.message('%7s %s from %s to %s' % ('changed',b1.name,b2.val,b1.val))
            self.change(b1,b2) ; changed = True
    if changed:
        c2.save()
    self.message('update settings done')&lt;/t&gt;
&lt;t tx="ekr.20060626085103.46"&gt;event = g.Bunch(widget=g.app.gui.get_focus(c),char='',keysym='')

c.editFileCommands.openOutlineByName(event)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.47"&gt;import Tkinter as Tk
@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.48"&gt;class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others&lt;/t&gt;
&lt;t tx="ekr.20060626085103.49"&gt;def __init__ (self,c):
    self.c = c
    
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")&lt;/t&gt;
&lt;t tx="ekr.20060626085103.50"&gt;def getAllClones(self,p):

    return [p2.copy() for p2 in self.c.allNodes_iter() if p2.v.t == p.v.t]&lt;/t&gt;
&lt;t tx="ekr.20060626085103.51"&gt;def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &amp;lt;&amp;lt;Fill listbox with clone parent headlines&amp;gt;&amp;gt;    
    &amp;lt;&amp;lt;Goto selected position when listbox selection changes&amp;gt;&amp;gt;
&lt;/t&gt;
&lt;t tx="ekr.20060626085103.52"&gt;# Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&amp;lt;top level&amp;gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.53"&gt;# Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):

    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return

self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.55"&gt;import doctest
import os

# create temporary file and write this node subtree to it
file, filename = g.create_temp_file()
c.importCommands.flattenOutline(filename)
# the file is now created and closed

# prepare content for testing
# strip trailing whitespace, an annoying source of doctest failures
text = open(filename).readlines()
text = [line.strip() for line in text]
text = "\n".join(text)

# run doctest on temporary file
file.write(text)
file.close()
# g.es(filename)
failures, tests = doctest.testfile(filename, module_relative = False)
os.remove(filename)

# report summary of results in Leo
if failures == 0:
    g.es("%s tests run successfully" % tests, color="blue")
if failures == 1:
    g.es("There was one failure in %s tests" % tests, color="red")    
if failures &amp;gt; 1:
    g.es("%s failures in %s tests" % (failures, tests), color="red")&lt;/t&gt;
&lt;t tx="ekr.20060626085103.56"&gt;target = r'c:\prog\tigris-cvs\leo\src\leo.py'

c.debugCommands.debug(target=target)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.57"&gt;c.debugCommands.debug()&lt;/t&gt;
&lt;t tx="ekr.20060626085103.58"&gt;# Delete a body pane editor.

c.frame.body.deleteEditor()&lt;/t&gt;
&lt;t tx="ekr.20060626085103.59"&gt;# Cycle focus through body pane editors.

c.frame.body.cycleEditorFocus()
g.app.gui.set_focus(c,c.frame.body.bodyCtrl)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.60"&gt;# Add a body editor.

c.frame.body.addEditor()
g.app.gui.set_focus(c,c.frame.body.bodyCtrl)&lt;/t&gt;
&lt;t tx="ekr.20060626085103.61"&gt;import leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        controller.processTopTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True&lt;/t&gt;
&lt;t tx="ekr.20060626085246"&gt;# You can run all tests by selecting the Unit Test headline.

import leoTest

leoTest.doTests(c,all=False)&lt;/t&gt;
&lt;t tx="ekr.20060914121042"&gt;chapter_hoist.py
cleo.py
vim.py
word_export.py
xemacs.py&lt;/t&gt;
&lt;t tx="ekr.20060914121042.1"&gt;import leoPlugins

plugin = leoPlugins.loadOnePlugin ('leo_to_html')

plugin.export_html(c)&lt;/t&gt;
&lt;t tx="ekr.20060914123717"&gt;import leoPlugins

plugin = leoPlugins.loadOnePlugin ('leo_to_rtf')

plugin.export_rtf(c)&lt;/t&gt;
&lt;t tx="ekr.20060914123949"&gt;import leoPlugins

if not leoPlugins.isLoaded('chapter_hoist'):

    plugin = leoPlugins.loadOnePlugin ('chapter_hoist',verbose=True)
    plugin.onCreate(tag='unit-test',keys={'c':c})
&lt;/t&gt;
&lt;t tx="ekr.20060914125424"&gt;import leoPlugins

if not leoPlugins.isLoaded('mod_scripting'):

    plugin = leoPlugins.loadOnePlugin ('mod_scripting',verbose=True)
    plugin.onCreate(tag='unit-test',keys={'c':c})&lt;/t&gt;
&lt;t tx="ekr.20060914125710"&gt;import leoPlugins

if not leoPlugins.isLoaded('open_with'):

    plugin = leoPlugins.loadOnePlugin ('open_with',verbose=True)
    plugin.create_open_with_menu(tag='unit-test',keyswords={'c':c})&lt;/t&gt;
&lt;t tx="ekr.20060914130213"&gt;import leoPlugins

if not leoPlugins.isLoaded('rst3'):

    plugin = leoPlugins.loadOnePlugin ('rst3',verbose=True)
    plugin.onCreate(tag='unit-test',keywords={'c':c})&lt;/t&gt;
&lt;t tx="ekr.20060914130545"&gt;import leoPlugins

if not leoPlugins.isLoaded('UNL'):

    plugin = leoPlugins.loadOnePlugin ('UNL',verbose=True)
    plugin.createStatusLine(tag='unit-test',keywords={'c':c})&lt;/t&gt;
&lt;t tx="ekr.20060914130924"&gt;import leoPlugins

if not leoPlugins.isLoaded('paste_as_headlines'):

    plugin = leoPlugins.loadOnePlugin ('paste_as_headlines',verbose=True)
    plugin.createPasteAsHeadlinesMenu(tag='unit-test',keywords={'c':c})&lt;/t&gt;
&lt;t tx="ekr.20061023080533"&gt;&lt;/t&gt;
&lt;t tx="ekr.20061023080533.1"&gt;workBody = '''first line
line 1
    line a
        line b
line c
last line
'''

c.beginUpdate()
try:
    p1 = p.insertAfter()
    c.setHeadString(p1,'@test ')
    body = 'import leoTest\nleoTest.runEditCommandTest(c,p)'
    c.setBodyString(p1,body)
    for s in ('work','before','after'):
        p2 = p1.insertAsLastChild()
        c.setHeadString(p2,s)
        if s == 'work':
            c.setBodyString(p2,workBody)
    p1.expand()
finally:
    c.endUpdate()
    c.editPosition(p1)&lt;/t&gt;
&lt;t tx="ekr.20061023080533.2"&gt;@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. The work node should have body text. If all is as expected,
copy the body text the work node to the before node, and represent the selection
range of the work in the headline of the before node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top and work.bodyString():
    c.beginUpdate()
    try:
        c.setBodyString(before,work.bodyString())
        c.setBodyString(after,'')
        putSelectionInHeadline(c,before,'before',sel)
    finally:
        c.endUpdate()
else:
    g.es_print('do-before: not in a proper @test tree')&lt;/t&gt;
&lt;t tx="ekr.20061023080533.3"&gt;def getSel(c):
    
    w = c.frame.body.bodyCtrl
    sel = g.app.gui.getSelectionRange(w)
    if not sel:
        i = g.app.gui.getInsertPoint(w)
        sel = (i,i)
    return sel&lt;/t&gt;
&lt;t tx="ekr.20061023080533.4"&gt;def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.headString().startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild() 
    before = work and work.next()     
    after  = before and before.next()
    if (
        work   and work.headString().startswith('work') and
        before and before.headString().startswith('before') and
        after  and after.headString().startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None&lt;/t&gt;
&lt;t tx="ekr.20061023080533.5"&gt;def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.headString(),repr(sel))
    
    if not sel:
        sel = ('1.0','1.0')

    s = '%s sel=%s,%s' % (prefix,sel[0],sel[1])

    c.setHeadString(p,s)
    
    &lt;/t&gt;
&lt;t tx="ekr.20061023080533.6"&gt;@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. If all is as expected, copy the work node to the after node,
and represent the selection range of the work node in the headline of the after node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top:
    c.beginUpdate()
    try:
        c.setBodyString(after,work.bodyString())
        putSelectionInHeadline(c,after,'after',sel)
    finally:
        c.endUpdate()
else:
    g.es_print('do-after: not in @test tree')&lt;/t&gt;
&lt;t tx="ekr.20061023080533.7"&gt;def getSel(c):
    
    w = c.frame.body.bodyCtrl
    sel = g.app.gui.getSelectionRange(w)
    if not sel:
        i = g.app.gui.getInsertPoint(w)
        sel = (i,i)
    return sel&lt;/t&gt;
&lt;t tx="ekr.20061023080533.8"&gt;def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.headString().startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild()
    before = work and work.next()
    after  = before and before.next()
    if (
        work   and work.headString().startswith('work') and
        before and before.headString().startswith('before') and
        after  and after.headString().startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None&lt;/t&gt;
&lt;t tx="ekr.20061023080533.9"&gt;def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.headString(),repr(sel))
    
    if not sel:
        sel = ('1.0','1.0')

    s = '%s sel=%s,%s' % (prefix,sel[0],sel[1])

    c.setHeadString(p,s)
    
    &lt;/t&gt;
&lt;t tx="ekr.20061023080533.10"&gt;import leoTest
leoTest.runEditCommandTest(c,p)&lt;/t&gt;
&lt;t tx="ekr.20061023080533.11"&gt;line 1
line 3&lt;/t&gt;
&lt;t tx="ekr.20061023080533.12"&gt;line 1
line 2
line 3&lt;/t&gt;
&lt;t tx="ekr.20061023080533.13"&gt;line 1
line 3&lt;/t&gt;
&lt;t tx="ekr.20061023111426"&gt;&amp;lt;&amp;lt; define aList &amp;gt;&amp;gt;

workBody = '''first line
line 1
    line a
        line b
line c
last line
'''

c.beginUpdate()
try:
    for h in aList:
        p1 = p.insertAfter()
        c.setHeadString(p1,'@test %s' % (h))
        body = 'import leoTest\nleoTest.runEditCommandTest(c,p)'
        c.setBodyString(p1,body)
        for s in ('work','before','after'):
            p2 = p1.insertAsLastChild()
            c.setHeadString(p2,s)
            if s == 'work':
                c.setBodyString(p2,workBody)
        # p1.expand()
finally:
    c.endUpdate()
    # c.editPosition(p1)&lt;/t&gt;
&lt;t tx="ekr.20061023111426.1"&gt;aList = (
    'back-char',
    'back-char-extend-selection',
    'back-paragraph',
    'back-paragraph-extend-selection',
    'back-sentence',
    'back-sentence-extend-selection',
    'back-word',
    'back-word-extend-selection',
    'backward-delete-char',
    'backward-kill-paragraph',
    'backward-find-character',
    'backward-find-character-extend-selection',
    'beginning-of-buffer',
    'beginning-of-buffer-extend-selection',
    'beginning-of-line',
    'beginning-of-line-extend-selection',
    'capitalize-word',
    'center-line',
    'center-region',
    'clean-lines',
    'clear-selected-text',
    'count-region',
    'dabbrev-completion',
    'dabbrev-expands',
    'delete-char',
    'delete-editor',
    'delete-indentation',
    'delete-spaces',
    'do-nothing',
    'downcase-region',
    'downcase-word',
    'end-of-buffer',
    'end-of-buffer-extend-selection',
    'end-of-line',
    'end-of-line-extend-selection',
    'exchange-point-mark',
    'extend-to-line',
    'extend-to-paragraph',
    'extend-to-sentence',
    'extend-to-word',
    'fill-paragraph',
    'fill-region',
    'fill-region-as-paragraph',
    'flush-lines',
    'forward-char',
    'forward-char-extend-selection',
    'forward-paragraph',
    'forward-paragraph-extend-selection',
    'forward-sentence',
    'forward-sentence-extend-selection',
    'forward-word',
    'forward-word-extend-selection',
    'goto-char',
    'how-many',
    'indent-relative',
    'indent-rigidly',
    'indent-to-comment-column',
    'insert-newline',
    'insert-parentheses',
    'keep-lines',
    'kill-paragraph',
    'move-lines-down',
    'move-lines-up',
    'move-past-close',
    'move-past-close-extend-selection',
    'newline-and-indent',
    'next-line',
    'next-line-extend-selection',
    'previous-line',
    'previous-line-extend-selection',
    'remove-blank-lines',
    'remove-space-from-lines',
    'remove-tab-from-lines',
    'reverse-region',
    'sort-columns',
    'sort-fields',
    'sort-lines',
    'split-line',
    'tabify',
    'transpose-chars',
    'transpose-lines',
    'transpose-words',
    'untabify',
    'upcase-region',
    'upcase-word',
)&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;
</t>
<t tx="ekr.20071105090148.352">@language python
@tabwidth -4
@encoding utf-8</t>
<t tx="ekr.20071105090148.353">@language python
@tabwidth -4
@others


</t>
<t tx="ekr.20071105090148.354">﻿# A test of unicode characters  Ä, ڱ,  궯, 奠 end.
</t>
<t tx="ekr.20071105090148.355"></t>
<t tx="ekr.20071211113237"></t>
<t tx="ekr.20071211113302.2"></t>
<t tx="ekr.20071211113302.3"></t>
<t tx="ekr.20071211113302.4"></t>
<t tx="ekr.20071211113302.5">def loadHandlers(tag):

    """Load all enabled plugins from the plugins directory"""

    def pr (*args,**keys):
        if not g.app.unitTesting:
            g.es_print(*args,**keys)

    plugins_path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_abspath(theFile) for theFile in files]

    s = g.app.config.getEnabledPlugins()
    if not s: return

    if not g.app.silentMode:
        pr('@enabled-plugins found in %s' % (
            g.app.config.enabledPluginsFileName),color='blue')

    enabled_files = getEnabledFiles(s,plugins_path)

    # Load plugins in the order they appear in the enabled_files list.
    if files and enabled_files:
        for theFile in enabled_files:
            if theFile in files:
                loadOnePlugin(theFile)

    # Note: g.plugin_signon adds module names to g.app.loadedPlugins
    if 0:
        if g.app.loadedPlugins:
            pr("%d plugins loaded" % (len(g.app.loadedPlugins)), color="blue")
</t>
<t tx="ekr.20071211113302.6">def getEnabledFiles (s,plugins_path):

    enabled_files = []
    disabled_files = []
    for s in g.splitLines(s):
        s = s.strip()
        if s:
            if g.match(s,0,"#"):
                s = s[1:].strip()
                # Kludge: ignore comment lines containing a blank or not ending in '.py'.
                if s and s.find(' ') == -1 and s[-3:] == '.py':
                    path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                    if path not in enabled_files and path not in disabled_files:
                        # print 'disabled',path
                        disabled_files.append(path)
            else:
                path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                if path not in enabled_files and path not in disabled_files:
                    # print 'enabled',path
                    enabled_files.append(path)

    return enabled_files</t>
<t tx="ekr.20071211113302.7"></t>
<t tx="ekr.20071211113302.8">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3768494
By: ktenney

I'm using current CVS, W2k

1 open a Leo file (I'm using a batch file / console)

2 click Edit-&gt;Open   &lt;-- Having this dialog open is the problem.

3 return focus to the Leo window

4 click Help-&gt;Open leoDocs.leo

Zombie!

@color</t>
<t tx="ekr.20071211113302.9">command_count = 0

def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""

    c = self ; p = c.currentPosition()
    commandName = command and command.__name__
    c.setLog()

    self.command_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_doCommand'):
        g.trace(commandName)

    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if c.exists and c.inCommand and not g.unitTesting:
        # g.trace('inCommand',c)
        g.es('Ignoring command: already executing a command.',color='red')
        return 'break'

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            c.inCommand = True
            val = command(event)
            if c and c.exists: # Be careful: the command could destroy c.
                c.inCommand = False
                c.k.funcReturn = val
            # else: print 'c no longer exists',c
        except:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            else:
                g.es("exception executing command")
                print "exception executing command"
                g.es_exception(c=c)
                if c and c.exists and hasattr(c,'frame'):
                    c.redraw_now()

        if c and c.exists and c.requestCloseWindow:
            g.trace('Closing window after command')
            c.requestCloseWindow = False
            g.app.closeLeoWindow(c.frame)

    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)

    return "break" # Inhibit all other handlers.
</t>
<t tx="ekr.20071211113302.10"># We no longer specify default extensions so that we can open and save files without extensions.
</t>
<t tx="ekr.20071211113302.11">def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""

    # __pychecker__ = '--no-argsused' # defaultextension not used.

    initialdir = g.app.globalOpenDir or g.os_path_abspath(os.getcwd())

    if multiple:
        # askopenfilenames requires Python 2.3 and Tk 8.4.
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        if (
            g.CheckVersion(version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(
                title=title,filetypes=filetypes,initialdir=initialdir)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(
                title=title,filetypes=filetypes,initialdir=initialdir)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(
            title=title,filetypes=filetypes,initialdir=initialdir)
</t>
<t tx="ekr.20071211113302.12">def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""

    # __pychecker__ = '--no-argsused' # defaultextension not used.

    initialdir=g.app.globalOpenDir or g.os_path_abspath(os.getcwd()),

    return tkFileDialog.asksaveasfilename(
        initialdir=initialdir,initialfile=initialfile,
        title=title,filetypes=filetypes)
</t>
<t tx="ekr.20071211113302.13">http://sourceforge.net/forum/message.php?msg_id=3525277</t>
<t tx="ekr.20071211113302.14">@nocolor

Vampire nodes from cvs

I've just discovered a major problem with cvs updates.  It is a subtle consequence of how Leo writes outlines and reads derived files.  This is a big bug in Leo, not cvs.  The effect of the bug is that nodes can appear in derived files that were never written to them!

The discovery of this 'big bug' came about as the result of the following Aha:

**@thin files that contain @all directives should be a cvs binary (-kb) files.**

The reason is straightforward:  cvs doesn't know enough to merge such files.  Maybe all @thin derived files should be -kb files, but Leo's users will never agree to that!

Anyway, leoProjects.txt is now a binary file as far as cvs is concerned.  Other .txt files, like leoScripts.txt, should also be binary files.  As we shall see, the fact that leoProjects.txt is now a -kb file means that we can not possibly blame the cvs merge algorithm for what is about to happen.

Ok, back to the 'big bug'.  Here is how I got bitten:

- I changed leoProjects.txt in two sandboxes 1 and 2.  In sandbox 1 I added a node called 'changed in the main line'.  In sandbox 2 I added a node called 'changed2'.

- I changed LeoPyRef.leo in sandbox 2, but *not* in sandbox 1.

- I did a update in sandbox 2.

As expected (now that leoProjects.txt is a binary file) I got the following from cvs:

M src/LeoPyRef.leo
...
cvs update: nonmergeable file needs merge
cvs update: revision 1.448 from repository is now in src/leoProjects.txt
cvs update: file from working directory is now in .#leoProjects.txt.1.447

To summarize the update:

- LeoPyRef.leo has been marked as modified (M), but it has **not** been changed by cvs.

- As expected, leoProjects.txt contains the version from sandbox **1**.

So far, so good.  But when I opened LeoPyRef.leo I got a huge surprise: the outline contains **both** the node 'changed in main-line' and the node 'changed2'.  Whoa Nellie!

How did this happen?  Well, obviously the 'changed in main-line' node came from the cvs update.  I expected that.  The 'changed2' line must have come from the local copy of LeoPyRef.leo.

Once I knew what to look for it wasn't too hard to discover what had happened.  The 'changed2' is a descendent of a cloned node called '4.4 projects'.

- One clone of '4.4 projects' node is a descendent of the @thin leoProjects.txt node.

- Another clone of the '4.4 project' is in the LeoPyRef.leo file but outside of any @thin node.

So the 'resurrection' of the 'changed2' node happened while Leo was reading leoProjects.txt into LeoPyRef.leo.  The '4.4 projects' node **already existed in the outline** before Leo read leoProjects.txt, and the present atFile read logic only **adds** nodes, it never deletes nodes.  Thus, the 'changed2' node 'survived' the atFile read logic.  The 'changed2' node became a 'vampire' node that couldn't be killed.

The problem is far from benign.  Because of clones, the vampire node became an orphan node in **another** file, namely leoKeys.py.  I tried two or three times to remove the vampire/orphan node before realizing what had happened.

The fix (there is *always* a fix) will require some care.  The present atFile.read logic is robust because it *doesn't* delete nodes.  It is essential that the read logic remain robust.  I suspect the solutions will be as follows:

A. The atFile.read code can not delete the subtree of @thin nodes initially, because it doesn't know whether there will be read errors later.  If there are read errors absolutely nothing must change.  This ensures that read errors never destroy information.

B. A new post-pass will look for vampire nodes: nodes that were not actually read from the derived file.  I think (but haven't proven) that all descendents of vampire nodes are also vampire nodes.  If that is so the post-pass will simply delete vampire nodes without worrying about whether they have descendents.

Warning: the new scheme will mean that cvs update can destroy information that previously existed in the outline.  I believe this is correct: we assume that derived files are the 'truly meaningful' files.  Hey, if we are wrong we can always get the old info from cvs :-)

Edward
</t>
<t tx="ekr.20071211113302.15">@nocolor


The atFile read logic only **adds** nodes, it never deletes nodes. Thus,
the 'changed2' node 'survived' the atFile read logic. The 'changed2' node became
a 'vampire' node that couldn't be killed.

The fix will require some care. The present atFile.read logic is robust because
it *doesn't* delete nodes. I suspect the solutions will be as follows:

A. The atFile.read code can not delete the subtree of @thin nodes initially,
because it doesn't know whether there will be read errors later. If there are
read errors absolutely nothing must change. This ensures that read errors never
destroy information.

B. A new post-pass will look for vampire nodes: nodes that were not actually
read from the derived file. I think (but haven't proven) that all descendents of
vampire nodes are also vampire nodes. If that is so the post-pass will simply
delete vampire nodes without worrying about whether they have descendents.
</t>
<t tx="ekr.20071211113302.16">@nocolor

1. createThinChild4 and findChild4 now set the visited bits for all found or
created nodes.

2. read now warns about 'ressurected' nodes for all the file types that read
handles, namely @file, @thin and @noref.

This should be a safe solution.  The user can choose at leisure what to do.</t>
<t tx="ekr.20071211113302.17"># The caller must enclose this code in beginUpdate/endUpdate.
# Reads @thin, @file and @noref trees.

def read(self,root,importFileName=None,thinFile=False,fromString=None):

    """Read any derived file."""

    at = self ; c = at.c
    if 0:
        p = c.currentPosition()
        g.trace('1',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    &lt;&lt; set fileName &gt;&gt;
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    if not g.unitTesting:
        g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    if 0:
        p = c.currentPosition()
        g.trace('2',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        &lt;&lt; advise user to delete all unvisited nodes &gt;&gt;
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    &lt;&lt; delete all tempBodyStrings &gt;&gt;
    return at.errors == 0
</t>
<t tx="ekr.20071211113302.18">if fromString:
    fileName = "&lt;string-file&gt;"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
</t>
<t tx="ekr.20071211113302.19">for p in c.allNodes_iter():

    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
</t>
<t tx="ekr.20071211113302.20">resurrected = 0
for p in root.self_and_subtree_iter():

    if not p.v.t.isVisited():
        g.es('resurrected node: %s' % (p.headString()),color='blue')
        g.es('in file: %s' % (fileName),color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

</t>
<t tx="ekr.20071211113302.21">def createThinChild4 (self,gnxString,headline):

    """Find or create a new *vnode* whose parent (also a vnode) is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)

    # New in Leo 4.4a5: Solve Read @file nodes problem (by LeoUser)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove(last)

    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)

    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            last.t.setVisited() # Supress warning/deletion of unvisited nodes.
            return last
        if child:
            child.t.setVisited() # Supress warning/deletion of unvisited nodes.
            return child
        copies = 1 # Create exactly one copy.

    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert indices.areEqual(t.fileIndex,gnx), 't.fileIndex: %s gnx: %s' % (t.fileIndex,gnx)
            # g.trace('not created, should already exist',gnxString)
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    child.t.setVisited() # Supress warning/deletion of unvisited nodes.
    return child
</t>
<t tx="ekr.20071211113302.22">def findChild4 (self,headline):

    """Return the next tnode in at.root.t.tnodeList."""

    # __pychecker__ = '--no-argsused' # headline might be used for debugging.

    # Note: tnodeLists are used _only_ when reading @file (not @thin) nodes.
    # tnodeLists compensate (a hack) for not having gnx's in derived files! 

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None

    if at.tnodeListIndex &gt;= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None

    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except Exception:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None

    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning/deletion of unvisited nodes.
    return t
</t>
<t tx="ekr.20071211113302.23">@nocolor

From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

** Also, no ignore inserted.

Current CVS, ubuntu

From the code below I get:

reading: /mnt/removable/bkup_proj/Mammals/mammaldb/mammaldb.leo
*** first mismatch at line 119
original line:      def provide(self, what):
generated line: def provide(self, what):
@auto did not import the file perfectly
first mismatched line: 119
u'def provide(self, what):\n'
inserting @ignore
Errors inhibited read
@auto /mnt/removable/bkup_proj/Mammals/mammaldb/mammalShow.py

In the code below line 119 is not the first "def provide(self, what):"
but the second, the one in class mainPages - I've included the preceding
class def because context seems to be important.

@color</t>
<t tx="ekr.20071211113302.24">class mammalProviderBase(object):
    """Root class for content providers used by DWEtree.py"""
    def __init__(self, params):
        """store reference to parameters"""
        self.params = params
    def provide(self, what):
        """default &lt;BASE&gt; value"""
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/'])
        return None

    def imagePath(self, sppdat):
        """return path to images and list of images for *species*"""
        path = 'MNMammals/imglib/Mammalia'
        for i in 'Order', 'Family', 'Genus', 'Species':
            path = os.path.join(path, sppdat['%sName' % (i,)])
        imglib = os.path.join('/var/www',path)
        imglib = os.path.join(imglib, '*.[Jj][Pp][Gg]')
        path = os.path.join('/',path)
        lst = [os.path.split(i)[1] for i in glob.glob(imglib)]
        lst.sort()
        return path, lst

class mainPages(mammalProviderBase):
    """provide content for pages in 'main' folder"""
    __parent = mammalProviderBase
    def provide(self, what):
        """add one layer to &lt;BASE&gt;"""
        ans = self.__parent.provide(self, what)
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/']+'main/')
        return ans
</t>
<t tx="ekr.20071211113302.25">def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    # g.trace(fileName)

    if not g.unitTesting:
        g.es("reading: " + p.headString())

    # Delete all children.
    c.beginUpdate()
    try:
        while p.hasChildren():
            p.firstChild().doDelete()
    finally:
        c.endUpdate(False)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('Errors inhibited read @auto %s' % (fileName),color='red')

    if ic.errors or not g.os_path_exists(fileName):
        #c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
</t>
<t tx="ekr.20071211113302.26">def putClass (self,s,i,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        self.sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    # Remember the indentation of the class line.
    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,bodyIndent,classDelim,decls,trailing = self.putClassHelper(s,i,codeEnd,class_node)
    # g.trace('bodyIndent',bodyIndent,'undentVal',undentVal)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name) or ''

    # Give ref the same indentation as the body of the class.
    if ref:
        bodyWs = g.computeLeadingWhitespace (bodyIndent,self.tab_width)
        ref = '%s%s' % (bodyWs,ref)

    # Remove the leading whitespace.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        self.undentBy(decls,undentVal) +
        self.undentBy(ref,undentVal) +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
</t>
<t tx="ekr.20071211113302.27">def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
</t>
<t tx="ekr.20071211113302.28">def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
</t>
<t tx="ekr.20071211113302.29">def getClassNodeRef (self,class_name):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    return '%s\n' % (s)
</t>
<t tx="ekr.20071211113302.30">def putClassHelper(self,s,i,end,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    j = i ; i = self.skipDecls(s,i,end,inClass=True)
    decls = s[j:i]

    # Set the body indent if there are real decls.
    bodyIndent = decls.strip() and self.getIndent(s,i) or None

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,bodyIndent2 = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,bodyIndent2 = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    if bodyIndent is None: bodyIndent = bodyIndent2

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,bodyIndent,classDelim,decls,trailing
</t>
<t tx="ekr.20071211113302.31">def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    # g.trace(g.callers())
    # g.trace('i',i,g.get_line(s,i))
    assert kind in ('class','outer')
    start = i ; putRef = False ; bodyIndent = None
    while i &lt; end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd &amp; codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd &amp; codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i)
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
            # Bug fix: 2007/11/8: do *not* set start: we are just skipping the block.
        else: i += 1
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,bodyIndent
</t>
<t tx="ekr.20071211113302.32">def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.

    The decls *must* end in a newline.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    if trace: g.trace(g.callers())
    while i &lt; end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsFunction(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            if self.outerBlockEndsDecls:
                break
            else:
                i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else:
            i += 1 ;  prefix = None
        assert(progress &lt; i)

    if prefix is not None:
        i = g.find_line_start(s,prefix) # i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
</t>
<t tx="ekr.20071211113302.33">@nocolor

In the following code:

extern  "C"
{
#include "stuff.h"
void    init(void);
#include "that.h"
}

produces the following in the log window:

Leo Log Window...
Leo 4.4.4 final, build  1.216 , November 2, 2007
Python 2.5.1, Tk 8.4.14, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

leoID = rshanley (in C:\)
global config dir: C:\Program Files\Leo\config
home dir: C:\
reading settings in C:\Program Files\Leo\config\leoSettings.leo
*** first mismatch at line 2
original line:  {
generated line:
import command did not import the file perfectly
first mismatched line: 2
u'\n'
input...
  0 extern  "C"
  1 {
  2 #include "stuff.h"
  3 void    init(void);
  4 #include "that.h"
  5 }
output...
  0 extern  "C"
  1
inserting @ignore
imported C:/test/aa.cc

@color</t>
<t tx="ekr.20071211113302.34">def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Init the parser status ivars.
    self.methodsSeen = False

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start &lt; len(s):
        self.c.appendStringToBody(parent,s[start:]) 
</t>
<t tx="ekr.20071211113302.35">def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i &lt; len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent &lt; startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level &lt;= 0:
                if trace: g.trace('returns\n',repr(s[start:i]))
                return i

        else: i += 1
        assert progress &lt; i

    self.error('no block')
    if 1:
        i,j = g.getLine(s,start)
        g.trace(s[max(0,i-20):i+20])
    if trace: g.trace('** no block')
    return start
</t>
<t tx="ekr.20071211113302.36">@nocolor

http://sourceforge.net/forum/forum.php?thread_id=1865290&amp;forum_id=10226

@bool at_auto_warns_about_leading_whitespace

@color</t>
<t tx="ekr.20071211113302.37"></t>
<t tx="ekr.20071211113302.38"></t>
<t tx="ekr.20071211113302.39">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4464649
By: terry_n_brown

An argument I'm always having with leo has to do with its conversion of file
paths to 'absolute' forms.

In the file browser I select '/home/tbrown/misc/foo.leo'.
Leo reinterprets this as '/media/hda2/usr1/home/tbrown/misc/foo.leo'

Then I switch machines, and while
'/home/tbrown/misc/foo.leo' would still be valid,
'/media/hda2/usr1/home/tbrown/misc/foo.leo' isn't - on the other machine it
would be '/media/hdb1/home/tbrown/misc/foo.leo'.

I end up with the two entries in recent files, having to identify the right one.

If the Tk dialog is returning '/home/tbrown/misc/foo.leo', which I assume it is
because that's what it's displaying, I wish leo would use and store that.
</t>
<t tx="ekr.20071211113302.40">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4615094
By: terry_n_brown

cvs&gt; python leo/src/leo.py
Traceback (most recent call last):
  File "leo/src/leo.py", line 409, in &lt;module&gt;
    run()
  File "leo/src/leo.py", line 115, in run
    fileName,relativeFileName = completeFileName(fileName)
TypeError: 'NoneType' object is not iterable

["cvs&gt;" above just indicates the shell is in a dir. called cvs, btw]

So it doesn't start unless you specify a file name.  I started it like this:

python leo/src/leo.py ~/myLeoSettings.leo

which worked ok, then after opening /home/tbrown/.tnb.leo and /home/tbrown/tmp.leo
using File -&gt; Open... the top of /home/tbrown/.leoRecentFiles.txt looks like
this:

/home/tbrown/myLeoSettings.leo
/mnt/removable/bkup_usr1/home/tbrown/tmp.leo
/mnt/removable/bkup_usr1/home/tbrown/.tnb.leo

so it seemed to work for the file loaded from the command line, but not from
File -&gt; Open...

@color</t>
<t tx="ekr.20071211113302.41">@nocolor

What I did:

- Added relativeFileName keyword arg to newLeoCommanderAndFrame
- Added c.mRelativeFileName ivar.
- Added c.relativeFileName() method.
- clear-recent-files now writes .leoRecentFiles.txt immediately.
- updateRecentFiles now clears both the relative and absolute version of the path.
</t>
<t tx="ekr.20071211113302.42">def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()</t>
<t tx="ekr.20071211113302.43">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="ekr.20071211113302.44">def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))
    # g.trace(relativeFileName,'--&gt;',fileName)

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        gui=gui)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by menu.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        if k: k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame</t>
<t tx="ekr.20071211113302.45">def updateRecentFiles (self,fileName):

    """Create the RecentFiles menu.  May be called with Null fileName."""

    if g.app.unitTesting: return

    def munge(name):
        return g.os_path_normpath(name or '').lower()
    def munge2(name):
        return g.os_path_abspath(g.os_path_join(g.app.loadDir,name or ''))

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if munge(fileName) == munge(name) or munge2(fileName) == munge2(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace('adding',fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
</t>
<t tx="ekr.20071211113302.46">def run(fileName=None,pymacs=None,jyLeo=False,*args,**keywords):

    """Initialize and run Leo"""

    # __pychecker__ = '--no-argsused' # keywords not used.

    # print 'leo.py:run','fileName',fileName
    if not jyLeo and not isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    adjustSysPath(g)
    if pymacs:
        script = windowFlag = False
    else:
        script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.batchMode = script is not None
    g.app.silentMode = '-silent' in sys.argv or '--silent' in sys.argv
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName,relativeFileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif jyLeo:
        import leoSwingGui
        g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
</t>
<t tx="ekr.20071211113302.47">if jyLeo:

    print '*** starting jyLeo',sys.platform # will be something like java1.6.0_02

    ### This is a hack.
    ### The jyleo script in test.leo sets the cwd to g.app.loadDir
    ### Eventually, we will have to compute the equivalent here.

    path = os.path.join(os.getcwd()) ### ,'..','src')
    if path not in sys.path:
        print 'appending %s to sys.path' % path
        sys.path.append(path)
    if 0:
        print 'sys.path...'
        for s in sys.path: print s

# Import leoGlobals, but do NOT set g.
import leoGlobals
import leoApp

# Create the app.
leoGlobals.app = leoApp.LeoApp()

# **now** we can set g.
g = leoGlobals
assert(g.app)

if jyLeo:
    startJyleo(g)
</t>
<t tx="ekr.20071211113302.48">import leoNodes
import leoConfig

# try:
    # import leoNodes
# except ImportError:
    # print "Error importing leoNodes.py"
    # import traceback ; traceback.print_exc()

# try:
    # import leoConfig
# except ImportError:
    # print "Error importing leoConfig.py"
    # import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20071211113302.49"></t>
<t tx="ekr.20071211113302.50">def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    &lt;&lt; compute the window title &gt;&gt;

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName,relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    if updateRecentFiles:
        c.updateRecentFiles(relativeFileName or fileName)

    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
</t>
<t tx="ekr.20071211113302.51"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
</t>
<t tx="ekr.20071211113302.52">def completeFileName (fileName):

    import leoGlobals as g

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    fileName = g.os_path_join(os.getcwd(),fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
</t>
<t tx="ekr.20071211113302.53">def createFrame (fileName,relativeFileName):

    """Create a LeoFrame during Leo's startup process."""

    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if frame.c.chapterController:
        frame.c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
</t>
<t tx="ekr.20071211113302.54">def createFrame (self,fileName):

    '''Create a commander and frame for the given file.
    Create a new frame if the fileName is empty or non-exisent.'''

    g = self.g

    if fileName.strip():
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok: return frame.c
        else: g.es("File not found %s, creating new window: " % fileName)

    # Create a new frame. Unlike leo.run, this is not a startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)
    return c
</t>
<t tx="ekr.20071211113302.55">def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
</t>
<t tx="ekr.20071211113302.56">def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
</t>
<t tx="ekr.20071211113302.57">def readOutlineOnly (self,event=None):

    '''Open a Leo outline from a .leo file, but do not read any derived files.'''

    fileName = g.app.gui.runOpenFileDialog(
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if not fileName:
        return

    try:
        theFile = open(fileName,'r')
        c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
        frame.deiconify()
        frame.lift()
        g.app.root.update() # Force a screen redraw immediately.
        c.fileCommands.readOutlineOnly(theFile,fileName) # closes file.
    except:
        g.es("can not open:" + fileName)
</t>
<t tx="ekr.20071211113302.58">def run_script(c,script,p=None):

    # It is possible to use script=None, in which case p must be defined.

    init()

    if c is None:
        c,frame = g.app.newLeoCommanderAndFrame(fileName='dummy script file')

    g.app.scriptResult = None

    c.executeScript(
        event=None,
        p=p,
        script=script,
        useSelectedText=False,
        define_g=True,
        define_name='__main__',
        silent=True,  # Don't write to the log.
    )

    # g.trace('script returns: ',repr(g.app.scriptResult))
    return g.app.scriptResult</t>
<t tx="ekr.20071211113302.59"></t>
<t tx="ekr.20071211113302.60">def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
</t>
<t tx="ekr.20071211113302.61">def openRecentFile(self,name=None):

    if not name: return

    c = self ; v = c.currentVnode()
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = name
    if not g.doHook("recentfiles1",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag):
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame) # 12/12/03
            c = frame.c # Switch to the new commander so the "recentfiles2" hook doesn't crash.
            c.setLog() # Sets the log stream for g.es()

    g.doHook("recentfiles2",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
</t>
<t tx="ekr.20071211113302.62">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="ekr.20071211113302.63">def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeDir second.
    if configDir == loadDir:
        g.es("%s not found in %s" % (name,configDir))
    else:
        fileName = g.os_path_join(homeDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es("%s not found in %s or %s" % (name,configDir,homeDir))
</t>
<t tx="ekr.20071211113302.64">def openLeoScripts (self,event=None):

    c = self
    fileName = g.os_path_join(g.app.loadDir,'..','scripts','scripts.leo')

    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es('not found: %s' % fileName)
</t>
<t tx="ekr.20071211113302.65">def leoDocumentation (self,event=None):

    '''Open LeoDocs.leo in a new Leo window.'''

    c = self ; name = "LeoDocs.leo"

    fileName = g.os_path_join(g.app.loadDir,"..","doc",name)
    ok,frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es("not found: %s" % name)
</t>
<t tx="ekr.20071211113302.66">def openLeoPlugins (self,event=None):

    '''Open leoPlugins.leo in a new Leo window.'''

    c = self ; name = "leoPlugins.leo"
    fileName = g.os_path_join(g.app.loadDir,"..","plugins",name)
    ok,frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es("not found: %s" % name)
</t>
<t tx="ekr.20071211113302.67">def openOutlineByName (self,event):

    '''Prompt for the name of a Leo outline and open it.'''

    k = self.k
    k.setLabelBlue('Open Leo Outline: ',protect=True)
    k.getFileName(event,handler=self.openOutlineByNameFinisher)

def openOutlineByNameFinisher (self,event):

    c = self.c ; k = self.k ; fileName = k.arg

    k.resetLabel()
    if fileName and g.os_path_exists(fileName) and not g.os_path_isdir(fileName):
        g.openWithFileName(fileName,c)
</t>
<t tx="ekr.20071211113302.68">def open (fileName=None):

    init()

    if g.app.unitTesting:
        return

    if not fileName:
        g.es_print('leoPymacs.open: no file name')
        return None

    # openWithFileName checks to see if the file is already open.
    ok, frame = g.openWithFileName(
        fileName,
        old_c=None,
        enableLog=False,
        readAtFileNodesFlag=True)

    c = ok and frame.c or None
    if c:
        g.es_print('leoPymacs.open: %s' % c)
    else:
        g.es_print('leoPymacs.open: Can not open %s' % fileName)

    return c</t>
<t tx="ekr.20071211113302.69">def runLeoTest(c,path,verbose=False,full=False):

    frame = None ; ok = False ; old_gui = g.app.gui

    # Do not set or clear g.app.unitTesting: that is only done in leoTest.runTest.

    try:
        ok, frame = g.openWithFileName(path,c,enableLog=False)
        assert(ok and frame)
        errors = frame.c.checkOutline(verbose=verbose,unittest=True,full=full)
        assert(errors == 0)
        ok = True
    finally:
        g.app.gui = old_gui
        if frame and frame.c != c:
            frame.c.setChanged(False)
            g.app.closeLeoWindow(frame.c.frame)
        ### c.frame.update()</t>
<t tx="ekr.20071211113302.70">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)
    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
    else:
        import webbrowser
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()
</t>
<t tx="ekr.20071211113302.71"></t>
<t tx="ekr.20071211113302.72"></t>
<t tx="ekr.20071211113302.73">def readRecentFiles (self,localConfigFile):

    '''Read all .leoRecentFiles.txt files.'''

    # The order of files in this list affects the order of the recent files list.
    seen = [] 
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()</t>
<t tx="ekr.20071211113302.74">def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created %s' % (fileName),color='red')
                return
            except Exception:
                g.es_print('can not create %s' % (fileName),color='red')
                g.es_exception()</t>
<t tx="ekr.20071211113302.75">def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
        if not g.unitTesting and not self.silent:
            print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)

    return ok</t>
<t tx="ekr.20071211113302.76">recentFileMessageWritten = False

def writeRecentFilesFile (self,c):

    '''Write the appropriate .leoRecentFiles.txt file.'''

    tag = '.leoRecentFiles.txt'

    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                if not self.recentFileMessageWritten:
                    self.recentFileMessageWritten = True
                    print ('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
</t>
<t tx="ekr.20071211113302.77">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)

    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
            # g.trace(fileName,'lines\n%s' % lines)
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass

    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()

    if theFile:
        theFile.close()
</t>
<t tx="ekr.20071211113302.78"></t>
<t tx="ekr.20071211113302.79">def clearRecentFiles (self,event=None):

    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer

    bunch = u.beforeClearRecentFiles()

    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.delete_range(recentFilesMenu,0,len(c.recentFiles))

    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.relativeFileName())

    g.app.config.appendToRecentFiles(c.recentFiles)

    # g.trace(c.recentFiles)

    u.afterClearRecentFiles(bunch)

    # New in Leo 4.4.5: write the file immediately.
    g.app.config.writeRecentFilesFile(c)
</t>
<t tx="ekr.20071211113302.80">@nocolor

https://sourceforge.net/forum/message.php?msg_id=4615931
By: yarkot

Noticed that in Released 4.4.4 Leo, the registry entry for opening a LeoFile
still has  "%1" portion entered without the quotes.

I saw somewhere that this was fixed - doesn't look like it is.


----- Probably have to update nsi script.

http://sourceforge.net/forum/message.php?msg_id=4616400
By: yarkot

I dug this out of the forums (trying to get open association to work properly)...
The post was:
http://sourceforge.net/forum/message.php?msg_id=2816347

Yes, to check this out I installed 4.4.4 w/ the *.exe file (to let installer
set up the registry; I've been running out of CVS so long, my registry
was Leo-less).

Eventually I updated the registry paths to point to my CVS snapshot - which
is when I caught this.</t>
<t tx="ekr.20071211113302.81"></t>
<t tx="ekr.20071211113302.82">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4618014
By: billp9619

I am not able to use Paste Node As Clone in recent install of leo
Using Windows XP

Here is the log pane output. Line "exception executing command" is beginning
of error message part.:
=================================================================
Leo Log Window...
Leo 4.4.4 final, build  1.216 , November 2, 2007
Python 2.5.1, Tk 8.4.12, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

leoID = id9619 (in E:\Program Files\Leo\config)
global config dir: E:\Program Files\Leo\config
home dir: None
reading settings in E:\Program Files\Leo\config\leoSettings.leo
exception executing command
exception executing command
Traceback (most recent call last):
  File "E:\Program Files\Leo\src\leoCommands.py", line 276, in doCommand
    val = command(event)
  File "E:\Program Files\Leo\src\leoCommands.py", line 3439,
in pasteOutlineRetainingClones
    return c.pasteOutline(reassignIndices=False)
  File "E:\Program Files\Leo\src\leoCommands.py", line 3387, in pasteOutline
    pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
  File "E:\Program Files\Leo\src\leoFileCommands.py", line 623, in
getLeoOutlineFromClipboard
    v = self.getLeoOutlineHelper(s,reassignIndices,checking=True)
  File "E:\Program Files\Leo\src\leoFileCommands.py", line 692, in
getLeoOutlineHelper
    tref = t.fileIndex
AttributeError: 'NoneType' object has no attribute 'fileIndex'
</t>
<t tx="ekr.20071211113302.83">def getLeoOutlineFromClipboard (self,s,reassignIndices=True):

    '''Read a Leo outline from string s in clipboard format.'''

    try:
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=True)
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=False)
    except invalidPaste:
        v = None
        g.es("Invalid Paste As Clone",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    return v

getLeoOutline = getLeoOutlineFromClipboard # for compatibility</t>
<t tx="ekr.20071211113302.84">def finishPaste(self,reassignIndices=True):

    """Finish pasting an outline from the clipboard.

    Retain clone links if reassignIndices is False."""

    c = self.c
    current = c.currentPosition()
    if reassignIndices:
        &lt;&lt; reassign tnode indices &gt;&gt;
    c.selectPosition(current)
    return current
</t>
<t tx="ekr.20071211113302.85">@ putLeoOutline calls assignFileIndices (when copying nodes) so that vnode can be associated with tnodes.
However, we must _reassign_ the indices here so that no "False clones" are created.
@c

nodeIndices = g.app.nodeIndices

current.clearVisitedInTree()

for p in current.self_and_subtree_iter():
    t = p.v.t
    if not t.isVisited():
        t.setVisited()
        # New in Leo 4.4.2 b2: use gnx's.  maxTnodeIndex is no longer used.
        t.fileIndex = nodeIndices.getNewIndex()
        # g.trace(t.fileIndex)</t>
<t tx="ekr.20071211113302.86">def getLeoOutlineHelper (self,s,reassignIndices,checking):

    self.checking = checking
    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.descendentUnknownAttributesDictList = []
    v = None

    self.tnodesDict = {}
    if not reassignIndices:
        &lt;&lt; recreate tnodesDict &gt;&gt;
    try:
        self.getXmlVersionTag()
        self.getXmlStylesheetTag()
        self.getTag("&lt;leo_file&gt;")
        self.getClipboardHeader()
        self.getDummyElements()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("&lt;/leo_file&gt;")
        if not checking:
            v = self.finishPaste(reassignIndices)
    finally:
        self.fileBuffer = None ; self.fileIndex = 0
        self.usingClipboard = False
        self.tnodesDict = {}
    return v
</t>
<t tx="ekr.20071211113302.87">nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    if hasattr(t,'fileIndex'):
        tref = t.fileIndex
        if nodeIndices.isGnx(tref):
            tref = nodeIndices.toString(tref)
        self.tnodesDict[tref] = t

if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]
</t>
<t tx="ekr.20071211113302.88">def getClipboardHeader (self):

    if self.getOpenTag("&lt;leo_header"):
        return # &lt;leo_header&gt; or &lt;leo_header/&gt; has been seen.

    while 1:
        if self.matchTag("file_format="):
            self.getDquote() ; self.getLong() ; self.getDquote()
        elif self.matchTag("tnodes="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("max_tnode_index="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("&gt;&lt;/leo_header&gt;"): # new in 4.2: allow this form.
            break
        else:
            self.getTag("/&gt;")
            break</t>
<t tx="ekr.20071211113302.89">Traceback (most recent call last):

  File "C:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2651, in doHook
    return f(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 91, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 70, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 49, in callTagHandler
    result = handler(tag,keywords)

  File "C:\prog\tigris-cvs\leo\plugins\add_directives.py", line 57, in scanPluginDirectives
    k += 1 + len(d) # Skip @directive

TypeError: coercing to Unicode: need string or buffer, int found

</t>
<t tx="ekr.20071211113302.90"></t>
<t tx="ekr.20071211113302.91">def initAnyMarkup (tag,keywords):

    """initialize colorer.markup_string

    The colorer completely recolors the body pane when this changes"""

    keys = ("colorer","v")
    colorer,v = [keywords.get(key) for key in keys]

    c = colorer.c
    if not c or not c.exists or not v: return

    # underline means hyperlinks
    c.frame.body.tag_configure("http",underline=1) # EKR: 11/4/03
    c.frame.body.tag_configure("https",underline=1) # EKR: 11/4/03
    dict = g.scanDirectives(c,p=v) # v arg is essential.
    pluginsList = dict.get("pluginsList")

    if pluginsList:
        for kind,v,s in pluginsList:
            if kind == "markup" and s:
                colorer.markup_string = s
                return

    colorer.markup_string = "unknown" # default
</t>
<t tx="ekr.20071211113302.92">def colorWikiMarkup (tag,keywords):

    keys = ("colorer","v","s","i","j","colortag")
    colorer,v,s,i,j,colortag = [keywords.get(key) for key in keys]
    c = colorer.c

    dict = g.scanDirectives(c,p=v) # v arg is essential.
    pluginsList = dict.get("pluginsList")

    if pluginsList:
        for kind,v,s2 in pluginsList:
            if kind == "markup" and s2 == 'wiki':
                doWikiText(colorer,s,i,j,colortag)
                return True # We have colored the text.

    # g.trace('**not colored')
    colorer.removeAllImages()
    return None # We have not colored the text.
</t>
<t tx="ekr.20071211113302.93">def doWikiText (colorer,s,i,end,colortag):

    firsti = i

    # Note: for old colorizer, must use index(i) and index(j) to get proper indices.
    # g.trace(i,end,colortag) # ,repr(s[i:end]))

    while i &lt; end:
        &lt;&lt; set first to a tuple describing the first tag to be handled &gt;&gt;
        if first:
            tag,n1,n2,delim1,delim2 = first
            i = n2 + len(delim2)
            &lt;&lt; handle the tag using n1,n2,delim1,delim2 &gt;&gt;
        else: i = end

    # g.trace('tag',colortag,firsti,end)
    colorer.tag(colortag,firsti,end)
</t>
<t tx="ekr.20071211113302.94">first = None

for tag,delim1,delim2 in (
    ("bold","__","__"),
    ("italic","''","''"),
    ("picture","{picture file=","}"),
    ("color","~~","~~"),
):
    n1 = s.find(delim1,i,end)
    if n1 &gt; -1:
        n2 = s.find(delim2,n1+len(delim1),end)
        if n2 &gt; -1:
            if not first or (first and n1 &lt; first[1]):
                first = tag,n1,n2,delim1,delim2

for tag,delim1 in (
    ("http","http://"),
    ("https","https://"),
):
    k = s.find(delim1,i,end)
    if k &gt; -1:
        k2 = k + len(delim1)
        while k2 &lt; len(s) and s[k2] not in (' ','\t','\n'):
            k2 += 1
        delim2 = s[k2]
        if s[k:k2] and not first or (first and k &lt; first[1]):
            # g.trace('delim1',k,k2,s[k:k2])
            first = tag,k,k2,delim1,delim2
</t>
<t tx="ekr.20071211113302.95"># g.trace(tag,i,n1,n2,s[n1:n2])

if tag =="picture":
    colorer.tag("elide",n1,n2+len(delim2)) # Elide everything.
    filename = s[n1+len(delim1):n2]
    filename = os.path.join(g.app.loadDir,filename)
    filename = os.path.normpath(filename)
    insertWikiPicture(colorer,filename,s,n2+len(delim2))
elif tag == "color":
    &lt;&lt; parse and handle color field &gt;&gt;
elif tag == "http" or tag == "https":
    colorer.tag(tag,n1,n2)
else:
    # look for nested bold or italic.
    if tag == "bold":
        delim3,delim4 = "''","''" # Look for nested italic.
    else:
        delim3,delim4 = "__","__" # Look for nested bold.
    n3 = s.find(delim3,n1+len(delim1),n2) ; n4 = -1
    if n3 &gt; -1:
        n4 = s.find(delim4,n3+len(delim3),n2+len(delim2))
    if n3 &gt; -1 and n4 &gt; -1:
        colorer.tag("elide",n1,n1+len(delim1))
        colorer.tag("elide",n2,n2+len(delim2))
        colorer.tag("elide",n3,n3+len(delim3))
        colorer.tag("elide",n4,n4+len(delim4))
        colorer.tag(tag,n1+len(delim1),n3)
        colorer.tag("bolditalic",n3+len(delim3),n4)
        colorer.tag(tag,n4+len(delim4),n2)
    else:
        # No nested tag.
        colorer.tag("elide",n1,n1+len(delim1))
        colorer.tag("elide",n2,n2+len(delim2))
        colorer.tag(tag,n1+len(delim1),n2)</t>
<t tx="ekr.20071211113302.96"># Parse the color value.
j = n1+len(delim1)
n = s.find(":",j,n2)
if n2 &gt; n &gt; j &gt; -1:
    name = s[j:n]
    if name[0] == '#' and len(name) &gt; 1:
        name = '#' + string.zfill(name[1:],6)
    if name in colorer.color_tags_list:
        colorer.tag("elide",n1,n+1)
        colorer.tag(name,n+1,n2)
        colorer.tag("elide",n2,n2+len(delim2))
    else:
        try:
            # print "entering", name
            c = colorer.c
            c.frame.body.bodyCtrl.tag_configure(name,foreground=name)
            colorer.color_tags_list.append(name)
            colorer.tag("elide",n1,n+1)
            colorer.tag(name,n+1,n2)
            colorer.tag("elide",n2,n2+len(delim2))
        except: # an invalid color name: elide nothing.
            pass # g.es_exception()</t>
<t tx="ekr.20071211113302.97">def scanPluginDirectives (tag, keywords):

    """Add a tuple (d,v,s,k) to list for every directive d found"""

    global directives

    keys = ("c","v","s","old_dict","dict","pluginsList")
    c,v,s,old_dict,dict,pluginsList = [keywords.get(key) for key in keys]

    for d in directives:
        if not old_dict.has_key(d) and dict.has_key(d):
            # Point k at whatever follows the directive.
            s = dict.get(d)
            kind = d
            pluginsList.append((kind,v,s),)
</t>
<t tx="ekr.20071211113302.98">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4620890
By: tokidokix

Hi,
I have a (very) small bug on Leo 4.4.4 (linux); I am not sure where to report
it, so I'll do it here.

When doing a "hoist" on a childless node (on linux, at least), the following
trackback is displayed on the log windows:

Traceback (most recent call last):
  File "/usr/local/lib/leo/src/leoTkinterTree.py", line 1315, in scrollTo
    h1 = self.yoffset(p)
  File "/usr/local/lib/leo/src/leoTkinterTree.py", line 1416, in yoffset
    h,flag = self.yoffsetTree(root,p1,isTop=True)
  File "/usr/local/lib/leo/src/leoTkinterTree.py", line 1436, in yoffsetTree
    if p2.isExpanded() and p2.hasChildren():
  File "/usr/local/lib/leo/src/leoNodes.py", line 1349, in isExpanded
    def isExpanded  (self): return self.v.isExpanded()
AttributeError: 'NoneType' object has no attribute 'isExpanded'

@color</t>
<t tx="ekr.20071211113302.99">class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):

    return self.siblings_iter_class(self,copy,following)

self_and_siblings_iter = siblings_iter

def following_siblings_iter (self,copy=False):

    return self.siblings_iter_class(self,copy,following=True)
</t>
<t tx="ekr.20071211113302.100">def __init__(self,p,copy,following):

    # We always include p, even if following is True.

    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
</t>
<t tx="ekr.20071211113302.101">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
</t>
<t tx="ekr.20071211113302.102">@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    if not p1: return 0
    c = self.c
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        root = bunch.p.copy()
    else:
        root = self.c.rootPosition()
    if root:
        h,flag = self.yoffsetTree(root,p1,isTop=True)
        # flag can be False during initialization.
        # if not flag: print "yoffset fails:",h,v1
        return h
    else:
        return 0

def yoffsetTree(self,p,p1,isTop):
    c = self.c ; h = 0 ; trace = False ; verbose = False
    if not c.positionExists(p):
        if trace: g.trace('does not exist',p.headString())
        return h,False # An extra precaution.
    p = p.copy()
    if trace and verbose and isTop and c.hoistStack:
        g.trace('c.hoistStack',c.hoistStack[-1].p.headString())
    if isTop and c.hoistStack:
        if p.firstChild():  theIter = [p.firstChild()]
        else:               theIter = []
    else: theIter = p.self_and_siblings_iter() # Bug fix 10/27/07: was p.siblings_iter()
    for p2 in theIter:
        if p2 == p1:
            if trace and verbose: g.trace(h,p1.headString())
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1,isTop=False)
            h += h2
            if flag:
                if trace and verbose: g.trace(h,p1.headString())
                return h, True

    if trace: g.trace('not found',p1.headString())
    return h, False
</t>
<t tx="ekr.20071211113302.103">@nocolor

From email from Terry Brown

python /home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py /home/tbrown/.tnb.leo

(should be all on one line, i.e. run and open /home/tbrown/.tnb.leo)

gives the traceback below.  Opening the file from within Leo works fine.

Bah - I just now looked at it closely enough to realize it's the evil
pickled Tk classes in cleo uAs.  So I don't know whether you want to
fix that or not, it makes sense Leo would read the file specified on
the command line before Tk is initialized - if it's just scanning for
settings maybe it could catch and ignore failed uA reads at that time?

At some point I want to take pickled Tk vars out of cleo, I was
thinking when that guy was working on the wx gui would be a good time,
too bad he got sick.

Cheers -Terry

reading settings in /mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/config/leoSettings.leo
reading settings in /home/tbrown/leoSettings.leo
reading settings in /home/tbrown/myLeoSettings.leo
reading settings in /home/tbrown/.tnb.leo
Traceback (most recent call last):
  File "/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py", line 398, in &lt;module&gt;
    run(fileName)
  File "/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leo.py", line 118, in run
    g.app.config.readSettingsFiles(fileName,verbose)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoConfig.py", line 1649, in readSettingsFiles
    c = self.openSettingsFile(path)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoConfig.py", line 1674, in openSettingsFile
    theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 892, in open
    silent=silent)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 779, in getLeoFile
    self.getAllLeoElements(fileName,silent)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1317, in getAllLeoElements
    self.getVnodes()
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1898, in getVnodes
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1781, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1738, in getVnode
    attr,val = self.getUa("vnode")
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoFileCommands.py", line 1658, in getUa
    val2 = pickle.loads(binString)
  File "/usr/lib/python2.5/pickle.py", line 1374, in loads
    return Unpickler(file).load()
  File "/usr/lib/python2.5/pickle.py", line 858, in load
    dispatch[key](self)
  File "/usr/lib/python2.5/pickle.py", line 1217, in load_build
    setstate(state)
  File "/mnt/removable/bkup_usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/plugins/cleo.py", line 130, in __setstate__
    Tk.Variable.__init__(self)
  File "/usr/lib/python2.5/lib-tk/Tkinter.py", line 188, in __init__
    self._tk = master.tk
AttributeError: 'NoneType' object has no attribute 'tk'
Exception exceptions.AttributeError: "TkPickleVar instance has no attribute '_tk'" in &lt;bound method TkPickleVar.__del__ of &lt;cleo.TkPickleVar instance at 0xb73a876c&gt;&gt; ignored

@color
</t>
<t tx="ekr.20071211113302.104"># changed for 4.3.

def getUa(self,unused_nodeType):

    """Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element."""

    # New in 4.2.  The unknown tag has been pickled and hexlify'd.
    attr,val = self.getUnknownTag()
    # g.trace(attr,repr(val))
    if not attr:
        return None,None

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return attr,val

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except TypeError:
        # Assume that Leo 4.1 wrote the attribute.
        # g.trace('4.1 val:',val2)
        return attr,val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return attr,val2
    except (pickle.UnpicklingError,ImportError):
        return attr,val
    except Exception:
        return attr,val # New in Leo 4.4.5.
</t>
<t tx="ekr.20071211113302.105"></t>
<t tx="ekr.20071211113302.106"></t>
<t tx="ekr.20071211113302.107">@nocolor

1. The dict returned by get_directives_dict contains values that are strings,
not indices. The string will be the line after the directive (with whitespace
stripped off).

This was a major change: all the various code sections that sets values from this
dict had to change.

2. Eliminated the s arg from the g.scanXDirective functions.

3. Refactored common code into g.computeRelativePath().</t>
<t tx="ekr.20071211113302.108"># The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(p,root=None):

    """Scans root for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}

    # The headline has higher precedence because it is more visible.
    for kind,s in (
        ('body',p.v.t.headString),
        ('head',p.v.t.bodyString),
    ):
        i = 0 ; n = len(s)
        while i &lt; n:
            if s[i] == '@' and i+1 &lt; n:
                &lt;&lt; set theDict for @ directives &gt;&gt;
            elif kind == 'body' and root and g.match(s,i,"&lt;&lt;"):
                &lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;
            i = g.skip_line(s,i)
    return theDict
</t>
<t tx="ekr.20071211113302.109">j = g.skip_c_id(s,i+1)
word = s[i+1:j]

global globalDirectiveList

if word in globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        # theDict [word] = i
        k = g.skip_line(s,j)
        theDict[word] = s[j:k].strip()</t>
<t tx="ekr.20071211113302.110">@ The following looks for chunk definitions of the form &lt; &lt; * &gt; &gt; =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)

if i &lt; n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,"&gt;&gt;="):
        # &lt; &lt; * &gt; &gt; = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
</t>
<t tx="ekr.20071211113302.111">def computeRelativePath (path):

    if len(path) &gt; 2 and (
        (path[0]=='&lt;' and path[-1] == '&gt;') or
        (path[0]=='"' and path[-1] == '"') or
        (path[0]=="'" and path[-1] == "'")
    ):
        path = path[1:-1].strip()

    # 11/14/02: we want a _relative_ path, not an absolute path.
    # path = g.os_path_join(g.app.loadDir,path)

    return path
</t>
<t tx="ekr.20071211113302.112"></t>
<t tx="ekr.20071211113302.113"></t>
<t tx="ekr.20071211113302.114"># Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    # g.trace(g.callers())

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
</t>
<t tx="ekr.20071211113302.115">def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.

    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)

    count = 0 ; delims = [None, None, None]
    while count &lt; 3 and i &lt; len(s):
        i = j = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1

    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
</t>
<t tx="ekr.20071211113302.116">def set_language(s,i,issue_errors_flag=False):

    """Scan the @language directive that appears at s[i:].

    The @language may have been stripped away.

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    # assert(g.match_word(s,i,tag))
    if g.match_word(s,i,tag):
        i += len(tag)
    # Get the argument.
    i = g.skip_ws(s, i)
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3

    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
</t>
<t tx="ekr.20071211113302.117">def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    &gt;&gt;&gt; g.comment_delims_from_extension(".py")
    ('#', None, None)

    &gt;&gt;&gt; g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    &gt;&gt;&gt; g.comment_delims_from_extension(".html")
    (None, '&lt;!--', '--&gt;')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:

        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
</t>
<t tx="ekr.20071211113302.118">@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(c,name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return c.nullPosition()
</t>
<t tx="ekr.20071211113302.119">def scanAtEncodingDirective(theDict):

    """Scan the @encoding directive at s[theDict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    encoding = theDict.get('encoding')
    if not encoding:
        return None

    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding: "+encoding,color="red")
        return None
</t>
<t tx="ekr.20071211113302.120">def scanAtLineendingDirective(theDict):

    """Scan the @lineending directive at s[theDict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    e = theDict.get('encoding')

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(name=e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
</t>
<t tx="ekr.20071211113302.121">def scanAtPagewidthDirective(theDict,issue_error_flag=False):

    """Scan the @pagewidth directive at s[theDict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """

    s = theDict.get('pagewidth')
    i, val = g.skip_long(s,0)

    if val != None and val &gt; 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            g.es("ignoring " + s,color="red")
        return None
</t>
<t tx="ekr.20071211113302.122">def scanAtRootOptions (s,i,err_flag=False):

    # The @root has been eaten when called from tangle.scanAllDirectives.
    if g.match(s,i,"@root"):
        i += len("@root")
        i = g.skip_ws(s,i)

    mode = None 
    while g.match(s,i,'-'):
        &lt;&lt; scan another @root option &gt;&gt;

    if mode == None:
        doc = app.config.at_root_bodies_start_in_doc_mode
        mode = g.choose(doc,"doc","code")

    return i,mode
</t>
<t tx="ekr.20071211113302.123">i += 1 ; err = -1

if g.match_word(s,i,"code"): # Just match the prefix.
    if not mode: mode = "code"
    elif err_flag: g.es("modes conflict in:" + g.get_line(s,i))
elif g.match(s,i,"doc"): # Just match the prefix.
    if not mode: mode = "doc"
    elif err_flag: g.es("modes conflict in:" + g.get_line(s,i))
else:
    err = i-1

# Scan to the next minus sign.
while i &lt; len(s) and s[i] not in (' ','\t','-'):
    i += 1

if err &gt; -1 and err_flag:
    g.es("unknown option:" + s[err:i] + " in " + g.get_line(s,i))
</t>
<t tx="ekr.20071211113302.124">def scanAtTabwidthDirective(theDict,issue_error_flag=False):

    """Scan the @tabwidth directive at s[theDict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """

    s = theDict.get('tabwidth')
    junk,val = g.skip_long(s,0)

    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            g.es("Ignoring " + s,color="red")
        return None
</t>
<t tx="ekr.20071211113302.125">def scanColorDirectives(c,p):

    '''Return the language in effect at position p.'''

    if c is None: return # c may be None for testing.

    language = c.target_language and c.target_language.lower() or 'python'

    p = p.copy()
    for p in p.self_and_parents_iter():
        d = g.get_directives_dict(p)
        z = d.get('language')
        if z is not None:
            language,junk,junk,junk = g.set_language(z,0)
            return language

    return language
</t>
<t tx="ekr.20071211113302.126">@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):

    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if p is None:
        p = c.currentPosition()

    &lt;&lt; Set local vars &gt;&gt;
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @wrap and @nowrap &gt;&gt;
        g.doHook("scan-directives",c=c,p=p,v=p,s=p.bodyString(),
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c)

    # g.trace('tabwidth',tab_width)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
</t>
<t tx="ekr.20071211113302.127">page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
if c.target_language:
    c.target_language = c.target_language.lower()
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
</t>
<t tx="ekr.20071211113302.128"># 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    z = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(z)

elif theDict.has_key("language"):
    z = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(z,0)
</t>
<t tx="ekr.20071211113302.129">if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(theDict)
    if e:
        encoding = e
</t>
<t tx="ekr.20071211113302.130">if not old.has_key("lineending") and theDict.has_key("lineending"):

    e = g.scanAtLineendingDirective(theDict)
    if e:
        lineending = e
</t>
<t tx="ekr.20071211113302.131">if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(theDict)
    if w and w &gt; 0:
        page_width = w
</t>
<t tx="ekr.20071211113302.132">if not path and not old.has_key("path") and theDict.has_key("path"):

    path = theDict["path"]
    path = g.computeRelativePath(path)

    if path and len(path) &gt; 0:
        base = g.getBaseDirectory(c) # returns "" on error.
        path = g.os_path_join(base,path)
</t>
<t tx="ekr.20071211113302.133">if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(theDict)
    if w and w != 0:
        tab_width = w
</t>
<t tx="ekr.20071211113302.134">if not old.has_key("wrap") and not old.has_key("nowrap"):

    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
</t>
<t tx="ekr.20071211113302.135">def scanForAtIgnore(c,p):

    """Scan position p and its ancestors looking for @ignore directives."""

    if g.app.unitTesting:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        d = g.get_directives_dict(p)
        if d.has_key("ignore"):
            return True

    return False
</t>
<t tx="ekr.20071211113302.136">def scanForAtLanguage(c,p):

    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""

    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            d = g.get_directives_dict(p)
            if d.has_key("language"):
                z = d["language"]
                language,delim1,delim2,delim3 = g.set_language(z,0)
                return language

    return c.target_language
</t>
<t tx="ekr.20071211113302.137">def scanForAtSettings(p):

    """Scan position p and its ancestors looking for @settings nodes."""

    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
</t>
<t tx="ekr.20071211113302.138">def getOutputNewline (c=None,name=None):

    '''Convert the name of a line ending to the line ending itself.

    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''

    # g.trace(c,name,c.config.output_newline)
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
</t>
<t tx="ekr.20071211113302.139"></t>
<t tx="ekr.20071211113302.140">@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):

    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    # __pychecker__ = '--maxlines=400'
    # g.stat()

    c = self.c
    &lt;&lt; Set ivars &gt;&gt;
    &lt;&lt; Set path from @file node &gt;&gt;
    old = {}
    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        old.update(theDict)
    &lt;&lt; Set current directory &gt;&gt;
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        &lt;&lt; Set comment strings from delims &gt;&gt;
    # For unit testing.
    return {
        "encoding"  : self.encoding,
        "language"  : self.language,
        "lineending": self.output_newline,
        "pagewidth" : self.page_width,
        "path"      : self.default_directory,
        "tabwidth"  : self.tab_width,
    }
</t>
<t tx="ekr.20071211113302.141">self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
</t>
<t tx="ekr.20071211113302.142"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) &gt; 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
</t>
<t tx="ekr.20071211113302.143"># We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    path = theDict["path"]
    path = g.computeRelativePath(path)
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory(c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            &lt;&lt; handle absolute path &gt;&gt;
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
</t>
<t tx="ekr.20071211113302.144"># path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else:
    self.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
</t>
<t tx="ekr.20071211113302.145">if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(theDict)
    if e:
        self.encoding = e
</t>
<t tx="ekr.20071211113302.146"># 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass # Do nothing more.

elif theDict.has_key("comment"):
    z = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(z)

elif theDict.has_key("language"):
    z = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(z,0)
</t>
<t tx="ekr.20071211113302.147"># EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
</t>
<t tx="ekr.20071211113302.148">if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
</t>
<t tx="ekr.20071211113302.149">if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(theDict,issue_error_flag=True)
    if w and w &gt; 0:
        self.page_width = w
</t>
<t tx="ekr.20071211113302.150">if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w
</t>
<t tx="ekr.20071211113302.151"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
</t>
<t tx="ekr.20071211113302.152">if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
</t>
<t tx="ekr.20071211113302.153">def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    &lt;&lt; Set path from @file node &gt;&gt;
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        if theDict.has_key("path"):
            &lt;&lt; handle @path &gt;&gt;
            return

    &lt;&lt; Set current directory &gt;&gt;
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
</t>
<t tx="ekr.20071211113302.154"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
</t>
<t tx="ekr.20071211113302.155"># We set the current director to a path so future writes will go to that directory.

path = theDict["path"]
path = g.computeRelativePath (path)

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        &lt;&lt; handle absolute path &gt;&gt;
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
</t>
<t tx="ekr.20071211113302.156"># path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
</t>
<t tx="ekr.20071211113302.157"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
</t>
<t tx="ekr.20071211113302.158">def scanColorDirectives(self,p):

    """Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.
    """

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    if c.target_language:
        c.target_language = c.target_language.lower()
    self.language = language = c.target_language
    self.comment_string = None
    self.rootMode = None # None, "code" or "doc"

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        &lt;&lt; Test for @comment or @language &gt;&gt;
        &lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;

    return self.language # For use by external routines.
</t>
<t tx="ekr.20071211113302.159"># @comment and @language may coexist in the same node.

if theDict.has_key("comment"):
    self.comment_string = theDict["comment"]

if theDict.has_key("language"):
    z = theDict["language"]
    language,junk,junk,junk = g.set_language(z,0)
    self.language = language

if theDict.has_key("comment") or theDict.has_key("language"):
    break
</t>
<t tx="ekr.20071211113302.160">if theDict.has_key("root") and not self.rootMode:

    root = theDict["root"]
    if g.match_word(root,0,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(root,0,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
</t>
<t tx="ekr.20071211113302.161"># Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        &lt;&lt; set w and break on @tabwidth &gt;&gt;

    c.frame.setTabWidth(w)
</t>
<t tx="ekr.20071211113302.162">if theDict.has_key("tabwidth"):

    val = g.scanAtTabwidthDirective(theDict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break
</t>
<t tx="ekr.20071211113302.163">def tangle(self,event=None,p=None):

    c = self.c
    if not p: p = c.currentPosition()
    self.initTangleCommand()

    # Paul Paterson's patch.
    if not self.tangleTree(p,report_errors):
        g.es("looking for a parent to tangle...")
        while p:
            d = g.get_directives_dict(p,[self.head_root])
            if d.has_key("root"):
                g.es("tangling parent")
                self.tangleTree(p,report_errors)
                break
            p.moveToParent()

    if not g.unitTesting:
        g.es("tangle complete")
</t>
<t tx="ekr.20071211113302.164">@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):

    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    # __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        &lt;&lt; Collect @first attributes &gt;&gt;
    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for print modes directives &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @root &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        old.update(theDict)
    &lt;&lt; Set self.tangle_directory &gt;&gt;
    # For unit testing.
    return {
        "encoding"  : self.encoding,
        "language"  : self.language,
        "lineending": self.output_newline,
        "pagewidth" : self.page_width,
        "path"      : self.tangle_directory,
        "tabwidth"  : self.tab_width,
    }
</t>
<t tx="ekr.20071211113302.165">@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i&gt;j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i &gt;= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break
</t>
<t tx="ekr.20071211113302.166">if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    z = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(z)
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: @comment " + z)

elif theDict.has_key("language"):

    z = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(z,0)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
</t>
<t tx="ekr.20071211113302.167">if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(theDict)
    if e:
        self.encoding = e
</t>
<t tx="ekr.20071211113302.168">if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(theDict)
    if lineending:
        self.output_newline = lineending
</t>
<t tx="ekr.20071211113302.169">@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
</t>
<t tx="ekr.20071211113302.170">if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    path = theDict["path"]
    theDir = relative_path = g.computeRelativePath(path)

    if len(theDir) &gt; 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                &lt;&lt; handle absolute @path &gt;&gt;
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
</t>
<t tx="ekr.20071211113302.171">if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir,c=c)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) &gt; 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) &gt; 0:
                g.es("relative path in @path directive: " + relative_path)
</t>
<t tx="ekr.20071211113302.172">if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(theDict,issue_error_flag)
    if w and w &gt; 0:
        self.page_width = w
</t>
<t tx="ekr.20071211113302.173">@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):
    z = theDict["root"]
    self.setRootFromText(z,issue_error_flag)
</t>
<t tx="ekr.20071211113302.174">if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
</t>
<t tx="ekr.20071211113302.175">if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.

elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
</t>
<t tx="ekr.20071211113302.176">@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) &gt; 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) &gt; 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                &lt;&lt; handle absolute path &gt;&gt;

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
</t>
<t tx="ekr.20071211113302.177">if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir,c=c)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) &gt; 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) &gt; 0:
            g.es(kind + " directory: " + dir2)
</t>
<t tx="ekr.20071211113302.178"># Traverses the tree whose root is given, handling each headline and associated body text.

def tanglePass1(self,p):

    """The main routine of tangle pass 1"""

    p = p.copy()
    next = p.nodeAfterTree()
    while p and p != next:
        self.p = p
        self.setRootFromHeadline(p)
        theDict = g.get_directives_dict(p,[self.head_root])
        is_ignore = theDict.has_key("ignore")
        if is_ignore:
            p.moveToNodeAfterTree()
            continue
        # This must be called after root_name has been set.
        if self.tangling:
            self.scanAllDirectives(p,require_path,report_errors) # calls init_directive_ivars.
        # Scan the headline and body text.
        self.skip_headline(p)
        self.skip_body(p)
        p.moveToThreadNext()
        if self.errors + g.app.scanErrors &gt;= max_errors:
            self.warning("----- Halting Tangle: too many errors")
            break

    if self.tangling:
        self.st_check()
        # g.trace(self.st_dump(verbose_flag=True))
</t>
<t tx="ekr.20071211113302.179"># This function is called only from the top level, so there is no need to initialize globals.

def tangleTree(self,p,report_flag):

    """Tangles all nodes in the tree whose root is p.

    Reports on its results if report_flag is True."""

    p = p.copy() # 9/14/04
    assert(p)
    any_root_flag = False
    next = p.nodeAfterTree()
    self.path_warning_given = False

    while p and p != next:
        self.setRootFromHeadline(p)
        theDict = g.get_directives_dict(p,[self.head_root])
        is_ignore = theDict.has_key("ignore")
        is_root = theDict.has_key("root")
        is_unit = theDict.has_key("unit")
        if is_ignore:
            p.moveToNodeAfterTree()
        elif not is_root and not is_unit:
            p.moveToThreadNext()
        else:
            self.tanglePass1(p) # sets self.p
            if self.root_list and self.tangling:
                any_root_flag = True
                self.tanglePass2() # self.p invalid in pass 2.
            self.cleanup()
            p.moveToNodeAfterTree()
            if self.path_warning_given: break # Fatal error.

    if self.tangling and report_flag and not any_root_flag:
        # This is done by Untangle if we are untangling.
        self.warning("----- The outline contains no roots")
    return any_root_flag
</t>
<t tx="ekr.20071211113302.180"># This funtion is called when the user selects any "Untangle" command.

def untangleTree(self,p,report_flag):

    p = p.copy() # 9/14/04
    c = self.c
    any_root_flag = False
    afterEntireTree = p.nodeAfterTree()
    # Initialize these globals here: they can't be cleared later.
    self.head_root = None
    self.errors = 0 ; g.app.scanErrors = 0
    c.clearAllVisited() # Used by untangle code.

    while p and p != afterEntireTree and self.errors + g.app.scanErrors == 0:
        self.setRootFromHeadline(p)
        theDict = g.get_directives_dict(p,[self.head_root])
        ignore = theDict.has_key("ignore")
        root = theDict.has_key("root")
        unit = theDict.has_key("unit")
        if ignore:
            p.moveToNodeAfterTree()
        elif unit:
            # Expand the context to the @unit directive.
            unitNode = p   # 9/27/99
            afterUnit = p.nodeAfterTree()
            p.moveToThreadNext()
            while p and p != afterUnit and self.errors + g.app.scanErrors== 0:
                self.setRootFromHeadline(p)
                theDict = g.get_directives_dict(p,[self.head_root])
                root = theDict.has_key("root")
                if root:
                    any_root_flag = True
                    end = None
                    &lt;&lt; set end to the next root in the unit &gt;&gt;
                    # g.trace("end:",end)
                    self.scanAllDirectives(p,require_path,report_errors)
                    self.untangleRoot(p,unitNode,afterUnit)
                    p = end.copy()
                else: p.moveToThreadNext()
        elif root:
            # Limit the range of the @root to its own tree.
            afterRoot = p.nodeAfterTree()
            any_root_flag = True
            self.scanAllDirectives(p,require_path,report_errors)
            self.untangleRoot(p,p,afterRoot) # 9/27/99
            p = afterRoot.copy()
        else:
            p.moveToThreadNext()

    self.errors += g.app.scanErrors

    if report_flag:
        if not any_root_flag:
            self.warning("----- The outline contains no roots")
        elif self.errors &gt; 0:
            self.warning("----- Untangle command halted because of errors")
    return any_root_flag
</t>
<t tx="ekr.20071211113302.181">@ The untangle_root function will untangle an entire tree by calling untangleTree, so the following code ensures that the next @root node will not be an offspring of p.
@c

end = p.threadNext()
while end and end != afterUnit:
    flag, i = g.is_special(end.bodyString(),0,"@root")
    if flag and not p.isAncestorOf(end):
        break
    end.moveToThreadNext()
</t>
<t tx="ekr.20071211113302.182">def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    p = p.copy() ; first = p.copy()
    self.killFlag = False
    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        no_color = theDict.has_key("nocolor")
        color = theDict.has_key("color")
        kill_color = theDict.has_key("killcolor")
        # A killcolor anywhere disables coloring.
        if kill_color:
            self.killFlag = True
            return False
        # A color anywhere in the target enables coloring.
        elif color and p == first:
            return True
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            return False
        elif color and not no_color:
            return True

    return True
</t>
<t tx="ekr.20071211113302.183">def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    w = self.editWidget(event)
    if not w: return 'break'
    &lt;&lt; set local vars &gt;&gt;
    #g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i &gt; j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:

            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
</t>
<t tx="ekr.20071211113302.184">c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab': # Support for wx_alt_gui plugin.
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch and ch in brackets)</t>
<t tx="ekr.20071211113302.185">def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()</t>
<t tx="ekr.20071211113302.186">def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'

    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
</t>
<t tx="ekr.20071211113302.187">def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
</t>
<t tx="ekr.20071211113302.188">def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
</t>
<t tx="ekr.20071211113302.189">def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins&lt;len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
</t>
<t tx="ekr.20071211113302.190">def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.scanColorDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
</t>
<t tx="ekr.20071211113302.191">def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i &lt;= j.

    if i != j:
        w.delete(i,j)

    if tab_width &gt; 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]

        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)</t>
<t tx="ekr.20071211113302.192"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    c = self.c ; u = c.undoer ; w = c.edit_widget(p)
    if c.suppressHeadChanged: return
    if not w: return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace('changed',changed,'old',repr(oldRevert),'new',repr(s))
        if changed:
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            # New in Leo 4.4.5: we must recolor the body because
            # the headline may contain directives.
            c.frame.scanForTabWidth(p)
            c.frame.body.recolor(p,incremental=True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(flag=changed,scroll=False)
            # scroll=False in 4.4.1; flag = changed in 4.4.3.
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
        else:
            c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
</t>
<t tx="ekr.20071211113302.193"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
</t>
<t tx="ekr.20071211113302.194"># There are many similarities, but there are subtle differences as well.
# It does not appear to be worth the risk, or benefit.</t>
<t tx="ekr.20071211113302.195"></t>
<t tx="ekr.20071211113302.196">@nocolor

This option has effect only when importing so-called non-strict languages,
for which leading whitespace is not terribly significant.

True: @auto warns about mismatches that occur solely in leading whitespace.</t>
<t tx="ekr.20071211113302.197">val = c.config.getBool('collapse_nodes_during_finds')
c.config.set(p,'collapse_nodes_during_finds',not val)
g.es_print('collapse_nodes_during_finds',c.config.getBool('collapse_nodes_during_finds'))</t>
<t tx="ekr.20071211113302.198">class searchCommandsClass (baseEditCommandsClass):

    '''Implements many kinds of searches.'''

    @others
</t>
<t tx="ekr.20071211113302.199">def __init__ (self,c):

    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.findTabHandler = None
    self.minibufferFindHandler = None
    self.inited = False

    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None

    # For isearch commands.
    self.ifinder = leoFind.leoFind(c,title='ifinder')
    self.isearch_v = None # vnode of last isearch.
    self.isearch_stack = [] # A stack of previous matches: entries are: (sel,insert)
    self.ignoreCase = None
    self.forward = None
    self.regexp = None
</t>
<t tx="ekr.20071211113302.200">def getPublicCommands (self):

    return {
        'clone-find-all':                       self.cloneFindAll,

        'find-all':                             self.findAll,
        'change-all':                           self.changeAll,

        # Thin wrappers on Find tab
        'change':                               self.findTabChange,
        'change-then-find':                     self.findTabChangeThenFind,
        'find-next':                            self.findTabFindNext,
        'find-prev':                            self.findTabFindPrev,

        'hide-find-tab':                        self.hideFindTab,

        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
        'isearch-with-present-options':         self.isearchWithPresentOptions,

        'open-find-tab':                        self.openFindTab,

        'replace-string':                       self.replaceString,

        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.

        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,

        'show-find-options':                    self.showFindOptions,

        'toggle-find-collapses_nodes':          self.toggleFindCollapesNodes,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,

        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
</t>
<t tx="ekr.20071211113302.201"></t>
<t tx="ekr.20071211113302.202">def openFindTab (self,event=None,show=True):

    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    wasOpen = self.inited

    if self.inited:
        log.selectTab(tabName)
    else:
        self.inited = True
        log.selectTab(tabName,createText=False)
        f = log.frameDict.get(tabName)
        self.findTabHandler = g.app.gui.createFindTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
</t>
<t tx="ekr.20071211113302.203"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):
    '''Execute the 'Change' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):
    '''Execute the 'Replace, Find' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindAll(self,event=None):
    '''Execute the 'Find All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    '''Execute the 'Find Next' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    '''Execute the 'Find Previous' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()

def hideFindTab (self,event=None):
    '''Hide the Find tab.'''
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
</t>
<t tx="ekr.20071211113302.204">def getHandler(self,show=False):

    '''Return the minibuffer handler, creating it if necessary.'''

    c = self.c

    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.

    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler
</t>
<t tx="ekr.20071211113302.205">def setFindScopeEveryWhere (self, event):
    '''Set the 'Entire Outline' radio button in the Find tab.'''
    return self.setFindScope('entire-outline')

def setFindScopeNodeOnly  (self, event):
    '''Set the 'Node Only' radio button in the Find tab.'''
    return self.setFindScope('node-only')

def setFindScopeSuboutlineOnly (self, event):
    '''Set the 'Suboutline Only' radio button in the Find tab.'''
    return self.setFindScope('suboutline-only')

def showFindOptions (self,event):
    '''Show all Find options in the minibuffer label area.'''
    self.getHandler().showFindOptions()

def toggleFindCollapesNodes(self,event):
    '''Toggle the 'Collapse Nodes' checkbox in the find tab.'''
    # return self.toggleOption('collapse_nodes')
    c = self.c ; p = c.currentPosition()
    val = c.config.getBool('collapse_nodes_during_finds')
    c.config.set(p,'collapse_nodes_during_finds',not val)
    g.es('collapse_nodes_during_finds',c.config.getBool('collapse_nodes_during_finds'))

def toggleIgnoreCaseOption     (self, event):
    '''Toggle the 'Ignore Case' checkbox in the Find tab.'''
    return self.toggleOption('ignore_case')

def toggleMarkChangesOption (self, event):
    '''Toggle the 'Mark Changes' checkbox in the Find tab.'''
    return self.toggleOption('mark_changes')
def toggleMarkFindsOption (self, event):
    '''Toggle the 'Mark Finds' checkbox in the Find tab.'''
    return self.toggleOption('mark_finds')
def toggleRegexOption (self, event):
    '''Toggle the 'Regexp' checkbox in the Find tab.'''
    return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event):
    '''Toggle the 'Reverse' checkbox in the Find tab.'''
    return self.toggleOption('reverse')

def toggleSearchBodyOption (self, event):
    '''Set the 'Search Body' checkbox in the Find tab.'''
    return self.toggleOption('search_body')

def toggleSearchHeadlineOption (self, event):
    '''Toggle the 'Search Headline' checkbox in the Find tab.'''
    return self.toggleOption('search_headline')

def toggleWholeWordOption (self, event):
    '''Toggle the 'Whole Word' checkbox in the Find tab.'''
    return self.toggleOption('whole_word')

def toggleWrapSearchOption (self, event):
    '''Toggle the 'Wrap Around' checkbox in the Find tab.'''
    return self.toggleOption('wrap')

def setFindScope (self, where):  self.getHandler().setFindScope(where)
def toggleOption (self, ivar):   self.getHandler().toggleOption(ivar)
</t>
<t tx="ekr.20071211113302.206">def changeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    self.getHandler().changeAll(event)

def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type &lt;Return&gt; to end the search string. The
    command will then prompt for the replacement string. Typing a second
    &lt;Return&gt; key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Set the 'Regexp' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Set the 'Regexp' checkbox to True, then do search-with-present-options.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Set the 'Word Search' checkbox to False and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Set the 'Word Search' checkbox to False, then do search-with-present-options.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Set the 'Word Search' checkbox to True, then do search-with-present-options.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Set the Word Search' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the &lt;Return&gt; key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
</t>
<t tx="ekr.20071211113302.207">def findAgain (self,event):

    '''The find-again command is the same as the find-next command
    if the search pattern in the Find tab is not '&lt;find pattern here&gt;'
    Otherwise, the find-again is the same as the search-with-present-options command.'''

    h = self.getHandler()

    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to search-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)
</t>
<t tx="ekr.20071211113302.208">def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=False)

def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=False)

def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=True)

def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=True)

def isearchWithPresentOptions (self,event):
    '''Begin an incremental regexp search using the regexp and reverse options from the find panel.'''
    self.startIncremental(event,forward=None,ignoreCase=None,regexp=None)
</t>
<t tx="ekr.20071211113302.209">def iSearchBackspace (self):

    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.w

    if not self.isearch_stack:
        ins = w.getInsertPoint()
        self.endSearch(ins,ins)
        return 

    gui.set_focus(c,w)
    pattern = k.getLabel(ignorePrompt=True)
    self.scolorizer(event=None,pattern=pattern)

    sel,ins = self.isearch_stack.pop()

    if sel:
        i,j = sel
        w.setSelectionRange(i,j,insert=ins)
    else:
        w.setInsertPoint(ins)

    w.seeInsertPoint()

    if not self.isearch_stack:
        self.endSearch(ins,ins)
</t>
<t tx="ekr.20071211113302.210">def startIncremental (self,event,forward,ignoreCase,regexp):

    c = self.c ; k = self.k ; w = self.w

    # None is a signal to get the option from the find tab.
    if forward is None or regexp is None:
        self.openFindTab(show=False)
        if not self.minibufferFindHandler:
            self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)
        getOption = self.minibufferFindHandler.getOption
        # g.trace('reverse',getOption('reverse'))
        # g.trace('pattern',getOption('pattern_match'))
    else:
        getOption = lambda a: False # The value isn't used.

    self.event = event
    self.forward    = g.choose(forward is None,not getOption('reverse'),forward)
    self.ignoreCase = g.choose(ignoreCase is None,getOption('ignore_case'),ignoreCase)
    self.regexp     = g.choose(regexp  is None,getOption('pattern_match'),regexp)
    # Note: the word option can't be used with isearches!

    self.ins1 = ins = w.getInsertPoint()
    sel = w.getSelectionRange() or (ins,ins),
    self.isearch_stack = [(sel,ins),]

    k.setLabelBlue('Isearch%s%s%s: ' % (
            g.choose(self.forward,'',' Backward'),
            g.choose(self.regexp,' Regexp',''),
            g.choose(self.ignoreCase,' NoCase',''),
        ),protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
</t>
<t tx="ekr.20071211113302.211"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w

    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return

    c.bodyWantsFocusNow()
    if keysym == 'Return':
        i,j = w.getSelectionRange()
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
    elif keysym == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif ch:
        k.updateLabel(event)
        self.iSearchHelper(event)
        self.scolorizer(event)
</t>
<t tx="ekr.20071211113302.212">def scolorizer (self,event,pattern=None):

    '''Colorizer for incremental searches.'''

    pass # not ready yet.   

    # k = self.k ; w = self.w
    # s = pattern or k.getLabel(ignorePrompt=True)
    # # g.trace(repr(s))
    # w.tag_delete('color','color1')
    # if not s: return
    # if g.app.gui.guiName() != 'tkinter':
        # return g.es('command not ready yet',color='blue')

    # ind = 0
    # index = w.getInsertPoint()
    # index2 = index + len(s)
    # # g.trace(index,index2)
    # # Colorize in the forward direction, regardless of the kind of search.
    # while ind:
        # try:
            # ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        # except Exception: break
        # if ind:
            # i, d = ind.split('.')
            # d = str(int(d)+len(s))
            # # g.trace(ind)
            # if ind in (index,index2):
                # w.tag_add('color1',ind,'%s.%s' % (i,d))
            # w.tag_add('color',ind,'%s.%s' % (i,d))
            # ind = i + '.' + d

    # w.tag_config('color',foreground='red')
    # w.tag_config('color1',background='lightblue')
</t>
<t tx="ekr.20071211113302.213">def iSearchHelper (self,event):

    '''Move the cursor to position that matches the pattern in the miniBuffer.
    isearches do not cross node boundaries.'''

    c = self.c ; gui = g.app.gui ; k = self.k ; w = self.w
    p = c.currentPosition()
    self.searchString = pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    s = w.getAllText()

    if self.isearch_v != p.v:
        self.isearch_v = p.v
        self.isearch_stack = []

    sel = w.getSelectionRange()
    startindex = insert = w.getInsertPoint()

    if self.forward:
        i1 = startindex
        j1 = len(s)
    else:
        i1 = 0
        j1 = min(len(s),startindex + len(pattern))

    i,j = self.ifinder.searchHelper(s,i1,j1,pattern,
        backwards=not self.forward,
        nocase=self.ignoreCase,
        regexp=self.regexp,
        word=False, # Incremental word-matches are not possible!
        swapij=False)

    if i != -1:
        self.isearch_stack.append((sel,insert),)
        # g.trace(i1,j1,i,j,pos,newpos)
        gui.set_focus(c,w)
        w.setSelectionRange(i,j,insert=i)
</t>
<t tx="ekr.20071211113302.214">def endSearch (self,i,j):

    w = self.w
    w.tag_delete('color','color1')

    insert = g.choose(self.forward,'sel.end','sel.start')
    w.setSelectionRange(i,j,insert=insert)

    self.k.keyboardQuit(event=None)</t>
<t tx="ekr.20071211113302.215">@
Also added sort-lines-ignoring-case, reverse-sort-lines and reverse-sort-lines-ignoring-case.</t>
<t tx="ekr.20071211113302.216">def reverseSortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True,reverse=True)

def reverseSortLines(self,event):
    return self.sortLines(event,reverse=True)

def sortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True)

def sortLines (self,event,ignoreCase=False,reverse=False):

    '''Sort lines of the selected text by comparing the entire text of a line.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not self._chckSel(event): return

    undoType = g.choose(reverse,'reverse-sort-lines','sort-lines')
    self.beginCommand(undoType=undoType)
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        s2 = s[i:j]
        if not s2.endswith('\n'): s2 = s2+'\n'
        aList = g.splitLines(s2)
        if ignoreCase:  aList.sort(key=string.lower)
        else:           aList.sort()
        if reverse:     aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20071211113302.217"></t>
<t tx="ekr.20071211113302.218">@others
</t>
<t tx="ekr.20071211113302.219">class spellCommandsClass (baseEditCommandsClass):

    '''Commands to support the Spell Tab.'''

    @others
</t>
<t tx="ekr.20071211113302.220">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.handler = None

    # All the work happens when we first open the frame.
</t>
<t tx="ekr.20071211113302.221">def getPublicCommands (self):

    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
</t>
<t tx="ekr.20071211113302.222">def openSpellTab (self,event=None):

    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        self.handler = spellTabHandler(c,tabName)
        if not self.handler.loaded:
            log.deleteTab(tabName,force=True)
</t>
<t tx="ekr.20071211113302.223"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()

def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
</t>
<t tx="ekr.20071211113302.224">class spellTabHandler (leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""

    @others
</t>
<t tx="ekr.20071211113302.225"></t>
<t tx="ekr.20071211113302.226">def __init__(self,c,tabName):

    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = g.app.gui.plainTextWidget(c.frame.top)
        # A text widget for scanning.
        # Must have a parent frame even though it is not packed.

    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.tab = g.app.gui.createSpellTab(c,self,tabName)
</t>
<t tx="ekr.20071211113302.227">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"..","plugins",'spellpyx.txt'))

    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)

    if self.aspell.aspell:
        self.dictionary = self.readDictionary(dictionaryFileName)
    else:
        self.dictionary = False
        # g.es_print('Can not open Aspell',color='red')

    return self.aspell.aspell
</t>
<t tx="ekr.20071211113302.228">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary

    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""

    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
</t>
<t tx="ekr.20071211113302.229"></t>
<t tx="ekr.20071211113302.230">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""

    if not self.currentWord: return

    # g.trace(self.currentWord)

    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
</t>
<t tx="ekr.20071211113302.231">def change(self,event=None):
    """Make the selected change to the text"""

    # __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; w = body.bodyCtrl

    selection = self.tab.getSuggestion()
    if selection:
        if hasattr(self.tab,'change_i') and self.tab.change_i is not None:
            start,end = oldSel = self.tab.change_i,self.tab.change_j
            # g.trace('using',start,end)
        else:
            start,end = oldSel = w.getSelectionRange()
        if start:
            if start &gt; end: start,end = end,start
            w.delete(start,end)
            w.insert(start,selection)
            w.setSelectionRange(start,start+len(selection))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20071211113302.232">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        # Save the selection range.
        ins = w.getInsertPoint()
        i,j = w.getSelectionRange()
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Restore the selection range.
        w.setSelectionRange(i,j,insert=ins)
        w.see(ins)
        ### w.update() ###
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20071211113302.233">def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.currentPosition()
    w = c.frame.body.bodyCtrl
    aspell = self.aspell ; alts = None ; word = None
    trace = False
    try:
        while 1:
            i,j,p,word = self.findNextWord(p)
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if trace: g.trace('alts',alts and len(alts) or 0,i,j,word,p and p.headString() or 'None')
            if alts:
                c.beginUpdate()
                try:
                    c.frame.tree.expandAllAncestors(p)
                    c.selectPosition(p)
                finally:
                    c.endUpdate()
                    w.setSelectionRange(i,j,insert=j)
                break
    except Exception:
        g.es_exception()
    return alts, word
</t>
<t tx="ekr.20071211113302.234">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
</t>
<t tx="ekr.20071211113302.235">def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; p = p.copy() ; trace = False
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i &lt; len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.headString(),'i',i,'len(s)',len(s))
        if i &lt; len(s):
            # A non-empty word has been found.
            j = i
            while j &lt; len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            if trace: g.trace(i,j,word,p.headString())
            return i,j,p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.bodyString())
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
            if trace: g.trace(0,0,'--&gt;',p.headString())

    return None,None,None,None</t>
<t tx="ekr.20071211113302.236">def hide (self,event=None):

    self.c.frame.log.selectTab('Log')

    for message in self.messages:
        g.es(message,color='blue')

    self.messages = []
</t>
<t tx="ekr.20071211113302.237">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""

    if not self.currentWord: return

    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
</t>
<t tx="ekr.20071211113302.238">class AspellClass:

    """A wrapper class for Aspell spell checker"""

    @others
</t>
<t tx="ekr.20071211113302.239"></t>
<t tx="ekr.20071211113302.240">def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = g.os_path_abspath(c.config.getString('aspell_dir'))
    self.aspell_bin_dir = g.os_path_abspath(c.config.getString('aspell_bin_dir'))
    self.diagnose = c.config.getBool('diagnose-aspell-installation')

    self.local_language_code = local_language_code or 'en'
    self.local_dictionary_file = g.os_path_abspath(local_dictionary_file)
    self.local_dictionary = "%s.wl" % os.path.splitext(self.local_dictionary_file) [0]

    # g.trace('code',self.local_language_code,'dict',self.local_dictionary_file)
    # g.trace('dir',self.aspell_dir,'bin_dir',self.aspell_bin_dir)

    self.aspell = self.sc = None

    if ctypes:
        self.getAspellWithCtypes()
    else:
        self.getAspell()
</t>
<t tx="ekr.20071211113302.241">def getAspell (self):

    if sys.platform.startswith('linux'):
        self.report('You must be using Python 2.5 or above to use aspell on Linux')
        return

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=None,verbose=False)

    if not aspell:
        self.report('can not import aspell')

    self.aspell = aspell
    self.sc = aspell and aspell.spell_checker(prefix=self.aspell_dir,lang=self.local_language_code)
</t>
<t tx="ekr.20071211113302.242">def getAspellWithCtypes (self):

    try:
        c_int, c_char_p = ctypes.c_int, ctypes.c_char_p

        if sys.platform.startswith('win'):
            path = g.os_path_join(self.aspell_bin_dir, "aspell-15.dll")
            self.aspell = aspell = ctypes.CDLL(path)
        else:
            path = 'aspell'
            libname = ctypes.util.find_library(path)
            assert(libname)
            self.aspell = aspell = ctypes.CDLL(libname)
    except Exception:
        self.report('Can not load %s' % (path))
        self.aspell = self.check = self.sc = None
        return

    try:
        &lt;&lt; define and configure aspell entry points &gt;&gt;
    except Exception:
        self.report('aspell checker not enabled')
        self.aspell = self.check = self.sc = None
        return

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
</t>
<t tx="ekr.20071211113302.243"># new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p] 

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_int, c_char_p] 

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p  

sc = new_aspell_config()
if 0:
    print sc 
    print aspell_config_replace(sc, "prefix", self.aspell_dir) #1/0 
    print 'prefix', self.aspell_dir, `aspell_config_retrieve(sc, "prefix")`
    print aspell_config_retrieve(sc, "lang")
    print aspell_config_replace(sc, "lang",self.local_language_code)
    print aspell_config_retrieve(sc, "lang")

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))

# Rudimentary error checking, needs more.  
if aspell.aspell_error_number(possible_err) != 0:
    self.report(aspell_error_message(possible_err))
    spell_checker = None
else: 
    spell_checker = aspell.to_aspell_speller(possible_err)

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_int
word_list_size.argtypes = [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_int
word_list_elements.argtypes = [c_int,]

# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_int 
suggest.argtypes = [c_int, c_char_p, c_int]</t>
<t tx="ekr.20071211113302.244">def report (self,message):

    if self.diagnose:
        g.es_print(message,color='blue')
</t>
<t tx="ekr.20071211113302.245">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; «original» «count» «offset»: «miss», «miss», ... 
    None: 
    # «original» «offset» 
    simplifyed to not create the string then make a list from it
    """

    # g.trace('word',word)

    if not self.aspell:
        g.trace('aspell not installed')
        return None
    elif ctypes:
        if self.check(self.spell_checker,word,len(word)):
            return None
        else:
            return self.suggestions(word)
    else:
        if self.sc.check(word):
            return None
        else:
            return self.sc.suggest(word)
</t>
<t tx="ekr.20071211113302.246">def suggestions(self,word):

    "return list of words found"

    aList = []
    sw = self.suggest(self.spell_checker, word, len(word))

    if self.word_list_size(sw):
        ewords = self.word_list_elements(sw)
        while 1: 
            x = self.string_enumeration_next(ewords)
            if x is None: break
            aList.append(x)
    return aList</t>
<t tx="ekr.20071211113302.247">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.

    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        # g.es_print("Unable to update local aspell dictionary: %s" % err)
        print "Unable to update local aspell dictionary: %s" % (err)
        return False
</t>
<t tx="ekr.20071211113302.248">There is also an @bool trace_plugins setting.</t>
<t tx="ekr.20071211113302.249">def loadOnePlugin (moduleOrFileName, verbose=False):

    global loadedModules,loadingModuleNameStack

    verbose = verbose or g.app.config.getBool(c=None,setting='trace_plugins')
    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    if moduleOrFileName.endswith('.py'):
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            s = 'plugin %s already loaded' % moduleName
            g.es_print(s,color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path,pluginName=moduleName,verbose=True)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        if hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                if init_result:
                    loadedModules[moduleName] = result
                else:
                    if verbose and not g.app.initing: ## or not g.app.unitTesting:
                        g.es_print('loadOnePlugin: loading module %s failed' % (moduleName),color="red")
                    result = None
            except Exception:
                g.es('Exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.
            g.trace('no init()',moduleName)
            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if g.unitTesting or g.app.batchMode or g.app.inBridge:
        pass
    elif result is None:
        if warn_on_failure or (verbose and not g.app.initing): # or not g.app.unitTesting:
            s = 'can not load enabled %s plugin' % moduleName
            g.es_print(s,color="red")
    elif verbose:
        s = 'loaded %s plugin' % moduleName
        g.es_print(s,color="blue")

    return result
</t>
<t tx="ekr.20071211113302.250">@ 1/6/05: The problem with Tkinter is that imp.load_module is equivalent to reload.

The solutions is easy: simply return sys.modules.get(moduleName) if moduleName is in sys.modules!
</t>
<t tx="ekr.20071211113302.251">def cantImport (moduleName,pluginName=None,verbose=True):

    """Print a "Can't Import" message and return None."""

    s = "Can not import %s" % moduleName
    if pluginName: s = s + " from plugin %s" % pluginName

    if not g.app or not g.app.gui:
        print s
    elif g.unitTesting:
        return
    elif g.app.gui.guiName() == 'tkinter' and moduleName in ('Tkinter','Pmw'):
        return
    else:
        g.es_print(s,color="blue")

</t>
<t tx="ekr.20071211113302.252">def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''

    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except Exception: # Importing a module can throw exceptions other than ImportError.
                g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
        finally:
            if theFile: theFile.close()
    return module
</t>
<t tx="ekr.20071211113302.253">def importExtension (moduleName,pluginName=None,verbose=False,required=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''

    # g.trace(verbose,moduleName,pluginName)

    import os

    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    extensionsDir = g.app and g.app.extensionsDir or os.path.join(os.path.dirname(__file__),'..','extensions')

    if not module:
        module = g.importFromPath(moduleName,extensionsDir,pluginName=pluginName,verbose=verbose)

        if not module and required:
            g.cantImportDialog(pluginName,moduleName)
            try: # Avoid raising SystemExit if possible.
                import os ; os._exit(1) # May not be available on all platforms.
            except Exception:
                import sys ; sys.exit(1)

    return module
</t>
<t tx="ekr.20071211113302.254">def cantImportDialog (pluginName,moduleName):

    '''Attempt to show a Tk dialog if an import fails.
    Yes, this is a small Tk dependency, but it can't be helped.'''

    message = '''
%s requires the %s module.
Official distributions contain this module in Leo's extensions folder,
but this module may be missing if you get Leo from cvs.
''' % (pluginName,moduleName)

    if 1: # Requires minimal further imports.
        try:
            import Tkinter as Tk
            root = g.app.root or Tk.Tk()
            title = 'Can not import %s' % moduleName
            top = createDialogFrame(Tk,root,title,message)
            root.wait_window(top)
        except ImportError:
            print 'Can not import %s' % moduleName
            print 'Can not import Tkinter'
            print 'Leo must now exit'

    else: # Can cause import problems during startup.
        import leoTkinterDialog

        d = leoTkinterDialog.tkinterAskOk(
            c=None,title='Can not import %s' %(moduleName),
            message=message)
        d.run(modal=True)
</t>
<t tx="ekr.20071211113302.255">def createDialogFrame(Tk,root,title,message):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    top = Tk.Toplevel(root)
    top.title(title)

    def onKey(event,top=top):
        if event.char.lower() in ('\n','\r'):
            top.destroy()
    top.bind("&lt;Key&gt;",onKey)

    f = Tk.Frame(top)
    f.pack(side="top",expand=1,fill="both")

    label = Tk.Label(f,text=message)
    label.pack(pady=10)

    def okButton(top=top):
        top.destroy()

    buttons = {"text":'OK',"command":okButton,"default":True}, # Singleton tuple.
    createDialogButtons(Tk,top,buttons)

    center(top)
    top.lift()
    top.focus_force()

    # Attach the icon at idle time.
    def attachIconCallback(top=top):
        g.app.gui.attachLeoIcon(top)
    top.after_idle(attachIconCallback)

    return top
</t>
<t tx="ekr.20071211113302.256">def createDialogButtons (Tk,top,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    f = Tk.Frame(top)
    f.pack(side="top",padx=30)

    for d in buttons:
        text = d.get("text","&lt;missing button name&gt;")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
</t>
<t tx="ekr.20071211113302.257">def center(top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = g.get_window_info(top)

    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))

    return w,h,x,y
</t>
<t tx="ekr.20071211113302.258"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (top):

    # This is an emergency measure: this call is NOT a major Tk-dependency.
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)

    return w,h,x,y
</t>
<t tx="ekr.20071211113302.259">def importFromPath (name,path,pluginName=None,verbose=False):

    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path,app and app.tkEncoding or 'ascii')

    # g.trace(verbose,name,pluginName)
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName,[path]) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                if 0: # verbose:
                    g.es_print("Exception in g.importFromPath",color='blue')
                    g.es_exception()
            except Exception:
                g.es_print("unexpected exception in g.importFromPath(%s)" %
                    (name),color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally: 
            if theFile: theFile.close()

    if not module:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
</t>
<t tx="ekr.20071211113302.260"></t>
<t tx="ekr.20071211113302.261">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4622384

vim.py does not open url nodes if the new setting: 

@bool vim_plugin_opens_url_nodes 

is False (or does not exist). 

@color</t>
<t tx="ekr.20071211113302.262"># The code now remembers the relative file name as well as the full path name.
# This may help find the icon when multiple machines are involved.</t>
<t tx="ekr.20071211113302.263">def makePathRelativeTo (fullPath,basePath):

    if fullPath.startswith(basePath):
        s = fullPath[len(basePath):]
        if s.startswith(os.path.sep):
            s = s[len(os.path.sep):]
        return s
    else:
        return fullPath
</t>
<t tx="ekr.20071211113302.264">def getPublicCommands (self):        

    c = self.c ; k = self.k 

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-all-lines':                      self.cleanAllLines,
        'clean-lines':                          self.cleanLines,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'cycle-all-focus':                      self.cycleAllFocus,
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        'delete-all-icons':                     self.deleteAllIcons,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-first-icon':                    self.deleteFirstIcon,
        'delete-indentation':                   self.deleteIndentation,
        'delete-last-icon':                     self.deleteLastIcon,
        'delete-node-icons':                    self.deleteNodeIcons,
        'delete-spaces':                        self.deleteSpaces,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-icon':                          self.insertIcon,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'reverse-sort-lines':                   self.reverseSortLines,
        'reverse-sort-lines-ignoring-case':     self.reverseSortLinesIgnoringCase,                 
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-all':                           self.selectAllText,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'sort-lines-ignoring-case':             self.sortLinesIgnoringCase,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20071211113302.265">def drawUserIcons(self,p,where,x,y):

    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""

    h,w = 0,0 ; t = p.v.t

    if not hasattr(t,"unknownAttributes"):
        return h,w

    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w

    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()

    # g.trace(where,h,w)

    return h,w
</t>
<t tx="ekr.20071211113302.266">def drawUserIcon (self,p,where,x,y,w2,theDict):

    c = self.c ; h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # if self.trace_gc: g.printNewObjects(tag='userIcon 1')

    # g.trace(where,x,y,theDict)

    &lt;&lt; set offsets and pads &gt;&gt;
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            &lt;&lt; draw the icon in string s &gt;&gt;
    elif theType == "file":
        theFile = theDict.get("file")
        relPath = theDict.get('relPath')
        &lt;&lt; draw the icon at file &gt;&gt;
    elif theType == "url":
        ## url = theDict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;

    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    # if self.trace_gc: g.printNewObjects(tag='userIcon 2')

    return h,w
</t>
<t tx="ekr.20071211113302.267">xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
</t>
<t tx="ekr.20071211113302.268">pass
</t>
<t tx="ekr.20071211113302.269">if relPath:
    fullname = g.os_path_join(g.app.loadDir,"..","Icons",relPath)
else:
    fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
fullname = g.os_path_normpath(fullname)

# Bug fix: the key must include distinguish nodes.
key = (fullname,p.v.t)
image = self.iconimages.get(key)

if not image:
    try:
        from PIL import Image, ImageTk
        image1 = Image.open(fullname)
        image = ImageTk.PhotoImage(image1)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if not image:
    try:
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image)

    tag='userIcon-%s' % theId
    self.canvas.itemconfigure(theId,tag=tag)
    self.ids[theId] = p.copy()

    def deleteButtonCallback(event=None,c=c,t=p.v.t,fullname=fullname,relPath=relPath):
        c.editCommands.deleteIconByName(t,fullname,relPath)

    self.canvas.tag_bind(tag,'&lt;3&gt;',deleteButtonCallback)

    # assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad
</t>
<t tx="ekr.20071211113302.270">pass
</t>
<t tx="ekr.20071211113302.271">@

To do:

- Define standard icons in a subfolder of Icons folder?
- Tree control recomputes height of each line.
</t>
<t tx="ekr.20071211113302.272">def deleteAllIcons (self,event):

    c = self.c

    for p in c.allNodes_iter():

        if hasattr(p.v.t,"unknownAttributes"):
            a = p.v.t.unknownAttributes
            iconsList = a.get("icons")
            if dict:
                a["icons"] = []
                a["lineYOffset"] = 0
                p.setDirty()
                c.setChanged(True)

    c.redraw()
</t>
<t tx="ekr.20071211113302.273">def deleteFirstIcon (self,event):

    c = self.c ; p = c.currentPosition()

    if not hasattr(p.v.t,'unknownAttributes'):
        return

    aList = p.v.t.unknownAttributes.get('icons',[])

    if aList:
        p.v.t.unknownAttributes ['icons'] = aList[1:]
        p.setDirty()
        c.setChanged(True)
        c.redraw()</t>
<t tx="ekr.20071211113302.274">def deleteIconByName (self,t,name,relPath):

    c = self.c ; p = c.currentPosition()

    if not hasattr(t,'unknownAttributes'):
        return

    aList = t.unknownAttributes.get('icons',[])

    basePath = g.os_path_abspath(g.os_path_normpath(g.os_path_join(g.app.loadDir,"..","Icons")))
    absRelPath = g.os_path_abspath(g.os_path_normpath(g.os_path_join(basePath,relPath)))
    name = g.os_path_abspath(name)

    for d in aList:
        name2 = d.get('file')
        name2 = g.os_path_abspath(name2)
        name2rel = d.get('relPath')
        # g.trace('name',name,'\nrelPath',relPath,'\nabsRelPath',absRelPath,'\nname2',name2,'\nname2rel',name2rel)
        if name == name2 or absRelPath == name2 or relPath == name2rel:
            aList.remove(d)
            t.unknownAttributes ['icons'] = aList
            p.setDirty()
            c.setChanged(True)
            c.redraw()
            break
    else:
        g.trace('not found',name)



</t>
<t tx="ekr.20071211113302.275">def deleteLastIcon (self,event):

    c = self.c ;  p = c.currentPosition()

    if not hasattr(p.v.t,'unknownAttributes'):
        return

    aList = p.v.t.unknownAttributes.get('icons',[])

    if aList:
        p.v.t.unknownAttributes ['icons'] = aList[:-1]
        p.setDirty()
        c.setChanged(True)
        c.redraw()
</t>
<t tx="ekr.20071211113302.276">def deleteNodeIcons (self,event):

    c = self.c ; p = c.currentPosition()

    if hasattr(p.v.t,"unknownAttributes"):
        a = p.v.t.unknownAttributes
        iconsList = a.get("icons")
        if dict:
            a["icons"] = []
            a["lineYOffset"] = 0
            p.setDirty()
            c.setChanged(True)
            c.redraw()
</t>
<t tx="ekr.20071211113302.277">def insertIcon (self,event):

    c = self.c ; p = c.currentPosition()

    os.chdir(g.os_path_normpath(g.os_path_join(g.app.loadDir,"..","Icons")))

    paths = g.app.gui.runOpenFileDialog(
        title='Get Icons',
        filetypes=[('All files','*'),('Gif','*.gif'), ('Bitmap','*.bmp'),('Icon','*.ico'),],
        defaultextension=None,
        multiple=True)

    aList = [] ; xoffset = 2
    basePath = g.os_path_abspath(g.os_path_normpath(g.os_path_join(g.app.loadDir,"..","Icons")))
    for path in paths:
        path = g.os_path_abspath(g.os_path_join(basePath,path))
        relPath = g.makePathRelativeTo(path,basePath)
        image,image_height = self.getImage(path)
        if not image:
            g.es('can not load image: %s' % (path))
            return
        if image_height is None:
            yoffset = 0
        else:
            yoffset = (c.frame.tree.line_height-image_height)/2

        aList.append ({
            'type' : 'file',
            'file' : path,
            'relPath': relPath,
            'where' : 'beforeHeadline',
            'yoffset' : yoffset, 'xoffset' : xoffset, 'xpad' : -2,
        })
        xoffset += 2

    if not hasattr(p.v.t,'unknownAttributes'):
        p.v.t.unknownAttributes = {}

    aList2 = p.v.t.unknownAttributes.get('icons',[])
    aList2.extend(aList)
    p.v.t.unknownAttributes ['icons'] = aList2
    p.v.t.unknownAttributes ['lineYOffset'] = 3
    p.setDirty()
    c.setChanged(True)
    c.redraw()</t>
<t tx="ekr.20071211113302.278">def getImage (self,path):

    c = self.c

    try:
        from PIL import Image
    except ImportError:
        Image = None

    try:
        from PIL import ImageTk
    except ImportError:
        try:
            import ImageTk
        except ImportError:
            ImageTk = None

    try:
        if Image and ImageTk:
            image1 = Image.open(path)
            image = ImageTk.PhotoImage(image1)
        else:
            import Tkinter as Tk
            image = Tk.PhotoImage(master=c.frame.tree.canvas,file=path)
        return image,image.height()
    except Exception:
        return None,None
</t>
<t tx="ekr.20071211113302.279">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4614081
</t>
<t tx="ekr.20071211113302.280">http://tango.freedesktop.org/Tango_Icon_Library

You need to have libmagick6-dev installed in adition to imagemagick
</t>
<t tx="ekr.20071211113302.281"></t>
<t tx="ekr.20071211113302.282"></t>
<t tx="ekr.20071211113302.283"># fixed: E1101:1877:atFile.readEndNode: Instance of 'atFile' has no 'correctedLines' member
# fixed: E1101:2725:atFile.norefWrite: Instance of 'atFile' has no 'putBuffered' member
</t>
<t tx="ekr.20071211113302.284"></t>
<t tx="ekr.20071211113302.285"></t>
<t tx="ekr.20071211113302.286">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4632695
By: zhms

I've made many tries, and finally i think i have caught the issue.
It's caused by "Paste Node as Clone".

1. Just open a leo file,
2. create some nodes,
3. and cut a node,
4. then use "past node as clone",
5. save and quit or quit and select "yes" to save.
Ok, the file is already truncated.

--------------

The recent fix to c.all_unique_tnodes_iter may be part of the problem.
</t>
<t tx="ekr.20071211113302.287"></t>
<t tx="ekr.20071211113302.288">class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):

    c = self
    return self.allNodes_iter_class(c,copy)

all_positions_iter = allNodes_iter</t>
<t tx="ekr.20071211113302.289">def __init__(self,c,copy):

    # g.trace('c.allNodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None
    self.copy = copy

def __iter__(self):

    return self
</t>
<t tx="ekr.20071211113302.290">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p

    else: raise StopIteration
</t>
<t tx="ekr.20071211113302.291"># def all_tnodes_iter(self):

    # c = self
    # for p in c.all_positions_iter():
        # yield p.v.t

    # # return c.rootPosition().all_tnodes_iter(all=True)

class all_tnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_tnodes_iter (self):

    c = self
    return self.all_tnodes_iter_class(c)
</t>
<t tx="ekr.20071211113302.292">def __init__(self,c):

    # g.trace('c.all_tnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071211113302.293">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v.t

    else:
        raise StopIteration
</t>
<t tx="ekr.20071211113302.294"># def all_unique_tnodes_iter(self):

    # c = self ; marks = {}

    # for p in c.all_positions_iter():
        # if not p.v.t in marks:
            # marks[p.v.t] = p.v.t
            # yield p.v.t

class all_unique_tnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_unique_tnodes_iter (self):

    c = self
    return self.all_unique_tnodes_iter_class(c)
</t>
<t tx="ekr.20071211113302.295">def __init__(self,c):

    # g.trace('c.all_uniquetnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.d = {}
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071211113302.296">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v.t):
            self.d [self.p.v.t] = True
            return self.p.v.t

    raise StopIteration
</t>
<t tx="ekr.20071211113302.297"># def all_vnodes_iter(self):

    # c = self
    # for p in c.all_positions_iter():
        # yield p.v

class all_vnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_vnodes_iter (self):

    c = self
    return self.all_vnodes_iter_class(c)
</t>
<t tx="ekr.20071211113302.298">def __init__(self,c):

    # g.trace('c.all_tnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071211113302.299">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v

    else: raise StopIteration
</t>
<t tx="ekr.20071211113302.300"># def all_unique_vnodes_iter(self):

    # c = self ; marks = {}
    # for p in c.all_positions_iter():
        # if not p.v in marks:
            # marks[p.v] = p.v
            # yield p.v

class all_unique_vnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_unique_vnodes_iter (self):

    c = self
    return self.all_unique_vnodes_iter_class(c)
</t>
<t tx="ekr.20071211113302.301">def __init__(self,c):

    # g.trace('c.all_uniquetnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.d = {}
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20071211113302.302">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v.t):
            self.d [self.p.v.t] = True
            return self.p.v

    raise StopIteration
</t>
<t tx="ekr.20071211113302.303"></t>
<t tx="ekr.20071211113302.304">def cutOutline (self,event=None):

    '''Delete the selected outline and send it to the clipboard.'''

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()
</t>
<t tx="ekr.20071211113302.305">def copyOutline (self,event=None):

    '''Copy the selected outline to the clipboard.'''

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    c.fileCommands.assignFileIndices()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)
</t>
<t tx="ekr.20071211113302.306"># To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        &lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return

    c.beginUpdate()
    try:
        copiedBunchList = []
        if pasteAsClone:
            &lt;&lt; put only needed info in copiedBunchList &gt;&gt;
        undoData = u.beforeInsertNode(current,
            pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
        c.endEditing()
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        c.setRootPosition(c.findRootPosition(pasted)) # New in 4.4.2.
        u.afterInsertNode(pasted,undoType,undoData)
    finally:
        c.endUpdate()
        c.recolor()
</t>
<t tx="ekr.20071211113302.307">@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())
</t>
<t tx="ekr.20071211113302.308"># Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t

# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
</t>
<t tx="ekr.20071211113302.309">def pasteOutlineRetainingClones (self,event=None):

    '''Paste an outline into the present outline from the clipboard.
    Nodes *retain* their original identify.'''

    c = self

    return c.pasteOutline(reassignIndices=False)
</t>
<t tx="ekr.20071211113302.310">@nocolor

https://sourceforge.net/forum/message.php?msg_id=4646055
By: thyrsus

Running: "Leo 4.4.5 beta 1, build  1.223 , November 16, 2007, Python 2.5.0,
Tk 8.4.13, Pmw 1.2, linux2", (CVS from 2007-11-25 22:17 GMT), Fedora 7; the
leo process hangs, running the CPU as hard as it can; I don't see any memory
increase; the process will die on a signal but is otherwise unresponsive; I
could probably get a core image, but nothing like a python stack trace.   Additional
clues: just before this happens I'm editing perl code in a particular node,
and the colorization is really random - e.g., three blue characters in the middle
of an otherwise black seven character variable name.  Perhaps relevant: some
threading models under Linux exhibit a new process for each thread, observable
with "ps", but I only see the one python process.  Is there a particular threading
model required by the threaded colorizer?

I've just turned off the threaded colorizer plugin, and the appearance is much
more sane, but these hangs have only happened twice this morning, so I can't
say for sure that I'm in the clear until I spend a good deal more time, plus
I worry about the extra work involved in maintaining two colorizers.

---------- One of my responses.

There is one kind of coding blunder that can bring everything to a halt: calling
g.es, g.pdb or g.es_exception from the helper thread; neither pdb nor Tkinter
are not thread safe, so they **must not** be called from outside the main
thread.

I did find one call to g.es in the helper thread. It is in match_regexp_helper
in the except clause. To fix this, change the call to g.es to:

g.trace('Invalid regular expression: %s' % (pattern))

Looking at perl.py, we see several calls to match_seq_regexp, which in turn
calls match_regexp_helper. So if there are problems with the regex's, this will
hang Leo. This would also explain weird colorizing behavior.

@color
</t>
<t tx="ekr.20071211113302.311">@nocolor

https://sourceforge.net/forum/message.php?msg_id=4643992
By: rjshanley1

The following code snippet throws the exception shown

    abc::stuff::~destructor(){}
void abc::stuff::read(int* b) {}

    abc::otherStuff::~otherDestructor(){}
void abc::otherStuff::testUnitReady(OP* op) {}

int mtSetPrimaryMgr()

-------------------------------

Leo Log Window...
Leo 4.4.5 beta 1, build  1.223 , November 16, 2007
Python 2.5.1, Tk 8.4.14, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

Can not load c:\aspell\bin\aspell-15.dll
leoID = rshanley (in C:\)
global config dir: C:\Program Files\Leo\config
home dir: C:\
reading settings in C:\Program Files\Leo\config\leoSettings.leo
exception executing command
Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoCommands.py", line 281, in doCommand
    val = command(event)
  File "C:\Program Files\Leo\src\leoCommands.py", line 1525, in importAtFile
    c.importCommands.importFilesCommand(names,"@file")
  File "C:\Program Files\Leo\src\leoImport.py", line 890, in importFilesCommand
    v = self.createOutline(fileName,current)
  File "C:\Program Files\Leo\src\leoImport.py", line 744, in createOutline
    self.scanCText(s,p,atAuto=atAuto)
  File "C:\Program Files\Leo\src\leoImport.py", line 2649, in scanCText
    scanner.run(s,parent)
  File "C:\Program Files\Leo\src\leoImport.py", line 2579, in run
    ok = self.errors == 0 and self.check(s,parent)
  File "C:\Program Files\Leo\src\leoImport.py", line 1500, in check
    return self.checkTrialWrite()
  File "C:\Program Files\Leo\src\leoImport.py", line 1539, in checkTrialWrite
    ok = self.compareHelper(lines1,lines2,i,self.strict)
  File "C:\Program Files\Leo\src\leoImport.py", line 1590, in compareHelper
    self.checkLeadingWhitespace(line1)
  File "C:\Program Files\Leo\src\leoImport.py", line 1615, in
checkLeadingWhitespace
    report('leading whitespace not consistent with @tabwidth %d' % tab_width)
NameError: global name 'report' is not defined</t>
<t tx="ekr.20071211113302.312"># This was done to init base classes in a more standard way.
# It should have been done long ago.</t>
<t tx="ekr.20071211113302.313">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4639426
By: kayvan

Using LEO 4.4.5b1, build 1.223, from November 16, 2007.

I have a simple LEO file with one Headline (called Testing) containing the following
body text:

@root test.py
"""Testing"""

When I try to tangle it, I get the following:

Tangling...
exception executing command
Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoCommands.py", line 281, in doCommand
    val = command(event)
  File "C:\Program Files\Leo\src\leoCommands.py", line 1381, in tangleAll
    c.tangleCommands.tangleAll()
  File "C:\Program Files\Leo\src\leoTangle.py", line 601, in tangleAll
    ok = self.tangleTree(p,dont_report_errors)
  File "C:\Program Files\Leo\src\leoTangle.py", line 718, in tangleTree
    self.tanglePass1(p) # sets self.p
  File "C:\Program Files\Leo\src\leoTangle.py", line 663, in tanglePass1
    self.scanAllDirectives(p,require_path,report_errors) # calls
init_directive_ivars.
  File "C:\Program Files\Leo\src\leoTangle.py", line 3598, in scanAllDirectives
    self.setRootFromText(z,issue_error_flag)
  File "C:\Program Files\Leo\src\leoTangle.py", line 3267, in setRootFromText
    i,self.start_mode = g.scanAtRootOptions(s,0)
  File "C:\Program Files\Leo\src\leoGlobals.py", line 2984, in
scanAtRootOptions
    assert(g.match(s,i,"@root"))
AssertionError

@color</t>
<t tx="ekr.20071211113302.314">@ This code skips the file name used in @root directives.

File names may be enclosed in &lt; and &gt; characters, or in double quotes.  If a file name is not enclosed be these delimiters it continues until the next newline.
@c
def setRootFromText(self,s,err_flag):

    # g.trace(s)
    self.root_name = None
    i,self.start_mode = g.scanAtRootOptions(s,0)
    i = g.skip_ws(s,i)

    if i &gt;= len(s): return i
    # Allow &lt;&gt; or "" as delimiters, or a bare file name.
    if s[i] == '"':
        i += 1 ; delim = '"'
    elif s[i] == '&lt;':
        i += 1 ; delim = '&gt;'
    else: delim = g.body_newline

    root1 = i # The name does not include the delimiter.
    while i &lt; len(s) and s[i] != delim and not g.is_nl(s,i):
        i += 1
    root2 = i

    if delim != g.body_newline and not g.match(s,i,delim):
        if err_flag:
            g.scanError("bad filename in @root " + s[:i])
    else:
        self.root_name = string.strip(s[root1:root2])
    return i
</t>
<t tx="ekr.20071211113302.315">def runAtFileTest(c,p):

    """Common code for testing output of @file, @thin, etc."""

    at = c.atFileCommands
    child1 = p.firstChild()
    child2 = child1.next()
    h1 = child1.headString().lower().strip()
    h2 = child2.headString().lower().strip()
    assert(g.match(h1,0,"#@"))
    assert(g.match(h2,0,"output"))
    expected = child2.bodyString()

    # Compute the type from child1's headline.
    j = g.skip_c_id(h1,2)
    theType = h1[1:j]
    assert theType in ("@file","@thin","@nosent","@noref","@asis","@root",), "bad type: %s" % type

    thinFile = theType == "@thin"
    nosentinels = theType in ("@asis","@nosent")

    if theType == "@root":
        c.tangleCommands.tangle_output = ''
        c.tangleCommands.tangle(event=None,p=child1)
        at.stringOutput = c.tangleCommands.tangle_output
    elif theType == "@asis":
        at.asisWrite(child1,toString=True)
    elif theType == "@noref":
        at.norefWrite(child1,toString=True)
    else:
        at.write(child1,thinFile=thinFile,nosentinels=nosentinels,toString=True)
    try:
        result = g.toUnicode(at.stringOutput,"ascii")
        assert(result == expected)
    except AssertionError:
        &lt;&lt; dump result and expected &gt;&gt;
        raise
</t>
<t tx="ekr.20071211113302.316">print ; print '-' * 20
print "result..."
for line in g.splitLines(result):
    print "%3d" % len(line),repr(line)
print '-' * 20
print "expected..."
for line in g.splitLines(expected):
    print "%3d" % len(line),repr(line)
print '-' * 20
</t>
<t tx="ekr.20071211113302.317">@
This is the top level method of the second pass. It creates a separate C file
for each @root directive in the outline. The file is actually written only if
the new version of the file is different from the old version,or if the file did
not exist previously. If changed_only_flag FLAG is True only changed roots are
actually written.
@c

def put_all_roots(self):

    c = self.c ; outline_name = c.mFileName

    for section in self.root_list:

        # g.trace(section.name)
        file_name = g.os_path_join(self.tangle_directory,section.name)
        file_name = g.os_path_normpath(file_name)
        mode = c.config.output_newline
        # mode = g.choose(mode=="platform",'w','wb')
        textMode = mode == 'platform'
        if g.unitTesting:
            self.output_file = g.fileLikeObject()
            temp_name = 'temp-file'
        else:
            self.output_file,temp_name = g.create_temp_file(textMode=textMode)
        if not temp_name:
            g.es("Can not create temp file")
            break
        &lt;&lt;Get root specific attributes&gt;&gt;
        &lt;&lt;Put @first lines&gt;&gt;
        if self.use_header_flag and self.print_mode == "verbose":
            &lt;&lt; Write a banner at the start of the output file &gt;&gt;
        for part in section.parts:
            if part.is_root:
                self.tangle_indent = 0 # Initialize global.
                self.put_part_node(part,False) # output first lws
        self.onl() # Make sure the file ends with a cr/lf
        if g.unitTesting:
            self.tangle_output = self.output_file.get()
        self.output_file.close()
        self.output_file = None
        if not g.unitTesting:
            if self.errors + g.app.scanErrors == 0:
                g.update_file_if_changed(c,file_name,temp_name)
            else:
                g.es("unchanged:  " + file_name)
                &lt;&lt; Erase the temporary file &gt;&gt;</t>
<t tx="ekr.20071211113302.318"># Stephen Schaefer, 9/2/02
# Retrieve the full complement of state for the root node
self.language = section.root_attributes.language
self.single_comment_string = section.root_attributes.single_comment_string
self.start_comment_string = section.root_attributes.start_comment_string
self.end_comment_string = section.root_attributes.end_comment_string
self.use_header_flag = section.root_attributes.use_header_flag
self.print_mode = section.root_attributes.print_mode
self.path = section.root_attributes.path
self.page_width = section.root_attributes.page_width
self.tab_width = section.root_attributes.tab_width
# Stephen P. Schaefer, 9/13/2002
self.first_lines = section.root_attributes.first_lines
</t>
<t tx="ekr.20071211113302.319"># Stephen P. Schaefer 9/13/2002
if self.first_lines:
    self.os(self.first_lines)
</t>
<t tx="ekr.20071211113302.320">if self.single_comment_string:
    self.os(self.single_comment_string)
    self.os(" Created by Leo from: ")
    self.os(outline_name)
    self.onl() ; self.onl()
elif self.start_comment_string and self.end_comment_string:
    self.os(self.start_comment_string)
    self.os(" Created by Leo from: ")
    self.os(outline_name)
    self.oblank() ; self.os(self.end_comment_string)
    self.onl() ; self.onl()
</t>
<t tx="ekr.20071211113302.321">try: # Just delete the temp file.
    os.remove(temp_name)
except: pass
</t>
<t tx="ekr.20071211113302.322">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4639872
By: kayvan

I created a LEO outline with the following in it and started LEO-4.4.5-b1:

---------------------------------------------
Header: @nosent test.pyw
Body:
@language python
@tabwidth -4
@others

- Subheader: Test code
- Body:
  #!/usr/bin/env python
  from Tkinter import *
  root = Tk()
  w = Label(root, text="Hello world!")
  w.pack()
  root.mainloop()
---------------------------------------------

When I run Cmd-&gt;Run Script/Tests-&gt;Execute Script, I see the Tk window as expected.
When I hit the close button to kill the application, all is fine. From this
point on, any command I do (like Control-I, etc.) I see a message in the Log:

Ignoring command: already executing a command.

Nothing further can be done and I have to kill LEO with Task Manager.

The same actions work as expected with LEO-4.4.4-final.

@color</t>
<t tx="ekr.20071211113302.323">def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # print '*** script\n',script
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    execfile(scriptFile,d)
                else:
                    exec script in d
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
</t>
<t tx="ekr.20071211113302.324">def redirectScriptOutput (self):

    c = self

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
</t>
<t tx="ekr.20071211113302.325">def unredirectScriptOutput (self):

    c = self

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
</t>
<t tx="ekr.20071211113302.326">def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        parts = path.split('/')
        path = g.app.loadDir
        for part in parts:
            path = g.os_path_abspath(g.os_path_join(path,part))
    else:
        path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile.py'))

    # Write the file.
    try:
        f = file(path,'w')
        f.write(script)
        f.close()
    except Exception:
        path = None

    return path</t>
<t tx="ekr.20071211113302.327">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''

    # pychecker complains about initAllEditCommanders.

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            # __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # print 'endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers()
            k.newMinibufferWidget = None
</t>
<t tx="ekr.20071211113302.328">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = False or k.traceMasterCommand
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    &lt;&lt; define specialKeysyms &gt;&gt;
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val</t>
<t tx="ekr.20071211113302.329">specialKeysyms = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)</t>
<t tx="ekr.20071211113302.330">if stroke or len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
</t>
<t tx="ekr.20071211113302.331">def callStateFunction (self,event):

    k = self ; val = None

    # g.trace(k.state.kind)

    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')

    return val
</t>
<t tx="ekr.20071211113302.332">def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
</t>
<t tx="ekr.20071211113302.333">def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: pass # Ignore the key.
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
</t>
<t tx="ekr.20071211113302.334">@ Several problems still remain:

- Files that contain what look like section references.
- Underindented docstrings.</t>
<t tx="ekr.20071211113302.335">def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
</t>
<t tx="ekr.20071211113302.336">def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line %d' % (i+1))
        g.es_print('original line:  %s' % line1)
        g.es_print('generated line: %s' % line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i &gt;= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i &gt;= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print(repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.

    # elif (not strict and not g.unitTesting) and line1.lstrip() == line2.lstrip():
        # if not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace:
            # self.mismatchWarningGiven = True
            # self.checkLeadingWhitespace(line1)
            # self.warning('mismatch in leading whitespace')
            # g.es_print('first mismatched line at line %d' % (i+1))
            # g.es_print('original line:  %s' % line1)
            # g.es_print('generated line: %s' % line2)
        # return True # A match excluding leading whitespace.
    # else: # strict OR unit testing.
        # if not g.unitTesting or i+1 != expectedMismatch:
            # # g.trace('unitTesting',g.unitTesting)
            # g.es_print('*** first mismatch at line %d' % (i+1))
            # g.es_print('original line:  %s' % line1)
            # g.es_print('generated line: %s' % line2)
        # d ['actualMismatchLine'] = i+1
        # # g.trace('lines 1...\n',repr(lines1),'\nlines2...\n',repr(lines2))
        # return False
</t>
<t tx="ekr.20071211113302.337">def underindentedComment (self,line):

    if self.atAutoWarnsAboutLeadingWhitespace:
        self.warning(
            'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
</t>
<t tx="ekr.20071211113302.338"></t>
<t tx="ekr.20071211113302.339"></t>
<t tx="ekr.20071211113302.340">@nocolor

https://sourceforge.net/forum/message.php?msg_id=4658901

Making the modifications you proposed I still was not able to open any outline.

Only if I open Leo w/o a file I was able to retrieve the following information
from the cms-shell:

&lt;Log&gt;

reading settings in C:\CVS-Reps\leo\config\leoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\myLeoSettings.leo
reading C:\Dokumente und Einstellungen\VR\.leoRecentFiles.txt
@enabled-plugins found in myLeoSettings.leo
rst3 plugin: SilverCity not loaded
loadOnePlugin: no init() detect_urls
loadOnePlugin: no init() empty_leo_file
redefining close-window in all to extend-to-word in all
redefining goto-first-node in tree to goto-first-visible-node in tree
redefining goto-first-node in tree to goto-first-visible-node in all
redefining goto-first-node in tree to goto-first-visible-node in all
redefining forward-sentence in text to propagate-key-event in all
redefining forward-word in text to propagate-key-event in all
redefining kill-region-save in all to propagate-key-event in all
Traceback (most recent call last):
  File "C:\CVS-Reps\leo\src\leo.py", line 428, in ?
    run()
  File "C:\CVS-Reps\leo\src\leo.py", line 146, in run
    c,frame = createFrame(fileName,relativeFileName)
  File "C:\CVS-Reps\leo\src\leo.py", line 221, in createFrame
    initEditCommanders=True)
  File "C:\CVS-Reps\leo\src\leoApp.py", line 583, in newLeoCommanderAndFrame
    c.finishCreate(initEditCommanders)
  File "C:\CVS-Reps\leo\src\leoCommands.py", line 223, in finishCreate
    c.frame.log.finishCreate()
  File "C:\CVS-Reps\leo\src\leoTkinterFrame.py", line 2096, in finishCreate
    c.spellCommands.openSpellTab()
  File "C:\CVS-Reps\leo\src\leoEditCommands.py", line 8051, in openSpellTab
    self.handler = spellTabHandler(c,tabName)
  File "C:\CVS-Reps\leo\src\leoEditCommands.py", line 8131, in __init__
    self.loaded = self.init_aspell(c)
  File "C:\CVS-Reps\leo\src\leoEditCommands.py", line 8151, in init_aspell
    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)
  File "C:\CVS-Reps\leo\src\leoEditCommands.py", line 8442, in __init__
    if ctypes:
UnboundLocalError: local variable 'ctypes' referenced before assignment
&gt;&gt;&gt;

&lt;/Log&gt;

To ease your analyis, I'm also adding my local output w/ Leo-4.4.5-beta-1,
which works w/o a problem:

&lt;Log&gt;

Leo Log Window...
Leo 4.4.5 beta 1, build  1.223 , November 16, 2007
Python 2.4.3, Tk 8.4.7, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

redefining close-window in all to extend-to-word in all
redefining goto-first-node in tree to goto-first-visible-node in tree
redefining goto-first-node in tree to goto-first-visible-node in all
redefining goto-first-node in tree to goto-first-visible-node in all
redefining forward-sentence in text to propagate-key-event in all
redefining forward-word in text to propagate-key-event in all
redefining kill-region-save in all to propagate-key-event in all
Can not import aspell
can not import aspell
leoID = vr20060903 (in C:\Dokumente und Einstellungen\VR)
global config dir: C:\Programme\Leo\config
home dir: C:\Dokumente und Einstellungen\VR
reading settings in C:\Programme\Leo\config\leoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\myLeoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\Eigene
Dateien\WLog\WLog.leo
reading: C:\Dokumente und Einstellungen\VR\Eigene Dateien\WLog\WLog.leo

&lt;/Log&gt;

Kind regards,

    Viktor Ransmayr
</t>
<t tx="ekr.20071211113302.341">@nocolor

leoEditCommands now tries to import ctypes at the top level.
If there is an ImportError, ctypes is set to None.</t>
<t tx="ekr.20071211113302.342"></t>
<t tx="ekr.20071211113302.343">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4652514
By: terry_n_brown

@auto seems to be munging decorators.

Starting with the decorator in the right place, it gets written correctly as:

class Index:
...."""docstring"""
....@cherrypy.expose
....def index(self):
........return "Hello world!"

but on read the body text for node 'class Index' is:

class Index:
...."""docstring"""
....@cherrypy.expose
....@others
</t>
<t tx="ekr.20071211113302.344"></t>
<t tx="ekr.20071211113302.345">def find_line_start(s,i):

    if i &lt; 0: return 0 # New in Leo 4.4.5: add this defensive code.
    # bug fix: 11/2/02: change i to i+1 in rfind
    i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
    if i == -1: return 0
    else: return i + 1
</t>
<t tx="ekr.20071211113302.346">def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    # if not tags: return False

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    sigId = self.getSigId(ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent &lt; self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.sigStart = self.adjustDefStart(s,self.sigStart)
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Issue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
</t>
<t tx="ekr.20071211113302.347">def adjustDefStart (self,s,i):

    '''A hook to allow the Python importer to adjust the 
    start of a class or function to include decorators.'''

    if i == 0 or s[i-1] != '\n':
        return i

    while i &gt; 0:
        progress = i

        start = j = g.find_line_start(s,i-2)
        j = g.skip_ws(s,j)
        if not g.match(s,j,'@'):
            return i

        j += 1
        k = g.skip_id(s,j)
        word = s[j:k]

        if word and word not in g.globalDirectiveList:
            # g.trace(repr(word),repr(s[start:i]))
            i = start
            assert i &lt; progress
        else:
            return i
</t>
<t tx="ekr.20071211113302.348">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4654762
By: terry_n_brown

Looking at it again I've decided it's a real bug.  Here's how to make it
happen.

Open a file, create a new @auto node, and type into the @auto node the
following:


import time

class test:
....pass

def main():
....a = test()

if __name__='__main__': main()


First and last lines may be irrelevant.  Save the file.  Check it's content
externally.  Looks fine.

Now add a line which just say 'class test' above the 'class test:' line, and
use command that creates a child node from the select text using the first line
of the selected text as the node title.  I can't remember its name, but you
press ctrl-shft-D.  Repeat for main().  Save.  Check it's content externally
- the children are gone!  Must have been the gypsies :-)

-------------

The problem is that there is no @others directive, but the orphan warning didn't happen and the file was written.

@color
</t>
<t tx="ekr.20071211113302.349"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,
    nosentinels=False,thinFile=False,scriptWrite=False,
    toString=False,write_strips_blank_lines=None
):

    """Write a 4.x derived file."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    &lt;&lt; set at.targetFileName &gt;&gt;
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString,
        write_strips_blank_lines=write_strips_blank_lines)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.closeWriteFile()
            &lt;&lt; set dirty and orphan bits on error &gt;&gt;
    except Exception:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
</t>
<t tx="ekr.20071211113302.350">if toString:
    at.targetFileName = "&lt;string-file&gt;"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
</t>
<t tx="ekr.20071211113302.351"># Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors &gt; 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
</t>
<t tx="ekr.20071211113302.352">def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"&lt;string-file&gt;",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString,atAuto=True)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        if at.errors == 0:
            at.replaceTargetFileIfDifferent()
        else:
            g.es("Not written: " + at.outputFileName)
    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("Not written: " + at.outputFileName)

    return ok
</t>
<t tx="ekr.20071211113302.353">@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantAtAutoTree(p): # There is noting of value to write.
        g.es_print('%s not written:\n\
no children and less than 10 characters (excluding directives)' % (p.headString()),color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
</t>
<t tx="ekr.20071211113302.354">def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    s = p.bodyString()

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    # g.trace('s2',s2)

    return p.hasChildren() or len(s2.strip()) &gt;= 10
</t>
<t tx="ekr.20071211113302.355"># New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,nosentinels=False,toString=False,fromString='',atAuto=False):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v.t.bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if atAuto or (not toString and not nosentinels):
        at.warnAboutOrphandAndIgnoredNodes()
</t>
<t tx="ekr.20071211113302.356"># Called from writeOpenFile.

def warnAboutOrphandAndIgnoredNodes (self):

    # Always warn, even when language=="cweb"
    at = self ; root = at.root

    for p in root.self_and_subtree_iter():
        if not p.v.t.isVisited(): # Check tnode bit, not vnode bit.
            at.writeError("Orphan node:  " + p.headString())
            if p.hasParent():
                g.es("parent node: " + p.parent().headString(),color="blue")
            if not at.thinFile and p.isAtIgnoreNode():
                at.writeError("@ignore node: " + p.headString())

    if at.thinFile:
        p = root.copy() ; after = p.nodeAfterTree()
        while p and p != after:
            if p.isAtAllNode():
                p.moveToNodeAfterTree()
            else:
                if p.isAtIgnoreNode():
                    at.writeError("@ignore node: " + p.headString())
                p.moveToThreadNext()
</t>
<t tx="ekr.20071211113302.357">@nocolor

I have clones that traverse chapters.

Given the following Chapters:

&gt; Main
&gt; Big Picture
&gt; Smaller Chunk

I have in Main, my organization, with my group in it.  It's also cloned around
all the other views (really, everything starts in the Big Picture).

This is the layout of my clone:

1:  Chapter:Main &gt; me
2:  Chapter:Main &gt; MyOrg &gt; me
3:  Chapter:Big Picture &gt; CEO &gt; Some Big Honcho &gt; MyOrg &gt; me
4:  Chapter:Smaller Chunk &gt; Some Big Honcho &gt; MyOrg &gt; me

If I Go-To-Next-Clone  (ALT-N) from (1), focus will move to the selected node
in Chapter:Main, namely (2).

So here's the issue: 

Let each successive line below represent a starting focus, and the next line
the node that ALT-N selects.  If focus changes in the Outline pane (including
Chapter pane change) to match the Node, that case is marked with [f] - a successful
focus transition.

The issue are the lines w/o [f];  Here's a couple of test runs.

1: [f] (starting node / focus)
2: [f]
3:
4:
1: [f]

Next test:

3: [f]
1: [f]
1: [f]
4:
3:
1: [f]

Next test:

4: [f]
3:
1: [f]
2: [f]
4:
3:
1: [f]
2: [f]
... and so on...

In cases with NO [f], the outline pane seems moved to the "end", but no node
selected.

Not a show stopper, but a bug nonetheless.

@color
</t>
<t tx="ekr.20071211113302.358">def goToNextClone (self,event=None):

    '''Select the next node that is a clone of the selected node.'''

    c = self ; cc = c.chapterController ; p = c.currentPosition()
    if not p: return
    if not p.isCloned():
        g.es('not a clone: %s' % (p.headString()),color='blue')
        return

    t = p.v.t
    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.v.t == t:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")

    if cc:
        name = cc.findChapterNameForPosition(p)
        cc.selectChapterByName(name)
        c.frame.tree.expandAllAncestors(p)

    c.selectPosition(p)
</t>
<t tx="ekr.20071211113302.359">def treeSelectHelper (self,p,redraw=True):

    c = self ; current = c.currentPosition()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectPosition(p,updateBeadList=False)
        finally:
            c.endUpdate(redraw)

    c.treeFocusHelper()
</t>
<t tx="ekr.20071211113302.360">def treeFocusHelper (self):

    c = self

    if c.config.getBool('stayInTreeAfterSelect'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20071211113302.361">def selectPosition(self,p,updateBeadList=True):

    """Select a new position."""

    c = self ; cc = c.chapterController

    if cc:
        cc.selectChapterForPosition(p)

    # g.trace(p.headString(),g.callers())

    c.frame.tree.select(p,updateBeadList)

    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
</t>
<t tx="ekr.20071211113302.362">def selectChapterForPosition (self,p):

    '''
    Select a chapter containing position p.
    Do nothing if p if p does not exist or is in the presently selected chapter.
    '''
    cc = self ; c = cc.c ; trace = False

    if not p or not c.positionExists(p):
        return

    theChapter = cc.getSelectedChapter()
    if not theChapter:
        if trace: g.trace('no chapter')
        return

    if trace: g.trace('selected:',theChapter.name)
    # First, try the presently selected chapter.
    firstName = theChapter.name
    if firstName == 'main' or theChapter.positionIsInChapter(p):
        if trace: g.trace('in chapter:',theChapter.name)
        return

    for name in cc.chaptersDict.keys():
        if name not in (firstName,'main'):
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                if trace: g.trace('select:',theChapter.name)
                cc.selectChapterByName(name)
                return
    else:
        if trace: g.trace('select main')
        cc.selectChapterByName('main')
</t>
<t tx="ekr.20071211113302.363">def findChapterNameForPosition (self,p):

    '''
    Return the name of a chapter containing p or None if p does not exist.
    '''
    cc = self ; c = cc.c

    if not p or not c.positionExists(p):
        return None

    for name in cc.chaptersDict.keys():
        if name != 'main':
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                return name
    else:
        return 'main'
</t>
<t tx="ekr.20071211113302.364">tree_select_lockout = False

def select (self,p,updateBeadList=True,scroll=True):

    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        val = 'break'
        self.tree_select_lockout = True
        val = self.treeSelectHelper(p,updateBeadList,scroll)
    finally:
        self.tree_select_lockout = False

    return val  # Don't put a return in a finally clause.
</t>
<t tx="ekr.20071211113302.365">#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def treeSelectHelper (self,p,updateBeadList,scroll):

    c = self.c ; frame = c.frame ; trace = False
    body = w = frame.body.bodyCtrl
    old_p = c.currentPosition()

    if not p:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    # g.trace('      ===',id(w),p and p.headString())
    if self.trace_select and not g.app.unitTesting: g.trace('tree',g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p,updateBeadList) # Remember this position.
    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
</t>
<t tx="ekr.20071211113302.366"># Remember the position of the scrollbar before making any changes.
if not body: g.trace('no body!','c.frame',c.frame,'old_p',old_p)

yview = body.getYScrollPosition()
insertSpot = c.frame.body.getInsertPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if c.edit_widget(old_p):
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
</t>
<t tx="ekr.20071211113302.367"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing newlines.

s = g.toUnicode(p.v.t.bodyString,"utf-8")
old_s = w.getAllText()

if True and p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
    pass
else:
    # This destroys all color tags, so do a full recolor.
    w.setAllText(s)
    self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    w.setYScrollPosition(first)

if p.v and p.v.t.insertSpot != None:
    spot = p.v.t.insertSpot
    w.setInsertPoint(spot)
    w.see(spot)
else:
    w.setInsertPoint(0)

# g.trace("select:",p.headString())
</t>
<t tx="ekr.20071211113302.368"># g.trace('selecting',p,'edit_widget',c.edit_widget(p))
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.headString())

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
</t>
<t tx="ekr.20071211113302.369">def findEditWidget (self,p):

    """Return the Tk.Text item corresponding to p."""

    c = self.c ; trace = False

    # if trace: g.trace(g.callers())
    if p and c:
        if trace: g.trace('h',p.headString(),'key',p.key())
        aTuple = self.visibleText.get(p.key())
        if aTuple:
            w,theId = aTuple
            if trace: g.trace('%4d' % (theId),self.textAddr(w),p.headString())
            return w
        else:
            if trace: g.trace('oops: not found',p,g.callers())
            return None

    if trace: g.trace('not found',p and p.headString())
    return None
</t>
<t tx="ekr.20071211113302.370">def key (self):

    p = self

    return '%s:%d.%s' % (
        id(p.v),
        p.childIndex(),
        ','.join([str(id(v)) for v in p.stack])
    )
</t>
<t tx="ekr.20071211113302.371"></t>
<t tx="ekr.20071211113302.372"></t>
<t tx="ekr.20071211113302.373"></t>
<t tx="ekr.20071211113302.374">@nocolor

https://sourceforge.net/forum/message.php?msg_id=4634600
By: kayvan

I have a puzzle. On my ubuntu 7.10 box, leo works just fine with aspell.

On my Redhat FC4 Linux, I was getting two mesasges on startup:

Can not import aspell
can not import aspell

Yes, one "Can" is capitalized and the next is not, and the "Spell" tab was not
showing up.

I have aspell-0.60 installed on both machines.

I looked around on the forums and I found some instructions that mention installing
aspell-python (from http://www.wmula.republika.pl/proj/aspell-python/index-c.html
) so I installed it on my Redhat box.

When I try to launch leo now, I get:

Traceback (most recent call last):
[...]
  File "/home/kayvan/src/leo/src/leoEditCommands.py", line 8152, in init_aspell
    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)
  File "/home/kayvan/src/leo/src/leoEditCommands.py", line 8446, in __init__
    self.getAspell()
  File "/home/kayvan/src/leo/src/leoEditCommands.py", line 8462, in getAspell
    self.sc = aspell
and aspell.spell_checker(prefix=self.aspell_dir,lang=self.local_language_code)
AttributeError: 'module' object has no attribute 'spell_checker'

So I had to remove aspell-python.

What's interesting is that I don't have aspell-python installed on my Ubuntu
box either.

What's going on? What do I need to do to get aspell working with leo on my Redhat
machine?

------------------------- My reply

Thanks for this report. I'll look into this immediately. At the very least the
error reporting could be a bit less alarming. Probably this code should not be
called at all on Linux.

Leo uses two different ways of importing aspell, depending on what version of
Python is installed. For Python 2.5 (and may other versions), Leo can avoid
trying to find aspell.dll. But this code isn't in getAspellWithCtypes, so you
must have a proper aspell.dll where Leo can find it. But this only work on
Windows.

The notes in leoSettings.leo, in the node '@settings--&gt;Spell tab' say that you
must be using Python 2.5 or later if you are using Linux.

@color</t>
</tnodes>
</leo_file>
