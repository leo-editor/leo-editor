#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20071217134533:Pylint
#@+node:ekr.20071217231348:Pylint docs
@nocolor



















#@+node:ekr.20071217231348.1:options
General options

rcfile:	Specify a configuration file.
init-hook:	Python code to execute, usually for sys.path manipulation such as pygtk.require().
rpython-mode:	enable the rpython checker which is disabled by default
errors-only:	In debug mode, checkers without error messages are disabled and for others, only the ERROR messages are displayed, and no reports are done by default
profile:	Profiled execution.
ignore:	Add <file or directory> to the black list. It should be a base name, not a path. You may set this option multiple times. Default: CVS
persistent:	Pickle collected data for later comparisons. Default: yes
cache-size:	Set the cache size for astng objects. Default: 500
load-plugins:	List of plugins (as comma separated values of python modules names) to load, usually to register additional checkers.

Commands options

help-msg:	Display a help message for the given message id and exit. The value may be a comma separated list of message ids.
list-msgs:	Generate pylint's full documentation.
generate-rcfile:
 	Generate a sample configuration file according to the current configuration. You can put other options before this one to get them in the generated configuration.
generate-man:	Generate pylint's man page.

Messages control options

enable-checker:	Enable only checker(s) with the given id(s). This option conflict with the disable-checker option
disable-checker: Enable all checker(s) except those with the given id(s). This option conflict with the disable-checker option
enable-msg-cat:	Enable all messages in the listed categories.
disable-msg-cat: Disable all messages in the listed categories.
enable-msg:	Enable the message(s) with the given id(s).
disable-msg:	Disable the message(s) with the given id(s).

Reports options

output-format:	set the output format. Available formats are text, parseable, colorized, msvs (visual studio) and html Default: text
include-ids:	Include message's id in output
files-output:	Put messages in a separate file for each module / package specified on the command line instead of printing them on stdout. Reports (if any) will be written in a file name "pylint_global.[txt|html]".
reports:	Tells wether to display a full report or only the messages Default: yes
evaluation:	Python expression which should return a note less than 10 (10 is the highest note).You have access to the variables errors warning, statement which respectivly contain the number of errors / warnings messages and the total number of statements analyzed. This is used by the global evaluation report (R0004). Default: 10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)
comment:	Add a comment according to your evaluation note. This is used by the global evaluation report (R0004).
enable-report:	Enable the report(s) with the given id(s).
disable-report:	Disable the report(s) with the given id(s).
#@nonl
#@-node:ekr.20071217231348.1:options
#@+node:ekr.20071217231348.2:Main messages and reports
Main messages

E0001:	Used when a syntax error is raised for a module.
E0011:	Unrecognized file option %r Used when an unknown inline option is encountered.
E0012:	Bad option value %r Used when a bad value for an inline option is encountered.

I0001:	Unable to run raw checkers on built-in module %s Used to inform that a built-in module has not been checked using the raw checkers.
I0010:	Unable to consider inline option %r Used when an inline option is either badly formatted or can't be used inside modules.
I0011:	Locally disabling %s Used when an inline option disable a message or a messages category.
I0012:	Locally enabling %s Used when an inline option enable a message or a messages category.
I0013:	Ignoring entire file Used to inform that the file will not be checked
F0001:	Used when an error occured preventing the analyzing of a module (unable to find it for instance).
F0002:	%s: %s Used when an unexpected error occured while building the ASTNG representation. This is usually accomopagned by a traceback. Please report such errors !
F0003:	ignored builtin module %s Used to indicate that the user asked to analyze a builtin module which has been skipped.
F0004:	unexpected infered value %s Used to indicate that some value of an unexpected type has been infered.

Main reports

R0001:	Messages by category
R0002:	% errors / warnings by module
R0003:	Messages
R0004:	Global evaluation
#@nonl
#@-node:ekr.20071217231348.2:Main messages and reports
#@+node:ekr.20071217231348.3:Basic
Basic checker

Options

required-attributes:
 	Required attributes for module, separated by a comma
no-docstring-rgx:
 	Regular expression which should only match functions or classes name which do not require a docstring Default: __.*__
module-rgx:	Regular expression which should only match correct module names Default: (([a-z_][a-z0-9_]*)|([A-Z][a-zA-Z0-9]+))$
const-rgx:	Regular expression which should only match correct module level names Default: (([A-Z_][A-Z1-9_]*)|(__.*__))$
class-rgx:	Regular expression which should only match correct class names Default: [A-Z_][a-zA-Z0-9]+$
function-rgx:	Regular expression which should only match correct function names Default: [a-z_][a-z0-9_]{2,30}$
method-rgx:	Regular expression which should only match correct method names Default: [a-z_][a-z0-9_]{2,30}$
attr-rgx:	Regular expression which should only match correct instance attribute names Default: [a-z_][a-z0-9_]{2,30}$
argument-rgx:	Regular expression which should only match correct argument names Default: [a-z_][a-z0-9_]{2,30}$
variable-rgx:	Regular expression which should only match correct variable names Default: [a-z_][a-z0-9_]{2,30}$
inlinevar-rgx:	Regular expression which should only match correct list comprehension / generator expression variable names Default: [A-Za-z_][A-Za-z0-9_]*$
good-names:	Good variable names which should always be accepted, separated by a comma Default: i,j,k,ex,Run,_
bad-names:	Bad variable names which should always be refused, separated by a comma Default: foo,bar,baz,toto,tutu,tata
bad-functions:	List of builtins function names that should not be used, separated by a comma Default: map,filter,apply,input

Messages

E0100:	__init__ method is a generator Used when the special class method __init__ is turned into a generator by a yield in its body.
E0101:	Explicit return in __init__ Used when the special class method __init__ has an explicit return value.
E0102:	%s already defined line %s Used when a function / class / method is redefined.
E0103:	%r not properly in loop Used when break or continue keywords are used outside a loop.
E0104:	return outside function Used when a "return" statement is found outside a function or method.
E0105:	yield outside function Used when a "yield" statement is found outside a function or method.
E0106:	return with argument inside generator Used when a "return" statement with an argument is found outside in a generator function or method (e.g. with some "yield" statements).

W0101:	Unreachable code Used when there is some code behind a "return" or "raise" statement, which will never be accessed.
W0102:	Dangerous default value %s as argument Used when a mutable value as list or dictionary is detected in a default value for an argument.
W0104:	Statement seems to have no effect Used when a statement doesn't have (or at least seems to) any effect.
W0105:	String statement has no effect Used when a string is used as a statement (which of course has no effect). This is a particular case of W0104 with its own message so you can easily disable it if you're using those strings as documentation, instead of comments.
W0106:	Unnecessary semicolon Used when a statement is endend by a semi-colon (";"), which isn't necessary (that's python, not C ;).
W0107:	Unnecessary pass statement Used when a "pass" statement that can be avoided is encountered.)
W0122:	Use of the exec statement Used when you use the "exec" statement, to discourage its usage. That doesn't mean you can not use it !
W0141:	Used builtin function %r Used when a black listed builtin function is used (see the bad-function option). Usual black listed functions are the ones like map, or filter , where Python offers now some cleaner alternative like list comprehension.
W0142:	Used * or * magic* Used when a function or method is called using *args or **kwargs to dispatch arguments. This doesn't improve readility and should be used with care.

C0102:	Black listed name "%s" Used when the name is listed in the black list (unauthorized names).
C0103:	Invalid name "%s" (should match %s) Used when the name doesn't match the regular expression associated to its type (constant, variable, class...).
C0111:	Missing docstring Used when a module, function, class or method has no docstring. Some special methods like __init__ doesn't necessary require a docstring.
C0112:	Empty docstring Used when a module, function, class or method has an empty docstring (it would be too easy ;).
C0121:	Missing required attribute "%s" Used when an attribute required for modules is missing.

Reports

R0101:	Statistics by type
#@-node:ekr.20071217231348.3:Basic
#@+node:ekr.20071217231348.4:Type
Typecheck checker

Options

ignore-mixin-members:
 	Tells wether missing members accessed in mixin class should be ignored. A mixin class is detected if its name ends with "mixin" (case insensitive). Default: yes
zope:	When zope mode is activated, consider the acquired-members option to ignore access to some undefined attributes.
acquired-members:
 	List of members which are usually get through zope's acquisition mecanism and so shouldn't trigger E0201 when accessed (need zope=yes to be considered). Default: REQUEST,acl_users,aq_parent

Messages

E1101:	%s %r has no %r member  A variable is accessed for an unexistant member.
E1102:	%s is not callable      An object being called has been infered to a non callable object
E1103:	%s %r has no %r member (but some types could not be inferred) 
                               A variable is accessed for an unexistant member, but astng was not able to interpret all possible types of this variable.
E1111:	Assigning to function call which doesn't return     An assigment is done on a function call but the infered function doesn't return anything.
W1111:	Assigning to function call which only returns None  An assigment is done on a function call but the infered function returns nothing but None.
#@nonl
#@-node:ekr.20071217231348.4:Type
#@+node:ekr.20071217231348.5:Variables
Variables checker

Options

init-import:	Tells wether we should check for unused import in __init__ files.
dummy-variables-rgx:
 	A regular expression matching names used for dummy variables (i.e. not used). Default: _|dummy
additional-builtins:
 	List of additional names supposed to be defined in builtins. Remember that you should avoid to define new builtins when possible.

Messages

E0601:	Using variable %r before assignment Used when a local variable is accessed before it's assignment.
E0602:	Undefined variable %r Used when an undefined variable is accessed.
E0611:	No name %r in module %r Used when a name cannot be found in a module.

W0601:	Global variable %r undefined at the module level Used when a variable is defined through the "global" statement but the variable is not defined in the module scope.
W0602:	Using global for %r but no assigment is done Used when a variable is defined through the "global" statement but no assigment to this variable is done.
W0603:	Using the global statement Used when you use the "global" statement to update a global variable.
PyLint just try to discourage this usage. That doesn't mean you can not use it !
W0604:	Using the global statement at the module level Used when you use the "global" statement at the module level since it has no effect
W0611:	Unused import %s Used when an imported module or variable is not used.
W0612:	Unused variable %r Used when a variable is defined but not used.
W0613:	Unused argument %r Used when a function or method argument is not used.
W0614:	Unused import %s from wildcard import Used when an imported module or variable is not used from a 'from X import *' style import.

W????: Inline emphasis start-string without end-string.
W0621:	Redefining name %r from outer scope (line %s) Used when a variable's name hide a name defined in the outer scope.
W0622:	Redefining built-in %r Used when a variable or function override a built-in.
W0631:	Using possibly undefined loop variable %r Used when an loop variable (i.e. defined by a for loop or a list comprehension or a generator expression) is used outside the loop.
#@nonl
#@-node:ekr.20071217231348.5:Variables
#@+node:ekr.20071217231501:Classes
Classes checker

Options

ignore-iface-methods:
 	List of interface methods to ignore, separated by a comma. This is used for instance to not check methods defines in Zope's Interface base class. Default: isImplementedBy,deferred,extends,names,namesAndDescriptions,queryDescriptionFor,getBases,getDescriptionFor,getDoc,getName,getTaggedValue,getTaggedValueTags,isEqualOrExtendedBy,setTaggedValue,isImplementedByInstancesOf,adaptWith,is_implemented_by
defining-attr-methods:
 	List of method names used to declare (i.e. assign) instance attributes. Default: __init__,__new__,setUp

Messages

E0202:	An attribute inherited from %s hide this method Used when a class defines a method which is hiden by an instance attribute from an ancestor class.
E0203:	Access to member %r before its definition line %s Used when an instance member is accessed before it's actually assigned.
E0211:	Method has no argument Used when a method which should have the bound instance as first argument has no argument defined.
E0213:	Method should have "self" as first argument Used when a method has an attribute different the "self" as first argument. This is considered as an error since this is a soooo common convention that you should'nt break it!
E0221:	Interface resolved to %s is not a class Used when a class claims to implement an interface which is not a class.
E0222:	Missing method %r from %s interface Used when a method declared in an interface is missing from a class implementing this interface

W0201:	Attribute %r defined outside __init__ Used when an instance attribute is defined outside the __init__ method.
W0211:	Static method with %r as first argument Used when a static method has "self" or "cls" as first argument.
W0212:	Access to a protected member %s of a client class Used when a protected member (i.e. class member with a name beginning with an underscore) is access outside the class or a descendant of the class where it's defined.
W0221:	Arguments number differs from %s method Used when a method has a different number of arguments than in the implemented interface or in an overridden method.
W0222:	Signature differs from %s method Used when a method signature is different than in the implemented interface or in an overridden method.
W0223:	Method %r is abstract in class %r but is not overridden Used when an abstract method (ie raise NotImplementedError) is not overridden in concrete class.
W0231:	__init__ method from base class %r is not called Used when an ancestor class method has an __init__ method which is not called by a derived class.
W0232:	Class has no __init__ method Used when a class has no __init__ method, neither its parent classes.
W0233:	__init__ method from a non direct base class %r is called Used when an __init__ method is called on a class which is not in the direct ancestors for the analysed class.
R0201:	Method could be a function Used when a method doesn't use its bound instance, and so could be written as a function.
C0202:	Class method should have "cls" as first argument Used when a class method has an attribute different than "cls" as first argument, to easily differentiate them from regular instance methods.
C0203:	Metaclass method should have "mcs" as first argument Used when a metaclass method has an attribute different the "mcs" as first argument.
F0202:	Unable to check methods signature (%s / %s) Used when PyLint has been unable to check methods signature compatibility for an unexpected raison. Please report this kind if you don't make sense of it.
F0220:	failed to resolve interfaces implemented by %s (%s) Used when a PyLint as failed to find interfaces implemented by a class
#@-node:ekr.20071217231501:Classes
#@+node:ekr.20071217231501.1:Design
Design checker

Options
max-args:	Maximum number of arguments for function / method Default: 5
max-locals:	Maximum number of locals for function / method body Default: 15
max-returns:	Maximum number of return / yield for function / method body Default: 6
max-branchs:	Maximum number of branch for function / method body Default: 12
max-statements:	Maximum number of statements in function / method body Default: 50
max-parents:	Maximum number of parents for a class (see R0901). Default: 7
max-attributes:	Maximum number of attributes for a class (see R0902). Default: 7
min-public-methods:
 	Minimum number of public methods for a class (see R0903). Default: 2
max-public-methods:
 	Maximum number of public methods for a class (see R0904). Default: 20

Messages

R0901:	Too many ancestors (%s/%s) Used when class has too many parent classes, try to reduce this to get a more simple (and so easier to use) class.
R0902:	Too many instance attributes (%s/%s) Used when class has too many instance attributes, try to reduce this to get a more simple (and so easier to use) class.
R0903:	Too few public methods (%s/%s) Used when class has too few public methods, so be sure it's really worth it.
R0904:	Too many public methods (%s/%s) Used when class has too many public methods, try to reduce this to get a more simple (and so easier to use) class.
R0911:	Too many return statements (%s/%s) Used when a function or method has too many return statement, making it hard to follow.
R0912:	Too many branches (%s/%s) Used when a function or method has too many branches, making it hard to follow.
R0913:	Too many arguments (%s/%s) Used when a function or method takes too many arguments.
R0914:	Too many local variables (%s/%s) Used when a function or method has too many local variables.
R0915:	Too many statements (%s/%s) Used when a function or method has too many statements. You should then split it in smaller functions / methods.
R0921:	Abstract class not referenced Used when an abstract class is not used as ancestor anywhere.
R0922:	Abstract class is only referenced %s times Used when an abstract class is used less than X times as ancestor.
R0923:	Interface not implemented Used when an interface class is not implemented anywhere.
#@nonl
#@-node:ekr.20071217231501.1:Design
#@+node:ekr.20071217231501.2:Imports
Imports checker

Options

deprecated-modules:
 	Deprecated modules which should not be used, separated by a comma Default: regsub,string,TERMIOS,Bastion,rexec
import-graph:	Create a graph of every (i.e. internal and external) dependencies in the given file (report R0402 must not be disabled)
ext-import-graph:
 	Create a graph of external dependencies in the given file (report R0402 must not be disabled)
int-import-graph:
 	Create a graph of internal dependencies in the given file (report R0402 must not be disabled)

Messages

W0401:	Wildcard import %s Used when from module import * is detected.
W0402:	Uses of a deprecated module %r Used a module marked as deprecated is imported.
W0403:	Relative import %r Used when an import relative to the package directory is detected.
W0404:	Reimport %r (imported line %s) Used when a module is reimported multiple times.
W0406:	Module import itself Used when a module is importing itself.
W0410:	__future__ import is not the first non docstring statement Python 2.5 and greater require __future__ import to be the first non docstring statement in the module.
R0401:	Cyclic import (%s) Used when a cyclic import between two or more modules is detected.
F0401:	Unable to import %r (%s) Used when pylint has been unable to import a module.

Reports

R0401:	External dependencies
R0402:	Modules dependencies graph
#@nonl
#@-node:ekr.20071217231501.2:Imports
#@+node:ekr.20071217231501.3:Newstyle
Newstyle checker


Messages

E1001:	Use __slots__ on an old style class Used when an old style class use the __slots__ attribute.
E1002:	Use super on an old style class Used when an old style class use the super builtin.
E1003:	Bad first argument %r given to super class Used when another argument than the current class is given as first argument of the super builtin.
E1010:	Raising a new style class Used when a new style class is raised since it's not possible with python < 2.5.
W1001:	Use of "property" on an old style class Used when PyLint detect the use of the builtin "property" on an old style class while this is relying on new style classes 
features
W1010:	Exception doesn't inherit from standard "Exception" class Used when a custom exception class is raised but doesn't inherit from the builtin "Exception" class.
#@nonl
#@-node:ekr.20071217231501.3:Newstyle
#@+node:ekr.20071217231828:Exceptions
Exceptions checker

Messages

E0701:	Bad except clauses order (%s) Used when except clauses are not in the correct order (from the more specific to the more generic). If you don't fix the order, some exceptions may not be catched by the most specific handler.
E0702:	Raising %s while only classes, instances or string are allowed Used when something which is neither a class, an instance or a string is raised (i.e. a TypeError will be raised).
W0701:	Raising a string exception Used when a string exception is raised.
W0702:	No exception's type specified Used when an except clause doesn't specify exceptions type to catch.
W0703:	Catch "Exception" Used when an except catch Exception instances.
W0704:	Except doesn't do anything Used when an except clause does nothing but "pass" and there is no "else" clause.
W0706:	Identifier %s used to raise an exception is assigned to %s Used when a variable used to raise an exception is initially assigned to a value which can't be used as an exception.
#@nonl
#@-node:ekr.20071217231828:Exceptions
#@+node:ekr.20071217231828.1:Format
Format checker

Options

max-line-length:
 	Maximum number of characters on a single line. Default: 80
max-module-lines:
 	Maximum number of lines in a module Default: 1000
indent-string:	String used as indentation unit. This is usually " " (4 spaces) or "t" (1 tab). Default: ' '

Messages

W0311:	Bad indentation. Found %s %s, expected %s Used when an unexpected number of indentation's tabulations or spaces has been found.
W0312:	Found indentation with %ss instead of %ss Used when there are some mixed tabs and spaces in a module.
W0331:	Use of the <> operator Used when the deprecated "<>" operator is used instead of "!=".
W0332:	Use l as long integer identifier Used when a lower case "l" is used to mark a long integer. You should use a upper case "L" since the letter "l" looks too much like the digit "1"
C0301:	Line too long (%s/%s) Used when a line is longer than a given number of characters.
C0302:	Too many lines in module (%s) Used when a module has too much lines, reducing its readibility.
C0321:	More than one statement on a single line Used when more than on statement are found on the same line.
C0322:	Operator not preceded by a space Used when one of the following operator (!= | <= | == | >= | < | > | = | += | -= | *= | /= | %) is not preceded by a space.
C0323:	Operator not followed by a space Used when one of the following operator (!= | <= | == | >= | < | > | = | += | -= | *= | /= | %) is not followed by a space.
C0324:	Comma not followed by a space Used when a comma (",") is not followed by a space.
F0321:	Format detection error in %r Used when an unexpected error occured in bad format detection. Please report the error if it occurs.
#@nonl
#@-node:ekr.20071217231828.1:Format
#@+node:ekr.20071217231828.2:Miscellaneous
Miscellaneous checker

Options

notes:	List of note tags to take in consideration, separated by a comma. Default: FIXME,XXX,TODO

Messages

E0501:	Non ascii characters found but no encoding specified (PEP 263) Used when some non ascii characters are detected but now encoding is specified, as explicited in the PEP 263.
E0502:	Wrong encoding specified (%s) Used when a known encoding is specified but the file doesn't seem to be actually in this encoding.
E0503:	Unknown encoding specified (%s) Used when an encoding is specified, but it's unknown to Python.
W0511:	Used when a warning note as FIXME or XXX is detected.
#@nonl
#@-node:ekr.20071217231828.2:Miscellaneous
#@+node:ekr.20071217231828.3:Metrics
Metrics checker


Reports

R0701:	Raw metrics
#@-node:ekr.20071217231828.3:Metrics
#@+node:ekr.20071217231828.4:Simularities
Similarities checker

min-similarity-lines:
 	Minimum lines number of a similarity. Default: 4
ignore-comments:
 	Ignore comments when computing similarities. Default: yes
ignore-docstrings:
 	Ignore docstrings when computing similarities. Default: yes

Messages

R0801:	Similar lines in %s files Indicates that a set of similar lines has been detected among multiple file. This usually means that the code should be refactored to avoid this duplication.

Reports

R0801:	Duplication
#@-node:ekr.20071217231828.4:Simularities
#@-node:ekr.20071217231348:Pylint docs
#@+node:ekr.20071220081732:pylint report
@killcolor


*** Erroneous errors in Leo 4.4.8



--- old --

************* Module leoTkinterTree

W0221:2377:leoTkinterTree.setSelectedLabelState: Arguments number differs from overridden method
W0221:2387:leoTkinterTree.setUnselectedLabelState: Arguments number differs from overridden method
#@+node:ekr.20080304084023:leoEditCommands
*** All these error messages are WRONG.

E1101:114:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'name' member
E1101:115:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'undoType' member
E1101:116:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldSel' member
E1101:116:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldText' member

E1101:8091:spellCommandsClass.openSpellTab: Instance of 'spellTabHandler' has no 'bringToFront' member
E1101:8121:spellCommandsClass.changeAll: Instance of 'spellTabHandler' has no 'changeAll' member
E1101:8129:spellCommandsClass.changeThenFind: Instance of 'spellTabHandler' has no 'changeThenFind' member
#@nonl
#@-node:ekr.20080304084023:leoEditCommands
#@+node:ekr.20080304084023.1:leoGlobals
*** All these error messages are WRONG.

E1101:137:computeGlobalConfigDir: Module 'sys' has no 'leo_config_directory' member
W0104:3915: Statement seems to have no effect

E0602:3931:getpreferredencoding: Undefined variable 'LC_CTYPE'
E0602:3932:getpreferredencoding: Undefined variable 'LC_CTYPE'
E1101:3933:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
E0602:3933:getpreferredencoding: Undefined variable 'CODESET'
E0602:3934:getpreferredencoding: Undefined variable 'LC_CTYPE'
E1101:3937:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
E0602:3937:getpreferredencoding: Undefined variable 'CODESET'
E1101:4432:mulderUpdateAlgorithm.copy_time: Module 'os' has no 'mtime' member
#@-node:ekr.20080304084023.1:leoGlobals
#@+node:ekr.20080304091441:leoTkinterFind
*** All these error messages are WRONG.

************* Module leoTkinterFind
E1101: 95:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'title' member
E1101:101:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'intKeys' member
E1101:104:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'newStringKeys' member
E1101:113:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'createTopFrame' member
E1101:115:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'top' member
E1101:116:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'top' member
E1101:123:leoTkinterFind.init: Instance of 'leoTkinterFind' has no 'intKeys' member
E1101:177:leoTkinterFind.destroySelf: Instance of 'leoTkinterFind' has no 'top' member
E1101:185:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'frame' member
E1101:213:leoTkinterFind.createFrame.setFocus: Instance of 'leoTkinterFind' has no 'c' member
E1101:298:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:305:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1103:325:leoTkinterFind.createFrame.findButtonCallback: Instance of 'leoTkinterFind' has no 'findButton' member (but some types c
ould not be inferred)
E1101:341:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'findAllButton' member
E1101:348:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeButton' member
E1101:354:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeThenFindButton' member
E1101:360:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeAllButton' member
E1101:367:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'top' member
E1101:368:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'top' member
E1103:378:leoTkinterFind.createBindings.findButtonCallback2: Instance of 'leoTkinterFind' has no 'findButton' member (but some typ
es could not be inferred)
E1101:382:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:383:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:384:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'selectAllFindText' member
E1101:396:leoTkinterFind.onCloseWindow: Instance of 'leoTkinterFind' has no 'top' member
E1101:401:leoTkinterFind.dismiss: Instance of 'leoTkinterFind' has no 'top' member
E1101:408:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'c' member
E1101:410:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:411:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:412:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:438:tkFindTab.initGui: Instance of 'tkFindTab' has no 'intKeys' member
E1101:441:tkFindTab.initGui: Instance of 'tkFindTab' has no 'newStringKeys' member
E1101:448:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'c' member
E1101:489:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:504:tkFindTab.createFrame.setFocus: Instance of 'tkFindTab' has no 'c' member
E1101:538:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:591:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'resetWrap' member
E1101:599:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'resetWrap' member
E1101:606:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:623:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'findButtonCallback' member
E1101:624:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'findAllButton' member
E1101:626:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeButton' member
E1101:627:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeThenFindButton' member
E1101:628:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeAllButton' member
E1101:647:tkFindTab.createBindings: Instance of 'tkFindTab' has no 'c' member
E1103:650:tkFindTab.createBindings.resetWrapCallback: Instance of 'tkFindTab' has no 'resetWrap' member (but some types could not
be inferred)
E1103:654:tkFindTab.createBindings.findButtonBindingCallback: Instance of 'tkFindTab' has no 'findButton' member (but some types c
ould not be inferred)
E1101:664:tkFindTab.createBindings: Instance of 'tkFindTab' has no 'hideTab' member
E1101:677:tkFindTab.init: Instance of 'tkFindTab' has no 'intKeys' member
E1101:746:tkFindTab.setOption: Instance of 'tkFindTab' has no 'intKeys' member
E1101:758:tkFindTab.toggleOption: Instance of 'tkFindTab' has no 'intKeys' member
"*****done*****"
Press any key to continue . . .
#@nonl
#@-node:ekr.20080304091441:leoTkinterFind
#@+node:ekr.20080304091441.1:leoTkinterGui
*** All these error messages are WRONG.

************* Module leoTkinterGui
E1101:179:tkinterGui.runMainLoop: Instance of 'tkinterGui' has no 'script' member
E1101:183:tkinterGui.runMainLoop: Instance of 'tkinterGui' has no 'script' member
#@-node:ekr.20080304091441.1:leoTkinterGui
#@+node:ekr.20080304092628:leoTkinterFrame
*** All these error messages are WRONG.

leoTkinterFrame.py Harmless: W0221: mismatch between Tk.Text methods and overridden methods.
leoTkinterFrame.py Dangerous: E1101
************* Module leoTkinterFrame
E1101: 53:leoTkinterBody.__init__: Instance of 'leoTkinterBody' has no 'c' member
E1101: 67:leoTkinterBody.createBindings: Instance of 'leoTkinterBody' has no 'frame' member
E1101: 67:leoTkinterBody.createBindings: Instance of 'leoTkinterBody' has no 'c' member
E1101: 88:leoTkinterBody.createControl: Instance of 'leoTkinterBody' has no 'c' member
E1101:102:leoTkinterBody.createControl: Instance of 'leoTkinterBody' has no 'editorWidgets' member
E1101:109:leoTkinterBody.createTextWidget: Instance of 'leoTkinterBody' has no 'c' member
E1101:176:leoTkinterBody.setColorFromConfig: Instance of 'leoTkinterBody' has no 'c' member
E1101:224:leoTkinterBody.setFontFromConfig: Instance of 'leoTkinterBody' has no 'c' member
E1101:241:leoTkinterBody.hasFocus: Instance of 'leoTkinterBody' has no 'frame' member
E1101:245:leoTkinterBody.setFocus: Instance of 'leoTkinterBody' has no 'c' member
E1101:351:leoTkinterBody.setEditorColors: Instance of 'leoTkinterBody' has no 'c' member
E1101:351:leoTkinterBody.setEditorColors: Instance of 'leoTkinterBody' has no 'editorWidgets' member
E1101:379:leoTkinterFrame.__init__: Class 'leoTkinterFrame' has no 'instances' member
E1101:437:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'initialRatios' member
E1101:439:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'createIconBar' member
E1101:442:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'createStatusLine' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'comparePanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'colorPanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'fontPanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'prefsPanel' member
E1101:1347:leoTkinterFrame.setMinibufferBindings: Instance of 'leoTkinterFrame' has no 'OnPaste' member
E1101:1901:leoTkinterFrame.toggleTkSplitDirection: Instance of 'leoTkinterFrame' has no 'initialRatios' member
E1101:2111:leoTkinterLog.createCanvasWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2138:leoTkinterLog.createTextWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2140:leoTkinterLog.createTextWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2303:leoTkinterLog.onActivateLog: Instance of 'leoTkinterLog' has no 'frame' member
E1101:2423:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2424:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2431:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2432:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2433:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2462:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2463:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2464:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2475:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2476:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2477:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2489:leoTkinterLog.cycleTabFocus: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2514:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2515:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2516:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2556:leoTkinterLog.numberOfVisibleTabs: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2573:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2574:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2587:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2589:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2600:leoTkinterLog.setTabBindings: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2600:leoTkinterLog.setTabBindings: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2787:leoTkinterLog.createColorPicker: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2788:leoTkinterLog.createColorPicker: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2845:leoTkinterLog.createFontPicker: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2846:leoTkinterLog.createFontPicker: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:3018:leoTkinterTreeTab.createControl: Instance of 'leoTkinterTreeTab' has no 'c' member
E1101:3065:leoTkinterTreeTab.selectTab: Instance of 'leoTkinterTreeTab' has no 'cc' member
"*****done*****"
Press any key to continue . . .
#@nonl
#@-node:ekr.20080304092628:leoTkinterFrame
#@+node:ekr.20080304093027:leoTkinterKeys
*** All these error messages are WRONG.

************* Module leoTkinterKeys
E1101: 27:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'useTextWidget' member
E1101: 27:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'widget' member
E1101: 29:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'widget' member
#@-node:ekr.20080304093027:leoTkinterKeys
#@+node:ekr.20080304093258:leoTkinterMenu
*** All these error messages are WRONG.

leoTkinterMenu.py
************* Module leoTkinterMenu
E1101: 62:leoTkinterMenu.computeMenuPositions: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:136:leoTkinterMenu.insert: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:172:leoTkinterMenu.clearAccel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:183:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'updateAllMenus' member
E1101:186:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'setMenu' member
E1101:187:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'createMenusFromTables' member
E1101:208:leoTkinterMenu.disableMenu: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:225:leoTkinterMenu.enableMenu: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:255:leoTkinterMenu.setMenuLabel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:258:leoTkinterMenu.setMenuLabel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:297:leoTkinterMenu.getMacHelpMenu: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:301:leoTkinterMenu.getMacHelpMenu: Instance of 'leoTkinterMenu' has no 'createMenuEntries' member
#@-node:ekr.20080304093258:leoTkinterMenu
#@-node:ekr.20071220081732:pylint report
#@-node:ekr.20071217134533:Pylint
#@+node:ekr.20080408060320.4:4.5 a1
#@+node:ekr.20080506135044.2:Unposted posting about removing .parents list
@nocolor

Unless I hear a truly convincing reason why I shouldn't, I plan to removed v.parents entirely from the sax-graph world. My reasons are as follows:

1. v.parents is actually used in exactly one place, namely p.setAllAncestorAtFileNodesDirty.  Because this is a position method, the full position stack is available, so the vnodes of all direct parents are available.  This means, in turn, that v.t.vnodeList is available, so at each level all clones of v are also available.

This is only a special case.  In general, given a position, it is possible to *compute* all information about parents.

2. As a result, all the work following work is essentially wasted: initing v.parents during reads, and updating v.parents during moves, clones, insertions, deletions, promotions, demotions, and the corresponding undo/redo for all these operations.

It's not so much that the work is odious: it's not.  It's just that conceptually it is completely unnecessary.  Because the work exists, it must be checked: unit tests written, code added to the check-outline command, etc.  All for nothing.

3. Conceptually, the big aha in the unified node world, and *also* in the graph world, is that the *combination* of positions and nodes is what defines the graph.  In any context containing a position p, the combination of p and p.v.t.children is the minimum needed to get *all* information about the graph.  That being so, the parents list adds nothing. 

4. Continuing with the idea in 3, good things often happen when one eliminates an entire area of complexity.  Not only does eliminating the parents list give us the "simplest thing that could possibly work", there is the as-yet-unexplored possibility of future improvements.  That is, this is not merely an implementation issue--by generalizing and simplifying the data structure we open the door to using that data structure in previously unimagined contexts.

So to repeat, I am very likely to get rid of v.parents. I must rewrite p.setAllAncestorAtFileNodesDirty first, so there is still time to voice any objections.  They had better be good :-)

Edward
#@nonl
#@-node:ekr.20080506135044.2:Unposted posting about removing .parents list
#@+node:ekr.20080408060320.782:Bug fixes
#@+node:ekr.20080425062953.1:Fixed bug in appendToRecentFiles
#@+node:ekr.20041201080436:appendToRecentFiles (g.app.config)
def appendToRecentFiles (self,files):

    files = [theFile.strip() for theFile in files]

    # g.trace(files)

    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles[:]:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@-node:ekr.20041201080436:appendToRecentFiles (g.app.config)
#@-node:ekr.20080425062953.1:Fixed bug in appendToRecentFiles
#@+node:ekr.20080408060320.2:Fixed bug in install script
@nocolor

On Mon, Apr 7, 2008 at 7:07 PM, SegundoBob <bhossley@ieee.org> wrote:

I installed Leo 4.4..8 final on Ubuntu.  The installation failed
because the installation put files in /usr/lib/leo/leo.  The
duplicated leo is a mistake.
On line 13 of install I changed:
LEO_LIB_DIR="${LEO_PREFIX}/lib/leo"
to
LEO_LIB_DIR="${LEO_PREFIX}/lib"

With the change the installation worked.
#@nonl
#@-node:ekr.20080408060320.2:Fixed bug in install script
#@+node:ekr.20080506135044.12:Fixed bug: no focus after save-as and save-to commands
#@-node:ekr.20080506135044.12:Fixed bug: no focus after save-as and save-to commands
#@+node:ekr.20080501180847.1:Fixed find bug
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/294866696257802e

For some reason if you remove the key mapping for the "replace-string"
entry in myLeoSettings or leoSettings.leo ( replace-string = None)
then the "search-with-present-options" function (ctrl-f) or the
"search-forward" function (if mapped) displays the request for a
search string in the mini-buffer but returns immediately when any key
is pressed and searches with the "Find:" entry in the "Find" tab.

@color
#@nonl
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    # g.trace('state',state)
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20060205170335.1:aproposFindCommands
def aproposFindCommands (self, event=None):

    '''Prints a discussion of of Leo's find commands.'''

    c = self.c

    << define s >>

    # Remove indentation from s: a workaround of a Leo bug.
    s = g.adjustTripleString(s,c.tab_width)

    if not g.app.unitTesting:
        g.es_print('',s)
#@+node:ekr.20060209082023.1:<< define s >>
s = '''
Note: all bindings shown are the default bindings for these commands.  You may change any of these bindings using @shortcuts nodes in leoSettings.leo.

Settings

leoSettings.leo now contains several settings related to the Find tab:

- @bool show_only_find_tab_options = True

When True (recommended), the Find tab does not show the 'Find', 'Change', 'Change, Then Find', 'Find All' and 'Change All' buttons.

- @bool minibufferSearchesShowFindTab = True

When True, Leo shows the Find tab when executing most of the commands discussed below.

Basic find commands

- open-find-tab makes the Find tab visible.  The Find tab does **not** need to be visible to execute any search command discussed below.

- hide-find-tab hides the Find tab, but retains all the present settings.

- search-with-present-options (Control-F) prompts for a search string.  Typing the <Return> key puts the search string in the Find tab and executes a search based on all the settings in the Find tab. This is a recommended default search command.

- show-search-options shows the present search options in the status line.  This command also makes the Find tab visible.

- find-next (F3) is the same as search-with-present-options, except that it uses the search string in the find-tab.  Recommended as the default 'search again' command.

- Similarly, find-previous (F2) repeats the command specified by the Find tab, but in reverse.

- find-again is the same as find-next if a search pattern is not '<find pattern here>'.
  Otherwise, find-again is the same as search-with-present-options.

Setting find options

- Several minibuffer commands toggle the checkboxes and radio buttons in the Find tab, and thus affect the operation of the search-with-present-options command. Some may want to bind these commands to keys. Others, will prefer to toggle options in a mode.

Here are the commands that toggle checkboxes: toggle-find-ignore-case-option, toggle-find-in-body-option, toggle-find-in-headline-option, toggle-find-mark-changes-option, toggle-find-mark-finds-option, toggle-find-regex-option, toggle-find-reverse-option, toggle-find-word-option, and toggle-find-wrap-around-option.

Here are the commands that set radio buttons: set-find-everywhere, set-find-node-only, and set-find-suboutline-only.

- enter-find-options-mode (Ctrl-Shift-F) enters a mode in which you may change all checkboxes and radio buttons in the Find tab with plain keys.  As always, you can use the mode-help (Tab) command to see a list of key bindings in effect for the mode.

Search commands that set options as a side effect

The following commands set an option in the Find tab, then work exactly like the search-with-present-options command.

- search-backward and search-forward set the 'Whole Word' checkbox to False.

- word-search-backward and word-search-forward set the 'Whole Word' checkbox to True.

- re-search-forward and re-search-backward set the 'Regexp' checkbox to True.

Find all commands

- find-all prints all matches in the log pane.

- clone-find-all replaces the previous 'Clone Find' checkbox.  It prints all matches in the log pane, and creates a node at the beginning of the outline containing clones of all nodes containing the 'find' string.  Only one clone is made of each node, regardless of how many clones the node has, or of how many matches are found in each node.

Note: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by the find-all and clone-find-all commands.

Search and replace commands

- replace-string prompts for a search string.  Type <Return> to end the search string.  The command will then prompt for the replacement string.  Typing a second <Return> key will place both strings in the Find tab and executes a **find** command, that is, search-with-present-options.

So the only difference between replace-string and search-with-present-options is that replace-string has the side effect of setting 'change' string in the Find tab.  However, this is an extremely useful side effect, because of the following commands...

- change (Ctrl-=) replaces the selected text with the 'change' text in the Find tab.

- change-then-find (Ctrl--) replaces the selected text with the 'change' text in the Find tab, then executes the find command again.

find-next, change and change-then-find can simulate any kind of query-replace command.  **Important**: Leo presently has separate query-replace and query-replace-regex commands, but they are buggy and 'under-powered'.  Fixing these commands has low priority.

- change-all changes all occurrences of the 'find' text with the 'change' text.  Important: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by this command.

Incremental search commands

Leo's incremental search commands are completely separate from Leo's legacy search commands.  At present, incremental search commands do not cross node boundaries: they work only in the body text of single node.

Eventually, the incremental commands will maintain a list of previous matches.  This allows for

a) support for backspace and
b) an incremental-search-again command.

Furthermore, this list makes it easy to detect the end of a wrapped incremental search.

Here is the list of incremental find commands: isearch-backward, isearch-backward-regexp, isearch-forward and
isearch-forward-regexp.'''
#@-node:ekr.20060209082023.1:<< define s >>
#@-node:ekr.20060205170335.1:aproposFindCommands
#@-node:ekr.20080501180847.1:Fixed find bug
#@+node:ekr.20080406075855.1:Fixed find completion bug
@nocolor

Trying to edit the minibuffer, when I backspace to a character and
press delete the cursor moves to the end of the buffer and deletes the
last character instead.

@nocolor
#@nonl
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.177:k.doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c ; w = self.widget

    if 0:
        g.trace('(keyHandler)',g.callers(4))
        g.trace('completion',completion,
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    # Step 1: actually delete the character.
    ins = w.getInsertPoint()
    s = w.getAllText()
    if ins <= len(k.mb_prefix):
        # g.trace('at start')
        return
    i,j = w.getSelectionRange()
    if i == j:
        ins -= 1
        w.delete(ins)
        w.setSelectionRange(ins,ins,insert=ins)
    else:
        ins = i
        w.delete(i,j)
        w.setSelectionRange(i,i,insert=ins)

    # Step 2: compute completions.
    if not completion: return
    k.mb_tabListPrefix = w.getAllText()
    k.computeCompletionList(defaultCompletionList,backspace=True)
#@-node:ekr.20061031131434.177:k.doBackSpace
#@-node:ekr.20080406075855.1:Fixed find completion bug
#@+node:ekr.20080407090400.1:Fixed how-many, find-word and goto-character commands
@nocolor

find-word
=========
This command is supposed to:

"Put the cursor at the next word (on a line) that starts with a
character"

It does not. You have to type in a whole word to get any result and
even then
it only selects the word it does not move the cursor to it.


goto-charachter
==============
'''Put the cursor at the n'th character of the buffer.'''

Doesn't do anything.

@color
#@nonl
#@+node:ekr.20050920084036.1:<< define class baseEditCommandsClass >>
class baseEditCommandsClass:

    '''The base class for all edit command classes'''

    @others
#@+node:ekr.20050920084036.2: ctor, finishCreate, init (baseEditCommandsClass)
def __init__ (self,c):

    self.c = c
    self.k = self.k = None
    self.registers = {} # To keep pychecker happy.
    self.undoData = None

def finishCreate(self):

    # Class delegators.
    self.k = self.k = self.c.k
    try:
        self.w = self.c.frame.body.bodyCtrl # New in 4.4a4.
    except AttributeError:
        self.w = None

def init (self):

    '''Called from k.keyboardQuit to init all classes.'''

    pass
#@nonl
#@-node:ekr.20050920084036.2: ctor, finishCreate, init (baseEditCommandsClass)
#@+node:ekr.20051214132256:begin/endCommand (baseEditCommands)
#@+node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
def beginCommand (self,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
#@+node:ekr.20051215102349:beingCommandHelper
# New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  w.getSelectionRange()
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
    else:
        self.undoData = None

    return w
#@-node:ekr.20051215102349:beingCommandHelper
#@-node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
#@+node:ekr.20051214133130.1:endCommand
# New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):

    '''Do the common processing at the end of each command.'''

    c = self.c ; b = self.undoData ; k = self.k

    # g.trace('changed',changed)

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)

    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()

    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
#@-node:ekr.20051214133130.1:endCommand
#@-node:ekr.20051214132256:begin/endCommand (baseEditCommands)
#@+node:ekr.20061007105001:editWidget
def editWidget (self,event):

    c = self.c ; w = event and event.widget

    if w and g.app.gui.isTextWidget(w) and w != c.frame.miniBufferWidget:
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    if self.w:
        c.widgetWantsFocusNow(self.w)

    return self.w
#@nonl
#@-node:ekr.20061007105001:editWidget
#@+node:ekr.20050920084036.5:getPublicCommands & getStateCommands
def getPublicCommands (self):

    '''Return a dict describing public commands implemented in the subclass.
    Keys are untranslated command names.  Values are methods of the subclass.'''

    return {}
#@-node:ekr.20050920084036.5:getPublicCommands & getStateCommands
#@+node:ekr.20050920084036.6:getWSString
def getWSString (self,s):

    return ''.join([g.choose(ch=='\t',ch,' ') for ch in s])
#@-node:ekr.20050920084036.6:getWSString
#@+node:ekr.20050920084036.7:oops
def oops (self):

    print("baseEditCommandsClass oops:",
        g.callers(),
        "must be overridden in subclass")
#@-node:ekr.20050920084036.7:oops
#@+node:ekr.20050929161635:Helpers
#@+node:ekr.20050920084036.249:_chckSel
def _chckSel (self,event,warning='no selection'):

    c = self.c ; k = self.k

    w = self.editWidget(event)

    val = w and w.hasSelection()

    if warning and not val:
        k.setLabelGrey(warning)

    return val
#@-node:ekr.20050920084036.249:_chckSel
#@+node:ekr.20050920084036.250:_checkIfRectangle
def _checkIfRectangle (self,event):

    k = self.k ; key = event.keysym.lower()

    val = self.registers.get(key)

    if val and type(val) == type([]):
        k.clearState()
        k.setLabelGrey("Register contains Rectangle, not text")
        return True

    return False
#@-node:ekr.20050920084036.250:_checkIfRectangle
#@+node:ekr.20050920084036.233:getRectanglePoints
def getRectanglePoints (self,w):

    c = self.c
    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    r1,r2 = g.convertPythonIndexToRowCol(s,i)
    r3,r4 = g.convertPythonIndexToRowCol(s,j)

    return r1+1,r2,r3+1,r4
#@-node:ekr.20050920084036.233:getRectanglePoints
#@+node:ekr.20051002090441:keyboardQuit
def keyboardQuit (self,event):

    '''Clear the state and the minibuffer label.'''

    return self.k.keyboardQuit(event)
#@-node:ekr.20051002090441:keyboardQuit
#@-node:ekr.20050929161635:Helpers
#@-node:ekr.20050920084036.1:<< define class baseEditCommandsClass >>
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20061007105001:editWidget
def editWidget (self,event):

    c = self.c ; w = event and event.widget

    if w and g.app.gui.isTextWidget(w) and w != c.frame.miniBufferWidget:
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    if self.w:
        c.widgetWantsFocusNow(self.w)

    return self.w
#@nonl
#@-node:ekr.20061007105001:editWidget
#@+node:ekr.20050920084036.80:howMany
def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@-node:ekr.20050920084036.80:howMany
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20060417194232:find (quick)
#@+node:ekr.20060925151926:backward/findCharacter & helper
def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)

def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)

def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)

def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
#@nonl
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward ; self.extend = extend
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        k.setLabelBlue(s,protect=True)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@-node:ekr.20060925151926:backward/findCharacter & helper
#@+node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
def findWord(self,event):

    '''Put the cursor at the next word that starts with a character.'''

    return self.findWordHelper(event,oneLine=False)

def findWordInLine(self,event):

    '''Put the cursor at the next word (on a line) that starts with a character.'''

    return self.findWordHelper(event,oneLine=True)

#@+node:ekr.20080408060320.1:findWordHelper
def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            g.choose(oneLine,'in line ','')))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg ; w = self.w ; c = k.c
        if ch:
            i = w.getInsertPoint()
            s = w.getAllText()
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            else:
                end = len(s)

            while i < end:
                i = s.find(ch,i+1,end) # Ensure progress and i > 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break

        k.resetLabel()
        k.clearState()
#@-node:ekr.20080408060320.1:findWordHelper
#@-node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
#@-node:ekr.20060417194232:find (quick)
#@+node:ekr.20050929115226:gotoCharacter
def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue("Goto n'th character: ")
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w ; ok = False
        if n.isdigit():
            n = int(n)
            if n >= 0:
                w.setInsertPoint(n)
                w.seeInsertPoint()
                ok = True
        if not ok:
            g.es('goto-char takes non-negative integer argument',color='blue')
        k.resetLabel()
        k.clearState()
#@-node:ekr.20050929115226:gotoCharacter
#@-node:ekr.20080407090400.1:Fixed how-many, find-word and goto-character commands
#@+node:ekr.20080424115643.5:Fixed import PHP bug
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/b068e88a577a0547

I have just started using Leo and though not familiar with Python, I
am finding it to be a great program.
I am however having difficulty understanding the ins & outs, for
example;

I am trying to use Leo to organize all my different php scripts I have
on my hard drive, when I try to import any php file I get errors. (see
example) I was able to import html files just fine but I don't
understand what I need to do to import my php files one by one so that
I can organize them in a useful manner.

ex error;
exception executing command
Traceback (most recent call last):
  File "C:\Program Files (x86)\Leo\src\leoCommands.py", line 275, in
doCommand
    val = command(event)
  File "C:\Program Files (x86)\Leo\src\leoCommands.py", line 1508, in
importAtFile
    c.importCommands.importFilesCommand(names,"@file")
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 1004, in
importFilesCommand
    v = self.createOutline(fileName,current)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 869, in
createOutline
    self.scanPHPText(s,p,atAuto=atAuto)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 1671, in
scanPHPText
    scanner.run(s,parent)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 2929, in
run
    self.scan(s,parent)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 2394, in
scan
    i = self.skipDecls(s,0,len(s),inClass=False)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 2615, in
skipDecls
    i = self.skipString(s,i)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 3461, in
skipString
    return self.skipString()
TypeError: skipString() takes exactly 3 arguments (1 given)

@color
#@nonl
#@+node:ekr.20070711090052.1:class phpScanner
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20070711090052.2: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'

    self.hasClasses = False
    self.hasFunctions = True

    self.functionTags = ['function']

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20070711090052.2: __init__
#@+node:ekr.20070711094850:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php and ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20070711094850:isPurePHP
#@+node:ekr.20070711090052.3:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20070711090807:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return g.skip_string(s,i)
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20070711090807:startsString skipString
#@-node:ekr.20070711090052.3:Overrides
#@-node:ekr.20070711090052.1:class phpScanner
#@-node:ekr.20080424115643.5:Fixed import PHP bug
#@+node:ekr.20080506135044.7:Fixed keyword handling in g.es and g.es_print
#@-node:ekr.20080506135044.7:Fixed keyword handling in g.es and g.es_print
#@+node:ekr.20080405074410.39:Fixed new @auto bug
@nocolor

Leo's running, so I create a new outline with File->New

Then I save as in a location where foo.py exists.

The I create a node '@auto foo.py'

Then I use File->Read/Write->Read @auto (with that node selected)

Leo says it can't read it.

I close the leo file, re-open in from the recent files menu of the
outline that spawned it, and the @auto file is read no problems.

@color
#@nonl
#@+node:ekr.20031218072017.1839:readAtFileNodes (commands)
def readAtFileNodes (self,event=None):

    '''Read all @file nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    c.beginUpdate()
    try:
        undoData = u.beforeChangeTree(p)
        c.fileCommands.readAtFileNodes()
        u.afterChangeTree(p,'Read @file Nodes',undoData)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.1839:readAtFileNodes (commands)
#@+node:ekr.20031218072017.3029:readAtFileNodes (fileCommands)
def readAtFileNodes (self):

    c = self.c ; p = c.currentPosition()

    c.beginUpdate()
    try:
        c.atFileCommands.readAll(p,partialFlag=True)
    finally:
        c.endUpdate()

    # Force an update of the body pane.
    c.setBodyString(p,p.bodyString())
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20031218072017.3029:readAtFileNodes (fileCommands)
#@+node:ekr.20041005105605.26:readAll (atFile)
def readAll(self,root,partialFlag=False,forceGnx=False):

    """Scan vnodes, looking for @file nodes to read."""

    at = self ; c = at.c
    if partialFlag:
        # Capture the current headline only if we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            if forceGnx: # New in Leo 4.4.2 b1: support for sax read.
                at.forceGnxOnPosition(p)
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            # g.trace('@auto',p.headString(),'name',p.atAutoNodeName())
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for v in c.all_unique_vnodes_iter():
        v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")
#@-node:ekr.20041005105605.26:readAll (atFile)
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    # g.trace(fileName)

    if not g.unitTesting:
        g.es("reading:",p.headString())

    # Delete all children.
    c.beginUpdate()
    try:
        while p.hasChildren():
            p.firstChild().doDelete()
    finally:
        c.endUpdate(False)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        #c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = g.os_path_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setBodyString('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".js":
        self.scanJavaScriptText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    elif ext in ('.html','.htm','.xml'):
        self.scanXmlText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    z = g.choose(atAuto,'@auto ','')
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (z,fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # print 'found',e,'in',line1
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@+node:ekr.20041005105605.237:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>
#@+node:ekr.20041005105605.238:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

path = theDict["path"]
path = g.computeRelativePath (path)

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >>
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@-node:ekr.20080405074410.39:Fixed new @auto bug
#@+node:ekr.20080424061644.1:Fixed recent files bug
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/c6c4faf6fdead672

To reproduce:

Run leo.
Go to "File->Save as" and save the empty outline template somewhere,
for example to /tmp/test.leo
It will appear in "File->Recent files"
When trying to open it from there, I get the following traceback:

---
Error: 1
<type 'exceptions.AttributeError'> Exception in Tk callback
 Function: <function recentFilesCallback at 0x8ba8df4> (type: <type
'function'>)
 Args: ()
Traceback (innermost last):
 File "/home/shadow/leo/extensions/Pmw/Pmw_1_3/lib/PmwBase.py", line
1747, in __call__
   return apply(self.func, args)
 File "/home/shadow/leo/src/leoMenu.py", line 1599, in
recentFilesCallback
   c.openRecentFile(name)
 File "/home/shadow/leo/src/leoCommands.py", line 1173, in
openRecentFile
   c = frame.c # Switch to the new commander so the "recentfiles2"
hook doesn't crash.
<type 'exceptions.AttributeError'>: leoTkinterFrame instance has no
attribute 'c'
---

leo seems to crash, I hit Ctrl-C to stop it.
When I run leo again, there is no entry for test.leo in "File->Recent
files"

Leo 4.4.8 final, build  1.244 , April 6, 2008
python 2.5.1, Tk 8.4.16, Pmw 1.3
OS: Linux

This behaviour doesn't hurt me at all, I've found it accidentally.

@color
#@nonl
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        gui=gui)
    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
        p = c.currentPosition()
        # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
        if not g.doHook("menu1",c=c,p=p,v=p):
            frame.menu.createMenuBar(frame)
            c.updateRecentFiles(relativeFileName or fileName)
            g.doHook("menu2",c=frame.c,p=p,v=p)
            g.doHook("after-create-leo-frame",c=c)

    finally:
        c.endUpdate()
        assert frame.c == c and c.frame == frame
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.chapterController:
            c.chapterController.finishCreate()
        k = c.k
        if k: k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2079:Recent Files submenu & allies
#@+node:ekr.20031218072017.2080:clearRecentFiles
def clearRecentFiles (self,event=None):

    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer

    bunch = u.beforeClearRecentFiles()

    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.delete_range(recentFilesMenu,0,len(c.recentFiles))

    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.relativeFileName())

    g.app.config.appendToRecentFiles(c.recentFiles)

    # g.trace(c.recentFiles)

    u.afterClearRecentFiles(bunch)

    # New in Leo 4.4.5: write the file immediately.
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:ekr.20031218072017.2080:clearRecentFiles
#@+node:ekr.20031218072017.2081:openRecentFile
def openRecentFile(self,name=None):

    if not name: return

    c = self ; v = c.currentVnode()
    << Set closeFlag if the only open window is empty >>

    fileName = name
    if not g.doHook("recentfiles1",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag):
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag and frame != c.frame:
            g.app.destroyWindow(c.frame) # 12/12/03
            c = frame.c # Switch to the new commander so the "recentfiles2" hook doesn't crash.
            c.setLog() # Sets the log stream for g.es

    g.doHook("recentfiles2",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
#@+node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2081:openRecentFile
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):

    """Create the RecentFiles menu.  May be called with Null fileName."""

    if g.app.unitTesting: return

    def munge(name):
        return g.os_path_normpath(name or '').lower()
    def munge2(name):
        return g.os_path_abspath(g.os_path_join(g.app.loadDir,name or ''))

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if munge(fileName) == munge(name) or munge2(fileName) == munge2(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace('adding',fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@-node:ekr.20031218072017.2079:Recent Files submenu & allies
#@-node:ekr.20080424061644.1:Fixed recent files bug
#@+node:ekr.20080418154703.1:Fixed Tangle bugs
#@+node:ekr.20031218072017.2062:getPrefs
# Note: Leo 4.3 does not write these settings to local .leo files.
# Instead, corresponding settings are contained in leoConfig.leo files.

def getPrefs (self):

    c = self.c

    if self.getOpenTag("<preferences"):
        return # <preferences/> seen

    table = (
        ("allow_rich_text",None,None), # Ignored.
        ("tab_width","tab_width",self.getLong),
        ("page_width","page_width",self.getLong),
        ("tangle_bat","tangle_batch_flag",self.getBool),
        ("untangle_bat","untangle_batch_flag",self.getBool),
        ("output_doc_chunks","output_doc_flag",self.getBool),
        ("noweb_flag",None,None), # Ignored.
        ("extended_noweb_flag",None,None), # Ignored.
        ("defaultTargetLanguage","target_language",self.getTargetLanguage),
        ("use_header_flag","use_header_flag",self.getBool))

    done = False
    while 1:
        found = False
        for tag,var,f in table:
            if self.matchTag("%s=" % tag):
                if var:
                    self.getDquote() ; val = f() ; self.getDquote()
                    setattr(c,var,val)
                    # g.trace(var,val)
                else:
                    self.getDqString()
                found = True ; break
        if not found:
            if self.matchTag("/>"):
                done = True ; break
            if self.matchTag(">"):
                break
            else: # New in 4.1: ignore all other tags.
                self.getUnknownTag()

    if not done:
        while 1:
            if self.matchTag("<defaultDirectory>"):
                # New in version 0.16.
                c.tangle_directory = self.getEscapedString()
                self.getTag("</defaultDirectory>")
                if not g.os_path_exists(c.tangle_directory):
                    g.es("default tangle directory not found:",c.tangle_directory)
            elif self.matchTag("<TSyntaxMemo_options>"):
                self.getEscapedString() # ignored
                self.getTag("</TSyntaxMemo_options>")
            else: break
        self.getTag("</preferences>")
#@+node:ekr.20031218072017.2063:getTargetLanguage
def getTargetLanguage (self):

    # Must match longer tags before short prefixes.
    for name in g.app.language_delims_dict.keys():
        if self.matchTagWordIgnoringCase(name):
            language = name.replace("/","")
            # self.getDquote()
            return language

    return "c" # default
#@-node:ekr.20031218072017.2063:getTargetLanguage
#@-node:ekr.20031218072017.2062:getPrefs
#@+node:ekr.20031218072017.3579:error, pathError, warning
def error (self,s):
    self.errors += 1
    g.es_error(g.translateString(s))

def pathError (self,s):
    if not self.path_warning_given:
        self.path_warning_given = True
        self.error(s)

def warning (self,s):
    g.es_error(g.translateString(s))
#@-node:ekr.20031218072017.3579:error, pathError, warning
#@-node:ekr.20080418154703.1:Fixed Tangle bugs
#@+node:ekr.20080506135044.8:Greatly increased speed of undo clone-find-all
# findAll now just creates undo info for clone-find-all for one inserted node.
#@nonl
#@+node:ekr.20080506135044.9:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                undoData = u.beforeInsertNode(c.currentPosition())
                << create the found node >>
            clones.append(self.p.v.t)
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        # u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    self.restore(data)
    c.redraw_now()
    g.es("found",count,"matches")

#@+node:ekr.20080506135044.10:<< create the found node >>
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
#@-node:ekr.20080506135044.10:<< create the found node >>
#@+node:ekr.20080506135044.11:<< create a clone of p under the find node >>
q = self.p.clone()
q.moveToLastChildOf(found)
#@-node:ekr.20080506135044.11:<< create a clone of p under the find node >>
#@-node:ekr.20080506135044.9:findAll
#@-node:ekr.20080506135044.8:Greatly increased speed of undo clone-find-all
#@+node:ekr.20080502114149.2:Temporary fix for php import bug
#@+node:ekr.20080502114149.3:file
ok here is short form of the php file for your review; I am trying to
explain that this is the way Leo imported the file into 2 sections,
instead of having the complete begining and end php tags on the same
'section', it separated them.  I hope this helps.

***FIST SECTION BEGINS***

//@+leo-ver=4
//@+node:@file C:\inetpub\wwwroot\0_PHP_Template\incl\0_sitedef.php
//@@language php
//@@tabwidth -4
//@+others
//@+node:0_sitedef declarations
<?php /*Cascade Style Sheet style1.css*/
?>
<link href="../stex.css" rel="stylesheet" type="text/css" />

<?php
/*
Choice of language for website yes/no
*/
$ADD_LANGUAGE_CHOICE = 'yes';
/*
If 'Yes' you need to create images based on content/filename.htm
ex: /imgs/bttns_index.jpg
$NAV_IMAGES ='yes';
*/

?>

<?php /* Contact information */
$domain = "domain.com";

?>

<?php /* Content Script; reads .htm files in Content Directory */

*** FIRST SECTION ENDS => NOTICE THE LAST LINE OF FILE IS A BEGINING <?
PHP TAG THAT SHOULD BE FIRST LINE ON SECOND SECTION ***

*** SECOND SECTION BEGINS ***

//@-node:0_sitedef declarations
//@+node:include
include('language.php');

$mycontentdir = "content"."/".$mylanguage;
if ($main_page == "") $main_page = "index";


$pagename = $main_page;
$ptitle = $company . " " . $main_page . " page " . $tel ." " . $city .
" " . $state . " " . $zip;

$main_page = "" . $main_page . ".htm";

/* if (is_file("$mycontentdir/$main_page")) {
$open = fopen("$mycontentdir/$main_page", "r");
$size = filesize("$mycontentdir/$main_page");
$content = fread($open, $size); */
//}
?>

<?php
/*Echo's Website*/
function hpo(){
echo '<div class="hpo">whatever text goes here</a> </div>';
}
//@-node:include
//@-others
?>
//@-node:@file C:\inetpub\wwwroot\0_PHP_Template\incl\0_sitedef.php
//@-leo

*** SECOND SECTION ENDS ***
#@nonl
#@-node:ekr.20080502114149.3:file
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = g.os_path_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setBodyString('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".js":
        self.scanJavaScriptText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    elif ext in ('.html','.htm','.xml'):
        self.scanXmlText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    z = g.choose(atAuto,'@auto ','')
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (z,fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # print 'found',e,'in',line1
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20070711090122:scanPHPText
def scanPHPText (self,s,parent,atAuto=False):

    scanner = phpScanner(importCommands=self,atAuto=atAuto)
    scanner.run(s,parent)

    # if scanner.isPurePHP(s):
        # scanner.run(s,parent)
    # else:
        # fileName = scanner.fileName
        # if atAuto:
            # print('seems to be mixed HTML and PHP:',fileName)
        # else:
            # g.es_print('seems to be mixed HTML and PHP:',fileName)
        # scanner.createHeadline(
            # parent,body=s,headline=fileName)
#@-node:ekr.20070711090122:scanPHPText
#@+node:ekr.20070711090052.1:class phpScanner
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20070711090052.2: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'

    self.hasClasses = False
    self.hasFunctions = True

    self.functionTags = ['function']

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20070711090052.2: __init__
#@+node:ekr.20070711094850:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php and ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20070711094850:isPurePHP
#@+node:ekr.20070711090052.3:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20070711090807:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return g.skip_string(s,i)
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20070711090807:startsString skipString
#@-node:ekr.20070711090052.3:Overrides
#@-node:ekr.20070711090052.1:class phpScanner
#@-node:ekr.20080502114149.2:Temporary fix for php import bug
#@-node:ekr.20080408060320.782:Bug fixes
#@+node:ekr.20080506135044.13:Recent graph-world bugs
#@+node:ekr.20080506135044.14:Fixed paste outline
#@-node:ekr.20080506135044.14:Fixed paste outline
#@+node:ekr.20080506135044.15:Fixed two recent node bugs
@nocolor

1. clone-find-all truncated the outline.
   The fix was in p.linkAsRoot.

2. The move outline down command skipped nodes.
   The fix was to p.moveAfter.

3. Added defensive code to p.unlink.

@color
#@nonl
#@-node:ekr.20080506135044.15:Fixed two recent node bugs
#@+node:ekr.20080506135044.16:Fixed bug: Deleting the root didn't select another node
#@-node:ekr.20080506135044.16:Fixed bug: Deleting the root didn't select another node
#@+node:ekr.20080506135044.17:The str_leo_pos uA was not being cleared
#@-node:ekr.20080506135044.17:The str_leo_pos uA was not being cleared
#@+node:ekr.20080506135044.18:Fixed bug: Moving a clone to the root lost the clone mark
#@-node:ekr.20080506135044.18:Fixed bug: Moving a clone to the root lost the clone mark
#@+node:ekr.20080506135044.19:Fixed paste-retaining-clones
# getLeoOutlineFromClipboard now recreates the tnodesDict as needed.
#@nonl
#@-node:ekr.20080506135044.19:Fixed paste-retaining-clones
#@+node:ekr.20080506135044.20:Rewrote sort code
#@-node:ekr.20080506135044.20:Rewrote sort code
#@+node:ekr.20080506135044.21:Rewrote promote/demote code
#@-node:ekr.20080506135044.21:Rewrote promote/demote code
#@+node:ekr.20080506135044.22:Fixed undo/redo move
#@-node:ekr.20080506135044.22:Fixed undo/redo move
#@+node:ekr.20080506135044.23:Fixed inconsistencies between parents and children arrays
#@-node:ekr.20080506135044.23:Fixed inconsistencies between parents and children arrays
#@+node:ekr.20080506135044.24:Rewrote scanForClonedSibs
#@-node:ekr.20080506135044.24:Rewrote scanForClonedSibs
#@+node:ekr.20080506135044.25:Fixed bug: ancestors were not being marked dirty properly
#@-node:ekr.20080506135044.25:Fixed bug: ancestors were not being marked dirty properly
#@+node:ekr.20080506135044.26:Bug: Undo move crashes
@nocolor

This was fixed by calling p._adjustPositionBeforeUnlink.

Traceback (most recent call last):
  File "C:\leo.repo\sax-graph\leo\src\leoCommands.py", line 289, in doCommand
    val = command(event)
  File "C:\leo.repo\sax-graph\leo\src\leoUndo.py", line 1736, in undo
    if u.undoHelper: u.undoHelper()
  File "C:\leo.repo\sax-graph\leo\src\leoUndo.py", line 1921, in undoMove
    assert u.newParent_v.t.children[u.newN] == v
IndexError: list index out of range

#@-node:ekr.20080506135044.26:Bug: Undo move crashes
#@+node:ekr.20080506135044.27:Bug: Selection gets lost
# when moving node down into child
# when expanding node with alt-rtArrow

# This was fixed by calling p._adjustPositionBeforeUnlink.
#@nonl
#@-node:ekr.20080506135044.27:Bug: Selection gets lost
#@+node:ekr.20080506135044.28:Fixed bug involving p._unlink
#@+node:ekr.20080506135044.29:Posting
@nocolor

A brief period of testing revealed two, possibly three bugs that must be
fixed before the sax-graph branch will be usable.  One bug in particular is
interesting.  Code similar to the following code appears in several places
in leoNodes.py:

def insertAsNthChild(self,parent):
    p = self
    p._unlink()
    p._linkAsNthChild(parent)

This works in the "linked" world, but it must be modified for the graph
world.  Indeed, unlinking p can change the position at which p is to be
linked.  For example, suppose we have:

A
B
C

And we wish to move B to the first child of C.  After unlinking B, we will
have:

A
C

Notice: C's childIndex has changed from 2 to 1 but it has *not* changed in
the parent arg to p._linkAsNthChild(parent).  To handle this, Leo will need
code such as:

def insertAsNthChild(self,parent):
    p = self
    p._unlink()
    parent = p._adjustPositionAfterUnlink(parent)
    p._linkAsNthChild(parent)

p._adjustPositionAfterUnlink(parent) can adjust the parent position as
needed **provided** that p._unlink() does *not* change position p, but only
changes p.v.t.children, p.v.t.parents and p.v.t.vnodeList.  In particular,
p._adjustPositionAfterUnlink(parent) only needs to compare the stacks of
positions p and parent in order to adjust parent.  This breaks the circular
dependency: the position can be adjusted even after the actual links
(parents, children arrays) have be changed. 
#@nonl
#@-node:ekr.20080506135044.29:Posting
#@-node:ekr.20080506135044.28:Fixed bug involving p._unlink
#@+node:ekr.20080506135044.30:Moved parents ivar into vnodes
#@-node:ekr.20080506135044.30:Moved parents ivar into vnodes
#@+node:ekr.20080506135044.31:Bug: clone-find-all fails check-outline
#@-node:ekr.20080506135044.31:Bug: clone-find-all fails check-outline
#@+node:ekr.20080506135044.32:Linking/unlinking all clones into parents list
#@-node:ekr.20080506135044.32:Linking/unlinking all clones into parents list
#@+node:ekr.20080506135044.33:Fixed bug: check-outline failed after clone and clone-find-all
#@-node:ekr.20080506135044.33:Fixed bug: check-outline failed after clone and clone-find-all
#@+node:ekr.20080506135044.34:Fixed bug: sort did not select a node
#@-node:ekr.20080506135044.34:Fixed bug: sort did not select a node
#@+node:ekr.20080506135044.35:Fixed bug in clone (caused undo to fail)
#@-node:ekr.20080506135044.35:Fixed bug in clone (caused undo to fail)
#@+node:ekr.20080506135044.36:Fixed bug in createChapterByName
#@-node:ekr.20080506135044.36:Fixed bug in createChapterByName
#@-node:ekr.20080506135044.13:Recent graph-world bugs
#@+node:ekr.20080409111805.1:Cleanup
#@+node:ekr.20080409081425.1:Remove useTextWidget option from leoKeys.py
#@-node:ekr.20080409081425.1:Remove useTextWidget option from leoKeys.py
#@+node:ekr.20080409111805.2:Set use_sax = True always
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5

    self.currentVnode = None
    self.rootVnode = None

    # For writing
    self.read_only = False
    self.rootPosition = None
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    # self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20060919110638.13:setPositionsFromVnodes & helper
def setPositionsFromVnodes (self):

    c = self.c ; p = c.rootPosition()

    current = None
    d = hasattr(p.v,'unknownAttributes') and p.v.unknownAttributes
    if d:
        s = d.get('str_leo_pos')
        if s:
            current = self.archivedPositionToPosition(s)

    c.setCurrentPosition(current or c.rootPosition())
#@nonl
#@+node:ekr.20061006104837.1:archivedPositionToPosition
def archivedPositionToPosition (self,s):

    c = self.c
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level < len(aList):
        i = aList[level]
        while i > 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.headString(),c)
                return None
        level += 1
        if level < len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.headString())
    return p
#@nonl
#@-node:ekr.20061006104837.1:archivedPositionToPosition
#@-node:ekr.20060919110638.13:setPositionsFromVnodes & helper
#@-node:ekr.20080409111805.2:Set use_sax = True always
#@+node:ekr.20080506135044.54:Added g.unified_nodes
@nocolor

- Made t arg optional in vnode ctor.

- Removed the t arg from insertAsX.  Affects these plugins:

wrote:     base64Packager.py
wrote:     macros.py
wrote:     table.py
wrote:     templates.py
wrote:     xsltWithNodes.py

Search for tnode.

@color
#@-node:ekr.20080506135044.54:Added g.unified_nodes
#@-node:ekr.20080409111805.1:Cleanup
#@+node:ekr.20080408060320.783:Features
#@+node:ekr.20080407090400.3:Added install nodes re Leo's home directory
@nocolor

Leo puts several files in the home directory: .leoID.txt,
.leoRecentFiles.txt, and myLeoSettings.leo.  There are various fallback directories if there is no home directory.

If you want more details, you can do what I did: do a clone-find-all for homeDir.

As for how the home directory is set, the code to do this is g.computeHomeDir.  We get the home directory with

home = os.getenv('HOME',default=None)

There are some mind-numbing details to be handled if there os.getenv does, in fact, return a directory.

@color
#@nonl
#@+node:ekr.20080407090400.4:Found: homeDir
#@+node:ekr.20070224115832:readRecentFiles & helpers
def readRecentFiles (self,localConfigFile):

    '''Read all .leoRecentFiles.txt files.'''

    # The order of files in this list affects the order of the recent files list.
    seen = [] 
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()
#@nonl
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created',fileName,color='red')
                return
            except Exception:
                g.es_print('can not create',fileName,color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424115658:readRecentFilesFile
def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
        if not g.unitTesting and not self.silent:
            print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)

    return ok
#@nonl
#@-node:ekr.20050424115658:readRecentFilesFile
#@-node:ekr.20070224115832:readRecentFiles & helpers
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created',fileName,color='red')
                return
            except Exception:
                g.es_print('can not create',fileName,color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
recentFileMessageWritten = False

def writeRecentFilesFile (self,c):

    '''Write the appropriate .leoRecentFiles.txt file.'''

    tag = '.leoRecentFiles.txt'

    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    written = False
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                if not self.recentFileMessageWritten:
                    print ('wrote recent file: %s' % fileName)
                    written = True
                self.writeRecentFilesFileHelper(fileName)
                # Bug fix: Leo 4.4.6: write *all* recent files.

    if written:
        self.recentFileMessageWritten = True
    else:
        pass # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)

    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
            # g.trace(fileName,'lines\n%s' % lines)
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass

    except Exception:
        g.es('unexpected exception writing',fileName,color='red')
        g.es_exception()

    if theFile:
        theFile.close()
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@+node:ekr.20041117083857:initSettingsFiles
def initSettingsFiles (self):

    """Set self.globalConfigFile, self.homeFile, self.myGlobalConfigFile,
    self.myHomeConfigFile, and self.machineConfigFile."""

    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    machineConfigFile = g.computeMachineName() + 'LeoSettings.leo'

    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        #non-prefixed names take priority over prefixed names
        ('myHomeConfigFile',    g.app.homeDir,          g.app.homeSettingsPrefix + mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
        ('machineConfigFile',   g.app.homeDir,          g.app.homeSettingsPrefix + machineConfigFile),
        ('machineConfigFile',   g.app.homeDir,          machineConfigFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        #else:
            #if the path does not exist, only set to None if the ivar isn't already set.
            #dan: IMO, it's better to set the defaults to None in configClass.__init__().
            #     This avoids the creation of ivars in odd (non __init__) places.
            #setattr(self,ivar, getattr(self,ivar,None))
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)
#@nonl
#@-node:ekr.20041117083857:initSettingsFiles
#@+node:ekr.20080220082727:@scan_g.es_results
@first # -*- coding: utf-8 -*-

@ To be translated...

#if and #else parts have different braces:
%s dir:
(in
)
*** Two exclusive handlers for
***Updating:
...
:
= requires @root in the headline
@comment disables untangle for
Indentation error in
Leo Log Window...
ParserError in
Referenced from
This is for testing if g.es blocks in a thread
Token error in
TokenError in
\nauto-completer scan complete
\ntest of es_print: 
adding
after
all plugin handlers...
all tests enabled: this may take awhile
already loaded
auto-saving outline
bad
bad @+leo sentinel
bad @+node sentinel
bad abbrev:
bad encoding in derived file:
bad open/close_flash_brackets setting: using defaults
bad tnode index:
blanks converted to tabs in
buffers...
c.target_language:
can not add
can not create
can not create temp file
can not create: read only:
can not execute
can not import
can not import Image module from PIL
can not import ImageTk module
can not import gc module
can not load enabled plugin:
can not load image:
can not open
can not open Aspell
can not open dictionary file:
can not open local dictionary
can not open script file:
can not open:
can not write %s
can't happen: is_sentinel
can't move node out of
changed:
check complete
check-derived-file passed
check-leo-file failed:
check-leo-file passed
checking Python code
clearing undo
collapse_nodes_during_finds
command is not valid in batch mode
command not ready yet
conflicting @header and @noheader directives
correcting hidden node: t=
correcting line endings in:
count:
created
created chapter
created directory:
created in
created:
creating menu from
creating new window
creating:
current directory:
debugger does not exist:
default tangle directory not found:
deleting tnode list for
directory
directory:
disabling save commands
done
dubious brackets in
dummy created
empty
enabled brief gc stats
enabled plugins...
enabled verbose gc stats
end of script
error handling:
error parsing
error pretty-printing
error reading:
error:
errors
errors inhibited read @auto
event
exception binding
exception creating directory:
exception creating temp file
exception creating:
exception deleting backup file:
exception deleting:
exception executing
exception executing command
exception executing script
exception executing:
exception handling
exception in
exception in g.importFromPath
exception in os.chmod
exception loading plugin
exception opening:
exception removing:
exception renaming
exception writing:
extend mode
file not found
file not found:
finished
first mismatched line at line
from
g.app.config: bad encoding:
g.init_zodb: can not import ZODB
g.init_zodb: exception creating ZODB.DB instance
generated line:
get_focus:
gui does not support a stand-alone find dialog
gui does not support the compare window
handlers for
hasFocusWidget:
head_lines:
ignoring
ignoring 3.x sentinel:
ignoring bad @comment directive:
ignoring bad @comment sentinel:
ignoring bad @language directive:
ignoring bad @language sentinel:
ignoring bad unknownAttributes key
ignoring command: already executing a command.
ignoring invalid key binding:
ignoring non-dictionary unknownAttributes for
ignoring non-pickleable attribute
ignoring non-string attribute
ignoring redundant -noref in:
ignoring redundant -nosent in:
ignoring:
ignoring: @comment
imported
in
in file:
indentation error in
info string
inhibits untangle for
ins:
inserting @ignore
instances
invalid @+leo sentinel in
invalid @encoding:
invalid @lineending directive:
invalid Paste As Clone
invalid encoding in .leo file:
is a sentinel line
is also a prefix of
is bound to:
is not
is not in the outline
len
leoID=
line
line:
lines
load dir:
loadOnePlugin: failed to load module
loaded plugin:
looking for a parent to tangle...
lossage...
may be read-only or in use
minibuffer hidden
missing lines
missing vnode:
modes conflict in:
newTnode: unexpected index type:
no @auto nodes in the selected tree
no @file node in the selected tree
no @file nodes in the selected tree
no @test or @suite nodes in selected outline
no Find script node
no ancestor @file node: using script line numbers
no bindings
no child index for
no children and less than 10 characters (excluding directives)
no debugger found.
no dirty @auto nodes in the selected tree
no dirty @file nodes
no docstring for
no file name
no matching #endif:
no more clones
no more misspellings
no previous command
no script selected
no state function for
no such command:
no text selected
no tnode with index:
nodes
nodes checked
not a clone:
not a valid MORE file
not changed.
not found
not found in
not found:
not written:
nothing follows section name
offending line...
offending line:\n
only
or
original line:
over-riding setting:
parent node:
path does not exist:
plugin
probably an outline topology error.
psyco now logging to:
psyco now running
putCount
putDescendentUnknownAttributes can't happen 2
putDescendentUnknownAttributes: unexpected pickling exception
putUaHelper: unexpected pickling exception
read only
read only:
reading:
recreating:
redefining
redo
relative path in @path directive:
relative_path_base_directory:
rename failed: no file created!
reopening:
replacing
requestedFocusWidget:
restoring
resurrected node:
running
save commands disabled
saved:
scanGnx: unexpected index type:
scanning for auto-completer...
seems to be mixed HTML and PHP:
selected text should contain one or more section names
selected text should start with a section name
skipping settings in
surprise in checkPythonNode
swap-words command not ready yet
syntax error in class node: can not continue
syntax error in:
syntax error: deleting
tabs converted to blanks in
tail_lines:
tangle complete
tangling parent
tangling...
the
the clipboard is not valid
the current node is not a clone
the text will be discarded
there may be conflicting settings!
time.strftime not available on this platform
time/count:
time:
to
to dictionary
unchanged:
undo
unexpected exception converting hexlified string to string
unexpected exception in
unexpected exception in app.setLeoID
unexpected exception in c.openWith
unexpected exception in g.create_temp_file
unexpected exception in g.getScript
unexpected exception in g.importFromPath(%s)
unexpected exception parsing
unexpected exception writing
unit tests
unknown attributes for
unknown attributes for tnode
unknown command name:
unknown language: using Python comment delimiters
unknown option:
unmatched
untangle complete
untangling...
using
using -asis option in:
using -thin option in:
using a blank one instead
using empty text.
using os.getenv('USER'):
warning:
warning: conflicting values for
warning: ignoring
warning: possible duplicate definition of:
warning: updating changed text in
with
write the @file node or use the Import Derived File command
writing erroneous:
wrote:
you may want to delete ressurected nodes
@c
# Decls...
color='red'
newline=True
tabName='Log'
False = 'False'
aList = 'aList'
args = 'args'
at_DOT_outputFileName = 'at.outputFileName'
at_DOT_root_DOT_headString_PARENS_ = 'at.root.headString()'
attrDict_DOT_get_LP_key_RP_ = 'attrDict.get(key)'
b2_DOT_pane = 'b2.pane'
backupName = 'backupName'
badline = 'badline'
base = 'base'
bindStroke = 'bindStroke'
bindings = 'bindings'
bunch_DOT_kind = 'bunch.kind'
c_DOT_config_DOT_getBool_LP__SQ_collapse_nodes_during_finds_SQ__RP_ = 'c.config.getBool(\'collapse_nodes_during_finds\')'
c_DOT_disableCommandsMessage = 'c.disableCommandsMessage'
c_DOT_shortFileName_PARENS_ = 'c.shortFileName()'
c_DOT_tangle_directory = 'c.tangle_directory'
c_DOT_target_language = 'c.target_language'
c_DOT_widget_name_LP_c_DOT_get_focus_PARENS__RP_ = 'c.widget_name(c.get_focus())'
c_DOT_widget_name_LP_c_DOT_hasFocusWidget_RP_ = 'c.widget_name(c.hasFocusWidget)'
c_DOT_widget_name_LP_c_DOT_requestedFocusWidget_RP_ = 'c.widget_name(c.requestedFocusWidget)'
c_DOT_widget_name_LP_w_RP_ = 'c.widget_name(w)'
ch = 'ch'
command = 'command'
commandName = 'commandName'
computeProxyObject = 'computeProxyObject'
configDir = 'configDir'
count = 'count'
d_DOT_get_LP_ch_RP_ = 'd.get(ch)'
d2 = 'd2'
d3 = 'd3'
data = 'data'
debugger = 'debugger'
delim1 = 'delim1'
delim2 = 'delim2'
delim3 = 'delim3'
dictionaryFileName = 'dictionaryFileName'
dir2 = 'dir2'
doc = 'doc'
dst = 'dst'
e = 'e'
encoding = 'encoding'
encodingName = 'encodingName'
errors = 'errors'
eventName = 'eventName'
exctype_DOT___name__ = 'exctype.__name__'
fileName = 'fileName'
file_name = 'file_name'
filename = 'filename'
fn = 'fn'
g_DOT_angleBrackets_LP__DQ___DQ__RP_ = 'g.angleBrackets("*")'
g_DOT_app_DOT_globalOpenDir = 'g.app.globalOpenDir'
g_DOT_app_DOT_gui_DOT_getFullVersion_LP_c_RP_ = 'g.app.gui.getFullVersion(c)'
g_DOT_app_DOT_gui_DOT_guiName_PARENS_ = 'g.app.gui.guiName()'
g_DOT_app_DOT_leoID = 'g.app.leoID'
g_DOT_choose_LP_val_COMMA__SQ_on_SQ__COMMA__SQ_off_SQ__RP_ = 'g.choose(val,\'on\',\'off\')'
g_DOT_get_line_LP_s_COMMA_i_RP_ = 'g.get_line(s,i)'
g_DOT_plugin_date_LP_m_RP_ = 'g.plugin_date(m)'
g_DOT_shortFileName_LP_fileName_RP_ = 'g.shortFileName(fileName)'
g_DOT_shortFileName_LP_path_RP_ = 'g.shortFileName(path)'
h = 'h'
head_lines = 'head_lines'
headline = 'headline'
homeDir = 'homeDir'
i = 'i'
index = 'index'
inputFileName = 'inputFileName'
ins = 'ins'
ivar = 'ivar'
k_DOT_prettyPrintKey_LP_stroke_RP_ = 'k.prettyPrintKey(stroke)'
k_DOT_state_DOT_kind = 'k.state.kind'
key = 'key'
keys = 'keys'
kind = 'kind'
len_LP_lines_RP_ = 'len(lines)'
len_LP_s_RP_ = 'len(s)'
letter = 'letter'
line = 'line'
line1 = 'line1'
line2 = 'line2'
loadDir = 'loadDir'
lp = 'lp'
m = 'm'
m_DOT___name__ = 'm.__name__'
m_DOT___version__ = 'm.__version__'
message = 'message'
min_LP_12_COMMA_n2_RP_ = 'min(12,n2)'
min_LP_20_COMMA_n1_RP_ = 'min(20,n1)'
modeName = 'modeName'
moduleName = 'moduleName'
msg = 'msg'
n = 'n'
n1 = 'n1'
n2 = 'n2'
n3 = 'n3'
name = 'name'
newFileName = 'newFileName'
p_DOT_headString_PARENS_ = 'p.headString()'
p_DOT_parent_PARENS__DOT_headString_PARENS_ = 'p.parent().headString()'
pane = 'pane'
part_DOT_name = 'part.name'
path = 'path'
prefix = 'prefix'
ratio = 'ratio'
relative_path = 'relative_path'
repr_LP_at_DOT_t_RP_ = 'repr(at.t)'
repr_LP_ch_RP_ = 'repr(ch)'
repr_LP_data_RP_ = 'repr(data)'
repr_LP_g_DOT_app_DOT_leoID_RP_ = 'repr(g.app.leoID)'
repr_LP_line_RP_ = 'repr(line)'
repr_LP_theId_RP_ = 'repr(theId)'
repr_LP_val_RP_ = 'repr(val)'
requestedType = 'requestedType'
root_DOT_headString_PARENS_ = 'root.headString()'
rp = 'rp'
s = 's'
s_DOT_strip_PARENS_ = 's.strip()'
s1 = 's1'
s2 = 's2'
s3 = 's3'
section_DOT_name = 'section.name'
self_DOT_currentWord = 'self.currentWord'
self_DOT_fileName = 'self.fileName'
self_DOT_outputFileName = 'self.outputFileName'
self_DOT_print_mode = 'self.print_mode'
self_DOT_putCount = 'self.putCount'
self_DOT_shortFileName = 'self.shortFileName'
self_DOT_tabName = 'self.tabName'
self_DOT_targetFileName = 'self.targetFileName'
sep = 'sep'
setting = 'setting'
shortcut = 'shortcut'
signon = 'signon'
spaces = 'spaces'
sparseMove = 'sparseMove'
src = 'src'
start = 'start'
start_line = 'start_line'
str_LP_i_1_RP_ = 'str(i+1)'
str_LP_index_RP_ = 'str(index)'
str_LP_message_RP_ = 'str(message)'
str_LP_msg_RP_ = 'str(msg)'
str_LP_n_RP_ = 'str(n)'
str_LP_time_RP_ = 'str(time)'
stroke = 'stroke'
tag = 'tag'
tail_lines = 'tail_lines'
target = 'target'
theDir = 'theDir'
theFile = 'theFile'
time_DOT_clock_PARENS_ = 'time.clock()'
title = 'title'
torv = 'torv'
type_LP_index_RP_ = 'type(index)'
type_LP_s_RP_ = 'type(s)'
url = 'url'
v_DOT_headString_PARENS_ = 'v.headString()'
val = 'val'
value = 'value'
version = 'version'
vnodeName = 'vnodeName'
word = 'word'
z = 'z'
z_line = 'z_line'
z_opt = 'z_opt'
zipMark = 'zipMark'
g.app.translateToUpperCase=True
# ---- @thin leo.py 
g.es_print('','-------------------- @thin leo.py ',color='red')
# -- node run
g.es("disabling save commands",color="red")
# -- node createFrame (leo.py)
g.es("file not found:",fileName)
# -- node getBatchScript
g.es_print("can not open script file:",name, color="red")
# -- node reportDirectories
g.es("%s dir:" % (kind),theDir,color="blue")
# -- node startPsyco
g.es("psyco now logging to:",theFile,color="blue")
g.es("psyco now running",color="blue")
# ---- @thin leoApp.py
g.es_print('','-------------------- @thin leoApp.py',color='red')
# -- node < < return if we can set leoID from sys.leoID> >
# g.es_print("leoID=",g.app.leoID,spaces=False,color='red')
g.es_print("leoID=",g_DOT_app_DOT_leoID,spaces=False,color='red')
# -- node < < return if we can set leoID from "leoID.txt" > >
# g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('leoID=',g_DOT_app_DOT_leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
g.es_print('unexpected exception in app.setLeoID',color='red')
# -- node < < return if we can set leoID from os.getenv('USER') > >
# g.es("using os.getenv('USER'):",repr(theId),color='red')
g.es("using os.getenv('USER'):",repr_LP_theId_RP_,color='red')
# -- node < < put up a dialog requiring a valid id > >
# g.es('leoID=',repr(g.app.leoID),spaces=False,color="blue")
g.es('leoID=',repr_LP_g_DOT_app_DOT_leoID_RP_,spaces=False,color="blue")
# -- node < < attempt to create leoID.txt > >
g.es_print('',tag,'created in',theDir,color='red')
g.es('can not create',tag,'in',theDir,color='red')
# -- node app.writeWaitingLog
g.es('',s,color=color,newline=0)
# ---- @thin leoAtFile.py
g.es_print('','-------------------- @thin leoAtFile.py',color='red')
# -- node checkDerivedFile (atFile)
g.es_print('check-derived-file passed',color='blue')
# -- node < < warn on read-only file > >
g.es("read only:",fn,color="red")
# -- node read
# g.es("reading:",root.headString())
g.es("reading:",root_DOT_headString_PARENS_)
# -- node < < advise user to delete all unvisited nodes > >
# g.es('resurrected node:',p.headString(),color='blue')
g.es('resurrected node:',p_DOT_headString_PARENS_,color='blue')
g.es('in file:',fileName,color='blue')
g.es('you may want to delete ressurected nodes')
# -- node readAll (atFile)
g.es("no @file nodes in the selected tree")
# -- node readOneAtAutoNode (atFile)
# g.es("reading:",p.headString())
g.es("reading:",p_DOT_headString_PARENS_)
g.es_print('errors inhibited read @auto',fileName,color='red')
# -- node createNthChild3
g.es("dummy created")
# -- node handleLinesFollowingSentinel
g.es("using",s)
# g.es('',len(lines), "lines",m)
g.es('',len_LP_lines_RP_, "lines",m)
# -- node findChild4
g.es("write the @file node or use the Import Derived File command")
# -- node < < indicate that the node has been changed > >
# g.es("warning: updating changed text in",at.root.headString(),color="blue")
g.es("warning: updating changed text in",at_DOT_root_DOT_headString_PARENS_,color="blue")
# -- node < < bump at.correctedLines and tell about the correction > >
# g.es("correcting hidden node: t=",repr(at.t),color="red")
g.es("correcting hidden node: t=",repr_LP_at_DOT_t_RP_,color="red")
# -- node ignoreOldSentinel
g.es("ignoring 3.x sentinel:",s.strip(),color="blue")
# -- node < < handle @language > >
g.es("ignoring bad @language sentinel:",line,color="red")
# -- node < < handle @comment > >
g.es("ignoring bad @comment sentinel:",line,color="red")
# -- node copyAllTempBodyStringsToTnodes
# g.es("changed:",p.headString(),color="blue")
g.es("changed:",p_DOT_headString_PARENS_,color="blue")
# -- node < < read optional encoding param > >
g.es_print("bad encoding in derived file:",encoding)
# -- node < < set dirty and orphan bits on error > >
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# -- node < < say the command is finished > >
g.es("finished")
g.es("no @file nodes in the selected tree")
g.es("no dirty @file nodes")
# -- node writeAtAutoNodesHelper
g.es("finished")
g.es("no dirty @auto nodes in the selected tree")
g.es("no @auto nodes in the selected tree")
# -- node writeOneAtAutoNode & helpers
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# -- node shouldWriteAtAutoNode
# g.es_print(p.headString(),'not written:',color='red')
g.es_print(p_DOT_headString_PARENS_,'not written:',color='red')
g.es_print('no children and less than 10 characters (excluding directives)',color='red')
# -- node writeMissing
g.es("finished")
g.es("no @file node in the selected tree")
# -- node hasSectionName
g.es('dubious brackets in',line)
# -- node < < handle @language > >
g.es("ignoring bad @language directive:",line,color="blue")
# -- node < < handle @comment > >
g.es("ignoring bad @comment directive:",line,color="blue")
# -- node replaceTargetFileIfDifferent
# g.es('unchanged:',self.shortFileName)
g.es('unchanged:',self_DOT_shortFileName)
# g.es('wrote:    ',self.shortFileName)
g.es('wrote:    ',self_DOT_shortFileName)
# g.es('created:  ',self.targetFileName)
g.es('created:  ',self_DOT_targetFileName)
# -- node < < report if the files differ only in line endings > >
# g.es("correcting line endings in:",self.targetFileName,color="blue")
g.es("correcting line endings in:",self_DOT_targetFileName,color="blue")
# -- node warnAboutOrpanAndIgnoredNodes
# g.es("parent node:",p.parent().headString(),color="blue")
g.es("parent node:",p_DOT_parent_PARENS__DOT_headString_PARENS_,color="blue")
# -- node writeException
# g.es("exception writing:",self.targetFileName,color="red")
g.es("exception writing:",self_DOT_targetFileName,color="red")
# g.es("exception deleting:",self.outputFileName,color="red")
g.es("exception deleting:",self_DOT_outputFileName,color="red")
# -- node < < Test for @header and @noheader > >
g.es("conflicting @header and @noheader directives")
# -- node < < Set comment strings from delims > >
g.es("unknown language: using Python comment delimiters")
# g.es("c.target_language:",c.target_language)
g.es("c_DOT_target_language:",c_DOT_target_language)
g.es('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
# ---- @thin leoBridge.py
g.es_print('','-------------------- @thin leoBridge.py',color='red')
# -- node < < try to get leoID from sys.leoID> >
# g.es("leoID=",g.app.leoID,spaces=False,color='red')
g.es("leoID=",g_DOT_app_DOT_leoID,spaces=False,color='red')
# -- node < < try to get leoID from "leoID.txt" > >
# g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('leoID=',g_DOT_app_DOT_leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
g.es('unexpected exception in app.setLeoID',color='red')
# -- node < < try to get leoID from os.getenv('USER') > >
# g.es_print("using os.getenv('USER'):",repr(theId),color='red')
g.es_print("using os.getenv('USER'):",repr_LP_theId_RP_,color='red')
# -- node reportDirectories
g.es('',kind,'directory','',':',theDir,color='blue')
# -- node createFrame (leoBridge)
g.es('file not found', fileName,'creating new window')
# ---- @thin leoChapters.py
g.es_print('','-------------------- @thin leoChapters.py',color='red')
# -- node cc.createChapterByName
g.es('created chapter',name,color='blue')
# -- node cc.error
g.es_print(s,color='red')
# ---- @thin leoColor.py
g.es_print('','-------------------- @thin leoColor.py',color='red')
# ---- @thin leoCommands.py
g.es_print('','-------------------- @thin leoCommands.py',color='red')
# -- node doCommand
# g.es(c.disableCommandsMessage,color='blue')
g.es(c_DOT_disableCommandsMessage,color='blue')
g.es('ignoring command: already executing a command.',color='red')
g.es("exception executing command")
# -- node c.signOnWithVersion
g.es("Leo Log Window...",color=color)
g.es(signon)
# g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g_DOT_app_DOT_gui_DOT_getFullVersion_LP_c_RP_,version))
# -- node openWith and allies
g.es("unexpected exception in c.openWith")
# -- node < < create or recreate temp file as needed > >
# g.es("reopening:",g.shortFileName(path),color="blue")
g.es("reopening:",g_DOT_shortFileName_LP_path_RP_,color="blue")
# -- node < < execute a command to open path in external editor > >
g.es("exception executing:",command)
# -- node createOpenWithTempFile
# g.es("recreating:  ",g.shortFileName(path),color="red")
g.es("recreating:  ",g_DOT_shortFileName_LP_path_RP_,color="red")
# g.es("creating:  ",g.shortFileName(path),color="blue")
g.es("creating:  ",g_DOT_shortFileName_LP_path_RP_,color="blue")
# g.es("time: " + str(time))
g.es("time: " + str_LP_time_RP_)
g.es("exception creating temp file",color="red")
# -- node save (commands)
g.es("save commands disabled",color="purple")
# -- node saveAs
g.es("save commands disabled",color="purple")
# -- node saveTo
g.es("save commands disabled",color="purple")
# -- node readOutlineOnly
g.es("can not open:",fileName)
# -- node readFileIntoFile
g.es("can not open:",fileName)
# -- node writeFileFromNode
g.es_print('wrote:',fileName,color='blue')
g.es('can not write %s',fileName,color='red')
# -- node c.executeScript & helpers
g.es("end of script",color="purple",tabName=tabName)
g.es("no script selected",color="blue",tabName=tabName)
# -- node goToLineNumber & allies
# g.es("error handling:",root.headString())
g.es("error handling:",root_DOT_headString_PARENS_)
# -- node < < set root > >
g.es("no ancestor @file node: using script line numbers", color="blue")
# -- node < < read the file into lines > >
g.es("not found:",fileName)
# -- node < < 4.2: get node from gnx > >
g.es("not found:",vnodeName,color="red")
# -- node < < 4.x: scan for the node using tnodeList and n > >
# g.es_print("no child index for",root.headString(),color="red")
g.es_print("no child index for",root_DOT_headString_PARENS_,color="red")
# -- node < < set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false > >
g.es_print(s, color="red")
g.es_print(s, color="red")
g.es_print(s, color = "red")
# -- node < < set p to the first node whose headline matches vnodeName > >
g.es_print(s, color="red")
# -- node < < 3.x: scan for the node with the given childIndex > >
g.es("not found:",vnodeName, color="red")
# -- node < < put the cursor on line n2 of the body text > >
# g.es('only',len(lines),'lines',color="blue")
g.es('only',len_LP_lines_RP_,'lines',color="blue")
# -- node convertLineToVnodeNameIndexLine
g.es("bad @+leo sentinel")
# -- node < < handle delim while scanning backward > >
# g.es("line",str(n),"is a sentinel line")
g.es("line",str_LP_n_RP_,"is a sentinel line")
# -- node < < set vnodeName and (childIndex or gnx) from s > >
g.es("bad @+node sentinel")
# -- node convertAllBlanks
g.es("blanks converted to tabs in",count,"nodes")
# -- node convertAllTabs
g.es("tabs converted to blanks in",count,"nodes")
# -- node extract (test)
g.es("nothing follows section name",color="blue")
# -- node extractSection
g.es("nothing follows section name",color="blue")
# -- node < < Set headline for extractSection > >
g.es("selected text should start with a section name",color="blue")
# -- node extractSectionNames
g.es("selected text should contain one or more section names",color="blue")
# -- node < < trace head_lines, ins, tail_lines > >
g.es_print("head_lines: ",head_lines)
g.es_print("ins: ",ins)
g.es_print("tail_lines: ",tail_lines)
# -- node c.findMatchingBracket, helper and test
# g.es("unmatched",repr(ch))
g.es("unmatched",repr_LP_ch_RP_)
# -- node getTime
g.es("time.strftime not available on this platform",color="blue")
# -- node addComments (test)
g.es('no text selected',color='blue')
# -- node deleteComments (test)
g.es('no text selected',color='blue')
g.es('',"'%s'" % (d2),"not found",color='blue')
g.es('',"'%s'" % (d3),"not found",color='blue')
# -- node showFindPanel
# g.es('the',g.app.gui.guiName(),
#             'gui does not support a stand-alone find dialog',color='blue')
g.es('the',g_DOT_app_DOT_gui_DOT_guiName_PARENS_,
            'gui does not support a stand-alone find dialog',color='blue')
# -- node notValidInBatchMode
g.es('the',commandName,"command is not valid in batch mode")
# -- node c.checkOutline
g.es("all tests enabled: this may take awhile",color="blue")
# -- node < < remove unused tnodeList > >
g.es_print(s,color="blue")
# -- node < < do full tests > >
g.es('','.',newline=False)
# -- node < < give test failed message > >
g.es_print(s,color="red")
# -- node < <print summary message > >
g.es_print('',count,'nodes checked',errors,'errors',color=color)
# -- node checkAllPythonCode
g.es("check complete",color="blue")
# -- node < < print dots > >
g.es('','.',newline=False)
# -- node checkPythonCode
g.es("checking Python code   ")
g.es("surprise in checkPythonNode")
g.es("check complete",color="blue")
# -- node < < print dots > >
g.es('','.',newline=False)
# -- node checkPythonNode
g.es_print(s,color="blue")
# -- node tabNannyNode
g.es("ParserError in",headline,color="blue")
# g.es('',str(msg))
g.es('',str_LP_msg_RP_)
g.es("TokenError in",headline,color="blue")
# g.es('',str(msg))
g.es('',str_LP_msg_RP_)
g.es("indentation error in",headline,"line",badline,color="blue")
g.es(message)
g.es("offending line:\n",line2)
# -- node prettyPrintNode
g.es("error pretty-printing",h,"not changed.",color="blue")
# -- node markChangedHeadlines
g.es("done",color="blue")
# -- node markChangedRoots
g.es("done",color="blue")
# -- node markClones
g.es('the current node is not a clone',color='blue')
# -- node cantMoveMessage
g.es("can't move node out of",kind,color="blue")
# -- node c.toggleSparseMove
g.es(tag,'=',sparseMove,color='blue')
# -- node goToNextClone
# g.es('not a clone:',p.headString(),color='blue')
g.es('not a clone:',p_DOT_headString_PARENS_,color='blue')
g.es("done",color="blue")
# -- node findNextClone
g.es('no more clones',color='blue')
# -- node goToNextDirtyHeadline
g.es("done",color="blue")
# -- node goToNextMarkedHeadline
g.es("done",color="blue")
# -- node openCompareWindow
# g.es('the',g.app.gui.guiName(),
#             'gui does not support the compare window',color='blue')
g.es('the',g_DOT_app_DOT_gui_DOT_guiName_PARENS_,
            'gui does not support the compare window',color='blue')
# -- node openLeoSettings and openMyLeoSettings
g.es('',name,"not found in",configDir)
g.es('',name,"not found in",configDir,"or",homeDir)
# -- node openLeoScripts
g.es('not found:',fileName)
# -- node leoDocumentation
g.es("not found:",name)
# -- node leoHome
g.es("not found:",url)
# -- node leoPlugins
g.es("not found:",name)
# -- node leoTutorial (version number)
g.es("not found:",url)
# -- node leoUsersGuide
g.es("not found:",url)
# -- node initEncoding
g.es("bad", "%s: %s" % (encodingName,encoding))
# ---- @thin leoConfig.py
g.es_print('','-------------------- @thin leoConfig.py',color='red')
# -- node error
g.es(s,color="blue")
# -- node doIfGui
g.es_print(s,color='blue')
# -- node doMenus & helper
# g.es_print('creating menu from',c.shortFileName(),color='blue')
g.es_print('creating menu from',c_DOT_shortFileName_PARENS_,color='blue')
# -- node set (parseBaseClass)
g.es("over-riding setting:",name,"from",path)
# -- node traverse (parserBaseClass)
# g.es_print('skipping settings in',p.headString(),color='blue')
g.es_print('skipping settings in',p_DOT_headString_PARENS_,color='blue')
# -- node initEncoding
g.es("g.app.config: bad encoding:","%s: %s" % (ivar,encoding))
# -- node getValFromDict
# g.es_print('warning: ignoring',bunch.kind,'',setting,'is not',requestedType,color='red')
g.es_print('warning: ignoring',bunch_DOT_kind,'',setting,'is not',requestedType,color='red')
g.es_print('there may be conflicting settings!',color='red')
# -- node createRecentFiles
g.es_print('created',fileName,color='red')
g.es_print('can not create',fileName,color='red')
# -- node writeRecentFilesFileHelper
g.es('unexpected exception writing',fileName,color='red')
# -- node g.app.config.printSettings & helper
g.es('','%s %s = %s' % (letter,key,val))
# ---- @thin leoEditCommands.py
g.es_print('','-------------------- @thin leoEditCommands.py',color='red')
# -- node dynamicCompletion
g.es('command not ready yet',color='blue')
# -- node dynamicExpansion
g.es('command not ready yet',color='blue')
# -- node listAbbrevs
g.es('','%s=%s' % (z,s))
# -- node readAbbreviations
g.es('can not open',fileName)
# -- node writeAbbreviations
g.es('can not create',fileName)
# -- node listBuffers & listBuffersAlphabetically
g.es('buffers...')
g.es('',name)
g.es('buffers...')
g.es('',name)
# -- node debug & helper
g.es("info string")
# -- node findDebugger
g.es('debugger does not exist:',debugger,color='blue')
g.es('no debugger found.')
# -- node enable/disableGcTrace
g.es('enabled verbose gc stats',color='blue')
g.es('enabled brief gc stats',color='blue')
# -- node printFocus
# g.es_print('      hasFocusWidget:',c.widget_name(c.hasFocusWidget))
g.es_print('      hasFocusWidget:',c_DOT_widget_name_LP_c_DOT_hasFocusWidget_RP_)
# g.es_print('requestedFocusWidget:',c.widget_name(c.requestedFocusWidget))
g.es_print('requestedFocusWidget:',c_DOT_widget_name_LP_c_DOT_requestedFocusWidget_RP_)
# g.es_print('           get_focus:',c.widget_name(c.get_focus()))
g.es_print('           get_focus:',c_DOT_widget_name_LP_c_DOT_get_focus_PARENS__RP_)
# -- node appendImageDictToList
g.es('can not load image:',path)
# -- node getImage
g.es('can not import Image module from PIL',color='blue')
g.es('can not import ImageTk module',color='blue')
# -- node initBracketMatcher
g.es_print('bad open/close_flash_brackets setting: using defaults')
# -- node viewLossage
g.es('lossage...')
# g.es('',stroke or d.get(ch) or ch or 'None')
g.es('',stroke or d_DOT_get_LP_ch_RP_ or ch or 'None')
# -- node clear/set/ToggleExtendMode
# g.es('extend mode',g.choose(val,'on','off'),color='red')
g.es('extend mode',g_DOT_choose_LP_val_COMMA__SQ_on_SQ__COMMA__SQ_off_SQ__RP_,color='red')
# -- node swapWords
g.es('swap-words command not ready yet',color='blue')
# -- node getReadableTextFile
g.es('can not open',fileName)
# -- node saveFile
g.es('can not create',fileName)
# -- node helpForMinibuffer
g.es_print('',s)
# -- node helpForCommand
g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')
# -- node aproposAutocompletion
g.es_print('',s)
# -- node aproposBindings
g.es_print('',s)
# -- node aproposDebuggingCommands
g.es_print('',s)
# -- node aproposFindCommands
g.es_print('',s)
# -- node loadFile & helpers
g.es('can not open',fileName)
# -- node saveMacros & helper
g.es('can not create',fileName)
# -- node findNextMatch (query-replace)
g.es('command not ready yet',color='blue')
# -- node Find options wrappers
# g.es('collapse_nodes_during_finds',c.config.getBool('collapse_nodes_during_finds'))
g.es('collapse_nodes_during_finds',c_DOT_config_DOT_getBool_LP__SQ_collapse_nodes_during_finds_SQ__RP_)
# -- node scolorizer LATER
g.es('command not ready yet',color='blue')
# -- node init_aspell
g.es_print('can not open dictionary file:',dictionaryFileName, color='red')
g.es_print('can not open Aspell',color='red')
# -- node readDictionary
g.es("can not open local dictionary",fileName,"using a blank one instead")
# -- node add
g.es("adding ", color= "blue", newline= False)
# g.es('','%s' % self.currentWord)
g.es('','%s' % self_DOT_currentWord)
# g.es("can not add",self.currentWord,"to dictionary",color="red")
g.es("can not add",self_DOT_currentWord,"to dictionary",color="red")
# -- node find & helpers
g.es("no more misspellings")
# -- node hide
g.es(message,color='blue')
# -- node ignore
g.es("ignoring ",color= "blue", newline= False)
# g.es('','%s' % self.currentWord)
g.es('','%s' % self_DOT_currentWord)
# -- node report
g.es_print(message,color='blue')
# ---- @thin leoFileCommands.py
g.es_print('','-------------------- @thin leoFileCommands.py',color='red')
# -- node processingInstruction (stylesheet)
g.es('','%s: %s' % (target,data),color='blue')
# -- node startVnodes
# g.es("reading:",self.fileName)
g.es("reading:",self_DOT_fileName)
# -- node checkLeoFile (fileCommands)
g.es_print('check-leo-file passed',color='blue')
# g.es_print('check-leo-file failed:',str(message),color='red')
g.es_print('check-leo-file failed:',str_LP_message_RP_,color='red')
# -- node getLeoOutlineFromClipboard & helpers
g.es("invalid Paste As Clone",color="blue")
g.es("the clipboard is not valid ",color="blue")
# -- node < < warn on read-only files > >
g.es("read only:",fileName,color="red")
# -- node newTnode
# g.es("bad tnode index:",str(index),"using empty text.")
g.es("bad tnode index:",str_LP_index_RP_,"using empty text.")
# g.es("newTnode: unexpected index type:",type(index),index,color="red")
g.es("newTnode: unexpected index type:",type_LP_index_RP_,index,color="red")
# -- node getAllLeoElements
g.es("reading:",fileName)
# -- node getPrefs
# g.es("default tangle directory not found:",c.tangle_directory)
g.es("default tangle directory not found:",c_DOT_tangle_directory)
# -- node getTnode
# g.es("no tnode with index:",str(index),"the text will be discarded")
g.es("no tnode with index:",str_LP_index_RP_,"the text will be discarded")
# -- node < < handle unknown attributes > >
g.es_print("unknown attributes for tnode",color = "blue")
# g.es_print('',"%s = %s" % (key,attrDict.get(key)))
g.es_print('',"%s = %s" % (key,attrDict_DOT_get_LP_key_RP_))
# -- node < < handle unknown vnode attributes > >
# g.es_print("unknown attributes for",v.headString(),color="blue")
g.es_print("unknown attributes for",v_DOT_headString_PARENS_,color="blue")
# g.es_print('',"%s = %s" % (key,attrDict.get(key)))
g.es_print('',"%s = %s" % (key,attrDict_DOT_get_LP_key_RP_))
# -- node getExistingVnode
g.es("missing vnode:",headline,color="red")
g.es("probably an outline topology error.")
# -- node getXmlVersionTag
g.es("invalid encoding in .leo file:",encoding,color="red")
# -- node getSaxUa
g.es_print('unexpected exception converting hexlified string to string')
# -- node parse_leo_file
g.es_print('error parsing',inputFileName,color='red')
g.es_print('unexpected exception parsing',inputFileName,color='red')
# -- node save (fileCommands)
g.es("clearing undo")
# -- node putSavedMessage
# g.es("saved:","%s%s" % (zipMark,g.shortFileName(fileName)))
g.es("saved:","%s%s" % (zipMark,g_DOT_shortFileName_LP_fileName_RP_))
# -- node deleteFileWithMessage
g.es("read only",color="red")
g.es("exception deleting backup file:",fileName)
# -- node putUnknownAttributes & helper
g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
# -- node putUaHelper
g.es("ignoring non-string attribute",key,"in",torv,color="blue")
g.es('putUaHelper: unexpected pickling exception',color='red')
g.es("ignoring non-pickleable attribute",key,"in",torv,color="blue")
# -- node < < Append tnodeList and unKnownAttributes to attrs> >
# g.es("deleting tnode list for",p.headString(),color="blue")
g.es("deleting tnode list for",p_DOT_headString_PARENS_,color="blue")
# -- node < < issue informational messages > >
# g.es("writing erroneous:",p.headString(),color="blue")
g.es("writing erroneous:",p_DOT_headString_PARENS_,color="blue")
# -- node putDescendentUnknownAttributes
g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
g.es("ignoring bad unknownAttributes key",key,"in",p,color="blue")
g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
g.es("putDescendentUnknownAttributes can't happen 2",color='red')
# -- node write_Leo_file
# g.es_print('len',len(s),'putCount',self.putCount)
g.es_print('len',len_LP_s_RP_,'putCount',self_DOT_putCount)
g.es("exception writing:",fileName)
# -- node < < return if the .leo file is read-only > >
g.es("can not create: read only:",fileName,color="red")
# -- node < < create backup file > >
g.es("read only",color="red")
# -- node < < rename backupName to fileName > >
g.es("restoring",fileName,"from",backupName)
# -- node writeAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeDirtyAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeMissingAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeOutlineOnly
g.es('done',color='blue')
# ---- @thin leoGlobals.py
g.es_print('','-------------------- @thin leoGlobals.py',color='red')
# -- node computeLoadDir
g.es("load dir:",loadDir,color="blue")
# -- node set_language
# g.es("ignoring:",g.get_line(s,i))
g.es("ignoring:",g_DOT_get_line_LP_s_COMMA_i_RP_)
# -- node < < set theDict for @ directives > >
g.es("warning: conflicting values for",word,color="blue")
# -- node < < set theDict["root"] for noweb * chunks > >
# g.es('',g.angleBrackets("*") + "= requires @root in the headline")
g.es('',g_DOT_angleBrackets_LP__DQ___DQ__RP_ + "= requires @root in the headline")
# -- node g.scanAtEncodingDirective
g.es("invalid @encoding:",encoding,color="red")
# -- node g.scanAtLineendingDirective
g.es("invalid @lineending directive:",e,color="red")
# -- node g.scanAtPagewidthDirective
g.es("ignoring",s,color="red")
# -- node < < scan another @root option > >
# g.es("modes conflict in:",g.get_line(s,i))
g.es("modes conflict in:",g_DOT_get_line_LP_s_COMMA_i_RP_)
# g.es("modes conflict in:",g.get_line(s,i))
g.es("modes conflict in:",g_DOT_get_line_LP_s_COMMA_i_RP_)
g.es("unknown option:",z_opt,"in",z_line)
# -- node g.scanAtTabwidthDirective
g.es("ignoring",s,color="red")
# -- node alert
g.es('',message)
# -- node es_dump
g.es_print('',title)
g.es_print('',aList)
# -- node es_error
g.es(s,color=color)
# -- node es_event_exception
g.es("exception handling ",eventName,"event")
g.es('',i)
# -- node es_exception_type
# g.es_print('','%s, %s' % (exctype.__name__, value),color=color)
g.es_print('','%s, %s' % (exctype_DOT___name__, value),color=color)
# -- node getLastTracebackFileAndLineNumber
# g.es_print('',repr(val))
g.es_print('',repr_LP_val_RP_)
# g.es_print('',repr(data))
g.es_print('',repr_LP_data_RP_)
# -- node Timing
# g.es('',"%s %6.3f" % (message,(time.clock()-start)))
###g.es('',"%s %6.3f" % (message,(time_DOT_clock_PARENS_-start)))
# -- node g.create_temp_file
###g.es('unexpected exception in g.create_temp_file',color='red')
# -- node g.is_sentinel
g.es("can't happen: is_sentinel",color="red")
# -- node g.makeAllNonExistentDirectories
g.es("created directory:",path)
g.es("exception creating directory:",path)
# -- node g.openLeoOrZipFile
g.es("can not open:",fileName,color="blue")
# -- node g.setGlobalOpenDir
# g.es('current directory:',g.app.globalOpenDir)
g.es('current directory:',g_DOT_app_DOT_globalOpenDir)
# -- node g.update_file_if_changed
g.es('','%12s: %s' % (kind,file_name))
g.es("rename failed: no file created!",color="red")
g.es('',file_name," may be read-only or in use")
# -- node g.utils_remove
g.es("exception removing:",fileName)
# -- node g.utils_rename
g.es('exception renaming',src,'to',dst,color='red')
# -- node g.utils_chmod
g.es("exception in os.chmod",fileName)
# -- node enable_gc_debug
g.es('can not import gc module',color='blue')
# -- node g.doHook
g.es_print(s,color="blue")
# -- node g.plugin_signon
# g.es('',"...%s.py v%s: %s" % (
#             m.__name__, m.__version__, g.plugin_date(m)))
g.es('',"...%s.py v%s: %s" % (
            m_DOT___name__, m_DOT___version__, g_DOT_plugin_date_LP_m_RP_))
# -- node mini test of es
g.es(s)
g.es_print(s)
# -- node es_print
# -- node @@test g.es_print
g.es_print('\ntest of es_print: ',color='red',newline=False)
g.es_print('after')
g.es_print('done')
# -- node es_trace
# -- node < < scan another @file option > >
g.es("using -asis option in:",h)
g.es("ignoring redundant -noref in:",h)
g.es("ignoring redundant -nosent in:",h)
g.es("using -thin option in:",h)
g.es("unknown option:",z_opt,"in",h)
# -- node scanError
g.es('',s)
# -- node skip_pp_if
g.es("#if and #else parts have different braces:",start_line)
g.es("no matching #endif:",start_line)
# -- node g.initScriptFind (set up dialog)
g.es("no Find script node",color="red")
# -- node g.handleScriptException
g.es("exception executing script",color='blue')
# -- node < < dump the lines near the error > >
g.es_print('',s)
g.es('',s,newline=False)
# -- node reportBadChars
g.es(s2,color='red')
g.es(s2,color='red')
# -- node g.executeScript
g.es("exception executing",name,color="red")
# -- node g.getScript
g.es_print("unexpected exception in g.getScript")
# -- node g.cantImport
g.es_print('',s,color="blue")
# -- node g.importFromPath
g.es_print("exception in g.importFromPath",color='blue')
g.es_print("unexpected exception in g.importFromPath(%s)" %
                    (name),color='blue')
# -- node g.init_zodb
g.es('g.init_zodb: can not import ZODB')
g.es('g.init_zodb: exception creating ZODB.DB instance')
# ---- @thin leoImport.py
g.es_print('','-------------------- @thin leoImport.py',color='red')
# -- node exportHeadlines
g.es("can not open",fileName,color="blue")
# -- node flattenOutline
g.es("can not open",fileName,color="blue")
# -- node outlineToWeb
g.es("can not open",fileName,color="blue")
# -- node < < Read file into s > >
g.es("can not open",fileName, color="blue")
# -- node < < set delims from the header line > >
g.es("invalid @+leo sentinel in",fileName)
# -- node < < Write s into newFileName > >
g.es("created:",newFileName)
g.es("exception creating:",newFileName)
# -- node < < open filename to f, or return > >
g.es("exception opening:",filename)
# -- node error
g.es('',s)
# -- node < < Read file into s > >
g.es("can not open", "%s%s" % (z,fileName),color='red')
# -- node readAtAutoNodes (importCommands) & helper
# g.es_print('ignoring',p.headString(),color='blue')
g.es_print('ignoring',p_DOT_headString_PARENS_,color='blue')
g.es(message,color='blue')
# -- node importFilesCommand
g.es("imported",fileName,color="blue")
# -- node importFlattenedOutline
g.es("not a valid MORE file",fileName)
# -- node < < Read the file into array > >
g.es("can not open",fileName, color="blue")
# -- node scanWebFile (handles limbo)
g.es("can not import",fileName, color="blue")
# -- node cstLookup
g.es('',"****** %s" % (target),"is also a prefix of",s)
g.es("replacing",target,"with",s)
# -- node scanPHPText
g.es_print('seems to be mixed HTML and PHP:',fileName)
# -- node compareHelper
# g.es_print('first mismatched line at line',str(i+1))
g.es_print('first mismatched line at line',str_LP_i_1_RP_)
g.es_print('original line: ',line1)
g.es_print('generated line:',line2)
g.es_print('missing lines')
# g.es_print('',repr(line))
g.es_print('',repr_LP_line_RP_)
# -- node checkLeadingWhitespace
# g.es_print('line:',repr(line),color='red')
g.es_print('line:',repr_LP_line_RP_,color='red')
# -- node reportMismatch
# -- node insertIgnoreDirective
g.es_print('inserting @ignore',color='blue')
# -- node error, oops, report and warning
g.es_print('',s,color='red')
g.es_print('error:',s,color='red')
g.es_print('warning:',s,color='red')
# ---- @thin leoKeys.py
g.es_print('','-------------------- @thin leoKeys.py',color='red')
# -- node showAutocompleter/CalltipsStatus
g.es(s,color='red')
g.es(s,color='red')
# -- node computeCompletionList
# g.es('',z,tabName=self.tabName)
g.es('',z,tabName=self_DOT_tabName)
# -- node info
g.es('no docstring for',word,color='blue')
g.es('',doc,tabName='Info')
g.es('no docstring for',word,color='blue')
# -- node scan
g.es("This is for testing if g.es blocks in a thread", color = 'pink' )
# -- node scanOutline
g.es_print('scanning for auto-completer...')
g.es('','.',newline=False)
g.es_print('\nauto-completer scan complete',color='blue')
# -- node createClassObjectFromString
g.es_print('unexpected exception in',computeProxyObject)
# -- node forgivingParser
g.es_print('syntax error in class node: can not continue')
# g.es_print('syntax error: deleting',p.headString())
g.es_print('syntax error: deleting',p_DOT_headString_PARENS_)
# -- node bindKey
g.es_print('exception binding',shortcut,'to',commandName)
# -- node < < give warning and return if we try to bind to Enter or Leave > >
g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
# -- node < < remove previous conflicting definitions from bunchList > >
# g.es_print('redefining',z,'in',b2.pane,'to',commandName,'in',pane,color='red')
g.es_print('redefining',z,'in',b2_DOT_pane,'to',commandName,'in',pane,color='red')
# -- node k.initAbbrev
g.es_print('bad abbrev:',key,'unknown command name:',commandName,color='blue')
# -- node k.makeMasterGuiBinding
# g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')
g.es_print('exception binding',bindStroke,'to',c_DOT_widget_name_LP_w_RP_,color='blue')
# -- node callStateFunction
# g.es_print('no state function for',k.state.kind,color='red')
g.es_print('no state function for',k_DOT_state_DOT_kind,color='red')
# -- node k.show/hide/toggleMinibuffer
g.es('minibuffer hidden',color='red')
g.es('',commandName,'is bound to:',shortcut)
# -- node printBindings & helper
g.es('no bindings')
g.es('','%s %s' % (sep, prefix),tabName=tabName)
g.es('','%s %s' % (sep, 'Plain Keys',),tabName=tabName)
# -- node printBindingsHelper
# g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
# g.es('','%*s %*s %s' % (-n1,s1,-(min_LP_12_COMMA_n2_RP_),s2,s3),tabName='Bindings')
# -- node printCommands
# g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName=tabName)
# g.es('','%*s %*s %s' % (-n1,s1,-(min_LP_12_COMMA_n2_RP_),s2,s3),tabName=tabName)
# -- node repeatComplexCommand & helper
g.es('no previous command',color='blue')
# -- node k.registerCommand
g.es_print('redefining',commandName, color='red')
# g.es_print('','@command: %s = %s' % (
#                 commandName,k.prettyPrintKey(stroke)),color='blue')
g.es_print('','@command: %s = %s' % (
                commandName,k_DOT_prettyPrintKey_LP_stroke_RP_),color='blue')
g.es_print('','@command: %s' % (commandName),color='blue')
# -- node createModeBindings
g.es_print('no such command:',commandName,'Referenced from',modeName)
# -- node modeHelpHelper
g.es('','%s mode\n\n' % modeName,tabName=tabName)
###g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
# -- node k.computeCompletionList
# g.es('','%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3),tabName=tabName)
# g.es('','%*s %*s %s' % (-(min_LP_20_COMMA_n1_RP_),s1,n2,s2,s3),tabName=tabName)
# -- node k.showFileNameTabList
g.es('',s,tabName=tabName)
# ---- @thin leoNodes.py
g.es_print('','-------------------- @thin leoNodes.py',color='red')
# -- node v.bodyString
g.es_print('',s,color="red")
# -- node v.headString & v.cleanHeadString
g.es_print('',s,color="red")
# -- node scanGnx
# g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
g.es("scanGnx: unexpected index type:",type_LP_s_RP_,'',s,color="red")
# ---- @thin leoPlugins.py
g.es_print('','-------------------- @thin leoPlugins.py',color='red')
# -- node loadHandlers & helper
# -- node loadOnePlugin
g.es_print('plugin',moduleName,'already loaded',color="blue")
g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
g.es('exception loading plugin',color='red')
g.es_print('can not load enabled plugin:',moduleName,color="red")
g.es_print('loaded plugin:',moduleName,color="blue")
# -- node printHandlers
g.es_print('handlers for',moduleName,'...')
g.es_print('all plugin handlers...')
g.es_print('','%25s %s' % (tag,key))
# -- node printPlugins
g.es_print('enabled plugins...')
g.es_print('',key)
# -- node registerExclusiveHandler
g.es("*** Two exclusive handlers for","'%s'" % (tag))
# ---- @thin leoPymacs.py
g.es_print('','-------------------- @thin leoPymacs.py',color='red')
# -- node open
g.es_print('','leoPymacs.open:','no file name')
g.es_print('','leoPymacs.open:',c)
g.es_print('','leoPymacs.open:','can not open',fileName)
# ---- @thin leoTangle.py
g.es_print('','-------------------- @thin leoTangle.py',color='red')
# -- node < < call tangle_done.run() or untangle_done.run() > >
g.es("can not execute","tangle_done.run()")
g.es("can not execute","tangle_done.run()")
# -- node initTangleCommand
g.es("tangling...")
# -- node initUntangleCommand
g.es("untangling...")
# -- node tangle
g.es("looking for a parent to tangle...")
g.es("tangling parent")
g.es("tangle complete")
# -- node tangleAll
g.es("tangle complete")
# -- node tangleMarked
g.es("tangle complete")
# -- node untangle
g.es("untangle complete")
# -- node untangleAll
g.es("untangle complete")
# -- node untangleMarked
g.es("untangle complete")
# -- node untangleRoot (calls cleanup)
g.es('','@root ' + path)
# -- node < < return if @silent or unknown language > >
g.es("@comment disables untangle for",path, color="blue")
# g.es('','@%s' % (self.print_mode),"inhibits untangle for",path, color="blue")
g.es('','@%s' % (self_DOT_print_mode),"inhibits untangle for",path, color="blue")
# -- node < < Read the file into file_buf  > > in untangleRoot
g.es("error reading:",path)
# -- node tangle.put_all_roots
g.es("can not create temp file")
g.es("unchanged:",file_name)
# -- node st_check
# g.es('',' ' * 4,'warning:',lp,'',section.name,'',rp,'has been defined but not used.')
g.es('',' ' * 4,'warning:',lp,'',section_DOT_name,'',rp,'has been defined but not used.')
# -- node < <check for duplicate code definitions > >
g.es('warning: possible duplicate definition of:',s)
# -- node ust_warn_about_orphans
# g.es("warning:",'%s%s%s' % (lp,part.name,rp),"is not in the outline")
g.es("warning:",'%s%s%s' % (lp,part_DOT_name,rp),"is not in the outline")
# -- node update_def (pass 2)
# g.es("***Updating:",p.headString())
g.es("***Updating:",p_DOT_headString_PARENS_)
# -- node < < Test for @comment and @language > >
g.es("ignoring: @comment",z)
# -- node < < handle absolute @path > >
g.es("relative_path_base_directory:",base)
g.es("relative path in @path directive:",relative_path)
# -- node < < Test for @header and @noheader > >
g.es("conflicting @header and @noheader directives")
# -- node < < handle absolute path > >
g.es("relative_path_base_directory:",base)
g.es('',kind,"directory:",dir2)
# ---- @thin leoTest.py
g.es_print('','-------------------- @thin leoTest.py',color='red')
# -- node runTimerOnNode
# g.es_print("count:",count,"time/count:",ratio,'',p.headString())
g.es_print("count:",count,"time/count:",ratio,'',p_DOT_headString_PARENS_)
# -- node runTests
g.es('running',kind,'unit tests',color='blue')
g.es_print('no @test or @suite nodes in selected outline')
# -- node checkFileSyntax
g.es("syntax error in:",fileName,color="blue")
# -- node checkFileTabs
g.es_print("Token error in",fileName,color="blue")
g.es_print('',msg)
g.es_print("Indentation error in",fileName,"line",badline,color="blue")
g.es_print('',message)
g.es_print("offending line...")
g.es_print('',line)
# -- node importAllModulesInPath
g.es("path does not exist:",path)
# ---- @thin leoUndo.py
g.es_print('','-------------------- @thin leoUndo.py',color='red')
# -- node < < set newBead if we can't share the previous bead > >
g.es('exception in','setUndoRedoTypingParams',color='blue')
# -- node redoGroup
g.es("redo",count,"instances")
# -- node undoGroup
g.es("undo",count,"instances")
g.app.translateToUpperCase=False
#@nonl
#@-node:ekr.20080220082727:@scan_g.es_results
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = not g.app.unitTesting
    << return if we can set leoID from sys.leoID >>
    << return if we can set leoID from "leoID.txt" >>
    << return if we can set leoID from os.getenv('USER') >>
    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@+node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose and not g.app.unitTesting:
        g.es_print("leoID=",g.app.leoID,spaces=False,color='red')
    # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
    g.app.leoID = g.app.leoID.replace('.','-')
    return
else:
    g.app.leoID = None
#@-node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
                g.app.leoID = g.app.leoID.replace('.','-')
                if verbose and not g.app.unitTesting:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es_print('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose and not g.app.unitTesting:
            g.es("using os.getenv('USER'):",repr(theId),color='red')
        g.app.leoID = theId
        # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
        g.app.leoID = g.app.leoID.replace('.','-')
        return

except Exception:
    pass
#@-node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()

# Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
g.app.leoID = g.app.leoID.replace('.','-')

# g.trace(g.app.leoID)
g.es('leoID=',repr(g.app.leoID),spaces=False,color="blue")
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
                g.app.leoID = g.app.leoID.replace('.','-')
                if verbose and not g.app.unitTesting:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es_print('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@+node:ekr.20070426092031:Consider another way to compute home directory
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4281562
By: ktenney

I don't know if this is a resolved issue, here's another approach,
looks like a good one.

email link
http://murl.se/24201

python.org os.path doc
http://murl.se/24202

>>> import os
>>> lin_key, win_key = "home", "Documents"
>>> homedir = os.path.expanduser('~')
>>> if os.name == 'nt': os_key = win_key
>>> if os.name == 'posix': os_key = lin_key
>>> print homedir.find(os_key) > -1
True

#@-node:ekr.20070426092031:Consider another way to compute home directory
#@+node:ekr.20070227094232:getLeoID
def getLeoID (self):

    import os
    import sys

    g = self.g ; tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = False and not g.app.unitTesting
    << try to get leoID from sys.leoID >>
    if not g.app.leoID:
        << try to get leoID from "leoID.txt" >>
    if not g.app.leoID:
        << try to get leoID from os.getenv('USER') >>
    return g.app.leoID
#@+node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es("leoID=",g.app.leoID,spaces=False,color='red')
#@nonl
#@-node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
#@+node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                if verbose:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                break
            elif verbose:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
#@+node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'):",repr(theId),color='red')
        g.app.leoID = theId

except Exception:
    pass
#@-node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
#@-node:ekr.20070227094232:getLeoID
#@+node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeDir second.
    if configDir == loadDir:
        g.es('',name,"not found in",configDir)
    else:
        fileName = g.os_path_join(homeDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('',name,"not found in",configDir,"or",homeDir)
#@-node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():

    """Returns the user's home directory."""

    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@-node:ekr.20041117151301:computeHomeDir
#@-node:ekr.20080407090400.4:Found: homeDir
#@-node:ekr.20080407090400.3:Added install nodes re Leo's home directory
#@+node:ekr.20080318081653.1:Added support for @bool fixedWindow option
@nocolor

We should avoid conflicts here in the first place. We really need that
'toggle-fixed' thing (that would prevent writing window positions and node
expansion statuses to .leo file) I suggested a while back, to make collaboration
with .leo files possible...

@color
#@nonl
#@+node:ekr.20080412053100.3:Documentation
@nocolor

Leo suppresses marks, expansion state, orphan bits and current
position bits when writing fixed .leo files.  As a result, all nodes
will be collapsed and the root node will always be selected when Leo
opens a fixed .leo file.

When writing fixed .leo files, Leo writes fixed, immutable, reasonable
defaults for window size, position and body-outline ratio.
Specifically, width,height,left,top = 700,500,50,50 and the ratio is
0.5. These values are written so older versions of Leo can read fixed
files.

You make a file fixed by putting '@bool fixedWindow = True' in the
@settings tree of a particular .leo file.  The file will be fixed
after you save the file, reload the file, and save the file again.
Yes, this is clumsy, but it only has to be done once.  A toggle-fixed
file command doesn't seem that useful: using an @bool node is simple
and clear.

You can optionally specify the size and position on the screen of
fixed .leo files by putting an '@data fixedWindowPosition' node in the
@settings tree of myLeoSettings.leo or leoSettings.leo.  You should
**not** put such a node in the fixed .leo file itself--everyone who
opens the file would get that fixed position.

The body of the '@data fixedWindowPosition' node should contain
something like this:

# Must be four entries: width,height,left,top.
# Put this in myLeoSettings.leo, **not** in individual .leo files.

1200
800
50
50

Leo uses reasonable defaults for fixed .leo files if this node does
not exist, or contains something other than 4 numbers, one per line. 
#@nonl
#@-node:ekr.20080412053100.3:Documentation
#@+node:ekr.20060919145406:<< define sax classes >>
@others
#@nonl
#@+node:ekr.20060919110638.19:class saxContentHandler (XMLGenerator)
class saxContentHandler (xml.sax.saxutils.XMLGenerator):

    '''A sax content handler class that reads Leo files.'''

    @others
#@nonl
#@+node:ekr.20060919110638.20: __init__ & helpers
def __init__ (self,c,fileName,silent,inClipboard):

    self.c = c
    self.fileName = fileName
    self.silent = silent
    self.inClipboard = inClipboard

    # Init the base class.
    xml.sax.saxutils.XMLGenerator.__init__(self)

    << define dispatch dict >>

    self.printElements = [] # 'all', 'v'

    # Global attributes of the .leo file...
    # self.body_outline_ratio = '0.5'
    self.global_window_position = {}
    self.encoding = 'utf-8' 

    # Semantics...
    self.content = None
    self.elementStack = []
    self.errors = 0
    self.tnxToListDict = {} # Keys are tnx's (strings), values are *lists* of saxNodeClass objects.
    self.level = 0
    self.node = None
    self.nodeList = [] # List of saxNodeClass objects with the present tnode.
    self.nodeStack = []
    self.rootNode = None # a sax node.
#@nonl
#@+node:ekr.20060919110638.21:<< define dispatch dict >>
# There is no need for an 'end' method if all info is carried in attributes.

self.dispatchDict = {
    'change_string':               (None,None),
    'find_panel_settings':         (None,None),
    'find_string':                 (None,None),
    'globals':                     (self.startGlobals,None),
    'global_log_window_position':  (None,None), # The position of the log window is no longer used.
    'global_window_position':      (self.startWinPos,None),
    'leo_file':                    (None,None),
    'leo_header':                  (self.startLeoHeader,None),
    'preferences':                 (None,None),
    't':                           (self.startTnode,self.endTnode),
    'tnodes':                      (None,None),
    'v':                           (self.startVnode,self.endVnode),
    'vh':                          (self.startVH,self.endVH),
    'vnodes':                      (self.startVnodes,None), # Causes window to appear.
}
#@nonl
#@-node:ekr.20060919110638.21:<< define dispatch dict >>
#@-node:ekr.20060919110638.20: __init__ & helpers
#@+node:ekr.20060919110638.29: Do nothing
def endElementNS(self,unused_name,unused_qname):
    g.trace(unused_name)

def endDocument(self):
    pass

def ignorableWhitespace(self,unused_whitespace):
    pass

def skippedEntity(self,name):
    g.trace(name)

def startElementNS(self,unused_name,unused_qname,unused_attrs):
    g.trace(unused_name)

def startDocument(self):
    pass
#@nonl
#@-node:ekr.20060919110638.29: Do nothing
#@+node:ekr.20060919134313: Utils
#@+node:ekr.20060919110638.23:attrsToList
def attrsToList (self,attrs):

    '''Convert the attributes to a list of g.Bunches.

    attrs: an Attributes item passed to startElement.'''

    if 0: # check for non-unicode attributes.
        for name in attrs.getNames():
            val = attrs.getValue(name)
            if type(val) != type(u''):
                g.trace('Non-unicode attribute',name,val)

    # g.trace(g.listToString([repr(z) for z in attrs.getNames()]))

    return [
        g.Bunch(name=name,val=attrs.getValue(name))
            for name in attrs.getNames()]
#@nonl
#@-node:ekr.20060919110638.23:attrsToList
#@+node:ekr.20060919110638.26:error
def error (self, message):

    print
    print
    print 'XML error: %s' % (message)
    print

    self.errors += 1
#@nonl
#@-node:ekr.20060919110638.26:error
#@+node:ekr.20060919110638.27:inElement
def inElement (self,name):

    return self.elementStack and name in self.elementStack
#@nonl
#@-node:ekr.20060919110638.27:inElement
#@+node:ekr.20060919110638.28:printStartElement
def printStartElement(self,name,attrs):

    indent = '\t' * self.level or ''

    if attrs.getLength() > 0:
        print '%s<%s %s>' % (
            indent,
            self.clean(name).strip(),
            self.attrsToString(attrs,sep=' ')),
    else:
        print '%s<%s>' % (
            indent,
            self.clean(name).strip()),

    if name.lower() in ['v','t','vnodes','tnodes',]:
        print
#@nonl
#@+node:ekr.20060919110638.24:attrsToString
def attrsToString (self,attrs,sep='\n'):

    '''Convert the attributes to a string.

    attrs: an Attributes item passed to startElement.

    sep: the separator charater between attributes.'''

    result = [
        '%s="%s"' % (bunch.name,bunch.val)
        for bunch in self.attrsToList(attrs)
    ]

    return sep.join(result)
#@nonl
#@-node:ekr.20060919110638.24:attrsToString
#@+node:ekr.20060919110638.25:clean
def clean(self,s):

    return g.toEncodedString(s,"ascii")
#@nonl
#@-node:ekr.20060919110638.25:clean
#@-node:ekr.20060919110638.28:printStartElement
#@-node:ekr.20060919134313: Utils
#@+node:ekr.20060919110638.30:characters
def characters(self,content):

    if content and type(content) != type(u''):
        g.trace('Non-unicode content',repr(content))

    content = content.replace('\r','')
    if not content: return

    elementName = self.elementStack and self.elementStack[-1].lower() or '<no element name>'

    if elementName in ('t','vh'):
        # if elementName == 'vh': g.trace(elementName,repr(content))
        self.content.append(content)

    elif content.strip():
        print 'unexpected content:',elementName,repr(content)
#@nonl
#@-node:ekr.20060919110638.30:characters
#@+node:ekr.20060919110638.31:endElement & helpers
def endElement(self,name):

    name = name.lower()

    if name in self.printElements or 'all' in self.printElements:
        indent = '\t' * (self.level-1) or ''
        print '%s</%s>' % (indent,self.clean(name).strip())

    data = self.dispatchDict.get(name)

    if data is None:
        if 1: g.trace('unknown end element',name)
    else:
        junk,func = data
        if func:
            func()

    name2 = self.elementStack.pop()
    assert name == name2
#@nonl
#@+node:ekr.20060919110638.32:endTnode
def endTnode (self):

    for sax_node in self.nodeList:
        sax_node.bodyString = ''.join(self.content)

    self.content = []
#@nonl
#@-node:ekr.20060919110638.32:endTnode
#@+node:ekr.20060919110638.33:endVnode
def endVnode (self):

    self.level -= 1
    self.node = self.nodeStack.pop()
#@nonl
#@-node:ekr.20060919110638.33:endVnode
#@+node:ekr.20060919110638.34:endVH
def endVH (self):

    if self.node:
        self.node.headString = ''.join(self.content)

    self.content = []
#@nonl
#@-node:ekr.20060919110638.34:endVH
#@-node:ekr.20060919110638.31:endElement & helpers
#@+node:ekr.20060919110638.45:getRootNode
def getRootNode (self):
    return self.rootNode
#@-node:ekr.20060919110638.45:getRootNode
#@+node:ekr.20061004054323:processingInstruction (stylesheet)
def processingInstruction (self,target,data):

    if target == 'xml-stylesheet':
        self.c.frame.stylesheet = data
        if False and not self.silent:
            g.es('','%s: %s' % (target,data),color='blue')
    else:
        g.trace(target,data)
#@nonl
#@-node:ekr.20061004054323:processingInstruction (stylesheet)
#@+node:ekr.20060919110638.35:startElement & helpers
def startElement(self,name,attrs):

    name = name.lower()

    if name in self.printElements or 'all' in self.printElements:
        self.printStartElement(name,attrs)

    self.elementStack.append(name)

    data = self.dispatchDict.get(name)

    if data is None:
        if 1: g.trace('unknown start element',name)
    else:
        func,junk = data
        if func:
            func(attrs)
#@nonl
#@+node:ekr.20060919110638.36:getPositionAttributes
def getPositionAttributes (self,attrs):

    c = self.c

    if c.fixed and c.fixedWindowPosition:
        width,height,left,top = c.fixedWindowPosition
        d = {'top':top,'left':left,'width':width,'height':height}
    else:
        d = {}
        for bunch in self.attrsToList(attrs):
            name = bunch.name ; val = bunch.val
            if name in ('top','left','width','height'):
                try:
                    d[name] = int(val)
                except ValueError:
                    d[name] = 100 # A reasonable default.
            else:
                g.trace(name,len(val))

    return d
#@-node:ekr.20060919110638.36:getPositionAttributes
#@+node:ekr.20060919110638.37:startGlobals
def startGlobals (self,attrs):

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val

        if name == 'body_outline_ratio':
            # self.body_outline_ratio = val
            if not self.inClipboard:
                self.c.ratio = val
            # g.trace(name,val)
        elif 0:
            g.trace(name,len(val))
#@nonl
#@-node:ekr.20060919110638.37:startGlobals
#@+node:ekr.20060919110638.38:startWinPos
def startWinPos (self,attrs):

    self.global_window_position = self.getPositionAttributes(attrs)
#@nonl
#@-node:ekr.20060919110638.38:startWinPos
#@+node:ekr.20060919110638.39:startLeoHeader
def startLeoHeader (self,unused_attrs):

    self.tnxToListDict = {}
#@-node:ekr.20060919110638.39:startLeoHeader
#@+node:ekr.20060919110638.40:startVH
def startVH (self,unused_attrs):

    self.content = []
#@nonl
#@-node:ekr.20060919110638.40:startVH
#@+node:ekr.20060919112118:startVnodes
def startVnodes (self,unused_attrs):

    # __pychecker__ = '--no-argsused'

    if self.inClipboard:
        return # No need to do anything to the main window.

    c = self.c ; d = self.global_window_position

    w = d.get('width',700)
    h = d.get('height',500)
    x = d.get('left',50)
    y = d.get('top',50)
    # g.trace(d,w,h,x,y)

    # Redraw the window before writing into it.
    c.frame.setTopGeometry(w,h,x,y)
    c.frame.deiconify()
    c.frame.lift()
    c.frame.update()

    # Causes window to appear.
    # g.trace('ratio',c.frame.ratio,c.frame.secondary_ratio)
    c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
    if not self.silent and not g.unitTesting:
        g.es("reading:",self.fileName)
#@-node:ekr.20060919112118:startVnodes
#@+node:ekr.20060919110638.41:startTnode
def startTnode (self,attrs):

    if not self.inElement('tnodes'):
        self.error('<t> outside <tnodes>')

    self.content = []

    self.tnodeAttributes(attrs)
#@nonl
#@+node:ekr.20060919110638.42:tnodeAttributes
def tnodeAttributes (self,attrs):

    # The tnode must have a tx attribute to associate content with the proper node.

    node = self.node
    self.nodeList = []

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name == 'tx':
            self.nodeList = self.tnxToListDict.get(val,[])
            if not self.nodeList:
                self.error('Bad leo file: no node for <t tx=%s>' % (val))
        else:
            node.tnodeAttributes[name] = val

    if not self.nodeList:
        self.error('Bad leo file: no tx attribute for tnode')
#@nonl
#@-node:ekr.20060919110638.42:tnodeAttributes
#@-node:ekr.20060919110638.41:startTnode
#@+node:ekr.20060919110638.43:startVnode
def startVnode (self,attrs):

    if not self.inElement('vnodes'):
        self.error('<v> outside <vnodes>')

    if self.rootNode:
        parent = self.node
    else:
        self.rootNode = parent = saxNodeClass() # The dummy parent node.
        parent.headString = 'dummyNode'

    self.node = saxNodeClass()

    parent.children.append(self.node)
    self.vnodeAttributes(attrs)
    self.nodeStack.append(parent)

    return parent
#@nonl
#@+node:ekr.20060919110638.44:vnodeAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded and descendentTnodeUnknownAttributes.

def vnodeAttributes (self,attrs):

    node = self.node

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name == 't':
            aList = self.tnxToListDict.get(val,[])
            aList.append(self.node)
            self.tnxToListDict[val] = aList
            node.tnx = str(val) # nodeIndices.toString returns a string.
        else:
            node.attributes[name] = val
#@nonl
#@-node:ekr.20060919110638.44:vnodeAttributes
#@-node:ekr.20060919110638.43:startVnode
#@-node:ekr.20060919110638.35:startElement & helpers
#@-node:ekr.20060919110638.19:class saxContentHandler (XMLGenerator)
#@+node:ekr.20060919110638.15:class saxNodeClass
class saxNodeClass:

    '''A class representing one <v> element.

    Use getters to access the attributes, properties and rules of this mode.'''

    @others
#@nonl
#@+node:ekr.20060919110638.16: node.__init__
def __init__ (self):

    self.attributes = {}
    self.bodyString = ''
    self.headString = ''
    self.children = []
    self.tnodeAttributes = {}
    self.tnodeList = []
    self.tnx = None
#@nonl
#@-node:ekr.20060919110638.16: node.__init__
#@+node:ekr.20060919110638.17: node.__str__ & __repr__
def __str__ (self):

    return '<v: %s>' % self.headString

__repr__ = __str__
#@nonl
#@-node:ekr.20060919110638.17: node.__str__ & __repr__
#@+node:ekr.20060919110638.18:node.dump
def dump (self):

    print
    print 'node: tnx: %s len(body): %d %s' % (
        self.tnx,len(self.bodyString),self.headString)
    print 'children:',g.listToString(self.children)
    print 'attrs:',self.attributes.values()
#@nonl
#@-node:ekr.20060919110638.18:node.dump
#@-node:ekr.20060919110638.15:class saxNodeClass
#@-node:ekr.20060919145406:<< define sax classes >>
#@+node:ekr.20070626132332:es & minitest
def es(s,*args,**keys):

    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    # print 'es',repr(s)
    log = app.log
    if app.killed:
        return

    # Important: defining keyword arguments in addition to *args **does not work**.
    # See Section 5.3.4 (Calls) of the Python reference manual.
    # In other words, the following is about the best that can be done.
    color = keys.get('color')
    commas = keys.get('commas')
    commas = g.choose( 
        commas in (True,'True','true'),True,False)# default is False
    newline = keys.get('newline')
    newline = g.choose(
        newline in (False,'False','false'),False,True)# default is True
    spaces= keys.get('spaces')
    spaces = g.choose(
        spaces in (False,'False','false'),False,True)# default is True
    tabName = keys.get('tabName','Log')

        # Default goes to log pane *not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""):
        s = repr(s)
    s = g.translateArgs(s,args,commas,spaces)

    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            s = g.toEncodedString(s,'ascii')
            if newline: print s
            else: print s,
    else:
        if log and log.isNull:
            pass
        elif log:
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
        else:
            app.logWaiting.append((s,color),)
#@+node:ekr.20071024101611:mini test of es
@nocolor
@first
@first
@

This doesn't work as an external unit test.
To test, select all following lines and do execute-script.

s1 = 'line1 , ,  ,  end'
s2 = g.toUnicode(s1,'utf-8')

for s in (s1,s2):
    g.es(s)
    g.es_print(s)
#@-node:ekr.20071024101611:mini test of es
#@-node:ekr.20070626132332:es & minitest
#@+node:ekr.20041123092357:config.findSettingsPosition
# This was not used prior to Leo 4.5.

def findSettingsPosition (self,c,setting):

    """Return the position for the setting in the @settings tree for c."""

    munge = self.munge

    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()

    setting = munge(setting)

    for p in root.subtree_iter():
        #BJ munge will return None if a headstring is empty
        h = munge(p.headString()) or ''
        if h.startswith(setting):
            return p.copy()

    return c.nullPosition()
#@-node:ekr.20041123092357:config.findSettingsPosition
#@+node:ekr.20080412053100.2:changed
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName,relativeFileName=None):

    c = self

    # g.trace('Commands')
    self.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.

    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.chapterController = None
    self.frame = frame

    self.hiddenRootNode = leoNodes.vnode(context=c)
    self.hiddenRootNode.setHeadString('<hidden root vnode>')
    self.hiddenRootNode.t.vnodeList = [self.hiddenRootNode]
    self.isZipped = False # May be set to True by g.openWithFileName.
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()
    self.nodeHistory = nodeHistory(c)

    self.contractVisitedNodes = c.config.getBool('contractVisitedNodes')
    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')
    self.fixed = c.config.getBool('fixedWindow',False)
        # New in Leo 4.5: True: Don't write window position, expansion states, marks, etc.
    self.fixedWindowPosition = c.config.getData('fixedWindowPosition')
    if self.fixedWindowPosition:
        try:
            w,h,l,t = self.fixedWindowPosition
            self.fixedWindowPosition = int(w),int(h),int(l),int(t)
        except Exception:
            g.es_print('bad @data fixedWindowPosition',repr(self.fixedWindowPosition),color='red')
    else:
        self.windowPosition = 500,700,50,50 # width,height,left,top.

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20031218072017.3037:putGlobals
# Changed for Leo 4.0.

def putGlobals (self):

    c = self.c
    self.put("<globals")
    << put the body/outline ratio >>
    self.put(">") ; self.put_nl()
    << put the position of this frame >>
    << put the position of the log window >>
    self.put("</globals>") ; self.put_nl()
#@+node:ekr.20031218072017.3038:<< put the body/outline ratio >>
# Puts an innumerate number of digits

self.put(" body_outline_ratio=")

# New in Leo 4.5: support fixed .leo files.
self.put_in_dquotes(
    str(g.choose(c.fixed,0.5,c.frame.ratio)))
#@-node:ekr.20031218072017.3038:<< put the body/outline ratio >>
#@+node:ekr.20031218072017.3039:<< put the position of this frame >>
# New in Leo 4.5: support fixed .leo files.

if c.fixed:
    width,height,left,top = 700,500,50,50
        # Put fixed, immutable, reasonable defaults.
        # Leo 4.5 and later will ignore these when reading.
        # These should be reasonable defaults so that the
        # file will be opened properly by older versions
        # of Leo that do not support fixed .leo files.
else:
    width,height,left,top = c.frame.get_window_info()

# g.trace(width,height,left,top)

self.put_tab()
self.put("<global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3039:<< put the position of this frame >>
#@+node:ekr.20031218072017.3040:<< put the position of the log window >>
top = left = height = width = 0 # no longer used

self.put_tab()
self.put("<global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3040:<< put the position of the log window >>
#@-node:ekr.20031218072017.3037:putGlobals
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    # Not writing @auto nodes is way too dangerous.
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # forceWrite = isIgnore or not isThin or (isThin and isOrphan)
    if isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto: forceWrite = False     # Never write non-ignored @auto trees.
    elif isThin: forceWrite = isOrphan  # Only write orphan @thin trees.
    else:        forceWrite = True      # Write all other @file trees.

    << Set gnx = tnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append tnodeList and unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s><vh>%s</vh>' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        << issue informational messages >>
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('</v>\n')
    else:
        fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
# New in Leo 4.4.8.  Assign v.t.fileIndex here as needed.
if not v.t.fileIndex:
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)

if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
#@-node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
#@+node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren(): attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"

    # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    # if not self.use_sax:
        # if p.equal(self.topPosition):     attr += "T" # was a bottleneck
        # if p.equal(self.currentPosition): attr += "V" # was a bottleneck

    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    if not c.fixed:
        d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@-node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
#@+node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for",p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))
#@nonl
#@-node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
#@+node:ekr.20040702085529:<< issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.headString(),color="blue")
    p.clearOrphan()
#@-node:ekr.20040702085529:<< issue informational messages >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20060919110638.36:getPositionAttributes
def getPositionAttributes (self,attrs):

    c = self.c

    if c.fixed and c.fixedWindowPosition:
        width,height,left,top = c.fixedWindowPosition
        d = {'top':top,'left':left,'width':width,'height':height}
    else:
        d = {}
        for bunch in self.attrsToList(attrs):
            name = bunch.name ; val = bunch.val
            if name in ('top','left','width','height'):
                try:
                    d[name] = int(val)
                except ValueError:
                    d[name] = 100 # A reasonable default.
            else:
                g.trace(name,len(val))

    return d
#@-node:ekr.20060919110638.36:getPositionAttributes
#@+node:ekr.20040629121554.3:c.signOnWithVersion
def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info

    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass

    else: version = sys.platform

    if not g.unitTesting:
        g.es("Leo Log Window...",color=color)
        g.es(signon)
        g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
        g.enl()
        if c.fixed:
            g.es_print('This is a fixed window',color='red')
#@-node:ekr.20040629121554.3:c.signOnWithVersion
#@+node:ekr.20080412172151.2:updateFixedStatus
def updateFixedStatus (self):

    c = self.c
    p = g.app.config.findSettingsPosition(c,'@bool fixedWindow')
    if p:
        import leoConfig
        parser = leoConfig.settingsTreeParser(c)
        kind,name,val = parser.parseHeadline(p.headString())
        if val and val.lower() in ('true','1'):
            val = True
        else:
            val = False
        c.fixed = val

    # g.trace('c.fixed',c.fixed)
#@-node:ekr.20080412172151.2:updateFixedStatus
#@-node:ekr.20080412053100.2:changed
#@-node:ekr.20080318081653.1:Added support for @bool fixedWindow option
#@-node:ekr.20080408060320.783:Features
#@-node:ekr.20080408060320.4:4.5 a1
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
