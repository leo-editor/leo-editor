<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://leoeditor.com/leo_toc.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.48" body_secondary_ratio="0.80">
	<global_window_position top="34" left="486" height="1026" width="1176"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070417092935"><vh>Startup</vh>
<v t="ekr.20140103103143.4095"><vh>@views</vh></v>
<v t="ekr.20101220161557.6011"><vh>@file unitTestStartup.txt</vh></v>
<v t="ekr.20041121151002"><vh>@settings</vh>
<v t="ekr.20110521073115.3494"><vh>colorizer colors</vh>
<v t="ekr.20110521073115.3495"><vh>@@color keyword3_color = orange</vh></v>
<v t="ekr.20110521073115.3496"><vh>@@color keyword4_color = pink</vh></v>
</v>
<v t="ekr.20111026111009.3972"><vh>@data import_xml_tags</vh></v>
<v t="ekr.20140217055617.4231"><vh>@bool scriptingatscriptnodes = True</vh></v>
<v t="ekr.20080324133327.2"><vh>@bool allow_middle_button_paste = True</vh></v>
<v t="ekr.20101009105124.6195"><vh>@bool put_expansion_bits_in_leo_files = False</vh></v>
<v t="ekr.20051013162226"><vh>@bool test_setting = True</vh></v>
<v t="ekr.20070503064257"><vh>@bool use_chapters = True</vh></v>
<v t="ekr.20070528100318"><vh>@bool write_strips_blank_lines = False</vh></v>
<v t="ekr.20111123042627.6654"><vh>@enabled-plugins</vh></v>
<v t="ekr.20111112093605.4679"><vh>@shortcuts</vh></v>
<v t="ekr.20111124094121.3941"><vh>Empty @buttons and @commands nodes</vh>
<v t="ekr.20111124094121.3942"><vh>@buttons</vh></v>
<v t="ekr.20111124094121.3943"><vh>@commands</vh></v>
</v>
<v t="ekr.20050328101834"><vh>@page http plugin</vh>
<v t="ekr.20050328101834.1"><vh>@bool http_active = False</vh></v>
<v t="ekr.20050328101834.2"><vh>@int  port = 8080</vh></v>
<v t="ekr.20050328101834.3"><vh>@string rst_http_attributename = ''</vh></v>
</v>
<v t="ekr.20131111155830.4249"><vh>Vim settings</vh>
<v t="ekr.20131111155830.4250"><vh>@@@data vim-control-character-commands</vh></v>
<v t="ekr.20131111155830.4251"><vh>@data vim-command-tails</vh></v>
<v t="ekr.20131111155830.4252"><vh>@data vim-commands</vh></v>
<v t="ekr.20131111155830.4253"><vh>@data vim-motions</vh></v>
<v t="ekr.20131111155830.4254"><vh>@data vim-motion-tails</vh></v>
</v>
</v>
<v t="ekr.20111112092813.4154"><vh>@command cls</vh></v>
</v>
<v t="ekr.20111123042627.6654"></v>
<v t="ekr.20111112093605.4679"></v>
<v t="ekr.20051012104957"><vh>Docs</vh>
<v t="bwmulder.20050108100437.1"><vh>How to run unit tests</vh></v>
<v t="ekr.20050618061835"><vh>How to use the @test directive, by Roger Erens</vh>
<v t="ekr.20050618061835.1"><vh>Intro</vh>
<v t="ekr.20050618061835.2"><vh>@url http://www.onlamp.com/pub/a/python/2005/02/03/tdd_pyunit2.html</vh></v>
</v>
<v t="ekr.20050618061835.3"><vh>Preparations: adding a button</vh>
<v t="ekr.20050618061835.4"><vh>@@button Do @test</vh></v>
</v>
<v t="ekr.20050618061835.5"><vh>Alpha</vh>
<v t="ekr.20050618061835.6"><vh>@test my first Leo test</vh></v>
<v t="ekr.20050618061835.7"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.8"><vh>Bravo</vh>
<v t="ekr.20050618061835.9"><vh>@@test my second Leo test</vh></v>
<v t="ekr.20050618061835.10"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.11"><vh>It takes two to tango</vh>
<v t="ekr.20050618061835.6"></v>
<v t="ekr.20050618061835.9"></v>
<v t="ekr.20050618061835.12"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.13"><vh>Life gets more interesting</vh>
<v t="ekr.20050618061835.14"><vh>@@test koekiemonster.wants()</vh>
<v t="ekr.20050618061835.15"><vh>input data</vh></v>
<v t="ekr.20050618061835.16"><vh>expected result</vh></v>
</v>
<v t="ekr.20050618061835.17"><vh>output on the console</vh></v>
<v t="ekr.20050618061835.18"><vh>output on the console using print statements</vh></v>
</v>
<v t="ekr.20050618061835.19"><vh>How about @suite?</vh></v>
<v t="ekr.20050618061835.20"><vh>Final remarks</vh></v>
</v>
</v>
<v t="ekr.20100123172713.5114"><vh>Scripts</vh>
<v t="ekr.20100102164959.5088"><vh>Count pages</vh></v>
<v t="ekr.20100123172713.5116"><vh>Clean all tnodeLists</vh></v>
<v t="ekr.20070217065840"><vh>Scripts that make unit tests</vh>
<v t="ekr.20070217065840.1"><vh>@@command make-test @key = Alt-5</vh></v>
<v t="ekr.20070217065840.2"><vh>@@command do-before @key = Alt-6</vh>
<v t="ekr.20070217065840.3"><vh>getSel</vh></v>
<v t="ekr.20070217065840.4"><vh>findNodes</vh></v>
<v t="ekr.20070217065840.5"><vh>putSelectionInHeadline</vh></v>
</v>
<v t="ekr.20070217065840.6"><vh>@@command do-after @key = Alt-7</vh>
<v t="ekr.20070217072822"><vh>getSel</vh></v>
<v t="ekr.20070217065840.8"><vh>findNodes</vh></v>
<v t="ekr.20070217065840.9"><vh>putSelectionInHeadline</vh></v>
</v>
</v>
<v t="ekr.20070113145100"><vh>Create chinese folder</vh></v>
<v t="ekr.20071113140035"><vh>Find unique @ test nodes</vh></v>
<v t="ekr.20091206090247.5060"><vh>Clear all uA's, tnodeLists, etc.</vh>
<v t="ekr.20091206090247.5061"><vh>Clean unused tnodeLists</vh></v>
<v t="ekr.20091206090247.5062"><vh>Clear all timestamps</vh></v>
<v t="ekr.20091206090247.5063"><vh>Clear all uAs (unknown attributes)</vh></v>
</v>
</v>
<v t="ekr.20071113203234"><vh>Test files</vh>
<v t="ekr.20090704085350.5028"><vh>@asis ../test/unittest/at-asis-test.py</vh>
<v t="ekr.20090704085350.5029"><vh>spam</vh></v>
<v t="ekr.20090704085350.5030"><vh>eggs</vh></v>
</v>
<v t="ekr.20110610122533.3407"><vh>@auto ../test/at-auto-unit-test.py</vh></v>
<v t="ekr.20111214104615.3942"><vh>@auto ../test/unittest/at-auto-section-ref-test.py</vh></v>
<v t="ekr.20090704085350.5056"><vh>@auto ../test/unittest/at-auto-test.py</vh></v>
<v t="ekr.20080904084223.1"><vh>@auto unittest/at-auto-line-number-test.py</vh></v>
<v t="ekr.20111021115306.3697"><vh>@file ../test/unittest/tex-error.tex</vh></v>
<v t="ekr.20110615130436.3317" a="O"><vh>@file nonexistent-directory/orphan-bit-test.txt</vh>
<v t="ekr.20110615130436.3318"><vh>Child goes here.</vh></v>
</v>
<v t="ekr.20080904102243.2"><vh>@file unittest/at-file-line-number-test.py</vh></v>
<v t="ekr.20130912092638.4150"><vh>@file ../test/utf-16-test.txt</vh></v>
<v t="ekr.20090704085350.5034"><vh>@nosent ../test/unittest/at-nosent-test.py</vh>
<v t="ekr.20090704085350.5035"><vh>spam</vh></v>
<v t="ekr.20090704085350.5036"><vh>eggs</vh></v>
</v>
<v t="ekr.20080907123324.2"><vh>@nosent unittest/at-nosent-line-number-test.py</vh>
<v t="ekr.20080907123324.3"><vh>at-nosent-child</vh></v>
</v>
<v t="ekr.20090704085350.5014"><vh>@shadow ../test/unittest/at-shadow-test.py</vh></v>
<v t="ekr.20080907122804.1"><vh>@shadow unittest/at-shadow-line-number-test.py</vh></v>
<v t="ekr.20111213122041.3930"><vh>@shadow unittest/at-shadow-unlink-clones.py</vh></v>
<v t="ekr.20120229082711.3934"><vh>@@@shadow unittest/at-shadow-unlink-clones.py (COPY)</vh>
<v t="ekr.20120229082711.3935"><vh>Node 1</vh></v>
<v t="ekr.20120229082711.3936"><vh>Node 2</vh></v>
</v>
<v t="ekr.20100731163237.5782"><vh>@thin ../test/unittest/at-thin-html-test.html</vh></v>
<v t="ekr.20090704085350.5022"><vh>@thin ../test/unittest/at-thin-test.py</vh></v>
<v t="ekr.20070627082044.811"><vh>@thin ../test/unittest/batchTest.py</vh></v>
<v t="ekr.20070627082044.808"><vh>@thin ../test/unittest/errorTest.py</vh></v>
<v t="ekr.20080905130723.3"><vh>@thin unittest/at-thin-line-number-test.py</vh></v>
</v>
<v t="ekr.20111211094936.3970"><vh>To do</vh>
<v t="ekr.20111115080347.3872"><vh>To do: tests of the high-level interface</vh>
<v t="ekr.20100131171342.5478"><vh>@@@test that log and body implements high-level interface</vh></v>
</v>
<v t="ekr.20100131171342.5473"><vh>Tk gui tests</vh>
<v t="ekr.20100131171342.5474"><vh>@test leoBody is subset of leoTkBody</vh></v>
<v t="ekr.20100131171342.5475"><vh>@test leoFrame is subset of leoTkFrame</vh></v>
<v t="ekr.20100131171342.5476"><vh>@test leoGui is subset of leoTkGui</vh></v>
<v t="ekr.20100131171342.5477"><vh>@test leoTree is subset of leoTkTree</vh></v>
</v>
<v t="ekr.20111125183140.3952"><vh>@test ic.createOutline changes back-slashes to slashes</vh></v>
<v t="ekr.20111125182408.3947"><vh>@test ic.createImportParent changes back-slashes to slashes</vh></v>
</v>
<v t="ekr.20101220161557.6013"><vh>Slow and unused tests</vh>
<v t="ekr.20101220161557.6014"><vh>@file inactiveTests.txt</vh></v>
</v>
<v t="ekr.20101220161557.6016"><vh>Active Unit Tests</vh>
<v t="ekr.20070114140212" descendentVnodeUnknownAttributes="7d7100285505302e382e3771017d71025808000000616e6e6f7461746571037d7104735508302e372e31302e3971057d71065809000000756e69745f7465737471075804000000616263647108735508302e372e31342e3671097d710a5808000000616e6e6f74617465710b7d710c735508302e372e31362e37710d7d710e5808000000616e6e6f74617465710f7d711073752e"><vh>@file activeUnitTests.txt</vh></v>
</v>
<v t="ekr.20140206132559.4567"><vh>@test parse-body (fails)</vh>
<v t="ekr.20140206132559.4560"><vh>before</vh></v>
<v t="ekr.20140206132559.4564"><vh>expected</vh>
<v t="ekr.20140206132559.4565"><vh>__init__</vh></v>
<v t="ekr.20140206132559.4566"><vh>spam</vh></v>
</v>
</v>
<v t="ekr.20090529141856.4682"><vh>leoImport</vh>
<v t="ekr.20090529141856.4684"><vh> Export tests</vh>
<v t="ekr.20090529141856.4685"><vh>@suite Export tests</vh></v>
</v>
<v t="ekr.20090529141856.4698"><vh> Import tests</vh>
<v t="ekr.20090529141856.4699"><vh>@suite Import tests</vh></v>
</v>
<v t="ekr.20090529141856.4790"><vh> Test files</vh></v>
<v t="ekr.20090529141856.4716"><vh> Tests of @auto</vh>
<v t="ekr.20090529141856.4782"><vh>@test checkTrialWrite</vh></v>
<v t="ekr.20090529141856.4783"><vh>@test collapse-all</vh></v>
<v t="ekr.20090529141856.4717"><vh>C tests</vh>
<v t="ekr.20090529141856.4718"><vh>@test c class 1</vh></v>
<v t="ekr.20090529141856.4719"><vh>@test c class--underindented line</vh></v>
<v t="ekr.20090529141856.4720"><vh>@test defaultImporter</vh></v>
<v t="ekr.20090529141856.4721"><vh>@test c test--comment follows arg list</vh></v>
<v t="ekr.20090529141856.4722"><vh>@test c test--comment follows block delim</vh></v>
<v t="ekr.20090529141856.4723"><vh>@test c test--intermixed blanks and tabs</vh></v>
<v t="ekr.20090529141856.4724"><vh>@test c old-style decl 1</vh></v>
<v t="ekr.20090529141856.4725"><vh>@test c old-style decl 2</vh></v>
<v t="ekr.20090529141856.4726"><vh>@test c extern</vh></v>
</v>
<v t="ekr.20090529141856.4727"><vh>c# tests</vh>
<v t="ekr.20090529141856.4728"><vh>@test c# namespace indent</vh></v>
<v t="ekr.20090529141856.4729"><vh>@test c# namespace no indent</vh></v>
<v t="ekr.20090529141856.4730"><vh>@@test c# ref card</vh></v>
</v>
<v t="ekr.20090529141856.4731"><vh>elisp tests</vh>
<v t="ekr.20090529141856.4732"><vh>@test elisp functions</vh></v>
<v t="ekr.20090529141856.4733"><vh>@test elisp 2</vh></v>
</v>
<v t="ekr.20111029112647.4099"><vh>html tests</vh>
<v t="ekr.20111107102431.3849"><vh>@@test html whitespace bug</vh></v>
<v t="ekr.20111029112647.4101"><vh>@test html: lowercase tags</vh></v>
<v t="ekr.20111109143012.3839"><vh>@test html: multiple tags on a line</vh></v>
<v t="ekr.20111102164107.3975"><vh>@test html: underindented comment</vh></v>
<v t="ekr.20111029120441.3982"><vh>@test html: uppercase tags</vh></v>
<v t="ekr.20111112103320.3849"><vh>@test html: improperly nested tags</vh></v>
<v t="ekr.20111112103320.3887"><vh>@test html: improperly terminated tags</vh></v>
<v t="ekr.20111112103320.3893"><vh>@test html: improperly terminated tags2</vh></v>
</v>
<v t="ekr.20100803234640.5804"><vh>ini tests</vh>
<v t="ekr.20100803234640.5805"><vh>@test ini-test-1</vh></v>
</v>
<v t="ekr.20090529141856.4766"><vh>Java tests</vh>
<v t="ekr.20090529141856.4767"><vh>@test java interface test1</vh></v>
<v t="ekr.20090529141856.4768"><vh>@test java interface test2</vh></v>
<v t="ekr.20090529141856.4769"><vh>@@test constants.java</vh></v>
<v t="ekr.20090529141856.4770"><vh>@test from AdminPermission.java</vh></v>
<v t="ekr.20090529141856.4771"><vh>@@test AdminPermission.java</vh></v>
<v t="ekr.20090529141856.4773"><vh>@test from BundleException.java</vh></v>
</v>
<v t="ekr.20090529141856.4774"><vh>Javascript tests</vh>
<v t="ekr.20090529141856.4775"><vh>Problems</vh></v>
<v t="ekr.20090529141856.4776"><vh>@test Javascript-regex-1</vh></v>
<v t="ekr.20090529141856.4777"><vh>@test Javascript-2</vh></v>
<v t="ekr.20090529141856.4778"><vh>@test Javascript-3</vh></v>
<v t="ekr.20140218042220.4347"><vh>@test Javascript-4 (fails)</vh></v>
</v>
<v t="ekr.20121011094154.3906"><vh>TypeScript tests</vh>
<v t="ekr.20121011094154.3911"><vh>@test TypeScript class</vh></v>
<v t="ekr.20121011100210.4035"><vh>@test TypeScript module</vh></v>
</v>
<v t="ekr.20090529141856.4734"><vh>Pascal tests</vh>
<v t="ekr.20090529141856.4735"><vh>@test pascal-to-delphi interface</vh></v>
</v>
<v t="ekr.20100219080213.5365"><vh>PHP tests</vh>
<v t="ekr.20100219080213.5366"><vh>@test php import class</vh></v>
<v t="ekr.20100219080213.5367"><vh>@test php import conditional class</vh></v>
<v t="ekr.20100219080213.5368"><vh>@test php import classes &amp; functions</vh></v>
</v>
<v t="ekr.20090529141856.4736"><vh>Python tests</vh>
<v t="ekr.20090529141856.4737"><vh>@@test nested class</vh></v>
<v t="ekr.20090529141856.4738"><vh>@test python comment after dict assign</vh></v>
<v t="ekr.20090529141856.4739"><vh>@test python decorator</vh></v>
<v t="ekr.20090529141856.4740"><vh>@test python def inside def</vh></v>
<v t="ekr.20090529141856.4741"><vh>@test docstring only</vh></v>
<v t="ekr.20090529141856.4742"><vh>@test overindent def--no following def</vh></v>
<v t="ekr.20090529141856.4743"><vh>@test overindent def--one following def</vh></v>
<v t="ekr.20090529141856.4744"><vh>@test overindented def 3</vh></v>
<v t="ekr.20090529141856.4745"><vh>@test python bad class test</vh></v>
<v t="ekr.20101101034131.6042"><vh>@test python bug 603720</vh></v>
<v t="ekr.20090529141856.4746"><vh>@test python class test 2</vh></v>
<v t="ekr.20090529141856.4747"><vh>@test python class tests 1</vh></v>
<v t="ekr.20090529141856.4748"><vh>@test python decls test 1</vh></v>
<v t="ekr.20090529141856.4749"><vh>@test python def test 1</vh></v>
<v t="ekr.20090529141856.4750"><vh>@test python def test 2</vh></v>
<v t="ekr.20090529141856.4751"><vh>@test python empty decls</vh></v>
<v t="ekr.20090529141856.4752"><vh>@test python extra leading ws test</vh></v>
<v t="ekr.20090529141856.4753"><vh>@test python indent decls</vh></v>
<v t="ekr.20090529141856.4754"><vh>@test python minimal class 1</vh></v>
<v t="ekr.20090529141856.4755"><vh>@test python minimal class 2</vh></v>
<v t="ekr.20090529141856.4756"><vh>@test python minimal class 3</vh></v>
<v t="ekr.20090529141856.4757"><vh>@test python underindent method</vh></v>
<v t="ekr.20090529141856.4758"><vh>@test scanPythonText: leoImportNosent.py</vh></v>
<v t="ekr.20090529141856.4759"><vh>@test string test: extra indent</vh></v>
<v t="ekr.20090529141856.4760"><vh>@test string underindent lines</vh></v>
<v t="ekr.20090529141856.4761"><vh>@test string underindent lines 2</vh></v>
<v t="ekr.20090529141856.4762"><vh>@test trailing comment</vh></v>
<v t="ekr.20090529141856.4763"><vh>@test trailing comment--outer levels</vh></v>
<v t="ekr.20090529141856.4764"><vh>@test two functions (for comparison with unindent does not end function)</vh></v>
<v t="ekr.20090529141856.4765"><vh>@test unindent in triple string does not end function</vh></v>
</v>
<v t="ekr.20090529141856.4780"><vh>xml tests</vh>
<v t="ekr.20090529141856.4781"><vh>@test xml 1</vh></v>
<v t="ekr.20111026105935.3966"><vh>@test xml 2</vh></v>
<v t="ekr.20120306173116.3933"><vh>@test xml non-ascii tags</vh></v>
</v>
</v>
<v t="ekr.20090529141856.4784"><vh> Tests of @auto-rst</vh>
<v t="ekr.20090529141856.4785"><vh>@test rST import test</vh></v>
<v t="ekr.20090529141856.4786"><vh>@test rST import test (no double-underlines)</vh></v>
<v t="ekr.20090529141856.4787"><vh>@test rST import test: long underlines</vh></v>
<v t="ekr.20090529141856.4788"><vh>@test rST import test: long overlines</vh></v>
<v t="ekr.20090529141856.4789"><vh>@test rST import test: trailing whitespace</vh></v>
</v>
<v t="ekr.20090529141856.4793"><vh>@@test test imports for modes</vh></v>
<v t="ekr.20111228125719.3909"><vh>@test ic.BaseScanner.insertIgnoreDirective</vh></v>
<v t="ekr.20111110095252.3845"><vh>@test ic.compareTokens: mismatched length</vh>
<v t="ekr.20111110095252.3846"><vh>&lt;&lt; define tokens &gt;&gt;</vh></v>
</v>
<v t="ekr.20111105221757.3831"><vh>@test ic.createImportParent</vh></v>
<v t="ekr.20111214100515.3921"><vh>@test ic.createOutline: at-auto with lines that look like section references</vh></v>
<v t="ekr.20111104112332.3954"><vh>@test ic.htmlScanner.adjust_class_ref</vh></v>
<v t="ekr.20111111074026.3972"><vh>@test ic.htmlScanner.skipComment/Id/String</vh></v>
<v t="ekr.20100131180007.5393"><vh>@test ic.reportMismatch</vh></v>
<v t="ekr.20111105065243.3837"><vh>@test ic.rstScanner.removeBlankLinesTokens (rst)</vh></v>
<v t="ekr.20111104112332.3955"><vh>@test ic.skip...Token (htmlScanner)</vh></v>
<v t="ekr.20111104112332.3956"><vh>@test ic.skip...Token (pythonScanner)</vh></v>
<v t="ekr.20111104114406.3833"><vh>@test ic.tokenize (htmlScanner)</vh>
<v t="ekr.20111104114406.3834"><vh>&lt;&lt; define expected &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090529141856.4774"></v>
<v t="ekr.20140218045755.4348"><vh>@test p.nosentinels</vh></v>
</vnodes>
<tnodes>
<t tx="bwmulder.20050108100437.1">@killcolor

Running unit tests from test.leo is easy, provided you have enabled the
Scripting plugin. When this plugin is enabled Leo will create a blue 'script
button' in the icon bar called 'unit test'. 

- To run all unit tests, select the node in test.leo called 'Unit tests...',
then do &lt;alt-4&gt; 

- To run a single test, select an @test node and do &lt;alt-4&gt;.

- To run a suite of tests, select an @suite node and do &lt;alt-4&gt;.

- To run any other collection of tests, create an outline containing those @test
or @suite nodes, select the root of that tree and do &lt;alt-4&gt; .

Several nodes in the tree @thin ../src/leoTest.py (in test.leo) contain support
code for @test, @suite, etc. so if you want all the gory details you can read
the code. It's not complicated: Leo creates UnitTest classes automatically whose
run method is the body of the @suite or @test node.
</t>
<t tx="ekr.20041121151002"></t>
<t tx="ekr.20050328101834"></t>
<t tx="ekr.20050328101834.1"></t>
<t tx="ekr.20050328101834.2"></t>
<t tx="ekr.20050328101834.3"></t>
<t tx="ekr.20050618061835">@killcolor

Here is a tutorial written by Roger Erens.

Version Date        LeoID       Remarks
------- ----        -----       -------
0.1     20050519    rogererens  Initial version</t>
<t tx="ekr.20050618061835.1">So you think "Well, since I've written this piece of funky Python software, and everybody keeps saying how useful unit testing is, I really ought to start using unit tests." And since Leo's creator has said countless times in the Leo forums how easy unit testing in Leo is, a few uncomplicated examples might help convince you that he's not spamming.

Beware: this How-To should be the last time that you write tests AFTER having written your funky software! Test Driven Development dictates that tests have to be prepared BEFORE you get down to writing your actual code. See a nice tutorial on O'Reilly's website (url given in the descendant node).</t>
<t tx="ekr.20050618061835.10">Start of Do @test
F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Documents and Settings\re1705\My Documents\PythonStuff\leo\src\leoTes
t.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.010s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.11">A real fun feature of Leo is that Leo saves you from having to select each and single @test node and press the 'Do @test' button to obtain testing results. Just collecting the @test nodes under an organizing node, selecting that organizing node, and pressing the 'Do @test' button will suffice.
Of course, this was one of the key ideas of unit testing, but it's nice to see it being implemented by Leo so smoothly!

So, press the button while having this node selected, and see if your console's output matches the third child node more or less. </t>
<t tx="ekr.20050618061835.12">Start of Do @test
.F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 2 tests in 0.040s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.13">Okay: so you've seen now some simple stand-alone tests to get your toes wet.
Now, we get to the 'grande finale' and see real-life usage of the @test nodes.

The @test child node below illustrates the following points:

1.  The node imports the module to test (and keeps it up to date by reloading it).
2.  It also obtains data to use as input and referral. This is what you might call
    the setUp methods in traditional unit tests. If more tests need the same data,
    you can put the nodes in a central place where all the @test nodes can find
    them. Likewise, common code for several unit tests might be collected in a
    central place.
3.  Comparable with the traditional unit tests' tearDown method, some statements
    can follow the test itself, if neccessary. You might also consider using a
    try/finally construct.
4.  I have used g.es() statements instead of print statements, since the latter
    clutter the console. Try replacing the g.es() statements by corresponding
    print statements to see what I mean. With more than one @test node being tested,
    this will give quite a dreadful look.</t>
<t tx="ekr.20050618061835.14">@color

try:
    # SETUP
    import koekiemonster # this module defines a function want() which we want to test
    reload(koekiemonster) # changes in koekiemonster need to propagate to the test

    # obtaining the input parameter for the function
    inputNode = p.firstChild()
    inputData = inputNode.b
    
    # obtaining the expected result from the function with above input parameter
    expectedResultNode = inputNode.next()
    expected = expectedResultNode.b
    
    # execute the function with above input parameter
    result = koekiemonster.wants(inputData)
    
    # TEST
    assert(result == expected)
    
    # TEARDOWN
    g.es("Now it's time to clean up")

except AssertionError:
    # TEARDOWN
    g.es("Oh oh! %s failed:" % p.h.strip())
    g.es("koekiemonster.wants(%s)==%s" % (inputData, result))
    g.es("Expected: %s" % expected)
    raise # pass the exception on to the unit test machinery</t>
<t tx="ekr.20050618061835.15">vegetables</t>
<t tx="ekr.20050618061835.16">Yuck!</t>
<t tx="ekr.20050618061835.17">Start of Do @test
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.070s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.18">Start of Do @test
Oh oh: @test koekiemonster.wants() failed:
koekiemonster.wants(vegetables)=Yack!
Expected: Yuck!
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.051s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.19">With the aforementioned possibilities of running all @test nodes in a subtree
with a single click on a button, the sharing of input/expected data, and the
sharing of setUp/tearDown code, there hardly seems a need for the @suite nodes.

On Leo's website
(http://webpages.charter.net/edreamleo/scripting.html#unit-testing-with-test-and-suite)
I could still find some extra info on @suite nodes, not found in LeoDocs.leo:

&lt;quote&gt;

Using @suite nodes

Such nodes create a suite of tests. Leo executes the script in these nodes similar to @test nodes, but Leo assumes that the script in an @suite node will do the following:

    * Create a suite of unit tests
    * Put the suite in g.app.scriptDict["suite"]

The difference between @test and @suite is:

    * Leo creates a unit test from script in an @test node by creating an instance of generalTestCase, a subclass of unittest.TestCase.
    * The script in an @suite node creates the test suite.

An @suite nodes allows us to create "legacy" unit tests simply. For example,
rather than rewriting all the reformatParagraph unit tests to use @test nodes, I
simply wrote an @suite node with the following body.

    suite = c.testManager.makeReformatParagraphSuite()
    g.app.scriptDict['suite'] = suite

&lt;/quote&gt;

Well, that's almost, but not quite completely, totally incomprehensible to me.
Fortunately, since Leo's creator removed most of this quote from LeoDocs.leo and
test.leo, this information appears to be outdated
.</t>
<t tx="ekr.20050618061835.2"></t>
<t tx="ekr.20050618061835.20">Don't forget to read the node
Users Guide--&gt;Chapter 7: Scripting Leo with Python--&gt;Unit testing with @test, @suite
in LeoDocs.leo, especially the final notes. Also investigate a little further in test.leo to see some heavy weight lifting.

This concludes my How-To on using @test. It was not written by an expert on (unit) testing;
it is more or less the result of keeping notes on my way to find out how I could get started
with unit tests in Leo. Maybe it's useful for other newbies as well.

Please post any remarks on one of the Leo Fora, and if deemed helpful, I'll be glad to incorporate them into a next version.

Happy testing!</t>
<t tx="ekr.20050618061835.3">Comment by EKR: There is no need to do this if you use test.leo for your unit tests:  just use the unit test button.

From the console, start up a Leo instance. On MS Windows: go to the folder in which you installed Leo 4.3, open up the 'src' folder and double click the 'leo.py' file. Opening a command window, and typing "python leo.py" may be another way.

Use the File--&gt;Open... menu item to open the outline containing your code.

Choose a good-looking position to insert a new node called 'Test zone'. Copy the child node of the node you're reading right now, and paste it as a child node of 'Test zone'. The code it contains is essentially the same as found in the node
Unit tests...--&gt;Do @test
in the file 'test.leo' in the 'test' folder. I just added my 0.2 cents by adding some starting and finishing remarks. Remove them if they clutter your console too much.

Also, make sure that you have an entry 'Scripting' in the 'Plugins' menu (enable the plugin if neccessary). Now is a good time to save your leo file.

With the 'Scripting' plugin (also known as the 'mod_scripting' plugin) enabled, the net effect will be that the next time you open your outline, a blue button with the caption 'Do @test' shows up in the tool bar of Leo, if your screen is wide enough.
To get the button right away in the tool bar, I have to assume that you started Leo with the scripting plugin enabled. In this case, a yellow button with the caption 'script Button' can be pressed while having the node '@button Do @test' selected. Note: the resulting button will not be blue, but pink. Removing a button from the tool bar can be done by right-clicking it.

We'll see the use of this added button soon, but before that, read up on the 'assert' function in the Python manuals, since it is used a lot in testing. It won't be long before you're back here!</t>
<t tx="ekr.20050618061835.4">@color

g.pr("\nStart of Do @test")
c.testManager.doTests(all=False)
g.pr("End of Do @test")</t>
<t tx="ekr.20050618061835.5">The first child node of the node you're reading right now, contains the simplest succeeding test possible.
Select it, and press the button 'Do @test'.
You can find the verbatim result as it got sent to my console in the second child node.

A few things are worth noting here:

1.  The node containing the test must have its headline start with '@test'.
2.  Whenever the 'assert' statement finds out that the expression given to it
    is 'True', a test passes successfully. There are more ways to pass a test, but
    for now, let us stick to the use of assert functions.
3.  A passed test is denoted with a single dot in the output. See the line between
    'Start of Do @test' and the line filled with dashes. This is compatible with the
    way traditional unit testing shows its progress.
4.  Below the dashed line in the output, a summary is printed. This one surely gives
    us a reason to lean back for a moment, and congratualate ourselves with another
    piece of robust, funky code!</t>
<t tx="ekr.20050618061835.6">@color
assert(True)</t>
<t tx="ekr.20050618061835.7">Start of Do @test
.
----------------------------------------------------------------------
Ran 1 test in 0.010s

OK
End of Do @test</t>
<t tx="ekr.20050618061835.8">Now that you've seen a passing test, it should be obvious to imagine how a failing test would look like. See the first child node, and then run it by pressing the 'Do @test' button as before.

Instead of a dot denoting success, we get an 'F' denoting a failure on the line following 'Start of Do @test'. When running a lot of tests, the next part, following the lines filled with '='s, helps to identify which test failed.
It also includes a trace back, but for AssertionErrors, it does not seem to offer much added value to me right now. On second thought: when you have multiple asserts in a test, the trace back can tell you which assert function failed. Still, I would choose for only one assert function per test and get rid of this trace back altogether. This would keep the console much cleaner, IMHO.</t>
<t tx="ekr.20050618061835.9">@color
assert('Spam' == 'Ham')</t>
<t tx="ekr.20051012104957"></t>
<t tx="ekr.20051013162226"></t>
<t tx="ekr.20070113145100"># Not part of cvs distributions, but needed for two unit tests.

dir = g.os_path_join(g.app.loadDir,'..','test','unittest',g.u('chinese\u8116folder'),encoding='utf-8')
s   = g.os_path_join(dir,g.u('chinese\u8116test.leo'),encoding='utf-8')
    
if not g.os_path_exists(dir):
    import os
    os.mkdir(dir)
    g.pr('created chinese folder')
    
if not g.os_path_exists(s):
    f = file(s,'w')
    f.close()
    g.pr('created chinese file')
    
</t>
<t tx="ekr.20070217065840">@nocolor-node

@
To make unit tests, do the following:
    
- Use the make-test script (Alt-5) to create a suboutline for a unit test.
- Put text in the before node, selected desired text, then do the do-before script (Alt-6).
- Execute the command, then do the do-after script (Alt-7).
</t>
<t tx="ekr.20070217065840.1">try:
    p1 = p.insertAfter()
    c.setHeadString(p1,'@test ')
    body = 'c.testManager.runEditCommandTest(c,p)'
    c.setBodyString(p1,body)
    for s in ('work','before','after'):
        p2 = p1.insertAsLastChild()
        c.setHeadString(p2,s)
    p1.expand()
finally:
    c.redraw()
    c.editPosition(p1)</t>
<t tx="ekr.20070217065840.2">@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. The work node should have body text. If all is as expected,
copy the body text the work node to the before node, and represent the selection
range of the work in the headline of the before node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top and work.b:

    c.setBodyString(before,work.b)
    c.setBodyString(after,'')
    putSelectionInHeadline(c,before,'before',sel)
    c.redraw()
else:
    g.es_print('do-before: not in a proper @test tree')</t>
<t tx="ekr.20070217065840.3">def getSel(c):
    
    w = c.frame.body.bodyCtrl
    i,j= w.getSelectionRange()
    if i == j:
        i = j = w.getInsertPoint()
        sel = (i,i)
    return i,j</t>
<t tx="ekr.20070217065840.4">def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.h.startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild() 
    before = work and work.next()     
    after  = before and before.next()
    if (
        work   and work.h.startswith('work') and
        before and before.h.startswith('before') and
        after  and after.h.startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None</t>
<t tx="ekr.20070217065840.5">def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.h,repr(sel))

    w = c.frame.body.bodyCtrl
    i,j = sel
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    s = '%s sel=%s,%s' % (prefix,i,j)
    c.setHeadString(p,s)
</t>
<t tx="ekr.20070217065840.6">@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. If all is as expected, copy the work node to the after node,
and represent the selection range of the work node in the headline of the after node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top:
    c.setBodyString(after,work.b)
    putSelectionInHeadline(c,after,'after',sel)
    c.redraw()
else:
    g.es_print('do-after: not in @test tree')</t>
<t tx="ekr.20070217065840.8">def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.h.startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild()
    before = work and work.next()
    after  = before and before.next()
    if (
        work   and work.h.startswith('work') and
        before and before.h.startswith('before') and
        after  and after.h.startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None</t>
<t tx="ekr.20070217065840.9">def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.h,repr(sel))
    
    w = c.frame.body.bodyCtrl
    i,j = sel
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    s = '%s sel=%s,%s' % (prefix,i,j)
    c.setHeadString(p,s)
</t>
<t tx="ekr.20070217072822">def getSel(c):
    
    w = c.frame.body.bodyCtrl
    i,j= w.getSelectionRange()
    if i == j:
        i = j = w.getInsertPoint()
        sel = (i,i)
    return i,j</t>
<t tx="ekr.20070417092935" str_leo_pos="8"></t>
<t tx="ekr.20070503064257"></t>
<t tx="ekr.20070528100318"># Required to make a typing test work.
</t>
<t tx="ekr.20071113140035">fn = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','core','leoPy.leo'))
assert g.os_path_exists(fn),fn
c1 = c
c2 = g.openWithFileName(fn,old_c=None,enableLog=False)
assert c2
c.frame.bringToFront()
g.app.setLog(c.frame.log)

d1 = {} ; d2 = {}
for c,d in ( (c1,d1),(c2,d2)):
    for p in c.all_unique_positions():
        if p.h.startswith('@test'):
            d[p.h]=p.h

if 0: # not important
    g.pr()
    g.pr('----- Only in unitTest.leo')
    for h in sorted(d1.keys()):
        if not d2.get(h):
            print(h)

print('\n----- Only in leoPy.leo')
for h in sorted(d2.keys()):
    if not d1.get(h):
        print(h)</t>
<t tx="ekr.20071113203234"></t>
<t tx="ekr.20080324133327.2">True: allow linux-like pastes using a mouse's middle button.

Important: this may cause crashes on some platforms.
</t>
<t tx="ekr.20080907123324.2">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080907123324.3">def child():
    pass

#
#
#
#
#
#
</t>
<t tx="ekr.20090529141856.4682"></t>
<t tx="ekr.20090529141856.4684">@language python
@tabwidth -4
</t>
<t tx="ekr.20090529141856.4685"># Create unit tests in g.app.scriptDict["suite"]

suite = c.testManager.makeImportExportSuite("exportTests",doImport=False)

# g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20090529141856.4698"></t>
<t tx="ekr.20090529141856.4699"># Create unit tests in g.app.scriptDict["suite"]

suite = c.testManager.makeImportExportSuite("importTests",doImport=True)

# g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20090529141856.4716">@tabwidth -4
@language python
</t>
<t tx="ekr.20090529141856.4717"></t>
<t tx="ekr.20090529141856.4718">fileName = p.h

s = '''\
class cTestClass1 {

    int foo (int a) {
        a = 2 ;
    }

    char bar (float c) {
        ;
    }
}
'''

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4719">fileName = p.h

s = '''\
class cTestClass1 {

    int foo (int a) {
# an underindented line.
        a = 2 ;
    }

    # This should go with the next function.

    char bar (float c) {
        ;
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 1
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4720">fileName = p.h

s = '''\
class cTestClass1 {

    int foo (int a) {
        a = 2 ;
    }

    char bar (float c) {
        ;
    }
}
'''

c.importCommands.defaultImporterUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4721">fileName = p.h

s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) //  &lt;---------------------problem
{
    return true;
}
'''

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4722">fileName = p.h

s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) 
{
    return true;
} //  &lt;---------------------problem
'''

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4723">fileName = p.h

s = '''
void
aaa::bbb::doit
    (
    awk* b  // leading blank
    )
{
	assert(false); // leading tab
}

'''

g.app.unitTestDict ['expectedErrors'] = 0 # Intermixed blanks and tabs are ok for C.

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4724">fileName = p.h

s = '''\
static void
ReleaseCharSet(cset)
    CharSet *cset;
{
    ckfree((char *)cset-&gt;chars);
    if (cset-&gt;ranges) {
    ckfree((char *)cset-&gt;ranges);
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4725">fileName = p.h

s = '''\
Tcl_Obj *
Tcl_NewLongObj(longValue)
    register long longValue;	/* Long integer used to initialize the
         * new object. */
{
    return Tcl_DbNewLongObj(longValue, "unknown", 0);
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4726">fileName = p.h

s = '''\
extern  "C"
{
#include "stuff.h"
void    init(void);
#include "that.h"
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4727"></t>
<t tx="ekr.20090529141856.4728">s = '''\
namespace {
    class cTestClass1 {
        ;
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cSharpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4729">s = '''\
namespace {
class cTestClass1 {
    ;
}
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cSharpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4730">import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','big-c#-test.c#'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.cSharpUnitTest(p,s=s,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20090529141856.4731"></t>
<t tx="ekr.20090529141856.4732">s = '''\
;;; a.el --- Test

;; some other verbose comment
;; some other verbose comment
;; some other verbose comment

(defun abc (a1 a2)
  "Return blah blah."
  (+ 1 2))

(defun fgh (a1 a2)
  "Return blah blah."
  (- 1 2))

;;; a.el ends here
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.elispUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4733">s = '''\
;;; comment
;;; continue
;;;

(defun abc (a b)
   (+ 1 2 3))

; comm
(defun cde (a b)
   (+ 1 2 3))
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.elispUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4734"></t>
<t tx="ekr.20090529141856.4735">s = '''
unit Unit1;

interface

uses
Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
Forms,
Dialogs;

type
TForm1 = class(TForm)
procedure FormCreate(Sender: TObject);
private
{ Private declarations }
public
{ Public declarations }
end;

var
Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.FormCreate(Sender: TObject);
var
x,y: double;
begin
x:= 4;
Y := x/2;
end;

end.
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pascalUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4736"># Warning: setting atAuto=True can wipe out unit tests.
</t>
<t tx="ekr.20090529141856.4737">s = '''\
NS = { 'i': 'http://www.inkscape.org/namespaces/inkscape',
      's': 'http://www.w3.org/2000/svg',
      'xlink' : 'http://www.w3.org/1999/xlink'}

tabLevels = 4  # number of defined tablevels, FIXME, could derive from template?
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4738">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
NS = { 'i': 'http://www.inkscape.org/namespaces/inkscape',
      's': 'http://www.w3.org/2000/svg',
      'xlink' : 'http://www.w3.org/1999/xlink'}

tabLevels = 4  # number of defined tablevels, FIXME, could derive from template?
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4739">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class Index:
    """docstring"""
    @cherrypy.nocolor
    @cherrypy.expose
    def index(self):
        return "Hello world!"
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4740">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class aClass:
    def outerDef(self):
        """docstring.
        line two."""

        def pr(*args,**keys):
            g.es_print(color='blue',*args,**keys)

        a = 3
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4741">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
"""A file consisting only of a docstring.
"""
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4742">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class aClass:
    def def1(self):
        pass

    if False or g.unitTesting:

        def pr(*args,**keys): # reportMismatch test
            g.es_print(color='blue',*args,**keys)

        pr('input...')
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4743">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class aClass:
    def def1(self):
        pass

    if False or g.unitTesting:

        def pr(*args,**keys): # reportMismatch test
            g.es_print(color='blue',*args,**keys)

        pr('input...')

    def def2(self):
        pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4744">@tabwidth -4
    # Required when running unit tests externally.

# This caused PyParse.py not to be imported properly.
s = r'''
import re
if 0: # Causes the 'overindent'
   if 0:   # for throwaway debugging output
      def dump(*stuff):
        sys.__stdout__.write(" ".join(map(str, stuff)) + "\n")
for ch in "({[":
   _tran[ord(ch)] = '('
class testClass1:
    pass
'''
c.importCommands.pythonUnitTest(p,s=s,showTree=False)

</t>
<t tx="ekr.20090529141856.4745">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class testClass1 # no colon
    pass

def spam():
    pass
'''

g.app.unitTestDict ['expectedErrors'] = 0 # Not really an error.

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4746">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class testClass2:
    pass
'''

tree = c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4747">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class testClass1:
    """A docstring"""
    def __init__ (self):
        pass
    def f1(self):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4748">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
import leo.core.leoGlobals as g

a = 3
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4749">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class test:

    def importFilesCommand (self,files=None,treeType=None,
        perfectImport=True,testing=False,verbose=False):
            # Not a command.  It must *not* have an event arg.

        c = self.c
        if c == None: return
        p = c.currentPosition()

    # Used by paste logic.

    def convertMoreStringToOutlineAfter (self,s,firstVnode):
        s = string.replace(s,"\\r","")
        strings = string.split(s,"\\n")
        return self.convertMoreStringsToOutlineAfter(strings,firstVnode)
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4750">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class test:
    def spam(b):
        pass

    # Used by paste logic.

    def foo(a):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4751">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
import leo.core.leoGlobals as g

a = 3
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4752">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class cls:
     def fun(): # one extra space.
        pass
'''

g.app.unitTestDict ['expectedErrors'] = None # No error unless we get an unexpected mismatch line.
g.app.unitTestDict ['expectedMismatchLine'] = 3 # The error happens before any lines are checked.
g.app.unitTestDict ['expectedErrorMessage'] = 'leading whitespace not consistent with @tabwidth -4'

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4753">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class mammalProviderBase(object):
    """Root class for content providers used by DWEtree.py"""
    def __init__(self, params):
        """store reference to parameters"""
        self.params = params
    def provide(self, what):
        """default &lt;BASE&gt; value"""
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/'])
        return None

    def imagePath(self, sppdat):
        """return path to images and list of images for *species*"""
        path = 'MNMammals/imglib/Mammalia'
        for i in 'Order', 'Family', 'Genus', 'Species':
            path = os.path.join(path, sppdat['%sName' % (i,)])
        imglib = os.path.join('/var/www',path)
        imglib = os.path.join(imglib, '*.[Jj][Pp][Gg]')
        path = os.path.join('/',path)
        lst = [os.path.split(i)[1] for i in glob.glob(imglib)]
        lst.sort()
        return path, lst

class mainPages(mammalProviderBase):
    """provide content for pages in 'main' folder"""
    __parent = mammalProviderBase
    def provide(self, what):
        """add one layer to &lt;BASE&gt;"""
        ans = self.__parent.provide(self, what)
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/']+'main/')
        return ans
''' 

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4754">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class ItasException(Exception):

    pass

def gpRun(gp, cmd, args, log = None):

    """Wrapper for making calls to the geoprocessor and reporting errors"""

    if log:

        log('gp: %s: %s\\n' % (cmd, str(args)))
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)


</t>
<t tx="ekr.20090529141856.4755">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class emptyClass: pass

def followingDef():
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4756">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class emptyClass: pass # comment

def followingDef(): # comment
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4757">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class emptyClass: 

    def spam():

        """docstring line 1
under-indented docstring line"""
        pass

def followingDef(): # comment
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4758">@encoding utf-8
    # leoImport.py uses unicode characters, so *this* test must have the directive above.

@tabwidth -4
    # Required when running unit tests externally.

fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'leoImport.py'))

f = open(fileName)
s = f.read()
f.close()

g.app.unitTestDict['testingLeoImport.py'] = True

c.importCommands.pythonUnitTest(p,s=None,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20090529141856.4759">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class BaseScanner:

        """The base class for all import scanner classes."""

        def __init__ (self,importCommands,language):

            self.c = ic.c

        def createHeadline (self,parent,body,headline):
            # g.trace("parent,headline:",parent,headline)
            return p
'''

# We expect mismatches because the indentation does not match @tabwidth -4.
g.app.unitTestDict ['expectedErrors'] = None # No error unless we get an unexpected mismatch line.
g.app.unitTestDict ['expectedMismatchLine'] = 3
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4760">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class BaseScanner:
    def containsUnderindentedComment(self):
        a = 2
    # A true underindented comment.
        b = 3
    # This underindented comment should be placed with next function.
    def empty(self):
        pass
'''

g.app.unitTestDict ['expectedErrors'] = 0 # underindented comments are no longer an error.
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4761">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class BaseScanner:
    def containsUnderindentedComment(self):
        a = 2
    #
        b = 3
        # This comment is part of the present function.

    def empty(self):
        pass
'''

g.app.unitTestDict ['expectedErrors'] = 0 # underindented comments are no longer an error.
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4762">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class aClass: # trailing comment


    def def1(self):             # trailing comment
        pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4763">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

xyz = 6 # trailing comment
pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4764">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

def foo():
    pass

def bar():
    pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4765">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

def foo():

    error("""line1
line2.
""")

    a = 5

def bar():
    pass
'''

showTree = False
keepTree = False

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=showTree)

if showTree:
    try:
        child = p.firstChild()
        n = child.numberOfChildren()
        assert n == 2, 'expected 2 children, got %s' % n
    finally:
        if keepTree:
            h = child.h
            print('h',h)
            child.setHeadString('@'+h)
        else:
            while p.hasChildren():
                p.firstChild().doDelete()
        c.redraw(p)
</t>
<t tx="ekr.20090529141856.4766"></t>
<t tx="ekr.20090529141856.4767">s = '''\
interface Bicycle {
    void changeCadence(int newValue);
    void changeGear(int newValue);
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4768">s = '''\
interface Bicycle {
void changeCadence(int newValue);
void changeGear(int newValue);
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4769">import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','constants.java'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=None,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20090529141856.4770">s = '''\
/**
 * Indicates the caller's authority to perform lifecycle operations on
 */

public final class AdminPermission extends BasicPermission
{
    /**
     * Creates a new &lt;tt&gt;AdminPermission&lt;/tt&gt; object.
     */
    public AdminPermission()
    {
        super("AdminPermission");
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)

</t>
<t tx="ekr.20090529141856.4771">import sys

if sys.platform.lower().startswith('win'):


    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','AdminPermission.java'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=s,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20090529141856.4773">@language python
@tabwidth 8
    # Must be in this node when run externally.

s = '''\
/*
 * $Header: /cvs/leo/test/unitTest.leo,v 1.247 2008/02/14 14:59:04 edream Exp $
 * 
 * Copyright (c) OSGi Alliance (2000, 2005). All Rights Reserved.
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this 
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html.
 */

package org.osgi.framework;

/**
 * A Framework exception used to indicate that a bundle lifecycle problem
 * occurred.
 * 
 * &lt;p&gt;
 * &lt;code&gt;BundleException&lt;/code&gt; object is created by the Framework to denote
 * an exception condition in the lifecycle of a bundle.
 * &lt;code&gt;BundleException&lt;/code&gt;s should not be created by bundle developers.
 * 
 * &lt;p&gt;
 * This exception is updated to conform to the general purpose exception
 * chaining mechanism.
 * 
 * @version $Revision: 1.247 $
 */

public class BundleException extends Exception {
	static final long	serialVersionUID	= 3571095144220455665L;
	/**
	 * Nested exception.
	 */
	private Throwable	cause;

	/**
	 * Creates a &lt;code&gt;BundleException&lt;/code&gt; that wraps another exception.
	 * 
	 * @param msg The associated message.
	 * @param cause The cause of this exception.
	 */
	public BundleException(String msg, Throwable cause) {
		super(msg);
		this.cause = cause;
	}
}

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4774">@language python
</t>
<t tx="ekr.20090529141856.4775">@language javascript

// regexps that look like section references.

{
	name: "macro",
	match: "&lt;&lt;",
	lookaheadRegExp: /&lt;&lt;([^&gt;\s]+)(?:\s*)((?:[^&gt;]|(?:&gt;(?!&gt;)))*)&gt;&gt;/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch &amp;&amp; lookaheadMatch.index == w.matchStart &amp;&amp; lookaheadMatch[1]) {
			w.nextMatch = this.lookaheadRegExp.lastIndex;
			invokeMacro(w.output,lookaheadMatch[1],lookaheadMatch[2],w,w.tiddler);
		}
	}
},

// Comments that look like section references.

// &lt;&lt;gradient [[tiddler name]] vert|horiz rgb rgb rgb rgb... &gt;&gt;

config.macros.gradient.handler = function(place,macroName,params,wikifier)
{
	var panel = wikifier ? createTiddlyElement(place,"div",null,"gradient") : place;
	panel.style.position = "relative";
	panel.style.overflow = "hidden";
	panel.style.zIndex = "0";
	if(wikifier) {
		var styles = config.formatterHelpers.inlineCssHelper(wikifier);
		config.formatterHelpers.applyCssHelper(panel,styles);
	}
	var colours = [];
	for(var t=1; t&lt;params.length; t++) {
		var c = new RGB(params[t]);
		if(c)
			colours.push(c);
	}
	drawGradient(panel,params[0] != "vert",colours);
	if(wikifier)
		wikifier.subWikify(panel,"&gt;&gt;");
	if(document.all) {
		panel.style.height = "100%";
		panel.style.width = "100%";
	}
};

// @Deprecated: Use &lt;br&gt; or &lt;br /&gt; instead of &lt;&lt;br&gt;&gt;
config.macros.br = {};
config.macros.br.handler = function(place)
{
	createTiddlyElement(place,"br");
};
</t>
<t tx="ekr.20090529141856.4776">s = '''\

String.prototype.toJSONString = function()
{
    if(/["\\\\\\x00-\\x1f]/.test(this))
		return '"' + this.replace(/([\\x00-\\x1f\\"])/g,replaceFn) + '"';

	return '"' + this + '"';
};

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4777">s = '''\

// Convert a string to it's JSON representation by encoding control characters, double quotes and backslash. See json.org
String.prototype.toJSONString = function()
{
	var m = {
		'\\b': '\\\\b',
		'\\f': '\\\\f',
		'\\n': '\\\\n',
		'\\r': '\\\\r',
		'\\t': '\\\\t',
		'"' : '\\\\"',
		'\\\\': '\\\\\\\\'
		};
	var replaceFn = function(a,b) {
		var c = m[b];
		if(c)
			return c;
		c = b.charCodeAt();
		return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
		};
    if(/["\\\\\\x00-\\x1f]/.test(this))
		return '"' + this.replace(/([\\x00-\\x1f\\"])/g,replaceFn) + '"';

	return '"' + this + '"';
};

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4778">s = '''\

// Restarting
function restart()
{
	invokeParamifier(params,"onstart");
	if(story.isEmpty()) {
		var tiddlers = store.filterTiddlers(store.getTiddlerText("DefaultTiddlers"));
		for(var t=0; t&lt;tiddlers.length; t++) {
			story.displayTiddler("bottom",tiddlers[t].title);
		}
	}
	window.scrollTo(0,0);
}

'''

# Double each backslash (they are in a docstring).
# chars = [z for z in s]
# s = []
# for z in char:
    # if z == '\\': s.append('\\\\')
    # else: s.append(z)
# s = s.join('')

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4780"></t>
<t tx="ekr.20090529141856.4781">s = '''\
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/head&gt;
&lt;body class='bodystring'&gt;
&lt;div id='bodydisplay'&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.xmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4782">@first # -*- coding: utf-8 -*-

import leo.core.leoImport as leoImport
import sys

ic = c.importCommands
runner = leoImport.BaseScanner(ic,atAuto=True,language='python')
runner.root = p.copy()

g.app.unitTestDict ['expectedMismatchLine'] = 0

s1 = 'line , ,  end'
s2 = 'line , , end'

# Tracing checkTrialWrite causes a UnicodeDecodeError.
ok = runner.checkTrialWrite(s1=s1,s2=s2)

assert ok
</t>
<t tx="ekr.20090529141856.4783">c.contractAllHeadlines()
</t>
<t tx="ekr.20090529141856.4784"></t>
<t tx="ekr.20090529141856.4785">s = '''\
.. toc

====
top
====

The top section

section 1
---------

section 1, line 1
--
selction 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.rstUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4786">s = '''\
.. toc

top
====

The top section

section 1
---------

section 1, line 1
--
selction 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.rstUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4787">s = '''\
.. toc

top
-------------

The top section
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.rstUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4788">s = '''\
.. toc

======
top
======

The top section
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.rstUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4789">s = '''\
.. toc

.. The section name contains trailing whitespace.

======
top 
======

The top section.
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.rstUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4790">import leo.core.leoImport as leoImport
ic = c.importCommands
runner = leoImport.BaseScanner(ic,atAuto=True,language='python')
i = 0
lines1 = ['abc',]
lines2 = ['xyz',]

g.app.unitTestDict ['expectedErrors'] = 1
g.app.unitTestDict ['expectedMismatchLine'] = 1

runner.compareHelper(lines1,lines2,i,strict=True)
</t>
<t tx="ekr.20090529141856.4793">d = g.app.extra_extension_dict

for ext in g.app.extension_dict.keys():
    language =  c.importCommands.languageForExtension(ext)
    language2 = c.importCommands.languageForExtension('.'+ext)
    assert language == language2

    # Now a many-one relationship.
    if language:
        # Do not test extensions that have 'none' as the value of d.get(ext)
        # Otherwise, test only d.get(ext).
        language2 = d.get(ext)
        if language2 in ('None','none'):  continue
        if language2: language = language2
        # Made-up languages do not have mode files.
        if not language.endswith('_language') and language not in ('autohotkey','rest',):
            path = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
            assert g.os_path_exists(path), 'for ext=%s does not exist: %s' % (ext,path)

    if 0:
        if language is None:
            print('no language for ext=%s' % (ext))
</t>
<t tx="ekr.20090704085350.5028">@language python
@others</t>
<t tx="ekr.20090704085350.5029">def spam():
    pass</t>
<t tx="ekr.20090704085350.5030">def eggs():
    pass</t>
<t tx="ekr.20090704085350.5034">@language python
@others</t>
<t tx="ekr.20090704085350.5035">def spam():
    pass</t>
<t tx="ekr.20090704085350.5036">def eggs():
    pass</t>
<t tx="ekr.20091206090247.5060"># Use these with caution.</t>
<t tx="ekr.20091206090247.5061">count = 0
for p in c.all_unique_positions():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print(s) ; g.es(s)</t>
<t tx="ekr.20091206090247.5062"># About the only time you should run this script is when:
# - changing the format of timestamps in nodeIndices.setTimestamp or
# - when making a retroactive change to leoID.txt.

if 0: # This is usually a very bad idea.

    for p in c.all_positions():
        p.v.fileIndex = None

    g.es("all timestamps cleared")</t>
<t tx="ekr.20091206090247.5063">doDelete = False
put = g.es_print
for p in c.all_positions():
    if p.v.u:
        put("found v.u:",p.h,
            g.listToString(p.v.u.keys()))
        if doDelete:
            p.v.u = None
put('done') 
c.redraw()</t>
<t tx="ekr.20100102164959.5088">nodes = 0 ; lines = 0
for p in c.all_unique_positions():
    nodes += 1
    lines += len(g.splitLines(p.b))

pages = ((nodes * 10) + lines) / 50
s = "%d nodes,  %d lines, %d pages" % (nodes,lines,pages)
print(s); g.es(s)</t>
<t tx="ekr.20100123172713.5114"></t>
<t tx="ekr.20100123172713.5116">count = 0
for p in c.all_unique_positions():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList"): # and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print s ; g.es(s)</t>
<t tx="ekr.20100131171342.5473"></t>
<t tx="ekr.20100131171342.5474">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)
    assert(tkGui)

    import leo.core.leoFrame as leoFrame
    import inspect,sys

    baseClass = leoFrame.leoBody
    subClasses  = (tkGui.leoTkinterBody,leoFrame.nullBody)
    baseObject = c.frame.body

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        try:
            assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)
        except AssertionError:
            exctype, value = sys.exc_info()[:2]
            print(value)
            raise

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                #raise
                exctype, value = sys.exc_info()[:2]
                print(value)
</t>
<t tx="ekr.20100131171342.5475">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoFrame
    subClasses  = (tkGui.leoTkinterFrame,leoFrame.nullFrame)
    baseObject = c.frame

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
</t>
<t tx="ekr.20100131171342.5476">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoGui as leoGui
    import inspect

    baseClass = leoGui.leoGui
    subClasses  = (tkGui.tkinterGui,) # nullGui can inherit almost all leoGui dummy methods.
    baseObject = g.app.gui

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                raise
</t>
<t tx="ekr.20100131171342.5477">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoTree
    subClasses  = (tkGui.leoTkinterTree,leoFrame.nullTree)
    baseObject = c.frame.tree

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
</t>
<t tx="ekr.20100131171342.5478">logCtrl = c.frame.log.logCtrl

table = (
    ('mustBeDefinedInSubclasses',logCtrl.mustBeDefinedInSubclasses),
    ('mustBeDefinedInBaseClass',logCtrl.mustBeDefinedOnlyInBaseClass),
    ('mustBeDefined',logCtrl.mustBeDefined),
)

# Check existence.
for tag,aList in table:
    for z in aList:
        assert hasattr(c.frame.log,z),'%s %s %s' % (tag,c.frame.log,z)
        assert hasattr(c.frame.body,z),'%s %s %s' % (tag,c.frame.body,z)

# Check signatures.
import inspect
for tag,aList in table:
    for z in aList:
        func = getattr(c.frame.body.bodyCtrl,z)
        func2 = getattr(c.frame.log.logCtrl,z)
        assert func,z
        assert func2,z
        d1 = inspect.getargspec(func)
        d2 = inspect.getargspec(func2)
        assert d1==d2,'\n%s\n\nd1 %s\n\nd2 %s' % (z,d1,d2)
</t>
<t tx="ekr.20100131180007.5393">import leo.core.leoImport as leoImport

ic = c.importCommands
scanner = leoImport.rstScanner(importCommands=ic,atAuto=True)
scanner.root = p
s1 = ["abc","xyz",]
s2 = ["xyz",]

scanner.reportMismatch(s1,s2,1,1)

s1 = ["xyz",]
s2 = ["abc","xyz",]

scanner.reportMismatch(s1,s2,1,1)
</t>
<t tx="ekr.20100219080213.5365"></t>
<t tx="ekr.20100219080213.5366">s = '''\
&lt;?php

$type = 'cc';
$obj = new $type; // outputs "hi!"

class cc {
    function __construct() {
        echo 'hi!';
    }
}

?&gt;

'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.phpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20100219080213.5367">s = '''\
&lt;?php

if (expr) {
    class cc {
        // version 1
    }
} else {
    class cc {
        // version 2
    }
}

?&gt;
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.phpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20100219080213.5368">s = '''\
&lt;?php
class Enum {
    protected $self = array();
    public function __construct( /*...*/ ) {
        $args = func_get_args();
        for( $i=0, $n=count($args); $i&lt;$n; $i++ )
            $this-&gt;add($args[$i]);
    }

    public function __get( /*string*/ $name = null ) {
        return $this-&gt;self[$name];
    }

    public function add( /*string*/ $name = null, /*int*/ $enum = null ) {
        if( isset($enum) )
            $this-&gt;self[$name] = $enum;
        else
            $this-&gt;self[$name] = end($this-&gt;self) + 1;
    }
}

class DefinedEnum extends Enum {
    public function __construct( /*array*/ $itms ) {
        foreach( $itms as $name =&gt; $enum )
            $this-&gt;add($name, $enum);
    }
}

class FlagsEnum extends Enum {
    public function __construct( /*...*/ ) {
        $args = func_get_args();
        for( $i=0, $n=count($args), $f=0x1; $i&lt;$n; $i++, $f *= 0x2 )
            $this-&gt;add($args[$i], $f);
    }
}
?&gt;

'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.phpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20100803234640.5804"></t>
<t tx="ekr.20100803234640.5805">s = '''\
; last modified 1 April 2001 by John Doe
[owner]
name=John Doe
organization=Acme Widgets Inc.

[database]
server=192.0.2.62     ; use IP address in case network name resolution is not working
port=143
file = "payroll.dat"
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.iniUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20101009105124.6195">True (recommended):
    Write "E" attribute bits in &lt;v&gt; elements.
    Leo outlines will record the expansion state of all nodes.

False:
    (Good for files like unitTest.leo)
    Suppress "E" attribute bits in &lt;v&gt; elements.
    Only the ancestors of the presently selected node will
    be expanded when Leo opens an outline.
</t>
<t tx="ekr.20101101034131.6042">@tabwidth -4
    # Required when running unit tests externally.

# Leo bug 603720
# Within the docstring we must change '\' to '\\'
s = '''\
def foo():
    s = \\
"""#!/bin/bash
cd /tmp
ls"""
    file('/tmp/script', 'w').write(s)

class bar:
    pass

foo()
'''

showTree = False

tree = c.importCommands.pythonUnitTest(p,s=s,showTree=showTree)

if showTree:
    c.redraw_now()
    foo = g.findNodeInTree(c,p,'foo')
    assert foo
    s = "file('/tmp/script', 'w').write(s)"
    print('foo.b',repr(foo.b))
    assert foo.b.find(s) &gt; -1,"foo.b: %s" % foo.b
</t>
<t tx="ekr.20101220161557.6013"># Some of these tests give warnings.</t>
<t tx="ekr.20101220161557.6016"></t>
<t tx="ekr.20110521073115.3494"></t>
<t tx="ekr.20110521073115.3495">builtins, including cython builtins
</t>
<t tx="ekr.20110521073115.3496">cython keywords
</t>
<t tx="ekr.20110615130436.3317">@language rest

This file is part of a unit test that ensures that orphan bits are retained when
writing .leo files.

The path is **supposed** not to exist.
</t>
<t tx="ekr.20110615130436.3318">Child content goes here.</t>
<t tx="ekr.20111026105935.3966">s = '''\
&lt;nodeA&gt;
&lt;nodeB/&gt;
&lt;/nodeA&gt;
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.xmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111026111009.3972"># lowercase xml tags, one per line.

html
body
head
div
table
nodeA
nodeB
</t>
<t tx="ekr.20111029112647.4099"></t>
<t tx="ekr.20111029112647.4101">s = '''\
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/head&gt;
&lt;body class='bodystring'&gt;
&lt;div id='bodydisplay'&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111029120441.3982">s = '''\
&lt;HTML&gt;
&lt;HEAD&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/HEAD&gt;
&lt;BODY class='bodystring'&gt;
&lt;DIV id='bodydisplay'&gt;&lt;/DIV&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111102164107.3975">s = '''\

&lt;td width="550"&gt;
&lt;table cellspacing="0" cellpadding="0" width="600" border="0"&gt;
    &lt;td class="blutopgrabot" height="28"&gt;&lt;/td&gt;
    
    &lt;!-- The indentation of this element causes the problem. --&gt;
    &lt;table&gt;
    
&lt;!--
&lt;div align="center"&gt;
&lt;iframe src="http://www.amex.com/atamex/regulation/listingStatus/index.jsp"&lt;/iframe&gt;
&lt;/div&gt;
--&gt;

&lt;/table&gt;
&lt;/table&gt;

&lt;p&gt;Paragraph&lt;/p&gt;
&lt;/td&gt;

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111104112332.3954">import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)

s = '''
&lt;aTag&gt;  @others
&lt;/aTag&gt;
'''

# Avoid probems with representation of @others in scripts.
expected = '\n&lt;aTag&gt;\n@others\n&lt;/aTag&gt;\n'

result = hs.adjust_class_ref(s)
assert result == expected,'expected...\n%s\ngot...\n%s' % (
    repr(expected),repr(result))
</t>
<t tx="ekr.20111104112332.3955">import leo.core.leoImport as leoImport
ic = c.importCommands
scanner = leoImport.htmlScanner(importCommands=ic,atAuto=True)

tails = (
    '&lt;whatever&gt;',
    '+ abc', # don't concatenate with id or whitespace.
    '&lt;!-- tail comment --&gt;',
    '"tail string"',
)
    
table = (
    (scanner.skipCommentToken,  '&lt;!-- Test --&gt;'),
    (scanner.skipIdToken,       'a_b-c.d:e'), # Valid in xml ids:  ".-:"
    # (scanner.skipNewlineToken,'\n'),
        # xmlScanner.skipNewlineToken throws exception (on purpose).
    (scanner.skipOtherToken,    '+'),
    (scanner.skipOtherToken,    '#'),
    (scanner.skipStringToken,   '"A string"'),
    (scanner.skipWsToken,       ' '),
)

# Special test for whitespace: Converts all runs of whitespace to a single blank.
if 0: # No longer does this.
    s = ' \n\t\t \n'
    i,result = scanner.skipWsToken(s+tails[0],0)
    assert i == len(s),'expected i==%s, got i==%s' % (len(s),i)
    expected = ' '
    assert result == expected,'expected...\n%s\ngot...\n%s' % (
        repr(expected),repr(result))
    
for f,s in table:
    for tail in tails:
        i,result = f(s+tail,0)
        expected = s
        assert i == len(s),'expected i==%s, got i==%s' % (len(s),i)
        assert result == expected,'expected...\n%s\ngot...\n%s' % (
            repr(expected),repr(result))
</t>
<t tx="ekr.20111104112332.3956">import leo.core.leoImport as leoImport
ic = c.importCommands
scanner = leoImport.pythonScanner(importCommands=ic,atAuto=True)
    
tails = (
    '+ abc', # don't concatenate with id or whitespace.
    '# tail comment',
    '"tail string"',
    "'tail string'",
)

table = (
    (scanner.skipCommentToken,  '# Test'),
    (scanner.skipIdToken,       'ab_c'),
    (scanner.skipNewlineToken,  '\n'),
    (scanner.skipOtherToken,    '+'),
    (scanner.skipOtherToken,    '#'),
    (scanner.skipStringToken,   '"A string"'),
    (scanner.skipWsToken,       ' '),
    (scanner.skipWsToken,       '\t '),
)
    
for f,s in table:
    for tail in tails:
        if f.__name__ == 'skipCommentToken':
            i,result = f(s,0)
        else:
            i,result = f(s+tail,0)
        expected = s
        assert i == len(s),'expected i==%s, got i==%s' % (len(s),i)
        assert result == expected,'expected...\n%s\ngot...\n%s' % (
            repr(expected),repr(result))
</t>
<t tx="ekr.20111104114406.3833">import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)

s = '''
&lt;!-- a comment --&gt;
&lt;html "string"&gt;
Test.
&lt;/html&gt;
'''

&lt;&lt; define expected &gt;&gt;

result = hs.tokenize(s)

if 1:
    assert result == expected,'expected...\n%s\ngot...\n%s' % (
        repr(expected),repr(result))
else:
    print(result)
    
@


AssertionError: expected...
[('ws', ' ', 0), ('comment', '&lt;!-- a comment --&gt;', 1), ('ws', ' ', 1), ('other', '&lt;', 2), ('id', 'html', 2), ('ws', ' ',
 2), ('string', '"string"', 2), ('other', '&gt;', 2), ('ws', ' ', 2), ('id', 'Test.', 3), ('ws', ' ', 3), ('other', '&lt;', 4)
, ('other', '/', 4), ('id', 'html', 4), ('other', '&gt;', 4), ('ws', ' ', 4)]
got...
[('nl', '\n', 0), ('comment', '&lt;!-- a comment --&gt;', 1), ('nl', '\n', 1), ('other', '&lt;', 2), ('id', 'html', 2), ('ws', '
', 2), ('string', '"string"', 2), ('other', '&gt;', 2), ('nl', '\n', 2), ('id', 'Test.', 3), ('nl', '\n', 3), ('other', '&lt;'
, 4), ('other', '/', 4), ('id', 'html', 4), ('other', '&gt;', 4), ('nl', '\n', 4)]

----------------------------------------------------------------------
Ran 1 test in 0.018s

FAILED (failures=1)

</t>
<t tx="ekr.20111104114406.3834"># expected = [
    # ('ws', ' ', 0),
    # ('comment', '&lt;!-- a comment --&gt;', 1),
    # ('ws', ' ', 1),
    # ('other', '&lt;', 2), ('id', 'html', 2),
    # ('ws', ' ',2), ('string', '"string"', 2),
    # ('other', '&gt;', 2),
    # ('ws', ' ', 2),
    # ('id', 'Test.', 3),
    # ('ws', ' ', 3),
    # ('other', '&lt;', 4), ('other', '/', 4), ('id', 'html', 4), ('other', '&gt;', 4),
    # ('ws', ' ', 4),
# ]

expected = [
    ('nl', '\n', 0),
    ('comment', '&lt;!-- a comment --&gt;', 1),
    ('nl', '\n', 1),
    ('other', '&lt;', 2),
    ('id', 'html', 2),
    ('ws', ' ', 2),
    ('string', '"string"', 2),
    ('other', '&gt;', 2),
    ('nl', '\n', 2),
    ('id', 'Test.', 3),
    ('nl', '\n', 3),
    ('other', '&lt;', 4),
    ('other', '/', 4),
    ('id', 'html', 4),
    ('other', '&gt;', 4),
    ('nl', '\n', 4),
]
</t>
<t tx="ekr.20111105065243.3837"># Important: at present only the rstScanner sets ignoreBlankLines == True
import leo.core.leoImport as leoImport
sc = leoImport.rstScanner(c.importCommands,atAuto=False)

assert sc.ignoreBlankLines,'fail0'

def strip(tokens):
    '''Remove the line number item from all tokens.'''
    return [(kind,val) for kind,val,n in tokens]
    
table = (
    ('a\n\nb',          'a\nb'),
    ('a\n \t\nb',       'a\nb'),
    ('a\n \n\t\n\n\nb', 'a\nb'),
    ('a\nb\n',          'a\nb\n'),
)

for s,expected in table:

    tokens = sc.tokenize(s)
    s2 = ''.join([val for (kind,val,n) in tokens])
    assert s == s2,'fail1\nexpected:\n%s\ngot:\n%s' % (
        repr(s),repr(s2))
    
    # A: Remove tokens for blank lines from tokens.
    tokens2 = sc.removeBlankLinesTokens(tokens)
    
    # B: Remove blank lines first, then tokenize.
    lines = g.splitLines(s)
    lines2 = [z for z in lines if z.strip()]
    s2 = ''.join(lines2)
    tokens3 = sc.tokenize(s2)
    
    if 0:
        for kind,val,n in tokens3:
            print('%3s %7s %s' % (n,kind,repr(val)))
    
    # A and B should give the same result: just like abstract algebra diagrams.
    if 0:
        if strip(tokens2) != strip(tokens3):
            sc.compareTokens(tokens2,tokens3,trace=True)
    assert strip(tokens2) == strip(tokens3),'fail2\nexpected:\n%s\ngot:\n%s' % (
        strip(tokens3),strip(tokens2))
    
    # C: Removing blank tokens from already-compressed tokens should have no effect.
    tokens4 = sc.removeBlankLinesTokens(tokens3)
    assert tokens4 == tokens3,'fail3'
</t>
<t tx="ekr.20111105221757.3831">files = ('x.h','x.cpp')

while p.hasChildren():
    p.firstChild().doDelete()

try:
    current = c.importCommands.createImportParent(c.p,files)
    assert current
    assert current.h == 'x'
    assert p.firstChild() == current
finally:
    while p.hasChildren():
        p.firstChild().doDelete()
    c.redraw()
</t>
<t tx="ekr.20111107102431.3849"># A good test, but we don't want this large a file included in the distro.

# fn = r'c:\recent\data4.html'
fn = r'c:\recent\data.html'

root = p.copy()

# Fails with more tags: a newline gets inserted between tags.

html_tags = ('body','head','html','table','xxx',)
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

try:
    c.importCommands.importFilesCommand(files=[fn],treeType='@file')
finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete()
        c.redraw()
    assert not root.hasChildren()

fail = g.app.unitTestDict.get('fail')
assert not fail
</t>
<t tx="ekr.20111109143012.3839">@language html
    # Essential for the unit test.
    
# This part of the test file caused lots of problems.

s = '''

&lt;html&gt;

&lt;body&gt;

&lt;table id="0"&gt;
&lt;tr valign="top"&gt;
&lt;td width="619"&gt;
	&lt;table id="2"&gt;	&lt;tr valign="top"&gt;	&lt;td width="377"&gt;
		&lt;table id="3"&gt;
		&lt;tr&gt;
		&lt;td width="368"&gt;
			&lt;table id="4"&gt;

&lt;tbody id="5"&gt;

&lt;tr valign="top"&gt;
&lt;td width="550"&gt;
&lt;table id="6"&gt;

&lt;tbody id="6"&gt;
&lt;tr&gt;

&lt;td class="blutopgrabot"&gt;&lt;a href="href1"&gt;Listing Standards&lt;/a&gt; | &lt;a href="href2"&gt;Fees&lt;/a&gt; | &lt;strong&gt;Non-compliant Issuers&lt;/strong&gt; | &lt;a href="href3"&gt;Form 25 Filings&lt;/a&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;

&lt;/table&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;
&lt;td width="100%" colspan="2"&gt;


&lt;br /&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;	
							&lt;/td&gt;
						&lt;/tr&gt;
						&lt;/table&gt;

	&lt;!-- View First part --&gt;	&lt;/td&gt;	&lt;td width="242"&gt;	&lt;!-- View Second part --&gt;

	&lt;!-- View Second part --&gt;	&lt;/td&gt;	&lt;/tr&gt;&lt;/table&gt;										


&lt;DIV class="webonly"&gt;

&lt;script src="/scripts/footer.js"&gt;&lt;/script&gt;
	
&lt;/DIV&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;script language="JavaScript1.1"&gt;var SA_ID="nyse;nyse";&lt;/script&gt;
&lt;script language="JavaScript1.1" src="/scripts/stats/track.js"&gt;&lt;/script&gt;
&lt;noscript&gt;&lt;img src="/scripts/stats/track.js" height="1" width="1" alt="" border="0"&gt;&lt;/noscript&gt;
&lt;/body&gt;
&lt;/html&gt;

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111110095252.3845">import leo.core.leoImport as leoImport

ic = c.importCommands
bs = leoImport.BaseScanner(ic,atAuto=True,language='html')

&lt;&lt; define tokens &gt;&gt;

table = (
    (tokens11,tokens12),
    (tokens21,tokens22),
)

for tokens1,tokens2 in table:
    bs.compareTokens(tokens1,tokens2)
</t>
<t tx="ekr.20111110095252.3846">@ 2011/11/10:

File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2074, in scanAndCompare
n1,n2,ok = self.compareTokens(tokens1,tokens2)
File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2094, in compareTokens
else:      kind1,val1 = 'eof','',n1
ValueError: too many values to unpack
@c

tokens11 = ()
tokens12 = (('id','abc',0),)

# Test similar situation, reversed.

tokens21 = (('id','abc',0),)
tokens22 = ()
</t>
<t tx="ekr.20111111074026.3972">import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)

table = (
    # Yes, both single and double quotes are valid in html.
    (hs.skipComment, '&lt;!-- comment --&gt; after',  '&lt;!-- comment --&gt;'),
    (hs.skipComment, '&lt;!-- a\nb --&gt; after',     '&lt;!-- a\nb --&gt;'),
    (hs.skipId,      'abc&gt;',                    'abc'),
    (hs.skipId,      'abc"',                    'abc'),
    (hs.skipId,      'abc&lt;!--',                 'abc'),
    (hs.skipId,      'a.b-c9:d after',          'a.b-c9:d'),
    (hs.skipString,  '"a string" after',        '"a string"'),
    (hs.skipString,  "'a string2' after",       "'a string2'"),
    (hs.skipString,  "'a string&lt;'&gt;",            "'a string&lt;'"),
    (hs.skipString,  "'a string&gt;'&lt;",            "'a string&gt;'"),
)

for func,s,expected in table:
    
    i = func(s,0)
    result = s[0:i]
    assert result == expected,'expected %s got %s' % (
        repr(expected),repr(result))
</t>
<t tx="ekr.20111112092813.4154">g.cls()</t>
<t tx="ekr.20111112093605.4679"># run-marked-unit-tests-externally = Alt-4 # Standard binding, unchanged.
# run-selected-unit-tests-externally = Alt-5 # Standard binding, unchanged.
# run-selected-unit-tests-locally = Alt-6

# From stc.leo.
run-selected-unit-tests-locally = Alt-4
run-marked-unit-tests-locally = Alt-5
# run-all-unit-tests-locally = Alt-6
do-nothing = Alt-6
</t>
<t tx="ekr.20111112103320.3849">s = '''\
&lt;body&gt;

&lt;!-- OOPS: the div and p elements not properly nested.--&gt;
&lt;!-- OOPS: this table got generated twice. --&gt;

&lt;p id="P1"&gt;
&lt;div id="D666"&gt;Paragraph&lt;/p&gt; &lt;!-- P1 --&gt;
&lt;p id="P2"&gt;

&lt;TABLE id="T666"&gt;&lt;/TABLE&gt;&lt;/p&gt; &lt;!-- P2 --&gt;
&lt;/div&gt;
&lt;/p&gt; &lt;!-- orphan --&gt;

&lt;/body&gt;
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111112103320.3887">s = '''\
&lt;html&gt;

&lt;head&gt;
    &lt;!-- oops: link elements terminated two different ways --&gt;
    &lt;link id="L1"&gt;
    &lt;link id="L2"&gt;
    &lt;link id="L3" /&gt;
    &lt;link id='L4' /&gt;
    
    &lt;title&gt;TITLE&lt;/title&gt;
    
&lt;!-- oops: missing tags. --&gt;
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111112103320.3893">s = '''\
&lt;html&gt;
&lt;head&gt;
    &lt;!-- oops: link elements terminated two different ways --&gt;
    &lt;link id="L1"&gt;
    &lt;link id="L2"&gt;
    &lt;link id="L3" /&gt;
    &lt;link id='L4' /&gt;
    
    &lt;title&gt;TITLE&lt;/title&gt;
    
&lt;/head&gt;
&lt;html&gt;
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111115080347.3872"></t>
<t tx="ekr.20111123042627.6654"># Leo loads plugins in the order they appear here.

# **Important**: to change these defaults, put
# an @enabled-plugins node in myLeoSettings.leo.

# Highly-recommended plugins:
plugins_menu.py
free_layout.py # needs to be early
viewrendered.py

# Recommended plugins:
contextmenu.py
# leo_to_html.py
mod_scripting.py
# nav_qt.py
# quicksearch.py
# stickynotes.py
# todo.py
</t>
<t tx="ekr.20111124094121.3941"># These exist for a unit test.</t>
<t tx="ekr.20111124094121.3942"></t>
<t tx="ekr.20111124094121.3943"></t>
<t tx="ekr.20111125182408.3947">def setup():
    while p.hasChildren():
        p.firstChild().doDelete()

setup()

try:
    files = (r'a\b.c',r'a\b.h',)
    c.importCommands.createImportParent(p,files)
    child = p.firstChild()
    assert child
    assert child.h == 'a/b',child.h
finally:
    setup()</t>
<t tx="ekr.20111125183140.3952">child = p.firstChild()
def setup():
    while p.hasChildren():
        p.firstChild().doDelete()

setup()
try:
    c.importCommands.createOutline(
        fileName=r'a\b\c.xyzzy',
        parent=p,
        atAuto=False,atShadow=False,
        s='test body',
        ext='xyzzy'
    )
    child = p.firstChild()
    assert child
    h = g.os_path_finalize_join(g.app.loadDir,'..','test','a','b','c.xyzzy')
    h = h.replace('\\','/')
    h = '@file ' + h
    # C: vs c: is not relevant here.
    assert child.h.lower() == h.lower(),child.h
finally:
    setup()</t>
<t tx="ekr.20111211094936.3970"></t>
<t tx="ekr.20111214100515.3921">ic = c.importCommands

def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

fn = g.os_path_finalize_join(g.app.loadDir,'..','test','unittest','at-auto-section-ref-test.py')
# fn = r'c:\Users\edreamleo\at-auto-test.py'
assert g.os_path_exists(fn),fn

try:
    setup(p)
    child = p.insertAsNthChild(0)
    child.h = 'child'
    assert child

    ic.errors = 0
    ic.createOutline (fn,parent=child,atAuto=True,atShadow=False,s=None,ext=None)
    assert ic.errors == 0
finally:
    setup(p)
    c.redraw(p)
</t>
<t tx="ekr.20111228125719.3909">import leo.core.leoImport as leoImport

def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

importCommands = c.importCommands
bic = leoImport.BaseScanner(importCommands,atAuto=False,language='python')

try:
    setup(p)
    child = p.insertAsLastChild()
    child.h = 'child'
    bic.insertIgnoreDirective(parent=child)
    assert child.b.find('@ignore') == 0
finally:
    if 1:
        setup(p)
</t>
<t tx="ekr.20120229082711.3934">@language python
@tabwidth -4

# Begin

@others

# End
</t>
<t tx="ekr.20120229082711.3935"># node 1 text A.
</t>
<t tx="ekr.20120229082711.3936"># node 2 text B.
</t>
<t tx="ekr.20120306173116.3933">@first # -*- coding: utf-8 -*-

s = '''\
&lt;:.&gt;
&lt;&gt;
&lt;_.&gt;
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.xmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20121011094154.3906">@language python
</t>
<t tx="ekr.20121011094154.3911">s = '''

class Greeter {
    greeting: string;
    constructor (message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

var greeter = new Greeter("world");

var button = document.createElement('button')
button.innerText = "Say Hello"
button.onclick = function() {
    alert(greeter.greet())
}

document.body.appendChild(button)

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.typeScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20121011100210.4035">s = '''

module Sayings {
    export class Greeter {
        greeting: string;
        constructor (message: string) {
            this.greeting = message;
        }
        greet() {
            return "Hello, " + this.greeting;
        }
    }
}
var greeter = new Sayings.Greeter("world");

var button = document.createElement('button')
button.innerText = "Say Hello"
button.onclick = function() {
	alert(greeter.greet())
}

document.body.appendChild(button)


'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.typeScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20131111155830.4249"></t>
<t tx="ekr.20131111155830.4250"># Not yet...

    &lt;BS&gt;        delete the character in front of the cursor
N   &lt;Del&gt;       delete N characters under and after the cursor
    &lt;Del&gt;       delete the character under the cursor
    &lt;Del&gt;       while entering a count: delete last character
    &lt;Down&gt;      recall newer command-line that starts with current command
    &lt;Esc&gt;       abandon command-line (if 'wildchar' is &lt;Esc&gt;, type it twice)
    &lt;Left&gt;      (motion) cursor left
    &lt;Right&gt;     (motion) cursor right
    &lt;S-Down&gt;    recall newer command-line from history
    &lt;S-Left&gt;    (motion) cursor one word left
    &lt;S-Right&gt;   (motion) cursor one word right
    &lt;S-Up&gt;      recall older command-line from history
    &lt;Up&gt;        recall older command-line that starts with current command

N   CTRL-^                  Edit alternate file N (equivalent to ":e #N").
N   CTRL-A                  add N to the number at or after the cursor
N   CTRL-B                  window N pages Backwards (upwards)
    CTRL-B                  (motion?) cursor to beginning of command-line
    CTRL-BREAK              MS-DOS: during searches: interrupt the search
    CTRL-C                  during searches: interrupt the search
N   CTRL-D                  window N lines Downwards (default: 1/2 window)
N   CTRL-E                  window N lines downwards (default: 1)
    CTRL-E                  (motion?) cursor to end of command-line
N   CTRL-F                  (motion) window N pages Forwards (downwards)
    CTRL-G                  show current file name (with path) and cursor position
N   CTRL-I                  (motion) go to Nth newer position in jump list
    CTRL-K {char1} {char2}  enter digraph
    CTRL-L                  Clear and redraw the screen.
N   CTRL-O                  (motion) go to Nth older position in jump list
N   CTRL-R                  redo last N undone changes
    CTRL-R &lt;0-9a-z"%:-&gt;     insert contents of register &lt;0-9a-z"%:-&gt;
N   CTRL-T                  (motion) Jump back from Nth older tag in tag list
N   CTRL-U                  window N lines Upwards (default: 1/2 window)
    CTRL-U                  remove all characters
    CTRL-V                  highlight blockwise or stop highlighting
    CTRL-V                  start highlighting blockwise   }  highlighted text
    CTRL-V {char}           insert {char} literally
    CTRL-V {number}         enter decimal value of character (up to three digits)
    CTRL-W                  delete the word in front of the cursor
    CTRL-W +                Increase current window height
    CTRL-W -                Decrease current window height
    CTRL-W =                Make all windows equal height
    CTRL-W CTRL-W           Move cursor to window below (wrap)
    CTRL-W CTRL-^           Split window and edit alternate file
    CTRL-W R                Rotate windows upwards
    CTRL-W W                Move cursor to window above (wrap)
    CTRL-W ]                Split window and jump to tag under cursor
    CTRL-W _                Set current window height (default: very high)
    CTRL-W b                Move cursor to bottom window
    CTRL-W c  or :cl[ose]   Make buffer hidden and close window
    CTRL-W f                Split window and edit file name under the cursor
    CTRL-W j                Move cursor to window below
    CTRL-W k                Move cursor to window above
    CTRL-W n  or :new       Create new empty window
    CTRL-W o  or :on[ly]    Make current window only one on the screen
    CTRL-W p                Move cursor to previous active window
    CTRL-W q  or :q[uit]    Quit editing and close window
    CTRL-W r                Rotate windows downwards
    CTRL-W s                Split window into two parts
    CTRL-W t                Move cursor to top window
    CTRL-W x                Exchange current window with next one
N   CTRL-X                  subtract N from the number at or after the cursor
N   CTRL-Y                  window N lines upwards (default: 1)
    CTRL-Z                  Same as ":stop!"
    CTRL-]                  Jump to the tag under cursor, unless changes have been made</t>
<t tx="ekr.20131111155830.4251">char F
char T
char f
char r
char t
letter m
letter q
motion &lt;
motion &gt;
motion c
motion d
motion gU
motion gq
motion gu
motion g~
motion y
pattern /
pattern ?
register @
</t>
<t tx="ekr.20131111155830.4252"># http://tnerual.eriogerg.free.fr/vimqrc.html
vim_0 0
vim_tilda ~
vim_plus +
vim_underscore _
vim_minus -
vim_comma ,
vim_dot .
vim_semicolon ;
vim_lparen (
vim_rparen )
vim_lcurly {
vim_rcurly }
vim_vertical |
vim_backtick `
vim_dollar $
vim_caret ^
vim_percent %
vim_langle &lt;
vim_langle &lt;&lt;
vim_rangle &gt;
vim_rangle &gt;&gt;
vim_pound #
vim_star *
vim_slash /\\n
vim_slash /
vim_question ?\\n
vim_question ?
vim_at @
vim_at @@
vim_dquote "
vim_lsquare [#
vim_lsquare [(
vim_lsquare [*
vim_lsquare [[
vim_lsquare []
vim_lsquare [p
vim_lsquare [{
vim_rsquare ]#
vim_rsquare ])
vim_rsquare ]*
vim_rsquare ][
vim_rsquare ]]
vim_rsquare ]p
vim_rsquare ]}
vim_A A
vim_B B
vim_C C
vim_D D
vim_E E
vim_F F
vim_G G
vim_H H
vim_I I
vim_J J
vim_K K
vim_M M
vim_L L
vim_N N
vim_O O
vim_P P
vim_R R
vim_S S
vim_T T
vim_U U
vim_V V
vim_W W
vim_X X
vim_Y Y
vim_Z ZQ
vim_Z ZZ
vim_a a
vim_b b
vim_c c
vim_d dd
vim_d d
vim_g g~
vim_g g^
vim_g g#
vim_g g$
vim_g g*
vim_g g0
vim_g gD
vim_g gE
vim_g gI
vim_g gU
vim_g ga
vim_g gd
vim_g ge
vim_g gf
vim_g gg
vim_g gj
vim_g gk
vim_g gq
vim_g gs
vim_g gu
vim_g gv
vim_h h
vim_i i
vim_j j
vim_k k
vim_l l
vim_n n
vim_m m
vim_o o
vim_p p
vim_q q
vim_r r
vim_s s
vim_t t
vim_u u
vim_v v
vim_w w
vim_x x
vim_y y
vim_y yy
vim_z z-
vim_z z.
vim_z z&lt;CR&gt;
vim_z zb
vim_z zh
vim_z zl
vim_z zt
vim_z zz
</t>
<t tx="ekr.20131111155830.4253"># CR
# Ctrl-End
# Ctrl-Home
# Ctrl-Left
# Ctrl-M
# Ctrl-N
# Ctrl-P
# Ctrl-Right
# End
# Home
# Shift-Left
# Shift-Right

( 	
)
{
}
[[
[]
][
]]
$
^	
+
,
-
;
_
0
B
E
F
G
T
W
b
e
f
g$
g^
g0
gE
# gEnd
# gHome	
ge
gg
h
j
k
t
w
</t>
<t tx="ekr.20131111155830.4254">char F
char T
char f
char t
</t>
<t tx="ekr.20140103103143.4095"></t>
<t tx="ekr.20140206132559.4560">class aClass:
    def __init__(self):
        pass
    def spam(self):
        pass
bClass = aClass</t>
<t tx="ekr.20140206132559.4564">class aClass:
    @others
bClass = aClass</t>
<t tx="ekr.20140206132559.4565">def __init__(self):
    pass
</t>
<t tx="ekr.20140206132559.4566">def spam(self):
    pass
</t>
<t tx="ekr.20140206132559.4567">tm = c.testManager
before   = g.findNodeInTree(c,p,'before')
expected = g.findNodeInTree(c,p,'expecterd')
assert before,expected
try:
    c.selectPosition(before)
    c.importCommands.parseBody()
    # compare tree.
    tm.compareOutlines(before,expected,compareHeadlines=True,tag='',report=True)
    c.undoer.undo()
finally:
    c.redraw()
</t>
<t tx="ekr.20140217055617.4231"># For a unit test.</t>
<t tx="ekr.20140218042220.4347">s = '''\

var c3 = (function () {
    "use strict";

    // Globals
    var c3 = { version: "0.0.1"   };

    c3.someFunction = function () {
        console.log("Just a demo...");
    };

    return c3;
}());

'''

g.app.unitTestDict ['expectedErrors'] = 0
c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20140218045755.4348">@language python
@tabwidth -4

def not_a_sentinel(x):
    pass
@not_a_sentinel
def spam():
    pass

# s1 = ''.join([z for z in g.splitLines(p.b) if not z.startswith('@language')])
s1 = ''.join(g.splitLines(p.b)[2:])
s2 = p.nosentinels   
assert s1 == s2,'expected:\n%s\ngot:\n%s' % (s1,s2)
</t>
</tnodes>
</leo_file>
