<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070417092935"><vh>Startup</vh>
<v t="ekr.20041121151002"><vh>@settings</vh>
<v t="ekr.20080324133327.2"><vh>@bool allow_middle_button_paste = True</vh></v>
<v t="ekr.20161011095551.1"><vh>@bool allow_section_references_in_at_auto = True</vh></v>
<v t="ekr.20101009105124.6195"><vh>@bool put_expansion_bits_in_leo_files = True</vh></v>
<v t="ekr.20140902101931.4478"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20161129030232.1"><vh>@bool run-pyflakes-on-write = False</vh></v>
<v t="ekr.20140217055617.4231"><vh>@bool scriptingatscriptnodes = True</vh></v>
<v t="ekr.20051013162226"><vh>@bool test_setting = True</vh></v>
<v t="ekr.20150602215639.1"><vh>@bool tidy_autobeautify = False</vh></v>
<v t="ekr.20070503064257"><vh>@bool use_chapters = True</vh></v>
<v t="ekr.20150321155210.11"><vh>@bool verbose_check_outline = False</vh></v>
<v t="ekr.20070528100318"><vh>@bool write_strips_blank_lines = False</vh></v>
<v t="ekr.20111026111009.3972"><vh>@data import_xml_tags</vh></v>
<v t="ekr.20111123042627.6654"><vh>@enabled-plugins</vh></v>
<v t="ekr.20050328101834"><vh>@page http plugin</vh>
<v t="ekr.20050328101834.1"><vh>@bool http_active = False</vh></v>
<v t="ekr.20050328101834.2"><vh>@int  port = 8080</vh></v>
<v t="ekr.20050328101834.3"><vh>@string rst_http_attributename = ''</vh></v>
</v>
<v t="ekr.20111112093605.4679"><vh>@shortcuts</vh></v>
<v t="ekr.20110521073115.3494"><vh>colorizer colors</vh>
<v t="ekr.20110521073115.3495"><vh>@@color keyword3_color = orange</vh></v>
<v t="ekr.20110521073115.3496"><vh>@@color keyword4_color = pink</vh></v>
</v>
<v t="ekr.20111124094121.3941"><vh>Empty @buttons and @commands nodes</vh>
<v t="ekr.20111124094121.3942"><vh>@buttons</vh></v>
<v t="ekr.20111124094121.3943"><vh>@commands</vh></v>
</v>
<v t="ekr.20131111155830.4249"><vh>Vim settings</vh>
<v t="ekr.20131111155830.4250"><vh>@@@data vim-control-character-commands</vh></v>
<v t="ekr.20131111155830.4251"><vh>@data vim-command-tails</vh></v>
<v t="ekr.20131111155830.4252"><vh>@data vim-commands</vh></v>
<v t="ekr.20131111155830.4253"><vh>@data vim-motions</vh></v>
<v t="ekr.20131111155830.4254"><vh>@data vim-motion-tails</vh></v>
</v>
</v>
<v t="ekr.20150216110251.11"><vh>@persistence</vh>
<v t="edward.20150612083734.1"><vh>@data:#@auto</vh></v>
<v t="edward.20150612083734.2"><vh>@data:#@auto</vh>
<v t="edward.20150612083734.3"><vh>@gnxs</vh></v>
</v>
<v t="edward.20150612083734.4"><vh>@data:#@auto</vh></v>
<v t="edward.20150612083734.5"><vh>@data:#@auto</vh>
<v t="edward.20150612083734.6"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150625052701.1"><vh>@data:@auto unittest/at-auto-line-number-test.py</vh>
<v t="ekr.20150625134618.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150625091937.3"><vh>@data:@auto ../test/at-auto-unit-test.py</vh>
<v t="ekr.20161231115551.4"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150626093952.1"><vh>@data:@auto-rst unittest/at-auto-rst-line-number-test.py</vh>
<v t="ekr.20161205045751.3"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150626100832.1"><vh>@data:@auto-otl unittest/at-auto-otl-line-number-test.py</vh>
<v t="ekr.20161231115549.10"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150626101730.1"><vh>@data:@auto-org unittest/at-auto-org-line-number-test.py</vh>
<v t="ekr.20161231115549.3"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150626102601.1"><vh>@data:@auto unittest/at-auto-md-line-number-test.md</vh>
<v t="ekr.20161231115548.6"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20160403143348.1"><vh>@data:@auto unittest/at-auto-section-ref-test.py</vh>
<v t="ekr.20160403143348.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20160403143351.1"><vh>@data:@auto unittest/at-auto-test.py</vh>
<v t="ekr.20160403143351.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20160917122402.1"><vh>@data:#@auto</vh></v>
<v t="ekr.20160917122402.2"><vh>@data:#@auto</vh>
<v t="ekr.20160917122402.3"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20160917122402.4"><vh>@data:#@auto</vh></v>
<v t="ekr.20160917122402.5"><vh>@data:#@auto</vh>
<v t="ekr.20160917122402.6"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161124021953.210"><vh>@data:#@auto</vh></v>
<v t="ekr.20161124021953.211"><vh>@data:#@auto</vh>
<v t="ekr.20161124021953.212"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161124021953.213"><vh>@data:#@auto</vh></v>
<v t="ekr.20161124021953.214"><vh>@data:#@auto</vh>
<v t="ekr.20161124021953.215"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161130053017.1"><vh>@data:@auto-ctext unittest/at-auto-ctext-test.txt</vh>
<v t="ekr.20161205045751.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161204034537.1"><vh>@data:@auto-rst unittest/at-auto-rst-line-number-test.py</vh>
<v t="ekr.20161205045751.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161221063636.208"><vh>@data:#@auto</vh></v>
<v t="ekr.20161221063636.209"><vh>@data:#@auto</vh>
<v t="ekr.20161221063636.210"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161221063636.211"><vh>@data:#@auto</vh></v>
<v t="ekr.20161221063636.212"><vh>@data:#@auto</vh>
<v t="ekr.20161221063636.213"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161221065120.206"><vh>@data:#@auto</vh></v>
<v t="ekr.20161221065120.207"><vh>@data:#@auto</vh>
<v t="ekr.20161221065120.208"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161221065120.209"><vh>@data:#@auto</vh></v>
<v t="ekr.20161221065120.210"><vh>@data:#@auto</vh>
<v t="ekr.20161221065120.211"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161221092134.208"><vh>@data:#@auto</vh></v>
<v t="ekr.20161221092134.209"><vh>@data:#@auto</vh>
<v t="ekr.20161221092134.210"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161221092134.211"><vh>@data:#@auto</vh></v>
<v t="ekr.20161221092134.212"><vh>@data:#@auto</vh>
<v t="ekr.20161221092134.213"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161222123640.208"><vh>@data:#@auto</vh></v>
<v t="ekr.20161222123640.209"><vh>@data:#@auto</vh>
<v t="ekr.20161222123640.210"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161222123640.211"><vh>@data:#@auto</vh></v>
<v t="ekr.20161222123640.212"><vh>@data:#@auto</vh>
<v t="ekr.20161222123640.213"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161223153752.1"><vh>@data:#@auto</vh></v>
<v t="ekr.20161223153752.2"><vh>@data:#@auto</vh>
<v t="ekr.20161223153752.3"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161223153752.4"><vh>@data:#@auto</vh></v>
<v t="ekr.20161223153752.5"><vh>@data:#@auto</vh>
<v t="ekr.20161223153752.6"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161228071942.1"><vh>@data:@auto c:\test\bug-354-test.py</vh>
<v t="ekr.20161228071942.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161231115527.208"><vh>@data:#@auto</vh></v>
<v t="ekr.20161231115527.209"><vh>@data:#@auto</vh>
<v t="ekr.20161231115527.210"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20161231115527.211"><vh>@data:#@auto</vh></v>
<v t="ekr.20161231115527.212"><vh>@data:#@auto</vh>
<v t="ekr.20161231115527.213"><vh>@gnxs</vh></v>
</v>
</v>
<v t="ekr.20101220161557.6011"><vh>@file unitTestStartup.txt</vh></v>
<v t="ekr.20111112092813.4154"><vh>@command cls</vh></v>
<v t="ekr.20140716121225.4354"><vh>@@button print-gnx</vh></v>
<v t="ekr.20100123172713.5114"><vh>Scripts</vh>
<v t="ekr.20100102164959.5088"><vh>Count pages</vh></v>
<v t="ekr.20100123172713.5116"><vh>Clean all tnodeLists</vh></v>
<v t="ekr.20070217065840"><vh>Scripts that make unit tests</vh>
<v t="ekr.20070217065840.1"><vh>@@command make-test @key = Alt-5</vh></v>
<v t="ekr.20070217065840.2"><vh>@@command do-before @key = Alt-6</vh>
<v t="ekr.20070217065840.3"><vh>getSel</vh></v>
<v t="ekr.20070217065840.4"><vh>findNodes</vh></v>
<v t="ekr.20070217065840.5"><vh>putSelectionInHeadline</vh></v>
</v>
<v t="ekr.20070217065840.6"><vh>@@command do-after @key = Alt-7</vh>
<v t="ekr.20070217072822"><vh>getSel</vh></v>
<v t="ekr.20070217065840.8"><vh>findNodes</vh></v>
<v t="ekr.20070217065840.9"><vh>putSelectionInHeadline</vh></v>
</v>
</v>
<v t="ekr.20070113145100"><vh>Create chinese folder</vh></v>
<v t="ekr.20071113140035"><vh>Find unique @ test nodes</vh></v>
<v t="ekr.20091206090247.5060"><vh>Clear all uA's, tnodeLists, etc.</vh>
<v t="ekr.20091206090247.5061"><vh>Clean unused tnodeLists</vh></v>
<v t="ekr.20091206090247.5062"><vh>Clear all timestamps</vh></v>
<v t="ekr.20091206090247.5063"><vh>Clear all uAs (unknown attributes)</vh></v>
</v>
</v>
</v>
<v t="ekr.20111123042627.6654"></v>
<v t="ekr.20111112093605.4679"></v>
<v t="ekr.20161123080832.1"><vh>@button make-table</vh></v>
<v t="ekr.20051012104957"><vh>@ignore Docs</vh>
<v t="bwmulder.20050108100437.1"><vh>How to run unit tests</vh></v>
<v t="ekr.20050618061835"><vh>How to use the @test directive, by Roger Erens</vh>
<v t="ekr.20050618061835.1"><vh>Intro</vh>
<v t="ekr.20050618061835.2"><vh>@url http://www.onlamp.com/pub/a/python/2005/02/03/tdd_pyunit2.html</vh></v>
</v>
<v t="ekr.20050618061835.3"><vh>Preparations: adding a button</vh>
<v t="ekr.20050618061835.4"><vh>@@button Do @test</vh></v>
</v>
<v t="ekr.20050618061835.5"><vh>Alpha</vh>
<v t="ekr.20050618061835.6"><vh>@test my first Leo test</vh></v>
<v t="ekr.20050618061835.7"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.8"><vh>Bravo</vh>
<v t="ekr.20050618061835.9"><vh>@@test my second Leo test</vh></v>
<v t="ekr.20050618061835.10"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.11"><vh>It takes two to tango</vh>
<v t="ekr.20050618061835.6"></v>
<v t="ekr.20050618061835.9"></v>
<v t="ekr.20050618061835.12"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.13"><vh>Life gets more interesting</vh>
<v t="ekr.20050618061835.14"><vh>@@test koekiemonster.wants()</vh>
<v t="ekr.20050618061835.15"><vh>input data</vh></v>
<v t="ekr.20050618061835.16"><vh>expected result</vh></v>
</v>
<v t="ekr.20050618061835.17"><vh>output on the console</vh></v>
<v t="ekr.20050618061835.18"><vh>output on the console using print statements</vh></v>
</v>
<v t="ekr.20050618061835.19"><vh>How about @suite?</vh></v>
<v t="ekr.20050618061835.20"><vh>Final remarks</vh></v>
</v>
<v t="ekr.20111211094936.3970"><vh>@ignore To do</vh>
<v t="ekr.20111115080347.3872"><vh>To do: tests of the high-level interface</vh>
<v t="ekr.20100131171342.5478"><vh>@@@test that log and body implements high-level interface</vh></v>
</v>
<v t="ekr.20100131171342.5473"><vh>Tk gui tests</vh>
<v t="ekr.20100131171342.5474"><vh>@test leoBody is subset of leoTkBody</vh></v>
<v t="ekr.20100131171342.5475"><vh>@test leoFrame is subset of leoTkFrame</vh></v>
<v t="ekr.20100131171342.5476"><vh>@test leoGui is subset of leoTkGui</vh></v>
<v t="ekr.20100131171342.5477"><vh>@test leoTree is subset of leoTkTree</vh></v>
</v>
<v t="ekr.20111125183140.3952"><vh>@test ic.createOutline changes back-slashes to slashes</vh></v>
<v t="ekr.20111125182408.3947"><vh>@test ic.createImportParent changes back-slashes to slashes</vh></v>
</v>
</v>
<v t="ekr.20071113203234"><vh>Test files</vh>
<v t="ekr.20111214104615.3942"><vh>@@@auto unittest/at-auto-section-ref-test.py</vh>
<v t="ekr.20161011092326.7"><vh>at-auto-section-ref-test declarations</vh></v>
</v>
<v t="ekr.20110615130436.3317"><vh>@@file nonexistent-directory/orphan-bit-test.txt</vh></v>
<v t="ekr.20080907122804.1"><vh>@@shadow unittest/at-shadow-line-number-test.py</vh>
<v t="ekr.20150208213643.15"><vh>spam</vh></v>
<v t="ekr.20150208213643.16"><vh>eggs</vh></v>
</v>
<v t="ekr.20090704085350.5014"><vh>@@shadow unittest/at-shadow-test.py</vh>
<v t="ekr.20150208213643.12"><vh>spam</vh></v>
<v t="ekr.20150208213643.13"><vh>eggs</vh></v>
</v>
<v t="ekr.20111213122041.3930"><vh>@@shadow unittest/at-shadow-unlink-clones.py</vh>
<v t="ekr.20150208213643.18"><vh>Node 1</vh></v>
<v t="ekr.20150208213643.19"><vh>Node 2</vh></v>
</v>
<v t="ekr.20090704085350.5028"><vh>@asis unittest/at-asis-test.py</vh>
<v t="ekr.20090704085350.5029"><vh>spam</vh></v>
<v t="ekr.20090704085350.5030"><vh>eggs</vh></v>
</v>
<v t="ekr.20080904084223.1"><vh>@auto unittest/at-auto-line-number-test.py</vh></v>
<v t="ekr.20150626101842.1"><vh>@auto unittest/at-auto-md-line-number-test.md</vh></v>
<v t="ekr.20090704085350.5056"><vh>@auto unittest/at-auto-test.py</vh></v>
<v t="ekr.20110610122533.3407"><vh>@auto unittest/at-auto-unit-test.py</vh></v>
<v t="ekr.20161130052935.1"><vh>@auto-ctext unittest/at-auto-ctext-test.txt</vh></v>
<v t="ekr.20150626101627.1"><vh>@auto-org unittest/at-auto-org-line-number-test.py</vh></v>
<v t="ekr.20150626100719.1"><vh>@auto-otl unittest/at-auto-otl-line-number-test.py</vh></v>
<v t="ekr.20161130041921.1"><vh>@@@auto-rst unittest/at-auto-rst-line-number-test.py</vh>
<v t="ekr.20161228071435.1"><vh>@nosent c:\test\bug-354-test.py</vh>
<v t="ekr.20161228071822.1"><vh>&lt;&lt; u:1 &gt;&gt;</vh></v>
<v t="ekr.20161228071836.1"><vh>&lt;&lt; ue:1 &gt;&gt;</vh></v>
<v t="ekr.20161228071849.1"><vh>&lt;&lt; u:2 &gt;&gt;</vh></v>
<v t="ekr.20161228071905.1"><vh>&lt;&lt; ue: 2&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20150626093745.1"><vh>@auto-rst unittest/at-auto-rst-line-number-test.txt</vh></v>
<v t="ekr.20160403143048.1"><vh>@clean unittest/at-clean-line-number-test.c</vh>
<v t="ekr.20160403143048.2"><vh>spam</vh></v>
<v t="ekr.20160403150121.1"><vh>eggs</vh></v>
</v>
<v t="ekr.20160403143130.1"><vh>@clean unittest/at-clean-line-number-test.py</vh>
<v t="ekr.20160403150216.1"><vh>spam</vh></v>
<v t="ekr.20160403150222.1"><vh>eggs</vh></v>
</v>
<v t="ekr.20160403123754.1"><vh>@file unittest/at-file-line-number-test.c</vh></v>
<v t="ekr.20080904102243.2"><vh>@file unittest/at-file-line-number-test.py</vh></v>
<v t="ekr.20111021115306.3697"><vh>@file unittest/tex-error.tex</vh></v>
<v t="ekr.20130912092638.4150"><vh>@file unittest/utf-16-test.txt</vh></v>
<v t="ekr.20080907123324.2"><vh>@nosent unittest/at-nosent-line-number-test.py</vh>
<v t="ekr.20080907123324.3"><vh>spam</vh></v>
<v t="ekr.20160403152507.1"><vh>eggs</vh></v>
</v>
<v t="ekr.20090704085350.5034"><vh>@nosent unittest/at-nosent-test.py</vh>
<v t="ekr.20090704085350.5035"><vh>spam</vh></v>
<v t="ekr.20090704085350.5036"><vh>eggs</vh></v>
</v>
<v t="ekr.20100731163237.5782"><vh>@thin unittest/at-thin-html-test.html</vh></v>
<v t="ekr.20080905130723.3"><vh>@thin unittest/at-thin-line-number-test.py</vh></v>
<v t="ekr.20090704085350.5022"><vh>@thin unittest/at-thin-test.py</vh></v>
<v t="ekr.20070627082044.811"><vh>@thin unittest/batchTest.py</vh></v>
<v t="ekr.20070627082044.808"><vh>@thin unittest/errorTest.py</vh></v>
</v>
<v t="ekr.20101220161557.6016"><vh>Active Unit Tests</vh>
<v t="edward.20160314170027.56" descendentVnodeUnknownAttributes="7d7100285808000000302e362e31322e3971017d71025809000000756e69745f7465737471035804000000616263647104735808000000302e362e31362e3371057d71065808000000616e6e6f7461746571077d7108735809000000302e362e31392e343071097d710a58090000006d795f706c7567696e710b580300000076616c710c735808000000302e362e32372e37710d7d710e5808000000616e6e6f74617465710f7d7110735808000000302e362e31382e3771117d71125808000000616e6e6f7461746571137d711473752e"
expanded="ekr.20090529141856.4716,ekr.20090529141856.4717,ekr.20090529141856.4727,ekr.20161108034116.1,ekr.20161123115047.1,ekr.20090529141856.4731,ekr.20111029112647.4099,ekr.20100803234640.5804,ekr.20090529141856.4766,ekr.20090529141856.4774,ekr.20161123202857.1,ekr.20161124040933.1,ekr.20090529141856.4734,ekr.20161103015908.1,ekr.20100219080213.5365,ekr.20121011094154.3906,ekr.20090529141856.4780,ekr.20160410152100.1,ekr.20090529141856.4784,ekr.20161204041557.1,"><vh>@file activeUnitTests.txt</vh></v>
</v>
<v t="ekr.20090529141856.4682"><vh>leoImport</vh>
<v t="ekr.20090529141856.4684"><vh>Export tests</vh>
<v t="ekr.20090529141856.4685"><vh>@suite Export tests</vh></v>
</v>
<v t="ekr.20090529141856.4698"><vh>Import tests</vh>
<v t="ekr.20090529141856.4699"><vh>@suite Import tests</vh></v>
</v>
<v t="ekr.20090529141856.4716" a="E"><vh>Tests of @auto</vh>
<v t="ekr.20090529141856.4783"><vh>@test collapse-all</vh></v>
<v t="ekr.20090529141856.4717" a="E"><vh>C tests</vh>
<v t="ekr.20090529141856.4718"><vh>@test c class 1</vh></v>
<v t="ekr.20090529141856.4719"><vh>@test c class--underindented line</vh></v>
<v t="ekr.20090529141856.4721"><vh>@test c comment follows arg list</vh></v>
<v t="ekr.20090529141856.4722"><vh>@test c comment follows block delim</vh></v>
<v t="ekr.20090529141856.4723"><vh>@test c intermixed blanks and tabs</vh></v>
<v t="ekr.20090529141856.4724"><vh>@test c old-style decl 1</vh></v>
<v t="ekr.20090529141856.4725"><vh>@test c old-style decl 2</vh></v>
<v t="ekr.20090529141856.4726"><vh>@test c extern</vh></v>
</v>
<v t="ekr.20090529141856.4727" a="E"><vh>c# tests</vh>
<v t="ekr.20090529141856.4728"><vh>@test c# namespace indent</vh></v>
<v t="ekr.20090529141856.4729"><vh>@test c# namespace no indent</vh></v>
<v t="ekr.20090529141856.4730"><vh>@@test c# ref card</vh></v>
</v>
<v t="ekr.20161108034116.1" a="E"><vh>coffeescript tests</vh>
<v t="ekr.20161108034138.1"><vh>@test coffeescript-1</vh></v>
<v t="ekr.20161109084732.1"><vh>@test coffeescript-2</vh></v>
<v t="ekr.20161118144658.1"><vh>@test coffeescript-3</vh></v>
</v>
<v t="ekr.20161123115047.1" a="E"><vh>dart tests</vh>
<v t="ekr.20161123120652.1"><vh>@test dart hello world</vh></v>
</v>
<v t="ekr.20090529141856.4731" a="E"><vh>elisp tests</vh>
<v t="ekr.20090529141856.4733"><vh>@test elisp</vh></v>
</v>
<v t="ekr.20111029112647.4099" a="E"><vh>html tests</vh>
<v t="ekr.20111107102431.3849"><vh>@@test html whitespace bug</vh></v>
<v t="ekr.20111029112647.4101"><vh>@test html: lowercase tags</vh></v>
<v t="ekr.20111109143012.3839"><vh>@test html: multiple tags on a line</vh></v>
<v t="ekr.20140218122321.4349"><vh>@test html: multple node starts on a line</vh></v>
<v t="ekr.20111102164107.3975"><vh>@test html: underindented comment</vh></v>
<v t="ekr.20111029120441.3982"><vh>@test html: uppercase tags</vh></v>
<v t="ekr.20111112103320.3849"><vh>@test html: improperly nested tags</vh></v>
<v t="ekr.20111112103320.3887"><vh>@test html: improperly terminated tags</vh></v>
<v t="ekr.20111112103320.3893"><vh>@test html: improperly terminated tags2</vh></v>
</v>
<v t="ekr.20100803234640.5804" a="E"><vh>ini tests</vh>
<v t="ekr.20100803234640.5805"><vh>@test ini-test-1</vh></v>
</v>
<v t="ekr.20090529141856.4766" a="E"><vh>Java tests</vh>
<v t="ekr.20090529141856.4771"><vh>@@test AdminPermission.java</vh></v>
<v t="ekr.20090529141856.4769"><vh>@@test constants.java</vh></v>
<v t="ekr.20090529141856.4770"><vh>@test from AdminPermission.java</vh></v>
<v t="ekr.20090529141856.4773"><vh>@test from BundleException.java</vh></v>
<v t="ekr.20090529141856.4767"><vh>@test java interface test1</vh></v>
<v t="ekr.20090529141856.4768"><vh>@test java interface test2</vh></v>
</v>
<v t="ekr.20090529141856.4774" a="E"><vh>Javascript tests</vh>
<v t="ekr.20090529141856.4775"><vh>Problems</vh></v>
<v t="ekr.20090529141856.4776"><vh>@test Javascript-regex-1</vh></v>
<v t="ekr.20090529141856.4777"><vh>@@test JSON</vh></v>
<v t="ekr.20090529141856.4778"><vh>@test Javascript-3</vh></v>
<v t="ekr.20140218042220.4347"><vh>@test Javascript-4</vh></v>
<v t="ekr.20140218151418.4353"><vh>@test Javascript-5</vh></v>
</v>
<v t="ekr.20161123202857.1" a="E"><vh>org tests</vh>
<v t="ekr.20161123202924.1"><vh>@test org-1</vh></v>
</v>
<v t="ekr.20161124040933.1" a="E"><vh>otl (vim-outline) tests</vh>
<v t="ekr.20161124040933.2"><vh>@test otl-1</vh></v>
</v>
<v t="ekr.20090529141856.4734" a="E"><vh>Pascal tests</vh>
<v t="ekr.20090529141856.4735"><vh>@test pascal-to-delphi interface</vh></v>
</v>
<v t="ekr.20161103015908.1" a="E"><vh>Perl tests</vh>
<v t="ekr.20161103015940.1"><vh>@test perl-1</vh></v>
<v t="ekr.20161103021621.1"><vh>@test perlpod comment</vh></v>
<v t="ekr.20161103021420.1"><vh>@test perl multi-line string</vh></v>
<v t="ekr.20161119031833.1"><vh>@test perl regex-1</vh></v>
<v t="ekr.20161119032623.1"><vh>@test perl regex-2</vh></v>
</v>
<v t="ekr.20100219080213.5365" a="E"><vh>PHP tests</vh>
<v t="ekr.20100219080213.5366"><vh>@test php import class</vh></v>
<v t="ekr.20100219080213.5367"><vh>@test php import conditional class</vh></v>
<v t="ekr.20100219080213.5368"><vh>@test php import classes &amp; functions</vh></v>
<v t="ekr.20161129222003.1"><vh>@test php here doc</vh>
<v t="ekr.20161130042452.50"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161130042452.51"><vh>class foo</vh></v>
</v>
<v t="ekr.20161130050706.29"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161130050706.30"><vh>class foo</vh></v>
</v>
<v t="ekr.20161202053644.21"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161202053644.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20161202083956.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161202083956.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161202093505.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161202093505.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204034138.15"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204034138.16"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204035447.20"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204035447.21"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041306.21"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041306.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041354.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041354.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041426.33"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041426.34"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041641.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041641.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041720.21"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041720.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041755.29"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041755.30"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041842.20"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041842.21"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041902.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041902.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041920.33"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041920.34"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204042116.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204042116.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204042155.7"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204042155.8"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204042301.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204042301.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204042714.33"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204042714.34"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204042739.15"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204042739.16"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204043013.1"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204043013.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204043028.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204043028.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204043342.40"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204043342.41"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204045827.15"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204045827.16"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204045955.21"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204045955.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204154852.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204154852.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204155218.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204155218.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161206135449.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161206135449.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161206165824.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161206165824.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161216141227.1"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161216141227.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20161218104646.1"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161218104646.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20161220185154.21"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161220185154.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221062411.1"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221062411.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221063734.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221063734.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221065216.7"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221065216.8"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221080848.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221080848.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221091453.20"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221091453.21"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221091950.20"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221091950.21"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221092230.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221092230.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161222122038.3"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161222122038.4"><vh>class foo</vh></v>
</v>
<v t="ekr.20161222123534.3"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161222123534.4"><vh>class foo</vh></v>
</v>
<v t="ekr.20161222123751.3"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161222123751.4"><vh>class foo</vh></v>
</v>
<v t="ekr.20161223153848.1"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161223153848.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20161231115630.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161231115630.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20170101085120.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170101085120.26"><vh>class foo</vh></v>
</v>
</v>
</v>
<v t="ekr.20090529141856.4736" a="E"><vh>Python tests</vh>
<v t="ekr.20161204042938.1"><vh>@@test print('end python tests')</vh></v>
<v t="ekr.20161204042916.1"><vh>@@test print('start python tests')</vh></v>
<v t="ekr.20161115092708.1"><vh>@test i.scan_state (for python)</vh></v>
<v t="ekr.20161224145026.1"><vh>@test leoApp fail</vh></v>
<v t="ekr.20161115063144.3"><vh>@test python bad class test</vh></v>
<v t="ekr.20161115063144.34"><vh>@test python basic nesting test</vh></v>
<v t="ekr.20161218103650.1"><vh>@test python bug #346</vh></v>
<v t="ekr.20161228070933.1"><vh>@test python bug #354</vh></v>
<v t="ekr.20161115063144.4"><vh>@test python bug 603720</vh></v>
<v t="ekr.20161115063144.5"><vh>@test python class test 2</vh></v>
<v t="ekr.20161115063144.6"><vh>@test python class tests 1</vh></v>
<v t="ekr.20161115063144.7"><vh>@test python comment after dict assign</vh></v>
<v t="ekr.20161115063144.8"><vh>@test python decls test 1</vh></v>
<v t="ekr.20161115063144.9"><vh>@test python decorator</vh></v>
<v t="ekr.20161224101046.1"><vh>@test python decorator 2</vh></v>
<v t="ekr.20161115063144.10"><vh>@test python def inside def</vh></v>
<v t="ekr.20161115063144.11"><vh>@test python def test 1</vh></v>
<v t="ekr.20161115063144.12"><vh>@test python def test 2</vh></v>
<v t="ekr.20161115063144.13"><vh>@test python docstring only</vh></v>
<v t="ekr.20161115063144.14"><vh>@test python empty decls</vh></v>
<v t="ekr.20161115063144.15"><vh>@test python extra leading ws test</vh></v>
<v t="ekr.20161115063144.16"><vh>@test python indent decls</vh></v>
<v t="ekr.20161117000902.1"><vh>@test python leoImport.py (small)</vh></v>
<v t="ekr.20161115063144.18"><vh>@test python looks like section ref</vh></v>
<v t="ekr.20161115063144.19"><vh>@test python minimal class 1</vh></v>
<v t="ekr.20161115063144.20"><vh>@test python minimal class 2</vh></v>
<v t="ekr.20161115063144.21"><vh>@test python minimal class 3</vh></v>
<v t="ekr.20161115063144.22"><vh>@test python overindent def--no following def</vh></v>
<v t="ekr.20161115063144.23"><vh>@test python overindent def--one following def</vh></v>
<v t="ekr.20161115063144.24"><vh>@test python overindented def 3</vh></v>
<v t="ekr.20161115063144.25"><vh>@test python string test: extra indent</vh></v>
<v t="ekr.20161115063144.26"><vh>@test python string underindent lines</vh></v>
<v t="ekr.20161115063144.27"><vh>@test python string underindent lines 2</vh></v>
<v t="ekr.20161222064421.1"><vh>@test python top-level later decl</vh></v>
<v t="ekr.20161115063144.28"><vh>@test python trailing comment</vh></v>
<v t="ekr.20161115063144.29"><vh>@test python trailing comment--outer levels</vh></v>
<v t="ekr.20161115063144.30"><vh>@test python two functions</vh></v>
<v t="ekr.20161115063144.31"><vh>@test python underindent method</vh></v>
<v t="ekr.20161115063144.32"><vh>@test python unindent in triple string does not end function</vh></v>
<v t="ekr.20161115063144.33"><vh>@test python unittest/perfectImport/formatter.py</vh></v>
</v>
<v t="ekr.20121011094154.3906" a="E"><vh>TypeScript tests</vh>
<v t="ekr.20121011094154.3911"><vh>@test TypeScript class</vh></v>
<v t="ekr.20121011100210.4035"><vh>@test TypeScript module</vh></v>
</v>
<v t="ekr.20090529141856.4780" a="E"><vh>xml tests</vh>
<v t="ekr.20090529141856.4781"><vh>@test xml 1</vh></v>
<v t="ekr.20111026105935.3966"><vh>@test xml 2</vh></v>
<v t="ekr.20120306173116.3933"><vh>@test xml non-ascii tags</vh></v>
</v>
</v>
<v t="ekr.20160410152100.1" a="E"><vh>Tests of @auto-md</vh>
<v t="ekr.20160410152100.2"><vh>@test md-import-test</vh>
<v t="ekr.20160411034540.1"><vh>&lt;&lt; define s &gt;&gt; (md-import-test)</vh></v>
<v t="ekr.20161202093709.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161202093709.2"><vh>!Declarations</vh>
<v t="ekr.20161202093709.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093709.4"><vh>Section 2</vh>
<v t="ekr.20161202093709.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093709.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093709.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093709.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034142.19"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204034142.20"><vh>Top</vh>
<v t="ekr.20161204034142.21"><vh>Section 1</vh></v>
<v t="ekr.20161204034142.22"><vh>Section 2</vh>
<v t="ekr.20161204034142.23"><vh>Section 2.1</vh>
<v t="ekr.20161204034142.24"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034142.25"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034142.26"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034207.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204034207.2"><vh>Top</vh>
<v t="ekr.20161204034207.3"><vh>Section 1</vh></v>
<v t="ekr.20161204034207.4"><vh>Section 2</vh>
<v t="ekr.20161204034207.5"><vh>Section 2.1</vh>
<v t="ekr.20161204034207.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034207.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034207.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204035451.19"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204035451.20"><vh>Top</vh>
<v t="ekr.20161204035451.21"><vh>Section 1</vh></v>
<v t="ekr.20161204035451.22"><vh>Section 2</vh>
<v t="ekr.20161204035451.23"><vh>Section 2.1</vh>
<v t="ekr.20161204035451.24"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204035451.25"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204035451.26"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041310.53"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041310.54"><vh>Top</vh>
<v t="ekr.20161204041310.55"><vh>Section 1</vh></v>
<v t="ekr.20161204041310.56"><vh>Section 2</vh>
<v t="ekr.20161204041310.57"><vh>Section 2.1</vh>
<v t="ekr.20161204041310.58"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041310.59"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041310.60"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041358.103"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041358.104"><vh>Top</vh>
<v t="ekr.20161204041358.105"><vh>Section 1</vh></v>
<v t="ekr.20161204041358.106"><vh>Section 2</vh>
<v t="ekr.20161204041358.107"><vh>Section 2.1</vh>
<v t="ekr.20161204041358.108"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041358.109"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041358.110"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041418.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041418.2"><vh>Top</vh>
<v t="ekr.20161204041418.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041418.4"><vh>Section 2</vh>
<v t="ekr.20161204041418.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041418.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041418.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041418.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041645.103"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041645.104"><vh>Top</vh>
<v t="ekr.20161204041645.105"><vh>Section 1</vh></v>
<v t="ekr.20161204041645.106"><vh>Section 2</vh>
<v t="ekr.20161204041645.107"><vh>Section 2.1</vh>
<v t="ekr.20161204041645.108"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041645.109"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041645.110"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041724.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041724.2"><vh>Top</vh>
<v t="ekr.20161204041724.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041724.4"><vh>Section 2</vh>
<v t="ekr.20161204041724.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041724.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041724.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041724.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041800.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041800.2"><vh>Top</vh>
<v t="ekr.20161204041800.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041800.4"><vh>Section 2</vh>
<v t="ekr.20161204041800.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041800.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041800.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041800.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042305.96"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204042305.97"><vh>Top</vh>
<v t="ekr.20161204042305.98"><vh>Section 1</vh></v>
<v t="ekr.20161204042305.99"><vh>Section 2</vh>
<v t="ekr.20161204042305.100"><vh>Section 2.1</vh>
<v t="ekr.20161204042305.101"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042305.102"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042305.103"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042719.4"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204042719.5"><vh>Top</vh>
<v t="ekr.20161204042719.6"><vh>Section 1</vh></v>
<v t="ekr.20161204042719.7"><vh>Section 2</vh>
<v t="ekr.20161204042719.8"><vh>Section 2.1</vh>
<v t="ekr.20161204042719.9"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042719.10"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042719.11"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042822.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204042822.2"><vh>Top</vh>
<v t="ekr.20161204042822.3"><vh>Section 1</vh></v>
<v t="ekr.20161204042822.4"><vh>Section 2</vh>
<v t="ekr.20161204042822.5"><vh>Section 2.1</vh>
<v t="ekr.20161204042822.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042822.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042822.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043017.19"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204043017.20"><vh>Top</vh>
<v t="ekr.20161204043017.21"><vh>Section 1</vh></v>
<v t="ekr.20161204043017.22"><vh>Section 2</vh>
<v t="ekr.20161204043017.23"><vh>Section 2.1</vh>
<v t="ekr.20161204043017.24"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043017.25"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043017.26"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043032.96"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204043032.97"><vh>Top</vh>
<v t="ekr.20161204043032.98"><vh>Section 1</vh></v>
<v t="ekr.20161204043032.99"><vh>Section 2</vh>
<v t="ekr.20161204043032.100"><vh>Section 2.1</vh>
<v t="ekr.20161204043032.101"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043032.102"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043032.103"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043346.4"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204043346.5"><vh>Top</vh>
<v t="ekr.20161204043346.6"><vh>Section 1</vh></v>
<v t="ekr.20161204043346.7"><vh>Section 2</vh>
<v t="ekr.20161204043346.8"><vh>Section 2.1</vh>
<v t="ekr.20161204043346.9"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043346.10"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043346.11"><vh>Section 3</vh></v>
</v>
</v>
</v>
<v t="ekr.20160411033840.1"><vh>@test md-import-test-rst-style</vh>
<v t="ekr.20161125230415.1"><vh>&lt;&lt; define s &gt;&gt; (md-import-test-rst-style)</vh></v>
<v t="ekr.20161202093319.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093319.2"><vh>Top</vh>
<v t="ekr.20161202093319.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093319.4"><vh>Section 2</vh>
<v t="ekr.20161202093319.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093319.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093319.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093319.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093322.9"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093322.10"><vh>Top</vh>
<v t="ekr.20161202093322.11"><vh>Section 1</vh></v>
<v t="ekr.20161202093322.12"><vh>Section 2</vh>
<v t="ekr.20161202093322.13"><vh>Section 2.1</vh>
<v t="ekr.20161202093322.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093322.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093322.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093409.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093409.2"><vh>Top</vh>
<v t="ekr.20161202093409.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093409.4"><vh>Section 2</vh>
<v t="ekr.20161202093409.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093409.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093409.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093409.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093410.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093410.2"><vh>Top</vh>
<v t="ekr.20161202093410.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093410.4"><vh>Section 2</vh>
<v t="ekr.20161202093410.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093410.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093410.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093410.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093509.22"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093509.23"><vh>Top</vh>
<v t="ekr.20161202093509.24"><vh>Section 1</vh></v>
<v t="ekr.20161202093509.25"><vh>Section 2</vh>
<v t="ekr.20161202093509.26"><vh>Section 2.1</vh>
<v t="ekr.20161202093509.27"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093509.28"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093509.29"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034142.27"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204034142.28"><vh>Top</vh>
<v t="ekr.20161204034142.29"><vh>Section 1</vh></v>
<v t="ekr.20161204034142.30"><vh>Section 2</vh>
<v t="ekr.20161204034142.31"><vh>Section 2.1</vh>
<v t="ekr.20161204034142.32"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034142.33"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034142.34"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034207.9"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204034207.10"><vh>Top</vh>
<v t="ekr.20161204034207.11"><vh>Section 1</vh></v>
<v t="ekr.20161204034207.12"><vh>Section 2</vh>
<v t="ekr.20161204034207.13"><vh>Section 2.1</vh>
<v t="ekr.20161204034207.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034207.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034207.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204035451.27"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204035451.28"><vh>Top</vh>
<v t="ekr.20161204035451.29"><vh>Section 1</vh></v>
<v t="ekr.20161204035451.30"><vh>Section 2</vh>
<v t="ekr.20161204035451.31"><vh>Section 2.1</vh>
<v t="ekr.20161204035451.32"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204035451.33"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204035451.34"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041310.61"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041310.62"><vh>Top</vh>
<v t="ekr.20161204041310.63"><vh>Section 1</vh></v>
<v t="ekr.20161204041310.64"><vh>Section 2</vh>
<v t="ekr.20161204041310.65"><vh>Section 2.1</vh>
<v t="ekr.20161204041310.66"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041310.67"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041310.68"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041359.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041359.2"><vh>Top</vh>
<v t="ekr.20161204041359.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041359.4"><vh>Section 2</vh>
<v t="ekr.20161204041359.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041359.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041359.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041359.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041418.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041418.10"><vh>Top</vh>
<v t="ekr.20161204041418.11"><vh>Section 1</vh></v>
<v t="ekr.20161204041418.12"><vh>Section 2</vh>
<v t="ekr.20161204041418.13"><vh>Section 2.1</vh>
<v t="ekr.20161204041418.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041418.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041418.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041646.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041646.2"><vh>Top</vh>
<v t="ekr.20161204041646.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041646.4"><vh>Section 2</vh>
<v t="ekr.20161204041646.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041646.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041646.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041646.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041724.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041724.10"><vh>Top</vh>
<v t="ekr.20161204041724.11"><vh>Section 1</vh></v>
<v t="ekr.20161204041724.12"><vh>Section 2</vh>
<v t="ekr.20161204041724.13"><vh>Section 2.1</vh>
<v t="ekr.20161204041724.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041724.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041724.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041800.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041800.10"><vh>Top</vh>
<v t="ekr.20161204041800.11"><vh>Section 1</vh></v>
<v t="ekr.20161204041800.12"><vh>Section 2</vh>
<v t="ekr.20161204041800.13"><vh>Section 2.1</vh>
<v t="ekr.20161204041800.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041800.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041800.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042305.104"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204042305.105"><vh>Top</vh>
<v t="ekr.20161204042305.106"><vh>Section 1</vh></v>
<v t="ekr.20161204042305.107"><vh>Section 2</vh>
<v t="ekr.20161204042305.108"><vh>Section 2.1</vh>
<v t="ekr.20161204042305.109"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042305.110"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042305.111"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042719.12"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204042719.13"><vh>Top</vh>
<v t="ekr.20161204042719.14"><vh>Section 1</vh></v>
<v t="ekr.20161204042719.15"><vh>Section 2</vh>
<v t="ekr.20161204042719.16"><vh>Section 2.1</vh>
<v t="ekr.20161204042719.17"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042719.18"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042719.19"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042822.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204042822.10"><vh>Top</vh>
<v t="ekr.20161204042822.11"><vh>Section 1</vh></v>
<v t="ekr.20161204042822.12"><vh>Section 2</vh>
<v t="ekr.20161204042822.13"><vh>Section 2.1</vh>
<v t="ekr.20161204042822.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042822.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042822.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043017.27"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204043017.28"><vh>Top</vh>
<v t="ekr.20161204043017.29"><vh>Section 1</vh></v>
<v t="ekr.20161204043017.30"><vh>Section 2</vh>
<v t="ekr.20161204043017.31"><vh>Section 2.1</vh>
<v t="ekr.20161204043017.32"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043017.33"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043017.34"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043032.104"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204043032.105"><vh>Top</vh>
<v t="ekr.20161204043032.106"><vh>Section 1</vh></v>
<v t="ekr.20161204043032.107"><vh>Section 2</vh>
<v t="ekr.20161204043032.108"><vh>Section 2.1</vh>
<v t="ekr.20161204043032.109"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043032.110"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043032.111"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043346.12"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204043346.13"><vh>Top</vh>
<v t="ekr.20161204043346.14"><vh>Section 1</vh></v>
<v t="ekr.20161204043346.15"><vh>Section 2</vh>
<v t="ekr.20161204043346.16"><vh>Section 2.1</vh>
<v t="ekr.20161204043346.17"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043346.18"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043346.19"><vh>Section 3</vh></v>
</v>
</v>
</v>
<v t="ekr.20161125134815.1"><vh>@test markdown importer-basic</vh></v>
<v t="ekr.20161126111517.1"><vh>@test markdown importer-implicit section</vh></v>
<v t="ekr.20161216141315.1"><vh>@test markdown importer-@@-section-name</vh></v>
<v t="ekr.20161127181028.1"><vh>@test markdown github syntax</vh></v>
</v>
<v t="ekr.20090529141856.4784" a="E"><vh>Tests of @auto-rst</vh>
<v t="ekr.20090529141856.4785"><vh>@test rST import test</vh></v>
<v t="ekr.20140725132959.4593"><vh>@test rST import test: simple</vh></v>
<v t="ekr.20090529141856.4786"><vh>@test rST import test: no double-underlines</vh></v>
<v t="ekr.20090529141856.4787"><vh>@test rST import test: long underlines</vh></v>
<v t="ekr.20090529141856.4788"><vh>@test rST import test: long overlines</vh></v>
<v t="ekr.20090529141856.4789"><vh>@test rST import test: trailing whitespace</vh></v>
<v t="ekr.20161129104243.1"><vh>@test leo_rst</vh></v>
</v>
<v t="ekr.20140724220921.5199"><vh>Tests of individual methods</vh>
<v t="ekr.20111214100515.3921"><vh>@@@test ic.createOutline: at-auto with lines that look like section references</vh></v>
<v t="ekr.20140206132559.4567"><vh>@@@test ic.parse-body</vh>
<v t="ekr.20150919073819.1"><vh>copy</vh></v>
<v t="ekr.20140206132559.4560"><vh>before</vh>
<v t="ekr.20161112061414.1"><vh>class aClass</vh>
<v t="ekr.20161112061414.2"><vh>__init__</vh></v>
<v t="ekr.20161112061414.3"><vh>spam</vh></v>
</v>
<v t="ekr.20161112061414.4"><vh>bClass = aClass</vh></v>
</v>
<v t="ekr.20140206132559.4564"><vh>expected</vh>
<v t="ekr.20150919074321.1"><vh>class aClass</vh>
<v t="ekr.20150919074321.2"><vh>__init__</vh></v>
<v t="ekr.20150919074321.3"><vh>spam</vh></v>
</v>
</v>
</v>
<v t="ekr.20150919074122.1"><vh>@@@test ic.parse-body mypy</vh>
<v t="ekr.20150919074220.1"><vh>copy</vh></v>
<v t="ekr.20150919074132.1"><vh>before</vh>
<v t="ekr.20161112061406.1"><vh>class TypeJoinVisitor</vh></v>
</v>
<v t="ekr.20150919074154.1"><vh>expected</vh>
<v t="ekr.20150919074211.1"><vh>class TypeJoinVisitor</vh>
<v t="ekr.20150919074211.2"><vh>__init__</vh></v>
<v t="ekr.20150919074211.3"><vh>visit_unbound_type</vh></v>
<v t="ekr.20150919074211.4"><vh>visit_union_type</vh></v>
<v t="ekr.20150919074211.5"><vh>visit_error_type</vh></v>
<v t="ekr.20150919074211.6"><vh>visit_type_list</vh></v>
<v t="ekr.20150919074211.7"><vh>visit_any</vh></v>
<v t="ekr.20150919074211.8"><vh>visit_void</vh></v>
<v t="ekr.20150919074211.9"><vh>visit_none_type</vh></v>
<v t="ekr.20150919074211.10"><vh>visit_erased_type</vh></v>
<v t="ekr.20150919074211.11"><vh>visit_type_var</vh></v>
<v t="ekr.20150919074211.12"><vh>visit_instance</vh></v>
<v t="ekr.20150919074211.13"><vh>visit_callable_type</vh></v>
<v t="ekr.20150919074211.14"><vh>visit_overloaded</vh></v>
<v t="ekr.20150919074211.15"><vh>visit_tuple_type</vh></v>
<v t="ekr.20150919074211.16"><vh>join</vh></v>
<v t="ekr.20150919074211.17"><vh>default</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20161204041557.1" a="E"><vh>All other tests</vh>
<v t="ekr.20090529141856.4793"><vh>@@test test imports for modes</vh></v>
<v t="ekr.20140723134017.4464"><vh>@test @auto importers</vh></v>
<v t="ekr.20161109065940.1"><vh>@test Importer.get_leading_indent</vh></v>
<v t="ekr.20161117011147.1"><vh>@test Importer.get_str_lws</vh></v>
<v t="ekr.20161109065949.1"><vh>@test Importer.is_ws_line</vh></v>
<v t="ekr.20161011052016.1"><vh>@test importers.javascript.scan_line</vh></v>
</v>
<v t="ekr.20140724164600.4590"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20161204040924.1"><vh>Failing unit tests</vh>
<v t="ekr.20161103075725.1"><vh>Python failing tests: parse-body</vh>
<v t="ekr.20140206132559.4567"></v>
<v t="ekr.20150919074122.1"></v>
</v>
<v t="ekr.20161130051657.1"><vh>@test ctext</vh></v>
<v t="ekr.20150626093653.1"><vh>@@@test find_file_line: @auto-rst</vh></v>
<v t="ekr.20150626101920.1"><vh>@test find_file_line: @auto-md</vh></v>
<v t="ekr.20161130053149.1"><vh>COPY @auto-ctext unittest/at-auto-ctext-test.txt</vh></v>
<v t="ekr.20161130041921.1"></v>
<v t="ekr.20161228071915.1"><vh>@@auto c:\test\bug-354-test.py</vh>
<v t="ekr.20161228072352.1"><vh>bug-354-test declarations</vh></v>
</v>
</v>
<v t="ekr.20161224111342.1"><vh>@test import all Leo's core files</vh>
<v t="ekr.20170101083204.1"><vh>@@file c:/leo.repo/leo-editor/leo/test/import all Leo's core files</vh>
<v t="ekr.20170101083204.2"><vh>Declarations</vh></v>
<v t="ekr.20170101083204.3"><vh>class ColorizerAPI</vh>
<v t="ekr.20170101083204.4"><vh>__init__</vh></v>
<v t="ekr.20170101083204.5"><vh>colorize</vh></v>
<v t="ekr.20170101083204.6"><vh>kill</vh></v>
<v t="ekr.20170101083204.7"><vh>scanColorDirectives</vh></v>
<v t="ekr.20170101083204.8"><vh>setHighlighter</vh></v>
<v t="ekr.20170101083204.9"><vh>updateSyntaxColorer</vh></v>
<v t="ekr.20170101083204.10"><vh>useSyntaxColoring</vh></v>
<v t="ekr.20170101083204.11"><vh>write_colorizer_cache</vh></v>
</v>
<v t="ekr.20170101083204.12"><vh>class StatusLineAPI</vh>
<v t="ekr.20170101083204.13"><vh>__init__</vh></v>
<v t="ekr.20170101083204.14"><vh>clear</vh></v>
<v t="ekr.20170101083204.15"><vh>disable</vh></v>
<v t="ekr.20170101083204.16"><vh>enable</vh></v>
<v t="ekr.20170101083204.17"><vh>get</vh></v>
<v t="ekr.20170101083204.18"><vh>isEnabled</vh></v>
<v t="ekr.20170101083204.19"><vh>put</vh></v>
<v t="ekr.20170101083204.20"><vh>setFocus</vh></v>
<v t="ekr.20170101083204.21"><vh>update</vh></v>
</v>
<v t="ekr.20170101083204.22"><vh>class TreeAPI</vh>
<v t="ekr.20170101083204.23"><vh>__init__</vh></v>
<v t="ekr.20170101083204.24"><vh>drawIcon</vh></v>
<v t="ekr.20170101083204.25"><vh>editLabel</vh></v>
<v t="ekr.20170101083204.26"><vh>edit_widget</vh></v>
<v t="ekr.20170101083204.27"><vh>redraw</vh></v>
<v t="ekr.20170101083204.28"><vh>redraw_now</vh></v>
<v t="ekr.20170101083204.29"><vh>scrollTo</vh></v>
<v t="ekr.20170101083204.30"><vh>initAfterLoad</vh></v>
<v t="ekr.20170101083204.31"><vh>afterSelectHint</vh></v>
<v t="ekr.20170101083204.32"><vh>beforeSelectHint</vh></v>
<v t="ekr.20170101083204.33"><vh>onHeadChanged</vh></v>
<v t="ekr.20170101083204.34"><vh>redraw_after_contract</vh></v>
<v t="ekr.20170101083204.35"><vh>redraw_after_expand</vh></v>
<v t="ekr.20170101083204.36"><vh>redraw_after_head_changed</vh></v>
<v t="ekr.20170101083204.37"><vh>redraw_after_icons_changed</vh></v>
<v t="ekr.20170101083204.38"><vh>redraw_after_select</vh></v>
<v t="ekr.20170101083204.39"><vh>OnIconCtrlClick</vh></v>
<v t="ekr.20170101083204.40"><vh>editPosition</vh></v>
<v t="ekr.20170101083204.41"><vh>endEditLabel</vh></v>
<v t="ekr.20170101083204.42"><vh>getEditTextDict</vh></v>
<v t="ekr.20170101083204.43"><vh>injectCallbacks</vh></v>
<v t="ekr.20170101083204.44"><vh>onHeadlineKey</vh></v>
<v t="ekr.20170101083204.45"><vh>select</vh></v>
<v t="ekr.20170101083204.46"><vh>setEditPosition</vh></v>
<v t="ekr.20170101083204.47"><vh>updateHead</vh></v>
</v>
<v t="ekr.20170101083204.48"><vh>class WrapperAPI</vh>
<v t="ekr.20170101083204.49"><vh>__init__</vh></v>
<v t="ekr.20170101083204.50"><vh>appendText</vh></v>
<v t="ekr.20170101083204.51"><vh>clipboard_append</vh></v>
<v t="ekr.20170101083204.52"><vh>clipboard_clear</vh></v>
<v t="ekr.20170101083204.53"><vh>delete</vh></v>
<v t="ekr.20170101083204.54"><vh>deleteTextSelection</vh></v>
<v t="ekr.20170101083204.55"><vh>disable</vh></v>
<v t="ekr.20170101083204.56"><vh>enable</vh></v>
<v t="ekr.20170101083204.57"><vh>flashCharacter</vh></v>
<v t="ekr.20170101083204.58"><vh>get</vh></v>
<v t="ekr.20170101083204.59"><vh>getAllText</vh></v>
<v t="ekr.20170101083204.60"><vh>getInsertPoint</vh></v>
<v t="ekr.20170101083204.61"><vh>getSelectedText</vh></v>
<v t="ekr.20170101083204.62"><vh>getSelectionRange</vh></v>
<v t="ekr.20170101083204.63"><vh>getXScrollPosition</vh></v>
<v t="ekr.20170101083204.64"><vh>getYScrollPosition</vh></v>
<v t="ekr.20170101083204.65"><vh>hasSelection</vh></v>
<v t="ekr.20170101083204.66"><vh>insert</vh></v>
<v t="ekr.20170101083204.67"><vh>see</vh></v>
<v t="ekr.20170101083204.68"><vh>seeInsertPoint</vh></v>
<v t="ekr.20170101083204.69"><vh>selectAllText</vh></v>
<v t="ekr.20170101083204.70"><vh>setAllText</vh></v>
<v t="ekr.20170101083204.71"><vh>setFocus</vh></v>
<v t="ekr.20170101083204.72"><vh>setInsertPoint</vh></v>
<v t="ekr.20170101083204.73"><vh>setSelectionRange</vh></v>
<v t="ekr.20170101083204.74"><vh>setXScrollPosition</vh></v>
<v t="ekr.20170101083204.75"><vh>setYScrollPosition</vh></v>
<v t="ekr.20170101083204.76"><vh>tag_configure</vh></v>
<v t="ekr.20170101083204.77"><vh>toPythonIndex</vh></v>
<v t="ekr.20170101083204.78"><vh>toPythonIndexRowCol</vh></v>
</v>
<v t="ekr.20170101083204.79"><vh>class IconBarAPI</vh>
<v t="ekr.20170101083204.80"><vh>__init__</vh></v>
<v t="ekr.20170101083204.81"><vh>add</vh></v>
<v t="ekr.20170101083204.82"><vh>addRow</vh></v>
<v t="ekr.20170101083204.83"><vh>addRowIfNeeded</vh></v>
<v t="ekr.20170101083204.84"><vh>addWidget</vh></v>
<v t="ekr.20170101083204.85"><vh>clear</vh></v>
<v t="ekr.20170101083204.86"><vh>createChaptersIcon</vh></v>
<v t="ekr.20170101083204.87"><vh>deleteButton</vh></v>
<v t="ekr.20170101083204.88"><vh>getNewFrame</vh></v>
<v t="ekr.20170101083204.89"><vh>setCommandForButton</vh></v>
</v>
<v t="ekr.20170101083204.90"><vh>class LeoBody</vh>
<v t="ekr.20170101083204.91"><vh>__init__</vh></v>
<v t="ekr.20170101083204.92"><vh>cmd</vh></v>
<v t="ekr.20170101083204.93"><vh>forceFullRecolor</vh></v>
<v t="ekr.20170101083204.94"><vh>getColorizer</vh></v>
<v t="ekr.20170101083204.95"><vh>updateSyntaxColorer</vh></v>
<v t="ekr.20170101083204.96"><vh>recolor</vh></v>
<v t="ekr.20170101083205.1"><vh>oops</vh></v>
<v t="ekr.20170101083205.2"><vh>createEditorFrame</vh></v>
<v t="ekr.20170101083205.3"><vh>createTextWidget</vh></v>
<v t="ekr.20170101083205.4"><vh>packEditorLabelWidget</vh></v>
<v t="ekr.20170101083205.5"><vh>addEditor</vh></v>
<v t="ekr.20170101083205.7"><vh>assignPositionToEditor</vh></v>
<v t="ekr.20170101083205.8"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20170101083205.10"><vh>deleteEditor</vh></v>
<v t="ekr.20170101083205.11"><vh>findEditorForChapter</vh></v>
<v t="ekr.20170101083205.14"><vh>unselectLabel</vh></v>
<v t="ekr.20170101083205.16"><vh>selectLabel</vh></v>
<v t="ekr.20170101083205.18"><vh>selectEditor</vh></v>
<v t="ekr.20170101083205.21"><vh>selectEditorHelper</vh></v>
<v t="ekr.20170101083205.25"><vh>updateEditors</vh></v>
<v t="ekr.20170101083205.27"><vh>computeLabel</vh></v>
<v t="ekr.20170101083205.29"><vh>createChapterIvar</vh></v>
<v t="ekr.20170101083205.31"><vh>ensurePositionExists</vh></v>
<v t="ekr.20170101083205.34"><vh>deactivateActiveEditor</vh></v>
<v t="ekr.20170101083205.36"><vh>recolorWidget</vh></v>
<v t="ekr.20170101083205.37"><vh>switchToChapter</vh></v>
<v t="ekr.20170101083205.39"><vh>updateInjectedIvars</vh></v>
<v t="ekr.20170101083205.41"><vh>getInsertLines</vh></v>
<v t="ekr.20170101083205.42"><vh>getSelectionAreas</vh></v>
<v t="ekr.20170101083205.43"><vh>getSelectionLines</vh></v>
<v t="ekr.20170101083205.46"><vh>onBodyChanged</vh></v>
<v t="ekr.20170101083205.53"><vh>setSelectionAreas</vh></v>
</v>
<v t="ekr.20170101083205.6"><vh>if self.numberOfEditors == 2:</vh></v>
<v t="ekr.20170101083205.9"><vh>if len(values) &gt; 1:</vh></v>
<v t="ekr.20170101083205.12"><vh>if p:</vh></v>
<v t="ekr.20170101083205.13"><vh>if hasattr(w, 'leo_chapter') and w.leo_chapter == chapter:</vh></v>
<v t="ekr.20170101083205.15"><vh>if hasattr(w, 'leo_label') and w.leo_label:</vh></v>
<v t="ekr.20170101083205.17"><vh>if self.numberOfEditors &gt; 1:</vh></v>
<v t="ekr.20170101083205.19"><vh>if self.selectEditorLockout:</vh></v>
<v t="ekr.20170101083205.20"><vh>if w and w == self.c.frame.body.widget:</vh></v>
<v t="ekr.20170101083205.22"><vh>if not (hasattr(wrapper, 'leo_p') and wrapper.leo_p):</vh></v>
<v t="ekr.20170101083205.23"><vh>if not self.ensurePositionExists(wrapper):</vh></v>
<v t="ekr.20170101083205.24"><vh>if trace:</vh></v>
<v t="ekr.20170101083205.26"><vh>if v and v == p.v and wrapper != c.frame.body.wrapper:</vh></v>
<v t="ekr.20170101083205.28"><vh>if hasattr(w, 'leo_chapter') and w.leo_chapter:</vh></v>
<v t="ekr.20170101083205.30"><vh>if not hasattr(w, 'leo_chapter') or not w.leo_chapter:</vh></v>
<v t="ekr.20170101083205.32"><vh>if c.positionExists(w.leo_p):</vh></v>
<v t="ekr.20170101083205.33"><vh>if p2.v and p2.v == w.leo_v:</vh></v>
<v t="ekr.20170101083205.35"><vh>if w2 != w and w2.leo_active:</vh></v>
<v t="ekr.20170101083205.38"><vh>if hasattr(w, 'leo_chapter') and w.leo_chapter:</vh></v>
<v t="ekr.20170101083205.40"><vh>if cc and use_chapters:</vh></v>
<v t="ekr.20170101083205.44"><vh>if g.app.batchMode:</vh></v>
<v t="ekr.20170101083205.45"><vh>if i == j:</vh></v>
<v t="ekr.20170101083205.47"><vh>if not oldText:</vh></v>
<v t="ekr.20170101083205.48"><vh>if trace:</vh></v>
<v t="ekr.20170101083205.49"><vh>if g.app.unitTesting:</vh></v>
<v t="ekr.20170101083205.50"><vh>if not p.isDirty() and p.setDirty():</vh></v>
<v t="ekr.20170101083205.51"><vh>if not hasattr(p.v, "iconVal") or val != p.v.iconVal:</vh></v>
<v t="ekr.20170101083205.52"><vh>if redraw_flag:</vh></v>
<v t="ekr.20170101083205.54"><vh>class LeoFrame</vh>
<v t="ekr.20170101083205.55"><vh>__init__</vh></v>
<v t="ekr.20170101083205.56"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20170101083205.57"><vh>cmd</vh></v>
<v t="ekr.20170101083205.58"><vh>initialRatios</vh></v>
<v t="ekr.20170101083205.60"><vh>longFileName</vh></v>
<v t="ekr.20170101083205.61"><vh>shortFileName</vh></v>
<v t="ekr.20170101083205.62"><vh>oops</vh></v>
<v t="ekr.20170101083205.63"><vh>promptForSave</vh></v>
<v t="ekr.20170101083205.68"><vh>scanForTabWidth</vh></v>
<v t="ekr.20170101083205.69"><vh>addIconButton</vh></v>
<v t="ekr.20170101083205.70"><vh>addIconRow</vh></v>
<v t="ekr.20170101083205.71"><vh>addIconWidget</vh></v>
<v t="ekr.20170101083205.72"><vh>clearIconBar</vh></v>
<v t="ekr.20170101083205.73"><vh>createIconBar</vh></v>
<v t="ekr.20170101083205.75"><vh>getIconBar</vh></v>
<v t="ekr.20170101083205.77"><vh>getNewIconFrame</vh></v>
<v t="ekr.20170101083205.79"><vh>hideIconBar</vh></v>
<v t="ekr.20170101083205.80"><vh>showIconBar</vh></v>
<v t="ekr.20170101083205.81"><vh>createStatusLine</vh></v>
<v t="ekr.20170101083205.83"><vh>clearStatusLine</vh></v>
<v t="ekr.20170101083205.84"><vh>disableStatusLine</vh></v>
<v t="ekr.20170101083205.85"><vh>enableStatusLine</vh></v>
<v t="ekr.20170101083205.86"><vh>getStatusLine</vh></v>
<v t="ekr.20170101083205.87"><vh>putStatusLine</vh></v>
<v t="ekr.20170101083205.88"><vh>setFocusStatusLine</vh></v>
<v t="ekr.20170101083205.89"><vh>statusLineIsEnabled</vh></v>
<v t="ekr.20170101083205.90"><vh>updateStatusLine</vh></v>
<v t="ekr.20170101083205.91"><vh>copyText</vh></v>
<v t="ekr.20170101083205.95"><vh>cutText</vh></v>
<v t="ekr.20170101083205.99"><vh>pasteText</vh></v>
<v t="ekr.20170101083205.108"><vh>OnPaste</vh></v>
<v t="ekr.20170101083205.109"><vh>abortEditLabelCommand</vh></v>
<v t="ekr.20170101083205.111"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20170101083205.114"><vh>resizePanesToRatio</vh></v>
<v t="ekr.20170101083205.115"><vh>setInitialWindowGeometry</vh></v>
<v t="ekr.20170101083205.116"><vh>setTopGeometry</vh></v>
<v t="ekr.20170101083205.117"><vh>OnCopy</vh></v>
<v t="ekr.20170101083205.118"><vh>OnCut</vh></v>
<v t="ekr.20170101083205.119"><vh>contractPane</vh></v>
<v t="ekr.20170101083205.120"><vh>expandPane</vh></v>
<v t="ekr.20170101083205.121"><vh>contractBodyPane</vh></v>
<v t="ekr.20170101083205.122"><vh>contractLogPane</vh></v>
<v t="ekr.20170101083205.123"><vh>contractOutlinePane</vh></v>
<v t="ekr.20170101083205.124"><vh>expandBodyPane</vh></v>
<v t="ekr.20170101083205.125"><vh>expandLogPane</vh></v>
<v t="ekr.20170101083205.126"><vh>expandOutlinePane</vh></v>
<v t="ekr.20170101083205.127"><vh>fullyExpandBodyPane</vh></v>
<v t="ekr.20170101083205.128"><vh>fullyExpandLogPane</vh></v>
<v t="ekr.20170101083205.129"><vh>fullyExpandPane</vh></v>
<v t="ekr.20170101083205.130"><vh>fullyExpandOutlinePane</vh></v>
<v t="ekr.20170101083205.131"><vh>hideBodyPane</vh></v>
<v t="ekr.20170101083205.132"><vh>hideLogPane</vh></v>
<v t="ekr.20170101083205.133"><vh>hidePane</vh></v>
<v t="ekr.20170101083205.134"><vh>hideOutlinePane</vh></v>
<v t="ekr.20170101083205.135"><vh>cascade</vh></v>
<v t="ekr.20170101083205.136"><vh>equalSizedPanes</vh></v>
<v t="ekr.20170101083205.137"><vh>hideLogWindow</vh></v>
<v t="ekr.20170101083205.138"><vh>minimizeAll</vh></v>
<v t="ekr.20170101083205.139"><vh>resizeToScreen</vh></v>
<v t="ekr.20170101083205.140"><vh>toggleActivePane</vh></v>
<v t="ekr.20170101083205.141"><vh>toggleSplitDirection</vh></v>
<v t="ekr.20170101083205.142"><vh>leoHelp</vh></v>
<v t="ekr.20170101083205.143"><vh>bringToFront</vh></v>
<v t="ekr.20170101083205.144"><vh>deiconify</vh></v>
<v t="ekr.20170101083205.145"><vh>get_window_info</vh></v>
<v t="ekr.20170101083205.146"><vh>lift</vh></v>
<v t="ekr.20170101083205.147"><vh>OnBodyClick</vh></v>
<v t="ekr.20170101083205.148"><vh>OnBodyRClick</vh></v>
<v t="ekr.20170101083205.149"><vh>getTitle</vh></v>
<v t="ekr.20170101083205.150"><vh>setTitle</vh></v>
<v t="ekr.20170101083205.151"><vh>initAfterLoad</vh></v>
<v t="ekr.20170101083205.152"><vh>initCompleteHint</vh></v>
<v t="ekr.20170101083205.153"><vh>setTabWidth</vh></v>
</v>
<v t="ekr.20170101083205.59"><vh>if verticalFlag:</vh></v>
<v t="ekr.20170101083205.64"><vh>if quick_save:</vh></v>
<v t="ekr.20170101083205.65"><vh>if answer == "cancel":</vh></v>
<v t="ekr.20170101083205.66"><vh>if not c.mFileName:</vh></v>
<v t="ekr.20170101083205.67"><vh>if c.mFileName:</vh></v>
<v t="ekr.20170101083205.74"><vh>if not self.iconBar:</vh></v>
<v t="ekr.20170101083205.76"><vh>if not self.iconBar:</vh></v>
<v t="ekr.20170101083205.78"><vh>if not self.iconBar:</vh></v>
<v t="ekr.20170101083205.82"><vh>if not self.statusLine:</vh></v>
<v t="ekr.20170101083205.92"><vh>if not w or not g.isTextWrapper(w):</vh></v>
<v t="ekr.20170101083205.93"><vh>if i == j:</vh></v>
<v t="ekr.20170101083205.94"><vh>if s:</vh></v>
<v t="ekr.20170101083205.96"><vh>if not w or not g.isTextWrapper(w):</vh></v>
<v t="ekr.20170101083205.97"><vh>if i != j:</vh></v>
<v t="ekr.20170101083205.98"><vh>if name.startswith('body'):</vh></v>
<v t="ekr.20170101083205.100"><vh>if not w or not g.isTextWrapper(w):</vh></v>
<v t="ekr.20170101083205.101"><vh>if self.cursorStay and wname.startswith('body'):</vh></v>
<v t="ekr.20170101083205.102"><vh>if middleButton and c.k.previousSelection is not None:</vh></v>
<v t="ekr.20170101083205.103"><vh>if singleLine:</vh></v>
<v t="ekr.20170101083205.104"><vh>if hasattr(w, 'getXScrollPosition'):</vh></v>
<v t="ekr.20170101083205.105"><vh>if i != j:</vh></v>
<v t="ekr.20170101083205.106"><vh>if wname.startswith('body'):</vh></v>
<v t="ekr.20170101083205.107"><vh>if hasattr(w, 'getXScrollPosition'):</vh></v>
<v t="ekr.20170101083205.110"><vh>if g.app.batchMode:</vh></v>
<v t="ekr.20170101083205.112"><vh>if g.app.batchMode:</vh></v>
<v t="ekr.20170101083205.113"><vh>if w_name.startswith('head'):</vh></v>
<v t="ekr.20170101083205.154"><vh>class LeoLog</vh>
<v t="ekr.20170101083205.155"><vh>__init__</vh></v>
<v t="ekr.20170101083205.156"><vh>cmd</vh></v>
<v t="ekr.20170101083205.157"><vh>clearTab</vh></v>
<v t="ekr.20170101083205.158"><vh>createTab</vh></v>
<v t="ekr.20170101083205.160"><vh>createTextWidget</vh></v>
<v t="ekr.20170101083205.161"><vh>cycleTabFocus</vh></v>
<v t="ekr.20170101083205.163"><vh>deleteTab</vh></v>
<v t="ekr.20170101083205.166"><vh>disable</vh></v>
<v t="ekr.20170101083205.167"><vh>enable</vh></v>
<v t="ekr.20170101083205.168"><vh>getSelectedTab</vh></v>
<v t="ekr.20170101083205.169"><vh>hideTab</vh></v>
<v t="ekr.20170101083205.170"><vh>lowerTab</vh></v>
<v t="ekr.20170101083205.171"><vh>raiseTab</vh></v>
<v t="ekr.20170101083205.172"><vh>orderedTabNames</vh></v>
<v t="ekr.20170101083205.173"><vh>numberOfVisibleTabs</vh></v>
<v t="ekr.20170101083205.174"><vh>put</vh></v>
<v t="ekr.20170101083205.175"><vh>putnl</vh></v>
<v t="ekr.20170101083205.176"><vh>renameTab</vh></v>
<v t="ekr.20170101083205.177"><vh>selectTab</vh></v>
</v>
<v t="ekr.20170101083205.159"><vh>if createText:</vh></v>
<v t="ekr.20170101083205.162"><vh>if self.numberOfVisibleTabs() &gt; 1:</vh></v>
<v t="ekr.20170101083205.164"><vh>if tabName == 'Log':</vh></v>
<v t="ekr.20170101083205.165"><vh>if tabName in d:</vh></v>
<v t="ekr.20170101083205.178"><vh>if not tabFrame:</vh></v>
<v t="ekr.20170101083205.179"><vh>if 0:</vh></v>
<v t="ekr.20170101083205.180"><vh>class LeoTree</vh>
<v t="ekr.20170101083205.181"><vh>__init__</vh></v>
<v t="ekr.20170101083205.182"><vh>initAfterLoad</vh></v>
<v t="ekr.20170101083205.183"><vh>afterSelectHint</vh></v>
<v t="ekr.20170101083205.184"><vh>beforeSelectHint</vh></v>
<v t="ekr.20170101083205.185"><vh>redraw_after_contract</vh></v>
<v t="ekr.20170101083205.186"><vh>redraw_after_expand</vh></v>
<v t="ekr.20170101083205.187"><vh>redraw_after_head_changed</vh></v>
<v t="ekr.20170101083205.188"><vh>redraw_after_icons_changed</vh></v>
<v t="ekr.20170101083205.189"><vh>redraw_after_select</vh></v>
<v t="ekr.20170101083205.190"><vh>onHeadChanged</vh></v>
<v t="ekr.20170101083205.199"><vh>endEditLabel</vh></v>
<v t="ekr.20170101083205.200"><vh>getEditTextDict</vh></v>
<v t="ekr.20170101083205.201"><vh>editPosition</vh></v>
<v t="ekr.20170101083205.202"><vh>setEditPosition</vh></v>
<v t="ekr.20170101083205.203"><vh>injectCallbacks</vh>
<v t="ekr.20170101083205.204"><vh>OnHyperLinkControlClick</vh></v>
<v t="ekr.20170101083205.206"><vh>OnHyperLinkEnter</vh></v>
<v t="ekr.20170101083205.207"><vh>OnHyperLinkLeave</vh></v>
</v>
<v t="ekr.20170101083205.208"><vh>onHeadlineKey</vh></v>
<v t="ekr.20170101083205.210"><vh>OnIconCtrlClick</vh></v>
<v t="ekr.20170101083205.211"><vh>OnIconDoubleClick</vh></v>
<v t="ekr.20170101083205.212"><vh>updateHead</vh></v>
<v t="ekr.20170101083205.216"><vh>drawIcon</vh></v>
<v t="ekr.20170101083205.217"><vh>redraw</vh></v>
<v t="ekr.20170101083205.218"><vh>redraw_now</vh></v>
<v t="ekr.20170101083205.219"><vh>scrollTo</vh></v>
<v t="ekr.20170101083205.220"><vh>editLabel</vh></v>
<v t="ekr.20170101083205.221"><vh>edit_widget</vh></v>
<v t="ekr.20170101083205.222"><vh>select</vh></v>
<v t="ekr.20170101083205.226"><vh>selectHelper</vh></v>
<v t="ekr.20170101083205.233"><vh>unselect_helper</vh></v>
<v t="ekr.20170101083205.239"><vh>stop_colorizer</vh></v>
<v t="ekr.20170101083205.241"><vh>select_new_node</vh></v>
<v t="ekr.20170101083205.246"><vh>set_body_text_after_select</vh></v>
<v t="ekr.20170101083205.253"><vh>change_current_position</vh></v>
<v t="ekr.20170101083205.257"><vh>scroll_cursor</vh></v>
<v t="ekr.20170101083205.260"><vh>set_status_line</vh></v>
<v t="ekr.20170101083205.263"><vh>oops</vh></v>
</v>
<v t="ekr.20170101083205.191"><vh>if c.suppressHeadChanged:</vh></v>
<v t="ekr.20170101083205.192"><vh>if not w:</vh></v>
<v t="ekr.20170101083205.193"><vh>if trace:</vh></v>
<v t="ekr.20170101083205.194"><vh>if i &gt; -1:</vh></v>
<v t="ekr.20170101083205.195"><vh>if len(s) &gt; limit:</vh></v>
<v t="ekr.20170101083205.196"><vh>if g.doHook("headkey1", c=c, p=p, v=p, ch=ch, changed=changed):</vh></v>
<v t="ekr.20170101083205.197"><vh>if changed:</vh></v>
<v t="ekr.20170101083205.198"><vh>if changed:</vh></v>
<v t="ekr.20170101083205.205"><vh>if c and c.exists:</vh></v>
<v t="ekr.20170101083205.209"><vh>if ch:</vh></v>
<v t="ekr.20170101083205.213"><vh>if ch == '\b':</vh></v>
<v t="ekr.20170101083205.214"><vh>if s.endswith('\n'):</vh></v>
<v t="ekr.20170101083205.215"><vh>if ch in ('\n', '\r'):</vh></v>
<v t="ekr.20170101083205.223"><vh>if g.app.killed or self.tree_select_lockout:</vh></v>
<v t="ekr.20170101083205.224"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.225"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.227"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.228"><vh>if not p:</vh></v>
<v t="ekr.20170101083205.229"><vh>if not c.frame.body.wrapper:</vh></v>
<v t="ekr.20170101083205.230"><vh>if call_event_handlers:</vh></v>
<v t="ekr.20170101083205.231"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.232"><vh>if 0:</vh></v>
<v t="ekr.20170101083205.234"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.235"><vh>if call_event_handlers:</vh></v>
<v t="ekr.20170101083205.236"><vh>if unselect and old_p != p:</vh></v>
<v t="ekr.20170101083205.237"><vh>if call_event_handlers:</vh></v>
<v t="ekr.20170101083205.238"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.240"><vh>if colorizer:</vh></v>
<v t="ekr.20170101083205.242"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.243"><vh>if call_event_handlers:</vh></v>
<v t="ekr.20170101083205.244"><vh>if select:</vh></v>
<v t="ekr.20170101083205.245"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.247"><vh>if trace and trace_time:</vh></v>
<v t="ekr.20170101083205.248"><vh>if not force and p and p == old_p and s == old_s:</vh></v>
<v t="ekr.20170101083205.249"><vh>if 0 &lt; c.max_pre_loaded_body_chars &lt; len(s):</vh></v>
<v t="ekr.20170101083205.250"><vh>if trace and trace_time:</vh></v>
<v t="ekr.20170101083205.251"><vh>if hasattr(colorizer, 'setHighlighter'):</vh></v>
<v t="ekr.20170101083205.252"><vh>if trace and trace_time:</vh></v>
<v t="ekr.20170101083205.254"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.255"><vh>if use_chapters:</vh></v>
<v t="ekr.20170101083205.256"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.258"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.259"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.261"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.262"><vh>if traceTime:</vh></v>
<v t="ekr.20170101083205.264"><vh>class LeoTreeTab</vh>
<v t="ekr.20170101083205.265"><vh>__init__</vh></v>
<v t="ekr.20170101083205.266"><vh>createControl</vh></v>
<v t="ekr.20170101083205.267"><vh>createTab</vh></v>
<v t="ekr.20170101083205.268"><vh>destroyTab</vh></v>
<v t="ekr.20170101083205.269"><vh>selectTab</vh></v>
<v t="ekr.20170101083205.270"><vh>setTabLabel</vh></v>
<v t="ekr.20170101083205.271"><vh>oops</vh></v>
</v>
<v t="ekr.20170101083205.272"><vh>class NullBody</vh>
<v t="ekr.20170101083205.273"><vh>__init__</vh></v>
<v t="ekr.20170101083205.274"><vh>findStartOfLine</vh></v>
<v t="ekr.20170101083205.275"><vh>scanToStartOfLine</vh></v>
<v t="ekr.20170101083205.278"><vh>scanToEndOfLine</vh></v>
<v t="ekr.20170101083205.281"><vh>createControl</vh></v>
<v t="ekr.20170101083205.282"><vh>addEditor</vh></v>
<v t="ekr.20170101083205.283"><vh>assignPositionToEditor</vh></v>
<v t="ekr.20170101083205.284"><vh>createEditorFrame</vh></v>
<v t="ekr.20170101083205.285"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20170101083205.286"><vh>deleteEditor</vh></v>
<v t="ekr.20170101083205.287"><vh>selectEditor</vh></v>
<v t="ekr.20170101083205.288"><vh>selectLabel</vh></v>
<v t="ekr.20170101083205.289"><vh>setEditorColors</vh></v>
<v t="ekr.20170101083205.290"><vh>unselectLabel</vh></v>
<v t="ekr.20170101083205.291"><vh>updateEditors</vh></v>
<v t="ekr.20170101083205.292"><vh>forceFullRecolor</vh></v>
<v t="ekr.20170101083205.293"><vh>scheduleIdleTimeRoutine</vh></v>
<v t="ekr.20170101083205.294"><vh>setFocus</vh></v>
</v>
<v t="ekr.20170101083205.276"><vh>if i &lt;= 0:</vh></v>
<v t="ekr.20170101083205.277"><vh>if self.s[i] == '\n':</vh></v>
<v t="ekr.20170101083205.279"><vh>if i &gt;= len(self.s):</vh></v>
<v t="ekr.20170101083205.280"><vh>if self.s[i] == '\n':</vh></v>
<v t="ekr.20170101083205.295"><vh>class NullColorizer</vh>
<v t="ekr.20170101083205.296"><vh>__init__</vh></v>
<v t="ekr.20170101083205.297"><vh>colorize</vh></v>
<v t="ekr.20170101083205.298"><vh>disable</vh></v>
<v t="ekr.20170101083205.299"><vh>enable</vh></v>
<v t="ekr.20170101083205.300"><vh>kill</vh></v>
<v t="ekr.20170101083205.301"><vh>setHighlighter</vh></v>
<v t="ekr.20170101083205.302"><vh>showInvisibles</vh></v>
<v t="ekr.20170101083205.303"><vh>write_colorizer_cache</vh></v>
</v>
<v t="ekr.20170101083205.304"><vh>class NullFrame</vh>
<v t="ekr.20170101083205.305"><vh>__init__</vh></v>
<v t="ekr.20170101083205.306"><vh>destroySelf</vh></v>
<v t="ekr.20170101083205.307"><vh>finishCreate</vh></v>
<v t="ekr.20170101083205.308"><vh>resizePanesToRatio</vh></v>
<v t="ekr.20170101083205.309"><vh>setInitialWindowGeometry</vh></v>
<v t="ekr.20170101083205.310"><vh>setTopGeometry</vh></v>
<v t="ekr.20170101083205.311"><vh>contractPane</vh></v>
<v t="ekr.20170101083205.312"><vh>expandPane</vh></v>
<v t="ekr.20170101083205.313"><vh>contractBodyPane</vh></v>
<v t="ekr.20170101083205.314"><vh>contractLogPane</vh></v>
<v t="ekr.20170101083205.315"><vh>contractOutlinePane</vh></v>
<v t="ekr.20170101083205.316"><vh>expandBodyPane</vh></v>
<v t="ekr.20170101083205.317"><vh>expandLogPane</vh></v>
<v t="ekr.20170101083205.318"><vh>expandOutlinePane</vh></v>
<v t="ekr.20170101083205.319"><vh>fullyExpandBodyPane</vh></v>
<v t="ekr.20170101083205.320"><vh>fullyExpandLogPane</vh></v>
<v t="ekr.20170101083205.321"><vh>fullyExpandPane</vh></v>
<v t="ekr.20170101083205.322"><vh>fullyExpandOutlinePane</vh></v>
<v t="ekr.20170101083205.323"><vh>hideBodyPane</vh></v>
<v t="ekr.20170101083205.324"><vh>hideLogPane</vh></v>
<v t="ekr.20170101083205.325"><vh>hidePane</vh></v>
<v t="ekr.20170101083205.326"><vh>hideOutlinePane</vh></v>
<v t="ekr.20170101083205.327"><vh>cascade</vh></v>
<v t="ekr.20170101083205.328"><vh>equalSizedPanes</vh></v>
<v t="ekr.20170101083205.329"><vh>hideLogWindow</vh></v>
<v t="ekr.20170101083205.330"><vh>minimizeAll</vh></v>
<v t="ekr.20170101083205.331"><vh>resizeToScreen</vh></v>
<v t="ekr.20170101083205.332"><vh>toggleActivePane</vh></v>
<v t="ekr.20170101083205.333"><vh>toggleSplitDirection</vh></v>
<v t="ekr.20170101083205.334"><vh>leoHelp</vh></v>
<v t="ekr.20170101083205.335"><vh>bringToFront</vh></v>
<v t="ekr.20170101083205.336"><vh>deiconify</vh></v>
<v t="ekr.20170101083205.337"><vh>get_window_info</vh></v>
<v t="ekr.20170101083205.338"><vh>lift</vh></v>
<v t="ekr.20170101083205.339"><vh>setWrap</vh></v>
<v t="ekr.20170101083205.340"><vh>update</vh></v>
</v>
<v t="ekr.20170101083205.341"><vh>class NullIconBarClass</vh>
<v t="ekr.20170101083205.342"><vh>__init__</vh></v>
<v t="ekr.20170101083205.343"><vh>addRow</vh></v>
<v t="ekr.20170101083205.344"><vh>addRowIfNeeded</vh></v>
<v t="ekr.20170101083205.345"><vh>addWidget</vh></v>
<v t="ekr.20170101083205.346"><vh>createChaptersIcon</vh></v>
<v t="ekr.20170101083205.347"><vh>deleteButton</vh></v>
<v t="ekr.20170101083205.348"><vh>getNewFrame</vh></v>
<v t="ekr.20170101083205.349"><vh>hide</vh></v>
<v t="ekr.20170101083205.350"><vh>show</vh></v>
<v t="ekr.20170101083205.351"><vh>add</vh>
<v t="ekr.20170101083205.353"><vh>class nullButtonWidget</vh>
<v t="ekr.20170101083205.354"><vh>__init__</vh></v>
<v t="ekr.20170101083205.355"><vh>__repr__</vh></v>
</v>
</v>
<v t="ekr.20170101083205.356"><vh>clear</vh></v>
<v t="ekr.20170101083205.357"><vh>setCommandForButton</vh></v>
</v>
<v t="ekr.20170101083205.352"><vh>if not command:</vh></v>
<v t="ekr.20170101083205.358"><vh>class NullLog</vh>
<v t="ekr.20170101083205.359"><vh>__init__</vh></v>
<v t="ekr.20170101083205.360"><vh>finishCreate</vh></v>
<v t="ekr.20170101083205.361"><vh>createControl</vh></v>
<v t="ekr.20170101083205.362"><vh>createTextWidget</vh></v>
<v t="ekr.20170101083205.363"><vh>isLogWidget</vh></v>
<v t="ekr.20170101083205.364"><vh>oops</vh></v>
<v t="ekr.20170101083205.365"><vh>put</vh></v>
<v t="ekr.20170101083205.367"><vh>putnl</vh></v>
<v t="ekr.20170101083205.369"><vh>clearTab</vh></v>
<v t="ekr.20170101083205.370"><vh>createCanvas</vh></v>
<v t="ekr.20170101083205.371"><vh>createTab</vh></v>
<v t="ekr.20170101083205.372"><vh>deleteTab</vh></v>
<v t="ekr.20170101083205.373"><vh>getSelectedTab</vh></v>
<v t="ekr.20170101083205.374"><vh>lowerTab</vh></v>
<v t="ekr.20170101083205.375"><vh>raiseTab</vh></v>
<v t="ekr.20170101083205.376"><vh>renameTab</vh></v>
<v t="ekr.20170101083205.377"><vh>selectTab</vh></v>
</v>
<v t="ekr.20170101083205.366"><vh>if self.enabled:</vh></v>
<v t="ekr.20170101083205.368"><vh>if self.enabled:</vh></v>
<v t="ekr.20170101083205.378"><vh>class NullStatusLineClass</vh>
<v t="ekr.20170101083205.379"><vh>__init__</vh></v>
<v t="ekr.20170101083205.380"><vh>disable</vh></v>
<v t="ekr.20170101083205.381"><vh>enable</vh></v>
<v t="ekr.20170101083205.382"><vh>clear</vh></v>
<v t="ekr.20170101083205.383"><vh>get</vh></v>
<v t="ekr.20170101083205.384"><vh>isEnabled</vh></v>
<v t="ekr.20170101083205.385"><vh>put</vh></v>
<v t="ekr.20170101083205.386"><vh>setFocus</vh></v>
<v t="ekr.20170101083205.387"><vh>update</vh></v>
</v>
<v t="ekr.20170101083205.388"><vh>class NullTree</vh>
<v t="ekr.20170101083205.389"><vh>__init__</vh></v>
<v t="ekr.20170101083205.390"><vh>printWidgets</vh></v>
<v t="ekr.20170101083205.391"><vh>drawIcon</vh></v>
<v t="ekr.20170101083205.392"><vh>redraw</vh></v>
<v t="ekr.20170101083205.393"><vh>redraw_now</vh></v>
<v t="ekr.20170101083205.394"><vh>redraw_after_contract</vh></v>
<v t="ekr.20170101083205.395"><vh>redraw_after_expand</vh></v>
<v t="ekr.20170101083205.396"><vh>redraw_after_head_changed</vh></v>
<v t="ekr.20170101083205.397"><vh>redraw_after_icons_changed</vh></v>
<v t="ekr.20170101083205.398"><vh>redraw_after_select</vh></v>
<v t="ekr.20170101083205.399"><vh>scrollTo</vh></v>
<v t="ekr.20170101083205.400"><vh>edit_widget</vh></v>
<v t="ekr.20170101083205.403"><vh>editLabel</vh></v>
<v t="ekr.20170101083205.405"><vh>setHeadline</vh></v>
</v>
<v t="ekr.20170101083205.401"><vh>if not p.v:</vh></v>
<v t="ekr.20170101083205.402"><vh>if not w:</vh></v>
<v t="ekr.20170101083205.404"><vh>if p:</vh></v>
<v t="ekr.20170101083205.406"><vh>if w:</vh></v>
<v t="ekr.20170101083205.407"><vh>class StringTextWrapper</vh>
<v t="ekr.20170101083205.408"><vh>__init__</vh></v>
<v t="ekr.20170101083205.409"><vh>__repr__</vh></v>
<v t="ekr.20170101083205.410"><vh>getName</vh></v>
<v t="ekr.20170101083205.411"><vh>clipboard_clear</vh></v>
<v t="ekr.20170101083205.412"><vh>clipboard_append</vh></v>
<v t="ekr.20170101083205.413"><vh>flashCharacter</vh></v>
<v t="ekr.20170101083205.414"><vh>getXScrollPosition</vh></v>
<v t="ekr.20170101083205.415"><vh>getYScrollPosition</vh></v>
<v t="ekr.20170101083205.416"><vh>see</vh></v>
<v t="ekr.20170101083205.417"><vh>seeInsertPoint</vh></v>
<v t="ekr.20170101083205.418"><vh>setFocus</vh></v>
<v t="ekr.20170101083205.419"><vh>setXScrollPosition</vh></v>
<v t="ekr.20170101083205.420"><vh>setYScrollPosition</vh></v>
<v t="ekr.20170101083205.421"><vh>tag_configure</vh></v>
<v t="ekr.20170101083205.422"><vh>appendText</vh></v>
<v t="ekr.20170101083205.423"><vh>delete</vh></v>
<v t="ekr.20170101083205.424"><vh>deleteTextSelection</vh></v>
<v t="ekr.20170101083205.425"><vh>get</vh></v>
<v t="ekr.20170101083205.426"><vh>getAllText</vh></v>
<v t="ekr.20170101083205.427"><vh>getInsertPoint</vh></v>
<v t="ekr.20170101083205.429"><vh>getSelectedText</vh></v>
<v t="ekr.20170101083205.430"><vh>getSelectionRange</vh></v>
<v t="ekr.20170101083205.432"><vh>hasSelection</vh></v>
<v t="ekr.20170101083205.433"><vh>insert</vh></v>
<v t="ekr.20170101083205.434"><vh>selectAllText</vh></v>
<v t="ekr.20170101083205.435"><vh>setAllText</vh></v>
<v t="ekr.20170101083205.436"><vh>setInsertPoint</vh></v>
<v t="ekr.20170101083205.437"><vh>setSelectionRange</vh></v>
<v t="ekr.20170101083205.438"><vh>toPythonIndex</vh></v>
<v t="ekr.20170101083205.439"><vh>toPythonIndexRowCol</vh></v>
</v>
<v t="ekr.20170101083205.428"><vh>if i is None:</vh></v>
<v t="ekr.20170101083205.431"><vh>if len(sel) == 2 and sel[0] &gt;= 0 and sel[1] &gt;= 0:</vh></v>
</v>
</v>
<v t="ekr.20090529141856.4736" a="E"></v>
</vnodes>
<tnodes>
<t tx="bwmulder.20050108100437.1">@killcolor

Running unit tests from test.leo is easy, provided you have enabled the
Scripting plugin. When this plugin is enabled Leo will create a blue 'script
button' in the icon bar called 'unit test'. 

- To run all unit tests, select the node in test.leo called 'Unit tests...',
then do &lt;alt-4&gt; 

- To run a single test, select an @test node and do &lt;alt-4&gt;.

- To run a suite of tests, select an @suite node and do &lt;alt-4&gt;.

- To run any other collection of tests, create an outline containing those @test
or @suite nodes, select the root of that tree and do &lt;alt-4&gt; .

Several nodes in the tree @thin ../src/leoTest.py (in test.leo) contain support
code for @test, @suite, etc. so if you want all the gory details you can read
the code. It's not complicated: Leo creates UnitTest classes automatically whose
run method is the body of the @suite or @test node.
</t>
<t tx="edward.20150612083734.1">gnx: ekr.20090627070131.4975
</t>
<t tx="edward.20150612083734.2">gnx: ekr.20090627070131.4975
</t>
<t tx="edward.20150612083734.3">gnx: ekr.20090627070131.4976
unl: spam
gnx: ekr.20090627070131.4977
unl: cheese
</t>
<t tx="edward.20150612083734.4">gnx: ekr.20100801125533.5788
</t>
<t tx="edward.20150612083734.5">gnx: ekr.20100801125533.5788
</t>
<t tx="edward.20150612083734.6">gnx: ekr.20100801125533.5789
unl: spam
gnx: ekr.20100801125533.5790
unl: cheese
</t>
<t tx="ekr.20041121151002"></t>
<t tx="ekr.20050328101834"></t>
<t tx="ekr.20050328101834.1"></t>
<t tx="ekr.20050328101834.2"></t>
<t tx="ekr.20050328101834.3"></t>
<t tx="ekr.20050618061835">@killcolor

Here is a tutorial written by Roger Erens.

Version Date        LeoID       Remarks
------- ----        -----       -------
0.1     20050519    rogererens  Initial version</t>
<t tx="ekr.20050618061835.1">So you think "Well, since I've written this piece of funky Python software, and everybody keeps saying how useful unit testing is, I really ought to start using unit tests." And since Leo's creator has said countless times in the Leo forums how easy unit testing in Leo is, a few uncomplicated examples might help convince you that he's not spamming.

Beware: this How-To should be the last time that you write tests AFTER having written your funky software! Test Driven Development dictates that tests have to be prepared BEFORE you get down to writing your actual code. See a nice tutorial on O'Reilly's website (url given in the descendant node).</t>
<t tx="ekr.20050618061835.10">Start of Do @test
F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Documents and Settings\re1705\My Documents\PythonStuff\leo\src\leoTes
t.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.010s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.11">A real fun feature of Leo is that Leo saves you from having to select each and single @test node and press the 'Do @test' button to obtain testing results. Just collecting the @test nodes under an organizing node, selecting that organizing node, and pressing the 'Do @test' button will suffice.
Of course, this was one of the key ideas of unit testing, but it's nice to see it being implemented by Leo so smoothly!

So, press the button while having this node selected, and see if your console's output matches the third child node more or less. </t>
<t tx="ekr.20050618061835.12">Start of Do @test
.F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 2 tests in 0.040s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.13">Okay: so you've seen now some simple stand-alone tests to get your toes wet.
Now, we get to the 'grande finale' and see real-life usage of the @test nodes.

The @test child node below illustrates the following points:

1.  The node imports the module to test (and keeps it up to date by reloading it).
2.  It also obtains data to use as input and referral. This is what you might call
    the setUp methods in traditional unit tests. If more tests need the same data,
    you can put the nodes in a central place where all the @test nodes can find
    them. Likewise, common code for several unit tests might be collected in a
    central place.
3.  Comparable with the traditional unit tests' tearDown method, some statements
    can follow the test itself, if neccessary. You might also consider using a
    try/finally construct.
4.  I have used g.es() statements instead of print statements, since the latter
    clutter the console. Try replacing the g.es() statements by corresponding
    print statements to see what I mean. With more than one @test node being tested,
    this will give quite a dreadful look.</t>
<t tx="ekr.20050618061835.14">@color

try:
    # SETUP
    import koekiemonster # this module defines a function want() which we want to test
    reload(koekiemonster) # changes in koekiemonster need to propagate to the test

    # obtaining the input parameter for the function
    inputNode = p.firstChild()
    inputData = inputNode.b
    
    # obtaining the expected result from the function with above input parameter
    expectedResultNode = inputNode.next()
    expected = expectedResultNode.b
    
    # execute the function with above input parameter
    result = koekiemonster.wants(inputData)
    
    # TEST
    assert(result == expected)
    
    # TEARDOWN
    g.es("Now it's time to clean up")

except AssertionError:
    # TEARDOWN
    g.es("Oh oh! %s failed:" % p.h.strip())
    g.es("koekiemonster.wants(%s)==%s" % (inputData, result))
    g.es("Expected: %s" % expected)
    raise # pass the exception on to the unit test machinery</t>
<t tx="ekr.20050618061835.15">vegetables</t>
<t tx="ekr.20050618061835.16">Yuck!</t>
<t tx="ekr.20050618061835.17">Start of Do @test
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.070s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.18">Start of Do @test
Oh oh: @test koekiemonster.wants() failed:
koekiemonster.wants(vegetables)=Yack!
Expected: Yuck!
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.051s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.19">With the aforementioned possibilities of running all @test nodes in a subtree
with a single click on a button, the sharing of input/expected data, and the
sharing of setUp/tearDown code, there hardly seems a need for the @suite nodes.

On Leo's website
(http://webpages.charter.net/edreamleo/scripting.html#unit-testing-with-test-and-suite)
I could still find some extra info on @suite nodes, not found in LeoDocs.leo:

&lt;quote&gt;

Using @suite nodes

Such nodes create a suite of tests. Leo executes the script in these nodes similar to @test nodes, but Leo assumes that the script in an @suite node will do the following:

    * Create a suite of unit tests
    * Put the suite in g.app.scriptDict["suite"]

The difference between @test and @suite is:

    * Leo creates a unit test from script in an @test node by creating an instance of generalTestCase, a subclass of unittest.TestCase.
    * The script in an @suite node creates the test suite.

An @suite nodes allows us to create "legacy" unit tests simply. For example,
rather than rewriting all the reformatParagraph unit tests to use @test nodes, I
simply wrote an @suite node with the following body.

    suite = c.testManager.makeReformatParagraphSuite()
    g.app.scriptDict['suite'] = suite

&lt;/quote&gt;

Well, that's almost, but not quite completely, totally incomprehensible to me.
Fortunately, since Leo's creator removed most of this quote from LeoDocs.leo and
test.leo, this information appears to be outdated
.</t>
<t tx="ekr.20050618061835.2"></t>
<t tx="ekr.20050618061835.20">Don't forget to read the node
Users Guide--&gt;Chapter 7: Scripting Leo with Python--&gt;Unit testing with @test, @suite
in LeoDocs.leo, especially the final notes. Also investigate a little further in test.leo to see some heavy weight lifting.

This concludes my How-To on using @test. It was not written by an expert on (unit) testing;
it is more or less the result of keeping notes on my way to find out how I could get started
with unit tests in Leo. Maybe it's useful for other newbies as well.

Please post any remarks on one of the Leo Fora, and if deemed helpful, I'll be glad to incorporate them into a next version.

Happy testing!</t>
<t tx="ekr.20050618061835.3">Comment by EKR: There is no need to do this if you use test.leo for your unit tests:  just use the unit test button.

From the console, start up a Leo instance. On MS Windows: go to the folder in which you installed Leo 4.3, open up the 'src' folder and double click the 'leo.py' file. Opening a command window, and typing "python leo.py" may be another way.

Use the File--&gt;Open... menu item to open the outline containing your code.

Choose a good-looking position to insert a new node called 'Test zone'. Copy the child node of the node you're reading right now, and paste it as a child node of 'Test zone'. The code it contains is essentially the same as found in the node
Unit tests...--&gt;Do @test
in the file 'test.leo' in the 'test' folder. I just added my 0.2 cents by adding some starting and finishing remarks. Remove them if they clutter your console too much.

Also, make sure that you have an entry 'Scripting' in the 'Plugins' menu (enable the plugin if neccessary). Now is a good time to save your leo file.

With the 'Scripting' plugin (also known as the 'mod_scripting' plugin) enabled, the net effect will be that the next time you open your outline, a blue button with the caption 'Do @test' shows up in the tool bar of Leo, if your screen is wide enough.
To get the button right away in the tool bar, I have to assume that you started Leo with the scripting plugin enabled. In this case, a yellow button with the caption 'script Button' can be pressed while having the node '@button Do @test' selected. Note: the resulting button will not be blue, but pink. Removing a button from the tool bar can be done by right-clicking it.

We'll see the use of this added button soon, but before that, read up on the 'assert' function in the Python manuals, since it is used a lot in testing. It won't be long before you're back here!</t>
<t tx="ekr.20050618061835.4">@color

g.pr("\nStart of Do @test")
c.testManager.doTests(all=False)
g.pr("End of Do @test")</t>
<t tx="ekr.20050618061835.5">The first child node of the node you're reading right now, contains the simplest succeeding test possible.
Select it, and press the button 'Do @test'.
You can find the verbatim result as it got sent to my console in the second child node.

A few things are worth noting here:

1.  The node containing the test must have its headline start with '@test'.
2.  Whenever the 'assert' statement finds out that the expression given to it
    is 'True', a test passes successfully. There are more ways to pass a test, but
    for now, let us stick to the use of assert functions.
3.  A passed test is denoted with a single dot in the output. See the line between
    'Start of Do @test' and the line filled with dashes. This is compatible with the
    way traditional unit testing shows its progress.
4.  Below the dashed line in the output, a summary is printed. This one surely gives
    us a reason to lean back for a moment, and congratualate ourselves with another
    piece of robust, funky code!</t>
<t tx="ekr.20050618061835.6">@color
assert(True)</t>
<t tx="ekr.20050618061835.7">Start of Do @test
.
----------------------------------------------------------------------
Ran 1 test in 0.010s

OK
End of Do @test</t>
<t tx="ekr.20050618061835.8">Now that you've seen a passing test, it should be obvious to imagine how a failing test would look like. See the first child node, and then run it by pressing the 'Do @test' button as before.

Instead of a dot denoting success, we get an 'F' denoting a failure on the line following 'Start of Do @test'. When running a lot of tests, the next part, following the lines filled with '='s, helps to identify which test failed.
It also includes a trace back, but for AssertionErrors, it does not seem to offer much added value to me right now. On second thought: when you have multiple asserts in a test, the trace back can tell you which assert function failed. Still, I would choose for only one assert function per test and get rid of this trace back altogether. This would keep the console much cleaner, IMHO.</t>
<t tx="ekr.20050618061835.9">@color
assert('Spam' == 'Ham')</t>
<t tx="ekr.20051012104957"></t>
<t tx="ekr.20051013162226"></t>
<t tx="ekr.20070113145100"># Not part of cvs distributions, but needed for two unit tests.

dir = g.os_path_join(g.app.loadDir,'..','test','unittest',g.u('chinese\u8116folder'),encoding='utf-8')
s   = g.os_path_join(dir,g.u('chinese\u8116test.leo'),encoding='utf-8')
    
if not g.os_path_exists(dir):
    import os
    os.mkdir(dir)
    g.pr('created chinese folder')
    
if not g.os_path_exists(s):
    f = file(s,'w')
    f.close()
    g.pr('created chinese file')
    
</t>
<t tx="ekr.20070217065840">@nocolor-node

@
To make unit tests, do the following:
    
- Use the make-test script (Alt-5) to create a suboutline for a unit test.
- Put text in the before node, selected desired text, then do the do-before script (Alt-6).
- Execute the command, then do the do-after script (Alt-7).
</t>
<t tx="ekr.20070217065840.1">try:
    p1 = p.insertAfter()
    c.setHeadString(p1,'@test ')
    body = 'c.testManager.runEditCommandTest(c,p)'
    c.setBodyString(p1,body)
    for s in ('work','before','after'):
        p2 = p1.insertAsLastChild()
        c.setHeadString(p2,s)
    p1.expand()
finally:
    c.redraw()
    c.editPosition(p1)</t>
<t tx="ekr.20070217065840.2">@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. The work node should have body text. If all is as expected,
copy the body text the work node to the before node, and represent the selection
range of the work in the headline of the before node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top and work.b:

    c.setBodyString(before,work.b)
    c.setBodyString(after,'')
    putSelectionInHeadline(c,before,'before',sel)
    c.redraw()
else:
    g.es_print('do-before: not in a proper @test tree')</t>
<t tx="ekr.20070217065840.3">def getSel(c):
    
    w = c.frame.body.bodyCtrl
    i,j= w.getSelectionRange()
    if i == j:
        i = j = w.getInsertPoint()
        sel = (i,i)
    return i,j</t>
<t tx="ekr.20070217065840.4">def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.h.startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild() 
    before = work and work.next()     
    after  = before and before.next()
    if (
        work   and work.h.startswith('work') and
        before and before.h.startswith('before') and
        after  and after.h.startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None</t>
<t tx="ekr.20070217065840.5">def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.h,repr(sel))

    w = c.frame.body.bodyCtrl
    i,j = sel
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    s = '%s sel=%s,%s' % (prefix,i,j)
    c.setHeadString(p,s)
</t>
<t tx="ekr.20070217065840.6">@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. If all is as expected, copy the work node to the after node,
and represent the selection range of the work node in the headline of the after node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top:
    c.setBodyString(after,work.b)
    putSelectionInHeadline(c,after,'after',sel)
    c.redraw()
else:
    g.es_print('do-after: not in @test tree')</t>
<t tx="ekr.20070217065840.8">def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.h.startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild()
    before = work and work.next()
    after  = before and before.next()
    if (
        work   and work.h.startswith('work') and
        before and before.h.startswith('before') and
        after  and after.h.startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None</t>
<t tx="ekr.20070217065840.9">def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.h,repr(sel))
    
    w = c.frame.body.bodyCtrl
    i,j = sel
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    s = '%s sel=%s,%s' % (prefix,i,j)
    c.setHeadString(p,s)
</t>
<t tx="ekr.20070217072822">def getSel(c):
    
    w = c.frame.body.bodyCtrl
    i,j= w.getSelectionRange()
    if i == j:
        i = j = w.getInsertPoint()
        sel = (i,i)
    return i,j</t>
<t tx="ekr.20070417092935">
@nosearch</t>
<t tx="ekr.20070503064257"></t>
<t tx="ekr.20070528100318"># Required to make a typing test work.
</t>
<t tx="ekr.20071113140035">fn = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','core','leoPy.leo'))
assert g.os_path_exists(fn),fn
c1 = c
c2 = g.openWithFileName(fn,old_c=None,enableLog=False)
assert c2
c.frame.bringToFront()
g.app.setLog(c.frame.log)

d1 = {} ; d2 = {}
for c,d in ( (c1,d1),(c2,d2)):
    for p in c.all_unique_positions():
        if p.h.startswith('@test'):
            d[p.h]=p.h

if 0: # not important
    g.pr()
    g.pr('----- Only in unitTest.leo')
    for h in sorted(d1.keys()):
        if not d2.get(h):
            print(h)

print('\n----- Only in leoPy.leo')
for h in sorted(d2.keys()):
    if not d1.get(h):
        print(h)</t>
<t tx="ekr.20071113203234"></t>
<t tx="ekr.20080324133327.2">True: allow linux-like pastes using a mouse's middle button.

Important: this may cause crashes on some platforms.
</t>
<t tx="ekr.20080907122804.1">@others</t>
<t tx="ekr.20080907123324.2">@language python
@tabwidth -4
# before @others: line 1
@others
# last line: line 6</t>
<t tx="ekr.20080907123324.3">def spam(): # line 2
    pass
</t>
<t tx="ekr.20090529141856.4682"></t>
<t tx="ekr.20090529141856.4684">@language python
@tabwidth -4
</t>
<t tx="ekr.20090529141856.4685"># Create unit tests in g.app.scriptDict["suite"]

suite = c.testManager.makeImportExportSuite("exportTests",doImport=False)

# g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20090529141856.4698"></t>
<t tx="ekr.20090529141856.4699"># Create unit tests in g.app.scriptDict["suite"]

suite = c.testManager.makeImportExportSuite("importTests",doImport=True)

# g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20090529141856.4716">@tabwidth -4
@language python
</t>
<t tx="ekr.20090529141856.4717"></t>
<t tx="ekr.20090529141856.4718">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
class cTestClass1 {

    int foo (int a) {
        a = 2 ;
    }

    char bar (float c) {
        ;
    }
}
'''
table = (
    'class cTestClass1',
    'int foo',
    'char bar',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4719">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
class cTestClass1 {

    int foo (int a) {
// an underindented line.
        a = 2 ;
    }

    // This should go with the next function.

    char bar (float c) {
        ;
    }
}
'''
table = (
    'class cTestClass1',
    'int foo',
    'char bar',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4721">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) //  &lt;---------------------problem
{
    return true;
}
'''
table = (
    'void aaa::bbb::doit',
    'bool aaa::bbb::dothat',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children 
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4722">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) 
{
    return true;
} //  &lt;---------------------problem
'''
table = (
    'void aaa::bbb::doit',
    'bool aaa::bbb::dothat',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4723">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
s = '''
void
aaa::bbb::doit
    (
    awk* b  // leading blank
    )
{
	assert(false); // leading tab
}

'''
table = (
    'void aaa::bbb::doit',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4724">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
static void
ReleaseCharSet(cset)
    CharSet *cset;
{
    ckfree((char *)cset-&gt;chars);
    if (cset-&gt;ranges) {
    ckfree((char *)cset-&gt;ranges);
    }
}
'''
table = (
    'static void ReleaseCharSet',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4725">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
Tcl_Obj *
Tcl_NewLongObj(longValue)
    register long longValue;	/* Long integer used to initialize the
         * new object. */
{
    return Tcl_DbNewLongObj(longValue, "unknown", 0);
}
'''
table = (
    'Tcl_Obj * Tcl_NewLongObj',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4726">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
extern "C"
{
#include "stuff.h"
void    init(void);
#include "that.h"
}
'''
table = (
    'extern "C"',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4727"></t>
<t tx="ekr.20090529141856.4728">s = '''\
namespace {
    class cTestClass1 {
        ;
    }
}
'''
try:
    c.importCommands.cSharpUnitTest(p,s=s,showTree=True)
    table = [
        'namespace',
        'class cTestClass1',
    ]
    root = c.p.firstChild()
    assert root.h.endswith('c# namespace indent'), root.h
    p2 = root.firstChild()
    for i, h in enumerate(table):
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20090529141856.4729">s = '''\
namespace {
class cTestClass1 {
    ;
}
}
'''
try:
    c.importCommands.cSharpUnitTest(p,s=s,showTree=True)
    table = [
        'namespace',
        'class cTestClass1',
    ]
    root = c.p.firstChild()
    assert root.h.endswith('c# namespace no indent'), root.h
    p2 = root.firstChild()
    for i, h in enumerate(table):
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20090529141856.4730">import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(
        g.app.loadDir,'..','test','big-c#-test.c#'))
    f = open(fileName)
    s = f.read()
    f.close()
    c.importCommands.cSharpUnitTest(p,s=s,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20090529141856.4731"></t>
<t tx="ekr.20090529141856.4733">if 0:
    # The preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.elisp
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.elisp)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
;;; comment
;;; continue
;;;

(defun abc (a b)
   (+ 1 2 3))

; comm
(defun cde (a b)
   (+ 1 2 3))
'''

table = (
    'defun abc',
    'defun cde',
)
try:
    ic.elispUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()

</t>
<t tx="ekr.20090529141856.4734"></t>
<t tx="ekr.20090529141856.4735">if 0:
    # The preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.pascal
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.pascal)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''
unit Unit1;

interface

uses
Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
Forms,
Dialogs;

type
TForm1 = class(TForm)
procedure FormCreate(Sender: TObject);
private
{ Private declarations }
public
{ Public declarations }
end;

var
Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.FormCreate(Sender: TObject);
var
x,y: double;
begin
x:= 4;
Y := x/2;
end;

end. // interface
'''
table = (
    'interface',
    'procedure FormCreate',
    'procedure TForm1.FormCreate',
)
try:
    ic.pascalUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20090529141856.4736"># Warning: setting atAuto=True can wipe out unit tests.
</t>
<t tx="ekr.20090529141856.4766"></t>
<t tx="ekr.20090529141856.4767">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.java)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
interface Bicycle {
    void changeCadence(int newValue);
    void changeGear(int newValue);
}
'''
table = (
    'interface Bicycle',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4768">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.java)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
interface Bicycle {
void changeCadence(int newValue);
void changeGear(int newValue);
}
'''
table = (
    'interface Bicycle',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4769">import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','constants.java'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=None,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20090529141856.4770">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.java)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
/**
 * Indicates the caller's authority to perform lifecycle operations on
 */

public final class AdminPermission extends BasicPermission
{
    /**
     * Creates a new &lt;tt&gt;AdminPermission&lt;/tt&gt; object.
     */
    public AdminPermission()
    {
        super("AdminPermission");
    }
}
'''
table = (
    'public final class AdminPermission extends BasicPermission',
    'public AdminPermission',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4771">import sys

if sys.platform.lower().startswith('win'):


    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','AdminPermission.java'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=s,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20090529141856.4773">@language python
@tabwidth 8
    # Must be in this node when run externally.
    
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.java)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
/*
 * $Header: /cvs/leo/test/unitTest.leo,v 1.247 2008/02/14 14:59:04 edream Exp $
 * 
 * Copyright (c) OSGi Alliance (2000, 2005). All Rights Reserved.
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this 
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html.
 */

package org.osgi.framework;

/**
 * A Framework exception used to indicate that a bundle lifecycle problem
 * occurred.
 * 
 * &lt;p&gt;
 * &lt;code&gt;BundleException&lt;/code&gt; object is created by the Framework to denote
 * an exception condition in the lifecycle of a bundle.
 * &lt;code&gt;BundleException&lt;/code&gt;s should not be created by bundle developers.
 * 
 * &lt;p&gt;
 * This exception is updated to conform to the general purpose exception
 * chaining mechanism.
 * 
 * @version $Revision: 1.247 $
 */

public class BundleException extends Exception {
	static final long	serialVersionUID	= 3571095144220455665L;
	/**
	 * Nested exception.
	 */
	private Throwable	cause;

	/**
	 * Creates a &lt;code&gt;BundleException&lt;/code&gt; that wraps another exception.
	 * 
	 * @param msg The associated message.
	 * @param cause The cause of this exception.
	 */
	public BundleException(String msg, Throwable cause) {
		super(msg);
		this.cause = cause;
	}
}

'''
table = (
    'public class BundleException extends Exception',
    'public BundleException',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4774">@language python
</t>
<t tx="ekr.20090529141856.4775">@language javascript

// regexps that look like section references.

{
	name: "macro",
	match: "&lt;&lt;",
	lookaheadRegExp: /&lt;&lt;([^&gt;\s]+)(?:\s*)((?:[^&gt;]|(?:&gt;(?!&gt;)))*)&gt;&gt;/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch &amp;&amp; lookaheadMatch.index == w.matchStart &amp;&amp; lookaheadMatch[1]) {
			w.nextMatch = this.lookaheadRegExp.lastIndex;
			invokeMacro(w.output,lookaheadMatch[1],lookaheadMatch[2],w,w.tiddler);
		}
	}
},

// Comments that look like section references.

// &lt;&lt;gradient [[tiddler name]] vert|horiz rgb rgb rgb rgb... &gt;&gt;

config.macros.gradient.handler = function(place,macroName,params,wikifier)
{
	var panel = wikifier ? createTiddlyElement(place,"div",null,"gradient") : place;
	panel.style.position = "relative";
	panel.style.overflow = "hidden";
	panel.style.zIndex = "0";
	if(wikifier) {
		var styles = config.formatterHelpers.inlineCssHelper(wikifier);
		config.formatterHelpers.applyCssHelper(panel,styles);
	}
	var colours = [];
	for(var t=1; t&lt;params.length; t++) {
		var c = new RGB(params[t]);
		if(c)
			colours.push(c);
	}
	drawGradient(panel,params[0] != "vert",colours);
	if(wikifier)
		wikifier.subWikify(panel,"&gt;&gt;");
	if(document.all) {
		panel.style.height = "100%";
		panel.style.width = "100%";
	}
};

// @Deprecated: Use &lt;br&gt; or &lt;br /&gt; instead of &lt;&lt;br&gt;&gt;
config.macros.br = {};
config.macros.br.handler = function(place)
{
	createTiddlyElement(place,"br");
};
</t>
<t tx="ekr.20090529141856.4776">s = '''\

String.prototype.toJSONString = function()
{
    if(/["\\\\\\x00-\\x1f]/.test(this))
		return '"' + this.replace(/([\\x00-\\x1f\\"])/g,replaceFn) + '"';

	return '"' + this + '"';
};

'''


c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4777">s = '''\

// Convert a string to it's JSON representation by encoding control characters, double quotes and backslash. See json.org
String.prototype.toJSONString = function()
{
	var m = {
		'\\b': '\\\\b',
		'\\f': '\\\\f',
		'\\n': '\\\\n',
		'\\r': '\\\\r',
		'\\t': '\\\\t',
		'"' : '\\\\"',
		'\\\\': '\\\\\\\\'
		};
	var replaceFn = function(a,b) {
		var c = m[b];
		if(c)
			return c;
		c = b.charCodeAt();
		return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
		};
    if(/["\\\\\\x00-\\x1f]/.test(this))
		return '"' + this.replace(/([\\x00-\\x1f\\"])/g,replaceFn) + '"';

	return '"' + this + '"';
};

'''


c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4778">s = '''\

// Restarting
function restart()
{
	invokeParamifier(params,"onstart");
	if(story.isEmpty()) {
		var tiddlers = store.filterTiddlers(store.getTiddlerText("DefaultTiddlers"));
		for(var t=0; t&lt;tiddlers.length; t++) {
			story.displayTiddler("bottom",tiddlers[t].title);
		}
	}
	window.scrollTo(0,0);
}

'''


c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4780"></t>
<t tx="ekr.20090529141856.4781">s = '''\
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/head&gt;
&lt;body class='bodystring'&gt;
&lt;div id='bodydisplay'&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
c.importCommands.xmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4783"># Not a real unit test.
c.contractAllHeadlines()
</t>
<t tx="ekr.20090529141856.4784"></t>
<t tx="ekr.20090529141856.4785">if 0: # Preamble
    g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

====
top
====

The top section

section 1
---------

section 1, line 1
--
section 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''
table = (
    '!Dummy chapter',
    'top',
    'section 1',
    'section 2',
    'section 2.1',
    'section 2.1.1',
    'section 3',
    'placeholder',
    'section 3.1.1',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4786">if 0: # Preamble
    g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

top
====

The top section

section 1
---------

section 1, line 1
--
section 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''
table = (
    '!Dummy chapter',
    'top',
    'section 1',
    'section 2',
    'section 2.1',
    'section 2.1.1',
    'section 3',
    'placeholder',
    'section 3.1.1',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4787">if 0: # Preamble
    g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

top
-------------

The top section
'''
table = (
    '!Dummy chapter',
    'top',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4788">if 0: # Preamble
    g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

======
top
======

The top section
'''
table = (
    "!Dummy chapter",
    "top",
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4789">s = '''\
.. toc

.. The section name contains trailing whitespace.

======
top 
======

The top section.
'''
table = (
    "!Dummy chapter",
    "top",
)
try:
    c.importCommands.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4793">d = g.app.extra_extension_dict

for ext in g.app.extension_dict.keys():
    language =  c.importCommands.languageForExtension(ext)
    language2 = c.importCommands.languageForExtension('.'+ext)
    assert language == language2

    # Now a many-one relationship.
    if language:
        # Do not test extensions that have 'none' as the value of d.get(ext)
        # Otherwise, test only d.get(ext).
        language2 = d.get(ext)
        if language2 in ('None','none'):  continue
        if language2: language = language2
        # Made-up languages do not have mode files.
        if not language.endswith('_language') and language not in ('autohotkey','rest','rst','typescript',):
            path = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
            assert g.os_path_exists(path), 'for ext=%s does not exist: %s' % (ext,path)

    if 0:
        if language is None:
            print('no language for ext=%s' % (ext))
</t>
<t tx="ekr.20090704085350.5014">@others</t>
<t tx="ekr.20090704085350.5028">@language python
@others</t>
<t tx="ekr.20090704085350.5029">def spam():
    pass</t>
<t tx="ekr.20090704085350.5030">def eggs():
    pass</t>
<t tx="ekr.20090704085350.5034">@first
@language python
@others
</t>
<t tx="ekr.20090704085350.5035">def spam():
    pass # Unicode test:  after.
</t>
<t tx="ekr.20090704085350.5036">def eggs():
    pass
</t>
<t tx="ekr.20091206090247.5060"># Use these with caution.</t>
<t tx="ekr.20091206090247.5061">count = 0
for p in c.all_unique_positions():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print(s) ; g.es(s)</t>
<t tx="ekr.20091206090247.5062"># About the only time you should run this script is when:
# - changing the format of timestamps in nodeIndices.setTimestamp or
# - when making a retroactive change to leoID.txt.

if 0: # This is usually a very bad idea.

    for p in c.all_positions():
        p.v.fileIndex = None

    g.es("all timestamps cleared")</t>
<t tx="ekr.20091206090247.5063">doDelete = False
put = g.es_print
for p in c.all_positions():
    if p.v.u:
        put("found v.u:",p.h,
            g.listToString(p.v.u.keys()))
        if doDelete:
            p.v.u = None
put('done') 
c.redraw()</t>
<t tx="ekr.20100102164959.5088">nodes = 0 ; lines = 0
for p in c.all_unique_positions():
    nodes += 1
    lines += len(g.splitLines(p.b))

pages = ((nodes * 10) + lines) / 50
s = "%d nodes,  %d lines, %d pages" % (nodes,lines,pages)
print(s); g.es(s)</t>
<t tx="ekr.20100123172713.5114"></t>
<t tx="ekr.20100123172713.5116">count = 0
for p in c.all_unique_positions():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList"): # and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print s ; g.es(s)</t>
<t tx="ekr.20100131171342.5473"></t>
<t tx="ekr.20100131171342.5474">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)
    assert(tkGui)

    import leo.core.leoFrame as leoFrame
    import inspect,sys

    baseClass = leoFrame.leoBody
    subClasses  = (tkGui.leoTkinterBody,leoFrame.nullBody)
    baseObject = c.frame.body

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        try:
            assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)
        except AssertionError:
            exctype, value = sys.exc_info()[:2]
            print(value)
            raise

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                #raise
                exctype, value = sys.exc_info()[:2]
                print(value)
</t>
<t tx="ekr.20100131171342.5475">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoFrame
    subClasses  = (tkGui.leoTkinterFrame,leoFrame.NullFrame)
    baseObject = c.frame

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
</t>
<t tx="ekr.20100131171342.5476">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoGui as leoGui
    import inspect

    baseClass = leoGui.leoGui
    subClasses  = (tkGui.tkinterGui,) # nullGui can inherit almost all leoGui dummy methods.
    baseObject = g.app.gui

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                raise
</t>
<t tx="ekr.20100131171342.5477">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoTree
    subClasses  = (tkGui.leoTkinterTree,leoFrame.nullTree)
    baseObject = c.frame.tree

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
</t>
<t tx="ekr.20100131171342.5478">logCtrl = c.frame.log.logCtrl

table = (
    ('mustBeDefinedInSubclasses',logCtrl.mustBeDefinedInSubclasses),
    ('mustBeDefinedInBaseClass',logCtrl.mustBeDefinedOnlyInBaseClass),
    ('mustBeDefined',logCtrl.mustBeDefined),
)

# Check existence.
for tag,aList in table:
    for z in aList:
        assert hasattr(c.frame.log,z),'%s %s %s' % (tag,c.frame.log,z)
        assert hasattr(c.frame.body,z),'%s %s %s' % (tag,c.frame.body,z)

# Check signatures.
import inspect
for tag,aList in table:
    for z in aList:
        func = getattr(c.frame.body.bodyCtrl,z)
        func2 = getattr(c.frame.log.logCtrl,z)
        assert func,z
        assert func2,z
        d1 = inspect.getargspec(func)
        d2 = inspect.getargspec(func2)
        assert d1==d2,'\n%s\n\nd1 %s\n\nd2 %s' % (z,d1,d2)
</t>
<t tx="ekr.20100219080213.5365"></t>
<t tx="ekr.20100219080213.5366">s = '''\
&lt;?php

$type = 'cc';
$obj = new $type; // outputs "hi!"

class cc {
    function __construct() {
        echo 'hi!';
    }
}

?&gt;

'''

c.importCommands.phpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20100219080213.5367">s = '''\
&lt;?php

if (expr) {
    class cc {
        // version 1
    }
} else {
    class cc {
        // version 2
    }
}

?&gt;
'''

c.importCommands.phpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20100219080213.5368">s = '''\
&lt;?php
class Enum {
    protected $self = array();
    public function __construct( /*...*/ ) {
        $args = func_get_args();
        for( $i=0, $n=count($args); $i&lt;$n; $i++ )
            $this-&gt;add($args[$i]);
    }

    public function __get( /*string*/ $name = null ) {
        return $this-&gt;self[$name];
    }

    public function add( /*string*/ $name = null, /*int*/ $enum = null ) {
        if( isset($enum) )
            $this-&gt;self[$name] = $enum;
        else
            $this-&gt;self[$name] = end($this-&gt;self) + 1;
    }
}

class DefinedEnum extends Enum {
    public function __construct( /*array*/ $itms ) {
        foreach( $itms as $name =&gt; $enum )
            $this-&gt;add($name, $enum);
    }
}

class FlagsEnum extends Enum {
    public function __construct( /*...*/ ) {
        $args = func_get_args();
        for( $i=0, $n=count($args), $f=0x1; $i&lt;$n; $i++, $f *= 0x2 )
            $this-&gt;add($args[$i], $f);
    }
}
?&gt;

'''

c.importCommands.phpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20100803234640.5804"></t>
<t tx="ekr.20100803234640.5805">s = r'''; last modified 1 April 2001 by John Doe
[owner]
name=John Doe
organization=Acme Widgets Inc.

; [ not a section ]

[database]
server=192.0.2.62
    ; use IP address
port=143
file = "payroll.dat"
'''
table = ('[owner]', '[database]')
try:
    c.importCommands.iniUnitTest(p,s=s,showTree=True)
    root = c.p.firstChild()
    p2 = root.firstChild()
    for h in table:
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
    assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()

</t>
<t tx="ekr.20101009105124.6195">True (recommended):
    Write "E" attribute bits in &lt;v&gt; elements.
    Leo outlines will record the expansion state of all nodes.

False:
    (Good for files like unitTest.leo)
    Suppress "E" attribute bits in &lt;v&gt; elements.
    Only the ancestors of the presently selected node will
    be expanded when Leo opens an outline.
</t>
<t tx="ekr.20101220161557.6016"># Nov. 17, 2016: 878 tests.

# Some tests are disabled when g.app.isExternalUnitTest is True.
# Using self.skipTest(reason) is now preferred.</t>
<t tx="ekr.20110521073115.3494"></t>
<t tx="ekr.20110521073115.3495">builtins, including cython builtins
</t>
<t tx="ekr.20110521073115.3496">cython keywords
</t>
<t tx="ekr.20110615130436.3317"># This was used by @test writing a .leo file retains orphan bits.
# but this test is moot because Leo no longer writes orphan bits.</t>
<t tx="ekr.20111026105935.3966">s = '''\
&lt;nodeA&gt;
&lt;nodeB/&gt;
&lt;/nodeA&gt;
'''


c.importCommands.xmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111026111009.3972"># lowercase xml tags, one per line.

html
body
head
div
table
nodeA
nodeB
</t>
<t tx="ekr.20111029112647.4099"></t>
<t tx="ekr.20111029112647.4101">s = '''\
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/head&gt;
&lt;body class="bodystring"&gt;
&lt;div id='bodydisplay'&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
table = [
    '&lt;html&gt;',
    '&lt;head&gt;',
    '&lt;body class="bodystring"&gt;',
]
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    root = c.p.firstChild()
    assert root.h.endswith('lowercase tags'), root.h
    p2 = root.firstChild()
    for i, h in enumerate(table):
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20111029120441.3982">s = '''\
&lt;HTML&gt;
&lt;HEAD&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/HEAD&gt;
&lt;BODY class='bodystring'&gt;
&lt;DIV id='bodydisplay'&gt;&lt;/DIV&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
'''


c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111102164107.3975">s = r'''
&lt;td width="550"&gt;
&lt;table cellspacing="0" cellpadding="0" width="600" border="0"&gt;
    &lt;td class="blutopgrabot" height="28"&gt;&lt;/td&gt;
    
    &lt;!-- The indentation of this element causes the problem. --&gt;
    &lt;table&gt;
    
&lt;!--
&lt;div align="center"&gt;
&lt;iframe src="http://www.amex.com/atamex/regulation/listingStatus/index.jsp"&lt;/iframe&gt;
&lt;/div&gt;
--&gt;

&lt;/table&gt;
&lt;/table&gt;

&lt;p&gt;Paragraph&lt;/p&gt;
&lt;/td&gt;

'''
table = (
    '&lt;td width="550"&gt;',
    '&lt;table cellspacing="0" cellpadding="0" width="600" border="0"&gt;',
    '&lt;table&gt;',
)
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    p2 = c.p.firstChild().firstChild()
    for i, h in enumerate(table):
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20111107102431.3849"># A good test, but we don't want this large a file included in the distro.

# fn = r'c:\recent\data4.html'
fn = r'c:\recent\data.html'

root = p.copy()

# Fails with more tags: a newline gets inserted between tags.

html_tags = ('body','head','html','table','xxx',)
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

try:
    c.importCommands.importFilesCommand(files=[fn],treeType='@file')
finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete()
        c.redraw()
    assert not root.hasChildren()

fail = g.app.unitTestDict.get('fail')
assert not fail
</t>
<t tx="ekr.20111109143012.3839">@language html
    # Essential for the unit test.
    
# This part of the test file caused lots of problems.

s = '''

&lt;html&gt;

&lt;body&gt;

&lt;table id="0"&gt;
&lt;tr valign="top"&gt;
&lt;td width="619"&gt;
	&lt;table id="2"&gt;	&lt;tr valign="top"&gt;	&lt;td width="377"&gt;
		&lt;table id="3"&gt;
		&lt;tr&gt;
		&lt;td width="368"&gt;
			&lt;table id="4"&gt;

&lt;tbody id="5"&gt;

&lt;tr valign="top"&gt;
&lt;td width="550"&gt;
&lt;table id="6"&gt;

&lt;tbody id="6"&gt;
&lt;tr&gt;

&lt;td class="blutopgrabot"&gt;&lt;a href="href1"&gt;Listing Standards&lt;/a&gt; | &lt;a href="href2"&gt;Fees&lt;/a&gt; | &lt;strong&gt;Non-compliant Issuers&lt;/strong&gt; | &lt;a href="href3"&gt;Form 25 Filings&lt;/a&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;

&lt;/table&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;
&lt;td width="100%" colspan="2"&gt;


&lt;br /&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;	
							&lt;/td&gt;
						&lt;/tr&gt;
						&lt;/table&gt;

	&lt;!-- View First part --&gt;	&lt;/td&gt;	&lt;td width="242"&gt;	&lt;!-- View Second part --&gt;

	&lt;!-- View Second part --&gt;	&lt;/td&gt;	&lt;/tr&gt;&lt;/table&gt;										


&lt;DIV class="webonly"&gt;

&lt;script src="/scripts/footer.js"&gt;&lt;/script&gt;
	
&lt;/DIV&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;script language="JavaScript1.1"&gt;var SA_ID="nyse;nyse";&lt;/script&gt;
&lt;script language="JavaScript1.1" src="/scripts/stats/track.js"&gt;&lt;/script&gt;
&lt;noscript&gt;&lt;img src="/scripts/stats/track.js" height="1" width="1" alt="" border="0"&gt;&lt;/noscript&gt;
&lt;/body&gt;
&lt;/html&gt;

'''

c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111112092813.4154">g.cls()</t>
<t tx="ekr.20111112093605.4679"># leoSettings.leo no longer sets any bindings for run-xxx-unit-test.
# These are now EKR's preferred settings everywhere:
# there should be little need to run unit tests externally.

run-selected-unit-tests-locally     = Alt-4
run-marked-unit-tests-locally       = Alt-5
run-all-unit-tests-locally          = Alt-6

# Important: Alt-9 is used by a unit test
</t>
<t tx="ekr.20111112103320.3849">s = '''\
&lt;body&gt;

&lt;!-- OOPS: the div and p elements not properly nested.--&gt;
&lt;!-- OOPS: this table got generated twice. --&gt;

&lt;p id="P1"&gt;
&lt;div id="D666"&gt;Paragraph&lt;/p&gt; &lt;!-- P1 --&gt;
&lt;p id="P2"&gt;

&lt;TABLE id="T666"&gt;&lt;/TABLE&gt;&lt;/p&gt; &lt;!-- P2 --&gt;
&lt;/div&gt;
&lt;/p&gt; &lt;!-- orphan --&gt;

&lt;/body&gt;
'''


c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111112103320.3887">s = r'''
&lt;html&gt;

&lt;head&gt;
    &lt;!-- oops: link elements terminated two different ways --&gt;
    &lt;link id="L1"&gt;
    &lt;link id="L2"&gt;
    &lt;link id="L3" /&gt;
    &lt;link id='L4' /&gt;
    
    &lt;title&gt;TITLE&lt;/title&gt;
    
&lt;!-- oops: missing tags. --&gt;
'''
table = ('&lt;html&gt;', '&lt;head&gt;', '&lt;link id="L1"&gt;')
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    p2 = c.p.firstChild().firstChild()
    for i, h in enumerate(table):
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20111112103320.3893">s = '''
&lt;html&gt;
&lt;head&gt;
    &lt;!-- oops: link elements terminated two different ways --&gt;
    &lt;link id="L1"&gt;
    &lt;link id="L2"&gt;
    &lt;link id="L3" /&gt;
    &lt;link id='L4' /&gt;
    
    &lt;title&gt;TITLE&lt;/title&gt;
    
&lt;/head&gt;
&lt;/html&gt;
'''
table = ('&lt;html&gt;', '&lt;head&gt;', '&lt;link id="L1"&gt;')
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    p2 = c.p.firstChild().firstChild()
    for h in table:
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20111115080347.3872"></t>
<t tx="ekr.20111123042627.6654"># Leo loads plugins in the order they appear here.

# **Important**: to change these defaults, put
# an @enabled-plugins node in myLeoSettings.leo.

# Highly-recommended plugins:
plugins_menu.py
free_layout.py # needs to be early
viewrendered.py

# Recommended plugins:
### contextmenu.py
# leo_to_html.py
mod_scripting.py
# nav_qt.py
# quicksearch.py
# stickynotes.py
# todo.py
</t>
<t tx="ekr.20111124094121.3941"># These exist for a unit test.</t>
<t tx="ekr.20111124094121.3942"></t>
<t tx="ekr.20111124094121.3943"></t>
<t tx="ekr.20111125182408.3947">def setup():
    while p.hasChildren():
        p.firstChild().doDelete()

setup()

try:
    files = (r'a\b.c',r'a\b.h',)
    c.importCommands.createImportParent(p,files)
    child = p.firstChild()
    assert child
    assert child.h == 'a/b',child.h
finally:
    setup()</t>
<t tx="ekr.20111125183140.3952">child = p.firstChild()
def setup():
    while p.hasChildren():
        p.firstChild().doDelete()

setup()
try:
    c.importCommands.createOutline(
        fileName=r'a\b\c.xyzzy',
        parent=p,
        atAuto=False,atShadow=False,
        s='test body',
        ext='xyzzy'
    )
    child = p.firstChild()
    assert child
    h = g.os_path_finalize_join(g.app.loadDir,'..','test','a','b','c.xyzzy')
    h = h.replace('\\','/')
    h = '@file ' + h
    # C: vs c: is not relevant here.
    assert child.h.lower() == h.lower(),child.h
finally:
    setup()</t>
<t tx="ekr.20111211094936.3970"></t>
<t tx="ekr.20111213122041.3930">@language python
@tabwidth -4

# Begin

@others

# End
</t>
<t tx="ekr.20111214100515.3921"># Disabled: this now fails *regardless* of python.v2 switch

ic = c.importCommands

def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

fn = g.os_path_finalize_join(g.app.loadDir,'..','test','unittest','at-auto-section-ref-test.py')
# fn = r'c:\Users\edreamleo\at-auto-test.py'
assert g.os_path_exists(fn),fn

try:
    setup(p)
    child = p.insertAsNthChild(0)
    child.h = 'child'
    assert child

    ic.errors = 0
    ic.createOutline (fn,parent=child,atAuto=True,atShadow=False,s=None,ext=None)
    assert ic.errors == 0
finally:
    setup(p)
    c.redraw(p)
</t>
<t tx="ekr.20111214104615.3942">@language python
@tabwidth -4
@others
# end.
</t>
<t tx="ekr.20120306173116.3933">@first # -*- coding: utf-8 -*-

s = '''\
&lt;:.&gt;
&lt;&gt;
&lt;_.&gt;
'''


c.importCommands.xmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20121011094154.3906">@language python
</t>
<t tx="ekr.20121011094154.3911">s = '''

class Greeter {
    greeting: string;
    constructor (message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

var greeter = new Greeter("world");

var button = document.createElement('button')
button.innerText = "Say Hello"
button.onclick = function() {
    alert(greeter.greet())
}

document.body.appendChild(button)

'''

c.importCommands.typeScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20121011100210.4035">s = '''

module Sayings {
    export class Greeter {
        greeting: string;
        constructor (message: string) {
            this.greeting = message;
        }
        greet() {
            return "Hello, " + this.greeting;
        }
    }
}
var greeter = new Sayings.Greeter("world");

var button = document.createElement('button')
button.innerText = "Say Hello"
button.onclick = function() {
	alert(greeter.greet())
}

document.body.appendChild(button)


'''

c.importCommands.typeScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20131111155830.4249"></t>
<t tx="ekr.20131111155830.4250"># Not yet...

    &lt;BS&gt;        delete the character in front of the cursor
N   &lt;Del&gt;       delete N characters under and after the cursor
    &lt;Del&gt;       delete the character under the cursor
    &lt;Del&gt;       while entering a count: delete last character
    &lt;Down&gt;      recall newer command-line that starts with current command
    &lt;Esc&gt;       abandon command-line (if 'wildchar' is &lt;Esc&gt;, type it twice)
    &lt;Left&gt;      (motion) cursor left
    &lt;Right&gt;     (motion) cursor right
    &lt;S-Down&gt;    recall newer command-line from history
    &lt;S-Left&gt;    (motion) cursor one word left
    &lt;S-Right&gt;   (motion) cursor one word right
    &lt;S-Up&gt;      recall older command-line from history
    &lt;Up&gt;        recall older command-line that starts with current command

N   CTRL-^                  Edit alternate file N (equivalent to ":e #N").
N   CTRL-A                  add N to the number at or after the cursor
N   CTRL-B                  window N pages Backwards (upwards)
    CTRL-B                  (motion?) cursor to beginning of command-line
    CTRL-BREAK              MS-DOS: during searches: interrupt the search
    CTRL-C                  during searches: interrupt the search
N   CTRL-D                  window N lines Downwards (default: 1/2 window)
N   CTRL-E                  window N lines downwards (default: 1)
    CTRL-E                  (motion?) cursor to end of command-line
N   CTRL-F                  (motion) window N pages Forwards (downwards)
    CTRL-G                  show current file name (with path) and cursor position
N   CTRL-I                  (motion) go to Nth newer position in jump list
    CTRL-K {char1} {char2}  enter digraph
    CTRL-L                  Clear and redraw the screen.
N   CTRL-O                  (motion) go to Nth older position in jump list
N   CTRL-R                  redo last N undone changes
    CTRL-R &lt;0-9a-z"%:-&gt;     insert contents of register &lt;0-9a-z"%:-&gt;
N   CTRL-T                  (motion) Jump back from Nth older tag in tag list
N   CTRL-U                  window N lines Upwards (default: 1/2 window)
    CTRL-U                  remove all characters
    CTRL-V                  highlight blockwise or stop highlighting
    CTRL-V                  start highlighting blockwise   }  highlighted text
    CTRL-V {char}           insert {char} literally
    CTRL-V {number}         enter decimal value of character (up to three digits)
    CTRL-W                  delete the word in front of the cursor
    CTRL-W +                Increase current window height
    CTRL-W -                Decrease current window height
    CTRL-W =                Make all windows equal height
    CTRL-W CTRL-W           Move cursor to window below (wrap)
    CTRL-W CTRL-^           Split window and edit alternate file
    CTRL-W R                Rotate windows upwards
    CTRL-W W                Move cursor to window above (wrap)
    CTRL-W ]                Split window and jump to tag under cursor
    CTRL-W _                Set current window height (default: very high)
    CTRL-W b                Move cursor to bottom window
    CTRL-W c  or :cl[ose]   Make buffer hidden and close window
    CTRL-W f                Split window and edit file name under the cursor
    CTRL-W j                Move cursor to window below
    CTRL-W k                Move cursor to window above
    CTRL-W n  or :new       Create new empty window
    CTRL-W o  or :on[ly]    Make current window only one on the screen
    CTRL-W p                Move cursor to previous active window
    CTRL-W q  or :q[uit]    Quit editing and close window
    CTRL-W r                Rotate windows downwards
    CTRL-W s                Split window into two parts
    CTRL-W t                Move cursor to top window
    CTRL-W x                Exchange current window with next one
N   CTRL-X                  subtract N from the number at or after the cursor
N   CTRL-Y                  window N lines upwards (default: 1)
    CTRL-Z                  Same as ":stop!"
    CTRL-]                  Jump to the tag under cursor, unless changes have been made</t>
<t tx="ekr.20131111155830.4251">char F
char T
char f
char r
char t
letter m
letter q
motion &lt;
motion &gt;
motion c
motion d
motion gU
motion gq
motion gu
motion g~
motion y
pattern /
pattern ?
register @
</t>
<t tx="ekr.20131111155830.4252"># http://tnerual.eriogerg.free.fr/vimqrc.html
vim_0 0
vim_tilda ~
vim_plus +
vim_underscore _
vim_minus -
vim_comma ,
vim_dot .
vim_semicolon ;
vim_lparen (
vim_rparen )
vim_lcurly {
vim_rcurly }
vim_vertical |
vim_backtick `
vim_dollar $
vim_caret ^
vim_percent %
vim_langle &lt;
vim_langle &lt;&lt;
vim_rangle &gt;
vim_rangle &gt;&gt;
vim_pound #
vim_star *
vim_slash /\\n
vim_slash /
vim_question ?\\n
vim_question ?
vim_at @
vim_at @@
vim_dquote "
vim_lsquare [#
vim_lsquare [(
vim_lsquare [*
vim_lsquare [[
vim_lsquare []
vim_lsquare [p
vim_lsquare [{
vim_rsquare ]#
vim_rsquare ])
vim_rsquare ]*
vim_rsquare ][
vim_rsquare ]]
vim_rsquare ]p
vim_rsquare ]}
vim_A A
vim_B B
vim_C C
vim_D D
vim_E E
vim_F F
vim_G G
vim_H H
vim_I I
vim_J J
vim_K K
vim_M M
vim_L L
vim_N N
vim_O O
vim_P P
vim_R R
vim_S S
vim_T T
vim_U U
vim_V V
vim_W W
vim_X X
vim_Y Y
vim_Z ZQ
vim_Z ZZ
vim_a a
vim_b b
vim_c c
vim_d dd
vim_d d
vim_g g~
vim_g g^
vim_g g#
vim_g g$
vim_g g*
vim_g g0
vim_g gD
vim_g gE
vim_g gI
vim_g gU
vim_g ga
vim_g gd
vim_g ge
vim_g gf
vim_g gg
vim_g gj
vim_g gk
vim_g gq
vim_g gs
vim_g gu
vim_g gv
vim_h h
vim_i i
vim_j j
vim_k k
vim_l l
vim_n n
vim_m m
vim_o o
vim_p p
vim_q q
vim_r r
vim_s s
vim_t t
vim_u u
vim_v v
vim_w w
vim_x x
vim_y y
vim_y yy
vim_z z-
vim_z z.
vim_z z&lt;CR&gt;
vim_z zb
vim_z zh
vim_z zl
vim_z zt
vim_z zz
</t>
<t tx="ekr.20131111155830.4253"># CR
# Ctrl-End
# Ctrl-Home
# Ctrl-Left
# Ctrl-M
# Ctrl-N
# Ctrl-P
# Ctrl-Right
# End
# Home
# Shift-Left
# Shift-Right

( 	
)
{
}
[[
[]
][
]]
$
^	
+
,
-
;
_
0
B
E
F
G
T
W
b
e
f
g$
g^
g0
gE
# gEnd
# gHome	
ge
gg
h
j
k
t
w
</t>
<t tx="ekr.20131111155830.4254">char F
char T
char f
char t
</t>
<t tx="ekr.20140206132559.4560">@others
</t>
<t tx="ekr.20140206132559.4564">@others
bClass = aClass
</t>
<t tx="ekr.20140206132559.4567">tm = c.testManager
before   = g.findNodeInTree(c,p,'before')
expected = g.findNodeInTree(c,p,'expected')
assert before,expected
try:
    c.selectPosition(before)
    before.h = 'expected' # To make the compare work.
    c.importCommands.parse_body(before)
    # compare tree.
    assert tm.compareOutlines(before,expected,compareHeadlines=True,tag='',report=True)
    c.undoer.undo()
finally:
    before.h = 'before'
    c.redraw()
</t>
<t tx="ekr.20140217055617.4231"># For a unit test.</t>
<t tx="ekr.20140218042220.4347">s = '''\

var c3 = (function () {
    "use strict";

    // Globals
    var c3 = { version: "0.0.1"   };

    c3.someFunction = function () {
        console.log("Just a demo...");
    };

    return c3;
}());

'''

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20140218122321.4349">@language html

s = '''
&lt;!-- tags that start nodes: html,body,head,div,table,nodeA,nodeB --&gt;
&lt;html&gt;&lt;head&gt;headline&lt;/head&gt;&lt;body&gt;body&lt;/body&gt;&lt;/html&gt;
'''


c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20140218151418.4353">s = '''\
var express = require('express');

var app = express.createServer(express.logger());

app.get('/', function(request, response) {
response.send('Hello World!');
});

var port = process.env.PORT || 5000;
app.listen(port, function() {
console.log("Listening on " + port);
});
'''

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20140716121225.4354">print(p.v.gnx)</t>
<t tx="ekr.20140723134017.4464"># This causes problems!
import glob
import importlib
path = g.os_path_finalize_join(g.app.loadDir,'..','plugins','importers')
# print('path: %s' % path)
assert g.os_path_exists(path)
pattern = g.os_path_finalize_join(path,'*.py')
for fn in glob.glob(pattern):
    sfn = g.shortFileName(fn)
    m = importlib.import_module('leo.plugins.importers.%s' % sfn[:-3])
    assert m
</t>
<t tx="ekr.20140724164600.4590"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of leoImport tests.')
</t>
<t tx="ekr.20140724220921.5199"></t>
<t tx="ekr.20140725132959.4593">s = '''\
.. toc

.. The section name contains trailing whitespace.

=======
Chapter 
=======

The top chapter.
'''
table = (
    "!Dummy chapter",
    "Chapter",
)
try:
    c.importCommands.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20140902101931.4478"></t>
<t tx="ekr.20150208213643.12">def spam():
    pass</t>
<t tx="ekr.20150208213643.13">def eggs():
    pass</t>
<t tx="ekr.20150208213643.15">def spam():
    pass</t>
<t tx="ekr.20150208213643.16">def eggs():
    pass</t>
<t tx="ekr.20150208213643.18"># node 1 text A.
</t>
<t tx="ekr.20150208213643.19"># node 2 text B.
</t>
<t tx="ekr.20150216110251.11"># Do not delete this node.
# It is used by unit tests.</t>
<t tx="ekr.20150321155210.11"></t>
<t tx="ekr.20150602215639.1">True: Automatically beautify all @&lt;file&gt; nodes when saving an outline.

# This *must* be False in unitTest.leo!</t>
<t tx="ekr.20150625052701.1">gnx: ekr.20080904084223.1
</t>
<t tx="ekr.20150625091937.3">gnx: ekr.20110610122533.3407
</t>
<t tx="ekr.20150625134618.1">gnx: ekr.20150625134601.13
unl: at_auto_child
</t>
<t tx="ekr.20150626093653.1"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = True
    h = '@auto-rst unittest/at-auto-rst-line-number-test.py'
    root = g.findNodeAnywhere(c, h)
    assert root
    assert root.isAtAutoRstNode(), root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        g.cls()
        print('get_external_file_with_sentinels returns...')
        # print(''.join(['%3s %r' % (i, s) for i, s in enumerate(g.splitLines(s))]))
        g.printList(g.splitLines(s))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n, offset, p and p.h))
        else:
            if trace: print('not found: %s' % n)
            assert n == 9, n
            break
</t>
<t tx="ekr.20150626093952.1">gnx: ekr.20150626093745.1
</t>
<t tx="ekr.20150626100832.1">gnx: ekr.20150626100719.1
</t>
<t tx="ekr.20150626101730.1">gnx: ekr.20150626101627.1
</t>
<t tx="ekr.20150626101920.1"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto unittest/at-auto-md-line-number-test.md'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        g.cls()
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n, offset, p and p.h))
        else:
            if trace: print('not found: %s' % n)
            assert n == 7, n
            break
</t>
<t tx="ekr.20150626102601.1">gnx: ekr.20150626101842.1
</t>
<t tx="ekr.20150919073819.1">class aClass:
    def __init__(self):
        pass
    def spam(self):
        pass
bClass = aClass
</t>
<t tx="ekr.20150919074122.1">tm = c.testManager
before   = g.findNodeInTree(c,p,'before')
expected = g.findNodeInTree(c,p,'expected')
assert before,expected
try:
    c.selectPosition(before)
    before.h = 'expected' # To make the compare work.
    c.importCommands.parse_body(before)
    # compare tree.
    assert tm.compareOutlines(before,expected,compareHeadlines=True,tag='',report=True)
    c.undoer.undo()
finally:
    before.h = 'before'
    c.redraw()
</t>
<t tx="ekr.20150919074132.1">@others
</t>
<t tx="ekr.20150919074154.1">@others
</t>
<t tx="ekr.20150919074211.1">class TypeJoinVisitor(TypeVisitor[Type]):
    """Implementation of the least upper bound algorithm.

    Attributes:
      s: The other (left) type operand.
    """
    @others
</t>
<t tx="ekr.20150919074211.10">def visit_erased_type(self, t: ErasedType) -&gt; Type:
    return self.s

</t>
<t tx="ekr.20150919074211.11">def visit_type_var(self, t: TypeVarType) -&gt; Type:
    if isinstance(self.s, TypeVarType) and (cast(TypeVarType, self.s)).id == t.id:
        return self.s
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20150919074211.12">def visit_instance(self, t: Instance) -&gt; Type:
    if isinstance(self.s, Instance):
        return join_instances(t, cast(Instance, self.s))
    elif isinstance(self.s, FunctionLike):
        return join_types(t, self.s.fallback)
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20150919074211.13">def visit_callable_type(self, t: CallableType) -&gt; Type:
    # TODO: Consider subtyping instead of just similarity.
    if isinstance(self.s, CallableType) and is_similar_callables(
            t, cast(CallableType, self.s)):
        return combine_similar_callables(t, cast(CallableType, self.s))
    elif isinstance(self.s, Overloaded):
        # Switch the order of arguments to that we'll get to visit_overloaded.
        return join_types(t, self.s)
    else:
        return join_types(t.fallback, self.s)

</t>
<t tx="ekr.20150919074211.14">def visit_overloaded(self, t: Overloaded) -&gt; Type:
    # This is more complex than most other cases. Here are some
    # examples that illustrate how this works.
    #
    # First let's define a concise notation:
    #  - Cn are callable types (for n in 1, 2, ...)
    #  - Ov(C1, C2, ...) is an overloaded type with items C1, C2, ...
    #  - Callable[[T, ...], S] is written as [T, ...] -&gt; S.
    #
    # We want some basic properties to hold (assume Cn are all
    # unrelated via Any-similarity):
    #
    #   join(Ov(C1, C2), C1) == C1
    #   join(Ov(C1, C2), Ov(C1, C2)) == Ov(C1, C2)
    #   join(Ov(C1, C2), Ov(C1, C3)) == C1
    #   join(Ov(C2, C2), C3) == join of fallback types
    #
    # The presence of Any types makes things more interesting. The join is the
    # most general type we can get with respect to Any:
    #
    #   join(Ov([int] -&gt; int, [str] -&gt; str), [Any] -&gt; str) == Any -&gt; str
    #
    # We could use a simplification step that removes redundancies, but that's not
    # implemented right now. Consider this example, where we get a redundancy:
    #
    #   join(Ov([int, Any] -&gt; Any, [str, Any] -&gt; Any), [Any, int] -&gt; Any) ==
    #       Ov([Any, int] -&gt; Any, [Any, int] -&gt; Any)
    #
    # TODO: Use callable subtyping instead of just similarity.
    result = []  # type: List[CallableType]
    s = self.s
    if isinstance(s, FunctionLike):
        # The interesting case where both types are function types.
        for t_item in t.items():
            for s_item in s.items():
                if is_similar_callables(t_item, s_item):
                    result.append(combine_similar_callables(t_item, s_item))
        if result:
            # TODO: Simplify redundancies from the result.
            if len(result) == 1:
                return result[0]
            else:
                return Overloaded(result)
        return join_types(t.fallback, s.fallback)
    return join_types(t.fallback, s)

</t>
<t tx="ekr.20150919074211.15">def visit_tuple_type(self, t: TupleType) -&gt; Type:
    if (isinstance(self.s, TupleType) and
            cast(TupleType, self.s).length() == t.length()):
        items = []  # type: List[Type]
        for i in range(t.length()):
            items.append(self.join(t.items[i],
                                   (cast(TupleType, self.s)).items[i]))
        # TODO: What if the fallback types are different?
        return TupleType(items, t.fallback)
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20150919074211.16">def join(self, s: Type, t: Type) -&gt; Type:
    return join_types(s, t)

</t>
<t tx="ekr.20150919074211.17">def default(self, typ: Type) -&gt; Type:
    if isinstance(typ, Instance):
        return object_from_instance(typ)
    elif isinstance(typ, UnboundType):
        return AnyType()
    elif isinstance(typ, Void) or isinstance(typ, ErrorType):
        return ErrorType()
    elif isinstance(typ, TupleType):
        return self.default(typ.fallback)
    elif isinstance(typ, FunctionLike):
        return self.default(typ.fallback)
    elif isinstance(typ, TypeVarType):
        return self.default(typ.upper_bound)
    else:
        return AnyType()
</t>
<t tx="ekr.20150919074211.2">
def __init__(self, s: Type) -&gt; None:
    self.s = s

</t>
<t tx="ekr.20150919074211.3">def visit_unbound_type(self, t: UnboundType) -&gt; Type:
    if isinstance(self.s, Void) or isinstance(self.s, ErrorType):
        return ErrorType()
    else:
        return AnyType()

</t>
<t tx="ekr.20150919074211.4">def visit_union_type(self, t: UnionType) -&gt; Type:
    if is_subtype(self.s, t):
        return t
    else:
        return UnionType(t.items + [self.s])

</t>
<t tx="ekr.20150919074211.5">def visit_error_type(self, t: ErrorType) -&gt; Type:
    return t

</t>
<t tx="ekr.20150919074211.6">def visit_type_list(self, t: TypeList) -&gt; Type:
    assert False, 'Not supported'

</t>
<t tx="ekr.20150919074211.7">def visit_any(self, t: AnyType) -&gt; Type:
    return t

</t>
<t tx="ekr.20150919074211.8">def visit_void(self, t: Void) -&gt; Type:
    if isinstance(self.s, Void):
        return t
    else:
        return ErrorType()

</t>
<t tx="ekr.20150919074211.9">def visit_none_type(self, t: NoneTyp) -&gt; Type:
    if not isinstance(self.s, Void):
        return self.s
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20150919074220.1">class TypeJoinVisitor(TypeVisitor[Type]):
    """Implementation of the least upper bound algorithm.

    Attributes:
      s: The other (left) type operand.
    """

    def __init__(self, s: Type) -&gt; None:
        self.s = s

    def visit_unbound_type(self, t: UnboundType) -&gt; Type:
        if isinstance(self.s, Void) or isinstance(self.s, ErrorType):
            return ErrorType()
        else:
            return AnyType()

    def visit_union_type(self, t: UnionType) -&gt; Type:
        if is_subtype(self.s, t):
            return t
        else:
            return UnionType(t.items + [self.s])

    def visit_error_type(self, t: ErrorType) -&gt; Type:
        return t

    def visit_type_list(self, t: TypeList) -&gt; Type:
        assert False, 'Not supported'

    def visit_any(self, t: AnyType) -&gt; Type:
        return t

    def visit_void(self, t: Void) -&gt; Type:
        if isinstance(self.s, Void):
            return t
        else:
            return ErrorType()

    def visit_none_type(self, t: NoneTyp) -&gt; Type:
        if not isinstance(self.s, Void):
            return self.s
        else:
            return self.default(self.s)

    def visit_erased_type(self, t: ErasedType) -&gt; Type:
        return self.s

    def visit_type_var(self, t: TypeVarType) -&gt; Type:
        if isinstance(self.s, TypeVarType) and (cast(TypeVarType, self.s)).id == t.id:
            return self.s
        else:
            return self.default(self.s)

    def visit_instance(self, t: Instance) -&gt; Type:
        if isinstance(self.s, Instance):
            return join_instances(t, cast(Instance, self.s))
        elif isinstance(self.s, FunctionLike):
            return join_types(t, self.s.fallback)
        else:
            return self.default(self.s)

    def visit_callable_type(self, t: CallableType) -&gt; Type:
        # TODO: Consider subtyping instead of just similarity.
        if isinstance(self.s, CallableType) and is_similar_callables(
                t, cast(CallableType, self.s)):
            return combine_similar_callables(t, cast(CallableType, self.s))
        elif isinstance(self.s, Overloaded):
            # Switch the order of arguments to that we'll get to visit_overloaded.
            return join_types(t, self.s)
        else:
            return join_types(t.fallback, self.s)

    def visit_overloaded(self, t: Overloaded) -&gt; Type:
        # This is more complex than most other cases. Here are some
        # examples that illustrate how this works.
        #
        # First let's define a concise notation:
        #  - Cn are callable types (for n in 1, 2, ...)
        #  - Ov(C1, C2, ...) is an overloaded type with items C1, C2, ...
        #  - Callable[[T, ...], S] is written as [T, ...] -&gt; S.
        #
        # We want some basic properties to hold (assume Cn are all
        # unrelated via Any-similarity):
        #
        #   join(Ov(C1, C2), C1) == C1
        #   join(Ov(C1, C2), Ov(C1, C2)) == Ov(C1, C2)
        #   join(Ov(C1, C2), Ov(C1, C3)) == C1
        #   join(Ov(C2, C2), C3) == join of fallback types
        #
        # The presence of Any types makes things more interesting. The join is the
        # most general type we can get with respect to Any:
        #
        #   join(Ov([int] -&gt; int, [str] -&gt; str), [Any] -&gt; str) == Any -&gt; str
        #
        # We could use a simplification step that removes redundancies, but that's not
        # implemented right now. Consider this example, where we get a redundancy:
        #
        #   join(Ov([int, Any] -&gt; Any, [str, Any] -&gt; Any), [Any, int] -&gt; Any) ==
        #       Ov([Any, int] -&gt; Any, [Any, int] -&gt; Any)
        #
        # TODO: Use callable subtyping instead of just similarity.
        result = []  # type: List[CallableType]
        s = self.s
        if isinstance(s, FunctionLike):
            # The interesting case where both types are function types.
            for t_item in t.items():
                for s_item in s.items():
                    if is_similar_callables(t_item, s_item):
                        result.append(combine_similar_callables(t_item, s_item))
            if result:
                # TODO: Simplify redundancies from the result.
                if len(result) == 1:
                    return result[0]
                else:
                    return Overloaded(result)
            return join_types(t.fallback, s.fallback)
        return join_types(t.fallback, s)

    def visit_tuple_type(self, t: TupleType) -&gt; Type:
        if (isinstance(self.s, TupleType) and
                cast(TupleType, self.s).length() == t.length()):
            items = []  # type: List[Type]
            for i in range(t.length()):
                items.append(self.join(t.items[i],
                                       (cast(TupleType, self.s)).items[i]))
            # TODO: What if the fallback types are different?
            return TupleType(items, t.fallback)
        else:
            return self.default(self.s)

    def join(self, s: Type, t: Type) -&gt; Type:
        return join_types(s, t)

    def default(self, typ: Type) -&gt; Type:
        if isinstance(typ, Instance):
            return object_from_instance(typ)
        elif isinstance(typ, UnboundType):
            return AnyType()
        elif isinstance(typ, Void) or isinstance(typ, ErrorType):
            return ErrorType()
        elif isinstance(typ, TupleType):
            return self.default(typ.fallback)
        elif isinstance(typ, FunctionLike):
            return self.default(typ.fallback)
        elif isinstance(typ, TypeVarType):
            return self.default(typ.upper_bound)
        else:
            return AnyType()
</t>
<t tx="ekr.20150919074321.1">class aClass:
    @others
</t>
<t tx="ekr.20150919074321.2">def __init__(self):
    pass
</t>
<t tx="ekr.20150919074321.3">def spam(self):
    pass
</t>
<t tx="ekr.20160403143048.1">@language c
@tabwidth -4
// before @others // line 1
@others
// last line: line 6
</t>
<t tx="ekr.20160403143048.2">@nocolor-node
def spam(): // line 2
    pass
</t>
<t tx="ekr.20160403143130.1">@language python
@tabwidth -4
# Before @others: line 1
@others
# Last line: line 6
</t>
<t tx="ekr.20160403143348.1">gnx: ekr.20111214104615.3942
</t>
<t tx="ekr.20160403143348.2">gnx: ekr.20160403142841.9
unl: at-auto-section-ref-test declarations
</t>
<t tx="ekr.20160403143351.1">gnx: ekr.20090704085350.5056
</t>
<t tx="ekr.20160403143351.2">gnx: ekr.20160403142841.10
unl: spam
gnx: ekr.20160403142841.11
unl: eggs
</t>
<t tx="ekr.20160403150121.1">def eggs(): // line 4
    pass</t>
<t tx="ekr.20160403150216.1">@nocolor-node
def spam(): # line 2
    pass
</t>
<t tx="ekr.20160403150222.1">def eggs(): # line 4
    pass
</t>
<t tx="ekr.20160403152507.1">def eggs(): # line 4
    pass</t>
<t tx="ekr.20160410152100.1"></t>
<t tx="ekr.20160410152100.2">&lt;&lt; define s &gt;&gt;
if 0:
    # The preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    ic = leoImport.LeoImportCommands(c)
    # x = markdown.Markdown_Importer(ic, atAuto=False)
else:
    ic = c.importCommands  
try:
    ic.markdownUnitTest(p,s=s,showTree=True) # Must be true.
    table = (
        (1, 'Top'),
        (2, 'Section 1'),
        (2, 'Section 2'),
        (3, 'Section 2.1'),
        (4, 'Section 2.1.1'),
        (3, 'Section 2.2'),
        (2, 'Section 3'),
    )
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@auto-m'), root.h
    p = root.firstChild()
    for n, h in table:
        n2 = p.level() - root.level()
        assert h == p.h, (h, p.h)
        assert n == n2, (n, n2, p.h)
        p.moveToThreadNext()
    assert p == after, p.h
finally:
    if 1:
        if root:
            root.doDelete()
        c.redraw()
</t>
<t tx="ekr.20160411033840.1">&lt;&lt; define s &gt;&gt;
if 0:
    # The preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    # imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    ic = leoImport.LeoImportCommands(c)
    # x = markdown.Markdown_Importer(ic, atAuto=False)
else:
    ic = c.importCommands  
try:
    ic.markdownUnitTest(p,s=s,showTree=True) # Must be True.
    table = (
        (1, 'Top'),
        (2, 'Section 1'),
        (2, 'Section 2'),
        (3, 'Section 2.1'),
        (4, 'Section 2.1.1'),
        (3, 'Section 2.2'),
        (2, 'Section 3'),
    )
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@auto-m'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, p.h
finally:
    if 1:
        if root:
            root.doDelete()
        c.redraw()
</t>
<t tx="ekr.20160411034540.1">s = '''\
#Top
The top section

##Section 1
section 1, line 1
section 1, line 2

##Section 2
section 2, line 1

###Section 2.1
section 2.1, line 1

####Section 2.1.1
section 2.2.1 line 1
The next section is empty. It must not be deleted.

###Section 2.2

##Section 3
Section 3, line 1

'''
</t>
<t tx="ekr.20160917122402.1">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20160917122402.2">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20160917122402.3">gnx: ekr.20090627070131.4976
unl: spam
gnx: ekr.20090627070131.4977
unl: cheese
</t>
<t tx="ekr.20160917122402.4">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20160917122402.5">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20160917122402.6">gnx: ekr.20100801125533.5789
unl: spam
gnx: ekr.20100801125533.5790
unl: cheese
</t>
<t tx="ekr.20161011052016.1">import leo.plugins.importers.javascript as js
table = (
    (None, (0, 0, '/*'),    r'/* abc'),
    (None, (0, 0, ''),      r'a + b // /*'),
    (None, (0, 1, ''),      r'(function'),
    (None, (1, 1, ''),      r'(function(a) {'),
    (None, (0, 0, ''),      r'var x = /abc/'),
    (None, (0, 0, ''),      r'var x = /a"c/'),
    (None, (0, 0, ''),      r'var x = /a\//'),
    (None, (0, 0, ''),      r'var x = /a\//'),
    (None, (0, 0, ''),      r"console.log(/'\d+'/)"),
    (None, (0, 1, ''),      r'var x = (0,'),
)
for base, result, s in table:
    importer = js.JS_Importer(c.importCommands, atAuto=False)
    prev_state = js.JS_ScanState()
    new_state = importer.scan_line(s, prev_state)
    curlies, parens, context = result
    ok = (
        new_state.curlies == curlies and
        new_state.parens == parens and
        new_state.context == context)
    assert ok, '\nexpected %r\n     got %r' % (expected_state, new_state)
</t>
<t tx="ekr.20161011092326.7"># ~/at-auto-test.py

# This is valid Python, but it looks like a section reference.
a = b &lt;&lt; c &gt;&gt; d

</t>
<t tx="ekr.20161011095551.1">True: (Experimental): The @auto write code expands section references.
False: (Legacy):      The @auto write code ignores section references.
</t>
<t tx="ekr.20161103015908.1"></t>
<t tx="ekr.20161103015940.1">s = '''\
#!/usr/bin/perl

# Function definition
sub Hello{
   print "Hello, World!\n";
}

sub Test{
   print "Test!\n";
}
"\N{LATIN SMALL LIGATURE FI}" =~ /fi/i;

$bar = "foo";
if ($bar =~ /foo/){
   print "Second time is matching\n";
}else{
   print "Second time is not matching\n";
}

# Function call
Hello();
'''
try:
    c.importCommands.perlUnitTest(p,s=s,showTree=True)
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161103021420.1">s = '''\
#!/usr/bin/perl

# This would print with a line break in the middle
print "Hello

sub World {
    print "This is not a funtion!"
}

world\n";
'''
try:
    c.importCommands.perlUnitTest(p,s=s,showTree=True)
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161103021621.1">s = '''\
#!/usr/bin/perl
          
sub Test{
   print "Test!\n";
}

=begin comment
sub World {
    print "This is not a funtion!"
}
=cut

# Function definition
sub Hello{
   print "Hello, World!\n";
}
'''
try:
    c.importCommands.perlUnitTest(p,s=s,showTree=True)
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161103075725.1"># These fail with the NEW (strict) import tests and the OLD scanners.</t>
<t tx="ekr.20161108034116.1"></t>
<t tx="ekr.20161108034138.1">@killcolor

s = r'''

# The JavaScript to CoffeeScript compiler.
# Common usage:
#
#
#     var src = "var square = function(n) { return n * n };"
#
#     js2coffee = require('js2coffee');
#     js2coffee.build(src);
#     //=&gt; "square = (n) -&gt; n * n"

# ## Requires
#
# Js2coffee relies on Narcissus's parser. (Narcissus is Mozilla's JavaScript
# engine written in JavaScript).

{parser} = @Narcissus or require('./narcissus_packed')

_ = @_ or require('underscore')

{Types, Typenames, Node} = @NodeExt or require('./node_ext')

{Code, p, strEscape, unreserve, unshift, isSingleLine, trim, blockTrim,
  ltrim, rtrim, strRepeat, paren, truthy} = @Js2coffeeHelpers or require('./helpers')

# ## Main entry point
# This is `require('js2coffee').build()`. It takes a JavaScript source
# string as an argument, and it returns the CoffeeScript version.
#
# 1. Ask Narcissus to break it down into Nodes (`parser.parse`). This
#    returns a `Node` object of type `script`.
#
# 2. This node is now passed onto `Builder#build()`.

buildCoffee = (str) -&gt;
  str  = str.replace /\r/g, ''
  str += "\n"

  builder    = new Builder
  scriptNode = parser.parse str

  output = trim builder.build(scriptNode)
  (rtrim line for line in output.split('\n')).join('\n')
# ## Builder class
# This is the main class that proccesses the AST and spits out streng.
# See the `buildCoffee()` function above for info on how this is used.

class Builder
  constructor: -&gt;
    @transformer = new Transformer
  # `build()`
  # The main entry point.

  # This finds the appropriate @builder function for `node` based on it's type,
  # the passes the node onto that function.
  #
  # For instance, for a `function` node, it calls `@builders.function(node)`.
  # It defaults to `@builders.other` if it can't find a function for it.

  build: (args...) -&gt;
    node = args[0]
    @transform node

    name = 'other'
    name = node.typeName()  if node != undefined and node.typeName

    fn  = (@[name] or @other)
    out = fn.apply(this, args)

    if node.parenthesized then paren(out) else out
  # `transform()`
  # Perform a transformation on the node, if a transformation function is
  # available.

  transform: (args...) -&gt;
    @transformer.transform.apply(@transformer, args)
  # `body()`
  # Works like `@build()`, and is used for code blocks. It cleans up the returned
  # code block by removing any extraneous spaces and such.

  body: (node, opts={}) -&gt;
    str = @build(node, opts)
    str = blockTrim(str)
    str = unshift(str)

    if str.length &gt; 0 then str else ""
  # ## The builders
  #
  # Each of these method are passed a Node, and is expected to return
  # a string representation of it CoffeeScript counterpart.
  #
  # These are invoked using the main entry point, `Builder#build()`.

  # `script`
  # This is the main entry point.

  'script': (n, opts={}) -&gt;
    c = new Code

    # *Functions must always be declared first in a block.*
    _.each n.functions,    (item) =&gt; c.add @build(item)
    _.each n.nonfunctions, (item) =&gt; c.add @build(item)

    c.toString()
  # `property_identifier`
  # A key in an object literal.

  'property_identifier': (n) -&gt;
    str = n.value.toString()

    # **Caveat:**
    # *In object literals like `{ '#foo click': b }`, ensure that the key is
    # quoted if need be.*

    if str.match(/^([_\$a-z][_\$a-z0-9]*)$/i) or str.match(/^[0-9]+$/i)
      str
    else
      strEscape str
  # `identifier`
  # Any object identifier like a variable name.

  'identifier': (n) -&gt;
    if n.value is 'undefined'
      '`undefined`'
    else if n.property_accessor
      n.value.toString()
    else
      unreserve n.value.toString()
  'number': (n) -&gt;
    "#{n.src()}"
  'id': (n) -&gt;
    if n.property_accessor
      n
    else
      unreserve n
  # `id_param`
  # Function parameters. Belongs to `list`.

  'id_param': (n) -&gt;
    if n.toString() in ['undefined']
      "#{n}_"
    else
      @id n
  # `return`
  # A return statement. Has `n.value` of type `id`.

  'return': (n) -&gt;
    if not n.value?
      "return\n"

    else
      "return #{@build(n.value)}\n"
  # `;` (aka, statement)
  # A single statement.

  ';': (n) -&gt;
    # **Caveat:**
    # Some statements can be blank as some people are silly enough to use `;;`
    # sometimes. They should be ignored.

    unless n.expression?
      ""

    else if n.expression.typeName() == 'object_init'
      src = @object_init(n.expression)
      if n.parenthesized
        src
      else
        "#{unshift(blockTrim(src))}\n"

    else
      @build(n.expression) + "\n"
  # `new` + `new_with_args`
  # For `new X` and `new X(y)` respctively.

  'new': (n) -&gt; "new #{@build n.left()}"
  'new_with_args': (n) -&gt; "new #{@build n.left()}(#{@build n.right()})"
  # ### Unary operators

  'unary_plus': (n) -&gt; "+#{@build n.left()}"
  'unary_minus': (n) -&gt; "-#{@build n.left()}"
  # ### Keywords

  'this': (n) -&gt; 'this'
  'null': (n) -&gt; 'null'
  'true': (n) -&gt; 'true'
  'false': (n) -&gt; 'false'
  'void': (n) -&gt; 'undefined'
  'debugger': (n) -&gt; "debugger\n"
  'break': (n) -&gt; "break\n"
  'continue': (n) -&gt; "continue\n"
  # ### Some simple operators

  '~': (n) -&gt; "~#{@build n.left()}"
  'typeof': (n) -&gt; "typeof #{@build n.left()}"
  'index': (n) -&gt;
    right = @build n.right()
    if _.any(n.children, (child) -&gt; child.typeName() == 'object_init' and child.children.length &gt; 1)
      right = "{#{right}}"
    "#{@build n.left()}[#{right}]"
  'throw': (n) -&gt; "throw #{@build n.exception}"
  '!': (n) -&gt;
    target = n.left()
    negations = 1
    ++negations while (target.isA '!') and target = target.left()
    if (negations &amp; 1) and target.isA '==', '!=', '===', '!==', 'in', 'instanceof' # invertible binary operators
      target.negated = not target.negated
      return @build target
    "#{if negations &amp; 1 then 'not ' else '!!'}#{@build target}"
  # ### Binary operators
  # All of these are rerouted to the `binary_operator` @builder.

  # TODO: make a function that generates these functions, invoked like so:
  #   in: binop 'in', 'of'
  #   '+': binop '+'
  #   and so on...

  in: (n) -&gt;    @binary_operator n, 'of'
  '+': (n) -&gt;   @binary_operator n, '+'
  '-': (n) -&gt;   @binary_operator n, '-'
  '*': (n) -&gt;   @binary_operator n, '*'
  '/': (n) -&gt;   @binary_operator n, '/'
  '%': (n) -&gt;   @binary_operator n, '%'
  '&gt;': (n) -&gt;   @binary_operator n, '&gt;'
  '&lt;': (n) -&gt;   @binary_operator n, '&lt;'
  '&amp;': (n) -&gt;   @binary_operator n, '&amp;'
  '|': (n) -&gt;   @binary_operator n, '|'
  '^': (n) -&gt;   @binary_operator n, '^'
  '&amp;&amp;': (n) -&gt;  @binary_operator n, 'and'
  '||': (n) -&gt;  @binary_operator n, 'or'
  '&lt;&lt;': (n) -&gt;  @binary_operator n, '&lt;&lt;'
  '&lt;=': (n) -&gt;  @binary_operator n, '&lt;='
  '&gt;&gt;': (n) -&gt;  @binary_operator n, '&gt;&gt;'
  '&gt;=': (n) -&gt;  @binary_operator n, '&gt;='
  '===': (n) -&gt; @binary_operator n, 'is'
  '!==': (n) -&gt; @binary_operator n, 'isnt'
  '&gt;&gt;&gt;': (n) -&gt;  @binary_operator n, '&gt;&gt;&gt;'
  instanceof: (n) -&gt; @binary_operator n, 'instanceof'
  '==': (n) -&gt;
    # TODO: throw warning
    @binary_operator n, 'is'
  '!=': (n) -&gt;
    # TODO: throw warning
    @binary_operator n, 'isnt'
  'binary_operator': do -&gt;
    INVERSIONS =
      is: 'isnt'
      in: 'not in'
      of: 'not of'
      instanceof: 'not instanceof'
    INVERSIONS[v] = k for own k, v of INVERSIONS
    (n, sign) -&gt;
      sign = INVERSIONS[sign] if n.negated
      "#{@build n.left()} #{sign} #{@build n.right()}"
  # ### Increments and decrements
  # For `a++` and `--b`.

  '--': (n) -&gt; @increment_decrement n, '--'
  '++': (n) -&gt; @increment_decrement n, '++'
  'increment_decrement': (n, sign) -&gt;
    if n.postfix
      "#{@build n.left()}#{sign}"
    else
      "#{sign}#{@build n.left()}"
  # `=` (aka, assignment)
  # For `a = b` (but not `var a = b`: that's `var`).

  '=': (n) -&gt;
    sign = if n.assignOp?
      Types[n.assignOp] + '='
    else
      '='

    "#{@build n.left()} #{sign} #{@build n.right()}"
  # `,` (aka, comma)
  # For `a = 1, b = 2'

  ',': (n) -&gt;
    list = _.map n.children, (item) =&gt; @build(item) + "\n"
    list.join('')
  # `regexp`
  # Regular expressions.

  'regexp': (n) -&gt;
    m     = n.value.toString().match(/^\/(.*)\/([a-z]?)/)
    value = m[1]
    flag  = m[2]

    # **Caveat:**
    # *If it begins with `=` or a space, the CoffeeScript parser will choke if
    # it's written as `/=/`. Hence, they are written as `new RegExp('=')`.*

    begins_with = value[0]

    if begins_with in [' ', '=']
      if flag.length &gt; 0
        "RegExp(#{strEscape value}, \"#{flag}\")"
      else
        "RegExp(#{strEscape value})"
    else
      "/#{value}/#{flag}"
  'string': (n) -&gt;
    strEscape n.value
  # `call`
  # A Function call.
  # `n.left` is an `id`, and `n.right` is a `list`.

  'call': (n) -&gt;
    if n.right().children.length == 0
      "#{@build n.left()}()"
    else
      "#{@build n.left()}(#{@build n.right()})"
  # `call_statement`
  # A `call` that's on it's own line.

  'call_statement': (n) -&gt;
    left = @build n.left()

    # **Caveat:**
    # *When calling in this way: `function () { ... }()`,
    # ensure that there are parenthesis around the anon function
    # (eg, `(-&gt; ...)()`).*

    left = paren(left)  if n.left().isA('function')

    if n.right().children.length == 0
      "#{left}()"
    else
      "#{left} #{@build n.right()}"
  # `list`
  # A parameter list.

  'list': (n) -&gt;
    list = _.map(n.children, (item) =&gt;
      if n.children.length &gt; 1
        item.is_list_element = true
      @build(item))

    list.join(", ")
  'delete': (n) -&gt;
    ids = _.map(n.children, (el) =&gt; @build(el))
    ids = ids.join(', ')
    "delete #{ids}\n"
  # `.` (scope resolution?)
  # For instances such as `object.value`.

  '.': (n) -&gt;
    # **Caveat:**
    # *If called as `this.xxx`, it should use the at sign (`n.xxx`).*

    # **Caveat:**
    # *If called as `x.prototype`, it should use double colons (`x::`).*

    left  = @build n.left()
    right_obj = n.right()
    right_obj.property_accessor = true
    right = @build right_obj

    if n.isThis and n.isPrototype
      "@::"
    else if n.isThis
      "@#{right}"
    else if n.isPrototype
      "#{left}::"
    else if n.left().isPrototype
      "#{left}#{right}"
    else
      "#{left}.#{right}"
  'try': (n) -&gt;
    c = new Code
    c.add 'try'
    c.scope @body(n.tryBlock)

    _.each n.catchClauses, (clause) =&gt;
      c.add @build(clause)

    if n.finallyBlock?
      c.add "finally"
      c.scope @body(n.finallyBlock)

    c
  'catch': (n) -&gt;
    body_ = @body(n.block)
    return '' if trim(body_).length == 0

    c = new Code

    if n.varName?
      c.add "catch #{n.varName}"
    else
      c.add 'catch'

    c.scope @body(n.block)
    c
  # `?` (ternary operator)
  # For `a ? b : c`. Note that these will always be parenthesized, as (I
  # believe) the order of operations in JS is different in CS.

  '?': (n) -&gt;
    "(if #{@build n.left()} then #{@build n.children[1]} else #{@build n.children[2]})"
  'for': (n) -&gt;
    c = new Code

    if n.setup?
      c.add "#{@build n.setup}\n"

    if n.condition?
      c.add "while #{@build n.condition}\n"
    else
      c.add "loop"

    c.scope @body(n.body)
    c.scope @body(n.update)  if n.update?
    c
  'for_in': (n) -&gt;
    c = new Code

    c.add "for #{@build n.iterator} of #{@build n.object}"
    c.scope @body(n.body)
    c
  'while': (n) -&gt;
    c = new Code

    keyword   = if n.positive then "while" else "until"
    body_     = @body(n.body)

    # *Use `loop` whin something will go on forever (like `while (true)`).*
    if truthy(n.condition)
      statement = "loop"
    else
      statement = "#{keyword} #{@build n.condition}"

    if isSingleLine(body_) and statement isnt "loop"
      c.add "#{trim body_}  #{statement}\n"
    else
      c.add statement
      c.scope body_
    c
  'do': (n) -&gt;
    c = new Code

    c.add "loop"
    c.scope @body(n.body)
    c.scope "break unless #{@build n.condition}"  if n.condition?

    c
  'if': (n) -&gt;
    c = new Code

    keyword = if n.positive then "if" else "unless"
    body_   = @body(n.thenPart)
    n.condition.parenthesized = false

    # *Account for `if (xyz) {}`, which should be `xyz`. (#78)*
    # *Note that `!xyz` still compiles to `xyz` because the `!` will not change anything.*
    if n.thenPart.isA('block') and n.thenPart.children.length == 0 and !n.elsePart?
      console.log n.thenPart
      c.add "#{@build n.condition}\n"

    else if isSingleLine(body_) and !n.elsePart?
      c.add "#{trim body_}  #{keyword} #{@build n.condition}\n"

    else
      c.add "#{keyword} #{@build n.condition}"
      c.scope @body(n.thenPart)

      if n.elsePart?
        if n.elsePart.typeName() == 'if'
          c.add "else #{@build(n.elsePart).toString()}"
        else
          c.add "else\n"
          c.scope @body(n.elsePart)

    c
  'switch': (n) -&gt;
    c = new Code

    c.add "switch #{@build n.discriminant}\n"

    fall_through = false
    _.each n.cases, (item) =&gt;
      if item.value == 'default'
        c.scope "else"
      else
        if fall_through == true
          c.add ", #{@build item.caseLabel}\n"
        else
          c.add "  when #{@build item.caseLabel}"
          
      if @body(item.statements).length == 0
        fall_through = true
      else
        fall_through = false
        c.add "\n"
        c.scope @body(item.statements), 2

      first = false

    c
  'existence_check': (n) -&gt;
    "#{@build n.left()}?"
  'array_init': (n) -&gt;
    if n.children.length == 0
      "[]"
    else
      "[ #{@list n} ]"
  # `property_init`
  # Belongs to `object_init`;
  # left is a `identifier`, right can be anything.

  'property_init': (n) -&gt;
    left = n.left()
    right = n.right()
    right.is_property_value = true
    "#{@property_identifier left}: #{@build right}"
  # `object_init`
  # An object initializer.
  # Has many `property_init`.

  'object_init': (n, options={}) -&gt;
    if n.children.length == 0
      "{}"

    else if n.children.length == 1 and not (n.is_property_value or n.is_list_element)
      @build n.children[0]

    else
      list = _.map n.children, (item) =&gt; @build item

      c = new Code
      c.scope list.join("\n")
      c = "{#{c}}"  if options.brackets?
      c
  # `function`
  # A function. Can be an anonymous function (`function () { .. }`), or a named
  # function (`function name() { .. }`).

  'function': (n) -&gt;
    c = new Code

    params = _.map n.params, (str) =&gt;
      if str.constructor == String
        @id_param str
      else
        @build str

    if n.name
      c.add "#{n.name} = "

    if n.params.length &gt; 0
      c.add "(#{params.join ', '}) -&gt;"
    else
      c.add "-&gt;"

    body = @body(n.body)
    if trim(body).length &gt; 0
      c.scope body
    else
      c.add "\n"

    c
  'var': (n) -&gt;
    list = _.map n.children, (item) =&gt;
      "#{unreserve item.value} = #{if item.initializer? then @build(item.initializer) else 'undefined'}"

    _.compact(list).join("\n") + "\n"
  # ### Unsupported things
  #
  # Due to CoffeeScript limitations, the following things are not supported:
  #
  #  * New getter/setter syntax (`x.prototype = { get name() { ... } };`)
  #  * Break labels (`my_label: ...`)
  #  * Constants

  'other': (n) -&gt;   @unsupported n, "#{n.typeName()} is not supported yet"
  'getter': (n) -&gt;  @unsupported n, "getter syntax is not supported; use __defineGetter__"
  'setter': (n) -&gt;  @unsupported n, "setter syntax is not supported; use __defineSetter__"
  'label': (n) -&gt;   @unsupported n, "labels are not supported by CoffeeScript"
  'const': (n) -&gt;   @unsupported n, "consts are not supported by CoffeeScript"
  'block': (args...) -&gt;
    @script.apply @, args
  # `unsupported()`
  # Throws an unsupported error.
  'unsupported': (node, message) -&gt;
    throw new UnsupportedError("Unsupported: #{message}", node)
# ## AST manipulation
# Manipulation of the abstract syntax tree happens here. All these are done on
# the `build()` step, done just before a node is passed onto `Builders`.

class Transformer
  transform: (args...) -&gt;
    node = args[0]
    return  if node.transformed?
    type = node.typeName()
    fn = @[type]

    if fn
      fn.apply(this, args)
      node.transformed = true
  'script': (n) -&gt;
    n.functions    = []
    n.nonfunctions = []

    _.each n.children, (item) =&gt;
      if item.isA('function')
        n.functions.push item
      else
        n.nonfunctions.push item

    last = null

    # *Statements don't need parens, unless they are consecutive object
    # literals.*
    _.each n.nonfunctions, (item) =&gt;
      if item.expression?
        expr = item.expression

        if last?.isA('object_init') and expr.isA('object_init')
          item.parenthesized = true
        else
          item.parenthesized = false

        last = expr
  '.': (n) -&gt;
    n.isThis      = n.left().isA('this')
    n.isPrototype = (n.right().isA('identifier') and n.right().value == 'prototype')
  ';': (n) -&gt;
    if n.expression?
      # *Statements don't need parens.*
      n.expression.parenthesized = false

      # *If the statement only has one function call (eg, `alert(2);`), the
      # parentheses should be omitted (eg, `alert 2`).*
      if n.expression.isA('call')
        n.expression.type = Typenames['call_statement']
        @call_statement n
  'function': (n) -&gt;
    # *Unwrap the `return`s.*
    n.body.walk last: true, (parent, node, list) -&gt;
      if node.isA('return') and node.value
        # Hax
        lastNode = if list
          parent[list]
        else
          parent.children[parent.children.length-1]

        if lastNode
          lastNode.type = Typenames[';']
          lastNode.expression = lastNode.value
  'switch': (n) -&gt;
    _.each n.cases, (item) =&gt;
      block = item.statements
      ch    = block.children

      # *CoffeeScript does not need `break` statements on `switch` blocks.*
      delete ch[ch.length-1] if block.last()?.isA('break')
  'call_statement': (n) -&gt;
    if n.children[1]
      _.each n.children[1].children, (child, i) -&gt;
        if child.isA('function') and i != n.children[1].children.length-1
          child.parenthesized = true
  'return': (n) -&gt;
    # *Doing "return {x:2, y:3}" should parenthesize the return value.*
    if n.value and n.value.isA('object_init') and n.value.children.length &gt; 1
      n.value.parenthesized = true
  'block': (n) -&gt;
    @script n
  'if': (n) -&gt;
    # *Account for `if(x) {} else { something }` which should be `something unless x`.*
    if n.thenPart.children.length == 0 and n.elsePart?.children.length &gt; 0
      n.positive = false
      n.thenPart = n.elsePart
      delete n.elsePart

    @inversible n
  'while': (n) -&gt;
    # *A while with a blank body (`while(x){}`) should be accounted for.*
    # *You can't have empty blocks, so put a `continue` in there. (#78)*
    if n.body.children.length is 0
      n.body.children.push n.clone(type: Typenames['continue'], value: 'continue', children: [])

    @inversible n
  'inversible': (n) -&gt;
    @transform n.condition
    positive = if n.positive? then n.positive else true

    # *Invert a '!='. (`if (x != y)` =&gt; `unless x is y`)*
    if n.condition.isA('!=')
      n.condition.type = Typenames['==']
      n.positive = not positive

    # *Invert a '!'. (`if (!x)` =&gt; `unless x`)*
    else if n.condition.isA('!')
      n.condition = n.condition.left()
      n.positive = not positive

    else
      n.positive = positive
  '==': (n) -&gt;
    if n.right().isA('null', 'void')
      n.type     = Typenames['!']
      n.children = [n.clone(type: Typenames['existence_check'], children: [n.left()])]
  '!=': (n) -&gt;
    if n.right().isA('null', 'void')
      n.type     = Typenames['existence_check']
      n.children = [n.left()]
class UnsupportedError
  constructor: (str, src) -&gt;
    @message = str
    @cursor  = src.start
    @line    = src.lineno
    @source  = src.tokenizer.source
  toString: -&gt; @message

# ## Exports

@Js2coffee = exports =
  version: '0.1.3'
  build: buildCoffee
  UnsupportedError: UnsupportedError

module.exports = exports  if module?
'''
@color

table = (
    "buildCoffee = (str) -&gt;",
    "class Builder",
    "constructor: -&gt;",
    "build: (args...) -&gt;",
    "transform: (args...) -&gt;",
    "body: (node, opts={}) -&gt;",
    "'script': (n, opts={}) -&gt;",
    "'property_identifier': (n) -&gt;",
    "'identifier': (n) -&gt;",
    "'number': (n) -&gt;",
    "'id': (n) -&gt;",
    "'id_param': (n) -&gt;",
    "'return': (n) -&gt;",
    "';': (n) -&gt;",
    "'new': (n) -&gt; \"new #{@build n.left()}\"",
    "'new_with_args': (n) -&gt; \"new #{@build n.left()}(#{@build n.right()})\"",
    "'unary_plus': (n) -&gt; \"+#{@build n.left()}\"",
    "'unary_minus': (n) -&gt; \"-#{@build n.left()}\"",
    "'this': (n) -&gt; 'this'",
    "'null': (n) -&gt; 'null'",
    "'true': (n) -&gt; 'true'",
    "'false': (n) -&gt; 'false'",
    "'void': (n) -&gt; 'undefined'",
    "'debugger': (n) -&gt; \"debugger\\n\"",
    "'break': (n) -&gt; \"break\\n\"",
    "'continue': (n) -&gt; \"continue\\n\"",
    "'~': (n) -&gt; \"~#{@build n.left()}\"",
    "'typeof': (n) -&gt; \"typeof #{@build n.left()}\"",
    "'index': (n) -&gt;",
    "'throw': (n) -&gt; \"throw #{@build n.exception}\"",
    "'!': (n) -&gt;",
    "in: (n) -&gt;    @binary_operator n, 'of'",
    "'+': (n) -&gt;   @binary_operator n, '+'",
    "'-': (n) -&gt;   @binary_operator n, '-'",
    "'*': (n) -&gt;   @binary_operator n, '*'",
    "'/': (n) -&gt;   @binary_operator n, '/'",
    "'%': (n) -&gt;   @binary_operator n, '%'",
    "'&gt;': (n) -&gt;   @binary_operator n, '&gt;'",
    "'&lt;': (n) -&gt;   @binary_operator n, '&lt;'",
    "'&amp;': (n) -&gt;   @binary_operator n, '&amp;'",
    "'|': (n) -&gt;   @binary_operator n, '|'",
    "'^': (n) -&gt;   @binary_operator n, '^'",
    "'&amp;&amp;': (n) -&gt;  @binary_operator n, 'and'",
    "'||': (n) -&gt;  @binary_operator n, 'or'",
    "'&lt;&lt;': (n) -&gt;  @binary_operator n, '&lt;&lt;'",
    "'&lt;=': (n) -&gt;  @binary_operator n, '&lt;='",
    "'&gt;&gt;': (n) -&gt;  @binary_operator n, '&gt;&gt;'",
    "'&gt;=': (n) -&gt;  @binary_operator n, '&gt;='",
    "'===': (n) -&gt; @binary_operator n, 'is'",
    "'!==': (n) -&gt; @binary_operator n, 'isnt'",
    "'&gt;&gt;&gt;': (n) -&gt;  @binary_operator n, '&gt;&gt;&gt;'",
    "instanceof: (n) -&gt; @binary_operator n, 'instanceof'",
    "'==': (n) -&gt;",
    "'!=': (n) -&gt;",
    "'binary_operator': do -&gt;",
    "'--': (n) -&gt; @increment_decrement n, '--'",
    "'++': (n) -&gt; @increment_decrement n, '++'",
    "'increment_decrement': (n, sign) -&gt;",
    "'=': (n) -&gt;",
    "',': (n) -&gt;",
    "'regexp': (n) -&gt;",
    "'string': (n) -&gt;",
    "'call': (n) -&gt;",
    "'call_statement': (n) -&gt;",
    "'list': (n) -&gt;",
    "'delete': (n) -&gt;",
    "'.': (n) -&gt;",
    "'try': (n) -&gt;",
    "'catch': (n) -&gt;",
    "'?': (n) -&gt;",
    "'for': (n) -&gt;",
    "'for_in': (n) -&gt;",
    "'while': (n) -&gt;",
    "'do': (n) -&gt;",
    "'if': (n) -&gt;",
    "'switch': (n) -&gt;",
    "'existence_check': (n) -&gt;",
    "'array_init': (n) -&gt;",
    "'property_init': (n) -&gt;",
    "'object_init': (n, options={}) -&gt;",
    "'function': (n) -&gt;",
    "'var': (n) -&gt;",
    "'other': (n) -&gt;   @unsupported n, \"#{n.typeName()} is not supported yet\"",
    "'getter': (n) -&gt;  @unsupported n, \"getter syntax is not supported; use __defineGetter__\"",
    "'setter': (n) -&gt;  @unsupported n, \"setter syntax is not supported; use __defineSetter__\"",
    "'label': (n) -&gt;   @unsupported n, \"labels are not supported by CoffeeScript\"",
    "'const': (n) -&gt;   @unsupported n, \"consts are not supported by CoffeeScript\"",
    "'block': (args...) -&gt;",
    "'unsupported': (node, message) -&gt;",
    "class Transformer",
    "transform: (args...) -&gt;",
    "'script': (n) -&gt;",
    "'.': (n) -&gt;",
    "';': (n) -&gt;",
    "'function': (n) -&gt;",
    "n.body.walk last: true, (parent, node, list) -&gt;",
    "'switch': (n) -&gt;",
    "'call_statement': (n) -&gt;",
    "'return': (n) -&gt;",
    "'block': (n) -&gt;",
    "'if': (n) -&gt;",
    "'while': (n) -&gt;",
    "'inversible': (n) -&gt;",
    "'==': (n) -&gt;",
    "'!=': (n) -&gt;",
    "class UnsupportedError",
    "constructor: (str, src) -&gt;",
    "toString: -&gt; @message",
)

try:
    c.importCommands.coffeeScriptUnitTest(p,s=s,showTree=True)
    if 1:
      p2 = c.p.firstChild().firstChild()
      for h in table:
          assert p2.h == h, (p2.h, h)
          p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161109065940.1"># g.cls()
import leo.plugins.importers.linescanner as linescanner
# import imp
# imp.reload(linescanner)
lines_table = [
    'abc',
    '    xyz',
    '    ',
    '  # comment',
]
for language in ('python', 'coffeescript'):
    importer = linescanner.Importer(
        c.importCommands,
        atAuto = True,
        language = language,
    )
    # print('%s %r' % (language, importer.comment_delim))
    assert importer.single_comment == '#', importer.single_comment
    for line in lines_table:
        lines = [line]
        n = importer.get_leading_indent(lines, 0)
        # print('%s %r' % (n, line))
</t>
<t tx="ekr.20161109065949.1"># g.cls()
import leo.plugins.importers.linescanner as linescanner
# import imp
# imp.reload(linescanner)
table = [
    (False, 'abc'),
    (False, '    xyz'),
    (True, '    '),
    (True,'  # comment'),
]
importer = linescanner.Importer(
    c.importCommands,
    atAuto = True,
    language = 'python',
)
for val, s in table:
    assert val == importer.is_ws_line(s), (val, repr(s))
</t>
<t tx="ekr.20161109084732.1">s = r'''

# Js2coffee relies on Narcissus's parser.

{parser} = @Narcissus or require('./narcissus_packed')

# Main entry point

buildCoffee = (str) -&gt;
  str  = str.replace /\r/g, ''
  str += "\n"

  builder    = new Builder
  scriptNode = parser.parse str
'''
table = (
    'buildCoffee = (str) -&gt;',
)
try:
    c.importCommands.coffeeScriptUnitTest(p,s=s,showTree=True)
    if 1:
      p2 = c.p.firstChild().firstChild()
      for h in table:
          assert p2.h == h, (p2.h, h)
          p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161112061406.1">class TypeJoinVisitor(TypeVisitor[Type]):
    """Implementation of the least upper bound algorithm.

    Attributes:
      s: The other (left) type operand.
    """

    def __init__(self, s: Type) -&gt; None:
        self.s = s

    def visit_unbound_type(self, t: UnboundType) -&gt; Type:
        if isinstance(self.s, Void) or isinstance(self.s, ErrorType):
            return ErrorType()
        else:
            return AnyType()

    def visit_union_type(self, t: UnionType) -&gt; Type:
        if is_subtype(self.s, t):
            return t
        else:
            return UnionType(t.items + [self.s])

    def visit_error_type(self, t: ErrorType) -&gt; Type:
        return t

    def visit_type_list(self, t: TypeList) -&gt; Type:
        assert False, 'Not supported'

    def visit_any(self, t: AnyType) -&gt; Type:
        return t

    def visit_void(self, t: Void) -&gt; Type:
        if isinstance(self.s, Void):
            return t
        else:
            return ErrorType()

    def visit_none_type(self, t: NoneTyp) -&gt; Type:
        if not isinstance(self.s, Void):
            return self.s
        else:
            return self.default(self.s)

    def visit_erased_type(self, t: ErasedType) -&gt; Type:
        return self.s

    def visit_type_var(self, t: TypeVarType) -&gt; Type:
        if isinstance(self.s, TypeVarType) and (cast(TypeVarType, self.s)).id == t.id:
            return self.s
        else:
            return self.default(self.s)

    def visit_instance(self, t: Instance) -&gt; Type:
        if isinstance(self.s, Instance):
            return join_instances(t, cast(Instance, self.s))
        elif isinstance(self.s, FunctionLike):
            return join_types(t, self.s.fallback)
        else:
            return self.default(self.s)

    def visit_callable_type(self, t: CallableType) -&gt; Type:
        # TODO: Consider subtyping instead of just similarity.
        if isinstance(self.s, CallableType) and is_similar_callables(
                t, cast(CallableType, self.s)):
            return combine_similar_callables(t, cast(CallableType, self.s))
        elif isinstance(self.s, Overloaded):
            # Switch the order of arguments to that we'll get to visit_overloaded.
            return join_types(t, self.s)
        else:
            return join_types(t.fallback, self.s)

    def visit_overloaded(self, t: Overloaded) -&gt; Type:
        # This is more complex than most other cases. Here are some
        # examples that illustrate how this works.
        #
        # First let's define a concise notation:
        #  - Cn are callable types (for n in 1, 2, ...)
        #  - Ov(C1, C2, ...) is an overloaded type with items C1, C2, ...
        #  - Callable[[T, ...], S] is written as [T, ...] -&gt; S.
        #
        # We want some basic properties to hold (assume Cn are all
        # unrelated via Any-similarity):
        #
        #   join(Ov(C1, C2), C1) == C1
        #   join(Ov(C1, C2), Ov(C1, C2)) == Ov(C1, C2)
        #   join(Ov(C1, C2), Ov(C1, C3)) == C1
        #   join(Ov(C2, C2), C3) == join of fallback types
        #
        # The presence of Any types makes things more interesting. The join is the
        # most general type we can get with respect to Any:
        #
        #   join(Ov([int] -&gt; int, [str] -&gt; str), [Any] -&gt; str) == Any -&gt; str
        #
        # We could use a simplification step that removes redundancies, but that's not
        # implemented right now. Consider this example, where we get a redundancy:
        #
        #   join(Ov([int, Any] -&gt; Any, [str, Any] -&gt; Any), [Any, int] -&gt; Any) ==
        #       Ov([Any, int] -&gt; Any, [Any, int] -&gt; Any)
        #
        # TODO: Use callable subtyping instead of just similarity.
        result = []  # type: List[CallableType]
        s = self.s
        if isinstance(s, FunctionLike):
            # The interesting case where both types are function types.
            for t_item in t.items():
                for s_item in s.items():
                    if is_similar_callables(t_item, s_item):
                        result.append(combine_similar_callables(t_item, s_item))
            if result:
                # TODO: Simplify redundancies from the result.
                if len(result) == 1:
                    return result[0]
                else:
                    return Overloaded(result)
            return join_types(t.fallback, s.fallback)
        return join_types(t.fallback, s)

    def visit_tuple_type(self, t: TupleType) -&gt; Type:
        if (isinstance(self.s, TupleType) and
                cast(TupleType, self.s).length() == t.length()):
            items = []  # type: List[Type]
            for i in range(t.length()):
                items.append(self.join(t.items[i],
                                       (cast(TupleType, self.s)).items[i]))
            # TODO: What if the fallback types are different?
            return TupleType(items, t.fallback)
        else:
            return self.default(self.s)

    def join(self, s: Type, t: Type) -&gt; Type:
        return join_types(s, t)

    def default(self, typ: Type) -&gt; Type:
        if isinstance(typ, Instance):
            return object_from_instance(typ)
        elif isinstance(typ, UnboundType):
            return AnyType()
        elif isinstance(typ, Void) or isinstance(typ, ErrorType):
            return ErrorType()
        elif isinstance(typ, TupleType):
            return self.default(typ.fallback)
        elif isinstance(typ, FunctionLike):
            return self.default(typ.fallback)
        elif isinstance(typ, TypeVarType):
            return self.default(typ.upper_bound)
        else:
            return AnyType()
</t>
<t tx="ekr.20161112061414.1">class aClass:
    @others
</t>
<t tx="ekr.20161112061414.2">def __init__(self):
    pass
</t>
<t tx="ekr.20161112061414.3">def spam(self):
    pass
</t>
<t tx="ekr.20161112061414.4">bClass = aClass
</t>
<t tx="ekr.20161115063144.10">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
class aClass:
    def outerDef(self):
        """docstring.
        line two."""

        def pr(*args,**keys):
            g.es_print(color='blue',*args,**keys)

        a = 3
'''
table = (
    (1, 'class aClass'),
    (2, 'outerDef'),
    (3, 'pr'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.11">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\

class test:

    def importFilesCommand (self,files=None,treeType=None,
        perfectImport=True,testing=False,verbose=False):
            # Not a command.  It must *not* have an event arg.

        c = self.c
        if c == None: return
        p = c.currentPosition()

    # Used by paste logic.

    def convertMoreStringToOutlineAfter (self,s,firstVnode):
        s = string.replace(s,"\\r","")
        strings = string.split(s,"\\n")
        return self.convertMoreStringsToOutlineAfter(strings,firstVnode)
'''
table = (
        (1, 'class test'),
        (2, 'importFilesCommand'),
        (2, 'convertMoreStringToOutlineAfter'),
    )
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        root.doDelete()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.12">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\

class test:
    def spam(b):
        pass

    # Used by paste logic.

    def foo(a):
        pass
'''

table = (
        (1, 'class test'),
        (2, 'spam'),
        (2, 'foo'),
    )
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.13">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
"""A file consisting only of a docstring.
"""
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.14">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
import leo.core.leoGlobals as g

a = 3
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.15">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class cls:
     def fun(): # one extra space.
        pass
'''


c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.16">@tabwidth -4
    # Required when running unit tests externally.
if 1: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\

class mammalProviderBase(object):
    """Root class for content providers used by DWEtree.py"""
    def __init__(self, params):
        """store reference to parameters"""
        self.params = params
    def provide(self, what):
        """default &lt;BASE&gt; value"""
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/'])
        return None

    def imagePath(self, sppdat):
        """return path to images and list of images for *species*"""
        path = 'MNMammals/imglib/Mammalia'
        for i in 'Order', 'Family', 'Genus', 'Species':
            path = os.path.join(path, sppdat['%sName' % (i,)])
        imglib = os.path.join('/var/www',path)
        imglib = os.path.join(imglib, '*.[Jj][Pp][Gg]')
        path = os.path.join('/',path)
        lst = [os.path.split(i)[1] for i in glob.glob(imglib)]
        lst.sort()
        return path, lst

class mainPages(mammalProviderBase):
    """provide content for pages in 'main' folder"""
    __parent = mammalProviderBase
    def provide(self, what):
        """add one layer to &lt;BASE&gt;"""
        ans = self.__parent.provide(self, what)
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/']+'main/')
        return ans
''' 
table = (
    (1, 'class mammalProviderBase'),
    (2, '__init__'),
    (2, 'provide'),
    (2, 'imagePath'),
    (1, 'class mainPages'),
    (2, 'provide'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.18"># ~/at-auto-test.py

s = '''\
# This is valid Python, but it looks like a section reference.
a = b &lt;&lt; c &gt;&gt; d
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)

# Always passes, but *sometimes* i.check gives a message!
</t>
<t tx="ekr.20161115063144.19">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class ItasException(Exception):

    pass

def gpRun(gp, cmd, args, log = None):

    """Wrapper for making calls to the geoprocessor and reporting errors"""

    if log:

        log('gp: %s: %s\\n' % (cmd, str(args)))
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)


</t>
<t tx="ekr.20161115063144.20">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class emptyClass: pass

def followingDef():
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.21">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class emptyClass: pass # comment

def followingDef(): # comment
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.22">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class aClass:
    def def1(self):
        pass

    if False or g.unitTesting:

        def pr(*args,**keys): # reportMismatch test
            g.es_print(color='blue',*args,**keys)

        pr('input...')
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.23">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class aClass:
    def def1(self):
        pass

    if False or g.unitTesting:

        def pr(*args,**keys): # reportMismatch test
            g.es_print(color='blue',*args,**keys)

        pr('input...')

    def def2(self):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.24">@tabwidth -4
    # Required when running unit tests externally.
if 1: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
# This caused PyParse.py not to be imported properly.
s = r'''
import re
if 0: # Causes the 'overindent'
   if 0:   # for throwaway debugging output
      def dump(*stuff):
        sys.__stdout__.write(" ".join(map(str, stuff)) + "\n")
for ch in "({[":
   _tran[ord(ch)] = '('
class testClass1:
    pass
'''
table = (
    (1, 'Declarations'),
    # (1, "if 0: # Causes the 'overindent'"),
    (1, 'class testClass1'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.25">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class BaseScanner:

        """The base class for all import scanner classes."""

        def __init__ (self,importCommands,language):

            self.c = ic.c

        def createHeadline (self,parent,body,headline):
            # g.trace("parent,headline:",parent,headline)
            return p
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.26">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class BaseScanner:
    def containsUnderindentedComment(self):
        a = 2
    # A true underindented comment.
        b = 3
    # This underindented comment should be placed with next function.
    def empty(self):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.27">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class BaseScanner:
    def containsUnderindentedComment(self):
        a = 2
    #
        b = 3
        # This comment is part of the present function.

    def empty(self):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.28">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class aClass: # trailing comment


    def def1(self):             # trailing comment
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.29">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

xyz = 6 # trailing comment
pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.3">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class testClass1 # no colon
    pass

def spam():
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.30"># For comparison with unindent does not end function.

@tabwidth -4
    # Required when running unit tests externally.

s = '''\

def foo():
    pass

def bar():
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.31">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\

class emptyClass: 

    def spam():
        """docstring line 1
under-indented docstring line"""
        pass

def followingDef(): # comment
    pass
'''
table = (
    (1, 'class emptyClass'),
    (2, 'spam'),
    (1, 'followingDef'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.32">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

def foo():

    error("""line1
line2.
""")

    a = 5

def bar():
    pass
'''

showTree = False
keepTree = False

c.importCommands.pythonUnitTest(p,s=s,showTree=showTree)

if showTree:
    try:
        child = p.firstChild()
        n = child.numberOfChildren()
        assert n == 2, 'expected 2 children, got %s' % n
    finally:
        if keepTree:
            h = child.h
            print('h',h)
            child.setHeadString('@'+h)
        else:
            while p.hasChildren():
                p.firstChild().doDelete()
        c.redraw(p)
</t>
<t tx="ekr.20161115063144.33">@killcolor

s = '''\

"""Generic output formatting.
"""

import sys


AS_IS = None


class NullFormatter:
    """A formatter which does nothing.

    If the writer parameter is omitted, a NullWriter instance is created.
    No methods of the writer are called by NullFormatter instances.

    Implementations should inherit from this class if implementing a writer
    interface but don't need to inherit any implementation.

    """

    def __init__(self, writer=None):
        if writer is None:
            writer = NullWriter()
        self.writer = writer
    def end_paragraph(self, blankline): pass
    def add_line_break(self): pass
    def add_hor_rule(self, *args, **kw): pass
    def add_label_data(self, format, counter, blankline=None): pass
    def add_flowing_data(self, data): pass
    def add_literal_data(self, data): pass
    def flush_softspace(self): pass
    def push_alignment(self, align): pass
    def pop_alignment(self): pass
    def push_font(self, x): pass
    def pop_font(self): pass
    def push_margin(self, margin): pass
    def pop_margin(self): pass
    def set_spacing(self, spacing): pass
    def push_style(self, *styles): pass
    def pop_style(self, n=1): pass
    def assert_line_data(self, flag=1): pass


class AbstractFormatter:
    """The standard formatter.

    This implementation has demonstrated wide applicability to many writers,
    and may be used directly in most circumstances.  It has been used to
    implement a full-featured World Wide Web browser.

    """

    #  Space handling policy:  blank spaces at the boundary between elements
    #  are handled by the outermost context.  "Literal" data is not checked
    #  to determine context, so spaces in literal data are handled directly
    #  in all circumstances.

    def __init__(self, writer):
        self.writer = writer            # Output device
        self.align = None               # Current alignment
        self.align_stack = []           # Alignment stack
        self.font_stack = []            # Font state
        self.margin_stack = []          # Margin state
        self.spacing = None             # Vertical spacing state
        self.style_stack = []           # Other state, e.g. color
        self.nospace = 1                # Should leading space be suppressed
        self.softspace = 0              # Should a space be inserted
        self.para_end = 1               # Just ended a paragraph
        self.parskip = 0                # Skipped space between paragraphs?
        self.hard_break = 1             # Have a hard break
        self.have_label = 0

    def end_paragraph(self, blankline):
        if not self.hard_break:
            self.writer.send_line_break()
            self.have_label = 0
        if self.parskip &lt; blankline and not self.have_label:
            self.writer.send_paragraph(blankline - self.parskip)
            self.parskip = blankline
            self.have_label = 0
        self.hard_break = self.nospace = self.para_end = 1
        self.softspace = 0

    def add_line_break(self):
        if not (self.hard_break or self.para_end):
            self.writer.send_line_break()
            self.have_label = self.parskip = 0
        self.hard_break = self.nospace = 1
        self.softspace = 0

    def add_hor_rule(self, *args, **kw):
        if not self.hard_break:
            self.writer.send_line_break()
        self.writer.send_hor_rule(*args, **kw)
        self.hard_break = self.nospace = 1
        self.have_label = self.para_end = self.softspace = self.parskip = 0

    def add_label_data(self, format, counter, blankline = None):
        if self.have_label or not self.hard_break:
            self.writer.send_line_break()
        if not self.para_end:
            self.writer.send_paragraph((blankline and 1) or 0)
        if isinstance(format, str):
            self.writer.send_label_data(self.format_counter(format, counter))
        else:
            self.writer.send_label_data(format)
        self.nospace = self.have_label = self.hard_break = self.para_end = 1
        self.softspace = self.parskip = 0

    def format_counter(self, format, counter):
        label = ''
        for c in format:
            if c == '1':
                label = label + ('%d' % counter)
            elif c in 'aA':
                if counter &gt; 0:
                    label = label + self.format_letter(c, counter)
            elif c in 'iI':
                if counter &gt; 0:
                    label = label + self.format_roman(c, counter)
            else:
                label = label + c
        return label

    def format_letter(self, case, counter):
        label = ''
        while counter &gt; 0:
            counter, x = divmod(counter-1, 26)
            # This makes a strong assumption that lowercase letters
            # and uppercase letters form two contiguous blocks, with
            # letters in order!
            s = chr(ord(case) + x)
            label = s + label
        return label

    def format_roman(self, case, counter):
        ones = ['i', 'x', 'c', 'm']
        fives = ['v', 'l', 'd']
        label, index = '', 0
        # This will die of IndexError when counter is too big
        while counter &gt; 0:
            counter, x = divmod(counter, 10)
            if x == 9:
                label = ones[index] + ones[index+1] + label
            elif x == 4:
                label = ones[index] + fives[index] + label
            else:
                if x &gt;= 5:
                    s = fives[index]
                    x = x-5
                else:
                    s = ''
                s = s + ones[index]*x
                label = s + label
            index = index + 1
        if case == 'I':
            return label.upper()
        return label

    def add_flowing_data(self, data):
        if not data: return
        # The following looks a bit convoluted but is a great improvement over
        # data = regsub.gsub('[' + string.whitespace + ']+', ' ', data)
        prespace = data[:1].isspace()
        postspace = data[-1:].isspace()
        data = " ".join(data.split())
        if self.nospace and not data:
            return
        elif prespace or self.softspace:
            if not data:
                if not self.nospace:
                    self.softspace = 1
                    self.parskip = 0
                return
            if not self.nospace:
                data = ' ' + data
        self.hard_break = self.nospace = self.para_end = \
                          self.parskip = self.have_label = 0
        self.softspace = postspace
        self.writer.send_flowing_data(data)

    def add_literal_data(self, data):
        if not data: return
        if self.softspace:
            self.writer.send_flowing_data(" ")
        self.hard_break = data[-1:] == '\n'
        self.nospace = self.para_end = self.softspace = \
                       self.parskip = self.have_label = 0
        self.writer.send_literal_data(data)

    def flush_softspace(self):
        if self.softspace:
            self.hard_break = self.para_end = self.parskip = \
                              self.have_label = self.softspace = 0
            self.nospace = 1
            self.writer.send_flowing_data(' ')

    def push_alignment(self, align):
        if align and align != self.align:
            self.writer.new_alignment(align)
            self.align = align
            self.align_stack.append(align)
        else:
            self.align_stack.append(self.align)

    def pop_alignment(self):
        if self.align_stack:
            del self.align_stack[-1]
        if self.align_stack:
            self.align = align = self.align_stack[-1]
            self.writer.new_alignment(align)
        else:
            self.align = None
            self.writer.new_alignment(None)

    def push_font(self, (size, i, b, tt)):
        if self.softspace:
            self.hard_break = self.para_end = self.softspace = 0
            self.nospace = 1
            self.writer.send_flowing_data(' ')
        if self.font_stack:
            csize, ci, cb, ctt = self.font_stack[-1]
            if size is AS_IS: size = csize
            if i is AS_IS: i = ci
            if b is AS_IS: b = cb
            if tt is AS_IS: tt = ctt
        font = (size, i, b, tt)
        self.font_stack.append(font)
        self.writer.new_font(font)

    def pop_font(self):
        if self.font_stack:
            del self.font_stack[-1]
        if self.font_stack:
            font = self.font_stack[-1]
        else:
            font = None
        self.writer.new_font(font)

    def push_margin(self, margin):
        self.margin_stack.append(margin)
        fstack = filter(None, self.margin_stack)
        if not margin and fstack:
            margin = fstack[-1]
        self.writer.new_margin(margin, len(fstack))

    def pop_margin(self):
        if self.margin_stack:
            del self.margin_stack[-1]
        fstack = filter(None, self.margin_stack)
        if fstack:
            margin = fstack[-1]
        else:
            margin = None
        self.writer.new_margin(margin, len(fstack))

    def set_spacing(self, spacing):
        self.spacing = spacing
        self.writer.new_spacing(spacing)

    def push_style(self, *styles):
        if self.softspace:
            self.hard_break = self.para_end = self.softspace = 0
            self.nospace = 1
            self.writer.send_flowing_data(' ')
        for style in styles:
            self.style_stack.append(style)
        self.writer.new_styles(tuple(self.style_stack))

    def pop_style(self, n=1):
        del self.style_stack[-n:]
        self.writer.new_styles(tuple(self.style_stack))

    def assert_line_data(self, flag=1):
        self.nospace = self.hard_break = not flag
        self.para_end = self.parskip = self.have_label = 0


class NullWriter:
    """Minimal writer interface to use in testing &amp; inheritance.

    A writer which only provides the interface definition; no actions are
    taken on any methods.  This should be the base class for all writers
    which do not need to inherit any implementation methods.

    """
    def __init__(self): pass
    def flush(self): pass
    def new_alignment(self, align): pass
    def new_font(self, font): pass
    def new_margin(self, margin, level): pass
    def new_spacing(self, spacing): pass
    def new_styles(self, styles): pass
    def send_paragraph(self, blankline): pass
    def send_line_break(self): pass
    def send_hor_rule(self, *args, **kw): pass
    def send_label_data(self, data): pass
    def send_flowing_data(self, data): pass
    def send_literal_data(self, data): pass


class AbstractWriter(NullWriter):
    """A writer which can be used in debugging formatters, but not much else.

    Each method simply announces itself by printing its name and
    arguments on standard output.

    """

    def new_alignment(self, align):
        print "new_alignment(%s)" % `align`

    def new_font(self, font):
        print "new_font(%s)" % `font`

    def new_margin(self, margin, level):
        print "new_margin(%s, %d)" % (`margin`, level)

    def new_spacing(self, spacing):
        print "new_spacing(%s)" % `spacing`

    def new_styles(self, styles):
        print "new_styles(%s)" % `styles`

    def send_paragraph(self, blankline):
        print "send_paragraph(%s)" % `blankline`

    def send_line_break(self):
        print "send_line_break()"

    def send_hor_rule(self, *args, **kw):
        print "send_hor_rule()"

    def send_label_data(self, data):
        print "send_label_data(%s)" % `data`

    def send_flowing_data(self, data):
        print "send_flowing_data(%s)" % `data`

    def send_literal_data(self, data):
        print "send_literal_data(%s)" % `data`


class DumbWriter(NullWriter):
    """Simple writer class which writes output on the file object passed in
    as the file parameter or, if file is omitted, on standard output.  The
    output is simply word-wrapped to the number of columns specified by
    the maxcol parameter.  This class is suitable for reflowing a sequence
    of paragraphs.

    """

    def __init__(self, file=None, maxcol=72):
        self.file = file or sys.stdout
        self.maxcol = maxcol
        NullWriter.__init__(self)
        self.reset()

    def reset(self):
        self.col = 0
        self.atbreak = 0

    def send_paragraph(self, blankline):
        self.file.write('\n'*blankline)
        self.col = 0
        self.atbreak = 0

    def send_line_break(self):
        self.file.write('\n')
        self.col = 0
        self.atbreak = 0

    def send_hor_rule(self, *args, **kw):
        self.file.write('\n')
        self.file.write('-'*self.maxcol)
        self.file.write('\n')
        self.col = 0
        self.atbreak = 0

    def send_literal_data(self, data):
        self.file.write(data)
        i = data.rfind('\n')
        if i &gt;= 0:
            self.col = 0
            data = data[i+1:]
        data = data.expandtabs()
        self.col = self.col + len(data)
        self.atbreak = 0

    def send_flowing_data(self, data):
        if not data: return
        atbreak = self.atbreak or data[0].isspace()
        col = self.col
        maxcol = self.maxcol
        write = self.file.write
        for word in data.split():
            if atbreak:
                if col + len(word) &gt;= maxcol:
                    write('\n')
                    col = 0
                else:
                    write(' ')
                    col = col + 1
            write(word)
            col = col + len(word)
            atbreak = 1
        self.col = col
        self.atbreak = data[-1].isspace()


def test(file = None):
    w = DumbWriter()
    f = AbstractFormatter(w)
    if file is not None:
        fp = open(file)
    elif sys.argv[1:]:
        fp = open(sys.argv[1])
    else:
        fp = sys.stdin
    while 1:
        line = fp.readline()
        if not line:
            break
        if line == '\n':
            f.end_paragraph(1)
        else:
            f.add_flowing_data(line)
    f.end_paragraph(0)


if __name__ == '__main__':
    test()
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.34"># Was unittest/at_auto-unit-test.py
if 0: # Preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
class class1:
    def class1_method1():
        pass
    def class1_method2():
        pass
    # After @others in child1.
class class2:
    def class2_method1():
        pass
    def class2_method2():
        pass
# last line
'''
table = (
    (1, 'class class1'),
    (2, 'class1_method1'),
    (2, 'class1_method2'),
    (1, 'class class2'),
    (2, 'class2_method1'),
    (2, 'class2_method2'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()

</t>
<t tx="ekr.20161115063144.4">@tabwidth -4
    # Required when running unit tests externally.

# Leo bug 603720
# Within the docstring we must change '\' to '\\'
s = '''\
def foo():
    s = \\
"""#!/bin/bash
cd /tmp
ls"""
    file('/tmp/script', 'w').write(s)

class bar:
    pass

foo()
'''

tree = c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.5">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class testClass2:
    pass
'''

tree = c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.6">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class testClass1:
    """A docstring"""
    def __init__ (self):
        pass
    def f1(self):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.7">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
NS = { 'i': 'http://www.inkscape.org/namespaces/inkscape',
      's': 'http://www.w3.org/2000/svg',
      'xlink' : 'http://www.w3.org/1999/xlink'}

tabLevels = 4  # number of defined tablevels, FIXME, could derive from template?
'''
table = (
    # (1, g.angleBrackets('Declarations')),
    (1, 'Declarations'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.8">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
import leo.core.leoGlobals as g

a = 3
'''
table = (
    # (1, g.angleBrackets('Declarations')),
    (1, 'Declarations'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.9">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class Index:
    """docstring"""
    @cherrypy.nocolor
    @cherrypy.expose
    def index(self):
        return "Hello world!"
        
    @cmd('abc')
    def abc(self):
        return "abc"
'''

try:
    c.importCommands.pythonUnitTest(p,s=s,showTree=True) # Must be true.
    index = g.findNodeInTree(c, p, 'index')
    assert index
    lines = g.splitLines(index.b)
    assert lines[0] == '@cherrypy.nocolor\n', repr(lines[0])
    assert lines[1] == '@cherrypy.expose\n', repr(lines[1])
    abc = g.findNodeInTree(c,p, 'abc')
    lines = g.splitLines(abc.b)
    assert lines[0] == "@cmd('abc')\n", repr(lines[0])
    if 1:
        p.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115092708.1"># g.cls()
import leo.plugins.importers.python as python
# import imp
# imp.reload(python)
# A list of dictionaries.
if 0:
    tests = [
        # g.Bunch(line='s = "\\""', ctx=('', '')),
        g.Bunch(line='\\\n'),
    ]
else:
    tests = [
        g.Bunch(line='\n'),
        g.Bunch(line='\\\n'),
        g.Bunch(line='s = "\\""', ctx=('', '')), # empty string.
        g.Bunch(line="s = '\\''", ctx=('', '')), # empty string.
        g.Bunch(line='# comment'),
        g.Bunch(line='  # comment'),
        g.Bunch(line='    # comment'),
        g.Bunch(line='a = "string"'),
        g.Bunch(line='a = "Continued string', ctx=('', '"')),
        g.Bunch(line='end of continued string"', ctx=('"', '')),
        g.Bunch(line='a = """Continued docstring', ctx=('', '"""')),
        g.Bunch(line='a = """#', ctx=('', '"""')),
        g.Bunch(line='end of continued string"""', ctx=('"""', '')),
        g.Bunch(line="a = '''Continued docstring", ctx=('', "'''")),
        g.Bunch(line="end of continued string'''", ctx=("'''", '')),
        g.Bunch(line='a = {[(')
    ]
importer = python.Py_Importer(c.importCommands, atAuto=True)
importer.test_scan_state(tests, State=python.Python_ScanState)
</t>
<t tx="ekr.20161117000902.1">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = """\
# -*- coding: utf-8 -*-
import leo.core.leoGlobals as g
class LeoImportCommands(object):
    '''A class implementing all of Leo's import/export code.'''
    def createOutline(self, fileName, parent, atAuto=False, atShadow=False, s=None, ext=None):
        '''Create an outline by importing a file or string.'''

    def dispatch(self, ext, p):
        '''Return the correct scanner function for p, an @auto node.'''
        # Match the @auto type first, then the file extension.
        return self.scanner_for_at_auto(p) or self.scanner_for_ext(ext)
    def scanner_for_at_auto(self, p):
        '''A factory returning a scanner function for p, an @auto node.'''
        d = self.atAutoDict
        for key in d.keys():
            aClass = d.get(key)
            if aClass and g.match_word(p.h, 0, key):
                if trace: g.trace('found', aClass.__name__)

                def scanner_for_at_auto_cb(atAuto, parent, s, prepass=False):
                    try:
                        scanner = aClass(importCommands=self, atAuto=atAuto)
                        return scanner.run(s, parent, prepass=prepass)
                    except Exception:
                        g.es_print('Exception running', aClass.__name__)
                        g.es_exception()
                        return None

                if trace: g.trace('found', p.h)
                return scanner_for_at_auto_cb
        if trace: g.trace('not found', p.h, sorted(d.keys()))
        return None
    def scanner_for_ext(self, ext):
        '''A factory returning a scanner function for the given file extension.'''
        aClass = self.classDispatchDict.get(ext)
        if aClass:

            def scanner_for_ext_cb(atAuto, parent, s, prepass=False):
                try:
                    scanner = aClass(importCommands=self, atAuto=atAuto)
                    return scanner.run(s, parent, prepass=prepass)
                except Exception:
                    g.es_print('Exception running', aClass.__name__)
                    g.es_exception()
                    return None

            return scanner_for_ext_cb
        else:
            return None
    def get_import_filename(self, fileName, parent):
        '''Return the absolute path of the file and set .default_directory.'''

    def init_import(self, atAuto, atShadow, ext, fileName, s):
        '''Init ivars &amp; vars for imports.'''
"""
table = (
    # (1, g.angleBrackets('Declarations')),
    (1, 'Declarations'),
    (1, "class LeoImportCommands"),
    (2, "createOutline"),
    (2, "dispatch"),
    (2, "scanner_for_at_auto"),
    (3, "scanner_for_at_auto_cb"),
    (2, "scanner_for_ext"),
    (3, "scanner_for_ext_cb"),
    (2, "get_import_filename"),
    (2, "init_import"),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161117011147.1">import leo.plugins.importers.linescanner as linescanner
table = [
    ('', 'abc\n'),
    ('    ', '    xyz\n'),
    ('    ', '    \n'),
    ('  ','  # comment\n'),
    ('', '\n'),
]
importer = linescanner.Importer(c.importCommands,
    atAuto=True, language='python')
for val, s in table:
    assert val == importer.get_str_lws(s), (val, repr(s))
</t>
<t tx="ekr.20161118144658.1">@tabwidth -2 # Required

s = r'''
class Builder
  constructor: -&gt;
    @transformer = new Transformer
  # `build()`

  build: (args...) -&gt;
    node = args[0]
    @transform node

    name = 'other'
    name = node.typeName()  if node != undefined and node.typeName

    fn  = (@[name] or @other)
    out = fn.apply(this, args)

    if node.parenthesized then paren(out) else out
  # `transform()`

  transform: (args...) -&gt;
    @transformer.transform.apply(@transformer, args)

  # `body()`

  body: (node, opts={}) -&gt;
    str = @build(node, opts)
    str = blockTrim(str)
    str = unshift(str)
    if str.length &gt; 0 then str else ""
'''
table = (
  'class Builder',
  'constructor: -&gt;',
  'build: (args...) -&gt;',
  'transform: (args...) -&gt;',
  'body: (node, opts={}) -&gt;',
)
try:
    c.importCommands.coffeeScriptUnitTest(p,s=s,showTree=True)
    if 1:
      p2 = c.p.firstChild().firstChild()
      for h in table:
          assert p2.h == h, (p2.h, h)
          p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161119031833.1"># ('len',   'tr///', '/',       context,  0,       0,       0),
# ('len',   's///',  '/',       context,  0,       0,       0),
# ('len',   'm//',   '/',       context,  0,       0,       0),
# ('len',   '/',     '/',       '',       0,       0,       0),

s = '''\
#!/usr/bin/perl

sub test1 {
    s = /{/g;
}

sub test2 {
    s = m//{/;
}

sub test3 {
    s = s///{/;
}

sub test4 {
    s = tr///{/;
}
'''
try:
    c.importCommands.perlUnitTest(p,s=s,showTree=True)
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161119032623.1">if 0:
    # The preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.perl
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.perl)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
#!/usr/bin/perl

sub test1 {
    s = /}/g;
}

sub test2 {
    s = m//}/;
}

sub test3 {
    s = s///}/;
}

sub test4 {
    s = tr///}/;
}
'''
table = (
    'sub test1',
    'sub test2',
    'sub test3',
    'sub test4'
)
try:
    ic.perlUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161123080832.1">'''Create a table of expected headlines in a unit test.'''
g.cls()
# Proper escapes are tricky.
table = [
    '"%s",' % p.h.replace('\\', '\\\\').replace('"', '\\"')
        for p in c.p.subtree()
]
print("table = (\n    %s\n)" % '\n    '.join(table))</t>
<t tx="ekr.20161123115047.1"></t>
<t tx="ekr.20161123120652.1">s = r'''
var name = 'Bob';

hello() {
  print('Hello, World!');
}

// Define a function.
printNumber(num aNumber) {
  print('The number is $aNumber.'); // Print to console.
}

// This is where the app starts executing.
void main() {
  var number = 42; // Declare and initialize a variable.
  printNumber(number); // Call a function.
}
'''
table = (
    'hello',
    'printNumber',
    'void main',
)
try:
    c.importCommands.dartUnitTest(p,s=s,showTree=True)
    root = c.p.firstChild()
    p2 = root.firstChild()
    for h in table:
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
    assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161123202857.1"></t>
<t tx="ekr.20161123202924.1">s = '''\
* Section 1
Sec 1.
* Section 2
Sec 2.
** Section 2-1
Sec 2.1
*** Section 2-1-1
Sec 2.1.1
* Section 3
** Section 3.1
Sec 3.1
'''
table = (
    'Section 1',
    'Section 2', 'Section 2-1', 'Section 2-1-1',
    'Section 3', 'Section 3.1',
)
try:
    c.importCommands.orgUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.firstChild()
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()

</t>
<t tx="ekr.20161124021953.210">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161124021953.211">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161124021953.212">gnx: ekr.20090627070131.4976
unl: spam
gnx: ekr.20090627070131.4977
unl: cheese
</t>
<t tx="ekr.20161124021953.213">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161124021953.214">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161124021953.215">gnx: ekr.20100801125533.5789
unl: spam
gnx: ekr.20100801125533.5790
unl: cheese
</t>
<t tx="ekr.20161124040933.1"></t>
<t tx="ekr.20161124040933.2">@tabwidth 4 # Required
s = '''\
Section 1
: Sec 1.
Section 2
: Sec 2.
\tSection 2-1
: Sec 2-1
\t\tSection 2-1-1
: Sect 2-1-1
Section 3
: Sec 3
\tSection 3.1
: Sec 3.1
'''
table = (
    'Section 1',
    'Section 2', 'Section 2-1', 'Section 2-1-1',
    'Section 3', 'Section 3.1',
)
try:
    c.importCommands.otlUnitTest(p,s=s,showTree=True)
    if 0:
        root = c.p.firstChild()
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161125134815.1">if 0:
    # The preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    # imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    ic = leoImport.LeoImportCommands(c)
    # x = markdown.Markdown_Importer(ic, atAuto=False)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.
#Header

After header text

##Subheader

Not an underline

----------------

After subheader text

#Last header: no text
'''
table = (
    '!Declarations',
    'Header',
        'Subheader',
        'Last header: no text',
)
try:
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@auto-m'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161125230415.1">s = '''\
Top
====

The top section

Section 1
---------

section 1, line 1
-- Not an underline
secttion 1, line 2

Section 2
---------

section 2, line 1

###Section 2.1

section 2.1, line 1

####Section 2.1.1

section 2.2.1 line 1

###Section 2.2
section 2.2, line 1.

Section 3
---------

section 3, line 1

'''
</t>
<t tx="ekr.20161126111517.1">if 0:
    # The preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    # imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    ic = leoImport.LeoImportCommands(c)
    # x = markdown.Markdown_Importer(ic, atAuto=False)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.
#Header

After header text

##Subheader

Not an underline

----------------

This *should* be a section
==========================

After subheader text

#Last header: no text
'''
table = (
    '!Declarations',
    'Header',
        'Subheader',
            'This *should* be a section',
        'Last header: no text',
)
try:
    g.app.suppressImportChecks = True
        # Required, because the implicit underlining *must*
        # cause the perfect-import test to fail!
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@auto-m'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    g.app.suppressImportChecks = False
        # Not needed: done in Importer.check
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161127181028.1">if 0:
    # The preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    # imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    ic = leoImport.LeoImportCommands(c)
    # x = markdown.Markdown_Importer(ic, atAuto=False)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.
#Header

```python
loads.init = {
    Chloride: 11.5,
    TotalP: 0.002,
}
```
#Last header
'''
table = (
    '!Declarations',
    'Header',
    'Last header',
)
try:
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161129030232.1"></t>
<t tx="ekr.20161129104243.1">if 0:
    # The preamble...
    # g.cls()
    if c.isChanged(): c.save()
    import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst as leo_rst
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

# Notes:
# All heading must be followed by an empty line.
### g.app.suppressImportChecks = True
s = '''\
  #########
Chapter 1
  #########

It was a dark and stormy night.
section 1
+++++++++

Sec 1.
section 2
+++++++++

Sec 2.
'''
table = (
    '!Dummy chapter',
    'section 1',
    'section 2',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161129222003.1">s = '''\
&lt;?php
class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
'''

c.importCommands.phpUnitTest(p,s=s,showTree=True)
</t>
<t tx="ekr.20161130041921.1">#section 1
Sec 1.

#section 2
Sec 2.
@language python
@tabwidth -4
@ignore
</t>
<t tx="ekr.20161130042452.50">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161130042452.51">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161130050706.29">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161130050706.30">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161130051657.1">s = '''\
Leading text in root node of subtree

Etc. etc.

### A level one node ######################################################

This would be the text in this level one node.

And this.

### Another level one node ################################################

Another one

#### A level 2 node #######################################################

See what we did there - one more '#' - this is a subnode.
'''
ic = c.importCommands
ic.ctextUnitTest(p,fileName='@auto-ctext test.txt',s=s,showTree=True)</t>
<t tx="ekr.20161130053017.1">gnx: ekr.20161130052935.1
</t>
<t tx="ekr.20161130053149.1">Leading text in root node of subtree

Etc. etc.

### A level one node ######################################################

This would be the text in this level one node.

And this.

### Another level one node ################################################

Another one

#### A level 2 node #######################################################

See what we did there - one more '#' - this is a subnode.

</t>
<t tx="ekr.20161202053644.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161202053644.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161202083956.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161202083956.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161202093319.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093319.2">
The top section

</t>
<t tx="ekr.20161202093319.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093319.4">
section 2, line 1

</t>
<t tx="ekr.20161202093319.5">
section 2.1, line 1

</t>
<t tx="ekr.20161202093319.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093319.7">section 2.2, line 1.

</t>
<t tx="ekr.20161202093319.8">
section 3, line 1

</t>
<t tx="ekr.20161202093322.10">
The top section

</t>
<t tx="ekr.20161202093322.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093322.12">
section 2, line 1

</t>
<t tx="ekr.20161202093322.13">
section 2.1, line 1

</t>
<t tx="ekr.20161202093322.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093322.15">section 2.2, line 1.

</t>
<t tx="ekr.20161202093322.16">
section 3, line 1

</t>
<t tx="ekr.20161202093322.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093409.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093409.2">
The top section

</t>
<t tx="ekr.20161202093409.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093409.4">
section 2, line 1

</t>
<t tx="ekr.20161202093409.5">
section 2.1, line 1

</t>
<t tx="ekr.20161202093409.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093409.7">section 2.2, line 1.

</t>
<t tx="ekr.20161202093409.8">
section 3, line 1

</t>
<t tx="ekr.20161202093410.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093410.2">
The top section

</t>
<t tx="ekr.20161202093410.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093410.4">
section 2, line 1

</t>
<t tx="ekr.20161202093410.5">
section 2.1, line 1

</t>
<t tx="ekr.20161202093410.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093410.7">section 2.2, line 1.

</t>
<t tx="ekr.20161202093410.8">
section 3, line 1

</t>
<t tx="ekr.20161202093505.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161202093505.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161202093509.22">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093509.23">
The top section

</t>
<t tx="ekr.20161202093509.24">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093509.25">
section 2, line 1

</t>
<t tx="ekr.20161202093509.26">
section 2.1, line 1

</t>
<t tx="ekr.20161202093509.27">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093509.28">section 2.2, line 1.

</t>
<t tx="ekr.20161202093509.29">
section 3, line 1

</t>
<t tx="ekr.20161202093709.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093709.2">#Top
The top section

</t>
<t tx="ekr.20161202093709.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161202093709.4">section 2, line 1

</t>
<t tx="ekr.20161202093709.5">section 2.1, line 1

</t>
<t tx="ekr.20161202093709.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161202093709.7">
</t>
<t tx="ekr.20161202093709.8">Section 3, line 1

</t>
<t tx="ekr.20161204034138.15">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204034138.16">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204034142.19">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204034142.20">The top section

</t>
<t tx="ekr.20161204034142.21">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204034142.22">section 2, line 1

</t>
<t tx="ekr.20161204034142.23">section 2.1, line 1

</t>
<t tx="ekr.20161204034142.24">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204034142.25">
</t>
<t tx="ekr.20161204034142.26">Section 3, line 1

</t>
<t tx="ekr.20161204034142.27">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204034142.28">
The top section

</t>
<t tx="ekr.20161204034142.29">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204034142.30">
section 2, line 1

</t>
<t tx="ekr.20161204034142.31">
section 2.1, line 1

</t>
<t tx="ekr.20161204034142.32">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204034142.33">section 2.2, line 1.

</t>
<t tx="ekr.20161204034142.34">
section 3, line 1

</t>
<t tx="ekr.20161204034207.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204034207.10">
The top section

</t>
<t tx="ekr.20161204034207.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204034207.12">
section 2, line 1

</t>
<t tx="ekr.20161204034207.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204034207.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204034207.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204034207.16">
section 3, line 1

</t>
<t tx="ekr.20161204034207.2">The top section

</t>
<t tx="ekr.20161204034207.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204034207.4">section 2, line 1

</t>
<t tx="ekr.20161204034207.5">section 2.1, line 1

</t>
<t tx="ekr.20161204034207.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204034207.7">
</t>
<t tx="ekr.20161204034207.8">Section 3, line 1

</t>
<t tx="ekr.20161204034207.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204034537.1">gnx: ekr.20161130041921.1
</t>
<t tx="ekr.20161204035447.20">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204035447.21">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204035451.19">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204035451.20">The top section

</t>
<t tx="ekr.20161204035451.21">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204035451.22">section 2, line 1

</t>
<t tx="ekr.20161204035451.23">section 2.1, line 1

</t>
<t tx="ekr.20161204035451.24">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204035451.25">
</t>
<t tx="ekr.20161204035451.26">Section 3, line 1

</t>
<t tx="ekr.20161204035451.27">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204035451.28">
The top section

</t>
<t tx="ekr.20161204035451.29">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204035451.30">
section 2, line 1

</t>
<t tx="ekr.20161204035451.31">
section 2.1, line 1

</t>
<t tx="ekr.20161204035451.32">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204035451.33">section 2.2, line 1.

</t>
<t tx="ekr.20161204035451.34">
section 3, line 1

</t>
<t tx="ekr.20161204040924.1"></t>
<t tx="ekr.20161204041306.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041306.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041310.53">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041310.54">The top section

</t>
<t tx="ekr.20161204041310.55">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041310.56">section 2, line 1

</t>
<t tx="ekr.20161204041310.57">section 2.1, line 1

</t>
<t tx="ekr.20161204041310.58">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041310.59">
</t>
<t tx="ekr.20161204041310.60">Section 3, line 1

</t>
<t tx="ekr.20161204041310.61">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041310.62">
The top section

</t>
<t tx="ekr.20161204041310.63">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041310.64">
section 2, line 1

</t>
<t tx="ekr.20161204041310.65">
section 2.1, line 1

</t>
<t tx="ekr.20161204041310.66">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041310.67">section 2.2, line 1.

</t>
<t tx="ekr.20161204041310.68">
section 3, line 1

</t>
<t tx="ekr.20161204041354.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041354.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041358.103">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041358.104">The top section

</t>
<t tx="ekr.20161204041358.105">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041358.106">section 2, line 1

</t>
<t tx="ekr.20161204041358.107">section 2.1, line 1

</t>
<t tx="ekr.20161204041358.108">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041358.109">
</t>
<t tx="ekr.20161204041358.110">Section 3, line 1

</t>
<t tx="ekr.20161204041359.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041359.2">
The top section

</t>
<t tx="ekr.20161204041359.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041359.4">
section 2, line 1

</t>
<t tx="ekr.20161204041359.5">
section 2.1, line 1

</t>
<t tx="ekr.20161204041359.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041359.7">section 2.2, line 1.

</t>
<t tx="ekr.20161204041359.8">
section 3, line 1

</t>
<t tx="ekr.20161204041418.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041418.10">
The top section

</t>
<t tx="ekr.20161204041418.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041418.12">
section 2, line 1

</t>
<t tx="ekr.20161204041418.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204041418.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041418.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204041418.16">
section 3, line 1

</t>
<t tx="ekr.20161204041418.2">The top section

</t>
<t tx="ekr.20161204041418.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041418.4">section 2, line 1

</t>
<t tx="ekr.20161204041418.5">section 2.1, line 1

</t>
<t tx="ekr.20161204041418.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041418.7">
</t>
<t tx="ekr.20161204041418.8">Section 3, line 1

</t>
<t tx="ekr.20161204041418.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041426.33">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041426.34">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041557.1"></t>
<t tx="ekr.20161204041641.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041641.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041645.103">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041645.104">The top section

</t>
<t tx="ekr.20161204041645.105">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041645.106">section 2, line 1

</t>
<t tx="ekr.20161204041645.107">section 2.1, line 1

</t>
<t tx="ekr.20161204041645.108">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041645.109">
</t>
<t tx="ekr.20161204041645.110">Section 3, line 1

</t>
<t tx="ekr.20161204041646.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041646.2">
The top section

</t>
<t tx="ekr.20161204041646.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041646.4">
section 2, line 1

</t>
<t tx="ekr.20161204041646.5">
section 2.1, line 1

</t>
<t tx="ekr.20161204041646.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041646.7">section 2.2, line 1.

</t>
<t tx="ekr.20161204041646.8">
section 3, line 1

</t>
<t tx="ekr.20161204041720.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041720.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041724.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041724.10">
The top section

</t>
<t tx="ekr.20161204041724.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041724.12">
section 2, line 1

</t>
<t tx="ekr.20161204041724.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204041724.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041724.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204041724.16">
section 3, line 1

</t>
<t tx="ekr.20161204041724.2">The top section

</t>
<t tx="ekr.20161204041724.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041724.4">section 2, line 1

</t>
<t tx="ekr.20161204041724.5">section 2.1, line 1

</t>
<t tx="ekr.20161204041724.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041724.7">
</t>
<t tx="ekr.20161204041724.8">Section 3, line 1

</t>
<t tx="ekr.20161204041724.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041755.29">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041755.30">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041800.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041800.10">
The top section

</t>
<t tx="ekr.20161204041800.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041800.12">
section 2, line 1

</t>
<t tx="ekr.20161204041800.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204041800.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041800.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204041800.16">
section 3, line 1

</t>
<t tx="ekr.20161204041800.2">The top section

</t>
<t tx="ekr.20161204041800.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041800.4">section 2, line 1

</t>
<t tx="ekr.20161204041800.5">section 2.1, line 1

</t>
<t tx="ekr.20161204041800.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041800.7">
</t>
<t tx="ekr.20161204041800.8">Section 3, line 1

</t>
<t tx="ekr.20161204041800.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041842.20">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041842.21">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041902.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041902.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041920.33">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041920.34">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042116.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204042116.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042155.7">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204042155.8">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042301.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204042301.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042305.100">section 2.1, line 1

</t>
<t tx="ekr.20161204042305.101">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204042305.102">
</t>
<t tx="ekr.20161204042305.103">Section 3, line 1

</t>
<t tx="ekr.20161204042305.104">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042305.105">
The top section

</t>
<t tx="ekr.20161204042305.106">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204042305.107">
section 2, line 1

</t>
<t tx="ekr.20161204042305.108">
section 2.1, line 1

</t>
<t tx="ekr.20161204042305.109">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204042305.110">section 2.2, line 1.

</t>
<t tx="ekr.20161204042305.111">
section 3, line 1

</t>
<t tx="ekr.20161204042305.96">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042305.97">The top section

</t>
<t tx="ekr.20161204042305.98">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204042305.99">section 2, line 1

</t>
<t tx="ekr.20161204042714.33">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204042714.34">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042719.10">
</t>
<t tx="ekr.20161204042719.11">Section 3, line 1

</t>
<t tx="ekr.20161204042719.12">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042719.13">
The top section

</t>
<t tx="ekr.20161204042719.14">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204042719.15">
section 2, line 1

</t>
<t tx="ekr.20161204042719.16">
section 2.1, line 1

</t>
<t tx="ekr.20161204042719.17">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204042719.18">section 2.2, line 1.

</t>
<t tx="ekr.20161204042719.19">
section 3, line 1

</t>
<t tx="ekr.20161204042719.4">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042719.5">The top section

</t>
<t tx="ekr.20161204042719.6">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204042719.7">section 2, line 1

</t>
<t tx="ekr.20161204042719.8">section 2.1, line 1

</t>
<t tx="ekr.20161204042719.9">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204042739.15">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204042739.16">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042822.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042822.10">
The top section

</t>
<t tx="ekr.20161204042822.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204042822.12">
section 2, line 1

</t>
<t tx="ekr.20161204042822.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204042822.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204042822.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204042822.16">
section 3, line 1

</t>
<t tx="ekr.20161204042822.2">The top section

</t>
<t tx="ekr.20161204042822.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204042822.4">section 2, line 1

</t>
<t tx="ekr.20161204042822.5">section 2.1, line 1

</t>
<t tx="ekr.20161204042822.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204042822.7">
</t>
<t tx="ekr.20161204042822.8">Section 3, line 1

</t>
<t tx="ekr.20161204042822.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042916.1">print('start python tests')
</t>
<t tx="ekr.20161204042938.1">print('end python tests')
</t>
<t tx="ekr.20161204043013.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204043013.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204043017.19">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043017.20">The top section

</t>
<t tx="ekr.20161204043017.21">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204043017.22">section 2, line 1

</t>
<t tx="ekr.20161204043017.23">section 2.1, line 1

</t>
<t tx="ekr.20161204043017.24">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204043017.25">
</t>
<t tx="ekr.20161204043017.26">Section 3, line 1

</t>
<t tx="ekr.20161204043017.27">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043017.28">
The top section

</t>
<t tx="ekr.20161204043017.29">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204043017.30">
section 2, line 1

</t>
<t tx="ekr.20161204043017.31">
section 2.1, line 1

</t>
<t tx="ekr.20161204043017.32">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204043017.33">section 2.2, line 1.

</t>
<t tx="ekr.20161204043017.34">
section 3, line 1

</t>
<t tx="ekr.20161204043028.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204043028.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204043032.100">section 2.1, line 1

</t>
<t tx="ekr.20161204043032.101">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204043032.102">
</t>
<t tx="ekr.20161204043032.103">Section 3, line 1

</t>
<t tx="ekr.20161204043032.104">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043032.105">
The top section

</t>
<t tx="ekr.20161204043032.106">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204043032.107">
section 2, line 1

</t>
<t tx="ekr.20161204043032.108">
section 2.1, line 1

</t>
<t tx="ekr.20161204043032.109">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204043032.110">section 2.2, line 1.

</t>
<t tx="ekr.20161204043032.111">
section 3, line 1

</t>
<t tx="ekr.20161204043032.96">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043032.97">The top section

</t>
<t tx="ekr.20161204043032.98">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204043032.99">section 2, line 1

</t>
<t tx="ekr.20161204043342.40">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204043342.41">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204043346.10">
</t>
<t tx="ekr.20161204043346.11">Section 3, line 1

</t>
<t tx="ekr.20161204043346.12">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043346.13">
The top section

</t>
<t tx="ekr.20161204043346.14">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204043346.15">
section 2, line 1

</t>
<t tx="ekr.20161204043346.16">
section 2.1, line 1

</t>
<t tx="ekr.20161204043346.17">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204043346.18">section 2.2, line 1.

</t>
<t tx="ekr.20161204043346.19">
section 3, line 1

</t>
<t tx="ekr.20161204043346.4">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043346.5">The top section

</t>
<t tx="ekr.20161204043346.6">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204043346.7">section 2, line 1

</t>
<t tx="ekr.20161204043346.8">section 2.1, line 1

</t>
<t tx="ekr.20161204043346.9">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204045827.15">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204045827.16">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204045955.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204045955.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204154852.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204154852.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204155218.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204155218.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161205045751.1">gnx: ekr.20161205045639.17
unl: A level one node
gnx: ekr.20161205045639.18
unl: Another level one node
gnx: ekr.20161205045639.19
unl: Another level one node--&gt;A level 2 node
</t>
<t tx="ekr.20161205045751.2"></t>
<t tx="ekr.20161205045751.3"></t>
<t tx="ekr.20161206135449.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161206135449.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161206165824.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161206165824.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161216141227.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161216141227.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161216141315.1">if 0:
    # The preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    # imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    ic = leoImport.LeoImportCommands(c)
    # x = markdown.Markdown_Importer(ic, atAuto=False)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.

#@@ Header

After header text

##@@Subheader

Not an underline

----------------

This *should* be a section
==========================

After subheader text

#Last header: no text
'''
table = (
    '!Declarations',
    '@verbatim', # This is an artifact of the unit test.
    '@@ Header',
        '@@Subheader',
            'This *should* be a section',
        'Last header: no text',
)
try:
    g.app.suppressImportChecks = True
        # Required, because the implicit underlining *must*
        # cause the perfect-import test to fail!
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@auto-m'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    g.app.suppressImportChecks = False
        # Not needed: done in Importer.check
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161218103650.1">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
import sys

if sys.version_info[0] &gt;= 3:
    exec_ = eval('exec')
else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")

def make_parser():

    parser = argparse.ArgumentParser(
        description="""Raster calcs. with GDAL.
        The first --grid defines the projection, extent, cell size, and origin
        for all calculations, all other grids are transformed and resampled
        as needed to match.""",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
)
'''
table = (
    (1, 'Declarations'),
    # (1, 'if sys.version_info[0] &gt;= 3:'),
    (1, 'make_parser'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161218104646.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161218104646.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161220185154.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161220185154.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221062411.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221062411.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221063636.208">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161221063636.209">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161221063636.210">gnx: ekr.20090627070131.4976
unl: spam
gnx: ekr.20090627070131.4977
unl: cheese
</t>
<t tx="ekr.20161221063636.211">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161221063636.212">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161221063636.213">gnx: ekr.20100801125533.5789
unl: spam
gnx: ekr.20100801125533.5790
unl: cheese
</t>
<t tx="ekr.20161221063734.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221063734.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221065120.206">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161221065120.207">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161221065120.208">gnx: ekr.20090627070131.4976
unl: spam
gnx: ekr.20090627070131.4977
unl: cheese
</t>
<t tx="ekr.20161221065120.209">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161221065120.210">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161221065120.211">gnx: ekr.20100801125533.5789
unl: spam
gnx: ekr.20100801125533.5790
unl: cheese
</t>
<t tx="ekr.20161221065216.7">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221065216.8">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221080848.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221080848.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221091453.20">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221091453.21">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221091950.20">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221091950.21">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221092134.208">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161221092134.209">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161221092134.210">gnx: ekr.20090627070131.4976
unl: spam
gnx: ekr.20090627070131.4977
unl: cheese
</t>
<t tx="ekr.20161221092134.211">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161221092134.212">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161221092134.213">gnx: ekr.20100801125533.5789
unl: spam
gnx: ekr.20100801125533.5790
unl: cheese
</t>
<t tx="ekr.20161221092230.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221092230.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161222064421.1"># From xo.py.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = r'''#!/usr/bin/env python3

import os
import re

def merge_value(v1, v2):
    return v

class MainDisplay(object):

    def save_file(self):
        """Write the file out to disk."""
        with open(self.save_name, "w") as f:
            for newline in newlines:
                f.write(newline)

# This line should be included at the end of the class node.
ensure_endswith_newline = lambda x: x if x.endswith('\n') else x + '\n'

def retab(s, tabsize):
    return ''.join(pieces)

if __name__=="__main__":
    main()
'''
table = (
    # @auto does not allow section references.
    # (1, g.angleBrackets('Declarations')),
    (1, 'Declarations'),
    (1, 'merge_value'),
    (1, 'class MainDisplay'),
    (2, 'save_file'),
    (1, 'retab'),
    # (1, 'if __name__=="__main__":'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161222122038.3">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161222122038.4">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161222123534.3">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161222123534.4">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161222123640.208">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161222123640.209">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161222123640.210">gnx: ekr.20090627070131.4976
unl: spam
gnx: ekr.20090627070131.4977
unl: cheese
</t>
<t tx="ekr.20161222123640.211">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161222123640.212">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161222123640.213">gnx: ekr.20100801125533.5789
unl: spam
gnx: ekr.20100801125533.5790
unl: cheese
</t>
<t tx="ekr.20161222123751.3">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161222123751.4">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161223153752.1">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161223153752.2">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161223153752.3">gnx: ekr.20090627070131.4976
unl: spam
gnx: ekr.20090627070131.4977
unl: cheese
</t>
<t tx="ekr.20161223153752.4">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161223153752.5">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161223153752.6">gnx: ekr.20100801125533.5789
unl: spam
gnx: ekr.20100801125533.5790
unl: cheese
</t>
<t tx="ekr.20161223153848.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161223153848.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161224101046.1">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''
"""
A PyQt "task launcher" for quick access to python scripts.

Buttons to click to make working in Windows less unproductive.

e.g. a button to move the current window to top or bottom half
of screen, because Windows-Up / Windows-Down doesn't do that.
Or quote the text on the clipboard properly, because Outlook
can't do that.

terrynbrown@gmail.com, 2016-12-23
"""

import sys
import time
from PyQt4 import QtGui, QtCore, Qt
from PyQt4.QtCore import Qt as QtConst

COMMANDS = []

class Draggable(QtGui.QWidget):
    def __init__(self, *args, **kwargs):
        """__init__
        """

        QtGui.QWidget.__init__(self, *args, **kwargs)
        # self.setMouseTracking(True)
        self.offset = None
        layout = QtGui.QHBoxLayout()
        self.setLayout(layout)
        layout.addItem(QtGui.QSpacerItem(15, 5))
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)

    def mousePressEvent(self, event):
        self.offset = event.pos()

    def mouseMoveEvent(self, event):
        x=event.globalX()
        y=event.globalY()
        x_w = self.offset.x()
        y_w = self.offset.y()
        self.parent().move(x-x_w, y-y_w)

def command(name):
    def makebutton(function):
        COMMANDS.append((name, function))
        return function
    return makebutton

@command("Exit")
def exit_():
    exit()

def main():

    app = Qt.QApplication(sys.argv)

    main = QtGui.QMainWindow(None,
       # QtConst.CustomizeWindowHint  |
       QtConst.FramelessWindowHint #  |
       # QtConst.WindowCloseButtonHint
    )

    main.resize(800,16)
    main.move(40,40)
    mainwidj = Draggable()

    for name, function in COMMANDS:
        button = QtGui.QPushButton(name)
        button.clicked.connect(function)
        mainwidj.layout().addWidget(button)

    main.setCentralWidget(mainwidj)
    main.show()
    app.exec_()

if __name__ == '__main__':
    main()
'''
table = (
    (1, "Declarations"),
    (1, "class Draggable"),
    (2, "__init__"),
    (2, "mousePressEvent"),
    (2, "mouseMoveEvent"),
    (1, "command"),
    (2, "makebutton"),
    (1, "exit_"),
    (1, "main"),
    # (1, "if __name__ == '__main__':"),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    c.importCommands.pythonUnitTest(p,s=s,showTree=True) # Must be true.
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    target = g.findNodeInTree(c, root, 'exit_')
    assert target
    lines = g.splitLines(target.b)
    assert lines[0] == '@command("Exit")\n', repr(lines[0])
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161224111342.1">import glob
import os
if 1: # Preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.basescanner as basescanner
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.basescanner)
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

try:
    base_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'core')
    assert g.os_path_exists(base_dir), base_dir
    files = glob.glob('%s%s%s' % (base_dir, os.sep, '*.py'))
    files = [z for z in files if g.shortFileName(z).startswith('leo')]
    # leoTangle contains section refs in @c sections.
    files = [z for z in files
        if not g.shortFileName(z).endswith('leoTangle.py')]
    if 1: # Do just one file.
        files = [z for z in files
            if g.shortFileName(z).endswith('leoFrame.py')]
    test_node = p.copy()
    fails = []
    test_node.deleteAllChildren()
    for fn in files:
        sfn = g.shortFileName(fn)
        s = g.readFileIntoUnicodeString(fn)
        s2 = ic.removeSentinelLines(s, '#', None, None)
        try:
            print(sfn)
            ic.pythonUnitTest(p,s=s2,showTree=True)
            test_node.lastChild().h = '@@file %s' % sfn
        except AssertionError:
            print('FAIL: %6s %6s %s' % (len(s), len(s2), sfn))
            fails.append(sfn)
            break ###
    if fails:
        print('%s failures' % (len(fails)))
        g.printList(sorted(fails))
    elif 0:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161224145026.1">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
    
s = '''
def isValidPython(self):
    if sys.platform == 'cli':
        return True
    minimum_python_version = '2.6'
    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0, 1, 2)])
        ok = g.CheckVersion(version, minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                class EmergencyDialog(object):
                    def run(self):
                        """Run the modal emergency dialog."""
                        self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
                        self.top.lift()
                        self.top.grab_set() # Make the dialog a modal dialog.
                        self.root.wait_window(self.top)
                d = EmergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
def loadLocalFile(self, fn, gui, old_c):
    trace = (False or g.trace_startup) and not g.unitTesting
'''
table = (
    (1, 'isValidPython'),
    (2, 'class EmergencyDialog'),
    (3, 'run'),
    (1, 'loadLocalFile'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161228070933.1">if 1: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
s = """
if isPython3:
    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        return s

    def ue(s, encoding):
        return s if g.isUnicode(s) else str(s, encoding)
else:
    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        return builtins.unicode(s) # Suppress pyflakes complaint.

    def ue(s, encoding):
        return builtins.unicode(s, encoding)
"""
table = (
    # (1, 'if isPython3:'),
    (1, 'Declarations'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161228071435.1">if isPython3: # g.not defined yet.
    &lt;&lt; u:1 &gt;&gt;
    &lt;&lt; ue:1 &gt;&gt;
else:
    &lt;&lt; u:2 &gt;&gt;
    &lt;&lt; ue: 2&gt;&gt;
</t>
<t tx="ekr.20161228071822.1">def u(s):
    '''Return s, converted to unicode from Qt widgets.'''
    return s</t>
<t tx="ekr.20161228071836.1">def ue(s, encoding):
    return s if g.isUnicode(s) else str(s, encoding)</t>
<t tx="ekr.20161228071849.1">def u(s):
    '''Return s, converted to unicode from Qt widgets.'''
    return builtins.unicode(s) # Suppress pyflakes complaint.</t>
<t tx="ekr.20161228071905.1">def ue(s, encoding):
    return builtins.unicode(s, encoding)</t>
<t tx="ekr.20161228071915.1">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20161228071942.1">gnx: ekr.20161228071915.1
</t>
<t tx="ekr.20161228071942.2"></t>
<t tx="ekr.20161228072352.1">if isPython3: # g.not defined yet.
    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        return s
    def ue(s, encoding):
        return s if g.isUnicode(s) else str(s, encoding)
else:
    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        return builtins.unicode(s) # Suppress pyflakes complaint.
    def ue(s, encoding):
        return builtins.unicode(s, encoding)
</t>
<t tx="ekr.20161231115527.208">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161231115527.209">gnx: ekr.20090627070131.4975
</t>
<t tx="ekr.20161231115527.210">gnx: ekr.20090627070131.4976
unl: spam
gnx: ekr.20090627070131.4977
unl: cheese
</t>
<t tx="ekr.20161231115527.211">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161231115527.212">gnx: ekr.20100801125533.5788
</t>
<t tx="ekr.20161231115527.213">gnx: ekr.20100801125533.5789
unl: spam
gnx: ekr.20100801125533.5790
unl: cheese
</t>
<t tx="ekr.20161231115548.6">gnx: ekr.20161202200225.5
unl: section 1
gnx: ekr.20161202200225.6
unl: section 2
</t>
<t tx="ekr.20161231115549.10">gnx: ekr.20151009114144.15
unl: section 1
gnx: ekr.20151009114144.16
unl: section 2
</t>
<t tx="ekr.20161231115549.3">gnx: ekr.20151009114144.13
unl: section 1
gnx: ekr.20151009114144.14
unl: section 2
</t>
<t tx="ekr.20161231115551.4">gnx: ekr.20161202200225.7
unl: class class1
gnx: ekr.20161202200225.8
unl: class class1--&gt;class1_method1
gnx: ekr.20161202200225.9
unl: class class1--&gt;class1_method2
gnx: ekr.20161202200225.10
unl: class class2
gnx: ekr.20161202200225.11
unl: class class2--&gt;class2_method1
gnx: ekr.20161202200225.12
unl: class class2--&gt;class2_method2
</t>
<t tx="ekr.20161231115630.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161231115630.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170101083204.1">@others
@language python
@tabwidth -4
@ignore
</t>
<t tx="ekr.20170101083204.10">def useSyntaxColoring(self, p): return True

</t>
<t tx="ekr.20170101083204.11">def write_colorizer_cache(self, p): pass
</t>
<t tx="ekr.20170101083204.12">class StatusLineAPI(object):
    '''The required API for c.frame.statusLine.'''

    @others
</t>
<t tx="ekr.20170101083204.13">def __init__(self, c, parentFrame): pass

</t>
<t tx="ekr.20170101083204.14">def clear(self): pass

</t>
<t tx="ekr.20170101083204.15">def disable(self, background=None): pass

</t>
<t tx="ekr.20170101083204.16">def enable(self, background="white"): pass

</t>
<t tx="ekr.20170101083204.17">def get(self): return ''

</t>
<t tx="ekr.20170101083204.18">def isEnabled(self): return False

</t>
<t tx="ekr.20170101083204.19">def put(self, s, bg=None, fg=None): pass

</t>
<t tx="ekr.20170101083204.2">'''
The base classes for all Leo Windows, their body, log and tree panes, key bindings and menus.

These classes should be overridden to create frames for a particular gui.
'''
big_text_buttons = True
    # True: show buttons instead of immediately loading big text.
import leo.core.leoGlobals as g
import leo.core.leoColorizer as leoColorizer
    # NullColorizer is a subclass of ColorizerMixin
import leo.core.leoMenu as LeoMenu
import leo.core.leoNodes as leoNodes
import time
# or body panes. We must ensure that headline and body text corresponds
# to the VNode corresponding to presently selected outline, and vice
# versa. For example, when the user selects a new headline in the
# outline pane, we must ensure that:
# 
# 1) All vnodes have up-to-date information and
# 
# 2) the body pane is loaded with the correct data.
# 
# Early versions of Leo attempted to satisfy these conditions when the user
# switched outline nodes. Such attempts never worked well; there were too many
# special cases. Later versions of Leo use a much more direct approach: every
# keystroke in the body pane updates the presently selected VNode immediately.
# 
# The LeoTree class contains all the event handlers for the tree pane, and the
# LeoBody class contains the event handlers for the body pane. The following
# convenience methods exists:
# 
# - body.updateBody &amp; tree.updateBody:
#     Called by k.masterCommand after any keystroke not handled by k.masterCommand.
#     These are suprising complex.
# 
# - body.bodyChanged &amp; tree.headChanged:
#     Called by commands throughout Leo's core that change the body or headline.
#     These are thin wrappers for updateBody and updateTree.
# These classes are for documentation and unit testing.
# They are the base class for no class.
</t>
<t tx="ekr.20170101083204.20">def setFocus(self): pass

</t>
<t tx="ekr.20170101083204.21">def update(self): pass
</t>
<t tx="ekr.20170101083204.22">class TreeAPI(object):
    '''The required API for c.frame.tree.'''

    @others
</t>
<t tx="ekr.20170101083204.23">def __init__(self, frame): pass
# Must be defined in subclasses.

</t>
<t tx="ekr.20170101083204.24">def drawIcon(self, p): pass

</t>
<t tx="ekr.20170101083204.25">def editLabel(self, v, selectAll=False, selection=None): pass

</t>
<t tx="ekr.20170101083204.26">def edit_widget(self, p): return None

</t>
<t tx="ekr.20170101083204.27">def redraw(self, p=None, scroll=True, forceDraw=False): pass

</t>
<t tx="ekr.20170101083204.28">def redraw_now(self, p=None, scroll=True, forceDraw=False): pass

</t>
<t tx="ekr.20170101083204.29">def scrollTo(self, p): pass
# May be defined in subclasses.

</t>
<t tx="ekr.20170101083204.3">class ColorizerAPI(object):
    '''The required API of c.frame.body.colorizer.'''

    @others
</t>
<t tx="ekr.20170101083204.30">def initAfterLoad(self): pass

</t>
<t tx="ekr.20170101083204.31">def afterSelectHint(self, p, old_p): pass

</t>
<t tx="ekr.20170101083204.32">def beforeSelectHint(self, p, old_p): pass

</t>
<t tx="ekr.20170101083204.33">def onHeadChanged(self, p, undoType='Typing', s=None, e=None): pass
# Hints for optimization. The proper default is c.redraw()

</t>
<t tx="ekr.20170101083204.34">def redraw_after_contract(self, p=None): pass

</t>
<t tx="ekr.20170101083204.35">def redraw_after_expand(self, p=None): pass

</t>
<t tx="ekr.20170101083204.36">def redraw_after_head_changed(self): pass

</t>
<t tx="ekr.20170101083204.37">def redraw_after_icons_changed(self): pass

</t>
<t tx="ekr.20170101083204.38">def redraw_after_select(self, p=None): pass
# Must be defined in the LeoTree class...
# def OnIconDoubleClick (self,p):

</t>
<t tx="ekr.20170101083204.39">def OnIconCtrlClick(self, p): pass

</t>
<t tx="ekr.20170101083204.4">def __init__(self, c, widget): pass

</t>
<t tx="ekr.20170101083204.40">def editPosition(self): return None

</t>
<t tx="ekr.20170101083204.41">def endEditLabel(self): pass

</t>
<t tx="ekr.20170101083204.42">def getEditTextDict(self, v): return None

</t>
<t tx="ekr.20170101083204.43">def injectCallbacks(self): pass

</t>
<t tx="ekr.20170101083204.44">def onHeadlineKey(self, event): pass

</t>
<t tx="ekr.20170101083204.45">def select(self, p, scroll=True): pass

</t>
<t tx="ekr.20170101083204.46">def setEditPosition(self, p): pass

</t>
<t tx="ekr.20170101083204.47">def updateHead(self, event, w): pass
</t>
<t tx="ekr.20170101083204.48">class WrapperAPI(object):
    '''A class specifying the wrapper api used throughout Leo's core.'''

    @others
</t>
<t tx="ekr.20170101083204.49">def __init__(self, c): pass

</t>
<t tx="ekr.20170101083204.5">def colorize(self, p, incremental=False, interruptable=True): return 'ok'
# def disable (self,p): pass
# def enable (self,p): pass

</t>
<t tx="ekr.20170101083204.50">def appendText(self, s): pass

</t>
<t tx="ekr.20170101083204.51">def clipboard_append(self, s): pass

</t>
<t tx="ekr.20170101083204.52">def clipboard_clear(self): pass

</t>
<t tx="ekr.20170101083204.53">def delete(self, i, j=None): pass

</t>
<t tx="ekr.20170101083204.54">def deleteTextSelection(self): pass

</t>
<t tx="ekr.20170101083204.55">def disable(self): pass

</t>
<t tx="ekr.20170101083204.56">def enable(self, enabled=True): pass

</t>
<t tx="ekr.20170101083204.57">def flashCharacter(self, i, bg='white', fg='red', flashes=3, delay=75): pass

</t>
<t tx="ekr.20170101083204.58">def get(self, i, j): return ''

</t>
<t tx="ekr.20170101083204.59">def getAllText(self): return ''

</t>
<t tx="ekr.20170101083204.6">def kill(self): pass

</t>
<t tx="ekr.20170101083204.60">def getInsertPoint(self): return 0

</t>
<t tx="ekr.20170101083204.61">def getSelectedText(self): return ''

</t>
<t tx="ekr.20170101083204.62">def getSelectionRange(self): return (0, 0)

</t>
<t tx="ekr.20170101083204.63">def getXScrollPosition(self): return 0

</t>
<t tx="ekr.20170101083204.64">def getYScrollPosition(self): return 0

</t>
<t tx="ekr.20170101083204.65">def hasSelection(self): return False

</t>
<t tx="ekr.20170101083204.66">def insert(self, i, s): pass

</t>
<t tx="ekr.20170101083204.67">def see(self, i): pass

</t>
<t tx="ekr.20170101083204.68">def seeInsertPoint(self): pass

</t>
<t tx="ekr.20170101083204.69">def selectAllText(self, insert=None): pass

</t>
<t tx="ekr.20170101083204.7">def scanColorDirectives(self, p): return 'python'

</t>
<t tx="ekr.20170101083204.70">def setAllText(self, s, h=None): pass

</t>
<t tx="ekr.20170101083204.71">def setFocus(self): pass # Required: sets the focus to wrapper.widget.

</t>
<t tx="ekr.20170101083204.72">def setInsertPoint(self, pos, s=None): pass

</t>
<t tx="ekr.20170101083204.73">def setSelectionRange(self, i, j, insert=None): pass

</t>
<t tx="ekr.20170101083204.74">def setXScrollPosition(self, i): pass

</t>
<t tx="ekr.20170101083204.75">def setYScrollPosition(self, i): pass

</t>
<t tx="ekr.20170101083204.76">def tag_configure(self, colorName, **keys): pass

</t>
<t tx="ekr.20170101083204.77">def toPythonIndex(self, index): return 0

</t>
<t tx="ekr.20170101083204.78">def toPythonIndexRowCol(self, index): return (0, 0, 0)
</t>
<t tx="ekr.20170101083204.79">class IconBarAPI(object):
    '''The required API for c.frame.iconBar.'''

    @others
</t>
<t tx="ekr.20170101083204.8">def setHighlighter(self, p): return True

</t>
<t tx="ekr.20170101083204.80">def __init__(self, c, parentFrame): pass

</t>
<t tx="ekr.20170101083204.81">def add(self, *args, **keys): pass

</t>
<t tx="ekr.20170101083204.82">def addRow(self, height=None): pass

</t>
<t tx="ekr.20170101083204.83">def addRowIfNeeded(self): pass

</t>
<t tx="ekr.20170101083204.84">def addWidget(self, w): pass

</t>
<t tx="ekr.20170101083204.85">def clear(self): pass

</t>
<t tx="ekr.20170101083204.86">def createChaptersIcon(self): pass

</t>
<t tx="ekr.20170101083204.87">def deleteButton(self, w): pass

</t>
<t tx="ekr.20170101083204.88">def getNewFrame(self): pass

</t>
<t tx="ekr.20170101083204.89">def setCommandForButton(self, button, command, command_p, controller, gnx, script): pass
</t>
<t tx="ekr.20170101083204.9">def updateSyntaxColorer(self, p): return True

</t>
<t tx="ekr.20170101083204.90">class LeoBody(object):
    '''The base class for the body pane in Leo windows.'''
    @others
</t>
<t tx="ekr.20170101083204.91">def __init__(self, frame, parentFrame):
    '''Ctor for LeoBody class.'''
    c = frame.c
    frame.body = self
    self.c = c
    self.editorWidgets = {} # keys are pane names, values are text widgets
    self.forceFullRecolorFlag = False
    self.frame = frame
    self.parentFrame = parentFrame # New in Leo 4.6.
    self.totalNumberOfEditors = 0
    # May be overridden in subclasses...
    self.widget = None # set in LeoQtBody.setWidget.
    self.wrapper = None # set in LeoQtBody.setWidget.
    self.numberOfEditors = 1
    self.pb = None # paned body widget.
    self.use_chapters = c.config.getBool('use_chapters')
    # Must be overridden in subclasses...
    self.colorizer = None
</t>
<t tx="ekr.20170101083204.92">def cmd(name):
    '''Command decorator for the c.frame.body class.'''
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame', 'body'])
</t>
<t tx="ekr.20170101083204.93">def forceFullRecolor(self):
    self.forceFullRecolorFlag = True

</t>
<t tx="ekr.20170101083204.94">def getColorizer(self):
    return self.colorizer

</t>
<t tx="ekr.20170101083204.95">def updateSyntaxColorer(self, p):
    return self.colorizer.updateSyntaxColorer(p.copy())

</t>
<t tx="ekr.20170101083204.96">def recolor(self, p, incremental=False):
    self.c.requestRecolorFlag = True
    self.c.incrementalRecolorFlag = incremental

recolor_now = recolor
# Methods of this class call the following methods of subclasses (LeoQtBody)
# Fail loudly if these methods are not defined.

</t>
<t tx="ekr.20170101083205.1">def oops(self):
    '''Say that a required method in a subclass is missing.'''
    g.trace("(LeoBody) %s should be overridden in a subclass", g.callers())

</t>
<t tx="ekr.20170101083205.10">def deleteEditor(self, event=None):
    '''Delete the presently selected body text editor.'''
    c = self.c
    w = c.frame.body.wapper
    d = self.editorWidgets
    if len(list(d.keys())) == 1: return
    name = w.leo_name
    del d[name]
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0 / float(len(panes)))
    for pane in panes:
        self.pb.configurepane(pane, size=minSize)
    # Select another editor.
    w = list(d.values())[0]
    # c.frame.body.wrapper = w # Don't do this now?
    self.numberOfEditors -= 1
    self.selectEditor(w)
</t>
<t tx="ekr.20170101083205.100">if not w or not g.isTextWrapper(w):
    if trace: g.trace('not a text widget', w)
    return
</t>
<t tx="ekr.20170101083205.101">if self.cursorStay and wname.startswith('body'):
    tCurPosition = w.getInsertPoint()

i, j = oldSel = w.getSelectionRange() # Returns insert point if no selection.
oldText = w.getAllText()
</t>
<t tx="ekr.20170101083205.102">if middleButton and c.k.previousSelection is not None:
    start, end = c.k.previousSelection
    s = w.getAllText()
    s = s[start: end]
    c.k.previousSelection = None
else:
    s = g.app.gui.getTextFromClipboard()
s = g.toUnicode(s)
# g.trace('pasteText','wname',wname,'s',s,g.callers())
singleLine = wname.startswith('head') or wname.startswith('minibuffer')
</t>
<t tx="ekr.20170101083205.103">if singleLine:
    # Strip trailing newlines so the truncation doesn't cause confusion.
    while s and s[-1] in ('\n', '\r'):
        s = s[: -1]
# Save the horizontal scroll position.
</t>
<t tx="ekr.20170101083205.104">if hasattr(w, 'getXScrollPosition'):
    x_pos = w.getXScrollPosition()
# Update the widget.
</t>
<t tx="ekr.20170101083205.105">if i != j:
    w.delete(i, j)
w.insert(i, s)
w.see(i + len(s) + 2)
</t>
<t tx="ekr.20170101083205.106">if wname.startswith('body'):
    if self.cursorStay:
        if tCurPosition == j:
            offset = len(s)-(j-i)
        else:
            offset = 0
        newCurPosition = tCurPosition + offset
        w.setSelectionRange(i=newCurPosition, j=newCurPosition)

    c.frame.body.forceFullRecolor()
    c.frame.body.onBodyChanged('Paste', oldSel=oldSel, oldText=oldText)
elif singleLine:
    s = w.getAllText()
    while s and s[-1] in ('\n', '\r'):
        s = s[: -1]
    # 2011/11/14: headline width methods do nothing at present.
    # if wname.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        # width = f.tree.headWidth(p=None,s=s)
        # w.setWidth(width)
else:
    pass
# Never scroll horizontally.
</t>
<t tx="ekr.20170101083205.107">if hasattr(w, 'getXScrollPosition'):
    w.setXScrollPosition(x_pos)

\\-8.OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20170101083205.108">def OnPaste(self, event=None):
    return self.pasteText(event=event, middleButton=True)
</t>
<t tx="ekr.20170101083205.109">@cmd('abort-edit-headline')
def abortEditLabelCommand(self, event=None):
    '''End editing of a headline and revert to its previous value.'''
    frame = self; c = frame.c; tree = frame.tree
    p = c.p
</t>
<t tx="ekr.20170101083205.11">def findEditorForChapter(self, chapter, p):
    '''Return an editor to be assigned to chapter.'''
    c = self.c
    d = self.editorWidgets
    values = list(d.values())
    # First, try to match both the chapter and position.
</t>
<t tx="ekr.20170101083205.110">if g.app.batchMode:
    c.notValidInBatchMode("Abort Edit Headline")
    return
# Revert the headline text.
# Calling c.setHeadString is required.
# Otherwise c.redraw would undo the change!
c.setHeadString(p, tree.revertHeadline)
c.redraw(p)
\\-8.@cmd('end-edit-headline')
</t>
<t tx="ekr.20170101083205.111">def endEditLabelCommand(self, event=None, p=None):
    '''End editing of a headline and move focus to the body pane.'''
    frame = self; c = frame.c; k = c.k
</t>
<t tx="ekr.20170101083205.112">if g.app.batchMode:
    c.notValidInBatchMode("End Edit Headline")
else:
    w = c.get_focus()
    w_name = g.app.gui.widget_name(w)
</t>
<t tx="ekr.20170101083205.113">if w_name.startswith('head'):
    c.endEditing()
    c.treeWantsFocus()
else:
    # c.endEditing()
    c.bodyWantsFocus()
    k.setDefaultInputState()
    # Recolor the *body* text, **not** the headline.
    k.showStateAndMode(w=c.frame.body.wrapper)
</t>
<t tx="ekr.20170101083205.114">def resizePanesToRatio(self, ratio, secondary_ratio): self.oops()

</t>
<t tx="ekr.20170101083205.115">def setInitialWindowGeometry(self): self.oops()

</t>
<t tx="ekr.20170101083205.116">def setTopGeometry(self, w, h, x, y, adjustSize=True): self.oops()
# In the Edit menu...

</t>
<t tx="ekr.20170101083205.117">def OnCopy(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.118">def OnCut(self, event=None): self.oops()
#def OnCutFromMenu  (self,event=None):     self.oops()
#def OnCopyFromMenu (self,event=None):     self.oops()
# Expanding and contracting panes.

</t>
<t tx="ekr.20170101083205.119">def contractPane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.12">if p:
    for w in values:
        if (
            hasattr(w, 'leo_chapter') and w.leo_chapter == chapter and
            hasattr(w, 'leo_p') and w.leo_p and w.leo_p == p
        ):
            # g.trace('***',id(w),'match chapter and p',p.h)
            return w
# Next, try to match just the chapter.
for w in values:
</t>
<t tx="ekr.20170101083205.120">def expandPane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.121">def contractBodyPane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.122">def contractLogPane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.123">def contractOutlinePane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.124">def expandBodyPane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.125">def expandLogPane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.126">def expandOutlinePane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.127">def fullyExpandBodyPane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.128">def fullyExpandLogPane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.129">def fullyExpandPane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.13">if hasattr(w, 'leo_chapter') and w.leo_chapter == chapter:
    # g.trace('***',id(w),'match only chapter',p.h)
    return w
\\-12.# As a last resort, return the present editor widget.
\\-12.# g.trace('***',id(self.wrapper),'no match',p.h)
\\-12.return c.frame.body.wrapper
</t>
<t tx="ekr.20170101083205.130">def fullyExpandOutlinePane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.131">def hideBodyPane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.132">def hideLogPane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.133">def hidePane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.134">def hideOutlinePane(self, event=None): self.oops()
# In the Window menu...

</t>
<t tx="ekr.20170101083205.135">def cascade(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.136">def equalSizedPanes(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.137">def hideLogWindow(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.138">def minimizeAll(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.139">def resizeToScreen(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.14">def unselectLabel(self, w):
    self.createChapterIvar(w)
    self.packEditorLabelWidget(w)
    s = self.computeLabel(w)
</t>
<t tx="ekr.20170101083205.140">def toggleActivePane(self, event=None): self.oops()

</t>
<t tx="ekr.20170101083205.141">def toggleSplitDirection(self, event=None): self.oops()
# In help menu...

</t>
<t tx="ekr.20170101083205.142">def leoHelp(self, event=None): self.oops()
# Important: nothing would be gained by calling gui versions of these methods:
#            they can be defined in a gui-dependent way in a subclass.

</t>
<t tx="ekr.20170101083205.143">def bringToFront(self): self.oops()

</t>
<t tx="ekr.20170101083205.144">def deiconify(self): self.oops()

</t>
<t tx="ekr.20170101083205.145">def get_window_info(self): self.oops()

</t>
<t tx="ekr.20170101083205.146">def lift(self): self.oops()
</t>
<t tx="ekr.20170101083205.147">def OnBodyClick(self, event=None):
    pass

</t>
<t tx="ekr.20170101083205.148">def OnBodyRClick(self, event=None):
    pass
</t>
<t tx="ekr.20170101083205.149">def getTitle(self):
    return self.title

</t>
<t tx="ekr.20170101083205.15">if hasattr(w, 'leo_label') and w.leo_label:
    w.leo_label.configure(text=s, bg='LightSteelBlue1')

</t>
<t tx="ekr.20170101083205.150">def setTitle(self, title):
    # g.trace('**(LeoFrame)',title)
    self.title = title
</t>
<t tx="ekr.20170101083205.151">def initAfterLoad(self):
    '''Provide offical hooks for late inits of components of Leo frames.'''
    frame = self
    frame.body.initAfterLoad()
    frame.log.initAfterLoad()
    frame.menu.initAfterLoad()
    # if frame.miniBufferWidget: frame.miniBufferWidget.initAfterLoad()
    frame.tree.initAfterLoad()

</t>
<t tx="ekr.20170101083205.152">def initCompleteHint(self):
    pass
</t>
<t tx="ekr.20170101083205.153">def setTabWidth(self, w):
    '''Set the tab width in effect for this frame.'''
    # Subclasses may override this to affect drawing.
    self.tab_width = w
</t>
<t tx="ekr.20170101083205.154">class LeoLog(object):
    '''The base class for the log pane in Leo windows.'''
    @others
</t>
<t tx="ekr.20170101083205.155">def __init__(self, frame, parentFrame):
    '''Ctor for LeoLog class.'''
    self.frame = frame
    self.c = frame and frame.c or None
    self.enabled = True
    self.newlines = 0
    self.isNull = False
    # Official ivars...
    self.canvasCtrl = None # Set below. Same as self.canvasDict.get(self.tabName)
    self.logCtrl = None # Set below. Same as self.textDict.get(self.tabName)
        # Important: depeding on the log *tab*,
        # logCtrl may be either a wrapper or a widget.
    self.tabName = None # The name of the active tab.
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    self.canvasDict = {} # Keys are page names.  Values are Tk.Canvas's.
    self.frameDict = {} # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    self.textDict = {} # Keys are page names. Values are logCtrl's (text widgets).
</t>
<t tx="ekr.20170101083205.156">def cmd(name):
    '''Command decorator for the LeoLog class.'''
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame', 'log'])
</t>
<t tx="ekr.20170101083205.157">def clearTab(self, tabName, wrap='none'):
    self.selectTab(tabName, wrap=wrap)
    w = self.logCtrl
    if w: w.delete(0, 'end')
</t>
<t tx="ekr.20170101083205.158">def createTab(self, tabName, createText=True, widget=None, wrap='none'):
</t>
<t tx="ekr.20170101083205.159">if createText:
    w = self.createTextWidget(self.tabFrame)
    self.canvasDict[tabName] = None
    self.textDict[tabName] = w
else:
    self.canvasDict[tabName] = None
    self.textDict[tabName] = None
    self.frameDict[tabName] = tabName # tabFrame
</t>
<t tx="ekr.20170101083205.16">def selectLabel(self, w):
</t>
<t tx="ekr.20170101083205.160">def createTextWidget(self, parentFrame):
    return None
</t>
<t tx="ekr.20170101083205.161">@cmd('cycle-tab-focus')
def cycleTabFocus(self, event=None):
    '''Cycle keyboard focus between the tabs in the log pane.'''
    d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    values = list(d.values())
</t>
<t tx="ekr.20170101083205.162">if self.numberOfVisibleTabs() &gt; 1:
    i = values.index(w) + 1
    if i == len(values): i = 0
    tabName = list(d.keys())[i]
    self.selectTab(tabName)
    return i
</t>
<t tx="ekr.20170101083205.163">def deleteTab(self, tabName, force=False):
    c = self.c
</t>
<t tx="ekr.20170101083205.164">if tabName == 'Log':
    pass
elif tabName in ('Find', 'Spell') and not force:
    self.selectTab('Log')
else:
    for d in (self.canvasDict, self.textDict, self.frameDict):
</t>
<t tx="ekr.20170101083205.165">if tabName in d:
    del d[tabName]
\\-16.self.tabName = None
\\-16.self.selectTab('Log')
\\-16.c.invalidateFocus()
\\-16.c.bodyWantsFocus()
</t>
<t tx="ekr.20170101083205.166">def disable(self):
    self.enabled = False

</t>
<t tx="ekr.20170101083205.167">def enable(self, enabled=True):
    self.enabled = enabled
</t>
<t tx="ekr.20170101083205.168">def getSelectedTab(self):
    return self.tabName
</t>
<t tx="ekr.20170101083205.169">def hideTab(self, tabName):
    self.selectTab('Log')
</t>
<t tx="ekr.20170101083205.17">if self.numberOfEditors &gt; 1:
    self.createChapterIvar(w)
    self.packEditorLabelWidget(w)
    s = self.computeLabel(w)
    # g.trace(s,g.callers())
    if hasattr(w, 'leo_label') and w.leo_label:
        w.leo_label.configure(text=s, bg='white')
elif hasattr(w, 'leo_label') and w.leo_label:
    w.leo_label.pack_forget()
    w.leo_label = None
\\-8.selectEditorLockout = False

</t>
<t tx="ekr.20170101083205.170">def lowerTab(self, tabName):
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

</t>
<t tx="ekr.20170101083205.171">def raiseTab(self, tabName):
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
</t>
<t tx="ekr.20170101083205.172">def orderedTabNames(self, LeoLog):
    return list(self.frameDict.values())
</t>
<t tx="ekr.20170101083205.173">def numberOfVisibleTabs(self):
    return len([val for val in list(self.frameDict.values()) if val is not None])
# All output to the log stream eventually comes here.

</t>
<t tx="ekr.20170101083205.174">def put(self, s, color=None, tabName='Log', from_redirect=False):
    print(s)

</t>
<t tx="ekr.20170101083205.175">def putnl(self, tabName='Log'):
    pass # print ('')
</t>
<t tx="ekr.20170101083205.176">def renameTab(self, oldName, newName):
    pass
</t>
<t tx="ekr.20170101083205.177">def selectTab(self, tabName, createText=True, widget=None, wrap='none'): # widget unused.
    '''Create the tab if necessary and make it active.'''
    c = self.c
    tabFrame = self.frameDict.get(tabName)
    # g.trace(tabName, c.shortFileName())
</t>
<t tx="ekr.20170101083205.178">if not tabFrame:
    self.createTab(tabName, createText=createText)
# Update the status vars.
self.tabName = tabName
self.canvasCtrl = self.canvasDict.get(tabName)
self.logCtrl = self.textDict.get(tabName)
self.tabFrame = self.frameDict.get(tabName)
</t>
<t tx="ekr.20170101083205.179">if 0:
    # Absolutely do not do this here!
    # It is a cause of the 'sticky focus' problem.
    c.widgetWantsFocusNow(self.logCtrl)
return tabFrame
</t>
<t tx="ekr.20170101083205.18">def selectEditor(self, w):
    '''Select the editor given by w and node w.leo_p.'''
    #  Called whenever wrapper must be selected.
    c = self.c
</t>
<t tx="ekr.20170101083205.180">class LeoTree(object):
    '''The base class for the outline pane in Leo windows.'''
    @others
</t>
<t tx="ekr.20170101083205.181">def __init__(self, frame):
    '''Ctor for the LeoTree class.'''
    self.frame = frame
    self.c = frame.c
    self.edit_text_dict = {}
        # New in 3.12: keys vnodes, values are edit_widgets.
        # New in 4.2: keys are vnodes, values are pairs (p,edit widgets).
    # "public" ivars: correspond to setters &amp; getters.
    self.drag_p = None
    self._editPosition = None
    self.redrawCount = 0 # For traces
    self.revertHeadline = None
    self.use_chapters = False # May be overridden in subclasses.
    # Define these here to keep pylint happy.
    self.canvas = None
    self.trace_select = None
# These are new in Leo 4.6.

</t>
<t tx="ekr.20170101083205.182">def initAfterLoad(self):
    '''Do late initialization. Called in g.openWithFileName after a successful load.'''

</t>
<t tx="ekr.20170101083205.183">def afterSelectHint(self, p, old_p):
    '''Called at end of tree.select.'''

</t>
<t tx="ekr.20170101083205.184">def beforeSelectHint(self, p, old_p):
    '''Called at start of tree.select.'''
# Hints for optimization. The proper default is c.redraw()

</t>
<t tx="ekr.20170101083205.185">def redraw_after_contract(self, p=None): self.c.redraw()

</t>
<t tx="ekr.20170101083205.186">def redraw_after_expand(self, p=None): self.c.redraw()

</t>
<t tx="ekr.20170101083205.187">def redraw_after_head_changed(self): self.c.redraw()

</t>
<t tx="ekr.20170101083205.188">def redraw_after_icons_changed(self): self.c.redraw()

</t>
<t tx="ekr.20170101083205.189">def redraw_after_select(self, p=None): self.c.redraw()
# Tricky code: do not change without careful thought and testing.
# Important: This code *is* used by the leoBridge module.
# See also, nativeTree.onHeadChanged.

</t>
<t tx="ekr.20170101083205.19">if self.selectEditorLockout:
    return
</t>
<t tx="ekr.20170101083205.190">def onHeadChanged(self, p, undoType='Typing', s=None, e=None): # e used in qt_tree.py.
    '''
    Officially change a headline.
    Set the old undo text to the previous revert point.
    '''
    trace = False and not g.unitTesting
    c = self.c; u = c.undoer
    w = self.edit_widget(p)
</t>
<t tx="ekr.20170101083205.191">if c.suppressHeadChanged:
    if trace: g.trace('c.suppressHeadChanged')
    return
</t>
<t tx="ekr.20170101083205.192">if not w:
    if trace: g.trace('****** no w for p: %s', repr(p))
    return
ch = '\n' # New in 4.4: we only report the final keystroke.
if s is None: s = w.getAllText()
</t>
<t tx="ekr.20170101083205.193">if trace:
    g.trace('*** LeoTree', g.callers(5))
    g.trace(p and p.h, 'w', repr(w), 's', repr(s))
# Remove one or two trailing newlines before warning of truncation.
# for i in (0,1):
    # if s and s[-1] == '\n':
        # if len(s) &gt; 1: s = s[:-1]
        # else: s = ''
while s and s[-1] == '\n':
    s = s[: -1]
# Warn if there are multiple lines.
i = s.find('\n')
</t>
<t tx="ekr.20170101083205.194">if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.warning("truncating headline to one line")
    s = s[: i]
limit = 1000
</t>
<t tx="ekr.20170101083205.195">if len(s) &gt; limit:
    g.warning("truncating headline to", limit, "characters")
    s = s[: limit]
s = g.toUnicode(s or '')
# Make the change official, but undo to the *old* revert point.
oldRevert = self.revertHeadline
changed = s != oldRevert
self.revertHeadline = s
p.initHeadString(s)
if trace: g.trace('changed', changed, 'new', repr(s))
</t>
<t tx="ekr.20170101083205.196">if g.doHook("headkey1", c=c, p=p, v=p, ch=ch, changed=changed):
    return # The hook claims to have handled the event.
</t>
<t tx="ekr.20170101083205.197">if changed:
    undoData = u.beforeChangeNodeContents(p, oldHead=oldRevert)
    if not c.changed: c.setChanged(True)
    # New in Leo 4.4.5: we must recolor the body because
    # the headline may contain directives.
    c.frame.scanForTabWidth(p)
    c.frame.body.recolor(p, incremental=True)
    dirtyVnodeList = p.setDirty()
    u.afterChangeNodeContents(p, undoType, undoData,
        dirtyVnodeList=dirtyVnodeList, inHead=True)
</t>
<t tx="ekr.20170101083205.198">if changed:
    c.redraw_after_head_changed()
    # Fix bug 1280689: don't call the non-existent c.treeEditFocusHelper
g.doHook("headkey2", c=c, p=p, v=p, ch=ch, changed=changed)
</t>
<t tx="ekr.20170101083205.199">def endEditLabel(self):
    '''End editing of a headline and update p.h.'''
    trace = False and not g.unitTesting
    c = self.c; k = c.k; p = c.p
    if trace: g.trace('LeoTree', p and p.h, g.callers(4))
    self.setEditPosition(None) # That is, self._editPosition = None
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)
    if 0: # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
        k.setDefaultInputState()
        k.showStateAndMode()
    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
</t>
<t tx="ekr.20170101083205.2">def createEditorFrame(self, w):
    self.oops()

</t>
<t tx="ekr.20170101083205.20">if w and w == self.c.frame.body.widget:
    if w.leo_p and w.leo_p != c.p:
        c.selectPosition(w.leo_p)
        c.bodyWantsFocus()
    return
try:
    val = None
    self.selectEditorLockout = True
    val = self.selectEditorHelper(w)
finally:
    self.selectEditorLockout = False
return val # Don't put a return in a finally clause.
</t>
<t tx="ekr.20170101083205.200">def getEditTextDict(self, v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v, [])

</t>
<t tx="ekr.20170101083205.201">def editPosition(self):
    return self._editPosition

</t>
<t tx="ekr.20170101083205.202">def setEditPosition(self, p):
    self._editPosition = p
</t>
<t tx="ekr.20170101083205.203">def injectCallbacks(self):
    c = self.c
    # **Important:: These VNode methods are entitled to know about gui-level code.
    @others
</t>
<t tx="ekr.20170101083205.204">def OnHyperLinkControlClick(self, event=None, c=c):
    '''Callback injected into position class.'''
    p = self
</t>
<t tx="ekr.20170101083205.205">if c and c.exists:
    try:
        if not g.doHook("hypercclick1", c=c, p=p, v=p, event=event):
            c.selectPosition(p)
            c.redraw()
            c.frame.body.wrapper.setInsertPoint(0)
        g.doHook("hypercclick2", c=c, p=p, v=p, event=event)
    except Exception:
        g.es_event_exception("hypercclick")
</t>
<t tx="ekr.20170101083205.206">def OnHyperLinkEnter(self, event=None, c=c):
    '''Callback injected into position class.'''
    try:
        p = self
        g.doHook("hyperenter1", c=c, p=p, v=p, event=event)
        g.doHook("hyperenter2", c=c, p=p, v=p, event=event)
    except Exception:
        g.es_event_exception("hyperenter")
</t>
<t tx="ekr.20170101083205.207">def OnHyperLinkLeave(self, event=None, c=c):
    '''Callback injected into position class.'''
    try:
        p = self
        g.doHook("hyperleave1", c=c, p=p, v=p, event=event)
        g.doHook("hyperleave2", c=c, p=p, v=p, event=event)
    except Exception:
        g.es_event_exception("hyperleave")
for f in (OnHyperLinkControlClick, OnHyperLinkEnter, OnHyperLinkLeave):
    g.funcToMethod(f, leoNodes.position)
</t>
<t tx="ekr.20170101083205.208">def onHeadlineKey(self, event):
    '''Handle a key event in a headline.'''
    w = event and event.widget or None
    ch = event and event.char or ''
    # g.trace(repr(ch),g.callers())
    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
</t>
<t tx="ekr.20170101083205.209">if ch:
    # g.trace(repr(ch),g.callers())
    self.updateHead(event, w)
return # (for Tk) 'break' # Required
</t>
<t tx="ekr.20170101083205.21">def selectEditorHelper(self, wrapper):
    '''Select the editor whose widget is given.'''
    c = self.c
    trace = False and not g.unitTesting
</t>
<t tx="ekr.20170101083205.210">def OnIconCtrlClick(self, p):
    g.openUrl(p)
</t>
<t tx="ekr.20170101083205.211">def OnIconDoubleClick(self, p):
    if 0: g.trace(p and p.h)
</t>
<t tx="ekr.20170101083205.212">def updateHead(self, event, w):
    '''Update a headline from an event.

    The headline officially changes only when editing ends.'''
    c = self.c; k = c.k
    ch = event and event.char or ''
    i, j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i
    # g.trace('w',w,'ch',repr(ch),g.callers())
</t>
<t tx="ekr.20170101083205.213">if ch == '\b':
    if i != j: w.delete(i, j)
    else: w.delete(ins - 1)
    w.setSelectionRange(i - 1, i - 1, insert=i - 1)
elif ch and ch not in ('\n', '\r'):
    if i != j: w.delete(i, j)
    elif k.unboundKeyAction == 'overwrite': w.delete(i, i + 1)
    w.insert(ins, ch)
    w.setSelectionRange(ins + 1, ins + 1, insert=ins + 1)
s = w.getAllText()
</t>
<t tx="ekr.20170101083205.214">if s.endswith('\n'):
    s = s[: -1]
# 2011/11/14: Not used at present.
# w.setWidth(self.headWidth(s=s))
</t>
<t tx="ekr.20170101083205.215">if ch in ('\n', '\r'):
    self.endEditLabel() # Now calls self.onHeadChanged.
\\-8.# Drawing &amp; scrolling.

</t>
<t tx="ekr.20170101083205.216">def drawIcon(self, p): self.oops()

</t>
<t tx="ekr.20170101083205.217">def redraw(self, p=None, scroll=True, forceDraw=False): self.oops()

</t>
<t tx="ekr.20170101083205.218">def redraw_now(self, p=None, scroll=True, forceDraw=False): self.oops()

</t>
<t tx="ekr.20170101083205.219">def scrollTo(self, p): self.oops()
# idle_scrollTo = scrollTo # For compatibility.
# Headlines.

</t>
<t tx="ekr.20170101083205.22">if not (hasattr(wrapper, 'leo_p') and wrapper.leo_p):
    g.trace('no wrapper.leo_p')
    return
if trace: g.trace('==1', id(wrapper),
    hasattr(wrapper, 'leo_chapter') and wrapper.leo_chapter and wrapper.leo_chapter.name,
    hasattr(wrapper, 'leo_p') and wrapper.leo_p and wrapper.leo_p.h)
self.deactivateActiveEditor(wrapper)
# The actual switch.
c.frame.body.wrapper = wrapper
wrapper.leo_active = True
self.switchToChapter(wrapper)
self.selectLabel(wrapper)
</t>
<t tx="ekr.20170101083205.220">def editLabel(self, p, selectAll=False, selection=None): self.oops()

</t>
<t tx="ekr.20170101083205.221">def edit_widget(self, p): self.oops()
tree_select_lockout = False

</t>
<t tx="ekr.20170101083205.222">def select(self, p, scroll=True):
    '''
    Select a node.
    Never redraws outline, but may change coloring of individual headlines.
    The scroll argument is used by the gui to suppress scrolling while dragging.
    '''
</t>
<t tx="ekr.20170101083205.223">if g.app.killed or self.tree_select_lockout:
    return None
traceTime = False and not g.unitTesting
</t>
<t tx="ekr.20170101083205.224">if traceTime:
    t1 = time.time()
try:
    c = self.c; old_p = c.p
    val = 'break'
    self.tree_select_lockout = True
    c.frame.tree.beforeSelectHint(p, old_p)
    val = self.selectHelper(p, scroll=scroll)
finally:
    self.tree_select_lockout = False
    c.frame.tree.afterSelectHint(p, old_p)
</t>
<t tx="ekr.20170101083205.225">if traceTime:
    delta_t = time.time() - t1
    if False or delta_t &gt; 0.1:
        print('%20s: %2.3f sec' % ('tree-select:outer', delta_t))
return val # Don't put a return in a finally clause.
</t>
<t tx="ekr.20170101083205.226">def selectHelper(self, p, scroll):
    '''
    A helper function for leoTree.select.
    Do **not** "optimize" this by returning if p==c.p!
    '''
    traceTime = False and not g.unitTesting
</t>
<t tx="ekr.20170101083205.227">if traceTime:
    t1 = time.time()
</t>
<t tx="ekr.20170101083205.228">if not p:
    # This is not an error! We may be changing roots.
    # Do *not* test c.positionExists(p) here!
    return
c = self.c
</t>
<t tx="ekr.20170101083205.229">if not c.frame.body.wrapper:
    return # Defensive.
assert p.v.context == c
    # Selecting a foreign position will not be pretty.
old_p = c.p
call_event_handlers = p != old_p
# Order is important...
self.unselect_helper(old_p, p, traceTime)
self.select_new_node(old_p, p, traceTime)
self.change_current_position(old_p, p, traceTime)
self.scroll_cursor(p, traceTime)
self.set_status_line(p, traceTime)
</t>
<t tx="ekr.20170101083205.23">if not self.ensurePositionExists(wrapper):
    g.trace('***** no position editor!')
    return
</t>
<t tx="ekr.20170101083205.230">if call_event_handlers:
    g.doHook("select2", c=c, new_p=p, old_p=old_p, new_v=p, old_v=old_p)
    g.doHook("select3", c=c, new_p=p, old_p=old_p, new_v=p, old_v=old_p)
</t>
<t tx="ekr.20170101083205.231">if traceTime:
    delta_t = time.time() - t1
    if False or delta_t &gt; 0.1:
        print('%20s: %2.3f sec' % ('tree-select:total', delta_t))
</t>
<t tx="ekr.20170101083205.232">if 0:

    def is_qt_body(self):
        '''Return True if the body widget is a QTextEdit.'''
        c = self.c
        import leo.plugins.qt_text as qt_text
        w = c.frame.body.wrapper.widget
        val = isinstance(w, qt_text.LeoQTextBrowser)
            # c.frame.body.wrapper.widget is a LeoQTextBrowser.
            # c.frame.body.wrapper is a QTextEditWrapper or QScintillaWrapper.
        # if not val: g.trace(val,w,g.callers())
        return val
</t>
<t tx="ekr.20170101083205.233">def unselect_helper(self, old_p, p, traceTime):
    '''Unselect the old node, calling the unselect hooks.'''
    trace = False and not g.unitTesting
</t>
<t tx="ekr.20170101083205.234">if traceTime:
    t1 = time.time()
c = self.c
call_event_handlers = p != old_p
</t>
<t tx="ekr.20170101083205.235">if call_event_handlers:
    unselect = not g.doHook("unselect1", c=c, new_p=p, old_p=old_p, new_v=p, old_v=old_p)
else:
    unselect = True
</t>
<t tx="ekr.20170101083205.236">if unselect and old_p != p:
    if trace: g.trace(p.h)
    # Actually unselect the old node.
    self.endEditLabel() # sets editPosition = None
    self.stop_colorizer(old_p)
    btc = self.c.bigTextController
    if btc and btc.active_flag:
        btc.go_away()
</t>
<t tx="ekr.20170101083205.237">if call_event_handlers:
    g.doHook("unselect2", c=c, new_p=p, old_p=old_p, new_v=p, old_v=old_p)
</t>
<t tx="ekr.20170101083205.238">if traceTime:
    delta_t = time.time() - t1
    if False or delta_t &gt; 0.1:
        print('%20s: %2.3f sec' % ('tree-select:unselect', delta_t))
</t>
<t tx="ekr.20170101083205.239">def stop_colorizer(self, old_p):
    '''Stop colorizing the present node.'''
    c = self.c
    colorizer = c.frame.body.colorizer
</t>
<t tx="ekr.20170101083205.24">if trace:
    g.trace('==2', id(wrapper),
        hasattr(wrapper, 'leo_chapter') and wrapper.leo_chapter and wrapper.leo_chapter.name,
        hasattr(wrapper, 'leo_p') and wrapper.leo_p and wrapper.leo_p.h)
# g.trace('expanding ancestors of ',wrapper.leo_p.h,g.callers())
p = wrapper.leo_p
c.redraw(p)
c.recolor()
c.bodyWantsFocus()
\\-8.# Called from addEditor and assignPositionToEditor

</t>
<t tx="ekr.20170101083205.240">if colorizer:
    if hasattr(colorizer, 'kill'):
        colorizer.kill()
    if (hasattr(colorizer, 'colorCacheFlag') and
        colorizer.colorCacheFlag and
        hasattr(colorizer, 'write_colorizer_cache')
    ):
        colorizer.write_colorizer_cache(old_p)
</t>
<t tx="ekr.20170101083205.241">def select_new_node(self, old_p, p, traceTime):
    '''Select the new node, part 1.'''
</t>
<t tx="ekr.20170101083205.242">if traceTime:
    t1 = time.time()
c = self.c
call_event_handlers = p != old_p
</t>
<t tx="ekr.20170101083205.243">if call_event_handlers:
    select = not g.doHook("select1",
        c=c, new_p=p, old_p=old_p,
        new_v=p, old_v=old_p)
else:
    select = True
</t>
<t tx="ekr.20170101083205.244">if select:
    self.revertHeadline = p.h
    c.frame.setWrap(p)
    # w = c.frame.body.wrapper.widget
    btc = c.bigTextController
    if btc:
        if btc.should_add_buttons(old_p, p):
            btc.add_buttons(old_p, p)
        elif btc.should_go_away(p):
            btc.go_away()
    self.set_body_text_after_select(p, old_p, traceTime)
    c.nodeHistory.update(p)
</t>
<t tx="ekr.20170101083205.245">if traceTime:
    delta_t = time.time() - t1
    if False or delta_t &gt; 0.1:
        print('%20s: %2.3f sec' % ('tree-select:select1', delta_t))
</t>
<t tx="ekr.20170101083205.246">def set_body_text_after_select(self, p, old_p, traceTime, force=False):
    '''Set the text after selecting a node.'''
    trace = False and not g.unitTesting
    trace_pass = False
    trace_time = (True or traceTime)
    if trace_time: t1 = time.time()
    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c
    w = c.frame.body.wrapper
    s = p.v.b # Guaranteed to be unicode.
    # Part 1: get the old text.
    old_s = w.getAllText()
    if trace: g.trace('=====', len(s), p.h)
</t>
<t tx="ekr.20170101083205.247">if trace and trace_time:
    t2 = time.time()
    print('  part1: getAllText %4.2f sec' % (t2-t1))
</t>
<t tx="ekr.20170101083205.248">if not force and p and p == old_p and s == old_s:
    if trace and trace_pass: g.trace('*pass', len(s), p.h, old_p.h)
    return
# Part 2: set the new text.
# w.setAllText destroys all color tags, so do a full recolor.
</t>
<t tx="ekr.20170101083205.249">if 0 &lt; c.max_pre_loaded_body_chars &lt; len(s):
    # Don't load the text if not wanted.
    if trace and trace_time:
        t3 = time.time()
        print('  part2: setAllText %4.2f sec' % (t3-t2))
else:
    w.setAllText(s, h = p.h)
</t>
<t tx="ekr.20170101083205.25">def updateEditors(self):
    c = self.c; p = c.p
    d = self.editorWidgets
    if len(list(d.keys())) &lt; 2: return # There is only the main widget.
    for key in d:
        wrapper = d.get(key)
        v = wrapper.leo_v
</t>
<t tx="ekr.20170101083205.250">if trace and trace_time:
    t3 = time.time()
    print('  part2: setAllText %4.2f sec' % (t3-t2))
# Part 3: colorize.
# We can't call c.recolor_now here.
colorizer = c.frame.body.colorizer
</t>
<t tx="ekr.20170101083205.251">if hasattr(colorizer, 'setHighlighter'):
    if colorizer.setHighlighter(p):
        self.frame.body.recolor(p)
else:
    self.frame.body.recolor(p)
</t>
<t tx="ekr.20170101083205.252">if trace and trace_time:
    t4 = time.time()
    print('  part3: colorize   %4.2f sec' % (t4-t3))
    print('  total:            %4.2f sec' % (t4-t1))
# This is now done after c.p has been changed.
    # p.restoreCursorAndScroll()
</t>
<t tx="ekr.20170101083205.253">def change_current_position(self, old_p, p, traceTime):
    '''Select the new node, part 2.'''
</t>
<t tx="ekr.20170101083205.254">if traceTime:
    t1 = time.time()
c = self.c
c.setCurrentPosition(p)
c.frame.scanForTabWidth(p)
    #GS I believe this should also get into the select1 hook
use_chapters = c.config.getBool('use_chapters')
</t>
<t tx="ekr.20170101083205.255">if use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
c.treeFocusHelper()
c.undoer.onSelect(old_p, p)
</t>
<t tx="ekr.20170101083205.256">if traceTime:
    delta_t = time.time() - t1
    if False or delta_t &gt; 0.1:
        print('%20s: %2.3f sec' % ('tree-select:select2', delta_t))
</t>
<t tx="ekr.20170101083205.257">def scroll_cursor(self, p, traceTime):
    '''Scroll the cursor. It deserves separate timing stats.'''
</t>
<t tx="ekr.20170101083205.258">if traceTime:
    t1 = time.time()
p.restoreCursorAndScroll()
    # Was in setBodyTextAfterSelect
</t>
<t tx="ekr.20170101083205.259">if traceTime:
    delta_t = time.time() - t1
    if False or delta_t &gt; 0.1:
        print('%20s: %2.3f sec' % ('tree-select:scroll', delta_t))
</t>
<t tx="ekr.20170101083205.26">if v and v == p.v and wrapper != c.frame.body.wrapper:
    wrapper.delete(0, 'end')
    wrapper.insert('end', p.b)
    # g.trace('update',wrapper,v)
    self.recolorWidget(p, wrapper)
\\-12.c.bodyWantsFocus()
</t>
<t tx="ekr.20170101083205.260">def set_status_line(self, p, traceTime=False):
    '''Update the status line.'''
</t>
<t tx="ekr.20170101083205.261">if traceTime:
    t1 = time.time()
c = self.c
c.frame.body.assignPositionToEditor(p)
    # New in Leo 4.4.1.
c.frame.updateStatusLine()
    # New in Leo 4.4.1.
c.frame.clearStatusLine()
verbose = getattr(c, 'status_line_unl_mode', '') == 'canonical'
c.frame.putStatusLine(p.get_UNL(with_proto=verbose, with_index=verbose))
</t>
<t tx="ekr.20170101083205.262">if traceTime:
    delta_t = time.time() - t1
    if False or delta_t &gt; 0.1:
        print('%20s: %2.3f sec' % ('tree-select:status', delta_t))
</t>
<t tx="ekr.20170101083205.263">def oops(self):
    g.pr("LeoTree oops:", g.callers(4), "should be overridden in subclass")
</t>
<t tx="ekr.20170101083205.264">class LeoTreeTab(object):
    '''A class representing a tabbed outline pane.'''
    @others
</t>
<t tx="ekr.20170101083205.265">def __init__(self, c, chapterController, parentFrame):
    self.c = c
    self.cc = chapterController
    self.nb = None # Created in createControl.
    self.parentFrame = parentFrame
    self.selectedTabBackgroundColor = c.config.getColor(
        'selected_chapter_tab_background_color') or 'LightSteelBlue2'
    self.selectedTabForegroundColor = c.config.getColor(
        'selected_chapter_tab_foreground_color') or 'black'
    self.unselectedTabBackgroundColor = c.config.getColor(
        'unselected_chapter_tab_background_color') or 'lightgrey'
    self.unselectedTabForegroundColor = c.config.getColor(
        'unselected_chapter_tab_foreground_color') or 'black'
</t>
<t tx="ekr.20170101083205.266">def createControl(self):
    self.oops()

</t>
<t tx="ekr.20170101083205.267">def createTab(self, tabName, select=True):
    self.oops()

</t>
<t tx="ekr.20170101083205.268">def destroyTab(self, tabName):
    self.oops()

</t>
<t tx="ekr.20170101083205.269">def selectTab(self, tabName):
    self.oops()

</t>
<t tx="ekr.20170101083205.27">def computeLabel(self, w):
    s = w.leo_label_s
</t>
<t tx="ekr.20170101083205.270">def setTabLabel(self, tabName):
    self.oops()
</t>
<t tx="ekr.20170101083205.271">def oops(self):
    g.pr("LeoTreeTree oops:", g.callers(4), "should be overridden in subclass")
</t>
<t tx="ekr.20170101083205.272">class NullBody(LeoBody):
    '''A do-nothing body class.'''
    @others
</t>
<t tx="ekr.20170101083205.273">def __init__(self, frame, parentFrame):
    '''Ctor for NullBody class.'''
    # g.trace('NullBody','frame',frame,g.callers())
    LeoBody.__init__(self, frame, parentFrame)
        # Init the base class.
    self.insertPoint = 0
    self.selection = 0, 0
    self.s = "" # The body text
    self.widget = None
    self.wrapper = wrapper = StringTextWrapper(c=self.c, name='body')
    self.editorWidgets['1'] = wrapper
    self.colorizer = NullColorizer(self.c)
</t>
<t tx="ekr.20170101083205.274">def findStartOfLine(self, lineNumber):
    lines = g.splitLines(self.s)
    i = 0; index = 0
    for line in lines:
        if i == lineNumber: break
        i += 1
        index += len(line)
    return index
</t>
<t tx="ekr.20170101083205.275">def scanToStartOfLine(self, i):
</t>
<t tx="ekr.20170101083205.276">if i &lt;= 0:
    return 0
assert(self.s[i] != '\n')
while i &gt;= 0:
</t>
<t tx="ekr.20170101083205.277">if self.s[i] == '\n':
    return i + 1
\\-12.return 0
</t>
<t tx="ekr.20170101083205.278">def scanToEndOfLine(self, i):
</t>
<t tx="ekr.20170101083205.279">if i &gt;= len(self.s):
    return len(self.s)
assert(self.s[i] != '\n')
while i &lt; len(self.s):
</t>
<t tx="ekr.20170101083205.28">if hasattr(w, 'leo_chapter') and w.leo_chapter:
    s = '%s: %s' % (w.leo_chapter.name, s)
return s
</t>
<t tx="ekr.20170101083205.280">if self.s[i] == '\n':
    return i - 1
\\-12.return i
\\-12.# Birth, death...

</t>
<t tx="ekr.20170101083205.281">def createControl(self, parentFrame, p): pass
# Editors...

</t>
<t tx="ekr.20170101083205.282">def addEditor(self, event=None): pass

</t>
<t tx="ekr.20170101083205.283">def assignPositionToEditor(self, p): pass

</t>
<t tx="ekr.20170101083205.284">def createEditorFrame(self, w): return None

</t>
<t tx="ekr.20170101083205.285">def cycleEditorFocus(self, event=None): pass

</t>
<t tx="ekr.20170101083205.286">def deleteEditor(self, event=None): pass

</t>
<t tx="ekr.20170101083205.287">def selectEditor(self, w): pass

</t>
<t tx="ekr.20170101083205.288">def selectLabel(self, w): pass

</t>
<t tx="ekr.20170101083205.289">def setEditorColors(self, bg, fg): pass

</t>
<t tx="ekr.20170101083205.29">def createChapterIvar(self, w):
    c = self.c
    cc = c.chapterController
</t>
<t tx="ekr.20170101083205.290">def unselectLabel(self, w): pass

</t>
<t tx="ekr.20170101083205.291">def updateEditors(self): pass
# Events...

</t>
<t tx="ekr.20170101083205.292">def forceFullRecolor(self): pass

</t>
<t tx="ekr.20170101083205.293">def scheduleIdleTimeRoutine(self, function, *args, **keys): pass
# Low-level gui...

</t>
<t tx="ekr.20170101083205.294">def setFocus(self): pass
</t>
<t tx="ekr.20170101083205.295">class NullColorizer(leoColorizer.ColorizerMixin):
    '''
    A colorizer class that doesn't color,
    but does support methods
    '''
    @others
</t>
<t tx="ekr.20170101083205.296">def __init__(self, c):
    '''NullColorizer'''
    leoColorizer.ColorizerMixin.__init__(self, c)
    self.c = c
    self.count = 0
    self.enabled = False
    self.full_recolor_count = 0
    self.highlighter = None
</t>
<t tx="ekr.20170101083205.297">def colorize(self, p, incremental=False, interruptable=True):
    self.count += 1 # Used by unit tests.
    return 'ok' # Used by unit tests.

</t>
<t tx="ekr.20170101083205.298">def disable(self): pass

</t>
<t tx="ekr.20170101083205.299">def enable(self): pass

</t>
<t tx="ekr.20170101083205.3">def createTextWidget(self, parentFrame, p, name):
    self.oops()

</t>
<t tx="ekr.20170101083205.30">if not hasattr(w, 'leo_chapter') or not w.leo_chapter:
    if cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None
</t>
<t tx="ekr.20170101083205.300">def kill(self): pass

</t>
<t tx="ekr.20170101083205.301">def setHighlighter(self, p): return False

</t>
<t tx="ekr.20170101083205.302">def showInvisibles(self): pass

</t>
<t tx="ekr.20170101083205.303">def write_colorizer_cache(self, p): pass
# External unit tests require the standard (ColorizerMixin) methods for these:
    # def scanColorDirectives(self,p): pass
    # def updateSyntaxColorer (self,p): pass
    # def useSyntaxColoring(self,p): return False
</t>
<t tx="ekr.20170101083205.304">class NullFrame(LeoFrame):
    '''A null frame class for tests and batch execution.'''
    @others
</t>
<t tx="ekr.20170101083205.305">def __init__(self, c, title, gui):
    '''Ctor for the NullFrame class.'''
    # g.trace('NullFrame')
    LeoFrame.__init__(self, c, gui)
        # Init the base class.
    assert self.c
    self.wrapper = None
    self.iconBar = NullIconBarClass(self.c, self)
    self.isNullFrame = True
    self.outerFrame = None
    self.ratio = self.secondary_ratio = 0.5
    self.statusLineClass = NullStatusLineClass
    self.title = title
    self.top = None # Always None.
    # Create the component objects.
    self.body = NullBody(frame=self, parentFrame=None)
    self.log = NullLog(frame=self, parentFrame=None)
    self.menu = LeoMenu.NullMenu(frame=self)
    self.tree = NullTree(frame=self)
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
</t>
<t tx="ekr.20170101083205.306">def destroySelf(self):
    pass
</t>
<t tx="ekr.20170101083205.307">def finishCreate(self):
    # This may be overridden in subclasses.
    pass
</t>
<t tx="ekr.20170101083205.308">def resizePanesToRatio(self, ratio, secondary_ratio): pass

</t>
<t tx="ekr.20170101083205.309">def setInitialWindowGeometry(self): pass
</t>
<t tx="ekr.20170101083205.31">def ensurePositionExists(self, w):
    '''Return True if w.leo_p exists or can be reconstituted.'''
    c = self.c
</t>
<t tx="ekr.20170101083205.310">def setTopGeometry(self, w, h, x, y, adjustSize=True):
    self.w = w
    self.h = h
    self.x = x
    self.y = y
# Expanding and contracting panes.

</t>
<t tx="ekr.20170101083205.311">def contractPane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.312">def expandPane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.313">def contractBodyPane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.314">def contractLogPane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.315">def contractOutlinePane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.316">def expandBodyPane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.317">def expandLogPane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.318">def expandOutlinePane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.319">def fullyExpandBodyPane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.32">if c.positionExists(w.leo_p):
    return True
else:
    g.trace('***** does not exist', w.leo_name)
    for p2 in c.all_unique_positions():
</t>
<t tx="ekr.20170101083205.320">def fullyExpandLogPane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.321">def fullyExpandPane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.322">def fullyExpandOutlinePane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.323">def hideBodyPane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.324">def hideLogPane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.325">def hidePane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.326">def hideOutlinePane(self, event=None): pass
# In the Window menu...

</t>
<t tx="ekr.20170101083205.327">def cascade(self, event=None): pass

</t>
<t tx="ekr.20170101083205.328">def equalSizedPanes(self, event=None): pass

</t>
<t tx="ekr.20170101083205.329">def hideLogWindow(self, event=None): pass

</t>
<t tx="ekr.20170101083205.33">if p2.v and p2.v == w.leo_v:
    w.leo_p = p2.copy()
    return True
\\-16.# This *can* happen when selecting a deleted node.
\\-16.w.leo_p = c.p
\\-16.return False
\\-16.# Not used in Qt.

</t>
<t tx="ekr.20170101083205.330">def minimizeAll(self, event=None): pass

</t>
<t tx="ekr.20170101083205.331">def resizeToScreen(self, event=None): pass

</t>
<t tx="ekr.20170101083205.332">def toggleActivePane(self, event=None): pass

</t>
<t tx="ekr.20170101083205.333">def toggleSplitDirection(self, event=None): pass
# In help menu...

</t>
<t tx="ekr.20170101083205.334">def leoHelp(self, event=None): pass
</t>
<t tx="ekr.20170101083205.335">def bringToFront(self): pass

</t>
<t tx="ekr.20170101083205.336">def deiconify(self): pass

</t>
<t tx="ekr.20170101083205.337">def get_window_info(self):
    # Set w,h,x,y to a reasonable size and position.
    return 600, 500, 20, 20

</t>
<t tx="ekr.20170101083205.338">def lift(self): pass

</t>
<t tx="ekr.20170101083205.339">def setWrap(self, flag, force=False): pass

</t>
<t tx="ekr.20170101083205.34">def deactivateActiveEditor(self, w):
    '''Inactivate the previously active editor.'''
    d = self.editorWidgets
    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        w2 = d.get(key)
</t>
<t tx="ekr.20170101083205.340">def update(self): pass
</t>
<t tx="ekr.20170101083205.341">class NullIconBarClass(object):
    '''A class representing the singleton Icon bar'''
    @others
</t>
<t tx="ekr.20170101083205.342">def __init__(self, c, parentFrame):
    '''Ctor for NullIconBarClass.'''
    self.c = c
    self.iconFrame = None
    self.parentFrame = parentFrame
    self.w = g.NullObject()
</t>
<t tx="ekr.20170101083205.343">def addRow(self, height=None): pass

</t>
<t tx="ekr.20170101083205.344">def addRowIfNeeded(self): pass

</t>
<t tx="ekr.20170101083205.345">def addWidget(self, w): pass

</t>
<t tx="ekr.20170101083205.346">def createChaptersIcon(self): pass

</t>
<t tx="ekr.20170101083205.347">def deleteButton(self, w): pass

</t>
<t tx="ekr.20170101083205.348">def getNewFrame(self): return None

</t>
<t tx="ekr.20170101083205.349">def hide(self): pass

</t>
<t tx="ekr.20170101083205.35">if w2 != w and w2.leo_active:
    w2.leo_active = False
    self.unselectLabel(w2)
    return
</t>
<t tx="ekr.20170101083205.350">def show(self): pass
</t>
<t tx="ekr.20170101083205.351">def add(self, *args, **keys):
    '''Add a (virtual) button to the (virtual) icon bar.'''
    command = keys.get('command')
    text = keys.get('text')
    try:
        g.app.iconWidgetCount += 1
    except Exception:
        g.app.iconWidgetCount = 1
    n = g.app.iconWidgetCount
    name = 'nullButtonWidget %d' % n
    @others
</t>
<t tx="ekr.20170101083205.352">if not command:

    def commandCallback(name=name):
        g.pr("command for %s" % (name))

    command = commandCallback

</t>
<t tx="ekr.20170101083205.353">class nullButtonWidget:

    @others
b = nullButtonWidget(self.c, command, name, text)
return b
</t>
<t tx="ekr.20170101083205.354">def __init__(self, c, command, name, text):
    self.c = c
    self.command = command
    self.name = name
    self.text = text

</t>
<t tx="ekr.20170101083205.355">def __repr__(self):
    return self.name

</t>
<t tx="ekr.20170101083205.356">def clear(self):
    g.app.iconWidgetCount = 0
    g.app.iconImageRefs = []
</t>
<t tx="ekr.20170101083205.357">def setCommandForButton(self, button, command, command_p, controller, gnx, script):
    button.command = command
</t>
<t tx="ekr.20170101083205.358">class NullLog(LeoLog):
    '''A do-nothing log class.'''
    @others
</t>
<t tx="ekr.20170101083205.359">def __init__(self, frame=None, parentFrame=None):
    # Init the base class.
    LeoLog.__init__(self, frame, parentFrame)
    self.isNull = True
    self.logNumber = 0
    self.widget = self.createControl(parentFrame)
        # self.logCtrl is now a property of the base LeoLog class.
</t>
<t tx="ekr.20170101083205.36">def recolorWidget(self, p, w):
    c = self.c
    old_wrapper = c.frame.body.wrapper
    # Save.
    c.frame.body.wrapper = w
    try:
        c.frame.body.colorizer.colorize(p, incremental=False, interruptable=False)
    finally:
        # Restore.
        c.frame.body.wrapper = old_wrapper
</t>
<t tx="ekr.20170101083205.360">def finishCreate(self):
    pass
</t>
<t tx="ekr.20170101083205.361">def createControl(self, parentFrame):
    return self.createTextWidget(parentFrame)
</t>
<t tx="ekr.20170101083205.362">def createTextWidget(self, parentFrame):
    self.logNumber += 1
    c = self.c
    log = StringTextWrapper(c=c, name="log-%d" % self.logNumber)
    return log
</t>
<t tx="ekr.20170101083205.363">def isLogWidget(self, w):
    return False
</t>
<t tx="ekr.20170101083205.364">def oops(self):
    g.trace("NullLog:", g.callers(4))
</t>
<t tx="ekr.20170101083205.365">def put(self, s, color=None, tabName='Log', from_redirect=False):
    # print('(nullGui) print',repr(s))
</t>
<t tx="ekr.20170101083205.366">if self.enabled:
    try:
        g.pr(s, newline=False)
    except UnicodeError:
        s = s.encode('ascii', 'replace')
        g.pr(s, newline=False)

</t>
<t tx="ekr.20170101083205.367">def putnl(self, tabName='Log'):
</t>
<t tx="ekr.20170101083205.368">if self.enabled:
    g.pr('')
</t>
<t tx="ekr.20170101083205.369">def clearTab(self, tabName, wrap='none'): pass

</t>
<t tx="ekr.20170101083205.37">def switchToChapter(self, w):
    '''select w.leo_chapter.'''
    c = self.c; cc = c.chapterController
</t>
<t tx="ekr.20170101083205.370">def createCanvas(self, tabName): pass

</t>
<t tx="ekr.20170101083205.371">def createTab(self, tabName, createText=True, widget=None, wrap='none'): pass

</t>
<t tx="ekr.20170101083205.372">def deleteTab(self, tabName, force=False): pass

</t>
<t tx="ekr.20170101083205.373">def getSelectedTab(self): return None

</t>
<t tx="ekr.20170101083205.374">def lowerTab(self, tabName): pass

</t>
<t tx="ekr.20170101083205.375">def raiseTab(self, tabName): pass

</t>
<t tx="ekr.20170101083205.376">def renameTab(self, oldName, newName): pass

</t>
<t tx="ekr.20170101083205.377">def selectTab(self, tabName, createText=True, widget=None, wrap='none'): pass
</t>
<t tx="ekr.20170101083205.378">class NullStatusLineClass(object):
    '''A do-nothing status line.'''

    @others
</t>
<t tx="ekr.20170101083205.379">def __init__(self, c, parentFrame):
    '''Ctor for NullStatusLine class.'''
    self.c = c
    self.enabled = False
    self.parentFrame = parentFrame
    self.textWidget = StringTextWrapper(c, name='status-line')
    # Set the official ivars.
    c.frame.statusFrame = None
    c.frame.statusLabel = None
    c.frame.statusText = self.textWidget
</t>
<t tx="ekr.20170101083205.38">if hasattr(w, 'leo_chapter') and w.leo_chapter:
    chapter = w.leo_chapter
    name = chapter and chapter.name
    oldChapter = cc.getSelectedChapter()
    if chapter != oldChapter:
        # g.trace('===','old',oldChapter.name,'new',name,w.leo_p)
        cc.selectChapterByName(name)
        c.bodyWantsFocus()
\\-8.# Called from addEditor and assignPositionToEditor.

</t>
<t tx="ekr.20170101083205.380">def disable(self, background=None):
    self.enabled = False
    # self.c.bodyWantsFocus()

</t>
<t tx="ekr.20170101083205.381">def enable(self, background="white"):
    self.c.widgetWantsFocus(self.textWidget)
    self.enabled = True

</t>
<t tx="ekr.20170101083205.382">def clear(self):
    self.textWidget.delete(0, 'end')

</t>
<t tx="ekr.20170101083205.383">def get(self):
    return self.textWidget.getAllText()

</t>
<t tx="ekr.20170101083205.384">def isEnabled(self):
    return self.enabled

</t>
<t tx="ekr.20170101083205.385">def put(self, s, bg=None, fg=None):
    self.textWidget.insert('end', s)

</t>
<t tx="ekr.20170101083205.386">def setFocus(self):
    pass

</t>
<t tx="ekr.20170101083205.387">def update(self):
    pass
</t>
<t tx="ekr.20170101083205.388">class NullTree(LeoTree):
    '''A do-almost-nothing tree class.'''
    @others
</t>
<t tx="ekr.20170101083205.389">def __init__(self, frame):
    '''Ctor for NullTree class.'''
    LeoTree.__init__(self, frame) # Init the base class.
    assert(self.frame)
    self.c = frame.c
    self.editWidgetsDict = {} # Keys are tnodes, values are StringTextWidgets.
    self.font = None
    self.fontName = None
    self.canvas = None
    self.redrawCount = 0
    self.trace_edit = False
    self.trace_select = False
    self.updateCount = 0
</t>
<t tx="ekr.20170101083205.39">def updateInjectedIvars(self, w, p):
    '''Inject updated ivars in w, a gui widget.'''
    c = self.c
    cc = c.chapterController
    # Was in ctor.
    use_chapters = c.config.getBool('use_chapters')
</t>
<t tx="ekr.20170101083205.390">def printWidgets(self):
    d = self.editWidgetsDict
    for key in d:
        # keys are vnodes, values are StringTextWidgets.
        w = d.get(key)
        g.pr('w', w, 'v.h:', key.headString, 's:', repr(w.s))
</t>
<t tx="ekr.20170101083205.391">def drawIcon(self, p):
    pass

</t>
<t tx="ekr.20170101083205.392">def redraw(self, p=None, scroll=True, forceDraw=False):
    self.redrawCount += 1
    # g.trace(p and p.h, self.c.p.h)

</t>
<t tx="ekr.20170101083205.393">def redraw_now(self, p=None, scroll=True, forceDraw=False):
    self.redraw(p)

</t>
<t tx="ekr.20170101083205.394">def redraw_after_contract(self, p=None): self.redraw()

</t>
<t tx="ekr.20170101083205.395">def redraw_after_expand(self, p=None): self.redraw()

</t>
<t tx="ekr.20170101083205.396">def redraw_after_head_changed(self): self.redraw()

</t>
<t tx="ekr.20170101083205.397">def redraw_after_icons_changed(self): self.redraw()

</t>
<t tx="ekr.20170101083205.398">def redraw_after_select(self, p=None): self.redraw()

</t>
<t tx="ekr.20170101083205.399">def scrollTo(self, p):
    pass
</t>
<t tx="ekr.20170101083205.4">def packEditorLabelWidget(self, w):
    self.oops()
# This code uses self.pb, a paned body widget, created by tkBody.finishCreate.
</t>
<t tx="ekr.20170101083205.40">if cc and use_chapters:
    w.leo_chapter = cc.getSelectedChapter()
else:
    w.leo_chapter = None
w.leo_p = p.copy()
w.leo_v = w.leo_p.v
w.leo_label_s = p.h
# g.trace('   ===', id(w),w.leo_chapter and w.leo_chapter.name,p.h)
</t>
<t tx="ekr.20170101083205.400">def edit_widget(self, p):
    d = self.editWidgetsDict
</t>
<t tx="ekr.20170101083205.401">if not p.v:
    return None
w = d.get(p.v)
</t>
<t tx="ekr.20170101083205.402">if not w:
    d[p.v] = w = StringTextWrapper(
        c=self.c,
        name='head-%d' % (1 + len(list(d.keys()))))
    w.setAllText(p.h)
return w
</t>
<t tx="ekr.20170101083205.403">def editLabel(self, p, selectAll=False, selection=None):
    '''Start editing p's headline.'''
    self.endEditLabel()
    self.setEditPosition(p)
        # That is, self._editPosition = p
</t>
<t tx="ekr.20170101083205.404">if p:
    self.revertHeadline = p.h
        # New in 4.4b2: helps undo.
    wrapper = StringTextWrapper(c=self.c, name='head-wrapper')
    e = None
    return e, wrapper
else:
    return None, None
</t>
<t tx="ekr.20170101083205.405">def setHeadline(self, p, s):
    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''
    # g.trace('p',p.h,'s',repr(s),g.callers())
    w = self.edit_widget(p)
</t>
<t tx="ekr.20170101083205.406">if w:
    w.delete(0, 'end')
    if s.endswith('\n') or s.endswith('\r'):
        s = s[: -1]
    w.insert(0, s)
    self.revertHeadline = s
    # g.trace(repr(s),w.getAllText())
else:
    g.trace('-' * 20, 'oops')
</t>
<t tx="ekr.20170101083205.407">class StringTextWrapper(object):
    '''A class that represents text as a Python string.'''
    @others
</t>
<t tx="ekr.20170101083205.408">def __init__(self, c, name):
    '''Ctor for the StringTextWrapper class.'''
    self.c = c
    self.name = name
    self.ins = 0
    self.sel = 0, 0
    self.s = ''
    self.supportsHighLevelInterface = True
    self.widget = None # This ivar must exist, and be None.
    self.trace = False

</t>
<t tx="ekr.20170101083205.409">def __repr__(self):
    return '&lt;StringTextWrapper: %s&gt;' % self.name

</t>
<t tx="ekr.20170101083205.41">def getInsertLines(self):
    '''
    Return before,after where:

    before is all the lines before the line containing the insert point.
    sel is the line containing the insert point.
    after is all the lines after the line containing the insert point.

    All lines end in a newline, except possibly the last line.
    '''
    body = self
    w = body.wrapper
    s = w.getAllText()
    insert = w.getInsertPoint()
    i, j = g.getLine(s, insert)
    before = s[0: i]
    ins = s[i: j]
    after = s[j:]
    before = g.toUnicode(before)
    ins = g.toUnicode(ins)
    after = g.toUnicode(after)
    return before, ins, after
</t>
<t tx="ekr.20170101083205.410">def getName(self):
    '''StringTextWrapper.'''
    return self.name # Essential.
</t>
<t tx="ekr.20170101083205.411">def clipboard_clear(self):
    g.app.gui.replaceClipboardWith('')

</t>
<t tx="ekr.20170101083205.412">def clipboard_append(self, s):
    s1 = g.app.gui.getTextFromClipboard()
    g.app.gui.replaceClipboardWith(s1 + s)
# For StringTextWrapper.

</t>
<t tx="ekr.20170101083205.413">def flashCharacter(self, i, bg='white', fg='red', flashes=3, delay=75): pass

</t>
<t tx="ekr.20170101083205.414">def getXScrollPosition(self): return 0

</t>
<t tx="ekr.20170101083205.415">def getYScrollPosition(self): return 0

</t>
<t tx="ekr.20170101083205.416">def see(self, i): pass

</t>
<t tx="ekr.20170101083205.417">def seeInsertPoint(self): pass

</t>
<t tx="ekr.20170101083205.418">def setFocus(self): pass

</t>
<t tx="ekr.20170101083205.419">def setXScrollPosition(self, i): pass

</t>
<t tx="ekr.20170101083205.42">def getSelectionAreas(self):
    '''
    Return before,sel,after where:

    before is the text before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is the text after the selected text
    (or the text after the insert point if no selection)
    '''
    body = self
    w = body.wrapper
    s = w.getAllText()
    i, j = w.getSelectionRange()
    if i == j: j = i + 1
    before = s[0: i]
    sel = s[i: j]
    after = s[j:]
    before = g.toUnicode(before)
    sel = g.toUnicode(sel)
    after = g.toUnicode(after)
    return before, sel, after
</t>
<t tx="ekr.20170101083205.420">def setYScrollPosition(self, i): pass

</t>
<t tx="ekr.20170101083205.421">def tag_configure(self, colorName, **keys): pass
</t>
<t tx="ekr.20170101083205.422">def appendText(self, s):
    '''StringTextWrapper.'''
    self.s = self.s + s
    self.ins = len(self.s)
    self.sel = self.ins, self.ins
</t>
<t tx="ekr.20170101083205.423">def delete(self, i, j=None):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    # This allows subclasses to use this base class method.
    if i &gt; j: i, j = j, i
    s = self.getAllText()
    self.setAllText(s[: i] + s[j:])
    # Bug fix: 2011/11/13: Significant in external tests.
    self.setSelectionRange(i, i, insert=i)
</t>
<t tx="ekr.20170101083205.424">def deleteTextSelection(self):
    '''StringTextWrapper.'''
    i, j = self.getSelectionRange()
    self.delete(i, j)
</t>
<t tx="ekr.20170101083205.425">def get(self, i, j=None):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    s = self.s[i: j]
    return g.toUnicode(s)
</t>
<t tx="ekr.20170101083205.426">def getAllText(self):
    '''StringTextWrapper.'''
    s = self.s
    return g.toUnicode(s)
</t>
<t tx="ekr.20170101083205.427">def getInsertPoint(self):
    '''StringTextWrapper.'''
    i = self.ins
</t>
<t tx="ekr.20170101083205.428">if i is None:
    if self.virtualInsertPoint is None:
        i = 0
    else:
        i = self.virtualInsertPoint
self.virtualInsertPoint = i
# g.trace('BaseTextWrapper): i:',i,'virtual',self.virtualInsertPoint)
return i
</t>
<t tx="ekr.20170101083205.429">def getSelectedText(self):
    '''StringTextWrapper.'''
    i, j = self.sel
    s = self.s[i: j]
    return g.toUnicode(s)
</t>
<t tx="ekr.20170101083205.43">def getSelectionLines(self):
    '''
    Return before,sel,after where:

    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)
    '''
</t>
<t tx="ekr.20170101083205.430">def getSelectionRange(self, sort=True):
    '''Return the selected range of the widget.'''
    sel = self.sel
</t>
<t tx="ekr.20170101083205.431">if len(sel) == 2 and sel[0] &gt;= 0 and sel[1] &gt;= 0:
    i, j = sel
    if sort and i &gt; j: sel = j, i # Bug fix: 10/5/07
    return sel
else:
    i = self.ins
    return i, i
</t>
<t tx="ekr.20170101083205.432">def hasSelection(self):
    '''StringTextWrapper.'''
    i, j = self.getSelectionRange()
    return i != j
</t>
<t tx="ekr.20170101083205.433">def insert(self, i, s):
    '''StringTextWrapper.'''
    i = self.toPythonIndex(i)
    s1 = s
    self.s = self.s[: i] + s1 + self.s[i:]
    i += len(s1)
    self.ins = i
    self.sel = i, i
</t>
<t tx="ekr.20170101083205.434">def selectAllText(self, insert=None):
    '''StringTextWrapper.'''
    self.setSelectionRange(0, 'end', insert=insert)
</t>
<t tx="ekr.20170101083205.435">def setAllText(self, s, h=None):
    '''StringTextWrapper.'''
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i, i
</t>
<t tx="ekr.20170101083205.436">def setInsertPoint(self, pos, s=None):
    '''StringTextWrapper.'''
    self.virtualInsertPoint = i = self.toPythonIndex(pos)
    self.ins = i
    self.sel = i, i
</t>
<t tx="ekr.20170101083205.437">def setSelectionRange(self, i, j, insert=None):
    '''StringTextWrapper.'''
    i, j = self.toPythonIndex(i), self.toPythonIndex(j)
    self.sel = i, j
    self.ins = j if insert is None else self.toPythonIndex(insert)
    if self.trace: g.trace('i', i, 'j', j, 'insert', repr(insert))
</t>
<t tx="ekr.20170101083205.438">def toPythonIndex(self, index):
    '''StringTextWrapper.'''
    return g.toPythonIndex(self.s, index)
</t>
<t tx="ekr.20170101083205.439">def toPythonIndexRowCol(self, index):
    '''StringTextWrapper.'''
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row, col = g.convertPythonIndexToRowCol(s, i)
    return i, row, col
</t>
<t tx="ekr.20170101083205.44">if g.app.batchMode:
    return '', '', ''
# At present, called only by c.getBodyLines.
body = self
w = body.wrapper
s = w.getAllText()
i, j = w.getSelectionRange()
</t>
<t tx="ekr.20170101083205.45">if i == j:
    i, j = g.getLine(s, i)
else:
    i, junk = g.getLine(s, i)
    junk, j = g.getLine(s, j)
before = g.toUnicode(s[0: i])
sel = g.toUnicode(s[i: j])
after = g.toUnicode(s[j: len(s)])
# g.trace(i,j,'sel',repr(s[i:j]),'after',repr(after))
return before, sel, after # 3 strings.
\\-8.# This is the only key handler for the body pane.

</t>
<t tx="ekr.20170101083205.46">def onBodyChanged(self, undoType, oldSel=None, oldText=None, oldYview=None):
    '''Update Leo after the body has been changed.'''
    trace = False and not g.unitTesting
    c = self.c
    body, w = self, self.wrapper
    p = c.p
    insert = w.getInsertPoint()
    ch = '' if insert == 0 else w.get(insert - 1)
    ch = g.toUnicode(ch)
    newText = w.getAllText() # Note: getAllText converts to unicode.
    newSel = w.getSelectionRange()
</t>
<t tx="ekr.20170101083205.47">if not oldText:
    oldText = p.b; changed = True
else:
    changed = oldText != newText
if not changed: return
</t>
<t tx="ekr.20170101083205.48">if trace:
    # g.trace(repr(ch),'changed:',changed,'newText:',len(newText),'w',w)
    g.trace('oldSel', oldSel, 'newSel', newSel)
c.undoer.setUndoTypingParams(p, undoType,
    oldText=oldText, newText=newText, oldSel=oldSel, newSel=newSel, oldYview=oldYview)
p.v.setBodyString(newText)
p.v.insertSpot = w.getInsertPoint()
c.frame.scanForTabWidth(p)
body.recolor(p, incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
</t>
<t tx="ekr.20170101083205.49">if g.app.unitTesting:
    g.app.unitTestDict['colorized'] = True
if not c.changed: c.setChanged(True)
self.updateEditors()
p.v.contentModified()
redraw_flag = False
# Update dirty bits.
# p.setDirty() sets all cloned and @file dirty bits.
</t>
<t tx="ekr.20170101083205.5">def addEditor(self, event=None):
    '''Add another editor to the body pane.'''
    c, p = self.c, self.c.p
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1
</t>
<t tx="ekr.20170101083205.50">if not p.isDirty() and p.setDirty():
    redraw_flag = True
# Update icons. p.v.iconVal may not exist during unit tests.
val = p.computeIcon()
</t>
<t tx="ekr.20170101083205.51">if not hasattr(p.v, "iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True
</t>
<t tx="ekr.20170101083205.52">if redraw_flag:
    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20170101083205.53">def setSelectionAreas(self, before, sel, after):
    '''
    Replace the body text by before + sel + after and
    set the selection so that the sel text is selected.
    '''
    body = self
    w = body.wrapper
    # 2012/02/05: save/restore Yscroll position.
    pos = w.getYScrollPosition()
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0, len(s))
    w.insert(0, before + sel + after)
    i = len(before)
    j = max(i, len(before) + len(sel) - 1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(pos)
    return i, j
</t>
<t tx="ekr.20170101083205.54">class LeoFrame(object):
    '''The base class for all Leo windows.'''
    instances = 0
    @others
</t>
<t tx="ekr.20170101083205.55">def __init__(self, c, gui):
    self.c = c
    self.gui = gui
    self.iconBarClass = NullIconBarClass
    self.statusLineClass = NullStatusLineClass
    self.title = None # Must be created by subclasses.
    # Objects attached to this frame.
    self.body = None
    self.colorPanel = None
    self.comparePanel = None
    self.findPanel = None
    self.fontPanel = None
    self.iconBar = None
    self.isNullFrame = False
    self.keys = None
    self.log = None
    self.menu = None
    self.miniBufferWidget = None
    self.outerFrame = None
    self.prefsPanel = None
    self.statusLine = None
    self.tree = None
    self.useMiniBufferWidget = False
    # Gui-independent data
    self.componentsDict = {} # Keys are names, values are componentClass instances.
    self.es_newlines = 0 # newline count for this log stream
    self.openDirectory = ""
    self.saved = False # True if ever saved
    self.splitVerticalFlag = True
        # Set by initialRatios later.
    self.startupWindow = False # True if initially opened window
    self.stylesheet = None # The contents of &lt;?xml-stylesheet...?&gt; line.
    self.tab_width = 0 # The tab width in effect in this pane.
    self.cursorStay = c.config.getBool("cursor_stay_on_paste", default = True)
</t>
<t tx="ekr.20170101083205.56">def createFirstTreeNode(self):
    f = self; c = f.c
    v = leoNodes.VNode(context=c)
    p = leoNodes.Position(v)
    v.initHeadString("NewHeadline")
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot(oldRoot=None)
    # c.setRootPosition() # New in 4.4.2.
</t>
<t tx="ekr.20170101083205.57">def cmd(name):
    '''Command decorator for the LeoFrame class.'''
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame',])
</t>
<t tx="ekr.20170101083205.58">def initialRatios(self):
    c = self.c
    s = c.config.get("initial_split_orientation", "string")
    verticalFlag = s is None or (s != "h" and s != "horizontal")
</t>
<t tx="ekr.20170101083205.59">if verticalFlag:
    r = c.config.getRatio("initial_vertical_ratio")
    if r is None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
    r2 = c.config.getRatio("initial_vertical_secondary_ratio")
    if r2 is None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
else:
    r = c.config.getRatio("initial_horizontal_ratio")
    if r is None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
    r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
    if r2 is None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
# g.trace(r,r2)
return verticalFlag, r, r2
</t>
<t tx="ekr.20170101083205.6">if self.numberOfEditors == 2:
    # Inject the ivars into the first editor.
    # Bug fix: Leo 4.4.8 rc1: The name of the last editor need not be '1'
    d = self.editorWidgets
    keys = list(d.keys())
    if len(keys) == 1:
        w_old = d.get(keys[0])
        self.updateInjectedIvars(w_old, p)
        self.selectLabel(w_old) # Immediately create the label in the old editor.
    else:
        g.trace('can not happen: unexpected editorWidgets', d)
name = '%d' % self.totalNumberOfEditors
pane = self.pb.add(name)
panes = self.pb.panes()
minSize = float(1.0 / float(len(panes)))
# Create the text wrapper.
f = self.createEditorFrame(pane)
wrapper = self.createTextWidget(f, name=name, p=p)
wrapper.delete(0, 'end')
wrapper.insert('end', p.b)
wrapper.see(0)
c.k.completeAllBindingsForWidget(wrapper)
self.recolorWidget(p, wrapper)
self.editorWidgets[name] = wrapper
for pane in panes:
    self.pb.configurepane(pane, size=minSize)
self.pb.updatelayout()
c.frame.body.wrapper = wrapper
# Finish...
self.updateInjectedIvars(wrapper, p)
self.selectLabel(wrapper)
self.selectEditor(wrapper)
self.updateEditors()
c.bodyWantsFocus()
</t>
<t tx="ekr.20170101083205.60">def longFileName(self):
    return self.c.mFileName

</t>
<t tx="ekr.20170101083205.61">def shortFileName(self):
    return g.shortFileName(self.c.mFileName)
</t>
<t tx="ekr.20170101083205.62">def oops(self):
    g.pr("LeoFrame oops:", g.callers(4), "should be overridden in subclass")
</t>
<t tx="ekr.20170101083205.63">def promptForSave(self):
    '''
    Prompt the user to save changes.
    Return True if the user vetos the quit or save operation.
    '''
    c = self.c
    theType = "quitting?" if g.app.quitting else "closing?"
    # See if we are in quick edit/save mode.
    root = c.rootPosition()
    quick_save = not c.mFileName and not root.next() and root.isAtEditNode()
</t>
<t tx="ekr.20170101083205.64">if quick_save:
    name = g.shortFileName(root.atEditNodeName())
else:
    name = c.mFileName if c.mFileName else self.title
answer = g.app.gui.runAskYesNoCancelDialog(c,
    "Confirm",
    'Save changes to %s before %s' % (g.splitLongFileName(name), theType))
# g.pr(answer)
</t>
<t tx="ekr.20170101083205.65">if answer == "cancel":
    return True # Veto.
elif answer == "no":
    return False # Don't save and don't veto.
else:
</t>
<t tx="ekr.20170101083205.66">if not c.mFileName:
    root = c.rootPosition()
    if not root.next() and root.isAtEditNode():
        # There is only a single @edit node in the outline.
        # A hack to allow "quick edit" of non-Leo files.
        # See https://bugs.launchpad.net/leo-editor/+bug/381527
        # Write the @edit node if needed.
        if root.isDirty():
            c.atFileCommands.writeOneAtEditNode(root,
                toString=False, force=True)
        return False # Don't save and don't veto.
    else:
        c.mFileName = g.app.gui.runSaveFileDialog(c,
            initialfile='',
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()
</t>
<t tx="ekr.20170101083205.67">if c.mFileName:
    ok = c.fileCommands.save(c.mFileName)
    return not ok # New in 4.2: Veto if the save did not succeed.
else:
    return True # Veto.
</t>
<t tx="ekr.20170101083205.68">def scanForTabWidth(self, p):
    '''Return the tab width in effect at p.'''
    c = self.c
    tab_width = c.getTabWidth(p)
    c.frame.setTabWidth(tab_width)
</t>
<t tx="ekr.20170101083205.69">def addIconButton(self, *args, **keys):
    if self.iconBar: return self.iconBar.add(*args, **keys)
    else: return None

</t>
<t tx="ekr.20170101083205.7">def assignPositionToEditor(self, p):
    '''Called *only* from tree.select to select the present body editor.'''
    c = self.c
    w = c.frame.body.widget
    self.updateInjectedIvars(w, p)
    self.selectLabel(w)
    # g.trace('===',id(w),w.leo_chapter.name,w.leo_p.h)
</t>
<t tx="ekr.20170101083205.70">def addIconRow(self):
    if self.iconBar: return self.iconBar.addRow()

</t>
<t tx="ekr.20170101083205.71">def addIconWidget(self, w):
    if self.iconBar: return self.iconBar.addWidget(w)

</t>
<t tx="ekr.20170101083205.72">def clearIconBar(self):
    if self.iconBar: self.iconBar.clear()

</t>
<t tx="ekr.20170101083205.73">def createIconBar(self):
</t>
<t tx="ekr.20170101083205.74">if not self.iconBar:
    self.iconBar = self.iconBarClass(self.c, self.outerFrame)
return self.iconBar

</t>
<t tx="ekr.20170101083205.75">def getIconBar(self):
</t>
<t tx="ekr.20170101083205.76">if not self.iconBar:
    self.iconBar = self.iconBarClass(self.c, self.outerFrame)
return self.iconBar

\\-8.getIconBarObject = getIconBar

</t>
<t tx="ekr.20170101083205.77">def getNewIconFrame(self):
</t>
<t tx="ekr.20170101083205.78">if not self.iconBar:
    self.iconBar = self.iconBarClass(self.c, self.outerFrame)
return self.iconBar.getNewFrame()

</t>
<t tx="ekr.20170101083205.79">def hideIconBar(self):
    if self.iconBar: self.iconBar.hide()

</t>
<t tx="ekr.20170101083205.8">@cmd('editor-cycle-focus')
@cmd('cycle-editor-focus') # There is no LeoQtBody method
def cycleEditorFocus(self, event=None):
    '''Cycle keyboard focus between the body text editors.'''
    c = self.c
    d = self.editorWidgets
    w = c.frame.body.wrapper
    values = list(d.values())
</t>
<t tx="ekr.20170101083205.80">def showIconBar(self):
    if self.iconBar: self.iconBar.show()
</t>
<t tx="ekr.20170101083205.81">def createStatusLine(self):
</t>
<t tx="ekr.20170101083205.82">if not self.statusLine:
    self.statusLine = self.statusLineClass(self.c, self.outerFrame)
return self.statusLine

</t>
<t tx="ekr.20170101083205.83">def clearStatusLine(self):
    if self.statusLine: self.statusLine.clear()

</t>
<t tx="ekr.20170101083205.84">def disableStatusLine(self, background=None):
    if self.statusLine: self.statusLine.disable(background)

</t>
<t tx="ekr.20170101083205.85">def enableStatusLine(self, background="white"):
    if self.statusLine: self.statusLine.enable(background)

</t>
<t tx="ekr.20170101083205.86">def getStatusLine(self):
    return self.statusLine

getStatusObject = getStatusLine

</t>
<t tx="ekr.20170101083205.87">def putStatusLine(self, s, bg=None, fg=None):
    if self.statusLine: self.statusLine.put(s, bg, fg)

</t>
<t tx="ekr.20170101083205.88">def setFocusStatusLine(self):
    if self.statusLine: self.statusLine.setFocus()

</t>
<t tx="ekr.20170101083205.89">def statusLineIsEnabled(self):
    if self.statusLine: return self.statusLine.isEnabled()
    else: return False

</t>
<t tx="ekr.20170101083205.9">if len(values) &gt; 1:
    i = values.index(w) + 1
    if i == len(values): i = 0
    w2 = list(d.values())[i]
    assert(w != w2)
    self.selectEditor(w2)
    c.frame.body.wrapper = w2
</t>
<t tx="ekr.20170101083205.90">def updateStatusLine(self):
    if self.statusLine: self.statusLine.update()
</t>
<t tx="ekr.20170101083205.91">@cmd('copy-text')
def copyText(self, event=None):
    '''Copy the selected text from the widget to the clipboard.'''
    trace = False and not g.unitTesting
    f = self; c = f.c
    w = event and event.widget
    wname = (w and c.widget_name(w)) or '&lt;no widget&gt;'
    if trace: g.trace(g.isTextWrapper(w), wname, w)
</t>
<t tx="ekr.20170101083205.92">if not w or not g.isTextWrapper(w):
    return
# Set the clipboard text.
i, j = w.getSelectionRange()
</t>
<t tx="ekr.20170101083205.93">if i == j:
    ins = w.getInsertPoint()
    i, j = g.getLine(w.getAllText(), ins)
# 2016/03/27: Fix a recent buglet.
# Don't clear the clipboard if we hit ctrl-c by mistake.
s = w.get(i,j)
</t>
<t tx="ekr.20170101083205.94">if s:
    g.app.gui.replaceClipboardWith(s)

\\-8.OnCopyFromMenu = copyText
\\-8.@cmd('cut-text')
</t>
<t tx="ekr.20170101083205.95">def cutText(self, event=None):
    '''Invoked from the mini-buffer and from shortcuts.'''
    trace = False and not g.unitTesting
    f = self; c = f.c; w = event and event.widget
</t>
<t tx="ekr.20170101083205.96">if not w or not g.isTextWrapper(w):
    if trace: g.trace('not wrapper', w, g.callers())
    return
name = c.widget_name(w)
oldSel = w.getSelectionRange()
oldText = w.getAllText()
i, j = w.getSelectionRange()
# Update the widget and set the clipboard text.
s = w.get(i, j)
</t>
<t tx="ekr.20170101083205.97">if i != j:
    w.delete(i, j)
    w.see(i) # 2016/01/19: important
    g.app.gui.replaceClipboardWith(s)
else:
    ins = w.getInsertPoint()
    i, j = g.getLine(oldText, ins)
    s = w.get(i,j)
    w.delete(i,j)
    w.see(i) # 2016/01/19: important
    g.app.gui.replaceClipboardWith(s)
</t>
<t tx="ekr.20170101083205.98">if name.startswith('body'):
    c.frame.body.forceFullRecolor()
    c.frame.body.onBodyChanged('Cut', oldSel=oldSel, oldText=oldText)
elif name.startswith('head'):
    # The headline is not officially changed yet.
    # p.initHeadString(s)
    s = w.getAllText()
    # 2011/11/14: Not used at present.
    # width = f.tree.headWidth(p=None,s=s)
    # w.setWidth(width)
else: pass

\\-8.OnCutFromMenu = cutText
\\-8.@cmd('paste-text')
</t>
<t tx="ekr.20170101083205.99">def pasteText(self, event=None, middleButton=False):
    '''
    Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.
    '''
    trace = False and not g.unitTesting
    f = self; c = f.c
    w = event and event.widget
    wname = (w and c.widget_name(w)) or '&lt;no widget&gt;'
</t>
<t tx="ekr.20170101085120.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170101085120.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
</tnodes>
</leo_file>
