<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070417092935"><vh>Startup</vh>
<v t="ekr.20041001211817"><vh>Buttons</vh>
<v t="ekr.20070926090757"><vh>Disabled buttons</vh>
<v t="ekr.20051025070722"><vh>@@button Beautify</vh></v>
<v t="ekr.20070626153940"><vh>@@button dynamic-tests @key=Alt-5</vh>
<v t="ekr.20070626153940.1"><vh>searchOutline</vh></v>
<v t="ekr.20070626153940.2"><vh>createOutline</vh></v>
<v t="ekr.20070626153940.3"><vh>createFileFromOutline</vh></v>
<v t="ekr.20070626153940.4"><vh>runDynamicTests</vh></v>
</v>
<v t="ekr.20070201065053"><vh>@@button goto tk index</vh></v>
<v t="ekr.20070807104632"><vh>@@button local-tests @key=Alt+6</vh></v>
<v t="ekr.20100131171342.5459"><vh>@@button run-all-core-tests @key = Alt-7</vh></v>
<v t="ekr.20080405082101.1"><vh>@@button run-all-tests</vh></v>
<v t="ekr.20050911112310"><vh>@@button Save</vh></v>
<v t="ekr.20051025091355"><vh>@@button Spell</vh></v>
<v t="ekr.20051104081502.554"><vh>@@button test @key=alt-shift-ctrl-y</vh></v>
</v>
<v t="ekr.20080529114722.1"><vh>@button timeit</vh></v>
<v t="ekr.20080529115911.1"><vh>@button profile</vh></v>
</v>
<v t="ekr.20080312090030.1"><vh>Commands</vh>
<v t="ekr.20051104081502.552"><vh>@@command my-command @key = alt-shift-ctrl-z</vh></v>
<v t="ekr.20051107115231.1"><vh>@@command unit-test-command1</vh></v>
<v t="ekr.20051104081502.553"><vh>@@command my-command2</vh></v>
<v t="ekr.20051104081502.555"><vh>@@command rebind ctrl-e @key=shift-alt-e</vh></v>
<v t="ekr.20041001194357"><vh>@@command Unit Test @key=Alt+4</vh></v>
</v>
<v t="ekr.20041121151002"><vh>@settings</vh>
<v t="ekr.20070303143846.1"><vh>@@enabled-plugins</vh></v>
<v t="ekr.20080324133327.2"><vh>@bool allow_middle_button_paste = True</vh></v>
<v t="ekr.20090629104856.4992"><vh>@@bool big_outline_pane = True</vh></v>
<v t="ekr.20051013162226"><vh>@bool test_setting = True</vh></v>
<v t="ekr.20070503064257"><vh>@bool use_chapters = True</vh></v>
<v t="ekr.20070528100318"><vh>@bool write_strips_blank_lines = False</vh></v>
<v t="ekr.20050328101834"><vh>@page http plugin</vh>
<v t="ekr.20050328101834.1"><vh>@bool http_active = False</vh></v>
<v t="ekr.20050328101834.2"><vh>@int  port = 8080</vh></v>
<v t="ekr.20050328101834.3"><vh>@string rst_http_attributename = ''</vh></v>
</v>
<v t="ekr.20100507152400.5388"><vh>@@string qt-toolbar-location=left</vh></v>
<v t="ekr.20070303143951"><vh>unused</vh>
<v t="ekr.20051018071924"><vh>@@color log_pane_Completion_tab_background_color = yellow</vh></v>
<v t="ekr.20060325072919"><vh>@@ifgui tkinter</vh>
<v t="ekr.20060325072919.1"><vh>@bool test_tkinter_setting = True</vh></v>
</v>
<v t="ekr.20060325072919.2"><vh>@@ifgui wxWindows</vh>
<v t="ekr.20060325072919.3"><vh>@bool test_wxWindows_setting = True</vh></v>
</v>
<v t="ekr.20050104095950"><vh>@@shortcutsEqualSizedPanes</vh></v>
</v>
</v>
<v t="ekr.20070515150433"><vh>@chapters</vh>
<v t="ekr.20070611081718"><vh>@chapter unitTestChapter</vh>
<v t="ekr.20070611081718.1"><vh>unitTestChapter node 1</vh></v>
<v t="ekr.20070611081718.2"><vh>firstChild</vh></v>
<v t="ekr.20070611081718.4"><vh>firstChild</vh></v>
</v>
</v>
<v t="ekr.20100123172713.5114"><vh>Scripts</vh>
<v t="ekr.20100102164959.5088"><vh>Count pages</vh></v>
<v t="ekr.20100123172713.5116"><vh>Clean all tnodeLists</vh></v>
</v>
</v>
<v t="ekr.20070303143846.1"></v>
<v t="ekr.20051012104957"><vh>Docs</vh>
<v t="bwmulder.20050108100437.1"><vh>How to run unit tests</vh></v>
<v t="ekr.20050618061835"><vh>How to use the @test directive, by Roger Erens</vh>
<v t="ekr.20050618061835.1"><vh>Intro</vh>
<v t="ekr.20050618061835.2"><vh>@url http://www.onlamp.com/pub/a/python/2005/02/03/tdd_pyunit2.html</vh></v>
</v>
<v t="ekr.20050618061835.3"><vh>Preparations: adding a button</vh>
<v t="ekr.20050618061835.4"><vh>@@button Do @test</vh></v>
</v>
<v t="ekr.20050618061835.5"><vh>Alpha</vh>
<v t="ekr.20050618061835.6"><vh>@test my first Leo test</vh></v>
<v t="ekr.20050618061835.7"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.8"><vh>Bravo</vh>
<v t="ekr.20050618061835.9"><vh>@@test my second Leo test</vh></v>
<v t="ekr.20050618061835.10"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.11"><vh>It takes two to tango</vh>
<v t="ekr.20050618061835.6"></v>
<v t="ekr.20050618061835.9"></v>
<v t="ekr.20050618061835.12"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.13"><vh>Life gets more interesting</vh>
<v t="ekr.20050618061835.14"><vh>@@test koekiemonster.wants()</vh>
<v t="ekr.20050618061835.15"><vh>input data</vh></v>
<v t="ekr.20050618061835.16"><vh>expected result</vh></v>
</v>
<v t="ekr.20050618061835.17"><vh>output on the console</vh></v>
<v t="ekr.20050618061835.18"><vh>output on the console using print statements</vh></v>
</v>
<v t="ekr.20050618061835.19"><vh>How about @suite?</vh></v>
<v t="ekr.20050618061835.20"><vh>Final remarks</vh></v>
</v>
<v t="ekr.20051104080236"><vh>Other</vh>
<v t="ekr.20080405085247.1"><vh>@ignore</vh>
<v t="ekr.20051104081502"><vh>Other tests</vh>
<v t="ekr.20051104081502.542"><vh>@@nosent test-niceNosent</vh>
<v t="ekr.20051104081502.543"><vh>part 1</vh></v>
<v t="ekr.20051104081502.544"><vh>part 2</vh></v>
<v t="ekr.20051104081502.545"><vh>part 3</vh></v>
</v>
<v t="ekr.20051104081502.320"><vh>@nowrap tests</vh></v>
<v t="ekr.20051104081502.306"><vh>@url '..\doc\LeoDocs.leo#Users Guide--&gt;Chapter 8: Customizing Leo'</vh></v>
<v t="ekr.20051104081502.319"><vh>@url 'c:\Program Files\jEdit\doc\README.txt'</vh></v>
<v t="ekr.20051104081502.2"><vh>Clone test</vh>
<v t="ekr.20051104081502.3"><vh>clone test</vh>
<v t="ekr.20051104081502.4"><vh>b</vh>
<v t="ekr.20051104081502.5"><vh>c</vh>
<v t="ekr.20051104081502.6"><vh>firstChild</vh></v>
<v t="ekr.20051104081502.7"><vh>secondChild</vh></v>
</v>
<v t="ekr.20051104081502.8"><vh>sibling</vh></v>
</v>
<v t="ekr.20051104081502.9"><vh>a</vh></v>
</v>
<v t="ekr.20051104081502.10"><vh>d</vh>
<v t="ekr.20051104081502.5"></v>
<v t="ekr.20051104081502.11"><vh>sibling 2</vh></v>
</v>
<v t="ekr.20051104081502.6"></v>
<v t="ekr.20051104081502.12"><vh>last</vh></v>
</v>
<v t="ekr.20051104081502.13"><vh>Cloning headlines</vh>
<v t="ekr.20051104081502.14"><vh>read me</vh>
<v t="ekr.20051104081502.15"><vh>b</vh>
<v t="ekr.20051104081502.16"><vh>c</vh>
<v t="ekr.20051104081502.17"><vh>d</vh></v>
<v t="ekr.20051104081502.18"><vh>e</vh></v>
</v>
<v t="ekr.20051104081502.16"></v>
</v>
<v t="ekr.20051104081502.19"><vh>g</vh></v>
</v>
<v t="ekr.20051104081502.20"><vh>a</vh>
<v t="ekr.20051104081502.15"></v>
<v t="ekr.20051104081502.15"></v>
<v t="ekr.20051104081502.19"></v>
</v>
<v t="ekr.20051104081502.20"></v>
<v t="ekr.20051104081502.21"><vh>f</vh></v>
</v>
<v t="ekr.20051104081502.308"><vh>Develop &amp; test g.removeExtraLws</vh>
<v t="ekr.20051104081502.309"><vh>g.removeExtraLws</vh></v>
<v t="ekr.20051104081502.310"><vh>test_g_removeExtraLws</vh></v>
</v>
<v t="ekr.20051104081502.22"><vh>Experiments</vh>
<v t="ekr.20051104081502.23"><vh>Test of moving positions</vh></v>
<v t="ekr.20051104081502.24"><vh>Test of using an iterator inside a list comprehension</vh></v>
<v t="ekr.20051104081502.25"><vh>Test of using c.allNodes_iter to create a list of all positions</vh></v>
<v t="ekr.20051104081502.26"><vh>Creating a list of distinct vnodes</vh></v>
<v t="ekr.20051104081502.28"><vh>test of list comparisons</vh></v>
<v t="ekr.20051104081502.29"><vh>test that childIndex doesn't mess with p</vh></v>
<v t="ekr.20051104081502.30"><vh>Test of __cmp__ vrs equal</vh></v>
<v t="ekr.20051104081502.31"><vh>Test print</vh></v>
<v t="ekr.20051104081502.32"><vh>String-based imports...</vh>
<v t="ekr.20051104081502.33"><vh>import from string</vh>
<v t="ekr.20051104081502.34"><vh>@@test import from string</vh></v>
</v>
<v t="ekr.20051104081502.35"><vh>Subclass the file type for use with imp module</vh></v>
<v t="ekr.20051104081502.36"><vh>Use parser module to simulate import from string</vh>
<v t="ekr.20051104081502.37"><vh>test1</vh></v>
</v>
</v>
</v>
<v t="ekr.20051104081502.556"><vh>Handling tabs, backspaces</vh></v>
<v t="ekr.20051104081502.317"><vh>linda's node</vh></v>
<v t="ekr.20051104081502.209"><vh>Make sure openWith changes are benign</vh></v>
<v t="ekr.20051104081502.99"><vh>Manual tests...</vh>
<v t="ekr.20051104081502.101"><vh>Other Reformat Paragraph tests</vh></v>
<v t="ekr.20051104081502.102"><vh>Test of @tabwidth</vh></v>
<v t="ekr.20051104081502.103"><vh>Test of pasting into big node</vh></v>
<v t="ekr.20051104081502.104"><vh>Test of Remove sentinels</vh></v>
<v t="ekr.20051104081502.105"><vh>Test new docutils stull</vh></v>
</v>
<v t="ekr.20051104081502.220"><vh>Mini test arguments to hooks</vh>
<v t="ekr.20051104081502.221"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20051104081502.222"><vh>&lt;&lt; define hookData &gt;&gt;</vh></v>
<v t="ekr.20051104081502.223"><vh>&lt;&lt; define typeData &gt;&gt;</vh></v>
<v t="ekr.20051104081502.224"><vh>&lt;&lt; defineCheckHook &gt;&gt;</vh></v>
<v t="ekr.20051104081502.225"><vh>checkOneHook</vh></v>
</v>
<v t="ekr.20051104081502.312"><vh>Mini test of g.es_exception</vh></v>
<v t="ekr.20051104081502.311"><vh>Mini test of g.pdb</vh></v>
<v t="ekr.20051104081502.106"><vh>Mini tests of script buttons</vh>
<v t="ekr.20051104081502.107"><vh>Redundant: @suite run all doctests in @file nodes</vh></v>
<v t="ekr.20051104081502.108"><vh>runProfile button mini-test </vh></v>
<v t="ekr.20051104081502.109"><vh>runTimeit mini-test </vh></v>
<v t="ekr.20051104081502.110"><vh>profile redraws</vh></v>
</v>
<v t="ekr.20051104081502.111"><vh>Perfect import stuff...</vh>
<v t="ekr.20051104081502.112"><vh>Mulder Update script</vh>
<v t="ekr.20051104081502.113"><vh>sync</vh>
<v t="ekr.20051104081502.114"><vh>&lt;&lt; compute sourcetime and targettime &gt;&gt;</vh></v>
<v t="ekr.20051104081502.115"><vh>&lt;&lt; compute operation &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.116"><vh>Perfect Import Script</vh></v>
</v>
<v t="ekr.20051104081502.117"><vh>Printing tests...</vh>
<v t="ekr.20051104081502.118"><vh>Print findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20051104081502.119"><vh>Print iterations: do not delete</vh>
<v t="ekr.20051104081502.120"><vh>b</vh>
<v t="ekr.20051104081502.121"><vh>c</vh>
<v t="ekr.20051104081502.122"><vh>c2</vh>
<v t="ekr.20051104081502.123"><vh>c3</vh></v>
<v t="ekr.20051104081502.124"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20051104081502.125"><vh>Clone test data</vh>
<v t="ekr.20051104081502.126"><vh>aa</vh></v>
<v t="ekr.20051104081502.127"><vh>a</vh>
<v t="ekr.20051104081502.120"></v>
</v>
<v t="ekr.20051104081502.128"><vh>d</vh>
<v t="ekr.20051104081502.127"></v>
</v>
<v t="ekr.20051104081502.129"><vh>e</vh></v>
<v t="ekr.20051104081502.130"><vh>z</vh></v>
</v>
<v t="ekr.20051104081502.131"><vh>last node</vh></v>
</v>
<v t="ekr.20051104081502.145"><vh>Print isAnyAtFileNode</vh></v>
<v t="ekr.20051104081502.146"><vh>Print fundChildrenOf and </vh></v>
<v t="ekr.20051104081502.147"><vh>Tests of pickle &amp; hexlify</vh></v>
<v t="ekr.20051104081502.148"><vh>Test of undo registration</vh></v>
<v t="ekr.20051104081502.149"><vh>Test of unknownAttributes</vh></v>
<v t="ekr.20051104081502.150"><vh>Test of "end1" hook</vh></v>
<v t="ekr.20051104081502.151"><vh>Print timestamps of all nodes</vh></v>
<v t="ekr.20051104081502.152"><vh>test of focus</vh></v>
<v t="ekr.20051104081502.153"><vh>Using a generator instead of readLinesClass</vh></v>
<v t="ekr.20051104081502.154"><vh>Test of better error messages in Execute Script command</vh>
<v t="ekr.20051104081502.155"><vh>Contains error</vh></v>
</v>
<v t="ekr.20051104081502.157"><vh>print all docstrings from a module</vh>
<v t="ekr.20051104081502.158"><vh>&lt;&lt; print names sorted by type &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.216"><vh>Registering &amp; unregistering the "new" drawing hooks</vh>
<v t="ekr.20051104081502.217"><vh>Register all new hooks</vh></v>
<v t="ekr.20051104081502.218"><vh>Unregister all new hooks</vh></v>
<v t="ekr.20051104081502.219"><vh>Print all new hooks</vh></v>
</v>
<v t="ekr.20051104081502.538"><vh>ReportLab sample scripts</vh>
<v t="ekr.20051104081502.539"><vh>text</vh></v>
<v t="ekr.20051104081502.540"><vh>pencil</vh></v>
<v t="ekr.20051104081502.541"><vh>penciltip</vh></v>
</v>
<v t="ekr.20051104081502.272"><vh>Standalone imports</vh>
<v t="ekr.20051104081502.273"><vh>test that of standalone imports of leo files</vh></v>
<v t="ekr.20051104081502.274"><vh>Script to run in Idle</vh></v>
</v>
<v t="ekr.20051104081502.307"><vh>test local settings (c.redirect_execute_script_output_to_log_pane)</vh></v>
<v t="ekr.20051104081502.164"><vh>test of 4.3 str_ attributes</vh>
<v t="ekr.20051104081502.165"><vh>set</vh></v>
<v t="ekr.20051104081502.166"><vh>get</vh></v>
</v>
<v t="ekr.20051104081502.316"><vh>test of an exception in another module</vh></v>
<v t="ekr.20051104081502.210"><vh>Test of autocompleter</vh></v>
<v t="ekr.20051104081502.322"><vh>Test of g.getScript with forcePythonSentinels = False</vh>
<v t="ekr.20051104081502.323"><vh>g.getScript</vh></v>
<v t="ekr.20051104081502.324"><vh>html stuff</vh>
<v t="ekr.20051104081502.325"><vh>body</vh></v>
</v>
</v>
<v t="ekr.20051104081502.315"><vh>test of NameError traceback</vh></v>
<v t="ekr.20051104081502.318"><vh>Test of os.spawnv calls to c.openWith</vh></v>
<v t="ekr.20051104081502.321"><vh>Test of redirected scipt with error</vh></v>
<v t="ekr.20051104081502.183"><vh>Test of reportBadChars</vh></v>
<v t="ekr.20051104081502.234"><vh>test of tab_width &amp; tab_width ivars</vh></v>
<v t="ekr.20051104081502.211"><vh>Test of template plugin</vh>
<v t="ekr.20051104081502.213"><vh>A node that uses the template</vh></v>
</v>
<v t="ekr.20051104081502.214"><vh>test of using changes to Go To Line number to handle scripts</vh>
<v t="ekr.20051104081502.215"><vh>node that throws exception</vh></v>
</v>
<v t="ekr.20051104081502.547"><vh>Test of warnings of conflicting shortcuts</vh></v>
<v t="ekr.20051104081502.551"><vh>test k.registerCommand</vh></v>
<v t="ekr.20051104081502.226"><vh>Tests of leoGlobals</vh>
<v t="ekr.20051104081502.227"><vh>@test g.rawPrint</vh></v>
<v t="ekr.20051104081502.232"><vh>test of g.pdb</vh></v>
<v t="ekr.20051104081502.233"><vh>Test of g.app.debugSwitch</vh></v>
</v>
<v t="ekr.20051104081502.326"><vh>Tests of rst3 plugin</vh>
<v t="ekr.20051104081502.327"><vh>@rst ../doc/ListManagerDocs.html</vh>
<v t="ekr.20051104081502.328"><vh>wxListManager.py</vh>
<v t="ekr.20051104081502.329"><vh>Initial stuff</vh>
<v t="ekr.20051104081502.330"><vh>Module Imports</vh>
<v t="ekr.20051104081502.331"><vh>@rst-no-head About imports</vh></v>
</v>
<v t="ekr.20051104081502.332"><vh>Constants</vh></v>
<v t="ekr.20051104081502.333"><vh>Menu IDs</vh></v>
<v t="ekr.20051104081502.334"><vh>Read Config File</vh>
<v t="ekr.20051104081502.335"><vh>@rst-no-head About configuration files</vh></v>
</v>
</v>
<v t="ekr.20051104081502.336"><vh>class ListManager</vh>
<v t="ekr.20051104081502.337"><vh>Instantiation</vh>
<v t="ekr.20051104081502.338"><vh>def __init__</vh>
<v t="ekr.20051104081502.339"><vh>@rst-no-head About the ctor</vh></v>
<v t="ekr.20051104081502.340"><vh>&lt;&lt; List Manager Attributes &gt;&gt;</vh>
<v t="ekr.20051104081502.341"><vh>@rst</vh></v>
</v>
<v t="ekr.20051104081502.342"><vh>&lt;&lt; Menu Setup &gt;&gt;</vh>
<v t="ekr.20051104081502.343"><vh>@rst</vh></v>
</v>
<v t="ekr.20051104081502.344"><vh>&lt;&lt; Toolbar Setup &gt;&gt;</vh></v>
<v t="ekr.20051104081502.346"><vh>&lt;&lt; Menu/Toolbar Events &gt;&gt;</vh></v>
<v t="ekr.20051104081502.348"><vh>&lt;&lt; Create Controls&gt;&gt;</vh></v>
<v t="ekr.20051104081502.350"><vh>&lt;&lt; Other Events &gt;&gt;</vh></v>
<v t="ekr.20051104081502.352"><vh>&lt;&lt; Layout Stuff &gt;&gt;</vh></v>
<v t="ekr.20051104081502.354"><vh>&lt;&lt; GUI Instance Objects &gt;&gt;</vh></v>
<v t="ekr.20051104081502.356"><vh>&lt;&lt; Create Socket &gt;&gt;</vh></v>
<v t="ekr.20051104081502.358"><vh>&lt;&lt; Load Recent Files &gt;&gt;</vh></v>
<v t="ekr.20051104081502.360"><vh>&lt;&lt; Idle Timer &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.362"><vh>Ownerlist creation methods (used by thread)</vh>
<v t="ekr.20051104081502.364"><vh>def createownerlist</vh></v>
<v t="ekr.20051104081502.366"><vh>def createownerdialog</vh></v>
</v>
<v t="ekr.20051104081502.368"><vh>Notebook methods</vh>
<v t="ekr.20051104081502.370"><vh>def CreateNewNotebookPage</vh>
<v t="ekr.20051104081502.372"><vh>&lt;&lt; Fill OwnerListBox &gt;&gt;</vh></v>
<v t="ekr.20051104081502.374"><vh>&lt;&lt; ListControl Events &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.376"><vh>def OnPageChange</vh>
<v t="ekr.20051104081502.378"><vh>&lt;&lt; Find Highlighted Row &gt;&gt;</vh></v>
<v t="ekr.20051104081502.380"><vh>&lt;&lt; Update Title &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.382"><vh>Tickler methods</vh>
<v t="ekr.20051104081502.383"><vh>def OnShowTickler</vh></v>
<v t="ekr.20051104081502.384"><vh>def OnActivateTickler</vh></v>
</v>
<v t="ekr.20051104081502.385"><vh>Email methods</vh>
<v t="ekr.20051104081502.386"><vh>OnMailItem</vh></v>
<v t="ekr.20051104081502.387"><vh>OnMailView</vh></v>
</v>
<v t="ekr.20051104081502.388"><vh>Cut/Copy/Paste methods</vh>
<v t="ekr.20051104081502.389"><vh>OnCopyItems</vh>
<v t="ekr.20051104081502.390"><vh>&lt;&lt; Find Highlighted Items &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.391"><vh>OnPasteItems</vh></v>
<v t="ekr.20051104081502.392"><vh>OnDeleteItems</vh></v>
</v>
<v t="ekr.20051104081502.393"><vh>MouseDown methods</vh>
<v t="ekr.20051104081502.394"><vh>OnLeftDown (Action depends on x coordinate)</vh></v>
<v t="ekr.20051104081502.395"><vh>OnRightDown (Display popup sendto menu)</vh></v>
</v>
<v t="ekr.20051104081502.396"><vh>Move/Combine items methods</vh>
<v t="ekr.20051104081502.397"><vh>OnCombineItems</vh></v>
<v t="ekr.20051104081502.398"><vh>OnMoveToList</vh></v>
<v t="ekr.20051104081502.399"><vh>OnMoveToSpecificList</vh></v>
</v>
<v t="ekr.20051104081502.400"><vh>Change/update items methods</vh>
<v t="ekr.20051104081502.401"><vh>OnToggleFinished</vh>
<v t="ekr.20051104081502.402"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.403"><vh>OnPriority</vh>
<v t="ekr.20051104081502.404"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.405"><vh>Inplace Edit Methods</vh>
<v t="ekr.20051104081502.406"><vh>OnDisplayInPlaceEditor</vh></v>
<v t="ekr.20051104081502.407"><vh>OnCloseInPlaceEditor</vh></v>
</v>
<v t="ekr.20051104081502.408"><vh>OnDueDate</vh></v>
<v t="ekr.20051104081502.409"><vh>OnEditOwner</vh>
<v t="ekr.20051104081502.410"><vh>&lt;&lt; Common Owner Code &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.411"><vh>OnUpdate</vh>
<v t="ekr.20051104081502.412"><vh>&lt;&lt; Common Owner Code &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.413"><vh>OnNewItem</vh>
<v t="ekr.20051104081502.414"><vh>&lt;&lt; Clear data fields &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.415"><vh>Conflict (not in use)</vh></v>
<v t="ekr.20051104081502.416"><vh>OnEditNote</vh></v>
</v>
<v t="ekr.20051104081502.417"><vh>File menu methods</vh>
<v t="ekr.20051104081502.418"><vh>OnNewList</vh></v>
<v t="ekr.20051104081502.419"><vh>OnFileList</vh></v>
<v t="ekr.20051104081502.420"><vh>OnOpenList</vh></v>
<v t="ekr.20051104081502.421"><vh>OnDeleteList</vh></v>
<v t="ekr.20051104081502.422"><vh>OnCloseList</vh></v>
<v t="ekr.20051104081502.423"><vh>OnCloseAll</vh></v>
<v t="ekr.20051104081502.424"><vh>OnSaveAsText</vh></v>
<v t="ekr.20051104081502.425"><vh>OnArchive</vh></v>
<v t="ekr.20051104081502.426"><vh>OnWorkOffline</vh></v>
</v>
<v t="ekr.20051104081502.428"><vh>Display methods</vh>
<v t="ekr.20051104081502.429"><vh>OnItemSelected</vh></v>
<v t="ekr.20051104081502.430"><vh>OnItemActivated</vh></v>
<v t="ekr.20051104081502.431"><vh>OnShowAll</vh></v>
<v t="ekr.20051104081502.432"><vh>OnRefresh</vh></v>
<v t="ekr.20051104081502.433"><vh>OnFilterOwners</vh></v>
<v t="ekr.20051104081502.434"><vh>OnColumnClick (to sort columns)</vh></v>
<v t="ekr.20051104081502.435"><vh>OnShowFinished</vh></v>
<v t="ekr.20051104081502.436"><vh>OnColumnRightClick (popup to change date displayed)</vh></v>
<v t="ekr.20051104081502.437"><vh>OnDisplayDateCategory</vh></v>
<v t="ekr.20051104081502.438"><vh>ChangeDateDisplayed</vh></v>
<v t="ekr.20051104081502.439"><vh>DisplayList</vh>
<v t="ekr.20051104081502.440"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.441"><vh>Printing methods</vh>
<v t="ekr.20051104081502.442"><vh>OnPageSetup</vh></v>
<v t="ekr.20051104081502.443"><vh>OnPrint</vh></v>
</v>
<v t="ekr.20051104081502.444"><vh>Exiting methods</vh>
<v t="ekr.20051104081502.445"><vh>OnWindowExit</vh></v>
<v t="ekr.20051104081502.446"><vh>OnExit</vh>
<v t="ekr.20051104081502.447"><vh>&lt;&lt;save configuration file&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.448"><vh>Find methods</vh>
<v t="ekr.20051104081502.449"><vh>OnFind</vh></v>
<v t="ekr.20051104081502.450"><vh>FindString</vh></v>
<v t="ekr.20051104081502.451"><vh>FindNode</vh></v>
</v>
<v t="ekr.20051104081502.452"><vh>Database-related methods</vh>
<v t="ekr.20051104081502.453"><vh>GetCursor</vh></v>
<v t="ekr.20051104081502.454"><vh>GetNote</vh></v>
<v t="ekr.20051104081502.455"><vh>CreateTable</vh></v>
<v t="ekr.20051104081502.456"><vh>ReadFromDB (returns db results)</vh></v>
<v t="ekr.20051104081502.457"><vh>CreateAndDisplayList (returns Item List)</vh>
<v t="ekr.20051104081502.458"><vh>&lt;&lt; assign item attributes &gt;&gt;</vh></v>
<v t="ekr.20051104081502.459"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.460"><vh>OnSync</vh></v>
<v t="ekr.20051104081502.461"><vh>TimeStamper</vh></v>
</v>
<v t="ekr.20051104081502.462"><vh>Evaluate methods</vh>
<v t="ekr.20051104081502.463"><vh>OnShowEvaluate</vh></v>
<v t="ekr.20051104081502.464"><vh>OnEvaluate</vh></v>
</v>
<v t="ekr.20051104081502.465"><vh>Help menu methods</vh>
<v t="ekr.20051104081502.466"><vh>OnShowAbout</vh></v>
<v t="ekr.20051104081502.467"><vh>OnShowHelp</vh></v>
</v>
<v t="ekr.20051104081502.468"><vh>GetUID</vh></v>
<v t="ekr.20051104081502.469"><vh>OnIdle</vh>
<v t="ekr.20051104081502.471"><vh>&lt;&lt; Check for Transfers From Outlook &gt;&gt;</vh></v>
<v t="ekr.20051104081502.473"><vh>&lt;&lt; Check if Edited File has Changed &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.475"><vh>class ListCtrl</vh>
<v t="ekr.20051104081502.476"><vh>__init__</vh></v>
<v t="ekr.20051104081502.477"><vh>SetUpColumns</vh></v>
<v t="ekr.20051104081502.478"><vh>OnColBeginDrag</vh></v>
</v>
<v t="ekr.20051104081502.479"><vh>class MyApp</vh>
<v t="ekr.20051104081502.480"><vh>OnInit</vh></v>
</v>
<v t="ekr.20051104081502.481"><vh>class Logger</vh></v>
<v t="ekr.20051104081502.482"><vh>run</vh></v>
</v>
<v t="ekr.20051104081502.483"><vh>LMDialogs.py</vh>
<v t="ekr.20051104081502.484"><vh>class PopDialog</vh>
<v t="ekr.20051104081502.485"><vh>__init__</vh></v>
<v t="ekr.20051104081502.486"><vh>OnLeftDown</vh></v>
<v t="ekr.20051104081502.487"><vh>OnForward</vh></v>
<v t="ekr.20051104081502.488"><vh>OnMail</vh></v>
</v>
<v t="ekr.20051104081502.489"><vh>class StartupDialog</vh>
<v t="ekr.20051104081502.490"><vh>__init__</vh></v>
<v t="ekr.20051104081502.491"><vh>OnSelection</vh></v>
</v>
<v t="ekr.20051104081502.492"><vh>class ModifierDialog</vh>
<v t="ekr.20051104081502.493"><vh>__init__</vh></v>
<v t="ekr.20051104081502.494"><vh>GetUserInput</vh></v>
<v t="ekr.20051104081502.495"><vh>SelectCurrent</vh></v>
<v t="ekr.20051104081502.496"><vh>ClearSelections</vh></v>
</v>
<v t="ekr.20051104081502.497"><vh>class MailDialog</vh>
<v t="ekr.20051104081502.498"><vh>__init__</vh></v>
</v>
<v t="ekr.20051104081502.499"><vh>class CalendarDialog</vh>
<v t="ekr.20051104081502.500"><vh>__init__</vh></v>
<v t="ekr.20051104081502.501"><vh>OnCalSelected</vh></v>
<v t="ekr.20051104081502.502"><vh>OnChangeMonth</vh></v>
<v t="ekr.20051104081502.503"><vh>OnCloseWindow</vh></v>
<v t="ekr.20051104081502.504"><vh>GetDate</vh></v>
</v>
<v t="ekr.20051104081502.505"><vh>class FindDialog</vh>
<v t="ekr.20051104081502.506"><vh>__init__</vh></v>
</v>
<v t="ekr.20051104081502.507"><vh>class EvalDialog</vh>
<v t="ekr.20051104081502.508"><vh>__init__</vh></v>
<v t="ekr.20051104081502.509"><vh>PostOKEvent</vh></v>
</v>
<v t="ekr.20051104081502.510"><vh>class LoggerDialog</vh>
<v t="ekr.20051104081502.511"><vh>__init__</vh></v>
<v t="ekr.20051104081502.512"><vh>OnSave</vh></v>
</v>
<v t="ekr.20051104081502.513"><vh>class FinishedDialog</vh>
<v t="ekr.20051104081502.514"><vh>__init__</vh></v>
<v t="ekr.20051104081502.515"><vh>OnSpin</vh></v>
<v t="ekr.20051104081502.516"><vh>OnCheck</vh></v>
</v>
<v t="ekr.20051104081502.517"><vh>class TreeDialog</vh>
<v t="ekr.20051104081502.518"><vh>__init__</vh></v>
<v t="ekr.20051104081502.519"><vh>OnLeftDClick:</vh></v>
</v>
</v>
<v t="ekr.20051104081502.520"><vh>outlookAddin.py</vh>
<v t="ekr.20051104081502.521"><vh>&lt;&lt; outlookAddin declarations &gt;&gt;</vh></v>
<v t="ekr.20051104081502.522"><vh>class ButtonEvent</vh>
<v t="ekr.20051104081502.523"><vh>OnClick</vh></v>
</v>
<v t="ekr.20051104081502.524"><vh>class FolderEvent</vh>
<v t="ekr.20051104081502.525"><vh>OnItemAdd</vh></v>
</v>
<v t="ekr.20051104081502.526"><vh>class OutlookAddin</vh>
<v t="ekr.20051104081502.527"><vh>&lt;&lt; class OutlookAddin declarations &gt;&gt;</vh></v>
<v t="ekr.20051104081502.528"><vh>OnConnection</vh></v>
<v t="ekr.20051104081502.529"><vh>OnDisconnection</vh></v>
<v t="ekr.20051104081502.530"><vh>OnAddInsUpdate</vh></v>
<v t="ekr.20051104081502.531"><vh>OnStartupComplete</vh></v>
<v t="ekr.20051104081502.532"><vh>OnBeginShutdown</vh></v>
</v>
<v t="ekr.20051104081502.533"><vh>RegisterAddin</vh></v>
<v t="ekr.20051104081502.534"><vh>UnregisterAddin</vh></v>
</v>
</v>
<v t="ekr.20051104081502.535"><vh>@rst ../doc/pdfTest.pdf</vh>
<v t="ekr.20051104081502.536"><vh>child node</vh>
<v t="ekr.20051104081502.537"><vh>@rst</vh></v>
</v>
</v>
</v>
<v t="ekr.20051104081502.546"><vh>Tests of settings when opened from another .leo file</vh></v>
<v t="ekr.20051104081502.159"><vh>Tk bindtags test</vh></v>
<v t="ekr.20051104081502.305"><vh>Unicode stuff</vh></v>
<v t="ekr.20051104081502.549"><vh>Write to log tab</vh></v>
<v t="ekr.20051104081502.548"><vh>Write to test tab</vh></v>
</v>
<v t="ekr.20040712101754.213"><vh>Unfinished</vh>
<v t="ekr.20040712101754.214"><vh>Outline tests (Sometimes fails)</vh>
<v t="ekr.20040712101754.215"><vh>test of p.copyTreeAfter and p.copyTreeFromSelfTo</vh>
<v t="ekr.20040712101754.216"><vh>root1</vh>
<v t="ekr.20040712101754.217"><vh>a</vh>
<v t="ekr.20040712101754.218"><vh>c</vh>
<v t="ekr.20040712101754.219"><vh>d</vh></v>
</v>
</v>
<v t="ekr.20040712101754.220"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.221"><vh>Manual test of testUtils.replaceOutline</vh>
<v t="ekr.20040712101754.222"><vh>outline1</vh>
<v t="ekr.20040712101754.223"><vh>a</vh></v>
</v>
<v t="ekr.20040712101754.224"><vh>outline2</vh>
<v t="ekr.20040712101754.225"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.226"><vh>testUtils.replaceOutline</vh></v>
<v t="ekr.20040712101754.227"><vh>@@ suite Outline/Undo tests</vh>
<v t="ekr.20040712101754.228"><vh> makeOutlineSuite</vh></v>
<v t="ekr.20040712101754.229"><vh>class outlineTestCase</vh>
<v t="ekr.20040712101754.230"><vh>__init__</vh></v>
<v t="ekr.20040712101754.231"><vh>outlineCommand</vh></v>
<v t="ekr.20040712101754.232"><vh>runTest</vh></v>
<v t="ekr.20040712101754.233"><vh>setUp</vh></v>
<v t="ekr.20040712101754.234"><vh>tearDown</vh></v>
<v t="ekr.20040712101754.235"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20040712101754.236"><vh>outlineTests</vh>
<v t="ekr.20040712101754.237"><vh>moveOutlineDown</vh>
<v t="ekr.20040712101754.238"><vh>before</vh>
<v t="ekr.20040712101754.239"><vh>a</vh></v>
<v t="ekr.20040712101754.240"><vh>move</vh></v>
<v t="ekr.20040712101754.241"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.242"><vh>after</vh>
<v t="ekr.20040712101754.243"><vh>a</vh></v>
<v t="ekr.20040712101754.244"><vh>b</vh></v>
<v t="ekr.20040712101754.245"><vh>move</vh></v>
</v>
<v t="ekr.20040712101754.246"><vh>ref</vh>
<v t="ekr.20040712101754.247"><vh>a</vh></v>
<v t="ekr.20040712101754.248"><vh>move</vh></v>
<v t="ekr.20040712101754.249"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.250"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20040712101754.251"><vh>moveOutlineRight</vh></v>
<v t="ekr.20040712101754.252"><vh>moveOutlineUp</vh></v>
</v>
</v>
<v t="ekr.20040712101754.253"><vh>Find Command tests...(Not finished)</vh>
<v t="ekr.20040712101754.254"><vh>@suite Find commands tests</vh>
<v t="ekr.20040712101754.255"><vh>class findCommandTestCase</vh>
<v t="ekr.20040712101754.256"><vh>setUp</vh></v>
<v t="ekr.20040712101754.257"><vh>testFindCommand</vh></v>
<v t="ekr.20040712101754.258"><vh>testFindWordCommand</vh></v>
<v t="ekr.20040712101754.259"><vh>testFindIgnoreCaseCommand</vh></v>
</v>
</v>
<v t="ekr.20040712101754.260"><vh>findTests</vh></v>
</v>
</v>
<v t="ekr.20051104081502.160"><vh>User Icon tests</vh>
<v t="ekr.20051104081502.161"><vh>Delete user icons</vh></v>
<v t="ekr.20051104081502.162"><vh>Test of user icons</vh>
<v t="ekr.20051104081502.163"><vh>&lt;&lt; define event callbacks &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070615070259"><vh>No longer used</vh>
<v t="ekr.20050208073718"><vh>@@test open file with chinese characters in path &amp; file</vh></v>
<v t="ekr.20040831101747"><vh>@@test line endings of Linux scripts</vh></v>
<v t="ekr.20050106080304"><vh>@@suite run all test routines (runs some tests twice!)</vh>
<v t="ekr.20050106123646"><vh>unused</vh>
<v t="ekr.20050106094854"><vh>class commanderTestCase</vh>
<v t="ekr.20050106094854.1"><vh>__init__</vh></v>
<v t="ekr.20050106094854.2"><vh> fail</vh></v>
<v t="ekr.20050106094854.5"><vh>runTest</vh></v>
<v t="ekr.20050106094854.6"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20050106094747"><vh>addTestRoutinesInCommanderToSuite</vh>
<v t="ekr.20050106095223"><vh>findTestsInCommander</vh></v>
</v>
</v>
<v t="ekr.20050106080318.1"><vh>&lt;&lt; class testRoutineTestCase &gt;&gt;</vh>
<v t="ekr.20050106080318.2"><vh>__init__</vh></v>
<v t="ekr.20050106080318.3"><vh> fail</vh></v>
<v t="ekr.20050106080318.6"><vh>runTest</vh></v>
<v t="ekr.20050106080318.7"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20050106080318"><vh>addTestRoutinesInModuleToSuite</vh></v>
<v t="ekr.20050106081120.2"><vh>findTestsInModule</vh>
<v t="ekr.20050106124235"><vh>&lt;&lt; print classes, methods &amp; functions &gt;&gt;</vh></v>
</v>
<v t="ekr.20050106124624"><vh>getAllLeoModules</vh></v>
<v t="ekr.20050106133147"><vh>removeLeadingWs</vh></v>
</v>
<v t="ekr.20061014152506"><vh>Tests of script buttons</vh>
<v t="ekr.20061014152506.1"><vh>@@button test-at-button-node</vh></v>
<v t="ekr.20061014152506.2"><vh>@@test script buttons create commands</vh></v>
</v>
</v>
<v t="ekr.20060208195054"><vh>@@test k.inverseCommandsDict is inverse of c.commandsDict</vh>
<v t="ekr.20070926095117"><vh>mungeKey</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070417092935.1"><vh>Scripts</vh>
<v t="ekr.20080405085247.2"><vh>@ignore</vh>
<v t="ekr.20070217065840"><vh>Scripts that make unit tests</vh>
<v t="ekr.20070217065840.1"><vh>@@command make-test @key = Alt-5</vh></v>
<v t="ekr.20070217065840.2"><vh>@@command do-before @key = Alt-6</vh>
<v t="ekr.20070217065840.3"><vh>getSel</vh></v>
<v t="ekr.20070217065840.4"><vh>findNodes</vh></v>
<v t="ekr.20070217065840.5"><vh>putSelectionInHeadline</vh></v>
</v>
<v t="ekr.20070217065840.6"><vh>@@command do-after @key = Alt-7</vh>
<v t="ekr.20070217072822"><vh>getSel</vh></v>
<v t="ekr.20070217065840.8"><vh>findNodes</vh></v>
<v t="ekr.20070217065840.9"><vh>putSelectionInHeadline</vh></v>
</v>
<v t="ekr.20070217065840.10"><vh>@test kill-line</vh>
<v t="ekr.20070217065840.11"><vh>work</vh></v>
<v t="ekr.20070217065840.12"><vh>before sel=2.0,2.0</vh></v>
<v t="ekr.20070217065840.13"><vh>after sel=2.0,2.0</vh></v>
</v>
</v>
<v t="ekr.20070113145100"><vh>Create chinese folder</vh></v>
<v t="ekr.20071113140035"><vh>Find unique @ test nodes</vh></v>
<v t="ekr.20091206090247.5060"><vh>Clear all uA's, tnodeLists, etc.</vh>
<v t="ekr.20091206090247.5061"><vh>Clean unused tnodeLists</vh></v>
<v t="ekr.20091206090247.5062"><vh>Clear all timestamps</vh></v>
<v t="ekr.20091206090247.5063"><vh>Clear all uAs (unknown attributes)</vh></v>
</v>
</v>
</v>
<v t="ekr.20071113203234"><vh> Test files</vh>
<v t="ekr.20090704085350.5028"><vh>@asis ../test/unittest/at-asis-test.py</vh>
<v t="ekr.20090704085350.5029"><vh>spam</vh></v>
<v t="ekr.20090704085350.5030"><vh>eggs</vh></v>
</v>
<v t="ekr.20090704085350.5056"><vh>@auto ../test/unittest/at-auto-test.py</vh></v>
<v t="ekr.20090704085350.5007"><vh>@@file ../test/unittest/at-file-test.py</vh></v>
<v t="ekr.20090704085350.5040"><vh>@@noref ../test/unittest/at-noref-test.py</vh>
<v t="ekr.20100123093044.5115"><vh>spam</vh></v>
<v t="ekr.20100123093044.5117"><vh>eggs</vh></v>
</v>
<v t="ekr.20090704085350.5034"><vh>@nosent ../test/unittest/at-nosent-test.py</vh>
<v t="ekr.20090704085350.5035"><vh>spam</vh></v>
<v t="ekr.20090704085350.5036"><vh>eggs</vh></v>
</v>
<v t="ekr.20090704085350.5014"><vh>@shadow ../test/unittest/at-shadow-test.py</vh></v>
<v t="ekr.20090704085350.5022"><vh>@thin ../test/unittest/at-thin-test.py</vh></v>
<v t="ekr.20100731163237.5782"><vh>@thin ../test/unittest/at-thin-html-test.html</vh></v>
<v t="ekr.20070627082044.811"><vh>@thin ../test/unittest/batchTest.py</vh></v>
<v t="ekr.20070627082044.808"><vh>@thin ../test/unittest/errorTest.py</vh></v>
</v>
<v t="ekr.20080703104536.1"><vh>Other tests</vh>
<v t="ekr.20051104081502.108"></v>
<v t="ekr.20051104081502.109"></v>
<v t="ekr.20080821123427.2"><vh>Standard print test</vh></v>
<v t="ekr.20100125180231.5120"><vh>Print a unicode character</vh></v>
<v t="ekr.20080503132221.1"><vh>Startup</vh></v>
<v t="ekr.20100127162342.5123"><vh>Import all plugins script</vh></v>
<v t="ekr.20100203163606.5365"><vh>2to3 script</vh></v>
</v>
<v t="ekr.20100806211747.5792"><vh>Unused tests</vh>
<v t="ekr.20100806211605.5810"><vh>@ignore</vh>
<v t="ekr.20100806211747.5793"><vh>Tests of tangle, untangle and @root</vh>
<v t="sps.20100624231018.20956"><vh>leoTangle</vh>
<v t="sps.20100624231018.20957"><vh>support routines</vh>
<v t="sps.20100624231018.20968"><vh>@test setRootFromText</vh></v>
<v t="sps.20100625103510.5658"><vh>@test skip_section_name</vh></v>
<v t="sps.20100624231018.20970"><vh>@test st_enter</vh></v>
<v t="sps.20100624231018.20972"><vh>@test st_enter_root_name</vh></v>
<v t="sps.20100624231018.20966"><vh>@test token_type</vh></v>
<v t="sps.20100627223129.5655"><vh>parent_language_comment_settings</vh>
<v t="sps.20100627223129.5656"><vh>@test plcs 1</vh>
<v t="sps.20100627223129.5657"><vh>c1</vh></v>
</v>
<v t="sps.20100627223129.5660"><vh>@test plcs 2</vh>
<v t="sps.20100627223129.5661"><vh>c1</vh></v>
</v>
<v t="sps.20100627225153.5667"><vh>@test plcs 3</vh>
<v t="sps.20100627225153.5668"><vh>c1</vh></v>
</v>
<v t="sps.20100627232933.5673"><vh>@test plcs 4</vh>
<v t="sps.20100627232933.5677"><vh>'root-test'</vh>
<v t="sps.20100627232933.5674"><vh>c1</vh></v>
</v>
</v>
</v>
<v t="sps.20100624231018.20988"><vh>put_all_roots</vh>
<v t="sps.20100624231018.20989"><vh>@test put_all_roots</vh>
<v t="sps.20100624231018.20990"><vh>#@root</vh></v>
</v>
<v t="sps.20100624231018.20991"><vh>@test put_all_roots, multiple root</vh>
<v t="sps.20100624231018.20992"><vh>#@root</vh></v>
</v>
</v>
<v t="sps.20100624231018.20958"><vh>scanAllDirectives</vh>
<v t="sps.20100624231018.20959"><vh>@test c.tangleCommands.scanAllDirectives</vh></v>
<v t="sps.20100624231018.20960"><vh>@test c.tangleCommands.scanAllDirectives 2</vh></v>
<v t="sps.20100624231018.20961"><vh>@test c.tangleCommands.scanAllDirectives 3</vh>
<v t="sps.20100624231018.20962"><vh>#@root</vh></v>
</v>
<v t="sps.20100624231018.20963"><vh>@test t.scanAllDirectives 4</vh>
<v t="sps.20100624231018.20964"><vh>#@root</vh></v>
</v>
</v>
<v t="sps.20100624231018.20973"><vh>skip_body</vh>
<v t="sps.20100624231018.20974"><vh>@test skip_body</vh>
<v t="sps.20100624231018.20975"><vh>#@root</vh></v>
</v>
<v t="sps.20100624231018.20976"><vh>@test skip_body, multiple root</vh>
<v t="sps.20100624231018.20977"><vh>#@root</vh></v>
</v>
</v>
<v t="sps.20100624231018.20978"><vh>tanglePass1</vh>
<v t="sps.20100624231018.20979"><vh>@test tanglePass1</vh>
<v t="sps.20100624231018.20980"><vh>#@root</vh></v>
</v>
<v t="sps.20100624231018.20981"><vh>@test tanglePass1, multiple root</vh>
<v t="sps.20100624231018.20982"><vh>#@root</vh></v>
</v>
<v t="sps.20100625103510.5793"><vh>@test tanglePass1, less simple</vh>
<v t="sps.20100625103510.5794"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100628022850.5677"><vh>@test tanglePass1, less simple 2</vh>
<v t="sps.20100628022850.5679"><vh>@language html</vh>
<v t="sps.20100628022850.5678"><vh>'root-test'</vh></v>
</v>
</v>
</v>
<v t="sps.20100624231018.20983"><vh>tanglePass2</vh>
<v t="sps.20100624231018.20984"><vh>@test tanglePass2</vh>
<v t="sps.20100624231018.20985"><vh>#@root</vh></v>
</v>
<v t="sps.20100624231018.20986"><vh>@test tanglePass2, multiple root</vh>
<v t="sps.20100624231018.20987"><vh>#@root</vh></v>
</v>
</v>
</v>
<v t="sps.20100624231018.20993"><vh>top level</vh>
<v t="sps.20100624231018.20994"><vh>tangle</vh>
<v t="sps.20100624231018.20995"><vh>with sentinels</vh>
<v t="sps.20100624231018.20996"><vh>now working</vh>
<v t="sps.20100624231018.20997"><vh>@test @root with @language c</vh>
<v t="sps.20100624231018.20998"><vh>#@root</vh></v>
<v t="sps.20100624231018.20999"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21000"><vh>@test @root</vh>
<v t="sps.20100624231018.21001"><vh>#@root</vh></v>
<v t="sps.20100624231018.21002"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100629094515.16515"><vh>@test @root - trivial</vh>
<v t="sps.20100629094515.16516"><vh>#@root</vh></v>
<v t="sps.20100629094515.16517"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21003"><vh>NOTE:</vh></v>
<v t="sps.20100624231018.21004"><vh>@test @root-doc</vh>
<v t="sps.20100624231018.21005"><vh>#@root</vh></v>
<v t="sps.20100624231018.21006"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21007"><vh>@test @root-doc with subnodes</vh>
<v t="sps.20100624231018.21008"><vh>#@root</vh>
<v t="sps.20100624231018.21009"><vh>further definition</vh></v>
</v>
<v t="sps.20100624231018.21010"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21011"><vh>@test @root-code with subnodes</vh>
<v t="sps.20100624231018.21012"><vh>#@root</vh>
<v t="sps.20100624231018.21013"><vh>further definition</vh></v>
</v>
<v t="sps.20100624231018.21014"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21015"><vh>@test @root with multiple sections</vh>
<v t="sps.20100624231018.21016"><vh>#@root</vh>
<v t="sps.20100624231018.21017"><vh>&lt;&lt; secref one &gt;&gt;</vh></v>
<v t="sps.20100624231018.21018"><vh>&lt;&lt; secref two &gt;&gt;</vh></v>
</v>
<v t="sps.20100624231018.21019"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21020"><vh>@test @root with filled multiple sections</vh>
<v t="sps.20100624231018.21021"><vh>#@root</vh>
<v t="sps.20100624231018.21022"><vh>&lt;&lt; secref one &gt;&gt;</vh></v>
<v t="sps.20100624231018.21023"><vh>&lt;&lt; secref two &gt;&gt;</vh></v>
</v>
<v t="sps.20100624231018.21024"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21025"><vh>@test @root-doc with multiple sections</vh>
<v t="sps.20100624231018.21026"><vh>#@root</vh>
<v t="sps.20100624231018.21027"><vh>&lt;&lt; secref one &gt;&gt;</vh></v>
<v t="sps.20100624231018.21028"><vh>&lt;&lt; secref two &gt;&gt;</vh></v>
</v>
<v t="sps.20100624231018.21029"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21030"><vh>@test @root-code with multiple sections</vh>
<v t="sps.20100624231018.21031"><vh>#@root</vh>
<v t="sps.20100624231018.21032"><vh>&lt;&lt; secref one &gt;&gt;</vh></v>
<v t="sps.20100624231018.21033"><vh>&lt;&lt; secref two &gt;&gt;</vh></v>
</v>
<v t="sps.20100624231018.21034"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21035"><vh>@test @root with @comment #</vh>
<v t="sps.20100624231018.21036"><vh>#@root</vh></v>
<v t="sps.20100624231018.21037"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21038"><vh>@test @root with @comment /* */</vh>
<v t="sps.20100624231018.21039"><vh>#@root</vh></v>
<v t="sps.20100624231018.21040"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21041"><vh>@test @root with @comment // /* */</vh>
<v t="sps.20100624231018.21042"><vh>#@root</vh></v>
<v t="sps.20100624231018.21043"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21044"><vh>@test @root with @language html</vh>
<v t="sps.20100624231018.21045"><vh>#@root</vh></v>
<v t="sps.20100624231018.21046"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21047"><vh>@test @root with @path directive (relative) in parent node</vh>
<v t="sps.20100624231018.21048"><vh>root</vh>
<v t="sps.20100624231018.21049"><vh>#@root</vh></v>
<v t="sps.20100624231018.21050"><vh>foo/'root-test'</vh></v>
</v>
</v>
<v t="sps.20100624231018.21051"><vh>@test @root with @path directive, relative</vh>
<v t="sps.20100624231018.21052"><vh>#@root</vh></v>
<v t="sps.20100624231018.21053"><vh>foo/'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21054"><vh>@test @root with @path directive, absolute</vh>
<v t="sps.20100624231018.21055"><vh>#@root</vh></v>
<v t="sps.20100624231018.21056"><vh>/tmp/'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21057"><vh>@test multiple @root directives</vh>
<v t="sps.20100624231018.21058"><vh>#@root</vh></v>
<v t="sps.20100624231018.21059"><vh>'root-test-one'</vh></v>
<v t="sps.20100624231018.21060"><vh>'root-test-two'</vh></v>
</v>
<v t="sps.20100624231018.21086"><vh>@test @root with @language html and @comment  //</vh>
<v t="sps.20100624231018.21087"><vh>#@root</vh></v>
<v t="sps.20100624231018.21089"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21061"><vh>NOTE: Multiple parts (and nodes) ARE allowed for &lt;&lt; secref &gt;&gt;</vh>
<v t="sps.20100624231018.21062"><vh>@test @root-doc with subnodes - headline &lt;&lt; secref &gt;&gt; first</vh>
<v t="sps.20100624231018.21063"><vh>#@root</vh>
<v t="sps.20100624231018.21064"><vh>&lt;&lt; secref &gt;&gt; this works</vh></v>
<v t="sps.20100624231018.21065"><vh>secref &gt;&gt;= definition - this works</vh></v>
</v>
<v t="sps.20100624231018.21066"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21067"><vh>@test @root-doc with subnodes - headline &lt;&lt; secref &gt;&gt; first</vh>
<v t="sps.20100624231018.21068"><vh>#@root</vh>
<v t="sps.20100624231018.21069"><vh>&lt;&lt; secref &gt;&gt; this works</vh></v>
</v>
<v t="sps.20100624231018.21070"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21071"><vh>@test @root-doc with subnodes - body &lt;&lt; secref &gt;&gt;= first</vh>
<v t="sps.20100624231018.21072"><vh>#@root</vh>
<v t="sps.20100624231018.21073"><vh>secref &gt;&gt;= definition - this works</vh></v>
<v t="sps.20100624231018.21074"><vh>&lt;&lt; secref &gt;&gt; this fails</vh></v>
</v>
<v t="sps.20100624231018.21075"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21076"><vh>@test @root-doc with subnodes - two headline &lt;&lt; secref &gt;&gt;s</vh>
<v t="sps.20100624231018.21077"><vh>#@root</vh>
<v t="sps.20100624231018.21078"><vh>&lt;&lt; secref &gt;&gt; part 1</vh></v>
<v t="sps.20100624231018.21079"><vh>&lt;&lt; secref &gt;&gt; part 2</vh></v>
</v>
<v t="sps.20100624231018.21080"><vh>'root-test'</vh></v>
</v>
</v>
<v t="sps.20100715131351.6756"><vh>@test @root section with doc but no code</vh>
<v t="sps.20100715131351.6758"><vh>#@root</vh>
<v t="sps.20100715131351.6757"><vh>&lt;&lt;foo&gt;&gt;</vh></v>
</v>
<v t="sps.20100715131351.6759"><vh>root_bug.c</vh></v>
</v>
<v t="sps.20100720210022.5737"><vh>@test @root with @terse</vh>
<v t="sps.20100720210022.5738"><vh>#@root</vh></v>
<v t="sps.20100720210022.5739"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100624231018.21082"><vh>@test @root with @language html and @comment</vh>
<v t="sps.20100624231018.21083"><vh>#@root</vh></v>
<v t="sps.20100624231018.21084"><vh>'root-test'</vh></v>
</v>
</v>
<v t="sps.20100715131351.6762"><vh>failing</vh>
<v t="sps.20100720210022.5743"><vh>@@test @root</vh>
<v t="sps.20100720210022.5744"><vh>@root 'root-test'</vh></v>
<v t="sps.20100720210022.5745"><vh>'root-test'</vh></v>
</v>
</v>
<v t="sps.20100624231018.21090"><vh>supposed to fail</vh>
<v t="sps.20100624231018.21091"><vh>@@test @root with @language html and @comment  //</vh>
<v t="sps.20100624231018.21092"><vh>#@root</vh>
<v t="sps.20100624231018.21093"><vh>&lt;&lt; javascript section &gt;&gt;</vh></v>
</v>
<v t="sps.20100624231018.21094"><vh>'root-test'</vh></v>
</v>
</v>
</v>
<v t="sps.20100624231018.21095"><vh>without sentinels</vh>
<v t="sps.20100624231018.21096"><vh>@test @root with @silent</vh>
<v t="sps.20100624231018.21097"><vh>#@root</vh></v>
<v t="sps.20100624231018.21098"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100720205345.16593"><vh>@test @root with @quiet</vh>
<v t="sps.20100720205345.16594"><vh>#@root</vh></v>
<v t="sps.20100720205345.16595"><vh>'root-test'</vh></v>
</v>
</v>
</v>
<v t="sps.20100624231018.21099"><vh>untangle</vh>
<v t="sps.20100624231018.21100"><vh>@test simplest untangle</vh>
<v t="sps.20100624231018.21101"><vh>#@root</vh></v>
<v t="sps.20100624231018.21102"><vh>#@root</vh></v>
<v t="sps.20100624231018.21103"><vh>foo</vh></v>
</v>
<v t="sps.20100629164540.5728"><vh>@test @root with @language html and @comment  //; 1</vh>
<v t="sps.20100629164540.5729"><vh>#@root</vh></v>
<v t="sps.20100629164540.5733"><vh>#@root</vh></v>
<v t="sps.20100629164540.5730"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100629184507.5695"><vh>@test @root with @language html and @comment  //; 2</vh>
<v t="sps.20100629184507.5696"><vh>#@root</vh></v>
<v t="sps.20100629184507.5697"><vh>#@root</vh></v>
<v t="sps.20100629184507.5698"><vh>'root-test'</vh></v>
</v>
<v t="sps.20100629215924.5705"><vh>@test @root with @language html and @comment  //; 3</vh>
<v t="sps.20100629215924.5706"><vh>#@root</vh></v>
<v t="sps.20100629215924.5707"><vh>#@root</vh></v>
<v t="sps.20100629215924.5708"><vh>'root-test'</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20090704085350.5062"><vh>@@root ../test/unittest/at-root-test.py</vh>
<v t="ekr.20090704085350.5063"><vh>spam</vh></v>
<v t="ekr.20090704085350.5064"><vh>eggs</vh></v>
</v>
<v t="ekr.20051104081502.170"><vh>Tests of @root</vh>
<v t="ekr.20051104081502.171"><vh>atRootTest1.txt</vh></v>
<v t="ekr.20051104081502.172"><vh>atRootTest2.txt</vh></v>
</v>
<v t="ekr.20090704093658.5061"><vh>@test @root: shape of tree</vh></v>
<v t="ekr.20090704093658.5062"><vh>@test @root: tangle works</vh></v>
<v t="ekr.20080917151620.10"><vh>@test c.scanAtRootDirectives root-code</vh></v>
<v t="ekr.20080917151620.11"><vh>@test c.scanAtRootDirectives root-doc</vh></v>
<v t="sps.20100609154419.5460"><vh>g.scanAtRootOptions</vh>
<v t="sps.20100609154419.5450"><vh>@test g.scanAtRootOptions none with filename</vh></v>
<v t="sps.20100609154419.5452"><vh>@test g.scanAtRootOptions -doc with filename</vh></v>
<v t="sps.20100609154419.5453"><vh>@test g.scanAtRootOptions -doc with missing filename</vh></v>
<v t="sps.20100609154419.5454"><vh>@test g.scanAtRootOptions -code with filename</vh></v>
<v t="sps.20100609154419.5455"><vh>@test g.scanAtRootOptions -code with missing filename</vh></v>
<v t="sps.20100609154419.5456"><vh>@test g.scanAtRootOptions -doc and -code with filename</vh></v>
<v t="sps.20100609154419.5457"><vh>@test g.scanAtRootOptions -doc and -code with missing filename</vh></v>
<v t="sps.20100609154419.5458"><vh>@test g.scanAtRootOptions -code and -doc with filename</vh></v>
<v t="sps.20100609154419.5459"><vh>@test g.scanAtRootOptions -code and -doc with missing filename</vh></v>
<v t="sps.20100609154419.5451"><vh>@test g.scanAtRootOptions none with missing filename</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040712101754.2"><vh>Load tests for .leo files</vh>
<v t="ekr.20040712101754.3"><vh>@test test.leo</vh></v>
<v t="ekr.20040803090901"><vh>@test leoDist.leo</vh></v>
<v t="ekr.20081121164135.1"><vh>@test leoGuiPluginsRef.leo</vh></v>
<v t="ekr.20040712101754.4"><vh>@test LeoPyRef.leo</vh></v>
<v t="ekr.20040712101754.5"><vh>@test leoPluginsRef.leo</vh></v>
<v t="ekr.20040712101754.6"><vh>@test LeoDocs.leo</vh></v>
<v t="ekr.20040730181601"><vh>@test minimalLeoFile.leo</vh></v>
<v t="ekr.20040730181610"><vh>@test minimalLeoFile2.leo</vh></v>
<v t="ekr.20040831104758"><vh>@test minimalLeoFile3.leo</vh></v>
</v>
<v t="ekr.20070114140212"><vh>All unit tests</vh>
<v t="ekr.20090703080553.5000"><vh>@suite run all doctests</vh>
<v t="ekr.20090703093925.5003"><vh>&lt;&lt; define exclude &gt;&gt;</vh></v>
</v>
<v t="ekr.20100210222021.5388"><vh>@test save new file</vh></v>
<v t="ekr.20100208230953.5383"><vh>Cache tests</vh>
<v t="ekr.20100208095817.5387"><vh>@test leoCache</vh></v>
</v>
<v t="ekr.20100131171342.5471"><vh>General</vh>
<v t="ekr.20100131171342.5472"><vh>Check base classes &amp; ivars</vh>
<v t="ekr.20100131171342.5473"><vh>Tk gui tests</vh>
<v t="ekr.20100131171342.5474"><vh>@test leoBody is subset of leoTkBody</vh></v>
<v t="ekr.20100131171342.5475"><vh>@test leoFrame is subset of leoTkFrame</vh></v>
<v t="ekr.20100131171342.5476"><vh>@test leoGui is subset of leoTkGui</vh></v>
<v t="ekr.20100131171342.5477"><vh>@test leoTree is subset of leoTkTree</vh></v>
</v>
<v t="ekr.20100131171342.5478"><vh>@test that leoQtLog/Body implements high-level interface</vh></v>
<v t="ekr.20100131171342.5479"><vh>@test official commander ivars</vh></v>
<v t="ekr.20100131171342.5480"><vh>@test official frame ivars</vh></v>
<v t="ekr.20100131171342.5481"><vh>@test official g.app directories</vh></v>
<v t="ekr.20100131171342.5482"><vh>@test official g.app ivars</vh></v>
</v>
<v t="ekr.20100131171342.5483"><vh>@test batch mode</vh>
<v t="ekr.20100131171342.5484"><vh>removeFile</vh></v>
</v>
<v t="ekr.20100131171342.5485"><vh>@test all commands have an event arg</vh></v>
<v t="ekr.20100131171342.5486"><vh>@@test that all @test nodes in derived files start with if g.unitTesting</vh>
<v t="ekr.20100131171342.5487"><vh>checkFile</vh></v>
</v>
</v>
<v t="ekr.20050120095423"><vh>Plugins</vh>
<v t="ekr.20080309193654.1"><vh>@ignore</vh>
<v t="ekr.20050120095423.11"><vh>@suite plugins tests</vh>
<v t="ekr.20050120095423.12"><vh>makePluginsTestSuite</vh></v>
<v t="ekr.20050120095423.13"><vh>class pluginTestCase</vh>
<v t="ekr.20050120095423.14"><vh>__init__</vh></v>
<v t="ekr.20050120095423.15"><vh>fail</vh></v>
<v t="ekr.20050120095423.16"><vh>runTest</vh></v>
<v t="ekr.20050120095423.17"><vh>setUp</vh></v>
<v t="ekr.20050120095423.18"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20050120095423.20"><vh>class lastTestCase</vh></v>
</v>
<v t="ekr.20050218015346"><vh>@suite run all plugin test routines</vh>
<v t="ekr.20050218015346.11"><vh>&lt;&lt; class testRoutineTestCase &gt;&gt;</vh>
<v t="ekr.20050218015346.12"><vh>__init__</vh></v>
<v t="ekr.20050218015346.13"><vh> fail</vh></v>
<v t="ekr.20050218015346.16"><vh>runTest</vh></v>
<v t="ekr.20050218015346.17"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20050218015346.18"><vh>addTestRoutinesInPluginToSuite</vh></v>
<v t="ekr.20050218015346.19"><vh>findTestsInModule</vh>
<v t="ekr.20050218015346.20"><vh>&lt;&lt; print classes, methods &amp; functions &gt;&gt;</vh></v>
</v>
<v t="ekr.20050218015346.22"><vh>removeLeadingWs</vh></v>
</v>
<v t="ekr.20100131171342.5500"><vh>@test macros.parameterize</vh></v>
<v t="ekr.20070301064408"><vh>@test print All plugins tests complete</vh></v>
<v t="ekr.20100131171342.5495"><vh>@test rClick.py</vh></v>
<v t="ekr.20100131171342.5501"><vh>@test restore the screen</vh></v>
<v t="ekr.20100131171342.5496"><vh>detect_urls.py</vh>
<v t="ekr.20100131171342.5497"><vh>Startup</vh></v>
<v t="ekr.20100131171342.5498"><vh>Docs</vh></v>
</v>
<v t="ekr.20100131171342.5502"><vh>gui plugins</vh>
<v t="ekr.20100131171342.5503"><vh>@test c.vnode2position</vh></v>
<v t="ekr.20100131171342.5504"><vh>@test position2Item</vh></v>
<v t="ekr.20100131171342.5505"><vh>@test item2position</vh></v>
</v>
<v t="ekr.20050120095423.21"><vh>print all loaded plugins</vh></v>
<v t="ekr.20080701183239.1"><vh>Tests of threading_colorizer code</vh>
<v t="ekr.20080701183239.2"><vh>quickConvertRowColToPythonIndex</vh></v>
<v t="ekr.20080701183239.3"><vh>quickConvertPythonIndexToRowCol</vh></v>
</v>
</v>
</v>
<v t="ekr.20100205223124.5377"><vh>Syntax checking</vh>
<v t="ekr.20040712101813"><vh>@@test c.checkAllPythonCode</vh></v>
<v t="ekr.20100205231441.5386"><vh>@test at.checkPythonSyntax</vh></v>
<v t="ekr.20100205233116.5387"><vh>@test at.tabNannyNode</vh></v>
<v t="ekr.20100205235740.5391"><vh>@test c.checkPythonCode</vh></v>
<v t="ekr.20100205223124.5378"><vh>@test c.checkPythonNode</vh>
<v t="ekr.20100205223124.5379"><vh>syntax-error</vh></v>
</v>
<v t="ekr.20100205234837.5390"><vh>@test c.tabNannyNode</vh></v>
<v t="ekr.20100206002004.5397"><vh>@test g.es_exception</vh></v>
<v t="ekr.20071113145804.20"><vh>@@test g.es_exception (heroic)</vh></v>
<v t="ekr.20100206001203.5395"><vh>@test g.getLastTracebackFileAndLineNumber</vh></v>
<v t="ekr.20100205230621.5383"><vh>@test leoTest.checkFileSyntax</vh></v>
<v t="ekr.20100205235740.5392"><vh>@test syntax of all files</vh></v>
</v>
<v t="ekr.20050208051418"><vh>Unicode tests</vh>
<v t="ekr.20050206201145"><vh>@test % operator with unicode</vh></v>
<v t="ekr.20050208051854"><vh>@test atFile.printError</vh></v>
<v t="ekr.20050208051418.1"><vh>@test can't open message in g.openWithFileName</vh></v>
<v t="ekr.20050208111037"><vh>@test failure to convert unicode characters to ascii</vh></v>
<v t="ekr.20071113143844.6"><vh>@test failure with ascii encodings</vh></v>
<v t="ekr.20071113145804.23"><vh>@test g.reportBadChars</vh></v>
<v t="ekr.20100204053330.5367"><vh>@test koi8-r encoding</vh></v>
<v t="ekr.20050208104202"><vh>@test of round-tripping toUnicode &amp; toEncodedString</vh></v>
<v t="ekr.20050206090416"><vh>@test open non-existent non-ascii directory</vh></v>
<v t="ekr.20071113145804.24"><vh>@test round trip toUnicode toEncodedString</vh></v>
<v t="ekr.20100421102506.6282"><vh>@test rst.write with unicode character</vh></v>
</v>
<v t="ekr.20071113194858"><vh>Organized by file</vh>
<v t="ekr.20100223123103.5382"><vh>@test expand/contract-pane</vh></v>
<v t="ekr.20100131171342.5506"><vh>leoApp</vh>
<v t="ekr.20100131180007.5454"><vh>@test at.get/setPathUa</vh></v>
<v t="ekr.20100131180007.5461"><vh>@test at.replaceFileWithString</vh></v>
<v t="ekr.20100131180007.5458"><vh>@test at.scanAllDirectives</vh></v>
<v t="ekr.20100131180007.5451"><vh>@test cleanSaxInputString</vh></v>
<v t="ekr.20100131171342.5507"><vh>@test consistency of leoApp tables</vh></v>
<v t="ekr.20100131180007.5453"><vh>@test dynamicExpandHelper</vh></v>
<v t="ekr.20100131180007.5455"><vh>@test fullDirectoryPath</vh>
<v t="ekr.20100131180007.5456"><vh>@path abc</vh>
<v t="ekr.20100131180007.5457"><vh>xyz</vh></v>
</v>
</v>
<v t="ekr.20100131180007.5450"><vh>@test getSaxUa</vh></v>
<v t="ekr.20100131180007.5463"><vh>@test handleTnodeSaxAttributes</vh></v>
<v t="ekr.20100131180007.5460"><vh>@test handleVnodeSaxAttributes</vh></v>
<v t="ekr.20100131180007.5459"><vh>@test initAtAutoWrite</vh></v>
<v t="ekr.20100131180007.5452"><vh>@@test tnodeAttributes</vh></v>
<v t="ekr.20100131180007.5462"><vh>@test verbatim sentinel</vh></v>
</v>
<v t="ekr.20050112095306.1"><vh>leoAtFile</vh>
<v t="ekr.20040712101754.103"><vh>@@test @file no newline</vh>
<v t="ekr.20040712101754.104"><vh>#@file</vh></v>
<v t="ekr.20040712101754.105"><vh>Output</vh></v>
</v>
<v t="ekr.20040712101754.106"><vh>@@test @file one newline</vh>
<v t="ekr.20040712101754.107"><vh>#@file</vh></v>
<v t="ekr.20040712101754.108"><vh>Output</vh></v>
</v>
<v t="ekr.20040712101754.109"><vh>@@test @file two newlines</vh>
<v t="ekr.20040712101754.110"><vh>#@file</vh></v>
<v t="ekr.20040712101754.111"><vh>Output</vh></v>
</v>
<v t="ekr.20090704085350.5010"><vh>@@test @file: shape of tree</vh></v>
<v t="ekr.20041021065844"><vh>@test @asis</vh>
<v t="ekr.20041021065903"><vh>#@asis</vh>
<v t="ekr.20041021065903.1"><vh>&lt;&lt; section &gt;&gt;</vh></v>
<v t="ekr.20041021065903.2"><vh>unnamed node</vh></v>
</v>
<v t="ekr.20041021065844.1"><vh>Output</vh></v>
</v>
<v t="ekr.20090704085350.5044"><vh>@test @asis: shape of tree</vh></v>
<v t="ekr.20090627070131.4971"><vh>@test @auto (newlines at end of nodes)</vh>
<v t="ekr.20090627070131.4975"><vh>#@auto</vh>
<v t="ekr.20090627070131.4976"><vh>spam</vh></v>
<v t="ekr.20090627070131.4977"><vh>cheese</vh></v>
</v>
<v t="ekr.20090627070131.4978"><vh>Output</vh></v>
</v>
<v t="ekr.20100801125533.5787"><vh>@test @auto (no newline at end of nodes)</vh>
<v t="ekr.20100801125533.5788"><vh>#@auto</vh>
<v t="ekr.20100801125533.5789"><vh>spam</vh></v>
<v t="ekr.20100801125533.5790"><vh>cheese</vh></v>
</v>
<v t="ekr.20100801125533.5791"><vh>Output</vh></v>
</v>
<v t="ekr.20090704085350.5052"><vh>@test @auto: shape of tree</vh></v>
<v t="ekr.20090225102051.2"><vh>@test @edit</vh>
<v t="ekr.20090225102051.3"><vh>#@edit</vh></v>
<v t="ekr.20090225102051.4"><vh>Output</vh></v>
</v>
<v t="ekr.20090704085350.5018"><vh>@test @shadow: shape of tree</vh></v>
<v t="ekr.20040707141957.12"><vh>@test @thin: @last</vh>
<v t="ekr.20040707141957.13"><vh>#@thin</vh></v>
<v t="ekr.20040707141957.14"><vh>Output</vh></v>
</v>
<v t="ekr.20100731163237.5778"><vh>@test @thin: html section references</vh></v>
<v t="ekr.20090704085350.5046"><vh>@test @thin: shape of tree</vh></v>
<v t="ekr.20100802220019.5795"><vh>@test at.deleteUnvistedNodes</vh></v>
<v t="ekr.20071113145804.8"><vh>@test at.directiveKind4</vh></v>
<v t="ekr.20100225094004.5385"><vh>@test at.isFileLike</vh></v>
<v t="ekr.20071113143844.5"><vh>@test at.isSignificantTree</vh></v>
<v t="ekr.20090529115704.4562"><vh>@test at.open/closeStringFile</vh></v>
<v t="ekr.20090529115704.4563"><vh>@test at.openForWrite: not a shadow file</vh></v>
<v t="ekr.20090529115704.4564"><vh>@test at.readOneAtShadowNode</vh>
<v t="ekr.20090529115704.4565"><vh>@@shadow unittest/read_test.py</vh></v>
</v>
<v t="ekr.20050105093136"><vh>@test at.remove</vh></v>
<v t="ekr.20050105093524"><vh>@test at.rename</vh></v>
<v t="ekr.20090529115704.4566"><vh>@test at.replaceFileWithString</vh></v>
<v t="ekr.20050105094311"><vh>@test at.replaceTargetFileIfDifferent (different)</vh></v>
<v t="ekr.20050105095743"><vh>@test at.replaceTargetFileIfDifferent (identical)</vh></v>
<v t="ekr.20050105100227"><vh>@test at.replaceTargetFileIfDifferent (no target file)</vh></v>
<v t="ekr.20071113090055.4"><vh>@test at.scanAllDirectives</vh></v>
<v t="ekr.20090529115704.4567"><vh>@test at.writeOneAtShadowNode</vh>
<v t="ekr.20090529115704.4568"><vh>@@shadow unittest/test_1.py</vh></v>
</v>
<v t="ekr.20071113145804.7"><vh>@test parseLeoSentinel</vh></v>
<v t="ekr.20060602195313"><vh>@test reads/write using @comment</vh>
<v t="ekr.20060602195313.2"><vh>root</vh>
<v t="ekr.20060602195313.3"><vh>&lt;&lt; Get LRR Task &gt;&gt;</vh></v>
<v t="ekr.20060602195313.4"><vh>&lt;&lt; Start LRR &gt;&gt;</vh></v>
</v>
<v t="ekr.20060602195914"><vh>Result</vh></v>
</v>
<v t="ekr.20090620110118.5829"><vh>@test verbatim sentinel</vh></v>
<v t="ekr.20071113201736"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20100131171342.5508"><vh>leoBridge</vh>
<v t="ekr.20100131171342.5509"><vh>@test leoBridge init logic</vh></v>
</v>
<v t="ekr.20090615053403.4876"><vh>leoColor</vh>
<v t="ekr.20090615053403.4877"><vh>@test @comment after @language plain</vh>
<v t="ekr.20090615053403.4878"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4879"><vh>@test colorizer Actionscript</vh>
<v t="ekr.20090615053403.4880"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4881"><vh>@test colorizer C</vh>
<v t="ekr.20090615053403.4882"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4883"><vh>@test colorizer C#</vh>
<v t="ekr.20090615053403.4884"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4885"><vh>@test colorizer css</vh>
<v t="ekr.20090615053403.4886"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4887"><vh>@test colorizer CWEB</vh>
<v t="ekr.20090615053403.4888"><vh>Startup</vh>
<v t="ekr.20090615053403.4889"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090615053403.4890"><vh>@test colorizer elisp</vh>
<v t="ekr.20090615053403.4891"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4892"><vh>@test colorizer erlang</vh>
<v t="ekr.20090615053403.4893"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4894"><vh>@test colorizer forth</vh>
<v t="ekr.20090615053403.4895"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4896"><vh>@test colorizer HTML string bug</vh>
<v t="ekr.20090615053403.4897"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4898"><vh>@test colorizer HTML1</vh>
<v t="ekr.20090615053403.4899"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4900"><vh>@test colorizer HTML2</vh>
<v t="ekr.20090615053403.4901"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4902"><vh>@test colorizer Java</vh>
<v t="ekr.20090615053403.4903"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4904"><vh>@test colorizer LaTex</vh>
<v t="ekr.20090615053403.4905"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4906"><vh>@test colorizer lisp</vh>
<v t="ekr.20090615053403.4907"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4908"><vh>@test colorizer perl</vh>
<v t="ekr.20090615053403.4909"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4910"><vh>@test colorizer PHP</vh>
<v t="ekr.20090615053403.4911"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4912"><vh>@test colorizer plsql</vh>
<v t="ekr.20090615053403.4913"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4914"><vh>@test colorizer python.xml (jEdit)</vh>
<v t="ekr.20090615053403.4915"><vh>Startup</vh>
<v t="ekr.20090615053403.4916"><vh>&lt;&lt; remarks &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4917"><vh>&lt;&lt; comments &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4918"><vh>&lt;&lt; literals &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4919"><vh>&lt;&lt; operators &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4920"><vh>&lt;&lt; keywords &gt;&gt;</vh>
<v t="ekr.20090615053403.4921"><vh>&lt;&lt; reserved words &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4922"><vh>&lt;&lt; builtins &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4923"><vh>&lt;&lt; exceptions &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4924"><vh>&lt;&lt; types &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20090615053403.4925"><vh>@test colorizer Python1</vh>
<v t="ekr.20090615053403.4926"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4927"><vh>@test colorizer Python2</vh>
<v t="ekr.20090615053403.4928"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4929"><vh>@test colorizer r</vh>
<v t="ekr.20090615053403.4930"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4931"><vh>@test colorizer rapidq</vh>
<v t="ekr.20090615053403.4932"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4933"><vh>@test colorizer Rebol</vh>
<v t="ekr.20090615053403.4934"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4935"><vh>@test colorizer rest</vh>
<v t="ekr.20090615053403.4936"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4937"><vh>@test colorizer shell</vh>
<v t="ekr.20090615053403.4938"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4939"><vh>@test colorizer shellscript</vh>
<v t="ekr.20090615053403.4940"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4941"><vh>@test colorizer tex.xml (jEdit)</vh>
<v t="ekr.20090615053403.4942"><vh>Startup</vh>
<v t="ekr.20090615053403.4943"><vh>&lt;&lt; general rules &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4944"><vh>&lt;&lt; math rules &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090615053403.4945"><vh>@test colorizer wikiTest1</vh>
<v t="ekr.20090615053403.4946"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4947"><vh>@test colorizer wikiTest2</vh>
<v t="ekr.20090615053403.4948"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4949"><vh>@test colorizer wikiTest3</vh>
<v t="ekr.20090615053403.4950"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4951"><vh>@test leoColor.doNowebSecRef</vh>
<v t="ekr.20090615053403.4952"><vh>&lt;&lt; test defined &gt;&gt;</vh></v>
</v>
<v t="ekr.20090615053403.4953"><vh>@test python keywords (new colorizer)</vh></v>
<v t="ekr.20090615053403.4954"><vh>@test scanColorDirectives</vh></v>
<v t="ekr.20090615053403.4955"><vh>@test vbscript</vh>
<v t="ekr.20090615053403.4956"><vh>Startup</vh></v>
</v>
<v t="ekr.20090615053403.4957"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20071113193624"><vh>leoCommands</vh>
<v t="ekr.20050512084850"><vh> Check outline</vh>
<v t="ekr.20040712101754.272"><vh>Startup</vh></v>
<v t="ekr.20041019124050"><vh>Docs</vh>
<v t="ekr.20041019124050.1"><vh>Original</vh></v>
<v t="ekr.20041019124050.2"><vh>Test</vh></v>
</v>
<v t="ekr.20040713070526"><vh>Scripts</vh>
<v t="ekr.20040713123617"><vh>tempNode</vh></v>
<v t="ekr.20050726141158"><vh>before</vh></v>
<v t="ekr.20040713123828.1"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20100203103015.5352"><vh> For open-with</vh>
<v t="ekr.20100203103015.5353"><vh>@test open-with conflict dialog</vh></v>
<v t="ekr.20100203103015.5354"><vh>@test c.openWithTempFilePath</vh></v>
<v t="ekr.20100203103015.5355"><vh>@test c.getOpenWithExt</vh></v>
<v t="ekr.20100203103015.5356"><vh>@test c.openTempFileInExternalEditor</vh></v>
<v t="ekr.20100203103015.5357"><vh>@test g.isCallable</vh></v>
</v>
<v t="ekr.20071113194033"><vh> Mark commands</vh>
<v t="ekr.20050512083807.1"><vh>Startup</vh></v>
<v t="ekr.20050512083807.2"><vh>Docs</vh></v>
<v t="ekr.20050512083700.1"><vh>Scripts</vh></v>
<v t="ekr.20050512083807"><vh> Test files</vh></v>
<v t="ekr.20050512083816"><vh>Load tests for .leo files</vh></v>
<v t="ekr.20050512083816"></v>
<v t="ekr.20050512083822"><vh>All unit tests</vh></v>
<v t="ekr.20050512083822.1"><vh>@test markSubheads</vh>
<v t="ekr.20050512084850.1"><vh>child 1</vh></v>
<v t="ekr.20050512084850.2"><vh>child 2</vh></v>
</v>
<v t="ekr.20050512083822.2"><vh>@test unmarkAll</vh></v>
</v>
<v t="ekr.20050417102057"><vh> Reformat Paragraph tests </vh>
<v t="ekr.20050417102114"><vh>Startup</vh>
<v t="ekr.20050417104821"><vh>data</vh>
<v t="ekr.20050417124704"><vh>tempNode</vh></v>
<v t="ekr.20050417102114.1"><vh>before</vh></v>
<v t="ekr.20050417102114.2"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417111144"><vh>Docs</vh>
<v t="ekr.20050417111144.1"><vh>data</vh>
<v t="ekr.20050417111240"><vh>tempNode</vh></v>
<v t="ekr.20050417111144.2"><vh>before</vh></v>
<v t="ekr.20050417111144.3"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417113549"><vh>Scripts</vh>
<v t="ekr.20050417113910"><vh>data</vh>
<v t="ekr.20050417113921"><vh>tempNode</vh></v>
<v t="ekr.20050417113910.1"><vh>before</vh></v>
<v t="ekr.20050417113910.2"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417114153"><vh> Test files</vh>
<v t="ekr.20050417114221"><vh>data</vh>
<v t="ekr.20050417114221.1"><vh>tempNode</vh></v>
<v t="ekr.20050417114221.2"><vh>before</vh></v>
<v t="ekr.20050417114221.3"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417114836"><vh>Other tests</vh>
<v t="ekr.20050417095124.16"><vh>data</vh>
<v t="ekr.20050417114914"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.17"><vh>before</vh></v>
<v t="ekr.20050417095124.18"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417095020.11"><vh>Load tests for .leo files</vh>
<v t="ekr.20050417095124.19"><vh>data</vh>
<v t="ekr.20050417115111"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.20"><vh>before</vh></v>
<v t="ekr.20050417095124.21"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417095020.12"><vh>All unit tests</vh>
<v t="ekr.20050417095124.22"><vh>data</vh>
<v t="ekr.20050417115257"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.23"><vh>before</vh></v>
<v t="ekr.20050417095124.24"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417095020.13"><vh>@test simpleHangingIndent</vh>
<v t="ekr.20050417095124.25"><vh>data</vh>
<v t="ekr.20050417115414"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.26"><vh>before</vh></v>
<v t="ekr.20050417095124.27"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417095020.14"><vh>@test testSimpleHangingIndentVar1</vh>
<v t="ekr.20050417095124.28"><vh>data</vh>
<v t="ekr.20050417115559"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.29"><vh>before</vh></v>
<v t="ekr.20050417095124.30"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417095020.15"><vh>@test simpleHangingIndentVar2</vh>
<v t="ekr.20050417095124.31"><vh>data</vh>
<v t="ekr.20050417115709"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.32"><vh>before</vh></v>
<v t="ekr.20050417095124.33"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417120312.1"><vh>@test multiParagraphTest</vh>
<v t="ekr.20050417095124.34"><vh>data</vh>
<v t="ekr.20050417120312.2"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.35"><vh>before</vh></v>
<v t="ekr.20050417095124.36"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417121448"><vh>@test multiParagraphWithListTest</vh>
<v t="ekr.20050417095124.37"><vh>data</vh>
<v t="ekr.20050417121448.1"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.38"><vh>before</vh></v>
<v t="ekr.20050417095124.39"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417121942"><vh>@test leadingWSOnEmptyLinesTest</vh>
<v t="ekr.20050417095124.43"><vh>data</vh>
<v t="ekr.20050417121942.1"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.44"><vh>before</vh></v>
<v t="ekr.20050417095124.45"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417122215.1"><vh>@test directiveBreaksParagraphTest</vh>
<v t="ekr.20050417095124.40"><vh>data</vh>
<v t="ekr.20050417122215.2"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.41"><vh>before</vh></v>
<v t="ekr.20050417095124.42"><vh>after</vh></v>
</v>
</v>
</v>
<v t="ekr.20090104053806.1"><vh>@@test c.checkFileTimeStamp &amp; c.setFileTimeStamp</vh></v>
<v t="ekr.20071113145804.10"><vh>@test c.contractAllHeadlines</vh></v>
<v t="ekr.20100209155559.5386"><vh>@test c.createOpenWithTempFile</vh></v>
<v t="ekr.20100212072149.5341"><vh>@test c.goToScriptLineNumber</vh>
<v t="ekr.20100212072149.5342"><vh>syntax-error</vh></v>
</v>
<v t="ekr.20061106112522"><vh>@test c.insertBodyTime</vh></v>
<v t="ekr.20080917151620.9"><vh>@test c.scanAllDirectives</vh></v>
<v t="ekr.20100131180007.5466"><vh>@test c.scanAtPathDirectives</vh>
<v t="ekr.20100131180007.5467"><vh>@path one</vh>
<v t="ekr.20100131180007.5468"><vh>@path two</vh>
<v t="ekr.20100131180007.5469"><vh>xyz</vh></v>
</v>
</v>
</v>
<v t="sps.20100531034136.20110"><vh>@test c.scanAtPathDirectives same name subdirs</vh>
<v t="sps.20100531034136.20111"><vh>@path again</vh>
<v t="sps.20100531034136.20112"><vh>@path again</vh>
<v t="sps.20100531034136.20113"><vh>xyz</vh></v>
</v>
</v>
</v>
<v t="ekr.20040802065214"><vh>@test changing headline marks descendent @thin nodes dirty</vh>
<v t="ekr.20040802065214.1"><vh>bogus</vh></v>
</v>
<v t="ekr.20100131180007.5465"><vh>@test class StubConfig</vh></v>
<v t="ekr.20070611105423.1"><vh>@test contract all</vh></v>
<v t="ville.20090602190735.4770"><vh>@test g.command decorator</vh></v>
<v t="ekr.20071113105654.1"><vh>@test hoist with no children</vh></v>
<v t="ekr.20070611105728"><vh>@test illegal clone demote</vh></v>
<v t="ekr.20071113201833"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20071113194216"><vh>leoConfig</vh>
<v t="ekr.20060325071703.2"><vh>@@test ifgui</vh></v>
<v t="ekr.20100211110729.5389"><vh>@test g.app.config.writeRecentFilesFileHelper</vh></v>
<v t="ekr.20050203084930.1"><vh>@test global settings</vh></v>
<v t="ekr.20060325071703.1"><vh>@test ifplatform</vh></v>
<v t="ekr.20050203001146"><vh>@test local settings (c.page_width)</vh></v>
<v t="ekr.20071113201854"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20100131171342.5592"><vh>leoDialogs</vh>
<v t="ekr.20100131171342.5593"><vh>@test ctors for all dialogs</vh></v>
</v>
<v t="ekr.20071113192611"><vh>leoEditCommands</vh>
<v t="ekr.20100830114008.5967"><vh>@common leoEditCommands test code</vh>
<v t="ekr.20100830114008.5968"><vh>runEditCommandTest</vh></v>
</v>
<v t="ekr.20100204165850.5371"><vh>Toggle commands</vh>
<v t="ekr.20100119102849.5108"><vh>@test toggle-extend-mode</vh>
<v t="ekr.20100119102849.5109"><vh>&lt;&lt; define table &gt;&gt;</vh></v>
<v t="ekr.20100119102849.5110"><vh>work</vh></v>
</v>
<v t="ekr.20100204165850.5373"><vh>@test most toggle commands</vh></v>
<v t="ekr.20100204173354.5375"><vh>@test toggle-find-x</vh></v>
</v>
<v t="ekr.20070131175538"><vh> Commands A-B</vh>
<v t="ekr.20061101121602.78"><vh>@test add-space-to-lines</vh>
<v t="ekr.20061101121602.79"><vh>work</vh></v>
<v t="ekr.20061101121602.80"><vh>before sel=2.0,4.6</vh></v>
<v t="ekr.20061101121602.81"><vh>after sel=2.0,4.7</vh></v>
</v>
<v t="ekr.20061101121602.82"><vh>@test add-tab-to-lines</vh>
<v t="ekr.20061101121602.83"><vh>work</vh></v>
<v t="ekr.20061101121602.84"><vh>before sel=2.0,5.6</vh></v>
<v t="ekr.20061101121602.85"><vh>after sel=2.0,5.10</vh></v>
</v>
<v t="ekr.20071113145804.16"><vh>@test apropos_bindings</vh></v>
<v t="ekr.20071113145804.17"><vh>@test apropos_find_commands</vh></v>
<v t="ekr.20061101121602.86"><vh>@test back-char</vh>
<v t="ekr.20061101121602.87"><vh>work</vh></v>
<v t="ekr.20061101121602.88"><vh>before sel=3.8,3.8</vh></v>
<v t="ekr.20061101121602.89"><vh>after sel=3.7,3.7</vh></v>
</v>
<v t="ekr.20061101121602.90"><vh>@test back-char-extend-selection</vh>
<v t="ekr.20061101121602.91"><vh>work</vh></v>
<v t="ekr.20061101121602.92"><vh>before sel=4.12,4.12</vh></v>
<v t="ekr.20061101121602.93"><vh>after sel=4.11,4.12</vh></v>
</v>
<v t="ekr.20061101121602.94"><vh>@test back-paragraph</vh>
<v t="ekr.20061101121602.95"><vh>work</vh></v>
<v t="ekr.20061101121602.96"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.97"><vh>after sel=6.7,6.7</vh></v>
</v>
<v t="ekr.20061101121602.98"><vh>@test back-paragraph-extend-selection</vh>
<v t="ekr.20061101121602.99"><vh>work</vh></v>
<v t="ekr.20061101121602.100"><vh>before sel=9.0,9.5</vh></v>
<v t="ekr.20061101121602.101"><vh>after sel=6.7,9.5</vh></v>
</v>
<v t="ekr.20061101121602.102"><vh>@test back-sentence</vh>
<v t="ekr.20061101121602.103"><vh>work</vh></v>
<v t="ekr.20061101121602.104"><vh>before sel=3.169,3.169</vh></v>
<v t="ekr.20061101121602.105"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20061101121602.106"><vh>@test back-sentence-extend-selection</vh>
<v t="ekr.20061101121602.107"><vh>work</vh></v>
<v t="ekr.20061101121602.108"><vh>before sel=3.208,3.208</vh></v>
<v t="ekr.20061101121602.109"><vh>after sel=3.0,3.208</vh></v>
</v>
<v t="ekr.20061101121602.110"><vh>@test back-to-indentation</vh>
<v t="ekr.20061101121602.111"><vh>work</vh></v>
<v t="ekr.20061101121602.112"><vh>before sel=4.13,4.13</vh></v>
<v t="ekr.20061101121602.113"><vh>after sel=4.8,4.8</vh></v>
</v>
<v t="ekr.20090427104851.7"><vh>@test back-to-home (at start of line)</vh>
<v t="ekr.20090427104851.8"><vh>work</vh></v>
<v t="ekr.20090427104851.9"><vh>before sel=2.0,2.0</vh></v>
<v t="ekr.20090427104851.10"><vh>after sel=2.4,2.4</vh></v>
</v>
<v t="ekr.20090427104851.15"><vh>@test back-to-home (at indentation</vh>
<v t="ekr.20090427104851.16"><vh>work</vh></v>
<v t="ekr.20090427104851.17"><vh>before sel=2.4,2.4</vh></v>
<v t="ekr.20090427104851.18"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20090427104851.11"><vh>@test back-to-home (at end of line)</vh>
<v t="ekr.20090427104851.12"><vh>work</vh></v>
<v t="ekr.20090427104851.13"><vh>before sel=2.12,2.12</vh></v>
<v t="ekr.20090427104851.14"><vh>after sel=2.4,2.4</vh></v>
</v>
<v t="ekr.20061101121602.114"><vh>@test back-word</vh>
<v t="ekr.20061101121602.115"><vh>work</vh></v>
<v t="ekr.20061101121602.116"><vh>before sel=1.183,1.183</vh></v>
<v t="ekr.20061101121602.117"><vh>after sel=1.178,1.178</vh></v>
</v>
<v t="ekr.20061101121602.118"><vh>@test back-word-extend-selection</vh>
<v t="ekr.20061101121602.119"><vh>work</vh></v>
<v t="ekr.20061101121602.120"><vh>before sel=3.342,3.342</vh></v>
<v t="ekr.20061101121602.121"><vh>after sel=3.332,3.342</vh></v>
</v>
<v t="ekr.20061101121602.122"><vh>@test backward-delete-char</vh>
<v t="ekr.20061101121602.123"><vh>work</vh></v>
<v t="ekr.20061101121602.124"><vh>before sel=1.9,1.9</vh></v>
<v t="ekr.20061101121602.125"><vh>after sel=1.8,1.8</vh></v>
</v>
<v t="ekr.20071007121529"><vh>@test backward-delete-char  (middle of line)</vh>
<v t="ekr.20071007121529.1"><vh>work</vh></v>
<v t="ekr.20071007121529.2"><vh>before sel=1.6,1.6</vh></v>
<v t="ekr.20071007121529.3"><vh>after sel=1.5,1.5</vh></v>
</v>
<v t="ekr.20071007120947"><vh>@test backward-delete-char (last char)</vh>
<v t="ekr.20071007120947.6"><vh>work</vh></v>
<v t="ekr.20071007120947.7"><vh>before sel=2.9,2.9</vh></v>
<v t="ekr.20071007120947.8"><vh>after sel=2.8,2.8</vh></v>
</v>
<v t="ekr.20100817131738.5886"><vh>@test backward-delete-word (no selection)</vh>
<v t="ekr.20100817131738.5887"><vh>work</vh></v>
<v t="ekr.20100817131738.5888"><vh>before sel=1.10,1.10</vh></v>
<v t="ekr.20100817131738.5889"><vh>after sel=1.5,1.5</vh></v>
</v>
<v t="ekr.20100817131738.5894"><vh>@test backward-delete-word (selection)</vh>
<v t="ekr.20100817131738.5895"><vh>work</vh></v>
<v t="ekr.20100817131738.5896"><vh>before sel=1.7,1.12</vh></v>
<v t="ekr.20100817131738.5897"><vh>after sel=1.7,1.7</vh></v>
</v>
<v t="ekr.20061101121602.126"><vh>@test backward-kill-paragraph</vh>
<v t="ekr.20061101121602.127"><vh>work</vh></v>
<v t="ekr.20061101121602.128"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.129"><vh>after sel=7.0,7.0</vh></v>
</v>
<v t="ekr.20070131173932"><vh>@test backward-kill-sentence</vh>
<v t="ekr.20070131173932.1"><vh>work</vh></v>
<v t="ekr.20070131173932.2"><vh>before sel=3.2,3.2</vh></v>
<v t="ekr.20070131173932.3"><vh>after sel=2.23,2.23</vh></v>
</v>
<v t="ekr.20081215084144.2"><vh>@test backward-kill-word</vh>
<v t="ekr.20081215084144.3"><vh>work</vh></v>
<v t="ekr.20081215084144.4"><vh>before sel=3.7,3.7</vh></v>
<v t="ekr.20081215084144.5"><vh>after sel=3.5,3.5</vh></v>
</v>
<v t="ekr.20061101121602.130"><vh>@test beginning-of-buffer</vh>
<v t="ekr.20061101121602.131"><vh>work</vh></v>
<v t="ekr.20061101121602.132"><vh>before sel=5.56,5.56</vh></v>
<v t="ekr.20061101121602.133"><vh>after sel=1.0,1.0</vh></v>
</v>
<v t="ekr.20061101121602.134"><vh>@test beginning-of-buffer-extend-selection</vh>
<v t="ekr.20061101121602.135"><vh>work</vh></v>
<v t="ekr.20061101121602.136"><vh>before sel=3.423,3.423</vh></v>
<v t="ekr.20061101121602.137"><vh>after sel=1.0,3.423</vh></v>
</v>
<v t="ekr.20061101121602.138"><vh>@test beginning-of-line</vh>
<v t="ekr.20061101121602.139"><vh>work</vh></v>
<v t="ekr.20061101121602.140"><vh>before sel=3.10,3.10</vh></v>
<v t="ekr.20061101121602.141"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20061101121602.142"><vh>@test beginning-of-line-extend-selection</vh>
<v t="ekr.20061101121602.143"><vh>work</vh></v>
<v t="ekr.20061101121602.144"><vh>before sel=4.10,4.10</vh></v>
<v t="ekr.20061101121602.145"><vh>after sel=4.0,4.10</vh></v>
</v>
<v t="ekr.20081111084046.1"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20081111084046.2"><vh> Commands C-E</vh>
<v t="ekr.20061101121602.146"><vh>@test capitalize-word</vh>
<v t="ekr.20061101121602.147"><vh>work</vh></v>
<v t="ekr.20061101121602.148"><vh>before sel=3.6,3.6</vh></v>
<v t="ekr.20061101121602.149"><vh>after sel=3.6,3.6</vh></v>
</v>
<v t="ekr.20061101121602.150"><vh>@test center-line</vh>
<v t="ekr.20061101121602.151"><vh>work</vh></v>
<v t="ekr.20061101121602.152"><vh>before sel=3.0,9.0</vh></v>
<v t="ekr.20061101121602.153"><vh>after sel=3.0,9.0</vh></v>
</v>
<v t="ekr.20061101121602.154"><vh>@test center-region</vh>
<v t="ekr.20061101121602.155"><vh>work</vh></v>
<v t="ekr.20061101121602.156"><vh>before sel=1.0,7.0</vh></v>
<v t="ekr.20061101121602.157"><vh>after sel=1.0,7.0</vh></v>
</v>
<v t="ekr.20070217071121.1"><vh>@test clear-rectangle</vh>
<v t="ekr.20070217071121.2"><vh>work</vh></v>
<v t="ekr.20070217071121.3"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.4"><vh>after sel=2.3,5.6</vh></v>
</v>
<v t="ekr.20061101121602.158"><vh>@test clear-selected-text</vh>
<v t="ekr.20061101121602.159"><vh>work</vh></v>
<v t="ekr.20061101121602.160"><vh>before sel=2.4,4.4</vh></v>
<v t="ekr.20061101121602.161"><vh>after sel=2.4,2.4</vh></v>
</v>
<v t="ekr.20070217071121.5"><vh>@test close-rectangle</vh>
<v t="ekr.20070217071121.6"><vh>work</vh></v>
<v t="ekr.20070217071121.7"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.8"><vh>after sel=2.3,5.3</vh></v>
</v>
<v t="ekr.20061101121602.162"><vh>@test count-region</vh>
<v t="ekr.20061101121602.163"><vh>work</vh></v>
<v t="ekr.20061101121602.164"><vh>before sel=2.4,4.8</vh></v>
<v t="ekr.20061101121602.165"><vh>after sel=2.4,4.8</vh></v>
</v>
<v t="ekr.20061101121602.166"><vh>@test delete-char</vh>
<v t="ekr.20061101121602.167"><vh>work</vh></v>
<v t="ekr.20061101121602.168"><vh>before sel=1.5,1.5</vh></v>
<v t="ekr.20061101121602.169"><vh>after sel=1.5,1.5</vh></v>
</v>
<v t="ekr.20071007120750.3"><vh>@test delete-indentation</vh>
<v t="ekr.20071007121115.1"><vh>work</vh></v>
<v t="ekr.20071007121115.2"><vh>before sel=2.8,2.8</vh></v>
<v t="ekr.20071007121115.3"><vh>after sel=2.4,2.4</vh></v>
</v>
<v t="ekr.20070217071121.9"><vh>@test delete-rectangle</vh>
<v t="ekr.20070217071121.10"><vh>work</vh></v>
<v t="ekr.20070217071121.11"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.12"><vh>after sel=2.3,5.3</vh></v>
</v>
<v t="ekr.20070131162935"><vh>@test delete-spaces</vh>
<v t="ekr.20070131162935.1"><vh>work</vh></v>
<v t="ekr.20070131162935.2"><vh>before sel=3.2,3.2</vh></v>
<v t="ekr.20070131162935.3"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20100830113702.5969"><vh>@test delete-word (no selection)</vh>
<v t="ekr.20100830113702.5970"><vh>work</vh></v>
<v t="ekr.20100830113702.5971"><vh>before sel=1.10,1.10</vh></v>
<v t="ekr.20100830113702.5972"><vh>after sel=1.10,1.10</vh></v>
</v>
<v t="ekr.20100830113702.5977"><vh>@test delete-word (selection)</vh>
<v t="ekr.20100830113702.5978"><vh>work</vh></v>
<v t="ekr.20100830113702.5979"><vh>before sel=1.7,1.12</vh></v>
<v t="ekr.20100830113702.5980"><vh>after sel=1.7,1.7</vh></v>
</v>
<v t="ekr.20061101121602.170"><vh>@test do-nothing</vh>
<v t="ekr.20061101121602.171"><vh>work</vh></v>
<v t="ekr.20061101121602.172"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20061101121602.173"><vh>after sel=1.0,1.0</vh></v>
</v>
<v t="ekr.20061101121602.174"><vh>@test downcase-region</vh>
<v t="ekr.20061101121602.175"><vh>work</vh></v>
<v t="ekr.20061101121602.176"><vh>before sel=3.0,4.0</vh></v>
<v t="ekr.20061101121602.177"><vh>after sel=3.0,4.0</vh></v>
</v>
<v t="ekr.20061101121602.178"><vh>@test downcase-word</vh>
<v t="ekr.20061101121602.179"><vh>work</vh></v>
<v t="ekr.20061101121602.180"><vh>before sel=1.4,1.4</vh></v>
<v t="ekr.20061101121602.181"><vh>after sel=1.4,1.4</vh></v>
</v>
<v t="ekr.20061101121602.182"><vh>@test end-of-buffer</vh>
<v t="ekr.20061101121602.183"><vh>work</vh></v>
<v t="ekr.20061101121602.184"><vh>before sel=1.3,1.3</vh></v>
<v t="ekr.20061101121602.185"><vh>after sel=7.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.186"><vh>@test end-of-buffer-extend-selection</vh>
<v t="ekr.20061101121602.187"><vh>work</vh></v>
<v t="ekr.20061101121602.188"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20061101121602.189"><vh>after sel=1.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.190"><vh>@test end-of-line</vh>
<v t="ekr.20061101121602.191"><vh>work</vh></v>
<v t="ekr.20061101121602.192"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20061101121602.193"><vh>after sel=1.10,1.10</vh></v>
</v>
<v t="ekr.20061128082002"><vh>@test end-of-line 2</vh>
<v t="ekr.20061128082002.1"><vh>work</vh></v>
<v t="ekr.20061128082002.2"><vh>before sel=6.0,6.0</vh></v>
<v t="ekr.20061128082002.3"><vh>after sel=6.9,6.9</vh></v>
</v>
<v t="ekr.20061101121602.194"><vh>@test end-of-line-extend-selection</vh>
<v t="ekr.20061101121602.195"><vh>work</vh></v>
<v t="ekr.20061101121602.196"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20061101121602.197"><vh>after sel=3.0,3.10</vh></v>
</v>
<v t="ekr.20061101121602.198"><vh>@test exchange-point-mark</vh>
<v t="ekr.20061101121602.199"><vh>work</vh></v>
<v t="ekr.20061101121602.200"><vh>before sel=1.0,1.10</vh></v>
<v t="ekr.20061101121602.201"><vh>after sel=1.0,1.10</vh></v>
</v>
<v t="ekr.20061101121602.202"><vh>@test extend-to-line</vh>
<v t="ekr.20061101121602.203"><vh>work</vh></v>
<v t="ekr.20061101121602.204"><vh>before sel=3.3,3.3</vh></v>
<v t="ekr.20061101121602.205"><vh>after sel=3.0,3.10</vh></v>
</v>
<v t="ekr.20061101121602.206"><vh>@test extend-to-paragraph</vh>
<v t="ekr.20061101121602.207"><vh>work</vh></v>
<v t="ekr.20061101121602.208"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.209"><vh>after sel=8.0,13.33</vh></v>
</v>
<v t="ekr.20061101121602.210"><vh>@test extend-to-sentence</vh>
<v t="ekr.20061101121602.211"><vh>work</vh></v>
<v t="ekr.20061101121602.212"><vh>before sel=3.5,3.5</vh></v>
<v t="ekr.20061101121602.213"><vh>after sel=1.395,3.142</vh></v>
</v>
<v t="ekr.20061101121602.214"><vh>@test extend-to-word</vh>
<v t="ekr.20061101121602.215"><vh>work</vh></v>
<v t="ekr.20061101121602.216"><vh>before sel=3.10,3.10</vh></v>
<v t="ekr.20061101121602.217"><vh>after sel=3.4,3.12</vh></v>
</v>
<v t="ekr.20081111082931.1"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20070131175538.1"><vh> Commands F-L</vh>
<v t="ekr.20061101121602.218"><vh>@test fill-paragraph</vh>
<v t="ekr.20061101121602.219"><vh>work</vh></v>
<v t="ekr.20061101121602.220"><vh>before sel=3.0,3.7</vh></v>
<v t="ekr.20061101121602.221"><vh>after sel=10.0,10.0</vh></v>
</v>
<v t="ekr.20071007120750.4"><vh>@test fill-region (one paragraph)</vh>
<v t="ekr.20071007121312.1"><vh>work</vh></v>
<v t="ekr.20071007121312.2"><vh>before sel=1.0,9.7</vh></v>
<v t="ekr.20071007121312.3"><vh>after sel=8.0,8.0</vh></v>
</v>
<v t="ekr.20071007124202"><vh>@test fill-region (three paragraphs)</vh>
<v t="ekr.20071007124202.1"><vh>work</vh></v>
<v t="ekr.20071007124202.2"><vh>before sel=1.0,24.78</vh></v>
<v t="ekr.20071007124202.3"><vh>after sel=18.18,18.18</vh></v>
</v>
<v t="ekr.20061101121602.222"><vh>@test forward-char</vh>
<v t="ekr.20061101121602.223"><vh>work</vh></v>
<v t="ekr.20061101121602.224"><vh>before sel=1.2,1.2</vh></v>
<v t="ekr.20061101121602.225"><vh>after sel=1.3,1.3</vh></v>
</v>
<v t="ekr.20061101121602.226"><vh>@test forward-char-extend-selection</vh>
<v t="ekr.20061101121602.227"><vh>work</vh></v>
<v t="ekr.20061101121602.228"><vh>before sel=1.1,1.1</vh></v>
<v t="ekr.20061101121602.229"><vh>after sel=1.1,1.2</vh></v>
</v>
<v t="ekr.20061101121602.230"><vh>@test forward-end-word (end of line)</vh>
<v t="ekr.20061101121602.231"><vh>work</vh></v>
<v t="ekr.20061101121602.232"><vh>before sel=1.395,1.395</vh></v>
<v t="ekr.20061101121602.233"><vh>after sel=3.4,3.4</vh></v>
</v>
<v t="ekr.20061101121602.234"><vh>@test forward-end-word (start of word) </vh>
<v t="ekr.20061101121602.235"><vh>work</vh></v>
<v t="ekr.20061101121602.236"><vh>before sel=1.310,1.310</vh></v>
<v t="ekr.20061101121602.237"><vh>after sel=1.317,1.317</vh></v>
</v>
<v t="ekr.20061101121602.238"><vh>@test forward-end-word-extend-selection</vh>
<v t="ekr.20061101121602.239"><vh>work</vh></v>
<v t="ekr.20061101121602.240"><vh>before sel=3.20,3.20</vh></v>
<v t="ekr.20061101121602.241"><vh>after sel=3.20,3.30</vh></v>
</v>
<v t="ekr.20061101121602.242"><vh>@test forward-paragraph</vh>
<v t="ekr.20061101121602.243"><vh>work</vh></v>
<v t="ekr.20061101121602.244"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.245"><vh>after sel=15.0,15.0</vh></v>
</v>
<v t="ekr.20061101121602.246"><vh>@test forward-paragraph-extend-selection</vh>
<v t="ekr.20061101121602.247"><vh>work</vh></v>
<v t="ekr.20061101121602.248"><vh>before sel=10.0,10.0</vh></v>
<v t="ekr.20061101121602.249"><vh>after sel=10.0,15.0</vh></v>
</v>
<v t="ekr.20061101121602.250"><vh>@test forward-sentence</vh>
<v t="ekr.20061101121602.251"><vh>work</vh></v>
<v t="ekr.20061101121602.252"><vh>before sel=3.17,3.17</vh></v>
<v t="ekr.20061101121602.253"><vh>after sel=3.142,3.142</vh></v>
</v>
<v t="ekr.20061101121602.254"><vh>@test forward-sentence-extend-selection</vh>
<v t="ekr.20061101121602.255"><vh>work</vh></v>
<v t="ekr.20061101121602.256"><vh>before sel=1.264,1.264</vh></v>
<v t="ekr.20061101121602.257"><vh>after sel=1.264,1.395</vh></v>
</v>
<v t="ekr.20061101121602.258"><vh>@test forward-word</vh>
<v t="ekr.20061101121602.259"><vh>work</vh></v>
<v t="ekr.20061101121602.260"><vh>before sel=1.261,1.261</vh></v>
<v t="ekr.20061101121602.261"><vh>after sel=1.273,1.273</vh></v>
</v>
<v t="ekr.20061101121602.262"><vh>@test forward-word-extend-selection</vh>
<v t="ekr.20061101121602.263"><vh>work</vh></v>
<v t="ekr.20061101121602.264"><vh>before sel=1.395,1.395</vh></v>
<v t="ekr.20061101121602.265"><vh>after sel=1.395,3.0</vh></v>
</v>
<v t="ekr.20070305095401"><vh>@test goNext/PrevVisitedNode</vh></v>
<v t="ekr.20080904095020.1"><vh>goto-line-number tests</vh>
<v t="ekr.20080905112230.3"><vh>goto-line-number tests: original files</vh>
<v t="ekr.20080904084223.1"><vh>@auto unittest/at-auto-line-number-test.py</vh></v>
<v t="ekr.20080904102243.2"><vh>@file unittest/at-file-line-number-test.py</vh>
<v t="ekr.20080904102243.3"><vh>at-file-child</vh></v>
</v>
<v t="ekr.20080905130723.3"><vh>@thin unittest/at-thin-line-number-test.py</vh></v>
<v t="ekr.20080907122804.1"><vh>@shadow unittest/at-shadow-line-number-test.py</vh></v>
<v t="ekr.20080907123324.2"><vh>@nosent unittest/at-nosent-line-number-test.py</vh>
<v t="ekr.20080907123324.3"><vh>at-nosent-child</vh></v>
</v>
</v>
<v t="ekr.20080905112230.4"><vh>goto-line-number tests: clones</vh>
<v t="ekr.20080904102243.3"></v>
<v t="ekr.20080905130723.4"><vh>at-thin-child</vh></v>
<v t="ekr.20080907123324.3"></v>
</v>
<v t="ekr.20080905113550.2"><vh>Tests with @auto as the root</vh>
<v t="ekr.20080904110148.1"><vh>Startup</vh></v>
<v t="ekr.20080904110148.4"><vh>Docs</vh></v>
<v t="ekr.20080904110148.5"><vh>Scripts</vh></v>
<v t="ekr.20080904113003.2"><vh> Test files</vh></v>
</v>
<v t="ekr.20080905113550.3"><vh>Tests with @file as the root</vh>
<v t="ekr.20080904120258.6"><vh>Startup</vh></v>
<v t="ekr.20080905130723.1"><vh>Docs</vh></v>
</v>
<v t="ekr.20080907122804.2"><vh>Tests with @shadow as the root</vh>
<v t="ekr.20080907122804.3"><vh>Startup</vh></v>
</v>
<v t="ekr.20080907123324.4"><vh>Tests with @nosent as the root</vh>
<v t="ekr.20080907123324.5"><vh>Startup</vh></v>
</v>
<v t="ekr.20080905113550.4"><vh>General tests</vh>
<v t="ekr.20080905165432.1"><vh>Startup</vh></v>
<v t="ekr.20080905165432.3"><vh>Docs</vh></v>
<v t="ekr.20080904120258.2"><vh>Scripts</vh></v>
<v t="ekr.20080904120258.3"><vh>@test goto_showResults not found</vh></v>
</v>
<v t="ekr.20081111084046.6"><vh>@test zz restore the screen</vh></v>
<v t="ekr.20100216142240.5371"><vh>@test goto-global-line with @auto</vh>
<v t="ekr.20100216142240.5372"><vh>@auto ../test/at-auto-unit-test.py</vh></v>
</v>
</v>
<v t="ekr.20100212104817.5351"><vh>@test help-for-command</vh></v>
<v t="ekr.20061101121602.266"><vh>@test indent-relative</vh>
<v t="ekr.20061101121602.267"><vh>work</vh></v>
<v t="ekr.20061101121602.268"><vh>before sel=5.0,5.0</vh></v>
<v t="ekr.20061101121602.269"><vh>after sel=5.8,5.8</vh></v>
</v>
<v t="ekr.20061101121602.270"><vh>@test indent-rigidly</vh>
<v t="ekr.20061101121602.271"><vh>work</vh></v>
<v t="ekr.20061101121602.272"><vh>before sel=2.0,5.0</vh></v>
<v t="ekr.20061101121602.273"><vh>after sel=2.0,5.1</vh></v>
</v>
<v t="ekr.20071007120750.5"><vh>@test indent-to-comment-column</vh>
<v t="ekr.20071007121312.5"><vh>work</vh></v>
<v t="ekr.20071007121312.6"><vh>before sel=2.0,2.0</vh></v>
<v t="ekr.20071007121312.7"><vh>after sel=2.4,2.4</vh></v>
</v>
<v t="ekr.20061101121602.274"><vh>@test insert-newline</vh>
<v t="ekr.20061101121602.275"><vh>work</vh></v>
<v t="ekr.20061101121602.276"><vh>before sel=1.8,1.8</vh></v>
<v t="ekr.20061101121602.277"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20061101121602.278"><vh>@test insert-parentheses</vh>
<v t="ekr.20061101121602.279"><vh>work</vh></v>
<v t="ekr.20061101121602.280"><vh>before sel=1.5,1.5</vh></v>
<v t="ekr.20061101121602.281"><vh>after sel=1.6,1.6</vh></v>
</v>
<v t="ekr.20061128090338"><vh>@test kill-line end-1</vh>
<v t="ekr.20061128090338.1"><vh>work</vh></v>
<v t="ekr.20061128090338.2"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20061128090338.3"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20061128090441"><vh>@test kill-line end-2</vh>
<v t="ekr.20061128090441.1"><vh>work</vh></v>
<v t="ekr.20061128090441.3"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20061128090441.2"><vh>after sel=2.6,2.6</vh></v>
</v>
<v t="ekr.20061128090021"><vh>@test kill-line middle-1</vh>
<v t="ekr.20061128090021.1"><vh>work</vh></v>
<v t="ekr.20061128090021.2"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20061128090021.3"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20061128090147"><vh>@test kill-line middle-2</vh>
<v t="ekr.20061128090147.1"><vh>work</vh></v>
<v t="ekr.20061128090147.2"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20061128090147.3"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20061101121602.282"><vh>@test kill-paragraph</vh>
<v t="ekr.20061101121602.283"><vh>work</vh></v>
<v t="ekr.20061101121602.285"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.284"><vh>after sel=8.0,8.0</vh></v>
</v>
<v t="ekr.20070217071121.17"><vh>@test kill-rectangle</vh>
<v t="ekr.20070217071121.18"><vh>work</vh></v>
<v t="ekr.20070217071121.19"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.20"><vh>after sel=5.3,5.3</vh></v>
</v>
<v t="ekr.20070131172706"><vh>@test kill-sentence</vh>
<v t="ekr.20070131172706.1"><vh>work</vh></v>
<v t="ekr.20070131172706.2"><vh>before sel=2.2,2.2</vh></v>
<v t="ekr.20070131172706.3"><vh>after sel=1.27,1.27</vh></v>
</v>
<v t="ekr.20081215084144.7"><vh>@test kill-word</vh>
<v t="ekr.20081215084144.8"><vh>work</vh></v>
<v t="ekr.20081215084144.9"><vh>before sel=2.6,2.6</vh></v>
<v t="ekr.20081215084144.10"><vh>after sel=2.7,2.7</vh></v>
</v>
<v t="ekr.20081111084046.3"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20070131175646"><vh> Commands M-Z</vh>
<v t="ekr.20070131171218.1"><vh>@@test zap-to-chararacter</vh>
<v t="ekr.20070131171218.2"><vh>work</vh></v>
</v>
<v t="ekr.20061101121602.286"><vh>@test move-lines-down</vh>
<v t="ekr.20061101121602.287"><vh>work</vh></v>
<v t="ekr.20061101121602.288"><vh>before sel=3.3,4.3</vh></v>
<v t="ekr.20061101121602.289"><vh>after sel=4.0,5.0</vh></v>
</v>
<v t="ekr.20061101121602.290"><vh>@test move-lines-up </vh>
<v t="ekr.20061101121602.291"><vh>work</vh></v>
<v t="ekr.20061101121602.292"><vh>before sel=2.2,2.2</vh></v>
<v t="ekr.20061101121602.293"><vh>after sel=1.0,1.0</vh></v>
</v>
<v t="ekr.20061101121602.294"><vh>@test move-past-close</vh>
<v t="ekr.20061101121602.295"><vh>work</vh></v>
<v t="ekr.20061101121602.296"><vh>before sel=1.10,1.10</vh></v>
<v t="ekr.20061101121602.297"><vh>after sel=1.12,1.12</vh></v>
</v>
<v t="ekr.20061101121602.298"><vh>@test move-past-close-extend-selection</vh>
<v t="ekr.20061101121602.299"><vh>work</vh></v>
<v t="ekr.20061101121602.300"><vh>before sel=3.7,3.7</vh></v>
<v t="ekr.20061101121602.301"><vh>after sel=3.7,3.11</vh></v>
</v>
<v t="ekr.20061101121602.302"><vh>@test newline-and-indent</vh>
<v t="ekr.20061101121602.303"><vh>work</vh></v>
<v t="ekr.20061101121602.304"><vh>before sel=2.6,2.6</vh></v>
<v t="ekr.20061101121602.305"><vh>after sel=3.4,3.4</vh></v>
</v>
<v t="ekr.20070315065720"><vh>@test next-line</vh>
<v t="ekr.20070315065720.1"><vh>work</vh></v>
<v t="ekr.20070315065720.2"><vh>before sel=1.1,1.1</vh></v>
<v t="ekr.20070315065720.3"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20070217071121.13"><vh>@test open-rectangle</vh>
<v t="ekr.20070217071121.14"><vh>work</vh></v>
<v t="ekr.20070217071121.15"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.16"><vh>after sel=2.3,5.6</vh></v>
</v>
<v t="ekr.20070315065849"><vh>@test previous-line</vh>
<v t="ekr.20070315065849.1"><vh>work</vh></v>
<v t="ekr.20070315065849.2"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20070315065849.3"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20061101121602.306"><vh>@test remove-blank-lines </vh>
<v t="ekr.20061101121602.307"><vh>work</vh></v>
<v t="ekr.20061101121602.308"><vh>before sel=1.0,9.0</vh></v>
<v t="ekr.20061101121602.309"><vh>after sel=1.0,6.9</vh></v>
</v>
<v t="ekr.20061101121602.310"><vh>@test remove-space-from-lines</vh>
<v t="ekr.20061101121602.311"><vh>work</vh></v>
<v t="ekr.20061101121602.312"><vh>before sel=1.0,9.0</vh></v>
<v t="ekr.20061101121602.313"><vh>after sel=1.0,9.0</vh></v>
</v>
<v t="ekr.20061101121602.314"><vh>@test remove-tab-from-lines</vh>
<v t="ekr.20061101121602.315"><vh>work</vh></v>
<v t="ekr.20061101121602.316"><vh>before sel=1.0,7.0</vh></v>
<v t="ekr.20061101121602.317"><vh>after sel=1.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.318"><vh>@test reverse-region</vh>
<v t="ekr.20061101121602.319"><vh>work</vh></v>
<v t="ekr.20061101121602.320"><vh>before sel=1.0,7.0</vh></v>
<v t="ekr.20061101121602.321"><vh>after sel=7.10,7.10</vh></v>
</v>
<v t="ekr.20071113081247"><vh>@test reverse-sort-lines</vh>
<v t="ekr.20071113081247.1"><vh>work</vh></v>
<v t="ekr.20071113081247.2"><vh>before sel=1.0,5.1</vh></v>
<v t="ekr.20071113081247.3"><vh>after sel=1.0,5.1</vh></v>
</v>
<v t="ekr.20071113082531"><vh>@test reverse-sort-lines-ignoring-case</vh>
<v t="ekr.20071113082531.1"><vh>work</vh></v>
<v t="ekr.20071113082531.2"><vh>before sel=1.0,6.1</vh></v>
<v t="ekr.20071113082531.3"><vh>after sel=1.0,6.1</vh></v>
</v>
<v t="ekr.20071113145804.4"><vh>@test selfInsertCommand-1</vh></v>
<v t="ekr.20071113145804.5"><vh>@test selfInsertCommand-2 (replacing tabs)</vh></v>
<v t="ekr.20071007120750.6"><vh>@test set-fill-prefix</vh></v>
<v t="ekr.20061101121602.322"><vh>@test sort-columns</vh>
<v t="ekr.20061101121602.323"><vh>work</vh></v>
<v t="ekr.20061101121602.324"><vh>before sel=1.0,6.2</vh></v>
<v t="ekr.20061101121602.325"><vh>after sel=1.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.326"><vh>@test sort-lines</vh>
<v t="ekr.20061101121602.327"><vh>work</vh></v>
<v t="ekr.20061101121602.328"><vh>before sel=2.0,5.6</vh></v>
<v t="ekr.20061101121602.329"><vh>after sel=2.0,5.6</vh></v>
</v>
<v t="ekr.20071113081247.8"><vh>@test sort-lines-ignoring-case</vh>
<v t="ekr.20071113081247.9"><vh>work</vh></v>
<v t="ekr.20071113081247.10"><vh>before sel=1.0,5.1</vh></v>
<v t="ekr.20071113081247.11"><vh>after sel=1.0,5.1</vh></v>
</v>
<v t="ekr.20100212104817.5346"><vh>@test sort-recent-files (new)</vh></v>
<v t="ekr.20100212104817.5347"><vh>@test sort-siblings (new)</vh>
<v t="ekr.20100212104817.5348"><vh>b</vh></v>
<v t="ekr.20100212104817.5349"><vh>a</vh></v>
<v t="ekr.20100212104817.5350"><vh>c</vh></v>
</v>
<v t="ekr.20061101121602.330"><vh>@test split-line</vh>
<v t="ekr.20061101121602.331"><vh>work</vh></v>
<v t="ekr.20061101121602.332"><vh>before sel=1.5,1.5</vh></v>
<v t="ekr.20061101121602.333"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20070217071121.21"><vh>@test string-rectangle</vh>
<v t="ekr.20070217071121.22"><vh>work</vh></v>
<v t="ekr.20070217071121.23"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.24"><vh>after sel=2.3,5.8</vh></v>
</v>
<v t="ekr.20061101121602.334"><vh>@test tabify</vh>
<v t="ekr.20061101121602.335"><vh>work</vh></v>
<v t="ekr.20061101121602.336"><vh>before sel=1.0,7.0</vh></v>
<v t="ekr.20061101121602.337"><vh>after sel=7.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.338"><vh>@test transpose-chars</vh>
<v t="ekr.20061101121602.339"><vh>work</vh></v>
<v t="ekr.20061101121602.340"><vh>before sel=1.2,1.2</vh></v>
<v t="ekr.20061101121602.341"><vh>after sel=1.2,1.2</vh></v>
</v>
<v t="ekr.20061101121602.342"><vh>@test transpose-lines</vh>
<v t="ekr.20061101121602.343"><vh>work</vh></v>
<v t="ekr.20061101121602.344"><vh>before sel=2.2,2.2</vh></v>
<v t="ekr.20061101121602.345"><vh>after sel=2.10,2.10</vh></v>
</v>
<v t="ekr.20061101121602.346"><vh>@test untabify</vh>
<v t="ekr.20061101121602.347"><vh>work</vh></v>
<v t="ekr.20061101121602.348"><vh>before sel=1.0,7.0</vh></v>
<v t="ekr.20061101121602.349"><vh>after sel=7.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.350"><vh>@test upcase-region</vh>
<v t="ekr.20061101121602.351"><vh>work</vh></v>
<v t="ekr.20061101121602.352"><vh>before sel=3.0,4.0</vh></v>
<v t="ekr.20061101121602.353"><vh>after sel=3.0,4.0</vh></v>
</v>
<v t="ekr.20061101121602.354"><vh>@test upcase-word</vh>
<v t="ekr.20061101121602.355"><vh>work</vh></v>
<v t="ekr.20061101121602.356"><vh>before sel=3.7,3.7</vh></v>
<v t="ekr.20061101121602.357"><vh>after sel=3.7,3.7</vh></v>
</v>
<v t="ekr.20070217071121.25"><vh>@test yank-rectangle</vh>
<v t="ekr.20070217071121.26"><vh>work</vh></v>
<v t="ekr.20070217071121.28"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.27"><vh>after sel=2.3,5.6</vh></v>
</v>
<v t="ekr.20081111084046.4"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20061104172236.1"><vh> Function tests</vh>
<v t="ekr.20100902074747.5970"><vh>@test addAbbrevHelper</vh></v>
<v t="ekr.20061104172236.3"><vh>@test capitalizeHelper</vh></v>
<v t="ekr.20061104172236.5"><vh>@test extendHelper</vh></v>
<v t="ekr.20080408094623.1"><vh>@test findWord</vh></v>
<v t="ekr.20061104172236.2"><vh>@test findWordInLine</vh></v>
<v t="ekr.20071113145804.15"><vh>@test helpForMinibuffer</vh></v>
<v t="ekr.20061104172236.6"><vh>@test moveToHelper</vh></v>
<v t="ekr.20061110094226"><vh>@test moveUpOrDownHelper</vh></v>
<v t="ekr.20061104172236.7"><vh>@test scrollHelper</vh></v>
<v t="ekr.20061104172236.4"><vh>@test setMoveCol</vh></v>
</v>
<v t="ekr.20051107115231"><vh> Typing</vh>
<v t="ekr.20051122095426"><vh>Doctests</vh></v>
<v t="ekr.20051216171321"><vh>General</vh></v>
<v t="ekr.20051107115231.13"><vh>Plugins</vh>
<v t="ekr.20090128184952.3"><vh>Test headline abc</vh></v>
<v t="ekr.20060208072415"><vh>@test &lt;Delete&gt; key sticks in body</vh></v>
<v t="ekr.20051125170139"><vh>@test &lt;Delete&gt; key sticks in headline</vh></v>
<v t="ekr.20051109091333"><vh>@test deleting the last body character text redraws the screen (and icon)</vh></v>
<v t="ekr.20051107115231.15"><vh>@test editLabel selects entire headline</vh></v>
<v t="ekr.20051120110335"><vh>@test inserting a new node can be undone and redone</vh></v>
<v t="ekr.20051125155134"><vh>@test inserting a new node draws the screen exactly once</vh></v>
<v t="ekr.20051107115231.18"><vh>@test paste and undo in headline - at end</vh></v>
<v t="ekr.20051107115231.20"><vh>@test paste and undo in headline - with selection</vh></v>
<v t="ekr.20051107115231.16"><vh>@test paste at end of headline</vh></v>
<v t="ekr.20060208072307"><vh>@test paste from menu into body sticks</vh></v>
<v t="ekr.20060208072331"><vh>@test paste from menu into headline sticks</vh></v>
<v t="ekr.20051107115231.24"><vh>@test paste from menu to body recolors the body</vh></v>
<v t="ekr.20051107115231.14"><vh>@test return ends editing of headline</vh></v>
<v t="ekr.20051107115231.28"><vh>@test selecting new node retains paste in headline</vh></v>
<v t="ekr.20051107115231.21"><vh>@test selecting new node retains typing in headline</vh></v>
<v t="ekr.20051107115231.17"><vh>@test typing and undo in headline - at end</vh></v>
<v t="ekr.20060208072358"><vh>@test typing in empty body text redraws the screen (and icon)</vh></v>
<v t="ekr.20051107115231.25"><vh>@test typing in headline recomputes width</vh></v>
<v t="ekr.20051109091731"><vh>@test typing in non-empty body text does not redraw the screen</vh></v>
<v t="ekr.20051120115046"><vh>@test undoing insert node restores previous node's body text</vh></v>
<v t="ekr.20060131102450"><vh>print end of typing and undo tests</vh></v>
</v>
<v t="ekr.20051109143831"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20070306091949"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20061001114637"><vh>leoFileCommands</vh>
<v t="ekr.20100206165505.5386"><vh>@@test fc.handleNodeConflicts</vh></v>
<v t="ekr.20100225094004.5405"><vh>@test loading .leo file with @file nodes</vh></v>
<v t="ekr.20061001124008"><vh>@@test minimal test of putTnodeList</vh>
<v t="ekr.20061001124008.1"><vh>child</vh>
<v t="ekr.20061001124008.2"><vh>grandchild</vh></v>
</v>
</v>
<v t="ekr.20100204153116.5369"><vh>@@test raw file copy</vh></v>
<v t="ekr.20080806211453.5"><vh>@@test round-trip-uAs for @shadow</vh>
<v t="ekr.20080806211453.1"><vh>@@shadow uA_test_shadow_file.py</vh>
<v t="ekr.20080822160527.1"><vh>uA_test_shadow_file declarations</vh></v>
</v>
</v>
<v t="ekr.20080806095923.2"><vh>@@test round-trip-uAs for @thin</vh>
<v t="ekr.20080806084924.2"><vh>@@thin uA_test_file.py</vh>
<v t="ekr.20080806084924.3"><vh>child1</vh>
<v t="ekr.20080806084924.4"><vh>grandChild1</vh>
<v t="ekr.20080806084924.5"><vh>greatGrandChild1</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20071113145804.18"><vh>@test fc.deleteFileWithMessage</vh></v>
<v t="ekr.20080806072412.1"><vh>@test fc.resolveArchivedPosition</vh>
<v t="ekr.20080806072412.2"><vh>first child</vh></v>
<v t="ekr.20080806072412.3"><vh>second child</vh>
<v t="ekr.20080806072412.4"><vh>grandChild1</vh>
<v t="ekr.20080806080425.1"><vh>greatGrandChild11</vh></v>
<v t="ekr.20080806080425.2"><vh>greatGrandChild12</vh></v>
</v>
<v t="ekr.20080806072412.5"><vh>grandChild 2</vh>
<v t="ekr.20080806080425.3"><vh>greatGrandChild21</vh></v>
<v t="ekr.20080806080425.4"><vh>greatGrandChild22</vh></v>
</v>
</v>
</v>
<v t="ekr.20080805105541.1"><vh>@test p.archivedPosition</vh>
<v t="ekr.20080805122315.1"><vh>first child</vh></v>
<v t="ekr.20080805122315.2"><vh>second child</vh>
<v t="ekr.20080805122315.3"><vh>grandChild</vh></v>
<v t="ekr.20080805122315.4"><vh>grandChild 2</vh></v>
</v>
</v>
<v t="ekr.20080805104144.1"><vh>@test putDescendentVnodeUas</vh>
<v t="ekr.20080805104144.2"><vh>child</vh>
<v t="ekr.20080805104144.3"><vh>grandChild</vh></v>
</v>
</v>
<v t="ekr.20061001114236"><vh>@test putUa</vh></v>
<v t="ekr.20051107115231.9"><vh>@test Select a node when file is first loaded</vh></v>
<v t="ekr.20090507084947.5152"><vh>@test t.fileIndex remains the same</vh></v>
<v t="ekr.20061008162912"><vh>@test write .leo file with @ignore node</vh>
<v t="ekr.20061008162912.1"><vh>child</vh></v>
</v>
<v t="ekr.20071113202045"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20071113193527"><vh>leoFind</vh>
<v t="ekr.20051107115231.29"><vh>@@test Find keeps focus in body &amp; shows selected text</vh></v>
<v t="ekr.20060130151716.3"><vh>@test minbuffer find commands</vh></v>
<v t="ekr.20060130151716.2"><vh>@test set find mode commands</vh></v>
<v t="ekr.20060130151716.4"><vh>@test show-find-options</vh></v>
<v t="ekr.20060130151716.1"><vh>@test togle find options commands</vh></v>
<v t="ekr.20071113202153"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20071113194424"><vh>leoFrame</vh>
<v t="ekr.20060912091510.1"><vh>@@test add-editor &amp; delete-editor</vh></v>
<v t="ekr.20090608174319.4791"><vh>@@test delete-editor</vh></v>
<v t="ekr.20061104172236.22"><vh>@test c.frame.pasteText</vh></v>
<v t="ekr.20071113145804.33"><vh>@test c.frame.pasteText 2</vh></v>
<v t="ekr.20061106201509.6"><vh>@test leoBody.getInsertLines</vh></v>
<v t="ekr.20061106201509.7"><vh>@test leoBody.getSelectionAreas</vh></v>
<v t="ekr.20071113145804.32"><vh>@test leoBody.getSelectionAreas &amp; test</vh></v>
<v t="ekr.20100131180007.5359"><vh>@test OnIconDoubleClick</vh></v>
<v t="ekr.20061104172236.23"><vh>@test tkBody.onClick</vh></v>
<v t="ekr.20071113202153.1"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20071113194033.3"><vh>leoGlobals</vh>
<v t="ekr.20100131180007.5398"><vh>@test g.adjustTripleString</vh></v>
<v t="ekr.20040917062206"><vh>@test g.cantImport returns None</vh></v>
<v t="ekr.20060921115303"><vh>@test g.checkVersion</vh></v>
<v t="ekr.20071113143844.9"><vh>@test g.CheckVersionToInt</vh></v>
<v t="ekr.20100131180007.5428"><vh>@test g.comment_delims_from_extension</vh></v>
<v t="ekr.20071113145804.26"><vh>@test g.convertPythonIndexToRowCol</vh></v>
<v t="ekr.20071113145804.27"><vh>@test g.convertRowColToPythonIndex</vh></v>
<v t="ekr.20071113145804.21"><vh>@test g.create_temp_file</vh></v>
<v t="ekr.20100131180007.5403"><vh>@test g.ensureLeadingNewlines</vh></v>
<v t="ekr.20100131180007.5404"><vh>@test g.ensureTrailingNewlines</vh></v>
<v t="ekr.20071113145804.22"><vh>@test g.es_trace</vh></v>
<v t="ekr.20100131180007.5422"><vh>@test g.findDefaultDirectory</vh></v>
<v t="ekr.20071113090055.5"><vh>@test g.get_directives_dict</vh></v>
<v t="ekr.20100131180007.5434"><vh>@test g.get_directives_dict 2</vh></v>
<v t="ekr.20100131180007.5424"><vh>@test g.getAbsPathFromNode</vh></v>
<v t="ekr.20061104172236.18"><vh>@test g.getLine</vh></v>
<v t="ekr.20100131180007.5423"><vh>@test g.getPathFromDirectives</vh></v>
<v t="ekr.20071113145804.28"><vh>@test g.getScript strips crlf</vh></v>
<v t="ekr.20061104172236.11"><vh>@test g.getWord</vh></v>
<v t="ekr.20100131180007.5417"><vh>@test g.openLeoOrZipFile</vh></v>
<v t="ekr.20071113145804.19"><vh>@test g.pdb</vh></v>
<v t="ekr.20100212112056.5361"><vh>@test g.printGcAll</vh></v>
<v t="ekr.20100131180007.5396"><vh>@test g.removeBlankLines</vh></v>
<v t="ekr.20071113145804.29"><vh>@test g.removeExtraLws</vh></v>
<v t="ekr.20100131180007.5395"><vh>@test g.removeLeadingBlankLines</vh></v>
<v t="ekr.20100131180007.5402"><vh>@test g.removeTrailing</vh></v>
<v t="ekr.20080917151620.13"><vh>@test g.scanAtHeaderDirectives header</vh></v>
<v t="ekr.20100131180007.5435"><vh>@test g.scanAtHeaderDirectives header</vh></v>
<v t="ekr.20080917151620.14"><vh>@test g.scanAtHeaderDirectives noheader</vh></v>
<v t="ekr.20080917151620.15"><vh>@test g.scanAtLineendingDirectives cr</vh></v>
<v t="ekr.20080917151620.16"><vh>@test g.scanAtLineendingDirectives crlf</vh></v>
<v t="ekr.20080917151620.17"><vh>@test g.scanAtLineendingDirectives lf</vh></v>
<v t="ekr.20080917151620.18"><vh>@test g.scanAtLineendingDirectives nl</vh></v>
<v t="ekr.20080917151620.19"><vh>@test g.scanAtLineendingDirectives platform</vh></v>
<v t="ekr.20100131180007.5442"><vh>@test g.scanAtPagewidthDirectives -40</vh></v>
<v t="ekr.20080917151620.21"><vh>@test g.scanAtPagewidthDirectives 40</vh></v>
<v t="ekr.20080917151620.22"><vh>@test g.scanAtPathDirectives ../test/unittest/at-path-test1.py</vh>
<v t="ekr.20080917151620.23"><vh>@thin ../test/unittest/at-path-test1.py</vh></v>
</v>
<v t="ekr.20080917151620.27"><vh>@test g.scanAtPathDirectives @path ../test @path unittest @thin at-path-test3.py</vh>
<v t="ekr.20080917151620.28"><vh>@path ../test</vh>
<v t="ekr.20080917151620.29"><vh>@path unittest</vh>
<v t="ekr.20080917151620.30"><vh>@thin at-path-test3.py</vh></v>
</v>
</v>
</v>
<v t="ekr.20080917151620.24"><vh>@test g.scanAtPathDirectives @path ../test/unittest @thin at-path-test2.py</vh>
<v t="ekr.20080917151620.25"><vh>@path ../test/unittest</vh>
<v t="ekr.20080917151620.26"><vh>@thin at-path-test2.py</vh></v>
</v>
</v>
<v t="ekr.20080917151620.31"><vh>@test g.scanAtTabwidthDirectives +6</vh></v>
<v t="ekr.20080917151620.32"><vh>@test g.scanAtTabwidthDirectives -6</vh></v>
<v t="ekr.20080917151620.33"><vh>@test g.scanAtWrapDirectives nowrap</vh></v>
<v t="ekr.20080917151620.34"><vh>@test g.scanAtWrapDirectives wrap (with @wrap)</vh></v>
<v t="ekr.20080917151620.35"><vh>@test g.scanAtWrapDirectives wrap (without @nowrap)</vh></v>
<v t="ekr.20100131180007.5426"><vh>@test g.set_delims_from_language</vh></v>
<v t="ekr.20100131180007.5425"><vh>@test g.set_delims_from_string</vh></v>
<v t="ekr.20100131180007.5421"><vh>@test g.setDefaultDirectory</vh></v>
<v t="sps.20100609234650.16094"><vh>@test g.skip_blank_lines</vh></v>
<v t="ekr.20061104172236.15"><vh>@test g.skip_line</vh></v>
<v t="ekr.20061104172236.16"><vh>@test g.skip_to_end_of_line</vh></v>
<v t="ekr.20061104172236.17"><vh>@test g.skip_to_start_of_line</vh></v>
<v t="ekr.20100131180007.5427"><vh>@test g.stripPathCruft</vh></v>
<v t="ekr.20050105084757.1"><vh>@test g.utils_remove</vh></v>
<v t="ekr.20050105091547"><vh>@test g.utils_rename</vh></v>
<v t="ekr.20100131180007.5429"><vh>@test g.warnOnReadOnlyFile</vh></v>
<v t="ekr.20050208135429"><vh>@test pre-definition of g in scripts</vh></v>
<v t="ekr.20071113202153.2"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20100131171342.5599"><vh>leoGui</vh>
<v t="ekr.20100131171342.5600"><vh>@test w.toGui/PythonIndex</vh></v>
<v t="ekr.20100131171342.5601"><vh>@test w.toGuiIndex (test2)</vh></v>
<v t="ekr.20100131171342.5602"><vh>@test leoTextWidget</vh></v>
<v t="ekr.20100131171342.5603"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20090529141856.4682"><vh>leoImport</vh>
<v t="ekr.20090529141856.4684"><vh> Export tests</vh>
<v t="ekr.20090529141856.4685"><vh>@suite Export tests</vh></v>
<v t="ekr.20090529141856.4686"><vh>exportTests</vh>
<v t="ekr.20090529141856.4687"><vh>tempNode</vh></v>
<v t="ekr.20090529141856.4688"><vh>exportHeadlines</vh>
<v t="ekr.20090529141856.4689"><vh>dialog</vh></v>
</v>
<v t="ekr.20090529141856.4690"><vh>flattenOutline</vh>
<v t="ekr.20090529141856.4691"><vh>dialog</vh></v>
</v>
<v t="ekr.20090529141856.4692"><vh>weave</vh>
<v t="ekr.20090529141856.4693"><vh>dialog</vh></v>
</v>
<v t="ekr.20090529141856.4694"><vh>outlineToNoweb</vh>
<v t="ekr.20090529141856.4695"><vh>dialog</vh></v>
</v>
<v t="ekr.20090529141856.4696"><vh>outlineToCWEB</vh>
<v t="ekr.20090529141856.4697"><vh>dialog</vh></v>
</v>
</v>
</v>
<v t="ekr.20090529141856.4698"><vh> Import tests</vh>
<v t="ekr.20090529141856.4699"><vh>@suite Import tests</vh></v>
<v t="ekr.20090529141856.4700"><vh>importTests</vh>
<v t="ekr.20090529141856.4701"><vh>tempNode</vh></v>
<v t="ekr.20090529141856.4702"><vh>importAtRoot</vh>
<v t="ekr.20090529141856.4703"><vh>dialog</vh></v>
</v>
<v t="ekr.20090529141856.4704"><vh>importDerivedFile</vh>
<v t="ekr.20090529141856.4705"><vh>dialog</vh></v>
</v>
<v t="ekr.20090529141856.4706"><vh>importNowebFiles</vh>
<v t="ekr.20090529141856.4707"><vh>dialog</vh></v>
</v>
<v t="ekr.20090529141856.4708"><vh>importFlattenedOutline</vh>
<v t="ekr.20090529141856.4709"><vh>dialog</vh></v>
</v>
<v t="ekr.20090529141856.4710"><vh>importCWEBFiles</vh>
<v t="ekr.20090529141856.4711"><vh>dialog</vh></v>
</v>
<v t="ekr.20090529141856.4712"><vh>removeSentinels</vh>
<v t="ekr.20090529141856.4713"><vh>dialog</vh></v>
</v>
<v t="ekr.20090529141856.4714"><vh>importAtFile</vh>
<v t="ekr.20090529141856.4715"><vh>dialog</vh></v>
</v>
</v>
</v>
<v t="ekr.20090529141856.4790"><vh> Test files</vh></v>
<v t="ekr.20090529141856.4716"><vh> Tests of @auto</vh>
<v t="ekr.20090529141856.4782"><vh>@test checkTrialWrite</vh></v>
<v t="ekr.20090529141856.4783"><vh>@test collapse-all</vh></v>
<v t="ekr.20090529141856.4717"><vh>C tests</vh>
<v t="ekr.20090529141856.4718"><vh>@test c class 1</vh></v>
<v t="ekr.20090529141856.4719"><vh>@test c class--underindented line</vh></v>
<v t="ekr.20090529141856.4720"><vh>@test defaultImporter</vh></v>
<v t="ekr.20090529141856.4721"><vh>@test c test--comment follows arg list</vh></v>
<v t="ekr.20090529141856.4722"><vh>@test c test--comment follows block delim</vh></v>
<v t="ekr.20090529141856.4723"><vh>@test c test--intermixed blanks and tabs</vh></v>
<v t="ekr.20090529141856.4724"><vh>@test c old-style decl 1</vh></v>
<v t="ekr.20090529141856.4725"><vh>@test c old-style decl 2</vh></v>
<v t="ekr.20090529141856.4726"><vh>@test c extern</vh></v>
</v>
<v t="ekr.20090529141856.4727"><vh>c# tests</vh>
<v t="ekr.20090529141856.4728"><vh>@test c# namespace indent</vh></v>
<v t="ekr.20090529141856.4729"><vh>@test c# namespace no indent</vh></v>
<v t="ekr.20090529141856.4730"><vh>@@test c# ref card</vh></v>
</v>
<v t="ekr.20090529141856.4731"><vh>elisp tests</vh>
<v t="ekr.20090529141856.4732"><vh>@test elisp functions</vh></v>
<v t="ekr.20090529141856.4733"><vh>@test elisp 2</vh></v>
</v>
<v t="ekr.20100803234640.5804"><vh>ini tests</vh>
<v t="ekr.20100803234640.5805"><vh>@test ini-test-1</vh></v>
</v>
<v t="ekr.20090529141856.4766"><vh>Java tests</vh>
<v t="ekr.20090529141856.4767"><vh>@test java interface test1</vh></v>
<v t="ekr.20090529141856.4768"><vh>@test java interface test2</vh></v>
<v t="ekr.20090529141856.4769"><vh>@@test constants.java</vh></v>
<v t="ekr.20090529141856.4770"><vh>@test from AdminPermission.java</vh></v>
<v t="ekr.20090529141856.4771"><vh>@@test AdminPermission.java</vh></v>
<v t="ekr.20090529141856.4772"><vh>Test BundleException.java</vh>
<v t="ekr.20090529141856.4773"><vh>@test from BundleException.java</vh></v>
</v>
</v>
<v t="ekr.20090529141856.4774"><vh>Javascript tests</vh>
<v t="ekr.20090529141856.4775"><vh>Problems</vh></v>
<v t="ekr.20090529141856.4776"><vh>@test Javascript-regex-1</vh></v>
<v t="ekr.20090529141856.4777"><vh>@test Javascript-2</vh></v>
<v t="ekr.20090529141856.4778"><vh>@test Javascript-3</vh></v>
<v t="ekr.20090529141856.4779"><vh>@@test javascript-test-js</vh></v>
</v>
<v t="ekr.20090529141856.4734"><vh>Pascal tests</vh>
<v t="ekr.20090529141856.4735"><vh>@test pascal-to-delphi interface</vh></v>
</v>
<v t="ekr.20100219080213.5365"><vh>PHP tests</vh>
<v t="ekr.20100219080213.5366"><vh>@test php import class</vh></v>
<v t="ekr.20100219080213.5367"><vh>@test php import conditional class</vh></v>
<v t="ekr.20100219080213.5368"><vh>@test php import classes &amp; functions</vh></v>
</v>
<v t="ekr.20090529141856.4736"><vh>Python tests</vh>
<v t="ekr.20090529141856.4737"><vh>@@test nested class</vh></v>
<v t="ekr.20090529141856.4738"><vh>@test comment after dict assign</vh></v>
<v t="ekr.20090529141856.4739"><vh>@test decorator test</vh></v>
<v t="ekr.20090529141856.4740"><vh>@test def inside def</vh></v>
<v t="ekr.20090529141856.4741"><vh>@test docstring only</vh></v>
<v t="ekr.20090529141856.4742"><vh>@test overindent def--no following def</vh></v>
<v t="ekr.20090529141856.4743"><vh>@test overindent def--one following def</vh></v>
<v t="ekr.20090529141856.4744"><vh>@test overindented def 3</vh></v>
<v t="ekr.20090529141856.4745"><vh>@test python bad class test</vh></v>
<v t="ekr.20090529141856.4746"><vh>@test python class test 2</vh></v>
<v t="ekr.20090529141856.4747"><vh>@test python class tests 1</vh></v>
<v t="ekr.20090529141856.4748"><vh>@test python decls test 1</vh></v>
<v t="ekr.20090529141856.4749"><vh>@test python def test 1</vh></v>
<v t="ekr.20090529141856.4750"><vh>@test python def test 2</vh></v>
<v t="ekr.20090529141856.4751"><vh>@test python empty decls</vh></v>
<v t="ekr.20090529141856.4752"><vh>@test python extra leading ws test</vh></v>
<v t="ekr.20090529141856.4753"><vh>@test python indent decls</vh></v>
<v t="ekr.20090529141856.4754"><vh>@test python minimal class 1</vh></v>
<v t="ekr.20090529141856.4755"><vh>@test python minimal class 2</vh></v>
<v t="ekr.20090529141856.4756"><vh>@test python minimal class 3</vh></v>
<v t="ekr.20090529141856.4757"><vh>@test python underindent method</vh></v>
<v t="ekr.20090529141856.4758"><vh>@test scanPythonText: leoImportNosent.py</vh></v>
<v t="ekr.20090529141856.4759"><vh>@test string test: extra indent</vh></v>
<v t="ekr.20090529141856.4760"><vh>@test string underindent lines</vh></v>
<v t="ekr.20090529141856.4761"><vh>@test string underindent lines 2</vh></v>
<v t="ekr.20090529141856.4762"><vh>@test trailing comment</vh></v>
<v t="ekr.20090529141856.4763"><vh>@test trailing comment--outer levels</vh></v>
<v t="ekr.20090529141856.4764"><vh>@test two functions (for comparison with unindent does not end function)</vh></v>
<v t="ekr.20090529141856.4765"><vh>@test unindent in triple string does not end function</vh></v>
</v>
<v t="ekr.20090529141856.4780"><vh>xml tests</vh>
<v t="ekr.20090529141856.4781"><vh>@test xml 1</vh></v>
</v>
</v>
<v t="ekr.20090529141856.4784"><vh> Tests of @auto-rst</vh>
<v t="ekr.20090529141856.4785"><vh>@test rST import test</vh></v>
<v t="ekr.20090529141856.4786"><vh>@test rST import test (no double-underlines)</vh></v>
<v t="ekr.20090529141856.4787"><vh>@test rST import test: long underlines</vh></v>
<v t="ekr.20090529141856.4788"><vh>@test rST import test: long overlines</vh></v>
<v t="ekr.20090529141856.4789"><vh>@test rST import test: trailing whitespace</vh></v>
</v>
<v t="ekr.20090529141856.4793"><vh>@@test test imports for modes</vh></v>
<v t="ekr.20100131180007.5393"><vh>@test reportMismatch</vh></v>
<v t="ekr.20090529141856.4792"><vh>Load tests for .leo files</vh></v>
<v t="ekr.20090529141856.4791"><vh>Other tests</vh></v>
</v>
<v t="ekr.20100131171342.5604"><vh>leoKeys</vh>
<v t="ekr.20100131171342.5605"><vh>@test isPlainKey</vh></v>
<v t="ekr.20100131171342.5606"><vh>@test k.autoCompleterClass.calltip</vh></v>
<v t="ekr.20100131171342.5607"><vh>@test k.registerCommand</vh></v>
<v t="ekr.20100212110954.5359"><vh>@test print-bindings</vh></v>
<v t="ekr.20100131171342.5608"><vh>@test strokeFromSetting</vh></v>
<v t="ekr.20100131171342.5609"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20071113194424.1"><vh>leoNodes</vh>
<v t="ekr.20040712101754.181"><vh> inner @test: Test consistency between parents iter and v.parents</vh>
<v t="ekr.20040712101754.182"><vh>parent</vh>
<v t="ekr.20040712101754.183"><vh>Startup</vh></v>
</v>
<v t="ekr.20040712101754.182"></v>
</v>
<v t="ekr.20040712101754.175"><vh>@@test p.t == p.v</vh></v>
<v t="ekr.20040712101754.200"><vh>@@test that clones share subtrees</vh></v>
<v t="ekr.20070611071101"><vh>@@test visback</vh>
<v t="ekr.20070611071101.1"><vh>a</vh>
<v t="ekr.20070611071101.2"><vh>b</vh>
<v t="ekr.20070611071101.3"><vh>c2</vh></v>
</v>
</v>
<v t="ekr.20070611071101.4"><vh>limit</vh>
<v t="ekr.20070611071101.5"><vh>d</vh></v>
</v>
<v t="ekr.20070611071954"><vh>e</vh></v>
</v>
<v t="ekr.20040712101754.99"><vh>@test c iters</vh>
<v t="ekr.20040712101754.100"><vh>&lt;&lt; coverage tests &gt;&gt;</vh></v>
<v t="ekr.20040712101754.101"><vh>&lt;&lt; duplicate tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20090102061858.2"><vh>@test c.positionExists</vh></v>
<v t="ekr.20090102062037.2"><vh>@test c.positionExists for all nodes</vh></v>
<v t="ekr.20040712101754.204"><vh>@test consistency of back/next links</vh></v>
<v t="ekr.20040712101754.201"><vh>@test consistency of c.all_positions() and p.ThreadNext()</vh></v>
<v t="ekr.20040712101754.202"><vh>@test consistency of firstChild &amp; children_iter()</vh></v>
<v t="ekr.20040712101754.203"><vh>@test consistency of level</vh></v>
<v t="ekr.20040712101754.205"><vh>@test consistency of parent &amp; parents_iter()</vh></v>
<v t="ekr.20040712101754.206"><vh>@test consistency of parent/child links</vh></v>
<v t="ekr.20040712101754.207"><vh>@test consistency of threadBack/Next links</vh></v>
<v t="ekr.20040712101754.177"><vh>@test convertTreeToString and allies</vh>
<v t="ekr.20040712101754.178"><vh>File Conversion</vh>
<v t="ekr.20040712101754.179"><vh>moreHead</vh></v>
<v t="ekr.20040712101754.180"><vh>moreBody</vh></v>
</v>
</v>
<v t="ville.20090312195309.2"><vh>@test find_h / find_b / select_h / select_b</vh></v>
<v t="ekr.20090130133404.2"><vh>@test leoNodes properties</vh></v>
<v t="ekr.20080310073711.1"><vh>@test nodeIndices.toString(None) allocates a new index</vh></v>
<v t="ekr.20041013062906"><vh>@test onHyperLinkControlClick</vh></v>
<v t="ekr.20100131180007.5369"><vh>@test p.adjustPositionBeforeUnlink</vh>
<v t="ekr.20100131180007.5370"><vh>node 1</vh>
<v t="ekr.20100131180007.5371"><vh>node 1-1</vh>
<v t="ekr.20100131180007.5372"><vh>node 1-1-1</vh></v>
<v t="ekr.20100131180007.5373"><vh>node 1-1-2</vh></v>
</v>
<v t="ekr.20100131180007.5374"><vh>node 1-2</vh>
<v t="ekr.20100131180007.5375"><vh>node 1-2-1</vh></v>
<v t="ekr.20100131180007.5376"><vh>node 1-2-2</vh></v>
</v>
</v>
<v t="ekr.20100131180007.5377"><vh>node 2</vh>
<v t="ekr.20100131180007.5378"><vh>node 2-1</vh>
<v t="ekr.20100131180007.5379"><vh>node 2-1-1</vh></v>
<v t="ekr.20100131180007.5380"><vh>node 2-1-2</vh></v>
</v>
<v t="ekr.20100131180007.5381"><vh>node 2-2</vh>
<v t="ekr.20100131180007.5382"><vh>node 2-2-1</vh></v>
<v t="ekr.20100131180007.5383"><vh>node 2-2-2</vh></v>
</v>
</v>
<v t="ekr.20100131180007.5384"><vh>node 3</vh>
<v t="ekr.20100131180007.5385"><vh>node 3-1</vh>
<v t="ekr.20100131180007.5386"><vh>node 3-1-1</vh></v>
<v t="ekr.20100131180007.5387"><vh>node 3-1-2</vh></v>
</v>
<v t="ekr.20100131180007.5388"><vh>node 3-2</vh>
<v t="ekr.20100131180007.5389"><vh>node 3-2-1</vh></v>
<v t="ekr.20100131180007.5390"><vh>node 3-2-2</vh></v>
</v>
</v>
</v>
<v t="ekr.20040712101754.199"><vh>@test p.comparisons</vh></v>
<v t="ekr.20040712101754.209"><vh>@test p.hasNextBack</vh></v>
<v t="ekr.20040712101754.210"><vh>@test p.hasParentChild</vh></v>
<v t="ekr.20040712101754.211"><vh>@test p.hasThreadNextBack</vh></v>
<v t="ekr.20040722055040"><vh>@test p.isAncestorOf</vh></v>
<v t="ekr.20060106211922"><vh>@test p.isCurrentPosition</vh></v>
<v t="ekr.20060106211922.1"><vh>@test p.isRootPosition</vh></v>
<v t="ekr.20040712101754.188"><vh>@test p.iters and v.iters</vh>
<v t="ekr.20040712101754.189"><vh>child1</vh>
<v t="ekr.20040712101754.190"><vh>a</vh>
<v t="ekr.20040712101754.191"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.192"><vh>c</vh></v>
<v t="ekr.20040712101754.190"></v>
<v t="ekr.20040712101754.193"><vh>d</vh>
<v t="ekr.20040712101754.194"><vh>e</vh></v>
</v>
</v>
<v t="ekr.20040712101754.195"><vh>child2</vh></v>
<v t="ekr.20040712101754.196"><vh>&lt;&lt; tests of consistency of p and v iters &gt;&gt;</vh></v>
<v t="ekr.20040712101754.197"><vh>&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;</vh></v>
<v t="ekr.20040712101754.198"><vh>&lt;&lt; print nodes returned by iterators &gt;&gt;</vh></v>
</v>
<v t="ekr.20040802071519"><vh>@test p.setBodyStringOrPane</vh>
<v t="ekr.20040802071519.1"><vh>Startup</vh></v>
</v>
<v t="ekr.20100131180007.5391"><vh>@test v.atAutoNodeName &amp; v.atAutoRstNodeName</vh></v>
<v t="ekr.20060913084600"><vh>@test v/t.__hash__</vh></v>
<v t="ekr.20071113202452"><vh>@test zz restore the screen</vh></v>
<v t="ekr.20080501121449.1"><vh>Fundamental node operations</vh>
<v t="ekr.20080423110627.2"><vh>@test at most one vnode has str_leo_pos attribute</vh></v>
<v t="ekr.20080423110627.3"><vh>@test clone and move the clone to the root</vh></v>
<v t="ekr.20080503082625.3"><vh>@test delete node</vh></v>
<v t="ekr.20080423110627.13"><vh>@test deleting the root should select another node</vh></v>
<v t="ekr.20080503082625.5"><vh>@test demote</vh></v>
<v t="ekr.20080501121449.3"><vh>@test insert node</vh></v>
<v t="ekr.20080423110627.11"><vh>@test move-outline-down &amp; undo/redo</vh></v>
<v t="ekr.20080503073030.1"><vh>@test move-outline-left</vh></v>
<v t="ekr.20080503073030.2"><vh>@test move-outline-right</vh></v>
<v t="ekr.20080423110627.12"><vh>@test move-outline-up</vh></v>
<v t="ekr.20080423110627.5"><vh>@test paste-node</vh></v>
<v t="ekr.20080423110627.8"><vh>@test paste-retaining-clones</vh></v>
<v t="ekr.20080503082625.4"><vh>@test promote</vh></v>
</v>
<v t="ekr.20081001094920.2"><vh>tests for p.textOffset()</vh>
<v t="ekr.20081001094920.3"><vh>@test node that doesn't belong to a derived file</vh></v>
<v t="ekr.20081001094920.4"><vh>@test root of a derived file</vh></v>
<v t="ekr.20081001094920.5"><vh>@test organizer node</vh></v>
<v t="ekr.20081001094920.6"><vh>@test section node</vh></v>
<v t="ekr.20081001094920.7"><vh>@test "others" directive</vh></v>
</v>
</v>
<v t="ekr.20100131171342.5610"><vh>leoPlugins</vh>
<v t="ekr.20100131171342.5611"><vh>@test getHandlersForTag</vh></v>
</v>
<v t="ekr.20091219122958.5066"><vh>leoRst</vh>
<v t="ekr.20100812172232.5800"><vh>@common leoRst test code</vh>
<v t="ekr.20100812182942.5804"><vh>class rst3Test</vh>
<v t="ekr.20100827194549.5963"><vh>report</vh></v>
<v t="ekr.20100827183358.5957"><vh>run</vh></v>
<v t="ekr.20100827183358.5958"><vh>setup</vh></v>
<v t="ekr.20100827183358.5959"><vh>set_got</vh></v>
</v>
</v>
<v t="ekr.20091219121039.5065"><vh>@test rst3 handleMissingStyleSheetArgs</vh></v>
<v t="ekr.20100812172232.5801"><vh>@test rst3 defaults</vh>
<v t="ekr.20100812182942.5805"><vh>source</vh>
<v t="ekr.20100812182942.5807"><vh>@rst test.html</vh>
<v t="ekr.20100812182942.5808"><vh>section</vh></v>
</v>
</v>
<v t="ekr.20100812213445.5814"><vh>expected</vh>
<v t="ekr.20100813100841.5848"><vh>rst</vh></v>
<v t="ekr.20100813100841.5849"><vh> html</vh></v>
</v>
<v t="ekr.20100827182529.6840"><vh>got</vh>
<v t="ekr.20100827182529.6841"><vh>rst</vh></v>
<v t="ekr.20100827182529.6842"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20100813100841.5850"><vh>@test rst3 @no-head</vh>
<v t="ekr.20100813100841.5854"><vh>source</vh>
<v t="ekr.20100813100841.5855"><vh>@rst test.html</vh>
<v t="ekr.20100813100841.5856"><vh>@rst-no-head section</vh></v>
</v>
</v>
<v t="ekr.20100813100841.5857"><vh>expected</vh>
<v t="ekr.20100813100841.5858"><vh>rst</vh></v>
<v t="ekr.20100813100841.5859"><vh> html</vh></v>
</v>
<v t="ekr.20100827182529.6843"><vh>got</vh>
<v t="ekr.20100827182529.6844"><vh>rst</vh></v>
<v t="ekr.20100827182529.6845"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20100813100841.5824"><vh>@test doc_only_mode (set in headline)</vh>
<v t="ekr.20100813100841.5839"><vh>source</vh>
<v t="ekr.20100813100841.5840"><vh>@rst test.html</vh>
<v t="ekr.20100813124317.5868"><vh>@rst-option doc_only_mode=True</vh>
<v t="ekr.20100813100841.5841"><vh>section</vh></v>
</v>
</v>
</v>
<v t="ekr.20100813100841.5842"><vh>expected</vh>
<v t="ekr.20100813124317.5869"><vh>rst</vh></v>
<v t="ekr.20100813124317.5870"><vh> html</vh></v>
</v>
<v t="ekr.20100827182529.6846"><vh>got</vh>
<v t="ekr.20100827182529.6847"><vh>rst</vh></v>
<v t="ekr.20100827182529.6848"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20100813124317.5879"><vh>@test doc_only_mode (set in options doc part)</vh>
<v t="ekr.20100813124317.5880"><vh>source</vh>
<v t="ekr.20100813124317.5881"><vh>@rst test.html</vh>
<v t="ekr.20100813124317.5883"><vh>section</vh></v>
</v>
</v>
<v t="ekr.20100813124317.5884"><vh>expected</vh>
<v t="ekr.20100813124317.5889"><vh>rst</vh></v>
<v t="ekr.20100813124317.5890"><vh> html</vh></v>
</v>
<v t="ekr.20100827182529.6849"><vh>got</vh>
<v t="ekr.20100827182529.6850"><vh>rst</vh></v>
<v t="ekr.20100827182529.6851"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20100813100841.5825"><vh>@test show_doc_parts_in_rst_mode</vh></v>
<v t="ekr.20100827140832.5913"><vh>@test show_leo_directives=False</vh>
<v t="ekr.20100827140832.5917"><vh>source</vh>
<v t="ekr.20100827140832.5918"><vh>@rst test.html</vh>
<v t="ekr.20100827140832.5919"><vh>section</vh></v>
</v>
</v>
<v t="ekr.20100827140832.5926"><vh>expected</vh>
<v t="ekr.20100827140832.5929"><vh>rst</vh></v>
<v t="ekr.20100827140832.5930"><vh> html</vh></v>
</v>
<v t="ekr.20100827182529.6852"><vh>got</vh>
<v t="ekr.20100827182529.6853"><vh>rst</vh></v>
<v t="ekr.20100827182529.6854"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20100813100841.5847"><vh>@ignore</vh>
<v t="ekr.20100812213445.5824"><vh>@test code_mode: rst3 show_doc_parts_as_paragraphs</vh>
<v t="ekr.20100812213445.5825"><vh>source</vh>
<v t="ekr.20100812213445.5826"><vh>@rst test.html</vh>
<v t="ekr.20100812213445.5827"><vh>section</vh></v>
</v>
</v>
<v t="ekr.20100812213445.5828"><vh>expected</vh>
<v t="ekr.20100813100841.5843"><vh>rst</vh></v>
<v t="ekr.20100813100841.5844"><vh> html</vh></v>
</v>
</v>
<v t="ekr.20100813100841.5827"><vh>@test code_mode: show_leo_directives</vh></v>
<v t="ekr.20100813100841.5828"><vh>@test code_mode: show_markup_doc_parts</vh></v>
<v t="ekr.20100813100841.5829"><vh>@test code_mode: show_options_doc_parts</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4396"><vh>leoShadow</vh>
<v t="ekr.20090529115704.4560"><vh>@@test (minitest) x.show_error</vh></v>
<v t="ekr.20090529115704.4569"><vh>@@test delete unittest shadow directory</vh></v>
<v t="ekr.20090529115704.4397"><vh>@suite run @shadow-test nodes in the @shadow-tests tree</vh>
<v t="ekr.20090529115704.4398"><vh>@shadow-tests</vh>
<v t="ekr.20090529115704.4399"><vh>passed</vh></v>
<v t="ekr.20090529115704.4400"><vh>@shadow-test change middle line</vh>
<v t="ekr.20090529115704.4401"><vh>old</vh></v>
<v t="ekr.20090529115704.4402"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4403"><vh>@shadow-test change first line</vh>
<v t="ekr.20090529115704.4404"><vh>old</vh></v>
<v t="ekr.20090529115704.4405"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4406"><vh>@shadow-test change last line</vh>
<v t="ekr.20090529115704.4407"><vh>old</vh></v>
<v t="ekr.20090529115704.4408"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4409"><vh>@shadow-test delete first line</vh>
<v t="ekr.20090529115704.4410"><vh>old</vh></v>
<v t="ekr.20090529115704.4411"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4412"><vh>@shadow-test delete middle line</vh>
<v t="ekr.20090529115704.4413"><vh>old</vh></v>
<v t="ekr.20090529115704.4414"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4415"><vh>@shadow-test delete last line</vh>
<v t="ekr.20090529115704.4416"><vh>old</vh></v>
<v t="ekr.20090529115704.4417"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4418"><vh>@shadow-test insert before first line</vh>
<v t="ekr.20090529115704.4419"><vh>old</vh></v>
<v t="ekr.20090529115704.4420"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4421"><vh>@shadow-test insert after first line</vh>
<v t="ekr.20090529115704.4422"><vh>old</vh></v>
<v t="ekr.20090529115704.4423"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4424"><vh>@shadow-test insert before last line</vh>
<v t="ekr.20090529115704.4425"><vh>old</vh></v>
<v t="ekr.20090529115704.4426"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4427"><vh>@shadow-test insert after last line</vh>
<v t="ekr.20090529115704.4428"><vh>old</vh></v>
<v t="ekr.20090529115704.4429"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4430"><vh>@shadow-test-lax insert between nodes: at end of prev node</vh>
<v t="ekr.20090529115704.4431"><vh>old</vh>
<v t="ekr.20090529115704.4432"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4433"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4434"><vh>new</vh>
<v t="ekr.20090529115704.4435"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4436"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4437"><vh>@shadow-test insert between nodes: at start of next node</vh>
<v t="ekr.20090529115704.4438"><vh>old</vh>
<v t="ekr.20090529115704.4439"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4440"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4441"><vh>new</vh>
<v t="ekr.20090529115704.4442"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4443"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4444"><vh>@shadow-test delete between nodes: at end of prev node</vh>
<v t="ekr.20090529115704.4445"><vh>old</vh>
<v t="ekr.20090529115704.4446"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4447"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4448"><vh>new</vh>
<v t="ekr.20090529115704.4449"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4450"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4451"><vh>@shadow-test delete between nodes: at start of next node</vh>
<v t="ekr.20090529115704.4452"><vh>old</vh>
<v t="ekr.20090529115704.4453"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4454"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4455"><vh>new</vh>
<v t="ekr.20090529115704.4456"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4457"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4458"><vh>@shadow-test change end of prev node</vh>
<v t="ekr.20090529115704.4459"><vh>old</vh>
<v t="ekr.20090529115704.4460"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4461"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4462"><vh>new</vh>
<v t="ekr.20090529115704.4463"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4464"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4465"><vh>@shadow-test change start of next node</vh>
<v t="ekr.20090529115704.4466"><vh>old</vh>
<v t="ekr.20090529115704.4467"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4468"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4469"><vh>new</vh>
<v t="ekr.20090529115704.4470"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4471"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4472"><vh>@shadow-test-lax multiple-line insert between nodes: at end of prev node</vh>
<v t="ekr.20090529115704.4473"><vh>old</vh>
<v t="ekr.20090529115704.4474"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4475"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4476"><vh>new</vh>
<v t="ekr.20090529115704.4477"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4478"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4479"><vh>@shadow-test multiple-line insert between nodes: at start of next node</vh>
<v t="ekr.20090529115704.4480"><vh>old</vh>
<v t="ekr.20090529115704.4481"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4482"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4483"><vh>new</vh>
<v t="ekr.20090529115704.4484"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4485"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4486"><vh>@shadow-test multiple-line change end of prev node</vh>
<v t="ekr.20090529115704.4487"><vh>old</vh>
<v t="ekr.20090529115704.4488"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4489"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4490"><vh>new</vh>
<v t="ekr.20090529115704.4491"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4492"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4493"><vh>@shadow-test multiple-line change start of next node</vh>
<v t="ekr.20090529115704.4494"><vh>old</vh>
<v t="ekr.20090529115704.4495"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4496"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4497"><vh>new</vh>
<v t="ekr.20090529115704.4498"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4499"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20100107110353.5105"><vh>@shadow-test NEW multiple-NODE changes</vh>
<v t="ekr.20100107110353.5106"><vh>old</vh>
<v t="ekr.20100107110353.5107"><vh>node 1</vh></v>
<v t="ekr.20100107110353.5108"><vh>node 2</vh></v>
</v>
<v t="ekr.20100107110353.5109"><vh>new</vh>
<v t="ekr.20100107110353.5110"><vh>node 1</vh></v>
<v t="ekr.20100107110353.5111"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4500"><vh>@shadow-test multiple-line delete between nodes: at end of prev node</vh>
<v t="ekr.20090529115704.4501"><vh>old</vh>
<v t="ekr.20090529115704.4502"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4503"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4504"><vh>new</vh>
<v t="ekr.20090529115704.4505"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4506"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4507"><vh>@shadow-test multiple-line delete between nodes: at start of next node</vh>
<v t="ekr.20090529115704.4508"><vh>old</vh>
<v t="ekr.20090529115704.4509"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4510"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4511"><vh>new</vh>
<v t="ekr.20090529115704.4512"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4513"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4514"><vh>@shadow-test verbatim sentinels-delete verbatim line</vh>
<v t="ekr.20090529115704.4515"><vh>old</vh>
<v t="ekr.20090529115704.4516"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4517"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4518"><vh>new</vh>
<v t="ekr.20090529115704.4519"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4520"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4521"><vh>@shadow-test verbatim sentinels-delete verbatim line: at start of node</vh>
<v t="ekr.20090529115704.4522"><vh>old</vh>
<v t="ekr.20090529115704.4523"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4524"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4525"><vh>new</vh>
<v t="ekr.20090529115704.4526"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4527"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4528"><vh>@shadow-test verbatim sentinels-no change</vh>
<v t="ekr.20090529115704.4529"><vh>old</vh>
<v t="ekr.20090529115704.4530"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4531"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4532"><vh>new</vh>
<v t="ekr.20090529115704.4533"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4534"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4535"><vh>@shadow-test verbatim sentinels-delete verbatim line: at end of node</vh>
<v t="ekr.20090529115704.4536"><vh>old</vh>
<v t="ekr.20090529115704.4537"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4538"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4539"><vh>new</vh>
<v t="ekr.20090529115704.4540"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4541"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4542"><vh>@shadow-test verbatim sentinels-add verbatim line</vh>
<v t="ekr.20090529115704.4543"><vh>old</vh>
<v t="ekr.20090529115704.4544"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4545"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4546"><vh>new</vh>
<v t="ekr.20090529115704.4547"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4548"><vh>node 2</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20100131180007.5363"><vh>@test class markerClass.getDelims</vh></v>
<v t="ekr.20100131180007.5362"><vh>@test class markerClass.isSentinel</vh></v>
<v t="ekr.20100131180007.5361"><vh>@test class markerClass.isVerbatimSentinel</vh></v>
<v t="ekr.20090529115704.4550"><vh>@test x.baseDirName</vh></v>
<v t="ekr.20090529115704.4552"><vh>@test x.dirName</vh></v>
<v t="ekr.20100131180007.5366"><vh>@test x.findAtLeoLine</vh></v>
<v t="ekr.20090529115704.4557"><vh>@test x.makeShadowDirectory</vh>
<v t="ekr.20090529115704.4558"><vh>deleteShadowDir</vh></v>
</v>
<v t="ekr.20100131180007.5365"><vh>@test x.markerFromFileLines</vh></v>
<v t="ekr.20100131180007.5364"><vh>@test x.markerFromFileName</vh></v>
<v t="ekr.20090529115704.4551"><vh>@test x.pathName</vh></v>
<v t="ekr.20090529115704.4555"><vh>@@test x.rename</vh></v>
<v t="ekr.20090529115704.4559"><vh>@test x.replaceFileWithString</vh></v>
<v t="ekr.20100131180007.5367"><vh>@test x.replaceFileWithString 2</vh></v>
<v t="ekr.20090529115704.4554"><vh>@test x.shadowDirName</vh></v>
<v t="ekr.20090529115704.4553"><vh>@test x.shadowPathName</vh></v>
<v t="ekr.20090529115704.4556"><vh>@test x.unlink</vh></v>
</v>
<v t="ekr.20100131171342.5612"><vh>leoTest</vh>
<v t="ekr.20100131171342.5613"><vh>@test unit testing with embedded class</vh></v>
</v>
<v t="ekr.20071113193729"><vh>leoUndo</vh>
<v t="ekr.20040712101754.37"><vh>@suite Edit body tests</vh>
<v t="ekr.20040712101754.38"><vh>editBodyTests</vh>
<v t="ekr.20060127120604"><vh>tempNode</vh></v>
<v t="ekr.20050417202713"><vh>addComments</vh>
<v t="ekr.20050417202713.1"><vh>before</vh></v>
<v t="ekr.20050417202713.2"><vh>after</vh></v>
<v t="ekr.20050417202713.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417204940"><vh>convertAllBlanks</vh>
<v t="ekr.20050417204940.1"><vh>before</vh></v>
<v t="ekr.20050417204940.2"><vh>after</vh></v>
<v t="ekr.20050417204940.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417205012"><vh>convertAllTabs</vh>
<v t="ekr.20050417205012.1"><vh>before</vh></v>
<v t="ekr.20050417205012.2"><vh>after</vh></v>
<v t="ekr.20050417205012.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417203114"><vh>convertBlanks</vh>
<v t="ekr.20050417203310"><vh>before</vh></v>
<v t="ekr.20050417203310.1"><vh>after</vh></v>
<v t="ekr.20050417203336"><vh>selection</vh></v>
</v>
<v t="ekr.20050417203114.1"><vh>convertTabs</vh>
<v t="ekr.20050417204834"><vh>before</vh></v>
<v t="ekr.20050417204830"><vh>after</vh></v>
<v t="ekr.20050417204901"><vh>selection</vh></v>
</v>
<v t="ekr.20040712101754.49"><vh>dedentBody</vh>
<v t="ekr.20040712101754.50"><vh>before</vh></v>
<v t="ekr.20040712101754.51"><vh>after</vh></v>
<v t="ekr.20040712101754.52"><vh>selection</vh></v>
</v>
<v t="ekr.20050417202817"><vh>deleteComments</vh>
<v t="ekr.20050417202817.1"><vh>before</vh></v>
<v t="ekr.20050417202817.2"><vh>after</vh></v>
<v t="ekr.20050417202817.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417201845"><vh>extract test1</vh>
<v t="ekr.20050417201845.1"><vh>before</vh></v>
<v t="ekr.20050417201845.2"><vh>after</vh>
<v t="ekr.20050417201845.3"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20050417201845.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050518070540"><vh>extract test2</vh>
<v t="ekr.20050518070540.1"><vh>before</vh></v>
<v t="ekr.20050518070545"><vh>after</vh></v>
<v t="ekr.20050518070540.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050518070927"><vh>extractSection test1</vh>
<v t="ekr.20050518070927.1"><vh>before</vh></v>
<v t="ekr.20050518070927.2"><vh>after</vh>
<v t="ekr.20050518070927.3"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20050518070927.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050518071251"><vh>extractSection test2</vh>
<v t="ekr.20050518071251.1"><vh>before</vh></v>
<v t="ekr.20050518071258"><vh>after</vh></v>
<v t="ekr.20050518071251.4"><vh>selection</vh></v>
</v>
</v>
</v>
<v t="ekr.20071113202510"><vh>@test zz restore the screen</vh></v>
</v>
</v>
<v t="ekr.20090306091634.1"><vh>@test print redraw count</vh></v>
<v t="ekr.20081111150402.11"><vh>@test zz restore the screen</vh></v>
</v>
<v t="ekr.20100223094723.5375"><vh>New import tests</vh>
<v t="ekr.20100223094723.5376"><vh>@test skipToTheNextClassOrFunction (a class next)</vh></v>
<v t="ekr.20100223094723.5377"><vh>@test skipToTheNextClassOrFunction (a function next)</vh></v>
<v t="ekr.20100223094723.5378"><vh>@test skipToTheNextClassOrFunction (nothing next)</vh></v>
<v t="ekr.20100223094723.5379"><vh>@test skipToTheNextClassOrFunction (indented def next)</vh></v>
</v>
<v t="ekr.20100907003013.5979"><vh>@test leoInkCommands</vh></v>
</vnodes>
<tnodes>
<t tx="bwmulder.20050108100437.1">@killcolor

Running unit tests from test.leo is easy, provided you have enabled the
Scripting plugin. When this plugin is enabled Leo will create a blue 'script
button' in the icon bar called 'unit test'. 

- To run all unit tests, select the node in test.leo called 'Unit tests...',
then do &lt;alt-4&gt; 

- To run a single test, select an @test node and do &lt;alt-4&gt;.

- To run a suite of tests, select an @suite node and do &lt;alt-4&gt;.

- To run any other collection of tests, create an outline containing those @test
or @suite nodes, select the root of that tree and do &lt;alt-4&gt; .

Several nodes in the tree @thin ../src/leoTest.py (in test.leo) contain support
code for @test, @suite, etc. so if you want all the gory details you can read
the code. It's not complicated: Leo creates UnitTest classes automatically whose
run method is the body of the @suite or @test node.
</t>
<t tx="ekr.20040707141957.12">import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.13">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040707141957.14">#@+leo-ver=5-thin
#@+node:ekr.20040707141957.13: * #@thin
Line 1

#@@last
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040712101754.100">v1 = [p.v for p in c.all_positions()]
v2 = [v for v in c.all_nodes()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

# print("coverage tests pass")</t>
<t tx="ekr.20040712101754.101">nodes = []
for v in c.all_unique_nodes():
    assert v not in nodes
    nodes.append(v)
    
# print("duplicate tests pass")</t>
<t tx="ekr.20040712101754.103">import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.104">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040712101754.105">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@nonl
#@-node:#@file
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040712101754.106">import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.107">Line 1

@last last line 1: newline
</t>
<t tx="ekr.20040712101754.108">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@-node:#@file
#@-leo
last line 1: newline
</t>
<t tx="ekr.20040712101754.109">import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.110">Line 1

@last last line 1: two trailing newlines
</t>
<t tx="ekr.20040712101754.111">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@-node:#@file
#@-leo
last line 1: two trailing newlines
</t>
<t tx="ekr.20040712101754.175"># p.__getattr__ must be enabled for this test to work.

for p in c.all_positions():
    assert(p.t == p.v)</t>
<t tx="ekr.20040712101754.177">p = p.firstChild()
assert(p.h=="File Conversion")
p.convertTreeToString()</t>
<t tx="ekr.20040712101754.178">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040712101754.179">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.h)</t>
<t tx="ekr.20040712101754.180">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; list = []
    
    # Only escape the first non-blank character of the line.
    s =  p.b ; result = []
    lines = string.split(s,'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s):
            ch = s[i]
            if ch == '+' or ch == '-' or ch == '\\':
                s = s[:i] + '\\' + s[i:]
        result.append(s)
    return string.join(result,'\n')
</t>
<t tx="ekr.20040712101754.181"># The actual test is in a child node.</t>
<t tx="ekr.20040712101754.182"></t>
<t tx="ekr.20040712101754.183">try:
    for p in c.all_positions():
        if 0: # Check all ancestors.  This is tricky and doesn't work yet.
            parents1 = [parent.v for parent in p.parents_iter()]
            parents2 = []
            parent2 = p.v.directParents()
            while parent2:
                v = parent2[0]
                parents2.append(v)
                parent2 = v.directParents()
        else:
            parents1 = p.v.parents
            parents2 = p.v.directParents()
        
        assert len(parents1) == len(parents2), "length mismatch: %s" % (p)
        for parent in parents1:
            assert parent in parents2, "%s not in %s" % (parent,parent1)
        for parent in parents2:
            assert parent in parents1, "%s not in %s" % (parent,parent2)

except AssertionError:
    print("parents1")
    for parent in parents1: print(parent)
    print("parents2")
    for parent in parents2: print(parent)
    raise</t>
<t tx="ekr.20040712101754.188">import leo.core.leoNodes as leoNodes

current = c.p
child = current.firstChild()

allList = [p.v for p in c.all_positions_iter()]
vList1 = [v for v in c.p.vnodes_iter()]
vList2 = [v for v in c.p.unique_vnodes_iter()]

if 0:
    for v in vList1: print(v)
    for v in vList2: print(v)

if 0:
    print(len(allList),len(vList1),len(vList2))

if 0: # v.iters no longer exist.
    &lt;&lt; tests of consistency of p and v iters &gt;&gt;
&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;
&lt;&lt; print nodes returned by iterators &gt;&gt;</t>
<t tx="ekr.20040712101754.189"></t>
<t tx="ekr.20040712101754.190"></t>
<t tx="ekr.20040712101754.191"></t>
<t tx="ekr.20040712101754.192"></t>
<t tx="ekr.20040712101754.193"></t>
<t tx="ekr.20040712101754.194"></t>
<t tx="ekr.20040712101754.195"></t>
<t tx="ekr.20040712101754.196">try:
    tag = "test1"
    list1 = [v for v in current.vnodes_iter()]
    list2 = [v for v in current.v.self_and_subtree_iter()]
    assert(list1==list2)
    
    tag = "test2"
    list1 = [p.v for p in c.all_positions_iter()]
    list2 = [v   for v in c.all_vnodes_iter()]
    assert(list1==list2)
    
    # print("consistency tests pass")

except AssertionError:
    print(tag)
    print("list1")
    for v in list1: print(v)
    print("list2")
    for v in list2: print(v)
    raise</t>
<t tx="ekr.20040712101754.197">nodes = []
for v in current.unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in current.unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print("duplicate tests pass")</t>
<t tx="ekr.20040712101754.198">if 0:
    for v in current.vnodes_iter(): print(v)
    for v in current.unique_vnodes_iter(): print(v)

if 0: # subtree of root node:
    root = c.rootPosition()
    for v in root.vnodes_iter(): print(v)
    for t in root.tnodes_iter(): print(t)

if 0: # child1's tree.  child2 should not be included.
    for v in child.vnodes_iter(): print(v)
    for t in child.tnodes_iter(): print(t)</t>
<t tx="ekr.20040712101754.199">copy = p.copy()
assert(p == copy)
assert(p != p.threadNext())

root = c.rootPosition()
# assert p.equal(p.copy()) is True
# assert p.equal(root) is False
assert p.__eq__(copy) is True
assert p.__ne__(copy) is False
assert p.__eq__(root) is False
assert p.__ne__(root) is True</t>
<t tx="ekr.20040712101754.2">@language python
@tabwidth -4</t>
<t tx="ekr.20040712101754.200">for p in c.all_positions():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        firstChild = p.v.children[0]
        assert childv == firstChild
</t>
<t tx="ekr.20040712101754.201">p2 = c.rootPosition()
for p in c.all_positions():
    assert p==p2, "%s != %s" % (p,p2)
    p2.moveToThreadNext()
    
assert not p2, repr(p2)
</t>
<t tx="ekr.20040712101754.202">for p in c.all_positions():
    p2 = p.firstChild()
    for p3 in p.children_iter():
        assert p3==p2, "%s != %s" % (p3,p2)
        p2.moveToNext()

assert not p2, repr(p2)</t>
<t tx="ekr.20040712101754.203">for p in c.all_positions():
    
    if p.hasParent():
        assert(p.parent().level() == p.level() - 1)

    if p.hasChildren():
        assert(p.firstChild().level() == p.level() + 1)
        
    if p.hasNext():
        assert(p.next().level() == p.level())

    if p.hasBack():
        assert(p.back().level() == p.level())</t>
<t tx="ekr.20040712101754.204">for p in c.all_positions():
    
    back = p.back()
    next = p.next()
    if back: assert(back.getNext() == p)
    if next: assert(next.getBack() == p)</t>
<t tx="ekr.20040712101754.205">for p in c.all_positions():
    p2 = p.parent()
    for p3 in p.parents_iter():
        assert p3==p2, "%s != %s" % (p3,p2)
        p2.moveToParent()

    assert not p2, repr(p2)</t>
<t tx="ekr.20040712101754.206"># Test consistency of p.parent, p.next, p.back and p.firstChild.
for p in c.all_positions():
    
    if p.hasParent():
        n = p.childIndex()
        assert(p == p.parent().moveToNthChild(n))
        
    for child in p.children_iter():
        assert(p == child.parent())

    if p.hasNext():
        assert(p.next().parent() == p.parent())
        
    if p.hasBack():
        assert(p.back().parent() == p.parent())</t>
<t tx="ekr.20040712101754.207">for p in c.all_positions():

    threadBack = p.threadBack()
    threadNext = p.threadNext()

    if threadBack:
        assert(p == threadBack.getThreadNext())

    if threadNext:
        assert(p == threadNext.getThreadBack())</t>
<t tx="ekr.20040712101754.209">for p in c.all_positions():

    back = p.back()
    next = p.next()

    assert(
        (back and p.hasBack()) or
        (not back and not p.hasBack()))
            
    assert(
        (next and p.hasNext()) or
        (not next and not p.hasNext()))</t>
<t tx="ekr.20040712101754.210">for p in c.all_positions():

    child = p.firstChild()
    parent = p.parent()

    assert(
        (child and p.hasFirstChild()) or
        (not child and not p.hasFirstChild()))
            
    assert(
        (parent and p.hasParent()) or
        (not parent and not p.hasParent()))</t>
<t tx="ekr.20040712101754.211">for p in c.all_positions():

    threadBack = p.getThreadBack()
    threadNext = p.getThreadNext()

    assert(
        (threadBack and p.hasThreadBack()) or
        (not threadBack and not p.hasThreadBack()))
            
    assert(
        (threadNext and p.hasThreadNext()) or
        (not threadNext and not p.hasThreadNext()))</t>
<t tx="ekr.20040712101754.213"></t>
<t tx="ekr.20040712101754.214"></t>
<t tx="ekr.20040712101754.215">import leoNodes

root1 = p.firstChild()

root2 = root1.copyTreeAfter()
root2.initHeadString("root2")
c.checkOutline()
c.redraw()
root2.doDelete(root1)
c.checkOutline()
c.redraw()</t>
<t tx="ekr.20040712101754.216"></t>
<t tx="ekr.20040712101754.217"></t>
<t tx="ekr.20040712101754.218"></t>
<t tx="ekr.20040712101754.219"></t>
<t tx="ekr.20040712101754.220"></t>
<t tx="ekr.20040712101754.221">import leoTest

u = leoTest.testUtils(c)
outline1 = p.firstChild()
outline2 = outline1.next()
assert(outline1.h=="outline1")
assert(outline2.h=="outline2")

u.replaceOutline(outline1,outline2)
c.redraw()
c.checkOutline()</t>
<t tx="ekr.20040712101754.222"></t>
<t tx="ekr.20040712101754.223"></t>
<t tx="ekr.20040712101754.224"></t>
<t tx="ekr.20040712101754.225"></t>
<t tx="ekr.20040712101754.226">def replaceOutline (self,outline1,outline2):
    
    """Replace outline1 by a copy of outline 2,
    
    retaining the headline of outline1."""

    h = outline1.h
    copy = outline2.copyTreeAfter()
    copy.initHeadString(h)
    copy.unlink()
    copy.linkAfter(outline1)
    outline1.doDelete(copy)</t>
<t tx="ekr.20040712101754.227"># Create unit tests in g.app.scriptDict["suite"]

import unittest
import leoTest

@others

suite = makeOutlineSuite("outlineTests")

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.228">def makeOutlineSuite(c,parentHeadline):
    
    """Create an outline test for every descendant of testParentHeadline.."""

    v = c.currentVnode()
    u = leoTest.testUtils(c)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    
    parent = u.findNodeAnywhere(parentHeadline)
    
    for child in parent.children_iter(copy=True):
        before = u.findNodeInTree(child,"before")
        after  = u.findNodeInTree(child,"after")
        ref    = u.findNodeInTree(child,"ref")
        if before and after and ref:
            test = outlineTestCase(c,child,before,after,ref)
            suite.addTest(test)

    return suite
</t>
<t tx="ekr.20040712101754.229">class outlineTestCase(unittest.TestCase):
    
    """Data-driven unit tests for Leo's outline commands."""
    
    @others</t>
<t tx="ekr.20040712101754.230">def __init__ (self,c,parent,before,after,ref):
    
    # Init the base class.
    unittest.TestCase.__init__(self)
    
    self.u = leoTest.testUtils(c)

    self.c = c
    self.parent = parent
    self.before = before
    self.after = after
    self.ref    = ref</t>
<t tx="ekr.20040712101754.231">def outlineCommand (self):
    
    c = self.c ; u = self.u ; tree = c.frame.tree
    
    move = u.findNodeInTree(self.before,"move")
    assert move, "no move node"
    
    c.selectVnode(move)
    commandName = self.parent.h
    command = getattr(c,commandName)
    command(event)

    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))
    c.undoer.redo()
    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))</t>
<t tx="ekr.20040712101754.232">def runTest(self):

    self.outlineCommand()</t>
<t tx="ekr.20040712101754.233">def setUp(self):

    assert(self.before)
    assert(self.after)
    assert(self.ref)
    assert self.u.compareOutlines(self.before,self.ref,compareHeadlines=False),\
        "compare failed"
    
    # Batch mode bugs: meaning of move may depend on visibility.
    self.parent.parent().expand()
    self.parent.expand()
    self.before.expand()
    self.after.expand()</t>
<t tx="ekr.20040712101754.234">def tearDown (self):

    c = self.c ; u = self.u

    if not u.compareOutlines(self.before,self.ref):
        u.replaceOutline(c,self.before,self.ref)

    self.before.contract()
    self.after.contract()
    self.parent.contract()
    self.parent.parent().contract()</t>
<t tx="ekr.20040712101754.235">def shortDescription (self):
    
    return self.parent.h</t>
<t tx="ekr.20040712101754.236"></t>
<t tx="ekr.20040712101754.237"></t>
<t tx="ekr.20040712101754.238"></t>
<t tx="ekr.20040712101754.239"></t>
<t tx="ekr.20040712101754.240"></t>
<t tx="ekr.20040712101754.241"></t>
<t tx="ekr.20040712101754.242"></t>
<t tx="ekr.20040712101754.243"></t>
<t tx="ekr.20040712101754.244"></t>
<t tx="ekr.20040712101754.245"></t>
<t tx="ekr.20040712101754.246"></t>
<t tx="ekr.20040712101754.247"></t>
<t tx="ekr.20040712101754.248"></t>
<t tx="ekr.20040712101754.249"></t>
<t tx="ekr.20040712101754.250"></t>
<t tx="ekr.20040712101754.251"></t>
<t tx="ekr.20040712101754.252"></t>
<t tx="ekr.20040712101754.253"></t>
<t tx="ekr.20040712101754.254"># Create unit tests in g.app.scriptDict["suite"]

import unittest
import leoTest

@others

suite = unittest.makeSuite(findCommandTestCase,'test')

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.255">class findCommandTestCase(unittest.TestCase):
    
    """Unit tests for Leo's find commands."""
    
    @others</t>
<t tx="ekr.20040712101754.256">def setUp(self):
    
    self.c = c
    self.u = u = leoTest.testUtils(c)
    self.find_p = u.findNodeAnywhere("findTests")
    
    assert(self.find_p)
</t>
<t tx="ekr.20040712101754.257">def testFindCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.258">def testFindWordCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.259">def testFindIgnoreCaseCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.260">aaa</t>
<t tx="ekr.20040712101754.272">errors = c.checkOutline(verbose=False,unittest=True,full=True) # Run full check.

assert errors == 0, "Check Outline reported %d errors" % errors</t>
<t tx="ekr.20040712101754.3">import leo.core.leoTest as leoTest

path = g.os_path_join(g.app.loadDir,"..","test","test.leo")
leoTest.runLeoTest(c,path,verbose=False,full=True)

</t>
<t tx="ekr.20040712101754.37"># Create unit tests in g.app.scriptDict["suite"]

import leo.core.leoTest as leoTest

g.app.enableUnitTest = True

suite = leoTest.makeEditBodySuite(c,p)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.38">@language plain

The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.</t>
<t tx="ekr.20040712101754.4">import leo.core.leoTest as leoTest

path = g.os_path_join(g.app.loadDir,"..","core","LeoPyRef.leo")
leoTest.runLeoTest(c,path)
</t>
<t tx="ekr.20040712101754.49"></t>
<t tx="ekr.20040712101754.5">import leo.core.leoTest as leoTest

path = g.os_path_join(g.app.loadDir,"..","plugins","leoPluginsRef.leo")
leoTest.runLeoTest(c,path)
</t>
<t tx="ekr.20040712101754.50">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040712101754.51">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040712101754.52">2.0
3.5</t>
<t tx="ekr.20040712101754.6">import leo.core.leoTest as leoTest

path = g.os_path_join(g.app.loadDir,"..","doc","LeoDocs.leo")
leoTest.runLeoTest(c,path)
</t>
<t tx="ekr.20040712101754.99">&lt;&lt; coverage tests &gt;&gt;
&lt;&lt; duplicate tests &gt;&gt;

if 0:
    print("vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()]))
    print("tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()]))

if 0: # all nodes
    for v in c.all_vnodes_iter(): print(v)
    for t in c.all_tnodes_iter(): print(t)
        
if 0: # unique nodes
    for v in c.all_unique_vnodes_iter(): print(v)
    for t in c.all_unique_tnodes_iter(): print(t)</t>
<t tx="ekr.20040712101813">result = c.checkAllPythonCode(unittest=True,ignoreAtIgnore=True)

assert result=="ok", "checkPythonCode returns: %s" % result</t>
<t tx="ekr.20040713070526">@language python 

import leo.core.leoTest as leoTest

u = leoTest.testUtils(c)
dump = False 
all = False 

if all:
    c.prettyPrintAllPythonCode(dump=dump)
else:
    # Warning: at present the before and after text is unprotected:
    # Running Pretty Print on these nodes will negate the value of the test.
    temp = u.findNodeInTree(p,"tempNode")
    c.setBodyString(temp,"")
    before = u.findNodeInTree(p,"before")
    after = u.findNodeInTree(p,"after")
    temp.scriptSetBodyString(before.b)
    c.prettyPrintPythonCode(p=temp,dump=dump)
    assert temp.b == after.b,"Pretty Print Test failed"</t>
<t tx="ekr.20040713123617">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a == 3:
        g.pr("  ")

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others</t>
<t tx="ekr.20040713123828.1">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a == 3:
        g.pr("  ")

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others</t>
<t tx="ekr.20040722055040">for p in c.all_positions():
    
    child = p.firstChild()
    while child:
        for parent in p.self_and_parents_iter():
            assert parent.isAncestorOf(child)
        child.moveToNext()

    next = p.next()
    assert not p.isAncestorOf(next)</t>
<t tx="ekr.20040730181601">import leo.core.leoTest as leoTest

path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile.leo")
leoTest.runLeoTest(c,path,verbose=False,full=True)
</t>
<t tx="ekr.20040730181610">import leo.core.leoTest as leoTest

path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile2.leo")
leoTest.runLeoTest(c,path,verbose=False,full=True)
</t>
<t tx="ekr.20040802065214"># Make sure that changing this headline marks descendant @thin nodes dirty.
h = p.h

try:
    child = p.firstChild()
    child.initHeadString("@thin bogus")
    assert child.h == "@thin bogus", "setting headline failed"
    child.clearDirty()
    assert not child.isDirty(), "clearing dirty failed"
    c.setHeadString(p,"changed")
    assert child.isDirty(), "setting descendant @thin nodes dirty failed."
finally:
    try:
        c.setHeadString(p,h)
        c.setHeadString(child,"bogus")
        p.clearDirty()
        child.clearDirty()
    finally: pass

#### c.redraw()
</t>
<t tx="ekr.20040802065214.1">test</t>
<t tx="ekr.20040802071519"># Tests that c.setBodyString works immediately.
h = p.h

try:
    child = p.firstChild()
    before = child.b
    after = "after"
    c.setBodyString(child,"after")
    c.selectPosition(child)
    t = c.frame.body.bodyCtrl
    s = t.get("1.0","end")
    assert s.rstrip() == after.rstrip(), \
        "c.setBodyString failed: %s, %s" % (repr(s),repr(after))
finally:
    c.setBodyString(child,before)
    c.selectPosition(p)</t>
<t tx="ekr.20040802071519.1">after</t>
<t tx="ekr.20040803090901">import leo.core.leoTest as leoTest

path = g.os_path_join(g.app.loadDir,"..","dist","leoDist.leo")
leoTest.runLeoTest(c,path,verbose=False,full=True)
</t>
<t tx="ekr.20040831101747"># Apparently these file are fine when they are written.
# The problem comes later in the distribution process.

def checkLinuxLineEndings(filename):
    
    try:
        s = open(filename,"rb").read()
        cr = 0 ; nl = 0
        for ch in s:
            if ch == '\r': cr += 1
            if ch == '\n': nl += 1
        assert cr == 0, "Bad Linux line ending in %s: cr: %d, nl: %d" % (filename,cr,nl)
    except IOError:
        g.pr("checkLinuxLineEndings: can not open %s" % filename)
        raise

for file in ("install","uninstall"):
    checkLinuxLineEndings(g.os_path_join(g.app.loadDir,"..",file))</t>
<t tx="ekr.20040831104758">import leo.core.leoTest as leoTest

path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile3.leo")
leoTest.runLeoTest(c,path,verbose=False,full=True)
</t>
<t tx="ekr.20040917062206">assert(g.cantImport("xyzzy","during unit testing") is None)</t>
<t tx="ekr.20041001194357"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.doTests(c,all=False)
c.selectPosition(p)</t>
<t tx="ekr.20041001211817"></t>
<t tx="ekr.20041013062906"># This hack is needed only for tkinter gui.
if g.app.gui.guiName() == 'tkinter':
    p.OnHyperLinkControlClick(event=None)
</t>
<t tx="ekr.20041019124050">test1 = p.firstChild()
test2 = p.firstChild().next()

c.prettyPrintPythonCode(p=test2,dump=False)

assert(test2.b==test1.b)</t>
<t tx="ekr.20041019124050.1">"""
line 1
line 2
line 3
"""</t>
<t tx="ekr.20041019124050.2">"""
line 1
line 2
line 3
"""</t>
<t tx="ekr.20041021065844">import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20041021065844.1"># Test that @nosent generates no sentinels

&lt;&lt; section &gt;&gt;

@others

last linesection line 1unnamed node line 1</t>
<t tx="ekr.20041021065903"># Test that @nosent generates no sentinels

&lt;&lt; section &gt;&gt;

@others

last line</t>
<t tx="ekr.20041021065903.1">section line 1</t>
<t tx="ekr.20041021065903.2">unnamed node line 1</t>
<t tx="ekr.20041121151002"></t>
<t tx="ekr.20050104095950"># Switch EqualSizedPanes and ExecuteScript

# EqualSizedPanes = Ctrl+E
# ExecuteScript = Alt+Ctrl+E
# Exit = alt-ctrl-Z

# paste-text = Alt-Ctrl-V</t>
<t tx="ekr.20050105084757.1">import os

exists = g.os_path_exists

path = g.os_path_join(g.app.testDir,'xyzzy')
if exists(path):
    os.remove(path)
    
assert not exists(path)
assert not g.utils_remove(path,verbose=False)

f = open(path,'w')
f.write('test')
f.close()

assert exists(path)
assert g.utils_remove(path,verbose=True)
assert not exists(path)</t>
<t tx="ekr.20050105091547">import os

exists = g.os_path_exists
path = g.os_path_join(g.app.testDir,'xyzzy')
path2 = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths.
for p in (path,path2):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = open(p,'w')
    f.write('test %s' % p)
    f.close()
    assert exists(p)

assert g.utils_rename(c,path,path2) #,verbose=True)
assert exists(path2)
f = open(path2)
s = f.read()
f.close()
# print('Contents of %s: %s' % (path2,s))
assert s == 'test %s' % path
os.remove(path2)
assert not exists(path)</t>
<t tx="ekr.20050105093136">import os

at = c.atFileCommands
exists = g.os_path_exists

path = g.os_path_join(g.app.testDir,'xyzzy')
if exists(path):
    os.remove(path)
    
assert not exists(path)
assert not at.remove(path,verbose=False)

f = open(path,'w')
f.write('test')
f.close()

assert exists(path)
assert at.remove(path)
assert not exists(path)</t>
<t tx="ekr.20050105093524">import os

at = c.atFileCommands
exists = g.os_path_exists
path = g.os_path_join(g.app.testDir,'xyzzy')
path2 = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths.
for p in (path,path2):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = open(p,'w')
    f.write('test %s' % p)
    f.close()
    assert exists(p)

assert at.rename(path,path2,verbose=True)
assert exists(path2)
f = open(path2)
s = f.read()
f.close()
# print('Contents of %s: %s' % (path2,s))
assert s == 'test %s' % path
os.remove(path2)
assert not exists(path)</t>
<t tx="ekr.20050105094311">import os

at = c.atFileCommands
exists = g.os_path_exists

at.outputFileName = g.os_path_join(g.app.testDir,'xyzzy1')
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths (different contents)
for p in (at.outputFileName,at.targetFileName):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = open(p,'w')
    s = 'test %s' % p
    # print(repr(p),repr(s))
    f.write(s)
    f.close()
    assert exists(p) # , '%s does not exist' % repr(p)

at.toString = False # Set by execute script stuff.
at.shortFileName = at.targetFileName
root = at.root
assert at.replaceTargetFileIfDifferent(root), 'replaceTargetFileIfDifferent returns False'
if 0:
    print('%s exists %s' % (at.outputFileName,exists(at.outputFileName)))
    print('%s exists %s' % (at.targetFileName,exists(at.targetFileName)))
assert not exists(at.outputFileName), 'oops, output file exists'
assert exists(at.targetFileName), 'oops, target file does not exist'
f = open(at.targetFileName)
s = f.read()
f.close()
# print('Contents of %s: %s' % (at.targetFileName,s))
assert s == 'test %s' % at.outputFileName, 'unexpected contents of target file'
os.remove(at.targetFileName)</t>
<t tx="ekr.20050105095743">import os

at = c.atFileCommands
exists = g.os_path_exists

at.outputFileName = g.os_path_join(g.app.testDir,'xyzzy1')
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths (identical contents)
for p in (at.outputFileName,at.targetFileName):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = open(p,'w')
    s = 'test %s' % at.outputFileName
    # print(repr(p),repr(s))
    f.write(s)
    f.close()
    assert exists(p)

at.toString = False # Set by execute script stuff.
at.shortFileName = at.targetFileName
root = at.root
assert not at.replaceTargetFileIfDifferent(root), 'replaceTargetFileIfDifferent returns True'
if 0:
    print('%s exists %s' % (at.outputFileName,exists(at.outputFileName)))
    print('%s exists %s' % (at.targetFileName,exists(at.targetFileName)))
assert not exists(at.outputFileName), 'oops, output file exists'
assert exists(at.targetFileName), 'oops, target file does not exist'
f = open(at.targetFileName)
s = f.read()
f.close()
# print('Contents of %s: %s' % (at.targetFileName,s))
assert s == 'test %s' % at.outputFileName, 'unexpected contents of target file'
os.remove(at.targetFileName)</t>
<t tx="ekr.20050105100227">import os

at = c.atFileCommands
exists = g.os_path_exists

at.outputFileName = g.os_path_join(g.app.testDir,'xyzzy1')
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2')

# Remove both files, then create only the output file
for p in (at.outputFileName,at.targetFileName):
    if exists(p):
        os.remove(p)
        
for p in (at.outputFileName,):
    assert not exists(p)
    f = open(p,'w')
    s = 'test %s' % at.outputFileName
    # print(repr(p),repr(s))
    f.write(s)
    f.close()
    assert exists(p)

at.toString = False # Set by execute script stuff.
at.shortFileName = at.targetFileName
root = at.root
assert not at.replaceTargetFileIfDifferent(root), 'replaceTargetFileIfDifferent returns True'
if 0:
    print('%s exists %s' % (at.outputFileName,exists(at.outputFileName)))
    print('%s exists %s' % (at.targetFileName,exists(at.targetFileName)))
assert not exists(at.outputFileName), 'oops, output file exists'
assert exists(at.targetFileName), 'oops, target file does not exist'
f = open(at.targetFileName)
s = f.read()
f.close()
# print('Contents of %s: %s' % (at.targetFileName,s))
assert s == 'test %s' % at.outputFileName, 'unexpected contents of target file'
os.remove(at.targetFileName)</t>
<t tx="ekr.20050106080304">import glob
import inspect
import unittest

changed = c.isChanged() ; p1 = c.p
&lt;&lt; class testRoutineTestCase &gt;&gt;
@others

if 1: # Scan all Leo modules _except_ leoTest.py.
    modules = getAllLeoModules()
else: # Scan just leoTest.py.
    modules = ('leoTest',)

g.app.unitTestDict["fail"] = False

suite = unittest.makeSuite(unittest.TestCase)
for module in modules:
    n = addTestRoutinesInModuleToSuite(c,g,module,suite)
    if n:
        plural = g.choose(n==1,'','s')
        s = 'found %2d test routine%s for %s' % (n,plural,module)
        g.es_print(s)

if 1: # For @suite nodes.  Better for unit testing.
    g.app.scriptDict['suite'] = suite
else: # For script button nodes.  Good for testing.
    # Verbosity: 1: print just dots.
    unittest.TextTestRunner(verbosity=1).run(suite)
    c.setChanged(changed) # Restore changed state.
    c.selectVnode(p1) # N.B. Restore the selected node.
    
g.pr('\nEnd of test routines')</t>
<t tx="ekr.20050106080318">def addTestRoutinesInModuleToSuite (c,g,moduleName,suite):
    
    module = g.importModule(moduleName)
    if not module: return 0 # leoScriptModule may have errors.

    tests = findTestsInModule(module,moduleName)
    
    for test in tests:
        theClass,f = test
        code = inspect.getsource(f)
        testCase = testRoutineTestCase(c,g,moduleName,theClass,f,code,verbose=False)
        suite.addTest(testCase)
        
    return len(tests)</t>
<t tx="ekr.20050106080318.1">class testRoutineTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others</t>
<t tx="ekr.20050106080318.2">def __init__ (self,c,g,moduleName,theClass,f,code,verbose=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.moduleName = moduleName
    self.theClass = theClass
    self.f = f
    self.g = g
    self.code = code
    self.p = c.p.copy()
    self.verbose = verbose
</t>
<t tx="ekr.20050106080318.3">def fail (self,msg=None):

    """Mark a unit test as having failed."""
    
    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20050106080318.6">def runTest (self):
    
    f = self.f ; name = f.__name__ ; theClass = self.theClass
    
    d = {'c':self.c,'g':self.g,'p':self.p}

    if 1: # Use dead text to ensure a clean environment.
        # The present code assumes all leading whitespace is consistent.
        code = removeLeadingWs(self.code)
        # The code is a def statement.  We concoct a call to the function or method.
        if theClass:
            s = '%s\n%s(self=None)\n' % (code,name)
        else:
            s = '%s\n%s()\n' % (code,name)
            
        if self.verbose:
            g.trace('executing...\n\n%s' % s)

        exec s in d # Execute s in a environment containing c, g and p.
        
    else: # Use live objects.
        if theClass:
            # Create a subclass of f's original class.
            class __dummyClass(theClass):
                # Create a ctor with a known signature.
                def __init__(self): pass
            # Make f a method of the dummyClass with name 'f'.
            # N.B. f is still a method of theClass, and must be called as such!
            if 0: # Override the method with f's actual name.
                g.funcToMethod(f,__dummyClass,name)
                obj = __dummyClass()
                f = getattr(obj,name)
                f(obj)
            else:
                # Use the name 'f' for f's name.
                g.funcToMethod(f,__dummyClass,'f')
                # Create an instance of __dummyClass and call it's f method.
                obj = __dummyClass()
                obj.f()
        else: # Execute a plain function.
            f(**keys)</t>
<t tx="ekr.20050106080318.7">def shortDescription (self):

    return 'test function',repr(self.f)</t>
<t tx="ekr.20050106081120.2">def findTestsInModule (module,moduleName):
    
    toString = g.listToString
    try:
        functions = inspect.getmembers(module,inspect.isfunction)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isfunction) for %s' % moduleName)
        functions = []
    try:
        classes   = inspect.getmembers(module,inspect.isclass)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isclass) for %s' % moduleName)
        classes = []

    # Ignore subclasses of TestCase.
    classes = [theClass for className,theClass in classes
        if not issubclass(theClass,unittest.TestCase)]
        
    # April 6, 2005: Ignore base classes.
    subClasses = []
    for theClass in classes:
        for theClass2 in classes:
            if theClass != theClass2 and issubclass(theClass2,theClass):
                subClasses.append(theClass2)
        
    # g.pr('%20s' % (moduleName),'subClasses',g.listToString(subClasses))
    
    baseClasses = []
    for theClass in classes:
        for subClass in subClasses:
            if theClass != subClass and issubclass(subClass,theClass):
                baseClasses.append(theClass)
                
    # g.pr('%20s' % (moduleName),'baseClasses',g.listToString(baseClasses))
    
    classes = [theClass for theClass in classes
        if theClass in subClasses or not theClass in baseClasses]
        
    if 0:
        classNames = [theClass.__name__ for theClass in classes]
        g.pr('%20s' % (moduleName),'classes',classNames)
    
    allMethods = []
    for theClass in classes:
        try:
            methods = inspect.getmembers(theClass,inspect.ismethod)
        except Exception:
            g.trace('Exception in inspect.getmembers(theClass,inspect.ismethod) for %s' % moduleName)
            methods = []
        # g.pr('\nmethods of class %s...\n\n%s' % (theClass,toString(methods)))
        methods = [(theClass,f) for name,f in methods if name.startswith('test_')]
        allMethods.extend(methods)

    functions = [(None,f) for name,f in functions if name.startswith('test_')]

    if 0:
        &lt;&lt; print classes, methods &amp; functions &gt;&gt;
    if 0:
        if functions:
            g.pr('test functions in %s...\n%s' % (moduleName,toString(functions)))
    
    result = functions
    result.extend(allMethods)
    return result</t>
<t tx="ekr.20050106094747">def addTestRoutinesInCommanderToSuite(c,suite):
    
    tests = findTestsInCommander(c)
    
    for test in tests:
        testCase = commanderTestCase(c,test)
        suite.addTest(testCase)</t>
<t tx="ekr.20050106094854">class commanderTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others</t>
<t tx="ekr.20050106094854.1">def __init__ (self,c,test):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.test = test</t>
<t tx="ekr.20050106094854.2">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    
    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20050106094854.5">def runTest (self):

    # Try to run the function.
    self.test()</t>
<t tx="ekr.20050106094854.6">def shortDescription (self):

    return 'test function',repr(self.test)</t>
<t tx="ekr.20050106095223">def findTestsInCommander (c):
    
    g.pr('=' * 40)
    
    toString = g.listToString

    allMethods = []
    for obj in (c,c.frame,c.frame.tree):
        methods = inspect.getmembers(obj,inspect.ismethod)
        # g.pr('\nmethods of %s...\n\n%s' % (obj,toString(methods)))
        methods = [f for name,f in methods if name.startswith('test')]
        allMethods.extend(methods)
        g.pr('\ntest methods in %s...\n\n%s'   % (obj,toString(methods)))

    return allMethods</t>
<t tx="ekr.20050106123646">if 0:
    @others</t>
<t tx="ekr.20050106124235">g.pr('=' * 40)

if classes:
    g.pr('classes in %s...\n%s' % (moduleName,toString(classes)))
else:
    g.pr('no classes in %s' % (moduleName))
if allMethods:
    g.pr('test methods in %s...\n%s'   % (moduleName,toString(allMethods)))
else:
    g.pr('no test methods in %s' % (moduleName))
if functions:
    g.pr('test functions in %s...\n%s' % (moduleName,toString(functions)))
else:
    g.pr('no test functions in %s' % (moduleName))</t>
<t tx="ekr.20050106124624">def getAllLeoModules ():

    path = g.os_path_join(g.app.loadDir,"..","src")

    files = glob.glob(g.os_path_join(path,"leo*.py"))
    files = [g.os_path_abspath(f) for f in files]
    files = [str(g.shortFileName(f)) for f in files]
    files.sort()
    
    # This caused duplicates
    # modules = [g.os_path_splitext(f)[0] for f in files]
    
    modules = []
    for f in files:
        module = g.os_path_splitext(f)[0]
        if module not in modules:
            modules.append(module)
    
    if 'leoTest' in modules:
        modules.remove('leoTest')
    
    # g.trace(g.listToString(modules))
    return modules</t>
<t tx="ekr.20050106133147">def removeLeadingWs (code):

    if not code.strip():
        return ''

    lines = g.splitLines(code)
    line = lines[0]
    i = g.skip_ws(line,0)
    ws = line[0:i]
    if not ws:
        return code
    result = [] ; n = len(ws)
    for line in lines:
        if line.startswith(ws):
            result.append(line[n:])
        elif not line.strip() and line.endswith('\n'):
            result.append('\n')
        else:
            g.pr('unitTest.leo:underindented line:%s' % repr(line))
            result.append(line)
            
    # g.trace(g.listToString(result))

    result = ''.join(result)
    return result</t>
<t tx="ekr.20050112095306.1"></t>
<t tx="ekr.20050120095423"></t>
<t tx="ekr.20050120095423.11"># Create unit tests in g.app.scriptDict["suite"]
import leo.core.leoPlugins as leoPlugins
import leo.core.leoTest as leoTest
import glob
import sys
import unittest

@others

suite = makePluginsTestSuite(c)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20050120095423.12">def makePluginsTestSuite(c):

    '''Create a plugin test for .py file in the plugins directory'''

    # Create the suite.
    suite = unittest.makeSuite(unittest.TestCase)

    # Add a test case for every plugin.
    plugins = g.os_path_join(g.app.loadDir,'..','plugins','*.py')
    plugins = g.os_path_abspath(plugins)
    files = glob.glob(plugins)
    files = [g.os_path_abspath(f) for f in files]
    files.sort()

    for f in files:
        test = pluginTestCase(c,f)
        # g.trace(test.shortDescription())
        suite.addTest(test)
        
    if 1:
        # Open a new window after all tests are completed.  Tests many plugins.
        lastTest = lastTestCase(c,openFlag=True)
        suite.addTest(lastTest)

    return suite</t>
<t tx="ekr.20050120095423.13">class pluginTestCase(unittest.TestCase):

    '''A test case to test a single Leo plugin.'''

    @others</t>
<t tx="ekr.20050120095423.14">def __init__ (self,c,path):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path</t>
<t tx="ekr.20050120095423.15">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20050120095423.16">def runTest(self):

    c = self.c ; path = self.path
    
    path,file = g.os_path_split(path)
    moduleName,ext  = g.os_path_splitext(file)
    module = sys.modules.get(moduleName)

    if not module:
        module = leoPlugins.loadOnePlugin(moduleName,verbose=False)
        assert module, 'can not import %s' % moduleName</t>
<t tx="ekr.20050120095423.17">def setUp(self):

    g.app.unitTestDict = {}</t>
<t tx="ekr.20050120095423.18">def shortDescription (self):

    return "pluginTestCase: %s" % g.shortFileName(self.path)</t>
<t tx="ekr.20050120095423.20">class lastTestCase(unittest.TestCase):

    '''A test case to print a message at the end of plugin tests.'''
    
    def __init__ (self,c,openFlag):
        # Init the base class.
        unittest.TestCase.__init__(self)
        self.c = c
        self.openFlag = openFlag

    def runTest(self):
        c = self.c
        print('\n%s a new window to test more plugin logic\n' % g.choose()
            self.openFlag,'opening','open')
        if self.openFlag:
            self.new_c = new_c = c.new() # Create the new window.
            new_c.frame.setTitle("unit test for 'new' hook")
            
    if 0: # Doesn't work
        def shutDown(self):
            c = self.new_c
            c.close()</t>
<t tx="ekr.20050120095423.21">import leo.core.leoPlugins as leoPlugins

print('\nloaded plugins...')

for p in g.app.loadedPlugins:
    print(p)
    
leoPlugins.printHandlers()</t>
<t tx="ekr.20050203001146"># g.es(c.page_width)

assert c.page_width == 80</t>
<t tx="ekr.20050203084930.1">w = g.app.config.get(None,'global_setting_for_unit_tests','int')

assert w == 132</t>
<t tx="ekr.20050206090416">@first # -*- coding: utf-8 -*-

if g.isPython3:
    # Do not call g.ue: it will crash.
    theFile = ''
else:
    theFile = g.ue('','utf-8')

path = g.os_path_join('','')
# print(g.toEncodedString(theFile,'utf-8'))

ok,frame = g.openWithFileName(path,c)

assert not ok and not frame</t>
<t tx="ekr.20050206201145">@first # -*- coding: utf-8 -*-

s = "test(U+1FB9: Greek Capital Letter Alpha With Macron)"

s2 = 'test: %s' % s</t>
<t tx="ekr.20050208051418"></t>
<t tx="ekr.20050208051418.1">@first # -*- coding: utf-8 -*-

old_c = c
filename = "test(U+1FB9: Greek Capital Letter Alpha With Macron)"
ok,frame = g.openWithFileName(filename,old_c)
assert(not ok)</t>
<t tx="ekr.20050208051854">@first # -*- coding: utf-8 -*-

at = c.atFileCommands
at.errors = 0

if g.isPython3:
    # Do not call g.ue: it will crash.
    s = 'La Pea'
else:
    s = g.ue('La Pea','utf-8')

at.printError('test of at.printError:',s)

# important: this test will fail if sitecustomize.py
# does not contain sys.setdefaultencoding('utf-8')</t>
<t tx="ekr.20050208073718">import sys

if sys.platform.startswith('win'):

    import os
    
    # g.es("tkEncoding",g.app.tkEncoding,color='orange')
    
    # These work only with utf-8 encoding.  Fails with g.app.TkEncoding &amp; 'mbcs'
    for folder,file in (
        ('chinesefolder', 'chinesetest.leo'),
        (u'chinese\u8116folder',u'chinese\u8116test.leo'),
    ):
        s = g.os_path_join(g.app.loadDir,'..','test','unittest',folder,file,encoding='utf-8')
    
        assert g.os_path_exists(s), 'g.os_path_exists fails'
        assert os.path.exists(s),   'os.path.exists fails'
    
        ok,frame = g.openWithFileName(s,c)
        if frame: frame.c.close()
        assert ok and frame, 'did not open'</t>
<t tx="ekr.20050208104202">@first # -*- coding: utf-8 -*-

if not g.isPython3: # Does not work with Python 3.x

    for s,encoding in (
        ('a',    'utf-8'),
        ('a',    'ascii'),
        ('',  'utf-8'),
        ('',  'mbcs'),
        ('',    'utf-8'),
        ('',    'mbcs'),
    ):
        if g.isValidEncoding(encoding):
            s2,ok = g.toUnicodeWithErrorCode(s,encoding)
            assert ok, 'toUnicodeWithErrorCode fails for %s' %s
            s3,ok = g.toEncodedStringWithErrorCode(s2,encoding)
            assert ok, 'toEncodedStringWithErrorCode fails for %s' % s2
            assert s3 == s, 'Round-trip one fails for %s' %s
            
            s2 = g.toUnicode(s,encoding)
            s3 = g.toEncodedString(s2,encoding)
            assert s3 == s, 'Round-trip two fails for %s' %s</t>
<t tx="ekr.20050208111037">@first # -*- coding: utf-8 -*-

encoding = 'ascii'

if g.isPython3:
    s = '' # This is already unicode.
    s2,ok = g.toUnicodeWithErrorCode(s,encoding)
    assert ok, 'toUnicodeWithErrorCode returns False for %s with ascii encoding' % s
    
    s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
    assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s
else:
    s = '' # An encoded string.
    s2,ok = g.toUnicodeWithErrorCode(s,encoding)
    assert not ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s
    
    s = g.ue('','utf-8') # Must use utf-8 encoding *here*
    s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
    assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s</t>
<t tx="ekr.20050208135429"># print(g.listToString(dir()))

for ivar in ('c','g','p'):
    assert ivar in dir()
</t>
<t tx="ekr.20050218015346">import glob
import inspect
import unittest

changed = c.isChanged() ; p1 = c.p
&lt;&lt; class testRoutineTestCase &gt;&gt;
@others

plugins = getAllPlugins()

# g.printList(plugins)

print('@suite run all plugin test routines')

if 1:
    g.app.unitTestDict["fail"] = False
    suite = unittest.makeSuite(unittest.TestCase)
    for plugin in plugins:
        n = addTestRoutinesInPluginToSuite(c,g,plugin,suite)
        if n:
            plural = g.choose(n==1,'','s')
            s = 'found %2d test routine%s for %s' % (n,plural,plugin)
            g.es_print(s)
    if 1: # For @suite nodes.  Better for unit testing.
        g.app.scriptDict['suite'] = suite
    else: # For script button nodes.  Good for testing.
        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=1).run(suite)
        c.setChanged(changed) # Restore changed state.
        c.selectVnode(p1) # N.B. Restore the selected node.</t>
<t tx="ekr.20050218015346.11">class testRoutineTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others</t>
<t tx="ekr.20050218015346.12">def __init__ (self,c,g,moduleName,theClass,f,code,verbose=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.moduleName = moduleName
    self.theClass = theClass
    self.f = f
    self.g = g
    self.code = code
    self.p = c.p.copy()
    self.verbose = verbose
</t>
<t tx="ekr.20050218015346.13">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20050218015346.16">def runTest (self):
    
    f = self.f ; name = f.__name__ ; theClass = self.theClass
    
    d = {'c':self.c,'g':self.g,'p':self.p}

    if 1: # Use dead text to ensure a clean environment.
        # The present code assumes all leading whitespace is consistent.
        code = removeLeadingWs(self.code)
        # The code is a def statement.  We concoct a call to the function or method.
        if theClass:
            s = '%s\n%s(self=None)\n' % (code,name)
        else:
            s = '%s\n%s()\n' % (code,name)
            
        if self.verbose:
            g.trace('executing...\n\n%s' % s)

        exec s in d # Execute s in a environment containing c, g and p.
        
    else: # Use live objects.
        if theClass:
            # Create a subclass of f's original class.
            class __dummyClass(theClass):
                # Create a ctor with a known signature.
                def __init__(self): pass
            # Make f a method of the dummyClass with name 'f'.
            # N.B. f is still a method of theClass, and must be called as such!
            if 0: # Override the method with f's actual name.
                g.funcToMethod(f,__dummyClass,name)
                obj = __dummyClass()
                f = getattr(obj,name)
                f(obj)
            else:
                # Use the name 'f' for f's name.
                g.funcToMethod(f,__dummyClass,'f')
                # Create an instance of __dummyClass and call it's f method.
                obj = __dummyClass()
                obj.f()
        else: # Execute a plain function.
            f(**keys)</t>
<t tx="ekr.20050218015346.17">def shortDescription (self):

    return 'test function',repr(self.f)</t>
<t tx="ekr.20050218015346.18">def addTestRoutinesInPluginToSuite (c,g,pluginName,suite):
    
    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    
    plugin = g.importFromPath(pluginName,path,verbose=True)
    if not plugin:
        return len([])

    tests = findTestsInModule(plugin,pluginName)
    
    for test in tests:
        theClass,f = test
        code = inspect.getsource(f)
        testCase = testRoutineTestCase(c,g,pluginName,theClass,f,code,verbose=False)
        suite.addTest(testCase)
        
    return len(tests)
</t>
<t tx="ekr.20050218015346.19">def findTestsInModule (module,moduleName):
    
    # g.trace(moduleName)
    
    toString = g.listToString
    try:
        functions = inspect.getmembers(module,inspect.isfunction)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isfunction) for %s' % moduleName)
        functions = []
    try:
        classes = inspect.getmembers(module,inspect.isclass)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isclass) for %s' % moduleName)
        classes = []

    # Ignore subclasses of TestCase.
    classes = [theClass for className,theClass in classes
        if not issubclass(theClass,unittest.TestCase)]
    
    allMethods = []
    for theClass in classes:
        try:
            methods = inspect.getmembers(theClass,inspect.ismethod)
        except Exception:
            # This looks like a bug in inspect: The zodb classes have no methods.
            # g.trace('Exception in inspect.getmembers(theClass,inspect.ismethod) for %s' % moduleName)
            methods = []
        # print('\nmethods of class %s...\n\n%s' % (theClass,toString(methods)))
        methods = [(theClass,f) for name,f in methods if name.startswith('test_')]
        allMethods.extend(methods)

    # Hack: remove duplicate tests from leoGlobals.py.
    functions = [(None,f) for name,f in functions
        if name.startswith('test_') and not name.startswith('test_g_')]

    if 0:
        &lt;&lt; print classes, methods &amp; functions &gt;&gt;
    
    result = functions
    result.extend(allMethods)
    return result</t>
<t tx="ekr.20050218015346.20">print('=' * 40)

if classes:
    print('classes in %s...\n%s' % (moduleName,toString(classes)))
else:
    print('no classes in %s' % (moduleName))
if allMethods:
    print('test methods in %s...\n%s'   % (moduleName,toString(allMethods)))
else:
    print('no test methods in %s' % (moduleName))
if functions:
    print('test functions in %s...\n%s' % (moduleName,toString(functions)))
else:
    print('no test functions in %s' % (moduleName))</t>
<t tx="ekr.20050218015346.22">def removeLeadingWs (code):

    if not code.strip():
        return ''

    lines = g.splitLines(code)
    line = lines[0]
    i = g.skip_ws(line,0)
    ws = line[0:i]
    if not ws:
        return code
    result = [] ; n = len(ws)
    for line in lines:
        if line.startswith(ws):
            result.append(line[n:])
        elif not line.strip() and line.endswith('\n'):
            result.append('\n')
        else:
            print('unitTest.leo:underindented line:%s' % repr(line))
            result.append(line)
            
    # g.trace(g.listToString(result))

    result = ''.join(result)
    return result
</t>
<t tx="ekr.20050328101834"></t>
<t tx="ekr.20050328101834.1"></t>
<t tx="ekr.20050328101834.2"></t>
<t tx="ekr.20050328101834.3"></t>
<t tx="ekr.20050417095020.11"># Honor the first line's leading whitespace.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,5,16)
</t>
<t tx="ekr.20050417095020.12"># Honor the first and second line's leading whitespace.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,5,16)
</t>
<t tx="ekr.20050417095020.13"># Single paragraph, hanging indentation.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,5,8)
</t>
<t tx="ekr.20050417095020.14"># Single paragraph, hanging indentation with other indentation beyond line 2.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,5,8)</t>
<t tx="ekr.20050417095020.15"># Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,5,8)</t>
<t tx="ekr.20050417095124.16">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.17">This line is under 40 chars.</t>
<t tx="ekr.20050417095124.18">This line is under 40 chars.</t>
<t tx="ekr.20050417095124.19">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.20">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20050417095124.21">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20050417095124.22">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.23">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20050417095124.24">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20050417095124.25">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.26">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20050417095124.27">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20050417095124.28">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.29">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20050417095124.30">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20050417095124.31">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.32">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.</t>
<t tx="ekr.20050417095124.33">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20050417095124.34">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.35">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20050417095124.36">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20050417095124.37">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

</t>
<t tx="ekr.20050417095124.38">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20050417095124.39">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20050417095124.40">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
</t>
<t tx="ekr.20050417095124.41">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20050417095124.42">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20050417095124.43">@language plain
@pagewidth 40
@tabwidth 8

</t>
<t tx="ekr.20050417095124.44">This paragraph leads of this test.  It is the "lead"
paragraph.
  
  1. This is item 
     number 1.  It is the first item in the list.
  
  2. This is item 
     number 2.  It is the second item in the list.
  
  3. This is item 
     number 3.  It is the third item in the list.
  
This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20050417095124.45">This paragraph leads of this test. It is
the "lead" paragraph.
  
  1. This is item number 1. It is the
     first item in the list.
  
  2. This is item number 2. It is the
     second item in the list.
  
  3. This is item number 3. It is the
     third item in the list.
  
This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20050417102057">@ Rewritten by EKR.  April 17, 2005.

Each data node must have three children:
    
- a "before" node
- an "after" node
- a "tempNode" node

A parent to before and after nodes will contain pagewidth and language formatting directives.</t>
<t tx="ekr.20050417102114"># Wrap a long line, no trailing newline.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,2,24)</t>
<t tx="ekr.20050417102114.1">This line is over forty characters long, at least it seems to be.</t>
<t tx="ekr.20050417102114.2">This line is over forty characters long,
at least it seems to be.</t>
<t tx="ekr.20050417104821">@language plain
@pagewidth 40
@tabwidth 8

</t>
<t tx="ekr.20050417111144"># Wrap a long line, with trailing newline.

import leo.core.leoTest as leoTest

# Wrap a long line, no trailing newline.
leoTest.singleParagraphTest(c,p,3,0)</t>
<t tx="ekr.20050417111144.1">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417111144.2">This line is over forty characters long, at least it seems to be.
</t>
<t tx="ekr.20050417111144.3">This line is over forty characters long,
at least it seems to be.
</t>
<t tx="ekr.20050417111240"></t>
<t tx="ekr.20050417113549"># Wrap a long line and some short ones.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,4,10)</t>
<t tx="ekr.20050417113910">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417113910.1">This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.</t>
<t tx="ekr.20050417113910.2">This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.</t>
<t tx="ekr.20050417113921"></t>
<t tx="ekr.20050417114153"># Wrap a paragraph with interior lines that have leading white space.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,4,12)</t>
<t tx="ekr.20050417114221">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417114221.1"></t>
<t tx="ekr.20050417114221.2">This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.</t>
<t tx="ekr.20050417114221.3">This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.</t>
<t tx="ekr.20050417114836"># No wrapping required, so don't change a thing.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,1,28)
</t>
<t tx="ekr.20050417114914"></t>
<t tx="ekr.20050417115111"></t>
<t tx="ekr.20050417115257"></t>
<t tx="ekr.20050417115414"></t>
<t tx="ekr.20050417115559"></t>
<t tx="ekr.20050417115709"></t>
<t tx="ekr.20050417120312.1"># Multiple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.

import leo.core.leoTest as leoTest

leoTest.multiParagraphTest(c,p)</t>
<t tx="ekr.20050417120312.2"></t>
<t tx="ekr.20050417121448"># A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.
# Cursor should move to next paragraph after formatting a paragraph.

import leo.core.leoTest as leoTest

leoTest.multiParagraphWithListTest(c,p)</t>
<t tx="ekr.20050417121448.1"></t>
<t tx="ekr.20050417121942">@
Ran into a problem with the wrapping eating blank lines that delimit paragraphs
if those blank lines have any leading whitespace. This test is to make sure that
still works.

If you "show invisibles" you'll see the leading whitespace in the blank lines --
which is different from the "testMultiParagraphWithList" test.
@c

import leo.core.leoTest as leoTest

leoTest.leadingWSOnEmptyLinesTest(c,p)</t>
<t tx="ekr.20050417121942.1"></t>
<t tx="ekr.20050417122215.1">import leo.core.leoTest as leoTest

leoTest.directiveBreaksParagraphTest(c,p)</t>
<t tx="ekr.20050417122215.2"></t>
<t tx="ekr.20050417124704"></t>
<t tx="ekr.20050417201845"></t>
<t tx="ekr.20050417201845.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050417201845.2">before
after</t>
<t tx="ekr.20050417201845.3">sec line 1
    sec line 2 indented
sec line 3</t>
<t tx="ekr.20050417201845.4">2.0
5.10</t>
<t tx="ekr.20050417202713"></t>
<t tx="ekr.20050417202713.1">@language python

def addCommentTest():

    if 1:
        a = 2
        b = 3
        
    pass</t>
<t tx="ekr.20050417202713.2">@language python

def addCommentTest():

    # if 1:
        # a = 2
        # b = 3
        
    pass</t>
<t tx="ekr.20050417202713.3">5.0
7.8</t>
<t tx="ekr.20050417202817"></t>
<t tx="ekr.20050417202817.1">@language python

def deleteCommentTest():

    # if 1:
        # a = 2
        # b = 3
        
    pass</t>
<t tx="ekr.20050417202817.2">@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3
        
    pass</t>
<t tx="ekr.20050417202817.3">5.0
7.8</t>
<t tx="ekr.20050417203114"></t>
<t tx="ekr.20050417203114.1"></t>
<t tx="ekr.20050417203310">@tabwidth -4

line 1
    line 2
      line 3
line4</t>
<t tx="ekr.20050417203310.1">@tabwidth -4

line 1
	line 2
	  line 3
line4</t>
<t tx="ekr.20050417203336">1.0
6.5</t>
<t tx="ekr.20050417204830">@tabwidth -4

line 1
    line 2
      line 3
line4</t>
<t tx="ekr.20050417204834">@tabwidth -4

line 1
	line 2
	  line 3
line4</t>
<t tx="ekr.20050417204901">1.0
6.5</t>
<t tx="ekr.20050417204940"></t>
<t tx="ekr.20050417204940.1">@tabwidth -4

line 1
    line 2
      line 3
line4</t>
<t tx="ekr.20050417204940.2">@tabwidth -4

line 1
	line 2
	  line 3
line4</t>
<t tx="ekr.20050417204940.3">1.0
6.5</t>
<t tx="ekr.20050417205012"></t>
<t tx="ekr.20050417205012.1">@tabwidth -4

line 1
	line 2
	  line 3
line4</t>
<t tx="ekr.20050417205012.2">@tabwidth -4

line 1
    line 2
      line 3
line4</t>
<t tx="ekr.20050417205012.3">1.0
6.5</t>
<t tx="ekr.20050512083700.1">marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.markChangedHeadlines()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)
                
if not ok: raise</t>
<t tx="ekr.20050512083807">marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.markChangedRoots()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)
                
if not ok: raise</t>
<t tx="ekr.20050512083807.1">marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.markAllAtFileNodesDirty()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)
                
if not ok: raise</t>
<t tx="ekr.20050512083807.2">marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.markAtFileNodesDirty()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)
                
if not ok: raise</t>
<t tx="ekr.20050512083816">marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.markClones()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)
                
if not ok: raise</t>
<t tx="ekr.20050512083822">marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.markHeadline()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)
                
if not ok: raise</t>
<t tx="ekr.20050512083822.1">marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.markSubheads()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)
                
if not ok: raise</t>
<t tx="ekr.20050512083822.2">marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.unmarkAll()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise</t>
<t tx="ekr.20050512084850"></t>
<t tx="ekr.20050512084850.1">pass</t>
<t tx="ekr.20050512084850.2">pass</t>
<t tx="ekr.20050518070540"></t>
<t tx="ekr.20050518070540.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050518070540.4">2.0
2.16</t>
<t tx="ekr.20050518070545">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050518070927"></t>
<t tx="ekr.20050518070927.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050518070927.2">before
    &lt;&lt; section &gt;&gt;
after</t>
<t tx="ekr.20050518070927.3">sec line 1
    sec line 2 indented
sec line 3</t>
<t tx="ekr.20050518070927.4">2.0
5.10</t>
<t tx="ekr.20050518071251"></t>
<t tx="ekr.20050518071251.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050518071251.4">2.0
2.16</t>
<t tx="ekr.20050518071258">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050618061835">@killcolor

Here is a tutorial written by Roger Erens.

Version Date        LeoID       Remarks
------- ----        -----       -------
0.1     20050519    rogererens  Initial version</t>
<t tx="ekr.20050618061835.1">So you think "Well, since I've written this piece of funky Python software, and everybody keeps saying how useful unit testing is, I really ought to start using unit tests." And since Leo's creator has said countless times in the Leo forums how easy unit testing in Leo is, a few uncomplicated examples might help convince you that he's not spamming.

Beware: this How-To should be the last time that you write tests AFTER having written your funky software! Test Driven Development dictates that tests have to be prepared BEFORE you get down to writing your actual code. See a nice tutorial on O'Reilly's website (url given in the descendant node).</t>
<t tx="ekr.20050618061835.10">Start of Do @test
F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Documents and Settings\re1705\My Documents\PythonStuff\leo\src\leoTes
t.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.010s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.11">A real fun feature of Leo is that Leo saves you from having to select each and single @test node and press the 'Do @test' button to obtain testing results. Just collecting the @test nodes under an organizing node, selecting that organizing node, and pressing the 'Do @test' button will suffice.
Of course, this was one of the key ideas of unit testing, but it's nice to see it being implemented by Leo so smoothly!

So, press the button while having this node selected, and see if your console's output matches the third child node more or less. </t>
<t tx="ekr.20050618061835.12">Start of Do @test
.F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 2 tests in 0.040s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.13">Okay: so you've seen now some simple stand-alone tests to get your toes wet.
Now, we get to the 'grande finale' and see real-life usage of the @test nodes.

The @test child node below illustrates the following points:

1.  The node imports the module to test (and keeps it up to date by reloading it).
2.  It also obtains data to use as input and referral. This is what you might call
    the setUp methods in traditional unit tests. If more tests need the same data,
    you can put the nodes in a central place where all the @test nodes can find
    them. Likewise, common code for several unit tests might be collected in a
    central place.
3.  Comparable with the traditional unit tests' tearDown method, some statements
    can follow the test itself, if neccessary. You might also consider using a
    try/finally construct.
4.  I have used g.es() statements instead of print statements, since the latter
    clutter the console. Try replacing the g.es() statements by corresponding
    print statements to see what I mean. With more than one @test node being tested,
    this will give quite a dreadful look.</t>
<t tx="ekr.20050618061835.14">@color

try:
    # SETUP
    import koekiemonster # this module defines a function want() which we want to test
    reload(koekiemonster) # changes in koekiemonster need to propagate to the test

    # obtaining the input parameter for the function
    inputNode = p.firstChild()
    inputData = inputNode.b
    
    # obtaining the expected result from the function with above input parameter
    expectedResultNode = inputNode.next()
    expected = expectedResultNode.b
    
    # execute the function with above input parameter
    result = koekiemonster.wants(inputData)
    
    # TEST
    assert(result == expected)
    
    # TEARDOWN
    g.es("Now it's time to clean up")

except AssertionError:
    # TEARDOWN
    g.es("Oh oh! %s failed:" % p.h.strip())
    g.es("koekiemonster.wants(%s)==%s" % (inputData, result))
    g.es("Expected: %s" % expected)
    raise # pass the exception on to the unit test machinery</t>
<t tx="ekr.20050618061835.15">vegetables</t>
<t tx="ekr.20050618061835.16">Yuck!</t>
<t tx="ekr.20050618061835.17">Start of Do @test
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.070s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.18">Start of Do @test
Oh oh: @test koekiemonster.wants() failed:
koekiemonster.wants(vegetables)=Yack!
Expected: Yuck!
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.051s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.19">With the aforementioned possibilities of running all @test nodes in a subtree with a single click on a button, the sharing of input/expected data, and the sharing of setUp/tearDown code, there hardly seems a need for the @suite nodes.

On Leo's website (http://webpages.charter.net/edreamleo/scripting.html#unit-testing-with-test-and-suite) I could still find some extra info on @suite nodes, not found in LeoDocs.leo:

&lt;quote&gt;

Using @suite nodes

Such nodes create a suite of tests. Leo executes the script in these nodes similar to @test nodes, but Leo assumes that the script in an @suite node will do the following:

    * Create a suite of unit tests
    * Put the suite in g.app.scriptDict["suite"]

The difference between @test and @suite is:

    * Leo creates a unit test from script in an @test node by creating an instance of generalTestCase, a subclass of unittest.TestCase.
    * The script in an @suite node creates the test suite.

An @suite nodes allows us to create "legacy" unit tests simply. For example, rather than rewriting all the reformatParagraph unit tests to use @test nodes, I simply wrote an @suite node with the following body.
import leoGlobals as g
import leoTest ; reload(leoTest)
suite = leoTest.makeReformatParagraphSuite()
g.app.scriptDict['suite'] = suite

&lt;/quote&gt;

Well, that's almost, but not quite completely, totally incomprehensible to me. Fortunately, since Leo's creator removed most of this quote from LeoDocs.leo and test.leo, this information appears to be outdated.</t>
<t tx="ekr.20050618061835.2"></t>
<t tx="ekr.20050618061835.20">Don't forget to read the node
Users Guide--&gt;Chapter 7: Scripting Leo with Python--&gt;Unit testing with @test, @suite
in LeoDocs.leo, especially the final notes. Also investigate a little further in test.leo to see some heavy weight lifting.

This concludes my How-To on using @test. It was not written by an expert on (unit) testing;
it is more or less the result of keeping notes on my way to find out how I could get started
with unit tests in Leo. Maybe it's useful for other newbies as well.

Please post any remarks on one of the Leo Fora, and if deemed helpful, I'll be glad to incorporate them into a next version.

Happy testing!</t>
<t tx="ekr.20050618061835.3">Comment by EKR: There is no need to do this if you use test.leo for your unit tests:  just use the unit test button.

From the console, start up a Leo instance. On MS Windows: go to the folder in which you installed Leo 4.3, open up the 'src' folder and double click the 'leo.py' file. Opening a command window, and typing "python leo.py" may be another way.

Use the File--&gt;Open... menu item to open the outline containing your code.

Choose a good-looking position to insert a new node called 'Test zone'. Copy the child node of the node you're reading right now, and paste it as a child node of 'Test zone'. The code it contains is essentially the same as found in the node
Unit tests...--&gt;Do @test
in the file 'test.leo' in the 'test' folder. I just added my 0.2 cents by adding some starting and finishing remarks. Remove them if they clutter your console too much.

Also, make sure that you have an entry 'Scripting' in the 'Plugins' menu (enable the plugin if neccessary). Now is a good time to save your leo file.

With the 'Scripting' plugin (also known as the 'mod_scripting' plugin) enabled, the net effect will be that the next time you open your outline, a blue button with the caption 'Do @test' shows up in the tool bar of Leo, if your screen is wide enough.
To get the button right away in the tool bar, I have to assume that you started Leo with the scripting plugin enabled. In this case, a yellow button with the caption 'script Button' can be pressed while having the node '@button Do @test' selected. Note: the resulting button will not be blue, but pink. Removing a button from the tool bar can be done by right-clicking it.

We'll see the use of this added button soon, but before that, read up on the 'assert' function in the Python manuals, since it is used a lot in testing. It won't be long before you're back here!</t>
<t tx="ekr.20050618061835.4">@color

import leoTest

g.pr("\nStart of Do @test")
leoTest.doTests(c,all=False)
g.pr("End of Do @test")</t>
<t tx="ekr.20050618061835.5">The first child node of the node you're reading right now, contains the simplest succeeding test possible.
Select it, and press the button 'Do @test'.
You can find the verbatim result as it got sent to my console in the second child node.

A few things are worth noting here:

1.  The node containing the test must have its headline start with '@test'.
2.  Whenever the 'assert' statement finds out that the expression given to it
    is 'True', a test passes successfully. There are more ways to pass a test, but
    for now, let us stick to the use of assert functions.
3.  A passed test is denoted with a single dot in the output. See the line between
    'Start of Do @test' and the line filled with dashes. This is compatible with the
    way traditional unit testing shows its progress.
4.  Below the dashed line in the output, a summary is printed. This one surely gives
    us a reason to lean back for a moment, and congratualate ourselves with another
    piece of robust, funky code!</t>
<t tx="ekr.20050618061835.6">@color
assert(True)</t>
<t tx="ekr.20050618061835.7">Start of Do @test
.
----------------------------------------------------------------------
Ran 1 test in 0.010s

OK
End of Do @test</t>
<t tx="ekr.20050618061835.8">Now that you've seen a passing test, it should be obvious to imagine how a failing test would look like. See the first child node, and then run it by pressing the 'Do @test' button as before.

Instead of a dot denoting success, we get an 'F' denoting a failure on the line following 'Start of Do @test'. When running a lot of tests, the next part, following the lines filled with '='s, helps to identify which test failed.
It also includes a trace back, but for AssertionErrors, it does not seem to offer much added value to me right now. On second thought: when you have multiple asserts in a test, the trace back can tell you which assert function failed. Still, I would choose for only one assert function per test and get rid of this trace back altogether. This would keep the console much cleaner, IMHO.</t>
<t tx="ekr.20050618061835.9">@color
assert('Spam' == 'Ham')</t>
<t tx="ekr.20050726141158">@ This is    a test of stuff.in doc parts.

         I wonder           what will happen.
@c

def        spam (self         )  :   

    """ This is a ' triple'   quoted string:
        It should remain untouched."""
    
    if a==3:
        g.pr("  ")
        
    ''' Another ' triple'   quoted string:
        It should remain untouched.'''
        
    "yet another\
    multi-line string"
        
class eggs:
    
    """ A typical doc string """
    
    @others</t>
<t tx="ekr.20050911112310">c.save()
c.redraw_now()</t>
<t tx="ekr.20051012104957"></t>
<t tx="ekr.20051013162226"></t>
<t tx="ekr.20051018071924">	</t>
<t tx="ekr.20051025070722">c.prettyPrintPythonNode()</t>
<t tx="ekr.20051025091355">c.spellCommands.openSpellTab()
</t>
<t tx="ekr.20051104080236"></t>
<t tx="ekr.20051104081502">@language python
@tabwidth -4</t>
<t tx="ekr.20051104081502.10"></t>
<t tx="ekr.20051104081502.101">@language plain
@pagewidth 40

A one-line paragraph one two three four five six seven eight nine ten...

An @rawfile tree is a tree whose root headline starts with
@rawfile &lt;filename&gt;. Similarly, an @silentfile tree is a
tree whose root headline starts with an @silentfile
&lt;filename&gt; directive.

    Leo creates derived files from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. Exception: Leo recognizes the @ignore directive in @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:
    
  This
  is
  a
  test.

  1. This is the first line and it is really really really long. And it has
     a hanging indentation.
     and another line.

  2. This is a lllllllllllllllllllllllllllllllllllloooooooooooooooooong
     next item.
     And it too has a hanging indentation.

  3. This is an exxxxxxxxxxxxxxxxxxxxxxxxtrrrrrrrrrrrrrrreeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeemlylong
     word.
And it too has a hanging indentation.</t>
<t tx="ekr.20051104081502.102">@tabwidth -4
@language plain

    
    a   b   c
a   b   c   d
aa  b   c   d
aaa b   c   d
end</t>
<t tx="ekr.20051104081502.103">@killcolor
@language plain

Note: Previously, one could crash Leo by pasting a large text into a headline.  Leo now truncates that text, and furthermore Leo no longer makes all headline text into one gigantic line.  Therefore, we don't have to test Tk's ability to handle super-long lines.

The test:  Copy the following and paste it into a headline.  Leo should give 2 truncation messages:

- Truncating headline to one line.
- Truncating headline to 250 characters.

About a year ago I found the website at www.literateprogamming.com and was immediately convinced that the basic idea of Literate Programming is an important breakthrough. At the time I was working on a contract trying to decipher a true masterpiece of over-engineering, and if at any time during the construction of this masterpiece the perpetrators had been required to explain themselves in English, my client would have saved millions of dollars.

I never did try CWEB or NOWEB though, because on the literate programming site I read about a tool named Leo that combined outlines with Literate Programming techniques. Since Ive always found outlining tools very useful I downloaded and tried this. I found that using this tool completely changed my programming practice and brought out all of the power inherent in the original Literate Programming idea as I understood it.</t>
<t tx="ekr.20051104081502.104">import os

g.pr(os.getcwd())
name = g.os_path_join("test","removeSentTest.txt")
c.importCommands.removeSentinelsCommand(name)</t>
<t tx="ekr.20051104081502.105">import leoTest
import glob

g.pr('-' * 40)

if 0:
    g.pr("modules in test.leo...")
    paths = leoTest.findAllAtFileNodes(c)
    modules = leoTest.importAllModulesInPathList(paths)
    for module in modules:
        g.pr(module)
    
if 1:
    g.pr("modules in leo/src...")
    path = g.os_path_join(g.app.loadDir,"..","src")
    modules = leoTest.importAllModulesInPath(path)
    for module in modules:
        g.pr(module)
        
if 0:
    directory = g.os_path_join(g.app.loadDir,"..","src")
    glob_path = g.os_path_join(directory,"leo*.py")
    files = glob.glob(glob_path)
    modules = leoTest.importAllModulesInPathList(files)
    for module in modules:
        g.pr(module)</t>
<t tx="ekr.20051104081502.106"></t>
<t tx="ekr.20051104081502.107">import doctest
import unittest
import leoTest

createUnitTest = True

if createUnitTest:
    suite = unittest.makeSuite(unittest.TestCase)
else:
    suite = None
    
paths = leoTest.findAllAtFileNodes(c)
modules = leoTest.importAllModulesInPathList(paths)

if createUnitTest:
    suite = leoTest.createUnitTestsFromDoctests(modules)
else:
    for module in modules:
        doctest.testmod(module,verbose=True,report=False)
                            
if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20051104081502.108">for i in range(10000):
    if i and (i % 1000) == 0:
        g.pr(i)</t>
<t tx="ekr.20051104081502.109">i = 0
for i in range(100000):
    i += 1
    i -= 1</t>
<t tx="ekr.20051104081502.11"></t>
<t tx="ekr.20051104081502.110"># c.redraw just schedules the actual drawing.
# We want to profile the actual idle-time drawing.

c.frame.tree.idle_redraw()</t>
<t tx="ekr.20051104081502.111">@language python
@tabwidth -4</t>
<t tx="ekr.20051104081502.112"># EKR: I don't remember the status of this.

@language python

import shutil

testing = True
sourcedir=r"c:/prog/test/perfectImport"
targetdir=r"c:/prog/test/perfectImport/leo"
s1 = g.os_path_join(sourcedir,"leoAtFile.py")
t1 = g.os_path_join(targetdir,"leoAtFile.py")
files = [(s1,t1)]

@others

g.pr('\n' + '-' * 20)
sync(files) # push or pull, depending on date.
</t>
<t tx="ekr.20051104081502.113">def sync(files):
    
    """Do a pull or a push, depending on the date of the files."""
    
    none, push, pull = 'None', 'push', 'pull'
    mu = g.mulderUpdateAlgorithm()

    for sourcefilename, targetfilename in files:
        &lt;&lt; compute sourcetime and targettime &gt;&gt;
        &lt;&lt; compute operation &gt;&gt;
        if operation == push:
            if testing: g.pr(push, sourcefilename, targetfilename)
            strippedLines = mu.removeSentinelsFromFile(sourcefilename)
            mu.write_if_changed(strippedLines,sourcefilename,targetfilename)
            mu.copy_time(sourcefilename,targetfilename)
        elif operation == pull:
            if testing: g.pr(pull, sourcefilename, targetfilename)
            if sourcetime:
                mu.propagateDiffsToSentinelsFile(sourcefilename,targetfilename)
                mu.copy_time(targetfilename,sourcefilename)
            else:
                shutil.copy2(targetfilename,sourcefilename)</t>
<t tx="ekr.20051104081502.114">sourcetime = targettime = None

if g.os_path_exists(sourcefilename):
    sourcetime = g.os_path_getmtime(sourcefilename)

if g.os_path_exists(targetfilename):
    targettime = g.os_path_getmtime(targetfilename)</t>
<t tx="ekr.20051104081502.115">operation = None
if sourcetime:
    if targettime:
        if sourcetime &gt; targettime:
            operation = push
        elif sourcetime &lt; targettime:
            operation = pull
    else:
        operation = push
elif targettime:
    operation = pull</t>
<t tx="ekr.20051104081502.116"># Run this script to import a file.
# This is undoable because the Import @file command is undoable.

path = r"c:\prog\test\perfectImport"

# Two files from Python23/Lib
name1 = g.os_path_join(path,"formatter.py")
name2 = g.os_path_join(path,"SimpleHTTPServer.py")
names = [name1]

c.importCommands.importFilesCommand (names,"@file",
    perfectImport=True,testing=False,verbose=True)</t>
<t tx="ekr.20051104081502.117"></t>
<t tx="ekr.20051104081502.118">g.pr('-'*20)

for p in c.allNodes_iter():
    if p.isDirty():
        vnodes = p.findAllPotentiallyDirtyNodes()
        g.pr('-'*5, p)
        for v in vnodes:
            g.pr(v)

g.pr("done")</t>
<t tx="ekr.20051104081502.119">import leoNodes

position = leoNodes.position

@others

current = pos = c.p
child1 = current.firstChild()
child2 = child1.firstChild()

if 0:
    g.pr('-'*10, "parents")
    for p in child2.parents_iter(): g.pr(p)
if 0:
    g.pr('-'*10, "subtree")
    for p in pos.subtree_iter(): g.pr(p)
if 0:
    g.pr('-'*10, "children")
    for p in child1.children_iter(): g.pr(p)
if 0:
    g.pr('-'*10, "siblings")
    for p in pos.siblings_iter(): g.pr(p)
if 1:
    g.pr('-'*10, "all nodes")
    for p in c.allNodes_iter():
        g.pr(p.isCloned(),p)
</t>
<t tx="ekr.20051104081502.12"></t>
<t tx="ekr.20051104081502.120"></t>
<t tx="ekr.20051104081502.121"></t>
<t tx="ekr.20051104081502.122"></t>
<t tx="ekr.20051104081502.123"></t>
<t tx="ekr.20051104081502.124"></t>
<t tx="ekr.20051104081502.125"></t>
<t tx="ekr.20051104081502.126"></t>
<t tx="ekr.20051104081502.127"></t>
<t tx="ekr.20051104081502.128"></t>
<t tx="ekr.20051104081502.129"></t>
<t tx="ekr.20051104081502.13"></t>
<t tx="ekr.20051104081502.130"></t>
<t tx="ekr.20051104081502.131"></t>
<t tx="ekr.20051104081502.14"></t>
<t tx="ekr.20051104081502.145">g.pr('-'*20)

for p in c.allNodes_iter():
    if p.isAnyAtFileNode():
        g.pr(p)
        
g.pr("done")</t>
<t tx="ekr.20051104081502.146">import leoTest

u = leoTest.testUtils(c)

g.pr("children", '-' * 20)
children = u.findChildrenOf(p)
for child in children: g.pr(child.h)

g.pr("subtree", '-' * 20)
descendants = u.findSubnodesOf(p)
for descendant in descendants: g.pr(descendant.h)</t>
<t tx="ekr.20051104081502.147">import binascii
import pickle

d = { "a":True }

g.pr('-' * 40)

s = pickle.dumps(d,bin=True)
s2 = binascii.hexlify(s)
g.pr(`s`,s2)

s3 = binascii.unhexlify(s2)
d2 = cPickle.loads(s3)

g.pr(`d2`)
g.pr(d == d2, d is d2)</t>
<t tx="ekr.20051104081502.148">def redoBletch(self):
    g.trace()
    
def undoBletch(self):
    g.trace()
    
u = c.undoer

if 0:
    # bad functions
    u.registerUndoHandlers("Bletch","abc","xyz")
else:
    u.registerUndoHandlers("Bletch",undoBletch,redoBletch)
    
# "Execute" the Bletch command :-)  The Edit command should contain "Undo Bletch"
u.setUndoParams("Bletch",p)

# Selecting "Undo Bletch" will enable "Redo Bletch", etc.</t>
<t tx="ekr.20051104081502.149">d = { "a":True }

if 1:
    # Warning: executing this in the a2 code base will cause any save operation to fail.
    p.v.unknownAttributes = { "myPlugin" : d }
    
g.pr(repr(p.v.unknownAttributes))</t>
<t tx="ekr.20051104081502.15"></t>
<t tx="ekr.20051104081502.150">import leoPlugins

def onEnd (tag,keys):
    g.pr("onEnd",tag,keys)
    
count = 0
    
def onIdle (tag,keys):
    global count ; count += 1
    if count % 10 == 0:
        g.pr("onIdle",count,keys.get("c"))

leoPlugins.registerHandler("end1", onEnd)
g.pr("onEnd registered as end1 hook")

leoPlugins.registerHandler("idle", onIdle)
g.pr("onIdle registered as idle hook")</t>
<t tx="ekr.20051104081502.151">for p in c.all_positions_iter():
    g.pr(p.v.t.fileIndex)</t>
<t tx="ekr.20051104081502.152">g.pr(c.frame.bodyCtrl.focus())</t>
<t tx="ekr.20051104081502.153"># This kind of code is used in the prototypes of new commands.

from __future__ import generators

@others

lines = "a\nb\nc\nd"

if 1: # Both work
    readline = g.readLinesGenerator(lines).next
else:
    readline = g.readLinesClass(lines).next

g.pr('-' * 20)

if 1: # Both work
    for s in g.readLinesGenerator(lines):
        g.pr(s,)
else:
    while 1:
        s = readline()
        if s: g.pr(s,)
        else: break
    
g.pr('\n' + '-' * 20)</t>
<t tx="ekr.20051104081502.154"># Test
@others
# Last</t>
<t tx="ekr.20051104081502.155">a = 1
g.pr("hello")
c = b
</t>
<t tx="ekr.20051104081502.157">import leoTest
import types

specialDictNames = ('__builtins__','__doc__','__name__','__file__','__module__')

def printDoc(x,s):
    if hasattr(x,"__doc__") and x.__doc__:
        g.pr("%4d %s" % (len(x.__doc__),s))
    else:
        g.pr("%4s %s" % (' ',s))

g.pr('-' * 60)
g.pr("%4d %s" % (len(leoTest.__doc__),"leoTest"))

if 1:
    for s in leoTest.__dict__:
        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) != types.ModuleType:
                printDoc(x,s)
                if type(x) == types.ClassType:
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            g.pr(' '*4,)
                            printDoc(x2,s2)
else:
    &lt;&lt; print names sorted by type &gt;&gt;</t>
<t tx="ekr.20051104081502.158">for theType,typeName in (
    (types.ModuleType,"modules"),
    (types.ClassType,"classes"),
    (types.FunctionType,"functions"),
):

    g.pr("\n%s..." % typeName)
    for s in leoTest.__dict__:
        
        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) == theType:
                printDoc(x,s)
                if theType == types.ClassType:
                    g.pr("\tmethods...")
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            g.pr("\t",newline=False)
                            printDoc(x2,s2)</t>
<t tx="ekr.20051104081502.159">import Tkinter as Tk

root = Tk.Tk()
c = Tk.Canvas(root,background='white')
g.pr(c.bindtags())

if 0:
    c.pack(expand=1,fill='both')
    f = Tk.Frame(c)
    c.create_window(0,0,window=f,anchor='nw')
    f.pack_configure(fill='both',expand=1)
    body = olCreateControl(self,frame,f)
    c.on = False 
    sel = lambda event, c = c, body = body:select(event,c,body)
    ai = lambda event, c = c, body = body, colorizer = frame.body:add_item(event,c,body,colorizer.getColorizer())
    c.bind("&lt;Key&gt;",watcher,'+')
    c.bind("&lt;Key&gt;",sel,'+')
    c.bind("&lt;Key&gt;",ai,'+')
    ctags = c.bindtags()
    btags = body.bindtags()
    btags =(ctags[0],btags[0],btags[1],btags[2],btags[3])
    body.bindtags(btags)</t>
<t tx="ekr.20051104081502.16"></t>
<t tx="ekr.20051104081502.160"></t>
<t tx="ekr.20051104081502.161">for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"unknownAttributes"):
        a = p.v.t.unknownAttributes
        iconsList = a.get("icons")
        if dict:
            a["icons"] = []
            a["lineYOffset"] = 0
            
c.redraw()</t>
<t tx="ekr.20051104081502.162">p.v.t.unknownAttributes = {}
a = p.v.t.unknownAttributes

&lt;&lt; define event callbacks &gt;&gt;

path = g.os_path_join(g.app.loadDir,"..","Icons")
icon1 = g.os_path_join(path,"lt_arrow_enabled.gif")
icon2 = g.os_path_join(path,"rt_arrow_enabled.gif")

d1 = {
    "type" : "file", "file" : icon1,
    "where" : "beforeIcon",
    "yoffset" : -3,
    # "yoffset" : 5, "ypad" : -5,
    # "height" : 40, # automatically adjust headline y position.
    "xpad": 2
}

# Classes and functions can only be pickled if they are at the top level of a module.
    #"onClick" : onClick,
    #"onRightClick" : onRightClick,
    #"onDoubleClick" : onDoubleClick }

d2 = {
    "type" : "file", "file" : icon2,
    "where" : "beforeHeadline",
    "yoffset" : -3,
    "xoffset" : 2, "xpad" : -2 }

a["icons"] = [d1,d2] # [d1,d2]
a["lineYOffset"] = 3

c.redraw()
</t>
<t tx="ekr.20051104081502.163">def onClick(p=p):
    
    g.trace(p)

def onRightClick(p=p):
    
    g.trace(p)

def onDoubleClick(p=p):
    
    g.trace(p)</t>
<t tx="ekr.20051104081502.164"></t>
<t tx="ekr.20051104081502.165"># Set the attribute.
d = {'str_ekr_attribute': 'abc'}
p.v.t.unknownAttributes = d</t>
<t tx="ekr.20051104081502.166">for p in c.allNodes_iter():
    h = p.h
    if hasattr(p.v.t,'unknownAttributes'):
        d = p.v.t.unknownAttributes
        val = d.get('str_ekr_attribute')
        if val:
           g.es('str_ekr_attribute is: %s' % val)</t>
<t tx="ekr.20051104081502.17"></t>
<t tx="ekr.20051104081502.170">@path c:\prog\test</t>
<t tx="ekr.20051104081502.171">@root atRootTest1.txt

atRootTest1.txt</t>
<t tx="ekr.20051104081502.172">@root atRootTest2.txt

atRootTest2.txt</t>
<t tx="ekr.20051104081502.18"></t>
<t tx="ekr.20051104081502.183">s = u""

g.reportBadChars(s,"latin_1")

g.pr(g.toEncodedString(s,"latin_1"))</t>
<t tx="ekr.20051104081502.19"></t>
<t tx="ekr.20051104081502.2"></t>
<t tx="ekr.20051104081502.20"></t>
<t tx="ekr.20051104081502.209">arg = "arg" ; filename = "fileName"
path = "path" ; shortPath = "shortPath"
vtuple = "vtuple"

def test(a,b):
    assert(a==b)

test(
    "os.system("+arg+shortPath+")",
    "os.system(%s)" % (arg+shortPath))
test(
    "os.startfile("+arg+shortPath+")",
    "os.startfile(%s)" % (arg+shortPath))
test(
    "exec("+arg+shortPath+")",
    "exec(%s)" % (arg+shortPath))
test(
    "os.spawnl("+arg+","+filename+','+ shortPath+")",
    "os.spawnl(%s,%s,%s)" % (arg,filename,shortPath))
test(
    "os.spawnv("+arg[0]+","+repr(vtuple)+")",
    "os.spawnv(%s,%s)" % (arg[0],repr(vtuple)))</t>
<t tx="ekr.20051104081502.21"></t>
<t tx="ekr.20051104081502.210">@language python

# Type a period to autocomplete
leoTest

# Type an open paren to bring up calltip.
leoTest.findAllAtFileNodes</t>
<t tx="ekr.20051104081502.211"></t>
<t tx="ekr.20051104081502.213"></t>
<t tx="ekr.20051104081502.214"># Go To Line number now assumes that selected node is
# the root of a script if there is no ancestor @file node.

@others

# last line</t>
<t tx="ekr.20051104081502.215"># We should also be able to use the goto line number command to get to the erroneous line.

a = 1/0 # ZeroDivisionError

b = 2</t>
<t tx="ekr.20051104081502.216"></t>
<t tx="ekr.20051104081502.217">import leoPlugins as plugins

def traceHook(tag,event):
    g.trace(tag)
    
tags = (
    "boxclick1","boxclick2",
    "drag1","drag2",
    "dragging1","dragging2",
    "enddrag1","enddrag2",
    "iconclick1","iconclick2"  , 
    "iconrclick1","iconrclick2",
    "icondclick1","icondclick2",
)

plugins.registerHandler(tags,traceHook)

handlers = plugins.getHandlersForTag(tags)
if handlers:
    g.pr("-" * 20)
    for h in handlers:
        g.pr(h)</t>
<t tx="ekr.20051104081502.218">import leoPlugins as plugins

tags = (
    "boxclick1","boxclick2",
    "drag1","drag2",
    "dragging1","dragging2",
    "enddrag1","enddrag2",
    "iconclick1","iconclick2"  , 
    "iconrclick1","iconrclick2",
    "icondclick1","icondclick2",
)

for tag in tags:
    handlers = plugins.getHandlersForTag(tag)
    if handlers:
        g.pr(handlers)
        for f in handlers:
            plugins.unregisterHandler(tag,f)

handlers = plugins.getHandlersForTag(tags)
if handlers:
    g.pr("-" * 20)
    for h in handlers:
        g.pr(h)</t>
<t tx="ekr.20051104081502.219">import leoPlugins as plugins

tags = (
    "boxclick1","boxclick2",
    "drag1","drag2",
    "dragging1","dragging2",
    "enddrag1","enddrag2",
    "iconclick1","iconclick2"  , 
    "iconrclick1","iconrclick2",
    "icondclick1","icondclick2",
)

handlers = plugins.getHandlersForTag(tags)
if handlers:
    g.pr("-" * 20)
    for h in handlers:
        g.pr(h)</t>
<t tx="ekr.20051104081502.22"></t>
<t tx="ekr.20051104081502.220">"""Mini test that documentation of hooks in leoDocs.leo is correct.

hookData should match that documentation for this test to be effective.

This is not a complete unit test:  it does not force executions of all hooks.
"""

&lt;&lt; imports &gt;&gt;
&lt;&lt; define hookData &gt;&gt;
&lt;&lt; define typeData &gt;&gt;
checked = [] # List of all hooks that have been checked.

@others

tags = [] 
for name,args in hookData:
    tags.append(name)
    &lt;&lt; define checkHook &gt;&gt;
    leoPlugins.registerHandler(name,checkHook)
    
if 0: # print all hooks.
    handlers = leoPlugins.getHandlersForTag(tags)
    if handlers:
        g.pr("-" * 20)
        for h in handlers:
            g.pr(h)</t>
<t tx="ekr.20051104081502.221">import leoColor
import leoCommands
import leoNodes
import leoPlugins
import leoTkinterTree

import types
import Tkinter as Tk</t>
<t tx="ekr.20051104081502.222">hookData = (
    ("bodyclick1",   ("c","p","v","event")),
    ("bodyclick2",   ("c","p","v","event")),
    ("bodydclick1",  ("c","p","v","event")),
    ("bodydclick2",  ("c","p","v","event")),
    ("bodykey1",     ("c","p","v","ch","oldSel","undoType")),
    ("bodykey2",     ("c","p","v","ch","oldSel","undoType")),
    ("bodyrclick1",  ("c","p","v","event")),
    ("bodyrclick2",  ("c","p","v","event")),
    ("boxclick1",    ("c","p","v","event")),
    ("boxclick2",    ("c","p","v","event")),
    ("command1",     ("c","p","v","label")),
    ("command2",     ("c","p","v","label")),
    ("drag1",        ("c","p","v","event")),
    ("drag2",        ("c","p","v","event")),
    ("dragging1",    ("c","p","v","event")),
    ("dragging2",    ("c","p","v","event")),
    ("end1",         None),
    ("enddrag1",     ("c","p","v","event")),
    ("enddrag2",     ("c","p","v","event")),
    ("headclick1",   ("c","p","v","event")),
    ("headclick2",   ("c","p","v","event")),
    ("headrclick1",  ("c","p","v","event")),
    ("headrclick2",  ("c","p","v","event")),
    ("headkey1",     ("c","p","v","ch")),
    ("headkey2",     ("c","p","v","ch")),
    ("hypercclick1", ("c","p","v","event")),
    ("hypercclick2", ("c","p","v","event")),
    ("hyperenter1",  ("c","p","v","event")),
    ("hyperenter2",  ("c","p","v","event")),
    ("hyperleave1",  ("c","p","v","event")),
    ("hyperleave2",  ("c","p","v","event")),
    ("iconclick1",   ("c","p","v","event")),
    ("iconclick2",   ("c","p","v","event")),
    ("iconrclick1",  ("c","p","v","event")),
    ("iconrclick2",  ("c","p","v","event")),
    ("icondclick1",  ("c","p","v","event")),
    ("icondclick2",  ("c","p","v","event")),
    ("idle",         ("c",)),
    ("menu1",        ("c","p","v")),
    ("menu2",        ("c","p","v")),
    ("open1",        ("old_c","new_c","fileName")),
    ("open2",        ("old_c","new_c","fileName")),
    ("openwith1",    ("c","p","v","openType","arg","ext")),
    ("openwith2",    ("c","p","v","openType","arg,ext" )),
    ("recentfiles1", ("c","p","v","fileName","closeFlag")),
    ("recentfiles2", ("c","p","v","fileName","closeFlag")),
    ("save1",        ("c","p","v","fileName" )),
    ("save2",        ("c","p","v","fileName" )),
    ("select1",      ("c","new_p","old_p","new_v","old_v")),
    ("select2",      ("c","new_p","old_p","new_v","old_v")),
    ("select3",      ("c","new_p","old_p","new_v","old_v")),
    ("set-mark",     ("c","p","v")),
    ("start1",       None),
    ("start2",       ("c","p","v","fileName" )),
    ("unselect1",    ("c","new_p","old_p","new_v","old_v")),
    ("unselect2",    ("c","new_p","old_p","new_v","old_v")),
    ("@url1",        ("c","p","v")),
    ("@url2",        ("c","p","v")),
    # Stub hooks.
    ("after-redraw-outline",         ("c",)),
    ("clear-mark",                   ("c","p","v")),
    ("close-frame",                  ("c",)),
    ("color-optional-markup",        ("colorer","p","v","s","i","j","colortag")),
    ("create-optional-menus",        ("c",)),
    ("destroy-all-global-windows",   None),
    ("draw-outline-box",             ("tree","p","v","x","y")), #
    ("draw-outline-icon",            ("tree","p","v","x","y")), #
    ("draw-outline-node",            ("tree","p","v","x","y")), #
    ("draw-outline-text-box",        ("tree","p","v","x","y")), #
    ("create-popup-menu-items",      ("c","p","v","event")),
    ("enable-popup-menu-items",      ("c","p","v","event")),
    ("init-color-markup",            ("colorer","p","v")),
    ("new",                          ("old_c","new_c")),
    ("redraw-entire-outline",        ("c",)),
    ("scan-directives",              ("c","p","v","s","old_dict","dict","pluginsList")),
    ("set-mark",                     ("c","p","v" )),
    ("show-popup-menu",              ("c","p","v","event")),
)</t>
<t tx="ekr.20051104081502.223">typeData = {
    "arg":      types.StringType,
    "c":        leoCommands.Commands,
    "ch":       types.StringType,
    "closeFlag":types.StringType,
    "colorer":  leoColor.colorizer,
    "colortag": types.StringType,
    "dict":     types.DictType,
    "event":    Tk.Event,
    "ext":      types.StringType,
    "fileName": types.StringType,
    "i":        types.IntType,
    "j":        types.IntType,
    "label":    types.StringType,
    "new_c":    leoCommands.Commands,
    "new_p":    leoNodes.position,
    "newSel":   types.TupleType,
    "new_v":    leoNodes.position,
    "old_c":    leoCommands.Commands,
    "old_dict": types.DictType,
    "old_p":    leoNodes.position,
    "oldSel":   types.TupleType,
    "old_v":    leoNodes.position,
    "openType": types.StringType,
    "p":        leoNodes.position,
    "pluginsList": types.ListType,
    "s":        types.UnicodeType,
    "tree":     leoTkinterTree.leoTkinterTree,
    "v":        leoNodes.position,
    "undoType": types.StringType,
    "x":        types.IntType,
    "y":        types.IntType,
}
</t>
<t tx="ekr.20051104081502.224">def checkHook (tag,keywords,args=args):

    """Check to see that the keywords passed to the hook are as described in args.
    Each arg is a list of strings whose type is defined in typeData."""

    global checked, verbose
    if tag in checked: return
    ok = True
    checked.append(tag)
    if args is None: args = []
    args = list(args)
    args.sort()
    keys = list(keywords.keys())
    keys.sort()
    
    if len(args) != len(keys):
        g.pr("%25s expected:" % (tag),args)
        g.pr("%25s      got:" % (tag),keys)
        ok = False
    else:
        for arg,key in zip(args,keys):
            arg_type = typeData.get(arg)
            val = keywords.get(key)
            if not checkOneHook(arg_type,val):
                g.pr("%25s      arg:" % (tag), arg)
                g.pr("%25s expected:" % (tag), arg_type)
                g.pr("%25s      got:" % (tag), type(val))
                ok = False
    if ok:
        g.pr(tag)</t>
<t tx="ekr.20051104081502.225">def checkOneHook (arg_type, val):
    
    if 0:
        if arg_type != type(val):
            g.trace(arg,key,arg_type,type(val))
    
    return (
        (arg_type is type(val)) or
        (arg_type == types.StringType and type(val) is types.UnicodeType) or
        (type(arg_type) == types.ClassType and isinstance(val,arg_type)))</t>
<t tx="ekr.20051104081502.226"></t>
<t tx="ekr.20051104081502.227">g.rawPrint("Test of g.rawPrint")
g.redirectStdout()
g.rawPrint("Test of g.rawPrint")
g.restoreStdout()</t>
<t tx="ekr.20051104081502.23">class position:
    def __init__(self):
        self.v = "a"
    def move(self):
        self.v = "b"

p = position()
v = p.v
g.pr("before", v, p.v, v is p.v)
p.move()
g.pr("after ", v, p.v, v is p.v)</t>
<t tx="ekr.20051104081502.232">g.pdb()</t>
<t tx="ekr.20051104081502.233">g.pr(g.app.debugSwitch)

g.app.debugSwitch = 0 # 2: drop into pdb

zerodivide = 1 / 0</t>
<t tx="ekr.20051104081502.234">g.pr(c)
g.pr('use_plugins',c.use_plugins)
g.pr('tab_width',c.tab_width)
g.pr('page_width',c.page_width)</t>
<t tx="ekr.20051104081502.24">class test_iter_class:
    def __init__ (self):
        self.vals = ("a","b","c")
        self.n = 0
    def __iter__(self):
        return self
    def next(self):
        if self.n &lt; len(self.vals):
            val = self.vals[self.n]
            self.n += 1
            return val
        else:
            raise StopIteration
            
def test_iter(): return test_iter_class()
        
vals = [val for val in test_iter()]

g.pr(vals)</t>
<t tx="ekr.20051104081502.25">g.pr('-'*20)

# These are equivalent.
positions1 = [p for p in c.allNodes_iter(copy=True)]
positions2 = [p.copy() for p in c.allNodes_iter()]

assert(len(positions1) == len(positions2))
for i in xrange(len(positions1)):
    assert(positions1[i] == positions2[i])

if 0:
    for p in positions1:
        g.pr(p)
g.pr("done")</t>
<t tx="ekr.20051104081502.26">g.pr('-'*20)

positions = [p.copy() for p in c.allNodes_iter()]

tnodes = {} ; vnodes = []
for p in c.allNodes_iter():
    t = p.v.t
    if tnodes.get(t) is None:
        tnodes[t]=t
        vnodes.append(p.v)
        
g.pr(len(positions),len(vnodes))

for v in vnodes:
    g.pr(v)</t>
<t tx="ekr.20051104081502.272"></t>
<t tx="ekr.20051104081502.273">import glob,sys,traceback

def printModules():
    mods = sys.modules.keys()
    mods.sort()
    for mod in mods: g.pr(mod)

def leoModules():
    files = glob.glob(r'%s\*.py' % g.app.loadDir)
    modules = []
    for file in files:
        path,file = g.os_path_split(file)
        module,ext = g.os_path_splitext(file)
        if g.match(module,0,'leo'):
            modules.append(module)
    return modules
            
def delLeoModules():
    for module in leoModules():
        if module in sys.modules:
            del sys.modules[module]

def test():
    for module in leoModules():
        g.pr(module)
        exec 'import %s' % module in {},{}
        del sys.modules[module]
    
delLeoModules()        
test()
# printModules()</t>
<t tx="ekr.20051104081502.274">def test():
    '''Tests whether all files can be imported.'''
    import glob, os, sys, traceback
    dir = r'c:\prog\leoCVS\leo\src'
    files = glob.glob(r'%s\*.py' % dir)
    modules = []
    for file in files:
        path,file = os.path.split(file)
        module,ext = os.path.splitext(file)
        if module[:3] == 'leo':
            modules.append(module)
    for module in modules:
        g.pr(module)
        try:
            exec 'import %s' % module in {},{}
            del sys.modules[module]
        except:
            traceback.print_exc()
            
def printModules():
    import sys
    mods = sys.modules.keys()
    mods.sort()
    for mod in mods: g.pr(mod)
    
</t>
<t tx="ekr.20051104081502.28">stack1 = ["a","b","c"]
stack2 = ["a","b","c"]
stack3 = ["a","b","d"]
stack4 = ["a","b"]
g.pr(stack1 == stack2)
g.pr(stack1 == stack3)
g.pr(stack1 == stack4)</t>
<t tx="ekr.20051104081502.29">g.pr(p.h)
g.pr(p.childIndex())
g.pr(p.h)</t>
<t tx="ekr.20051104081502.3"></t>
<t tx="ekr.20051104081502.30">import timeit

s1 = '''\
class test(object):
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s2 = '''\
class test:
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s3 = '''\
import leoNodes
p1 = leoNodes.position(None,[])
p2 = leoNodes.position(None,[])'''

for s in (s1,s2,s3):
    t1 = timeit.Timer(stmt='p1==p2',setup=s).timeit()
    t2 = timeit.Timer(stmt='p1.equal(p2)',setup=s).timeit()
    g.pr("%2.2f,%2.2f,%0.2f" % (t1,t2,t1/t2))
</t>
<t tx="ekr.20051104081502.305">stuff = g.toEncodedString(u'','utf-8')
g.pr(type(stuff))
g.pr('*' * 10)
for ch in stuff:
    g.pr(ch, ord(ch),newline=False)
g.pr()</t>
<t tx="ekr.20051104081502.306"></t>
<t tx="ekr.20051104081502.307">g.es(c.redirect_execute_script_output_to_log_pane)
g.es(c.config.redirect_execute_script_output_to_log_pane)
g.pr('hello')

#assert c.redirect_execute_script_output_to_log_pane is True
#assert c.config.redirect_execute_script_output_to_log_pane is True
</t>
<t tx="ekr.20051104081502.308">@others

test_g_removeExtraLws()</t>
<t tx="ekr.20051104081502.309">def removeExtraLws (s,tab_width):
    
    '''Removed extra indentation from one or more lines.'''
    
    lines = g.splitLines(s)

    # Find the first non-blank line:
    for s in lines:
       if s.strip():
            lws = g.get_leading_ws(s)
            w = g.computeWidth(lws,tab_width)
            # g.trace('w',w)
            break
    else: return s
    
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]

    return ''.join(result)</t>
<t tx="ekr.20051104081502.31"># "LPT1:", "PRN:" and "PRN" all freeze

s = 'stuff\n'
port = 'USB002'

try:
    f = file(port,'w')
    f.write(s)
    f.flush()
    f.close()
    g.pr("done")
except IOError:
    g.pr("Can not open",port)</t>
<t tx="ekr.20051104081502.310">def test_g_removeExtraLws():
    
    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
            
    g.pr('Success')</t>
<t tx="ekr.20051104081502.311"># Running this as a unit test would hang the unit tests!
g.pdb()</t>
<t tx="ekr.20051104081502.312">try:
    assert False, 'Assert False'
except AssertionError:
    g.es_exception()</t>
<t tx="ekr.20051104081502.315"># Comment

g.pr(z)</t>
<t tx="ekr.20051104081502.316">import leoTest

leoTest.throwAssertionError()</t>
<t tx="ekr.20051104081502.317">g.pr('-'*60)
count = 0
for p in c.allNodes_iter():
    count += 1
    g.pr(' '*p.level(),p.h)
g.pr('found',count,'nodes')</t>
<t tx="ekr.20051104081502.318">table = ('spawnv',None,(
    'os.spawnv',[
    r'c:\vim\vim63\gvim.exe',
    ' --servername LEO ',
    ' --remote-silent ',
    ],
    ".py")),

c.frame.menu.createOpenWithMenuFromTable(table)</t>
<t tx="ekr.20051104081502.319"></t>
<t tx="ekr.20051104081502.32">@ By far the simplest way is just to write the string to a temp file, then import the temp files.

All other approaches quickly get deeply involved with Leo's internals...</t>
<t tx="ekr.20051104081502.320">@nowrap
aaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbb cccccccccccccccccccc ddddddddddddddd eeeeeeeeeeeeeee ffffffffffffffff </t>
<t tx="ekr.20051104081502.321"># To run this test, set @bool redirect_execute_script_output_to_log_pane = True in the @settings tree.

g.pr('hi')
g.pr(c.config.redirect_execute_script_output_to_log_pane)
g.pr(c.xyzzy)</t>
<t tx="ekr.20051104081502.322">@language html</t>
<t tx="ekr.20051104081502.323">g.pr('-'*20)
g.pr(g.getScript(c,p,forcePythonSentinels=False))</t>
<t tx="ekr.20051104081502.324">&lt;body&gt;
@others
&lt;/body&gt;</t>
<t tx="ekr.20051104081502.325">This is a body</t>
<t tx="ekr.20051104081502.326">@nocolor
@pagewidth 100
@language python</t>
<t tx="ekr.20051104081502.327">@language python

@ @rst-options
code_mode = False
show_leo_directives = True
number_code_lines = False
@c

#########################
ListManager Documentation
#########################

:Author: Steven Zatz, Modified by EKR.
:Contact: slzatz@hotmail.com
:Date: $Date: 2008/02/14 14:59:04 $
:Status: This is a "work in progress"
:Revision: $Revision: 1.247 $
:Copyright: Application and documentation use the Python license which is compatible with the GPL. 

This is experimental documentation of a program called ListManager, written in
Python and wxPython using Leo to create both the application code and the
associated reST documentation.

ListManager is an application that allows a group of people working on a joint
project to maintain a common list of todos and related items that have owners,
due dates and associated notes. The application uses mysql as its database for
group use and also uses sqlite for locally resident databases for personal
lists. It works in conjunction with Outlook to allow email messages to be sent
to ListManager for inclusion in lists and uses Outlook to mail messages to
users.

.. contents:: Table of Contents
</t>
<t tx="ekr.20051104081502.328">@language python
@color
@others

@ @rst-options
code_mode = True
@c
</t>
<t tx="ekr.20051104081502.329">@ @rst-markup

Nothing unusual in what follows:  we start with the module imports, setting some global constants including Menu Ids and read the ListManager.ini file.</t>
<t tx="ekr.20051104081502.33">@language plain

The first idea was to use Python's imp module to simulate an import from a file.  This does not work well because imp expects a file, not a StringIO object.

The second idea was to use Python's parser module.  But this returns an instance type, not a module.

A third idea would be to subclass the file type to fool the imp module.

A fourth idea would be to use the ihooks module.  Apparently this module was designed to do something like what I am trying to do!  However, there doesn't seem to be docs for it, so I have imported the code...

@color</t>
<t tx="ekr.20051104081502.330">from wxPython.wx import *
from wxPython.lib.mixins.listctrl import wxListCtrlAutoWidthMixin

import os
import time
import pickle
import socket
import select
import random
import ConfigParser
import threading
import re
import sys

from pywintypes import CreateGuid
from win32com.client import Dispatch
#import win32pdh
import win32api
#from win32com.client import constants #--&gt; just needed two constants...

import MySQLdb
import sqlite
import mx.DateTime

from LMDialogs import CalendarDialog, ModifierDialog, TicklerDialog, MailDialog,LoggerDialog, FinishedDialog, FindDialog, EvalDialog, TreeDialog, StartupDialog
#from wxTreeCtrl import TreeDialog

from printout import PrintTable</t>
<t tx="ekr.20051104081502.331">@nocolor

os
    uses ``os.getcwd``, ``os.path.split``, ``os.chdir``, ``os.path.join``, ``os.path.getmtime``, ``os.startfile``, ``os.environ``

time
    uses ``time.sleep``, ``time.asctime``

pickle
    used to serialize data that is moved from Outlook to ListManager via sockets.  

socket
    as noted above, a socket is opened between Outlook and ListManager to move messages back and forth

select
    ListManager selects on the socket to see if there is a message that has been queued by Outlook

random
    used by the reminder popup to select messages

ConfigParser
    not surprisingly, using ConfiParser to parse the ListManager.ini file.  

threading
    more for fun than absolute necessity, a thread is opened on starting the program that constructs the list of owners for items.  In theory, if the datasize and number of Lists were large enough it could delay the appearance of the GUI and its initial responsiveness if we didn't construct the ownerlist in a thread.  On the other hand, it really let me play with threads and with creating a custom event that signalled the construction of the owner list to the main thread by posting a custom event.

re
    mainly using ``re.sub('[\\/:*"&lt;&gt;|\?]','-',f)`` to make sure that files are constructed only with legal characters.  Also searching the body text of nodes using re because it allows case insensitive searches through ``re.compile(pat, re.I)``.

pywintypes.CreateGuid
    probably should use pure python GUID that is in ASPN cookbook but it was easiest to just use the Windows GUID function.  Thank you Mark Hammond for win32all.

win32com.client.Dispatch
    used when launching Outlook to send email messages

win32api
    using win32api.GetUserName() in case there is no user name in the ini file or no ini file

MySQLdb
    using Andy Dustman's python extension module to connect to mysql back-end.

sqlite
    using  D. Richard Hipp's python extension to connect to local sqlite databases

import mx.DateTime
    using Marc-Andr Lemburg's mx.DateTime for dealing with datetime stuff in the databases

CalendarDialog, ModifierDialog, TicklerDialog, MailDialog,LoggerDialog, FinishedDialog, FindDialog, EvalDialog, TreeDialog, StartupDialog
   should just import LMDialogs and then access each dialog class by LM.WhateverDialog

printout.PrintTable
    There was an existing wxPython print module for printing from tables that I have modified to print Lists.

*#from win32com.client import constants*
    probably not wise but since the app only needs two constants from this module, just set the directly.  If MSFT decides to change the api, this is not good.
</t>
<t tx="ekr.20051104081502.332">cwd = os.getcwd()
DIRECTORY = os.path.split(cwd)[0]
os.chdir(DIRECTORY)
del cwd

#Outlook Constants
olMailItem = 0x0
olFlagMarked = 0x2

OFFLINE_ONLY = False #False-&gt; Online only  ; True-&gt; Online and Offline possible; REMOTE_HOST = None -&gt; Offline only

VERSION = '1.02'

@ @rst-markup

The following two global constants are needed to create emails through Outlook via COM::

    olMailItem = 0x0
    olFlagMarked = 0x2

For some reason, it seemed easier to just include them explicitly rather than worrying about generating all the Outlook constants in order to use early binding.  I supppose if MSFT changes the api, that would be a problem.
</t>
<t tx="ekr.20051104081502.333">@ @rst-markup
Menu Ids -- not much more to say although there should be something to say.
@c

#File Menu-----------------#
idNEWLIST = 1000
idOPENLIST = 1010
idCLOSELIST = 1015
idCLOSEALL = 1017
idSAVEAS = 1020
idDELETELIST = 1025
idPAGESETUP = 1030
idPRINT = 1035
idPRINTPREV = 1040
idMAILLIST = 1045
idOFFLINE = 1048
idEXIT = 1050

#Edit Menu-----------------
idCUT = 1055
idCOPY = 1060
idPASTE = 1065
idDELETEITEMS = 1070
idCOMBINEITEMS = 1075
idFIND = 1080

#Item Menu-------------------
idNEWITEM = 1085
idTOGGLEFINISHED = 1090
idEDITOWNER = 1095
idDUEDATE = 1100
idEDITNOTE = 1105
idMAILITEM =1110

#Diplay Menu---------------------
idSHOWFINISHED = 1115
idSHOWALL = 1120
idREFRESH = 1125
idDISPLAYDATE = 1130

#Tool Menu------------------------
idTICKLERACTIVE = 1135
idSHOWNEXT = 1140
idSYNC = 1145
idARCHIVE = 1150
idEVALUATE = 1155
idTOOLPRINT = 1165
idSENDTO = 1170

#Help Menu-------------------------
idABOUT = 1175
idHELP = 1180


</t>
<t tx="ekr.20051104081502.334">config_file = os.path.join(DIRECTORY, "List Manager.ini")
defaults = dict(pw='python', db='listmanager', ext='txt', local='wxLMDB:sqlite', x='700', y='400')
cp = ConfigParser.ConfigParser(defaults=defaults)
cp.read(config_file) #ConfigParser closes the file

USER = cp.has_option('User','user') and cp.get('User','user') or win32api.GetUserName()

# the following all have default values provided in the constructor
PW = cp.get('User','pw')
DB = cp.get('Database','db')
NOTE_EXT = cp.get('Note','ext')
LOCAL_HOST = cp.get('Hosts','local')
X = cp.getint('Configuration','x')
Y = cp.getint('Configuration','y')

# the folloowing default to None
MAIL_LIST_PATH = cp.has_option('Mail','path') and cp.get('Mail','path') or None
QUICK_LIST = cp.has_option('User','quicklist') and cp.get('User','quicklist') or None

# the following default to False
STARTUP_DIALOG = cp.has_option('User','startup_dialog') and cp.getboolean('User','startup_dialog')
DELETE_LIST = cp.has_option('User','delete_list') and cp.getboolean('User','delete_list')
OUTLOOK = cp.has_option('Mail','outlook') and cp.getboolean('Mail','outlook')

if cp.has_option('Hosts','remote'):
    REMOTE_HOST = cp.get('Hosts','remote')
else:
    REMOTE_HOST = None
    OFFLINE_ONLY = True
    
# reading it again because of the way defaults are handled
cp = ConfigParser.ConfigParser()
cp.read(config_file) #ConfigParser closes the file

if cp.has_section('Synchronization'):
    SYNC_TABLES = [t[1] for t in cp.items('Synchronization')]
else:
    SYNC_TABLES = ['follow_ups']

</t>
<t tx="ekr.20051104081502.335">@nocolor

.. sidebar:: A typical *List Manager.ini* file:

    ::

        [Files]
        path0 = wxLMDB:sqlite:mine
        path1 = nycpsszatzsql:mysql:follow_ups
        
        [Database]
        db = listmanager
        
        [Note]
        ext = txt
        
        [Synchronization]
        sync2 = follow_ups
	sync1 = test
        
        [Hosts]
        remote = nycpsszatzsql:mysql
        local = wxLMDB:sqlite
        
        [User]
        startup_dialog = true
        user = szatz
        pw = python
        
        [Mail]
	outlook = true
	path = wxLMDB:sqlite:mail_transfer
        
        [Configuration]
        y = 642
        x = 975

Application uses the ``ConfigParser`` module ito parse the ini file.  Unfortunately, ``ConfigParser`` doesn't work exactly like I think it should although it has been improved in 2.3.  My main issue is in the handling of default options.  The default options specified through the constructor show up in every section.  For example, if you use the items(*section*) method
then in addition to returning a list of tuples with whatever option/value pairs exist in the section, the list will include all the default option/value pairs, which does not make a whole lot of sense to me.  At the least, there should be a 'nodefaults' argument whose default was *False* but which could be set to *True*.  The following methods should have this option:

- items
- options
- has_option

In any event, because a nodefaults option does not exist, I create the ConfigParser object twice -- once with default options and once without them.  

The application will work fine if there is no ini file. In an effort to save some typing but not be too obscure, many of the options are read such that they default to the correct value either through explicit defaults in the constructor or statements that evaluate to *None* or *False*.

    ``QUICK_LIST = cp.has_option('User','quicklist') and cp.get('User','quicklist') or None``
    
    ``OUTLOOK = cp.has_option('Mail','outlook') and cp.getboolean('Mail,'outlook')``</t>
<t tx="ekr.20051104081502.336">class ListManager(wxFrame):
    @others

@ @rst-markup

ListManager is the main class in the application and is a sublass of ``wxFrame``, which is typical for a wxPython application.  From a GUI standpoint, the main child window of the ListManager object is a ``wxNoteBook`` object that holds one ``wxListCtrl`` per notebook page and one ``wxListBox``.  The ``wxListCtrl``\s display item information (e.g., name of the item, owners of the item, etc.) for a particular List and the ``wxListBox``\es displays a list of owners that is used to filter the items displayed by the ``wxListCtrl`` object.

Each ``wxListCtrl`` object has its own set of events that it is hooked to (see CreateNewNotebookPage`&lt;&lt; ListControl Events &gt;&gt;`_.
</t>
<t tx="ekr.20051104081502.337"></t>
<t tx="ekr.20051104081502.338">def __init__(self, parent, id, title, size):
    wxFrame.__init__(self, parent, id, title, size = size)

    self.SetIcon(wxIcon('bitmaps//wxpdemo.ico', wxBITMAP_TYPE_ICO))
    self.CreateStatusBar()
  
    &lt;&lt; ListManager Attributes &gt;&gt;
    &lt;&lt; Menu Setup &gt;&gt;
    &lt;&lt; Toolbar Setup &gt;&gt;
    &lt;&lt; Menu/Toolbar Events &gt;&gt;
    &lt;&lt; Create Controls&gt;&gt;
    &lt;&lt; Layout Stuff &gt;&gt;
    &lt;&lt; Other Events &gt;&gt;
    &lt;&lt; GUI Instance Objects &gt;&gt;
    &lt;&lt; Create Socket &gt;&gt;
    &lt;&lt; Load Recent Files &gt;&gt;
    &lt;&lt; Idle Timer &gt;&gt;
    
    ownerthread = threading.Thread(target=self.createownerlist)
    ownerthread.start()
    self.ModifierDialog = None

</t>
<t tx="ekr.20051104081502.339">@nocolor

The ListManager ``__init__`` method is pretty straightforward.  The ``__init__`` arguments are the ones that need to be passed to ``wxFrame __init__`` method. The wxFrame class has the following form:

    ``wxFrame(parent, id, title, pos=wxDefaultPosition, size=wxDefaultSize, style=wxDEFAULT_FRAME_STYLE, name="frame")``

The default style (``wxDEFAULT_FRAME_STYLE``) includes ``wxMINIMIZE_BOX``, ``wxMAXIMIZE_BOX``, ``wxRESIZE_BORDER``, ``wxSYSTEM_MENU``, ``wxCAPTION`` (the latter is the text that appears in the title bar).

``SetIcon`` is a method of ``wxFrame`` that sets the icon in the upper left of the title bar of the frame.  The wxIcon class has the following form:

    ``wxIcon(filename, type, desiredWidth=-1, desiredHeight=-1)``

``CreateStatusBar`` is a method of ``wxFrame``. The wxPython form is:

        ``CreateStatusBar(number=1, style=0, id=-1)``

*number* --&gt;
    number of fields to create. Specify a value greater than 1 to create a multi-field status bar.

``CreateStatusBar`` needs to be called before &lt;&lt; Load Recent Files &gt;&gt;.

The various sections of ``__init__`` are explained in their corresponding section::

    &lt;&lt; ListManager Attributes &gt;&gt;
    &lt;&lt; Menu Setup &gt;&gt;
    &lt;&lt; Toolbar Setup &gt;&gt;
    &lt;&lt; Menu/Toolbar Events &gt;&gt;
    &lt;&lt; Create Controls&gt;&gt;
    &lt;&lt; Layout Stuff &gt;&gt;
    &lt;&lt; Other Events &gt;&gt;
    &lt;&lt; GUI Instance Objects &gt;&gt;
    &lt;&lt; Create Socket &gt;&gt;
    &lt;&lt; Load Recent Files &gt;&gt;</t>
<t tx="ekr.20051104081502.34">import imp
import StringIO

@
load_module( name, file, filename, description) 

Load a module that was previously found by find_module() (or by an otherwise conducted search yielding compatible results). This function does more than importing the module: if the module was already imported, it is equivalent to a reload()! The name argument indicates the full module name (including the package name, if this is a submodule of a package). The file argument is an open file, and filename is the corresponding file name; these can be None and '', respectively, when the module is not being loaded from a file. The description argument is a tuple, as would be returned by get_suffixes(), describing what kind of module must be loaded. 
If the load is successful, the return value is the module object; otherwise, an exception (usually ImportError) is raised. 

Important: the caller is responsible for closing the file argument, if it was not None, even when an exception is raised. This is best done using a try ... finally statement.
@c

s = """

def foobar(): pass

"""

@ get_suffixes( ) 

Return a list of triples, each describing a particular type of module. Each triple has the form (suffix, mode, type), where suffix is a string to be appended to the module name to form the filename to search for, mode is the mode string to pass to the built-in open() function to open the file (this can be 'r' for text files or 'rb' for binary files), and type is the file type, which has one of the values PY_SOURCE, PY_COMPILED, or C_EXTENSION, described below.
@c

g.pr('-' * 20)
description = (".py","r",imp.PY_SOURCE)
theFile = StringIO.StringIO(s) # Create a file-like object
g.pr(repr(theFile))
try:
    imp.load_module("myModule",theFile,"myFileName",description)
except:
    g.es_exception()



</t>
<t tx="ekr.20051104081502.340">self.PropertyDicts = []
self.ItemLists = []
self.ListCtrls = []
self.OwnerLBoxes = []

self.L = -1
self.curIdx = -1

self.printdata = wxPrintData()
self.printdata.SetPaperId(wxPAPER_LETTER)
self.printdata.SetOrientation(wxPORTRAIT)

#self._options = {} #would be used in loadconfig

self.copyitems = []    
self.modified = {}
self.tickler_active = False

#there is a wxPanel in the AddListControl method so each wxListCtrl has a different panel as parent
#there is a nb_sizer = wxNotebookSizer(nb) class but doesn't seem to make any difference

self.editor = []

self.Cursors = {}
self.sqlite_connections = []
self.popupvisible = False
self.in_place_editor = None
self.showrecentcompleted = 0

self.LC_font = wxFont(9, wxSWISS, wxNORMAL, wxNORMAL)

self.date_titles = {'createdate':"Create Date",'duedate':"Due Date",'timestamp':"Last Modified",'finisheddate':"Completion Date"}
self.attr2col_num = {'priority':0, 'name':1,'owners':2, 'date':3}

self.FindDialog = FindDialog(self, "Find...", "")
self.EvalDialog = EvalDialog(self, "Evaluate...", "")
</t>
<t tx="ekr.20051104081502.341">@nocolor

self.PropertyDicts
    list of dictionaries that describe properties of each ListManager List (note that when referring to a collection of ListManager items a capital *L* List and table are used interchangeably).

self.ItemLists
    list of lists that consist of instance objects of class ``Item``.  Each of the lists contained in self.ItemLists correspond to the items that are being displayed in the ListCtrl.  So ``self.Itemlist[2]`` corresponds to the 2nd tab of the notebook and to the items in self.ListCtrls[2].

The class ``Item`` is just an empty class being used as a convenience to hold item attributes::

    class Item:
        pass

The purpose of the class is just to create an object that can have various attributes as follows:

+-----------------+----------------------------------------------------+
|item.id          |GUID                                                |
+-----------------+----------------------------------------------------+
|item.name        |string that describes the item                      |
+-----------------+----------------------------------------------------+
|item.priority    |integer ranging from 1 (high) to 3 (low)            |
+-----------------+----------------------------------------------------+
|item.owners      |list of the form ["Zatz, Steve", "Hoffman, Steve"]  |
+-----------------+----------------------------------------------------+
|item.note        |string that provides additional info on item        |
+-----------------+----------------------------------------------------+
|item.timestamp   |timestamp indicating when an item was last modified |
+-----------------+----------------------------------------------------+
|item.duedate     |default is None; mx.DateTime date                   |
+-----------------+----------------------------------------------------+
|item.createdate  |mx.DateTime.now() mx.DateTime timestamp             |
+-----------------+----------------------------------------------------+
|item.finisheddate|efaut is None; mx.DateTime date                     |
+-----------------+----------------------------------------------------+

self.ListCtrls
    list of of instance objects of class ListCtrls, which are a subclass of wxPython class wxListCtrl.

self.OwnerLBoxes
    list of of instance objects of wxPython class wxListBox, which is a simple one column List Control.

The wxPython constructor for a wxListBox is:

    ``wxListBox(parent, id, pos=wxDefaultPosition, size=wxDefaultSize, choices=[], style=0)``

self.L
    index of the currently active notebook tab.  If there are any tabs in the notebook then one of them is always selected.  If there are no tabs then this is indicated by setting ``self.L = -1``.

self.curIdx
    currently selected row in the active ``ListCtrl``.  There are times like after a row is deleted in which there may be rows visible but no row is selected.

The following lines set the default printer data::

    self.printdata = wxPrintData()
    self.printdata.SetPaperId(wxPAPER_LETTER)
    self.printdata.SetOrientation(wxPORTRAIT)


The wxPython class ``wxPrintData`` holds a variety of information related to printers and printer device contexts. This class is used to create a wxPrinterDC and a wxPostScriptDC. It is also used as a data member of wxPrintDialogData and wxPageSetupDialogData, as part of the mechanism for transferring data between the print dialogs and the application.

self.copyitems
    list that contains item instance objects that have been copied from one list to be moved to another list.

self.modified
    dictionary that contains the information concerning whether any of several elements have been changed.  Chose a dictionary more to test the idea that I could create a simple method that would update the dictionary and here is an example:

    ``EVT_TEXT(self, self.name.GetId(), lambda e: self.modified.update({'name':1}))``

So this lambda function means that if an ``EVT_TEXT`` event occurs then update the dictionary by adding the key to the dictionary (the value is not used and arbitrarily set to 1).  The wxPython form for the macro ``EVT_TEXT`` is:

    ``EVT_TEXT(window, id, func)``

A ``wxEVT_COMMAND_TEXT_UPDATED`` event is generated when the text in a ``wxTextCtrl`` changes and that is what ``EVT_TEXT`` catches. Note that this event will always be sent when the text controls content changes - whether this is due to user input or comes programmatically (for example, if ``SetValue()`` is called)

self.Cursors
    dictionary that holds the database cursor objects.  For example, it will look like:  ``{'sqlite':&lt;sqlite cursor object&gt;,'nycpsltszatz':&lt;mysql cursor object&gt;}``

self.tickler_active
    booean determines whether the tickler capabililty is active; can be shut off by unchecking Tickler menu item

self.editor
    list that holds the dictionaries that describe the notes that are edited by the external text editor::

        [
        {
        'table': 'mine',
        'host': 'wxLMDB:sqlite',
        'path': 'C:\\DOCUME~1\\STEVEN~1\\LOCALS~1\\Temp\\Journal Scan schedule.txt',
        'id': '1AB34FB9-9EE6-4AFC-8AF0-FFCA50103BF3',
        'time': 1070850894
        }, 
        {
        'table': 'factoids',
        'host': 'wxLMDB:sqlite',
        'path': 'C:\\DOCUME~1\\STEVEN~1\\LOCALS~1\\Temp\\How many cme programs are sponsored- - 91%.txt', 
        'id': '9CAC4D18-DE1C-4535-B9A5-4CDB1AD3F304', 
        'time': 1070850908
        }
        ]

The method that uses self.editor is `&lt;&lt; Check if Edited File has Changed &gt;&gt;`_.

There is a ``wxPanel`` in the ``AddListControl`` method so each ``wxListCtrl`` has a different panel as parent.

There is a nb_sizer = wxNotebookSizer(nb) class but doesn't seem to make any difference.

self.sqlite_connections
    Here because the sqlite connection has a weakreference that deletes it when you want it around

self.popupvisible
    boolean that is used to ensure that two reminder popups aren't visible at the same time.

self.in_place_editor 
    boolean that indicates whether the inplace item name text editor is active or not.

self.showrecentcompleted
    integer that determines the number of days in the past to retain completed items in the display.

self.LC_font
    default font for all of the ``ListCtrls``:  ``self.LC_font = wxFont(9, wxSWISS, wxNORMAL, wxNORMAL)``

The wxPython ``wxFont`` constructor is:

    ``wxFont(pointSize, family, style, weight, underline=False, faceName="", wencoding=wxFONTENCODING_DEFAULT)``

self.date_titles
    dictionary that holds the various dates that are associated with each item and which can be displayed in the date column.  The dictionary is not modified.  We use one column of each ``ListCtrl`` to display any one of the four dates that that the application tracks. This dictionary associates the item attribute with the text that will be displayed in both the column header for the date and in the dropdown that allows you to change the date:  ``self.date_titles = {'createdate':"Create Date",'duedate':"Due Date",'timestamp':"Last Modified",'finisheddate':"Completion Date"}``

self.attr2col_num
    dictionary that associates the item attribute with the column that attribute is displayed in in the ``ListCtrl``:  ``self.attr2col_num = {'priority':0, 'name':1,'owners':2, 'date':3}``

The following lines construct the Find Dialog and the Dialog that catches errors and shows expressions for debugging::

    self.FindDialog = FindDialog(self, "Find...", "")
    self.EvalDialog = EvalDialog(self, "Evaluate...", "")</t>
<t tx="ekr.20051104081502.342">filemenu = wxMenu()
filemenu.Append(idNEWLIST, "New List...", "Create a new List")
filemenu.Append(idOPENLIST, "Open List...", "Open a List")
filemenu.Append(idCLOSELIST, "Close", "Close the current List")
filemenu.Append(idCLOSEALL, "Close All", "Close all open Lists")
filemenu.Append(idSAVEAS, "Save As Text File...", "Save the current List")
filemenu.AppendSeparator()
filemenu.Append(idDELETELIST, "Delete List...", "Select a list to delete")
filemenu.AppendSeparator()
filemenu.Append(idPAGESETUP, "Page Setup...")
filemenu.Append(idPRINT, "Print...", "Print the current view")
filemenu.Append(idPRINTPREV, "Print Preview")
filemenu.AppendSeparator()
filemenu.Append(idMAILLIST, "Mail...", "Mail the current view")
filemenu.AppendSeparator()
filemenu.AppendCheckItem(idOFFLINE, "Work Offline")
filemenu.AppendSeparator()
filemenu.Append(idEXIT, "Exit", "Exit the program")

editmenu = wxMenu()
editmenu.Append(idCUT, "Cut\tCtrl+X")
editmenu.Append(idCOPY, "Copy\tCtrl+C")
editmenu.Append(idPASTE, "Paste\tCtrl+V")
editmenu.AppendSeparator()
editmenu.Append(idDELETEITEMS, "Delete")
editmenu.AppendSeparator()
editmenu.Append(idCOMBINEITEMS, "Combine Items...")
editmenu.AppendSeparator()
editmenu.Append(idFIND, "Find...")

itemmenu = wxMenu()
itemmenu.Append(idNEWITEM, "New Item")
itemmenu.AppendSeparator()
itemmenu.Append(idTOGGLEFINISHED, "Toggle Finished")
itemmenu.Append(idEDITOWNER, "Owner...")
itemmenu.Append(idDUEDATE, "Due Date...")
itemmenu.Append(idEDITNOTE, "Note...")
itemmenu.AppendSeparator()
itemmenu.Append(idMAILITEM, "Mail...")

displaymenu = wxMenu()
displaymenu.Append(idSHOWFINISHED, "Show/Hide Finished...")
displaymenu.AppendSeparator()
displaymenu.Append(idSHOWALL, "Show All", "Show all items in the current list")
displaymenu.AppendSeparator()
displaymenu.Append(idREFRESH, "Refresh Display", "Refresh the Display")
displaymenu.Append(idDISPLAYDATE, "Select Date to Display")

toolmenu = wxMenu()
toolmenu.AppendCheckItem(idTICKLERACTIVE, "Tickler Active")
toolmenu.Check(idTICKLERACTIVE,False)
toolmenu.Append(idSHOWNEXT, "Show Next Reminder")
toolmenu.Append(idSYNC, "Synchronize local and remote DBs")
toolmenu.Append(idARCHIVE, "Archive completed items in list...")
toolmenu.Append(idEVALUATE, "Evaluate an expression...")

helpmenu = wxMenu()
helpmenu.Append(idABOUT, "About ListManager")
helpmenu.Append(idHELP, "Help")

menubar = wxMenuBar()
menubar.Append(filemenu, '&amp;File')
menubar.Append(editmenu, 'Edit')
menubar.Append(itemmenu, 'Item')
menubar.Append(displaymenu, 'Display')
menubar.Append(toolmenu, 'Tools')
menubar.Append(helpmenu, 'Help')
self.SetMenuBar(menubar)
toolmenu.Enable(idSHOWNEXT,self.tickler_active)
filemenu.Enable(idDELETELIST,DELETE_LIST)
filemenu.Check(idOFFLINE,OFFLINE_ONLY)

#file history
self.filehistory = wxFileHistory()
self.filehistory.UseMenu(filemenu)

</t>
<t tx="ekr.20051104081502.343">@nocolor

+------------------------+------------------------------------------------+
|**File Menu**           |                                                |
+------------------------+------------------------------------------------+
| "New List... "         ||nl| ``self.OnNewList``                         |
+------------------------+------------------------------------------------+
| "Open List..."         ||ol| ``self.OnOpenList``                        |
+------------------------+------------------------------------------------+
| "Close"                |``self.OnCloseList``                            |
+------------------------+------------------------------------------------+
| "Close All"            |``self.OnCloseAll``                             |
+------------------------+------------------------------------------------+
| "Save As Text File..." |``self.OnSaveAsText``                           |
+------------------------+------------------------------------------------+
| "Delete List..."       ||de| ``self.OnDeleteList``                      |
+------------------------+------------------------------------------------+
| "Page Setup..."        ||ps| ``self.OnPageSetup``                       |
+------------------------+------------------------------------------------+
| "Print..."             ||pt| ``self.OnPrint``                           |
+------------------------+------------------------------------------------+
| "Print Preview"        ||pp| ``lambda e: self.OnPrint(e, prev=True)``   |
+------------------------+------------------------------------------------+
| "Mail..."              |``self.OnMailView``                             |
+------------------------+------------------------------------------------+
| "Work Offline"         |``self.OnWorkOffline``                          |
+------------------------+------------------------------------------------+
| "Exit"                 |``self.OnExit``                                 |
+------------------------+------------------------------------------------+
| **Edit Menu**          |                                                |
+------------------------+------------------------------------------------+
| "Cut" [Ctrl+X ]        ||ec| ``lambda e: self.OnCopyItems(e, cut=True)``|
+------------------------+------------------------------------------------+
| "Copy" [Ctrl+C]        ||ey| ``self.OnCopyItems``                       |
+------------------------+------------------------------------------------+
| "Paste" [Ctrl+V]       ||ep| ``self.OnPasteItems``                      |
+------------------------+------------------------------------------------+
| "Delete"               ||de| ``self.OnDeleteItems``                     |
+------------------------+------------------------------------------------+
| "Combine Items..."     |``self.OnCombineItems``                         |
+------------------------+------------------------------------------------+
| "Find..."              ||fi| ``self.OnFind``                            |
+------------------------+------------------------------------------------+
| **Item Menu**          |                                                |
+------------------------+------------------------------------------------+
| "New Item"             ||ni| ``self.OnNewItem``                         |
+------------------------+------------------------------------------------+
| "Toggle Finished"      ||co| ``self.OnToggleFinished``                  |
+------------------------+------------------------------------------------+
| "Owner..."             ||ow| ``self.OnEditOwner``                       |
+------------------------+------------------------------------------------+
| "Due Date..."          ||dd| ``self.OnDueDate``                         |
+------------------------+------------------------------------------------+
| "Note..."              ||en| ``self.OnEditNote``                        |
+------------------------+------------------------------------------------+
| "Mail..."              ||mi| ``self.OnMailItem``                        |
+------------------------+------------------------------------------------+
| **Display Menu**       |                                                |
+------------------------+------------------------------------------------+
| "Show/Hide Finished..."|``self.OnShowFinished``                         |
+------------------------+------------------------------------------------+
| "Show All"             |``self.OnShowAll``                              |
+------------------------+------------------------------------------------+
| "Refresh Display"      ||re| ``self.OnRefresh``                         |
+------------------------+------------------------------------------------+
|"Select Date to Display"|``self.OnDisplayDateCategory``                  |
+------------------------+------------------------------------------------+
| **Tool Menu**          |                                                |
+------------------------+------------------------------------------------+
| "Tickler Active"       |``self.OnActivateTickler``                      |
+------------------------+------------------------------------------------+
| "Show Next Reminder"   |``self.OnShowTickler``                          |
+------------------------+------------------------------------------------+
| "Synchronize ..."      |``self.OnSync``                                 |
+------------------------+------------------------------------------------+
| "Archive completed..." |``self.OnArchive``                              |
+------------------------+------------------------------------------------+
| "Evaluate expression"  |``self.OnShowEvaluate``                         |
+------------------------+------------------------------------------------+
| **Help Menu**          |                                                |
+------------------------+------------------------------------------------+
| "About ListManager"    |``self.OnShowAbout``                            |
+------------------------+------------------------------------------------+
| "Help"                 |``self.OnShowHelp``                             |
+------------------------+------------------------------------------------+




</t>
<t tx="ekr.20051104081502.344">tb = self.CreateToolBar(wxTB_HORIZONTAL|wxTB_FLAT)

tb.AddLabelTool(idNEWLIST, "New (local) List", wxBitmap('bitmaps\\new.bmp'), shortHelp="Create New List")
tb.AddLabelTool(idOPENLIST, "Open", wxBitmap('bitmaps\\open.bmp'), shortHelp="Open List")
tb.AddSeparator()
tb.AddLabelTool(idTOOLPRINT, "Print", wxBitmap('bitmaps\\print.bmp'), shortHelp="Print List")
tb.AddLabelTool(idPRINTPREV, "Preview", wxBitmap('bitmaps\\preview.bmp'), shortHelp="Print Preview")
tb.AddLabelTool(idPAGESETUP, "Setup", wxBitmap('bitmaps\\setup.bmp'), shortHelp="Page Setup")
tb.AddSeparator()
tb.AddLabelTool(idNEWITEM, "New Item", wxBitmap('bitmaps\\new_item.bmp'), shortHelp="Create New Item")
tb.AddSeparator()
tb.AddLabelTool(idREFRESH, "Refresh", wxBitmap('bitmaps\\refresh.bmp'), shortHelp="Refresh Display")     
tb.AddSeparator()
tb.AddLabelTool(idEDITNOTE, "Edit Note", wxBitmap('bitmaps\\edit_doc.bmp'), shortHelp="Edit Note")
tb.AddSeparator()
tb.AddLabelTool(idFIND, "Find", wxBitmap('bitmaps\\find.bmp'), shortHelp = "Find Item")        
tb.AddSeparator()
tb.AddLabelTool(idCUT, "Cut", wxBitmap('bitmaps\\editcut.bmp'), shortHelp ="Cut Item")        
tb.AddLabelTool(idCOPY, "Copy", wxBitmap('bitmaps\\copy.bmp'), shortHelp ="Copy Item")
tb.AddLabelTool(idPASTE, "Paste", wxBitmap('bitmaps\\paste.bmp'), shortHelp="Paste Item")
tb.AddSeparator()
tb.AddLabelTool(idTOGGLEFINISHED, "Toggle Date", wxBitmap('bitmaps\\filledbox.bmp'), shortHelp="Toggle Finished Date")
tb.AddLabelTool(idDELETEITEMS, "Delete", wxBitmap('bitmaps\\delete.bmp'), shortHelp="Delete Item")
tb.AddLabelTool(idDUEDATE, "Due Date", wxBitmap('bitmaps\\calendar.bmp'), shortHelp="Enter Due Date")
tb.AddLabelTool(idEDITOWNER,"Owner", wxBitmap('bitmaps\\owners.bmp'), shortHelp="Select Owner(s)")
tb.AddSeparator()
tb.AddLabelTool(idMAILITEM, "Mail", wxBitmap('bitmaps\\mail.bmp'), shortHelp="Mail Item")

if QUICK_LIST:
    tb.AddSeparator()
    tb.AddLabelTool(idSENDTO, "Send to", wxBitmap('bitmaps\\sendto.bmp'), shortHelp="Send to %s"%QUICK_LIST)
    
tb.Realize()
</t>
<t tx="ekr.20051104081502.346">#File Menu ------------------------------------
EVT_MENU(self, idNEWLIST, self.OnNewList)
EVT_MENU(self, idOPENLIST, self.OnOpenList)
EVT_MENU(self, idCLOSELIST, self.OnCloseList)
EVT_MENU(self, idCLOSEALL, self.OnCloseAll)
EVT_MENU(self, idSAVEAS, self.OnSaveAsText)
EVT_MENU(self, idDELETELIST, self.OnDeleteList)
EVT_MENU(self, idPAGESETUP, self.OnPageSetup)
EVT_MENU(self, idPRINT, self.OnPrint)
EVT_MENU(self, idPRINTPREV, lambda e: self.OnPrint(e, prev=True))
EVT_MENU(self, idOFFLINE, self.OnWorkOffline)
EVT_MENU(self, idMAILLIST, self.OnMailView)      
EVT_MENU_RANGE(self, wxID_FILE1, wxID_FILE9, self.OnFileList)
EVT_MENU(self, idEXIT, self.OnExit)
#Edit Menu ------------------------------------
EVT_MENU(self, idCUT, lambda e: self.OnCopyItems(e, cut=True))        
EVT_MENU(self, idCOPY, self.OnCopyItems)
EVT_MENU(self, idPASTE, self.OnPasteItems)
EVT_MENU(self, idDELETEITEMS, self.OnDeleteItems)
EVT_MENU(self, idCOMBINEITEMS, self.OnCombineItems)
EVT_MENU(self, idFIND, self.OnFind)
#item Menu ------------------------------------
EVT_MENU(self, idNEWITEM, self.OnNewItem)
EVT_MENU(self, idTOGGLEFINISHED, self.OnToggleFinished)             
EVT_MENU(self, idDUEDATE, self.OnDueDate)
EVT_MENU(self, idEDITOWNER, self.OnEditOwner)
EVT_MENU(self, idEDITNOTE, self.OnEditNote)
EVT_MENU(self, idMAILITEM, self.OnMailItem)
#Dips Menu ------------------------------------
EVT_MENU(self, idSHOWFINISHED, self.OnShowFinished)
EVT_MENU(self, idSHOWALL, self.OnShowAll)
EVT_MENU(self, idREFRESH, self.OnRefresh)
EVT_MENU(self, idDISPLAYDATE, self.OnDisplayDateCategory)
#Tool Menu ---------------------------------------
EVT_MENU(self, idTICKLERACTIVE, self.OnActivateTickler)
EVT_MENU(self, idSHOWNEXT, self.OnShowTickler)
EVT_MENU(self, idSYNC, self.OnSync)
EVT_MENU(self, idARCHIVE, self.OnArchive)
EVT_MENU(self, idEVALUATE, self.OnShowEvaluate)
#Help Menu -----------------------------------------
EVT_MENU(self, idABOUT, self.OnShowAbout)
EVT_MENU(self, idHELP, self.OnShowHelp)

EVT_TOOL(self, idTOOLPRINT, lambda e: self.OnPrint(e,showprtdlg=False))

if QUICK_LIST:
    EVT_TOOL(self, idSENDTO, lambda e: self.OnMoveToSpecificList(e,QUICK_LIST))
</t>
<t tx="ekr.20051104081502.348">upper_panel = wxPanel(self, -1)   #size = (900,400)
bottom_panel = wxPanel(self, -1, size = (900,150)) #900 note that 000 seems to work???

nb = wxNotebook(upper_panel, -1, size=(900,500), style=wxNB_BOTTOM)

f = wxFont(10, wxSWISS, wxNORMAL, wxNORMAL)
self.name = wxTextCtrl(bottom_panel, -1, size = (285,42), style = wxTE_MULTILINE|wxTE_RICH2)#34 #wxTE_PROCESS_ENTER
self.name.SetDefaultStyle(wxTextAttr("BLACK", font = f))
     
self.owners = wxTextCtrl(bottom_panel, -1, size = (250,42),style = wxTE_MULTILINE|wxTE_RICH2)
self.owners.SetDefaultStyle(wxTextAttr("BLACK", font = f))

self.note = wxTextCtrl(bottom_panel, -1, size = (400,50), style=wxTE_MULTILINE)
 </t>
<t tx="ekr.20051104081502.35">if 0:
    class myFile(file):
        pass
        
    g.pr(myFile)
    g.pr(issubclass(myFile,file))
    g.pr(isinstance(myFile,file))
    g.pr(super(myFile))
    g.pr(__import__)
    
if 0:
    old_import = __import__
        
    def myImport(*args,**keys):
        g.pr("myImport")
        global old_import
        old_import(*args,**keys)
        
    __import__ = myImport
    
mod = __import__("leoApp")
g.pr(mod)</t>
<t tx="ekr.20051104081502.350">EVT_TEXT(self, self.name.GetId(), lambda e: self.modified.update({'name':1}))
EVT_TEXT(self, self.note.GetId(), lambda e: self.modified.update({'note':1}))
EVT_TEXT(self, self.owners.GetId(), lambda e: self.modified.update({'owners':1}))

EVT_CLOSE(self, self.OnWindowExit)

EVT_IDLE(self, self.OnIdle)

</t>
<t tx="ekr.20051104081502.352">#Appears necessary to really get the listcontrol to size with the overall window  
#upper_panel sizer
sizer = wxBoxSizer(wxHORIZONTAL)
sizer.Add(nb,1,wxALIGN_LEFT|wxEXPAND)
upper_panel.SetSizer(sizer)        

#sizer for the row of data items
box = wxBoxSizer(wxHORIZONTAL)
box.Add(self.name,1,wxEXPAND)
box.Add(self.owners,0)

#bottom_panel sizer  
sizer = wxBoxSizer(wxVERTICAL)        
sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
sizer.Add(self.note,1,wxALIGN_LEFT|wxEXPAND)
bottom_panel.SetSizer(sizer)

sizer = wxBoxSizer(wxVERTICAL)
sizer.Add(upper_panel,1,wxALIGN_TOP|wxEXPAND)
sizer.Add(bottom_panel,0,wxALIGN_TOP|wxEXPAND)

self.SetAutoLayout(1)
self.SetSizer(sizer)
#sizer.Fit(self) #actively does bad things to the dimensions on startup
</t>
<t tx="ekr.20051104081502.354">self.toolmenu = toolmenu
self.filemenu = filemenu
self.nb = nb
self.tb = tb
</t>
<t tx="ekr.20051104081502.356">if OUTLOOK:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Create a TCP socket
    s.bind(('localhost',8888)) # Bind to port 8888
    s.listen(5) # Listen, but allow no more than
    self.sock = s
</t>
<t tx="ekr.20051104081502.358">try:
    pathlist = [f[1] for f in cp.items('Files')]
except:
    pathlist = []
    
if pathlist:
    pathlist.sort()
    pathlist.reverse()
    for path in pathlist[1:]:
        self.OnFileList(path=path)

    #don't want to trigger the page change event until n-1 of n files are loaded
    EVT_NOTEBOOK_PAGE_CHANGED(self,nb.GetId(),self.OnPageChange)

    self.OnFileList(path=pathlist[0])
else:
    EVT_NOTEBOOK_PAGE_CHANGED(self,nb.GetId(),self.OnPageChange)



</t>
<t tx="ekr.20051104081502.36">import compiler

for child in p.children_iter():
    h = child.h
    body = child.b
    
    try:
        val = compiler.parse(body)
        g.pr(type(val))
        g.pr(val)
    except SyntaxError:
        g.es("Syntax error: %s" % h,color="blue")</t>
<t tx="ekr.20051104081502.360">ID_TIMER = wxNewId()
self.timer = wxTimer(self, ID_TIMER) 
EVT_TIMER(self,  ID_TIMER, self.OnIdle)
self.timer.Start(3000)
</t>
<t tx="ekr.20051104081502.362"></t>
<t tx="ekr.20051104081502.364">def createownerlist(self):
    
    if REMOTE_HOST and OFFLINE_ONLY is False:
        cursor = self.GetCursor(REMOTE_HOST)
        sql = "SHOW TABLES" #sorted
    else:
        cursor = self.GetCursor(LOCAL_HOST)
        sql = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
        
    cursor.execute(sql)
    results = cursor.fetchall()

    #excluding 'system' tables and archive tables
    excluded_tables = ['user_sync','sync','owners']
    tables = [t for (t,) in results if t.find('_archive')== -1 and t not in excluded_tables]

    sql_list = []
    for table in tables:
        sql_list.append("""SELECT owner1 FROM %s UNION SELECT owner2 FROM %s UNION SELECT owner3 FROM %s"""%((table,)*3))
                
    sql = " UNION ".join(sql_list)
    cursor.execute(sql)
    results = cursor.fetchall()
    
    _list = [x[0] for x in results]
    if '' in _list:
        _list.remove('')
    if None in _list:
        _list.remove(None)
        
    self._list = _list
    
    #posting custom event to signal that this thread is done
    evt = wxPyEvent()
    evt_id = wxNewEventType()
    evt.SetEventType(evt_id)
    self.Connect(-1, -1, evt_id, self.createownerdialog)
    wxPostEvent(self, evt)

</t>
<t tx="ekr.20051104081502.366">def createownerdialog(self, evt=None):
    self.ModifierDialog = ModifierDialog(parent=self, title="Select owner(s)", size=(180,300), style=wxCAPTION, modifierlist = self._list)
    del self._list

</t>
<t tx="ekr.20051104081502.368"></t>
<t tx="ekr.20051104081502.37">import doctest
g.pr(doctest)</t>
<t tx="ekr.20051104081502.370">def CreateNewNotebookPage(self, host, table):
    
    Properties = {'owner':'*ALL',
                'LCdate':'duedate',
                'sort':{'attribute':'priority','direction':0}, #these could be set in Config
                'showfinished':0} #-1 show them all; 0 show none; integer show for that many days
    
    Properties['table'] = table
    Properties['host'] = host
                
    self.PropertyDicts.append(Properties)

    self.L = len(self.ItemLists)#could use self.ListCtrls, self.OwnerLBoxes, etc. with a -1
    
    results = self.ReadFromDB()
    if results is None:
        self.PropertyDicts = self.PropertyDicts[:-1]
        self.L = self.L - 1
        return
        
    panel = wxPanel(self.nb, -1, size = (900,400))
    LCtrl = ListCtrl(panel, -1, style=wxLC_REPORT|wxSUNKEN_BORDER|wxLC_VRULES|wxLC_HRULES)
    LCtrl.SetFont(self.LC_font)
    self.ListCtrls.append(LCtrl)
    
    OLBox = wxListBox(panel, -1, size = (126,550), choices = [""], style=wxLB_SORT|wxSUNKEN_BORDER)
    self.OwnerLBoxes.append(OLBox)
    
    sizer = wxBoxSizer(wxHORIZONTAL)
    sizer.Add(OLBox,0,wxALIGN_LEFT|wxEXPAND)
    sizer.Add(LCtrl,1,wxALIGN_LEFT|wxEXPAND)
    panel.SetSizer(sizer)
        
    self.ItemLists.append(self.CreateAndDisplayList(results)) 

    &lt;&lt; Fill OwnerListBox &gt;&gt;
    &lt;&lt; ListControl Events &gt;&gt;
    
    #img_num = LCtrl.arrows[Properties['sort']['direction']]
    #LCtrl.SetColumnImage(self.attr2col_num[Properties['sort']['attribute']], img_num)
    
    rdbms = host.split(':')[1]
    if rdbms == 'mysql':
        tab_title = '%s (remote)'%table
    else:
        tab_title = table
    
    if table in SYNC_TABLES:
        tab_title = '*'+tab_title
                             
    self.nb.AddPage(panel,tab_title)
    self.nb.SetSelection(self.L)
    
    self.filehistory.AddFileToHistory('%s:%s'%(host,table))

    self.SetStatusText("Successfully loaded %s"%tab_title)
    
</t>
<t tx="ekr.20051104081502.372">cursor = self.GetCursor(host)
if cursor is None:
    g.pr("Couldn't get cursor to fill OwnerListBox")
    return
    
cursor.execute("SELECT owner1 FROM %s UNION SELECT owner2 FROM %s UNION SELECT owner3 FROM %s"%((table,)*3))

owners = [x for (x,) in cursor.fetchall()]

if None in owners:
    owners.remove(None)
if '' in owners:
    owners.remove('')

OLBox.Clear()
for name in owners: 
    OLBox.Append(name)
OLBox.Append('*ALL')
OLBox.SetSelection(0)

</t>
<t tx="ekr.20051104081502.374">LCId = LCtrl.GetId()
EVT_LIST_ITEM_SELECTED(self, LCId, self.OnItemSelected)
EVT_LIST_ITEM_ACTIVATED(self, LCId, self.OnDisplayInPlaceEditor)
EVT_LEFT_DOWN(LCtrl, self.OnLeftDown) 
EVT_LEFT_DCLICK(LCtrl, self.OnLeftDown)
EVT_RIGHT_DOWN(LCtrl, self.OnRightDown)
EVT_LIST_COL_CLICK(self, LCId, self.OnColumnClick)
EVT_LIST_COL_RIGHT_CLICK(self, LCId, self.OnColumnRightClick)

# the following is a ListBox event
EVT_LISTBOX(self, OLBox.GetId(), self.OnFilterOwners)

</t>
<t tx="ekr.20051104081502.376">def OnPageChange(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    self.L = L = self.nb.GetSelection()

    &lt;&lt; Find Highlighted Row &gt;&gt;
    &lt;&lt; Update Title &gt;&gt;
    
    evt.Skip() #051403
    
</t>
<t tx="ekr.20051104081502.378">idx = self.ListCtrls[L].GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
if idx != -1:
    self.curIdx = idx
    #LCtrl.EnsureVisible(idx)
    self.OnItemSelected()
elif self.ItemLists[L]:
    self.curIdx = 0
    self.ListCtrls[L].SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
    #the line above triggers an OnItemSelected EVT so don't need self.OnItemSelected() 092803
else:
    self.curIdx = -1

</t>
<t tx="ekr.20051104081502.380">location,rdbms = self.PropertyDicts[L]['host'].split(':')
table = self.PropertyDicts[L]['table']
self.SetTitle("List Manager:  %s:  %s:  %s"%(location,rdbms,table))

</t>
<t tx="ekr.20051104081502.382"></t>
<t tx="ekr.20051104081502.383">def OnShowTickler(self, evt=None):
    if self.popupvisible:
        return
    
    self.popupvisible = True
    
    host = 'wxLMDB:sqlite'
    cursor = self.Cursors[host]
    table = 'follow_ups'

    sql = "SELECT COUNT() FROM "+table+" WHERE finisheddate IS NULL AND priority &gt; 1"
    cursor.execute(sql)
    results = cursor.fetchone()

    num_items = int(results[0])
    
    if not num_items:
        return

    if self.modified: #Should decide if this should be put back or not
        self.OnUpdate()
        
    n = random.randint(0,num_items-1)

    sql = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp,note FROM "+table+" WHERE finisheddate IS NULL AND priority &gt; 1 LIMIT 1 OFFSET %d"%n
    
    try:
        cursor.execute(sql)
    except:
        g.pr("In OnShowTickler and attempt to Select an item failed")
        return
        
    row = cursor.fetchone()
    
    class Item: pass
    item = Item()

    item.priority = int(row[0]) #int(row[0]) needs int because it seems to come back as a long from MySQL
    item.name = row[1]
    item.createdate = row[2]
    item.finisheddate = row[3]
    item.duedate = row[4]
    item.owners = [z for z in row[5:7] if z is not None] #if you carry around ['tom',None,None] you have an issue when you go write it
    item.id = row[8]
    item.timestamp = row[9]
    item.note = row[10]

    dlg = TicklerDialog(self, "", "Do something about this!!!", size=(550,350))
    TC = dlg.TC
    
    f = wxFont(14, wxSWISS, wxITALIC, wxBOLD, False)
    TC.SetDefaultStyle(wxTextAttr("BLUE",wxNullColour, f))
    TC.AppendText("%s..."%item.name)

    if item.priority == 3:
        TC.SetDefaultStyle(wxTextAttr("RED","YELLOW",f))
    TC.AppendText("%d\n\n"%item.priority)
    
    f = wxFont(8, wxSWISS, wxNORMAL, wxNORMAL)
    TC.SetDefaultStyle(wxTextAttr("BLACK","WHITE", f))
    TC.AppendText("owners: %s\n"%", ".join(item.owners))
    TC.AppendText("created on: %s\n"%item.createdate.Format('%m/%d/%y'))
    if item.duedate:
        ddate = item.duedate.Format('%m/%d/%y')
    else:
        ddate = "&lt;no due date&gt;"
    TC.AppendText("due on: %s\n\n"%ddate)

    note = item.note
    if not note:
        note = "&lt;no note&gt;"
    TC.AppendText("%s\n\n"%note)
    f = wxFont(10, wxSWISS, wxITALIC, wxBOLD)
    TC.SetDefaultStyle(wxTextAttr("BLACK",wxNullColour, f))
    TC.AppendText('follow_ups')
    TC.ShowPosition(0)   #did not do anything
    TC.SetInsertionPoint(0)
    result = dlg.ShowModal()
    dlg.Destroy()
    self.popupvisible = False     

    if result in (wxID_OK, wxID_APPLY):

        for L,Properties in enumerate(self.PropertyDicts):
            if Properties['table'] == table:
                break
        else:
            g.pr("Can't find %s"%table)
            return
                    
        self.nb.SetSelection(L) #if the page changes it sends a EVT_NOTEBOOK_PAGE_CHANGED, which calls OnPageChange
        self.L = L
        self.FindNode(item)
        if result==wxID_APPLY:
            self.OnMailItem(item)

    elif result==wxID_FORWARD:
        self.OnShowTickler()

</t>
<t tx="ekr.20051104081502.384">def OnActivateTickler(self, evt):
    self.tickler_active = not self.tickler_active
    self.toolmenu.Enable(idSHOWNEXT,self.tickler_active)

    
</t>
<t tx="ekr.20051104081502.385"></t>
<t tx="ekr.20051104081502.386">def OnMailItem(self, evt=None, item=None):
    if item is None:
        if self.curIdx == -1:
            return
        else:
            item = self.ItemLists[self.L][self.curIdx]
        
    dlg = MailDialog(self,"Mail a reminder", size=(450,500),
               recipients=item.owners,    
               subject=item.name,
               body=self.GetNote())          
    result = dlg.ShowModal()
    if result==wxID_OK:
        outlook= Dispatch("Outlook.Application")
        newMsg = outlook.CreateItem(olMailItem) #outlook.CreateItem(constants.olMailItem)
        newMsg.To = to = dlg.RTC.GetValue()
        newMsg.Subject = subject = dlg.STC.GetValue()
        newMsg.Body = body = dlg.BTC.GetValue()

        #newMsg.FlagStatus = constants.olFlagMarked
        
        newMsg.Display()

        dlg.Destroy()            
        #del outlook

        self.note.SetSelection(0,0)
        self.note.WriteText("**************************************************\n")
        self.note.WriteText("Email sent on %s\n"%mx.DateTime.today().Format("%m/%d/%y"))
        self.note.WriteText("To: %s\n"%to)
        self.note.WriteText("Subject: %s\n"%subject)
        self.note.WriteText("%s\n"%body)
        self.note.WriteText("**************************************************\n")

</t>
<t tx="ekr.20051104081502.387">def OnMailView(self, evt=None):
    recipients = [self.PropertyDicts[self.L]['owner']]
    
    body = ""
    for i,item in enumerate(self.ItemLists[self.L]):
        body = body+"%d. %s (%d)\n"%(i+1, item.name, item.priority)
    
    subject = "Follow-ups " + mx.DateTime.today().Format("%m/%d/%y")
            
    dlg = MailDialog(self,"Follow-up List", size=(450,500),
               recipients=recipients,
               subject=subject,
               body=body)
               
    val = dlg.ShowModal()
    dlg.Destroy()
    if val==wxID_OK:
        outlook= Dispatch("Outlook.Application")
        newMsg = outlook.CreateItem(olMailItem) #outlook.CreateItem(constants.olMailItem)
        newMsg.To = dlg.RTC.GetValue()
        newMsg.Subject = dlg.STC.GetValue()
        newMsg.Body = dlg.BTC.GetValue()

        newMsg.FlagStatus = olFlagMarked #constants.olFlagMarked
        newMsg.Categories = "Follow-up"
        
        newMsg.Display()
    
        #del outlook

</t>
<t tx="ekr.20051104081502.388"></t>
<t tx="ekr.20051104081502.389">def OnCopyItems(self, event=None, cut=False):
    if self.curIdx == -1:
        return
        
    L = self.L
    IList = self.ItemLists[L]
    LCtrl = self.ListCtrls[L]
    
    &lt;&lt; Find Highlighted Items &gt;&gt;
    
    self.SetStatusText("%d items copied"%len(copyitems))
    if cut:
        self.OnDeleteItems()

</t>
<t tx="ekr.20051104081502.390">copyitems = []
i = -1
while 1:
    i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
    if i==-1:
        break
    item = IList[i]
    item.notes = self.GetNote(L,item) #handles the database situation
    copyitems.append(item)

self.copyitems = copyitems</t>
<t tx="ekr.20051104081502.391">def OnPasteItems(self, evt=None, L=None): #noselect 051603
    #used by OnMoveToList, OnMoveToSpecificList and called directly
    if not self.copyitems:
        g.pr("Nothing was selected to be copied")
        return
        
    if L is None: #this is not needed by OnMoveTo or OnDragToTab but is for a straight call
        L = self.L
        
    Properties = self.PropertyDicts[L]
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]
    
    items = self.copyitems
    numitems = len(items)
    
    for item in items:

        z = item.owners+[None,None,None]

        id = self.GetUID() #we do give it a new id
        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']
        
        createdate = mx.DateTime.now() #need this or else it won't be seen as a new item when synching; would be seen as updated
        command = "INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
        cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))
        
        timestamp = self.TimeStamper(host, cursor, table, id)
        
        #creating a new item breaks the connection between item.x and new_item.x
        class Item: pass
        new_item = Item()
        new_item.id = id
        new_item.priority = item.priority
        new_item.owners = item.owners
        new_item.name = item.name
        new_item.timestamp = timestamp
        new_item.duedate =item.duedate
        new_item.finisheddate = item.finisheddate
        new_item.createdate = createdate
        IList.insert(0,new_item)
        
    self.DisplayList(IList,L)
    
    #If we didn't come from OnMoveToList or OnMoveToSpecificList where L != self.L
    if L==self.L:
        for i in range(numitems):
            LCtrl.SetItemState(i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = numitems-1



</t>
<t tx="ekr.20051104081502.392">def OnDeleteItems(self, event=None):
    """Called directly and by OnCopyItems (cut = true)
    """
    if self.curIdx == -1: #not absolutely necessary but gets you out quickly
        return
        
    L = self.L
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]
    Properties = self.PropertyDicts[L]
    
    i = -1
    while 1:
        i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
        if i==-1:
            break
        item = IList.pop(i)
        LCtrl.DeleteItem(i)

        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']
        
        cursor.execute("DELETE from "+table+" WHERE id = %s", (item.id,))
            
        #Track Deletes for Syncing ############################################
        if table in SYNC_TABLES:
            if host.split(':')[1] == 'sqlite':
                timestamp = mx.DateTime.now()
                cursor.execute("INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,item.name,timestamp))
            else:
                cursor.execute("INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,USER,item.name))
        #########################################################################
        i-=1

    self.name.Clear()
    self.owners.Clear()
    self.note.Clear()
    #note that Clearing does cause self.modified --&gt;{'name':1}
    self.modified = {}
    self.curIdx = -1

</t>
<t tx="ekr.20051104081502.393"></t>
<t tx="ekr.20051104081502.394">def OnLeftDown(self, evt):
    g.pr("Here")
    if self.modified:
        #if inplace editor is open and you click anywhere (same or different row from current row) but in the editor itself then just to close editor
        flag = self.modified.has_key('inplace')
        self.OnUpdate()
        if flag:
            evt.Skip() #without Skip, EVT_LIST_ITEM_SELECTED is not generated if you click in a new row
            return
    
    x,y = evt.GetPosition()
    LCtrl = self.ListCtrls[self.L]
    
    #Using HitTest to obtain row clicked on because there was a noticable delay in the generation of an
    #EVT_LIST_ITEM_SELECTED event when you click on the already selected row
    idx,flags = LCtrl.HitTest((x,y))
    
    #if you are below rows of items then idx = -1 which could match self.curIdx = -1
    if idx == -1:
        return
    
    # only if you click on the currently selected row do the following events occur
    if idx == self.curIdx:
        if x &lt; 18:
            self.OnToggleFinished()
        elif x &lt; 33:
            self.OnPriority()
        elif x &lt; 33 + LCtrl.GetColumnWidth(1):
            self.OnDisplayInPlaceEditor()
        elif x &lt; 33 + LCtrl.GetColumnWidth(1) + LCtrl.GetColumnWidth(2): 
            self.OnEditOwner()
        else:
            self.OnDueDate
    else:
        evt.Skip() #without Skip, EVT_LIST_ITEM_SELECTED is not generated if you click in a new row



</t>
<t tx="ekr.20051104081502.395">def OnRightDown(self, evt):
    x,y = evt.GetPosition()
    
    sendtomenu = wxMenu()
    
    open_tables = []
    for page,Properties in enumerate(self.PropertyDicts):
        host,table = Properties['host'],Properties['table']
        open_tables.append((host,table))
        sendtomenu.Append(1+page,"%s (%s)"%(table,host))
        EVT_MENU(self, 1+page, lambda e,p=page: self.OnMoveToList(e,p))
        
    sendtomenu.Delete(self.L+1) # don't send it to the page you're already on
    sendtomenu.AppendSeparator()
    
    self.closed_tables = []
    for host,cursor in self.Cursors.items():

        location, rdbms = host.split(':')

        if rdbms == 'sqlite':
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
        elif rdbms == 'mysql':
            cursor.execute("SHOW tables")

        results = cursor.fetchall()
        
        page+=1
        for (table,) in results:
            if not ((host,table) in open_tables or table in ['user_sync','owners','sync']):
                self.closed_tables.append((host,table))
                sendtomenu.Append(1+page,"%s (%s)"%('*'+table,host))
                EVT_MENU(self, 1+page, lambda e,p=page: self.OnMoveToList(e,p))
                page+=1

    self.PopupMenu(sendtomenu,(x+125,y+40))
    sendtomenu.Destroy()

</t>
<t tx="ekr.20051104081502.396"></t>
<t tx="ekr.20051104081502.397">def OnCombineItems(self, evt):
    L = self.L
    idx = self.curIdx
    IList = self.ItemLists[L]
    LCtrl = self.ListCtrls[L]
    
    combine_list = []
    i = -1
    while 1:
        i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
        if i==-1:
            break
        combine_list.append((IList[i].createdate,IList[i]))

    
    if len(combine_list) &lt; 2:
        g.pr("Fewer than two items highlighted")
        return
    
    combine_list.sort()
    combine_list.reverse()
    
    dlg = wxMessageDialog(self,
                        "Combine the %d selected items?"%len(combine_list),
                        "Combine Items?",
                        wxICON_QUESTION|wxYES_NO)
                        
    if dlg.ShowModal() == wxID_YES:
        Properties = self.PropertyDicts[L]
        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']
        
        t_item = combine_list[0][1]
        merge_list = combine_list[1:]
        new_note = ""
        
        for date,item in merge_list:
            note = self.GetNote(item=item)
            date = date.Format("%m/%d/%y")
            new_note = "%s\n%s %s\n\n%s"%(new_note, date, item.name, note)
            
            cursor.execute("DELETE from "+table+" WHERE id = %s", (item.id,))
            #Track Deletes for Syncing ############################################
            if table in SYNC_TABLES:
                if host.split(':')[1] == 'sqlite':
                    timestamp = mx.DateTime.now()
                    cursor.execute("INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,item.name,timestamp))
                else:
                    cursor.execute("INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,USER,item.name))
            #########################################################################
                
        t_note = self.GetNote(item=t_item)
        t_note = "%s\n%s"%(t_note,new_note)
        
        #What about combining owners?######################################
        
        cursor.execute("UPDATE "+table+" SET name = %s, note = %s WHERE id = %s", (t_item.name+"*",t_note,t_item.id))
        t_item.timestamp = self.TimeStamper(host, cursor, table, t_item.id)
        
        self.OnRefresh()
        LCtrl.SetItemState(0, 0, wxLIST_STATE_SELECTED)
        IList = self.ItemLists[L]
        id = t_item.id
        idx = -1
        for item in IList:
            idx+=1
            if id == item.id:
                break
        else:
            idx = -1 
    
        #should never be -1
        if idx != -1:	
            LCtrl.SetItemState(idx, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
            LCtrl.EnsureVisible(idx)
        self.curIdx = idx
        
    dlg.Destroy()

</t>
<t tx="ekr.20051104081502.398">def OnMoveToList(self, evt=None, page=0):
    self.OnCopyItems(cut=True)
    pc = self.nb.GetPageCount()
    if page &lt; pc:		
        self.OnPasteItems(L=page)
    else:
        host,table = self.closed_tables[page-pc]
        cursor = self.Cursors[host]# in ini self.Cursors[host]
    
        for item in self.copyitems:
            z = item.owners+[None,None,None]
            id = self.GetUID() #give it a new id
            
            #need this or else it won't be seen as a new item when syncing; would be seen as updated
            createdate = mx.DateTime.now() 
            command = "INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
            cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))
            timestamp = self.TimeStamper(host, cursor, table, id)
            
    self.copyitems = []
    
</t>
<t tx="ekr.20051104081502.399">def OnMoveToSpecificList(self, evt=None, table='follow_ups'):
    matches = {}
    for page,Properties in enumerate(self.PropertyDicts):
        host,tble = Properties['host'],Properties['table']
        if tble == table:
            rdbms = host.split(':')[1]
            matches[rdbms] = page
        
    self.OnCopyItems(cut=True)
    
    if matches:
        if matches.get('mysql'):	
            self.OnPasteItems(L=matches['mysql'])
        else:
            self.OnPasteItems(L=matches['sqlite'])
    else:
        cursor = self.Cursors[LOCAL_HOST]
    
        for item in self.copyitems:
            z = item.owners+[None,None,None]
            id = self.GetUID() #give it a new id
            
            #need this or else it won't be seen as a new item when syncing; would be seen as updated
            createdate = mx.DateTime.now() 
            command = "INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
            cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))
            timestamp = self.TimeStamper(host, cursor, table, id)
            
    self.copyitems = []

            

</t>
<t tx="ekr.20051104081502.4"></t>
<t tx="ekr.20051104081502.400"></t>
<t tx="ekr.20051104081502.401">def OnToggleFinished(self, evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx

    item = self.ItemLists[L][idx]
    LC_Item = LCtrl.GetItem(idx)
    
    if not item.finisheddate:
        item.finisheddate = mx.DateTime.today()
        LC_Item.SetImage(LCtrl.idx0)
    else:
        item.finisheddate = None
        LC_Item.SetImage(LCtrl.idx1)
    
    &lt;&lt; draw item &gt;&gt;

    self.tb.EnableTool(30, True)
    
    host = Properties['host']	
    cursor = self.Cursors[host]
    table = Properties['table']
    
    cursor.execute("UPDATE "+table+" SET finisheddate = %s WHERE id = %s", (item.finisheddate, item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)
    
    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
    elif Properties['LCdate'] == 'finisheddate':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.finisheddate.Format('%m/%d/%y'))



</t>
<t tx="ekr.20051104081502.402">if item.finisheddate:
    #It appears that SetTextColour resets font weight to Normal but this makes no sense
    #This means that all finished items have Normal weight whether they are priority 3,2 or 1
    #May actually be that GetItem() and then SetItem() sets the weight to Normal no matter what it was originally
    LC_Item.SetTextColour(wxLIGHT_GREY)
    
elif item.priority==1:
    #see note above about SetTextColour apparently resetting weight
    LC_Item.SetTextColour(wxBLACK)
    
elif item.priority==2:
    #LC_Item.SetTextColour(wxBLACK) -- this line should be necessary but it does not appear to be
    # ? font is black so ? if have to reset it
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

else:
    LC_Item.SetTextColour(wxRED) #appears to be the only way to set color - can't through font
    f = self.LC_font #LCtrl.font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight
    
LCtrl.SetItem(LC_Item)</t>
<t tx="ekr.20051104081502.403">def OnPriority(self, event=None, input=None):
    L = self.L
    idx = self.curIdx
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    item = self.ItemLists[L][idx]
    
    if input:
        item.priority=input

    else:
        if item.priority &lt; 3:
            item.priority+= 1
        else:
            item.priority=1

    LC_Item = LCtrl.GetItem(idx)

    &lt;&lt; draw item &gt;&gt;

    text = str(item.priority)        
    LCtrl.SetStringItem(idx, 0, text)

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    
    cursor.execute("UPDATE "+table+" SET priority = %s WHERE id = %s", (item.priority,item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)
    
    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format('%m/%d %H:%M:%S'))
        
    wxCallAfter(LCtrl.SetFocus)
    
</t>
<t tx="ekr.20051104081502.404">if item.finisheddate:
    #It appears that SetTextColour resets font weight to Normal but this makes no sense
    #This means that all finished items have Normal weight whether they are priority 3,2 or 1
    #May actually be that GetItem() and then SetItem() sets the weight to Normal no matter what it was originally
    LC_Item.SetTextColour(wxLIGHT_GREY)
    
elif item.priority==1:
    #see note above about SetTextColour apparently resetting weight
    LC_Item.SetTextColour(wxBLACK)
    
elif item.priority==2:
    #LC_Item.SetTextColour(wxBLACK) -- this line should be necessary but it does not appear to be
    # ? font is black so ? if have to reset it
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

else:
    LC_Item.SetTextColour(wxRED) #appears to be the only way to set color - can't through font
    f = self.LC_font #LCtrl.font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight
    
LCtrl.SetItem(LC_Item)</t>
<t tx="ekr.20051104081502.405"></t>
<t tx="ekr.20051104081502.406">def OnDisplayInPlaceEditor(self,evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx
    item = self.ItemLists[L][idx]
    
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
        
    #if self.Conflict(host, cursor, table, item): return #works -- may be overkill so i've commented it out
    
    TCid = wxNewId()
    y = LCtrl.GetItemPosition(idx)[1] 
    length = LCtrl.GetColumnWidth(1)

    editor = wxTextCtrl(self, TCid, pos = (167,y+28), size = (length,23), style=wxTE_PROCESS_ENTER)
    editor.SetFont(wxFont(9, wxSWISS, wxNORMAL, wxNORMAL))
    editor.SetBackgroundColour(wxColour(red=255,green=255,blue=175)) #Yellow
    editor.AppendText(item.name)
    editor.Show(True)
    editor.Raise()
    editor.SetSelection(-1,-1)
    editor.SetFocus()	
    
    EVT_TEXT_ENTER(self, TCid, self.OnCloseInPlaceEditor)		

    self.in_place_editor = editor
    self.modified['inplace'] = 1	





</t>
<t tx="ekr.20051104081502.407">def OnCloseInPlaceEditor(self,evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx
    item = self.ItemLists[L][idx]
    
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    LCdate = Properties['LCdate']
    
    #if self.Conflict(host, cursor, table, item)...

    text = self.in_place_editor.GetValue().strip()[:150]
    item.name = text
    LCtrl.SetStringItem(idx, self.attr2col_num['name'], text)
    self.in_place_editor.Destroy()
    
    cursor.execute("UPDATE "+table+" SET name = %s WHERE id = %s", (text, item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format('%m/%d %H:%M:%S'))

    self.name.Clear()
    self.name.AppendText(text) #this will cause self.modified['name'] = 1, which is dealt with below
    
    #using default in case for some reason self.modified does not have the keys
    self.modified.pop('inplace', None)
    self.modified.pop('name', None)
        
    wxCallAfter(LCtrl.SetFocus) #sets focus on LCtrl and current selection to be highlighted



</t>
<t tx="ekr.20051104081502.408">def OnDueDate(self, evt=None):
    idx = self.curIdx
    if idx == -1:
        return
    L = self.L
    Properties = self.PropertyDicts[L]
    item = self.ItemLists[L][idx]
    LCtrl = self.ListCtrls[L]

    if item.duedate:
        date = wxDateTime()
        date.SetTimeT(item.duedate) #I am surprised it takes a mx.DateTime object; supposed to need ticks
    else:
        date = 0
    dlg = CalendarDialog(parent=self,
                 title="Select a date",
                 size=(400,400),
                 style=wxCAPTION,
                 date = date)
    if dlg.ShowModal()==wxID_OK:
        date = dlg.cal.GetDate() # this is some date object
        #date = date.GetTicks()
        item.duedate = mx.DateTime.DateFromTicks(date.GetTicks())

        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']
        
        cursor.execute("UPDATE "+table+" SET duedate = %s WHERE id = %s", (item.duedate,item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)
        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
        elif Properties['LCdate'] == 'duedate':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.duedate.Format('%m/%d/%y'))
    dlg.cal.Destroy()
    dlg.Destroy()
    
</t>
<t tx="ekr.20051104081502.409">def OnEditOwner(self, evt=None): #, new=False) removed Aug. 31 for simplicity
    idx = self.curIdx
    if idx == -1:
        return
    L = self.L
    Properties = self.PropertyDicts[L]
    LCtrl = self.ListCtrls[L]
    item = self.ItemLists[L][idx]
    if not self.ModifierDialog:
        g.pr("self.ModifierDialog is still being constructed")
        return
    #need to clear the current selections or you'll just be making more and more selections
    self.ModifierDialog.SelectCurrent(item.owners)
    self.ModifierDialog.tc.Clear()
    self.ModifierDialog.CenterOnParent()
    
    val = self.ModifierDialog.ShowModal()

    if val == wxID_OK:
        item.owners, new_names = self.ModifierDialog.GetUserInput()
        
        &lt;&lt; Common Owner Code &gt;&gt;

        for owner in item.owners:
            if self.OwnerLBoxes[L].FindString(owner) == -1:
                self.OwnerLBoxes[L].Append(owner)

        for owner in new_names:
            self.ModifierDialog.lb.Append(owner)
        
        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        cursor.execute("UPDATE "+table+" SET owner1 = %s, owner2 = %s, owner3 = %s WHERE id = %s", (z[0],z[1],z[2],item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)
        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))

        if 'owners' in self.modified:
            del self.modified['owners']
            
    wxCallAfter(LCtrl.SetFocus)
    
</t>
<t tx="ekr.20051104081502.410">owner_str = '; '.join(item.owners)
LCtrl.SetStringItem(idx, self.attr2col_num['owners'], owner_str)
self.owners.Clear()
self.owners.AppendText(owner_str)
        
z = item.owners+[None,None,None] #note that + creates a new list
</t>
<t tx="ekr.20051104081502.411">def OnUpdate(self, evt=None):
    if 'inplace' in self.modified:
        self.OnCloseInPlaceEditor()
        if not self.modified:
            return

    L = self.L
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]
    Properties = self.PropertyDicts[L]
    OLBox = self.OwnerLBoxes[L]
    idx = self.curIdx

    # there is some chance that it is never true that idx == -1 and then this could be eliminated
    if idx != -1:
        item = IList[idx]
    else:
        msg = wxMessageDialog(self, "There is no selected item to update", "", wxICON_ERROR|wxOK)
        msg.ShowModal()
        msg.Destroy()
        self.modified = {}
        return
        
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    
    if 'name' in self.modified:
        item.name = self.name.GetValue().strip()[:150]
        LCtrl.SetStringItem(idx, self.attr2col_num['name'], item.name)
        cursor.execute("UPDATE "+table+" SET name =%s WHERE id = %s",(item.name,item.id))
        
    if 'note' in self.modified:
        note = self.note.GetValue() #a blank note starts out as None but after this it becomes '' -- ??
        cursor.execute("UPDATE "+table+" SET note =%s WHERE id = %s",(note,item.id))
        
    if 'owners' in self.modified:
        owner_str = self.owners.GetValue().strip()
        item.owners = []
        if owner_str:
            owner_list = [x.strip() for x in owner_str.split(';')]
            for owner in owner_list:
                owner = ", ".join([x.strip().title() for x in owner.split(',')])
                item.owners.append(owner)
            
        &lt;&lt; Common Owner Code &gt;&gt;

        cursor.execute("UPDATE "+table+" SET owner1 = %s, owner2 = %s, owner3 = %s WHERE id = %s", (z[0],z[1],z[2],item.id))
        
        for owner in item.owners:
            if self.ModifierDialog.lb.FindString(owner) == -1:
                self.ModifierDialog.lb.Append(owner)
                OLBox.Append(owner)
            elif OLBox.FindString(owner) == -1:
                OLBox.Append(owner)		
                
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)
    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, 3, item.timestamp.Format("%m/%d %H:%M:%S"))
    
    self.modified = {}
    
    
</t>
<t tx="ekr.20051104081502.412">owner_str = '; '.join(item.owners)
LCtrl.SetStringItem(idx, self.attr2col_num['owners'], owner_str)
self.owners.Clear()
self.owners.AppendText(owner_str)
        
z = item.owners+[None,None,None] #note that + creates a new list
</t>
<t tx="ekr.20051104081502.413">def OnNewItem(self, evt=None):
    L=self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    
    if self.curIdx != -1:
        LCtrl.SetItemState(self.curIdx, 0, wxLIST_STATE_SELECTED)
    
    &lt;&lt; Clear data fields &gt;&gt;
    
    class Item: pass
    item = Item()
    item.name = '&lt;New Item&gt;'
    item.priority = 1
    item.owners = []
    item.createdate = mx.DateTime.now() #need this to be a timestamp and not just date for syncing
    item.duedate = item.finisheddate = None

    self.ItemLists[L].insert(0,item)
    
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    item.id = self.GetUID()
    
    cursor.execute("INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,id) VALUES (%s,%s,%s,%s,%s,%s)",
                (item.priority,item.name,item.createdate,None,None,item.id))
        
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)
    
    #tracking new item for syncing will happen in Edit Name

    LCtrl.InsertImageStringItem(0,"1", LCtrl.idx1)
    LCtrl.SetStringItem(0,1,item.name)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(0, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
    elif Properties['LCdate'] == 'createdate':
        LCtrl.SetStringItem(0, self.attr2col_num['date'], item.createdate.Format('%m/%d/%y'))

    self.curIdx = 0
    
    #if Display is being filtered we assume that is the owner of the new node
    owner = Properties['owner']	
    if owner and owner!='*ALL':
        self.ListCtrls[L].SetStringItem(0, self.attr2col_num['owners'], owner)
        item.owners = [owner]
        
        self.owners.Clear()
        self.owners.AppendText(owner)
        
        cursor.execute("UPDATE "+table+" SET owner1 = %s WHERE id = %s", (owner,item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)  #not really necessary since just got a timestamp
    
    # decided that it was actually better not to ask for the owner on a new node	
    #else:
        #self.OnEditOwner()
    
    LCtrl.SetFocus() #needed for the in place editor to look right
    LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
    
    self.OnDisplayInPlaceEditor() #(new=True)</t>
<t tx="ekr.20051104081502.414">self.name.Clear()
self.owners.Clear()
self.note.Clear()</t>
<t tx="ekr.20051104081502.415">@ Need to decide if we are going to have timestamp checking to be sure something hasn't changed
Note that there would not need to be timestamp checking on a new node
Also  there is no need to timestamp check on a local DB
The following code seems to work fine, however, I have just commented out the calls to it in NameEditor methods
@c
def Conflict(self, host, cursor, table, item):
    if host is 'sqlite':
        return False
    cursor.execute("Select timestamp from "+table+" WHERE id = %s", (item.id,))
    db_timestamp = cursor.fetchone()[0]
    if db_timestamp != item.timestamp:
        g.pr("There is a conflict and you should refresh display")
        return True
    else:
        return False
</t>
<t tx="ekr.20051104081502.416">def OnEditNote(self, evt=None):
    if self.modified:
        self.OnUpdate()
    
    idx = self.curIdx
    
    if idx == -1:
        return
        
    L = self.L
        
    #if self.editor:
        #machine = None
        #win32pdh.EnumObjects(None, machine, 0, 1) # resets Enum otherwise it seems to hold onto old data
        #object = "Process"
        #items, instances = win32pdh.EnumObjectItems(None,None,"Process", -1)
        #if 'TextPad' in instances:
            #g.pr("TextPad is running")
        #else:
            #self.editor = {}
    
    item = self.ItemLists[L][idx]
    file_name = re.sub('[\\/:*"&lt;&gt;|\?]','-',item.name) #make sure all chars are legal file name characters
    
    path = os.path.join(os.environ['TMP'],file_name[:50])+'.%s'%NOTE_EXT
        
    f = file(path,'w')
    f.write(self.GetNote())
    f.close()
    
    os.startfile(path)
    
    id = item.id
    for d in self.editor:
        if d['id'] == id:
            return

    ed = {}
    ed['time'] = os.path.getmtime(path)
    ed['host'] = self.PropertyDicts[L]['host']
    ed['table'] = self.PropertyDicts[L]['table']
    ed['path'] = path
    ed['id'] = item.id
    
    self.editor.append(ed)
    
    time.sleep(.1)
</t>
<t tx="ekr.20051104081502.417"></t>
<t tx="ekr.20051104081502.418">def OnNewList(self, event=None):
    if self.modified:
        self.OnUpdate()
    
    if OFFLINE_ONLY is True or REMOTE_HOST is None:
        hosts = [LOCAL_HOST]
    else:
        hosts = [LOCAL_HOST, REMOTE_HOST]
        
    dlg = wxSingleChoiceDialog(self, 'Databases', 'Choose a database:', hosts, wxCHOICEDLG_STYLE)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        host = dlg.GetStringSelection()
    else:
        return
        
    cursor = self.GetCursor(host)
    if cursor is None:
        return
        
    dlg = wxTextEntryDialog(self, 'What is the name of the new table?', 'Create Table')
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        table = dlg.GetValue()
    else:
        return
    
    if not table:
        return
        
    location, rdbms = host.split(':')
    
    if rdbms == 'sqlite':
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
    else:
        cursor.execute("SHOW tables")
    
    if (table,) in cursor.fetchall():
        msg = wxMessageDialog(self,
                              "Table '%s' already exists"%table,
                              "Duplicate Table",
                              wxICON_ERROR|wxOK)
        msg.ShowModal()
        msg.Destroy()
        return
        
    dlg = wxMessageDialog(self,
          "Are you sure you want to create Table '%s'?"%table,
          "Create Table?",
          wxICON_QUESTION|wxYES_NO)

    if dlg.ShowModal() == wxID_YES:
        self.CreateTable(host,table)
        self.CreateNewNotebookPage(host,table)

        #self.AddListControl(tab_title) #add listcontrol displays the list
        
        #self.OnNewItem()
        
    dlg.Destroy()


</t>
<t tx="ekr.20051104081502.419">def OnFileList(self, evt=None, path=None):
    if self.modified:
        self.OnUpdate()
        
    #if there is no event, we got here through the start up loading of lists
    if evt:
        fileNum = evt.GetId() - wxID_FILE1			
        path = self.filehistory.GetHistoryFile(fileNum)
        location, rdbms, table = path.split(':')
        host = '%s:%s'%(location, rdbms)
        # only need to check if table is open if this is not at startup
        if table in [p['table'] for p in self.PropertyDicts if p['host'] == host]:
            dlg = wxMessageDialog(self,"%s (%s) is already open!"%(table,host),"List Open",wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            return
        
    else:
        location, rdbms, table = path.split(':')
        host = '%s:%s'%(location, rdbms)
    
    cursor = self.GetCursor(host)
    if cursor is None:
        return
        
    if rdbms == 'sqlite':
        sql = "SELECT name FROM sqlite_master WHERE name = '%s'"%table
    else:
        sql = "SHOW TABLES LIKE '%s'"%table
    
    cursor.execute(sql)
    if not cursor.fetchall():
        dlg = wxMessageDialog(self,
                    "Table '%s' at host '%s' does not appear to exist!"%(table,host),
                    "Table does not exist",
                    wxICON_ERROR|wxOK)
        dlg.ShowModal()
        dlg.Destroy()
        return
        
    self.CreateNewNotebookPage(host,table)

</t>
<t tx="ekr.20051104081502.420">def OnOpenList(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    tree = {}
    
    if OFFLINE_ONLY is True or REMOTE_HOST is None:
        hosts = [LOCAL_HOST]
    else:
        hosts = [LOCAL_HOST, REMOTE_HOST]
        
    for host in hosts:
        cursor = self.GetCursor(host)
        if cursor:
            if host.split(':')[1] == 'sqlite':
                sql = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
            else:
                sql = "SHOW TABLES" #sorted
    
            cursor.execute(sql)
            results = cursor.fetchall()
    
            #excluding already open tables + 'system' tables
            excluded_tables = [p['table'] for p in self.PropertyDicts if p['host'] == host]
            excluded_tables.extend(['user_sync','sync','owners'])
    
            tables = [t for (t,) in results if t not in excluded_tables]
    
            tree[host] = tables

    dlg = TreeDialog(self, "Open List", tree=tree)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        sel = dlg.TreeCtrl.GetSelection()
        table = dlg.TreeCtrl.GetItemText(sel)
        sel = dlg.TreeCtrl.GetItemParent(sel)
        host = dlg.TreeCtrl.GetItemText(sel)
        
        if host in hosts: #takes care of highlighting root or hosts
            self.CreateNewNotebookPage(host,table)
</t>
<t tx="ekr.20051104081502.421">def OnDeleteList(self, evt=None):
    #ini controls whether the menu item is enabled
    Properties = self.PropertyDicts[self.L]
    host = Properties['host']
    table = Properties['table']
        
    #if table is in SYNC_TABLES, should we make a point of that?
    dlg = wxMessageDialog(self,
                        "Are you sure that you want to delete table %s (%s)?\n(Please note that you cannot recover it once it is deleted!)"%(table,host),
                        "Delete Table...",
                        wxICON_EXCLAMATION|wxYES_NO|wxNO_DEFAULT)
    
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return
        
    rdbms = host.split(':')[1]
    
    if rdbms == 'mysql':
        dlg = wxMessageDialog(self,
                        "Are you sure really really sure you want to delete table %s (%s)?\n(You really really cannot recover it once it is deleted)"%(table,host),
                        "Delete Table...",
                        wxICON_EXCLAMATION|wxYES_NO|wxNO_DEFAULT)
                        
        val = dlg.ShowModal()
        dlg.Destroy()
        if val == wxID_NO:
            return

    cursor = self.Cursors[host]
    cursor.execute("DROP TABLE %s"%table)
    
    self.OnCloseList()

</t>
<t tx="ekr.20051104081502.422">def OnCloseList(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    L = self.L
            
    del self.ItemLists[L]
    del self.PropertyDicts[L]
    del self.ListCtrls[L]
    del self.OwnerLBoxes[L]

    self.nb.DeletePage(L)        

    ln = len(self.PropertyDicts)
    if ln:
        self.nb.SetSelection(0)
        self.L = 0
    else:
        self.L = -1




</t>
<t tx="ekr.20051104081502.423">def OnCloseAll(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    while self.L != -1:
        self.OnCloseList()
        
    self.name.Clear()
    self.owners.Clear()
    self.note.Clear()
    #note that Clearing does set self.modified (eg {'name':1})
    self.modified = {}
    
</t>
<t tx="ekr.20051104081502.424">def OnSaveAsText(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    Properties = self.PropertyDicts[self.L]
    wildcard = "txt files (*.txt)|*.txt|All files (*.*)|*.*"
    #dlg = wxFileDialog(self, "Save file", "", Properties['table'], wildcard, wxSAVE|wxOVERWRITE_PROMPT|wxCHANGE_DIR)
        
    body = ""
    for i,item in enumerate(self.ItemLists[self.L]):
        body = body+"%d. %s (%d)\n"%(i+1, item.name, item.priority)
    
    table = Properties['table']
    location, rdbms = Properties['host'].split(':')
    filename = re.sub('[\\/:*"&lt;&gt;|\?]','-','%s-%s-%s'%(location,rdbms,table)) 
    filename = filename[:50]+'.txt'

    path = os.path.join(DIRECTORY,filename)
    
    f = file(path,'w')
    f.write(body)
    f.close()

    os.startfile(path)

    self.SetStatusText("Saved file %s"%path)
    
</t>
<t tx="ekr.20051104081502.425">def OnArchive(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    Properties = self.PropertyDicts[self.L]
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    rdbms = host.split(':')[1]
        
    table_archive = table+'_archive'
    
    #need to test for existence of table_archive
    if rdbms == 'sqlite':
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
    else:
        cursor.execute("SHOW tables")

    results = cursor.fetchall()
    
    if (table_archive,) not in results:
        dlg = wxMessageDialog(self,
                    "Do you want to create an archive for table %s (%s)"%(table,rdbms),
                    "Create an archive...",
                    wxICON_QUESTION|wxYES_NO)
        val = dlg.ShowModal()
        dlg.Destroy()
        if val==wxID_YES:
            self.CreateTable(host,table_archive)
        else:
            return
    
    label1 = "In table %s (%s) \narchive all finished items older than:"%(table,rdbms)
    label2 = "Archive all finished items"
    dlg = FinishedDialog(self, "Archive completed items", days=7, spin_label=label1, check_label=label2)
    
    val = dlg.ShowModal()
    dlg.Destroy() #dialogs and frames not destroyed right away to allow processing events, methods
    if val==wxID_CANCEL:
        return
        
    if dlg.check.GetValue():
        cursor.execute("SELECT id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note FROM "+table+" WHERE finisheddate IS NOT NULL")
    else:
        days = dlg.text.GetValue()
        date = mx.DateTime.today() - int(days)
        cursor.execute("SELECT id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note FROM "+table+" WHERE finisheddate &lt; %s",(date,))

    results = cursor.fetchall()
    dlg = wxMessageDialog(self,
                        "Archiving will remove %d records from %s.\nDo you want to proceed?"%(len(results),table),
                        "Proceed to archive...",
                        wxICON_QUESTION|wxYES_NO)
    
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return

    if table in SYNC_TABLES:
        if rdbms == 'sqlite':
            def track_deletes():
                timestamp = mx.DateTime.now()
                cursor.execute("INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)",(id,'d',table,name,timestamp))
        else:
            def track_deletes():
                cursor.execute("INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)",(id,'d',table,USER,name))
    else:
        def track_deletes():
            pass	

    for row in results:
        # the next line is necessary because pysqlite returns a tuple-like object that is not a tuple
        r = tuple(row)
        id = r[0]
        name = r[2]
        cursor.execute("INSERT INTO "+table_archive+"  (id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)",r)
        timestamp = self.TimeStamper(host, cursor, table_archive, id)
        cursor.execute("DELETE from "+table+" WHERE id = %s", (id,))
        track_deletes()
        
    self.OnRefresh()
    dlg = wxMessageDialog(self,
                        "Table %s had items older than %s days successfully archived"%(table,days),
                        "Archiving successful...",
                        wxICON_INFORMATION|wxOK)
    dlg.ShowModal()
</t>
<t tx="ekr.20051104081502.426">def OnWorkOffline(self, evt=None):
    global OFFLINE_ONLY
    OFFLINE_ONLY = not OFFLINE_ONLY
    if OFFLINE_ONLY:
        del self.Cursors[REMOTE_HOST]
    else:
        server = REMOTE_HOST.split(':')[0]
        try:
            socket.gethostbyname(server)
        except:
            dlg = wxMessageDialog(None, "Cannot connect to remote server! Will set to work offline.", "ListManager", style=wxOK|wxICON_EXCLAMATION|wxSTAY_ON_TOP)
            dlg.ShowModal()
            dlg.Destroy()
            OFFLINE_ONLY = True

    self.filemenu.Check(idOFFLINE,OFFLINE_ONLY)
    
</t>
<t tx="ekr.20051104081502.428"></t>
<t tx="ekr.20051104081502.429">def OnItemSelected(self, evt=None):
    if self.modified:
        self.OnUpdate()

    if evt:
        idx = evt.GetIndex()
    elif self.curIdx != -1:
        idx = self.curIdx
    else: # really to catch self.curIdx = -1 (see OnDelete and OnRefresh)
        self.name.Clear() # could be moved out of if
        self.owners.Clear() # could be moved out of if
        self.note.Clear()
        #note that Clearing does set self.modified (eg {'name':1})
        self.modified = {}
        return
    
    L = self.L
    item = self.ItemLists[L][idx]

    self.name.Clear()
    self.name.AppendText(item.name) #SetValue(item.name) - if you use setvalue you don't get the font
        
    self.owners.Clear()
    self.owners.AppendText('; '.join(item.owners))
    
    note = self.GetNote(L,item)
    if note.find("&lt;leo_file&gt;") != -1:
        self.note.SetValue("Leo Outline")
        self.note.SetEditable(False)
    else:
        self.note.SetValue(note)
        self.note.SetEditable(True)
        
    self.ListCtrls[L].EnsureVisible(idx)
    self.curIdx = idx
    
    #writing to text widgets caused wxEVT_COMMAND_TEXT_UPDATED which is caught by EVT_TEXT, which updates self.modified
    self.modified={}

</t>
<t tx="ekr.20051104081502.430">def OnItemActivated(self,evt):
    g.pr("On Activated")
    
</t>
<t tx="ekr.20051104081502.431">def OnShowAll(self, evt=None):
    L = self.L
    OLBox = self.OwnerLBoxes[L]
    
    Properties = self.PropertyDicts[L]
    Properties['showfinished'] = -1
    Properties['owner'] = '*ALL'
    
    OLBox.SetStringSelection('*ALL')
    
    self.OnRefresh()
</t>
<t tx="ekr.20051104081502.432">def OnRefresh(self, evt=None):
    #OnItemSelected should be able to handle no items so this could be very short
    L = self.L
    
    results = self.ReadFromDB()
    self.ItemLists[L] = self.CreateAndDisplayList(results)

    if self.ItemLists[L]:
        self.ListCtrls[L].SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = 0
    else:
        self.curIdx = -1		
        
    self.OnItemSelected()
</t>
<t tx="ekr.20051104081502.433">def OnFilterOwners(self, evt=None):
    if self.modified:
        self.OnUpdate()
    sel = self.OwnerLBoxes[self.L].GetStringSelection()
    
    if sel:
        self.PropertyDicts[self.L]['owner'] = sel
        self.OnRefresh()
</t>
<t tx="ekr.20051104081502.434">def OnColumnClick(self, evt):
    col_num = evt.GetColumn()
    L = self.L
    LCtrl = self.ListCtrls[L]
    Sort = self.PropertyDicts[L]['sort']
    attr2col = self.attr2col_num
    
    prev_sort_attr = Sort.get('attribute') #if this is the first sort Properties['sort'] is {}
    
    #following is a little bit ugly but gets the key from the value, which is col_num
    Sort['attribute'] = attr2col.keys()[attr2col.values().index(col_num)]
    
    if prev_sort_attr == Sort['attribute']:
        Sort['direction'] = not Sort['direction']
    else:
        Sort['direction'] = 0
    
    self.OnRefresh()

    LCtrl.ClearColumnImage(attr2col['priority'])
    LCtrl.ClearColumnImage(attr2col['date'])
    img_num = LCtrl.arrows[Sort['direction']]
    LCtrl.SetColumnImage(col_num, img_num)
    
</t>
<t tx="ekr.20051104081502.435">def OnShowFinished(self,evt):
    Properties = self.PropertyDicts[self.L]
    label1 = "Enter the number of days to retain\ncompleted tasks in the display:"
    label2 = "Show all finished items"
    dlg = FinishedDialog(self, "Display of completed items", days=Properties['showfinished'], spin_label=label1, check_label=label2)
    if dlg.ShowModal()==wxID_OK:
        if dlg.check.GetValue():
            Properties['showfinished'] = -1
        else:
            days = dlg.text.GetValue()
            Properties['showfinished'] = int(days)			
        self.OnRefresh()
    dlg.Destroy()
    
</t>
<t tx="ekr.20051104081502.436">def OnColumnRightClick(self, evt=None):
    col = evt.GetColumn()
    if col != self.attr2col_num['date']:
        return
        
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    
    #x,y = evt.GetPosition()
    datemenu = wxMenu()
    
    for i,date in enumerate(['Create Date','Last Modified','Due Date','Completion Date']):
        datemenu.Append(200+i, date)
        EVT_MENU(self, 200+i, lambda e, i=i: self.ChangeDateDisplayed(e,i))

    x = LCtrl.GetColumnWidth(1)+ LCtrl.GetColumnWidth(2) + LCtrl.GetColumnWidth(3)
    self.PopupMenu(datemenu,(x,40))
    datemenu.Destroy()


</t>
<t tx="ekr.20051104081502.437">def OnDisplayDateCategory(self, evt=None):
    dlg = wxSingleChoiceDialog(self, 'Date Display', 'Choose a date to display:',
                    ['Create Date','Last Modified','Due Date','Completion Date']
                    , wxOK|wxCANCEL)
    val = dlg.ShowModal()
    dlg.Destroy()
    
    if val == wxID_OK:
        idx = dlg.GetSelection()
        self.ChangeDateDisplayed(i=idx)
        
</t>
<t tx="ekr.20051104081502.438">def ChangeDateDisplayed(self, evt=None, i=0):
    L = self.L
    LCtrl = self.ListCtrls[L]
    self.PropertyDicts[L]['LCdate'] = displaydate = ('createdate','timestamp','duedate','finisheddate')[i]	
    col_num = self.attr2col_num['date']
    col_info = LCtrl.GetColumn(col_num)
    col_info.SetText(self.date_titles[displaydate])
    LCtrl.SetColumn(col_num,col_info)
    self.DisplayList(self.ItemLists[L])
    #self.OnRefresh() #have gone back and forth but think that it should be self.DisplayList
</t>
<t tx="ekr.20051104081502.439">def DisplayList(self, List, L=None):
    #OnPasteItems needs to be able to have an L that is not self.L
    if L is None:
        L = self.L
    LCtrl = self.ListCtrls[L]
    LCdate = self.PropertyDicts[L]['LCdate']
    if LCdate == 'timestamp':
        format = '%m/%d %H:%M:%S'
    else:
        format = '%m/%d/%y'
    LCtrl.DeleteAllItems()
    
    for x,item in enumerate(List):
        &lt;&lt; draw item &gt;&gt;
        

</t>
<t tx="ekr.20051104081502.440">LCtrl.InsertImageStringItem(x, str(item.priority), LCtrl.idx1)
LCtrl.SetStringItem(x,1,item.name)
LCtrl.SetStringItem(x,2,'; '.join(item.owners))
date = item.__dict__[LCdate]
LCtrl.SetStringItem(x,3,date and date.Format(format) or "")

if item.finisheddate:
    LC_Item = LCtrl.GetItem(x)
    LC_Item.SetImage(LCtrl.idx0) #might just want generic number or greyed one two three
    LC_Item.SetTextColour(wxLIGHT_GREY)
    LCtrl.SetItem(LC_Item)
    
elif item.priority==2:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #resetting weight
    LCtrl.SetItem(LC_Item)

elif item.priority==3:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #return to normal
    LC_Item.SetTextColour(wxRED)
    LCtrl.SetItem(LC_Item)</t>
<t tx="ekr.20051104081502.441"></t>
<t tx="ekr.20051104081502.442">def OnPageSetup(self, evt):
    #need to pass printdata to tableprint

    psdata = wxPageSetupDialogData()

    # if want to vary margins will need to save them as ivars and then set
    #psdata.SetMarginTopLeft((self.Left,self.Top))
    psdata.EnableMargins(False)
    psdata.SetPrintData(self.printdata) #gets Paper Orientation and PaperId info from printdata
    
    dlg = wxPageSetupDialog(self, psdata)
    if dlg.ShowModal() == wxID_OK:
        self.printdata = dlg.GetPageSetupData().GetPrintData()
        dlg.Destroy()
</t>
<t tx="ekr.20051104081502.443">def OnPrint(self, evt=None, prev=False, showprtdlg=True): 		#???self.psdata = psdata
    IList = self.ItemLists[self.L]
    Properties = self.PropertyDicts[self.L]
    
    prt = PrintTable(self.printdata) #self.printdata is the wxPrintData object with Orientation Info

    font_name = prt.default_font_name
    prt.text_font = {'Name':font_name, 'Size':11, 'Colour':[0, 0, 0], 'Attr':[0, 0, 0]}
    prt.label_font = {'Name':font_name, 'Size':12, 'Colour':[0, 0, 0], 'Attr':[1, 0, 0]}
    prt.header_font = {'Name':font_name, 'Size':14, 'Colour':[0, 0, 0], 'Attr':[1, 0, 0]}
    
    prt.row_def_line_colour = wxLIGHT_GREY
    prt.column_def_line_colour = wxLIGHT_GREY
    
    prt.left_margin = 0.5

    data = []
    for row,item in enumerate(IList):	
        data.append([str(item.priority),
                    item.name,
                    item.duedate and item.duedate.Format('%m/%d/%y') or '',
                    '; '.join([x.split(',')[0] for x in item.owners])]) #just last names
                    
        if item.finisheddate:
            prt.SetCellText(row, 0, wxLIGHT_GREY)
            prt.SetCellText(row, 1, wxLIGHT_GREY)
            prt.SetCellText(row, 2, wxLIGHT_GREY)
            prt.SetCellText(row, 3, wxLIGHT_GREY)

    prt.data = data
    prt.label = ['P','Item','Due','Owner']
    
    if self.printdata.GetOrientation() == wxPORTRAIT:
        prt.set_column = [.2, 5, .65, 1]
    else:
        prt.set_column = [.2, 7, .65, 1.5]
                       
    title = "Table: %s   Owner: %s    "%(Properties['table'],Properties['owner'])
    prt.SetHeader(title, type='Date &amp; Time', align=wxALIGN_LEFT, indent = 1.5)
    prt.SetFooter("Page No ", type ="Num")

    if prev:
        prt.Preview()
    else:
        prt.Print(prompt=showprtdlg)
</t>
<t tx="ekr.20051104081502.444"></t>
<t tx="ekr.20051104081502.445">def OnWindowExit(self, evt):
    #this is called if you close the ListManager Window with the X
    if evt.CanVeto():
        self.OnExit()
    else:
        evt.Skip()
</t>
<t tx="ekr.20051104081502.446">def OnExit(self, event=None):   
    &lt;&lt; save configuration file &gt;&gt;
    sys.stderr.dlg.Destroy() #destroys the error dialog; need to do this to shut down correctly
    if self.ModifierDialog: #only reason to check is if closed before ModifierDialog is constructed
        self.ModifierDialog.Destroy()
    self.Close(1)
</t>
<t tx="ekr.20051104081502.447">cp.remove_section('Files')
cp.add_section("Files")

x,y = self.GetSizeTuple()

cp.set('Configuration','x', str(x))
cp.set('Configuration','y', str(y))

numfiles = self.filehistory.GetNoHistoryFiles()

for n in range(numfiles):
    cp.set("Files", "path%d"%n, self.filehistory.GetHistoryFile(n))

try:
    #you have to give ConfigParser a writable object
    cfile = file(config_file, 'w')
    cp.write(cfile)
    cfile.close()
except IOError:
    g.pr("The configuration file can't be written!")
    time.sleep(10) #so you can see that there was a problem
</t>
<t tx="ekr.20051104081502.448"></t>
<t tx="ekr.20051104081502.449">def OnFind(self, evt=None):
    self.FindDialog.Show(True)
    self.FindDialog.FindText.SetSelection(-1,-1)
    self.FindDialog.FindText.SetFocus()


</t>
<t tx="ekr.20051104081502.450">def FindString(self, evt=None):
    L = self.L
    Properties = self.PropertyDicts[L]
    cursor = self.Cursors[Properties['host']]
    table = Properties['table']
    
    pat = self.FindDialog.FindText.GetValue()
    likepat = r"'%"+pat+r"%'"
    finished = self.FindDialog.SearchFinished.GetValue()
    notes = self.FindDialog.SearchNotes.GetValue()
    
    if finished:
        WHERE = "WHERE "
    else:
        WHERE = "WHERE finisheddate IS NULL AND "
    
    if notes:
        SELECT = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp,note FROM %s "%table
        WHERE = WHERE + "(name LIKE %s OR note LIKE %s) ORDER BY timestamp DESC"%(likepat,likepat)
    else:
        SELECT = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp FROM %s "%table
        WHERE = WHERE + "name LIKE %s ORDER BY timestamp DESC"%likepat

    sql = SELECT + WHERE			
    try:
        cursor.execute(sql)
    except:
        g.pr("Cannot read %s: %s"%(Properties['host'],table))
        return
    else:
        results = cursor.fetchall()
    
    case = self.FindDialog.MatchCase.GetValue()
    whole = self.FindDialog.MatchWhole.GetValue()
    
    if whole:
        pat = '\\b%s\\b'%pat
    
    if case:
        z = re.compile(pat)
    else:
        z =re.compile(pat, re.I)

    if notes:
        results = [x for x in results if re.search(z,x[1]) or re.search(z,x[10])]
    else:
        results = [x for x in results if re.search(z,x[1])]
    
    Properties['LCdate'] = 'timestamp'
    self.ItemLists[L]= IList = self.CreateAndDisplayList(results)
    
    LCtrl = self.ListCtrls[L]
    col_num = self.attr2col_num['date']
    col_info = LCtrl.GetColumn(col_num)
    col_info.SetText(self.date_titles['timestamp'])
    LCtrl.SetColumn(col_num,col_info)
    
    if IList:
        self.curIdx = 0
        LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
    else:		
        self.curIdx = -1
        
    self.OnItemSelected()
    
    Properties['sort'] = {'direction':0,'attribute':'date'}
    Properties['owner'] = '*ALL'
    
    owner_idx = self.OwnerLBoxes[L].GetSelection()
    if owner_idx != -1:
        self.OwnerLBoxes[L].SetSelection(owner_idx, 0) #get exception if index = -1

    self.SetStatusText("Found %d items"%len(IList))
</t>
<t tx="ekr.20051104081502.451">def FindNode(self, item, showfinished=True):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    
    Properties['owner'] = '*ALL'
    Properties['showfinished'] = showfinished
    
    self.ItemLists[L] = IList = self.CreateAndDisplayList(self.ReadFromDB())
    
    id = item.id
    idx = -1
    for item in IList:
        idx+=1
        if id == item.id:
            break
    else:
        idx = -1

    if idx != -1:	
        LCtrl.SetItemState(idx, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        LCtrl.EnsureVisible(idx)
    self.curIdx = idx
    
</t>
<t tx="ekr.20051104081502.452"></t>
<t tx="ekr.20051104081502.453">def GetCursor(self, host):
    cursor = self.Cursors.get(host)
    if cursor:
        return cursor
        
    location, rdbms = host.split(':')
        
    if rdbms == 'sqlite':
        db = os.path.join(DIRECTORY,location,DB)
        try:
            Con = sqlite.connect(db=db, autocommit=1)
            cursor = Con.cursor()
            self.sqlite_connections.append(Con)  #getting a weak reference error from PySQLite and this makes it go away
        except:
            dlg = wxMessageDialog(self,
                    "Could not connect to SQLite database at %s"%location,
                    "Connection problem!",
                    wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            cursor = None
        
    elif not OFFLINE_ONLY:
        try:
            Con = MySQLdb.connect(host=location, user=USER, passwd=PW, db=DB)
            cursor = Con.cursor()
        except:
            dlg = wxMessageDialog(self,
                    "host = %s | user = %s | password = %s**** | db = %s - could not connect!"%(host,USER,PW[:3],DB),
                    "Connection problem",
                    wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            cursor = None
            
    if cursor:
        self.Cursors[host] = cursor
        
    return cursor


</t>
<t tx="ekr.20051104081502.454">def GetNote(self, L=None, item=None):
    if L is None:
        L = self.L
        
    if item is None:
        if self.curIdx != -1:
            item = self.ItemLists[L][self.curIdx]
        else:
            return ''
        
    Properties = self.PropertyDicts[L]
    
    cursor = self.Cursors[Properties['host']]
    table = Properties['table']
    cursor.execute("SELECT note from "+table+" WHERE id = %s", (item.id,))
    
    ###### Debug -- this does happen where note brings back None 053003
    z = cursor.fetchone()
    if z is None:
        g.pr("In GetNote -&gt; SELECT should not bring back None")
        g.pr("           -&gt; item.id=",item.id)
        z = (None,)
    note = z[0]
    if note is None:
        note = ''
    return note
    
</t>
<t tx="ekr.20051104081502.455">def CreateTable(self, host, table):
    cursor = self.Cursors[host]
    rdbms = host.split(':')[1]
    if rdbms == 'sqlite':
        sql = """CREATE TABLE '%s' ('id' varchar(36) PRIMARY KEY,
'priority' int(1),
'name' varchar(150),
'createdate' datetime,
'finisheddate' date,
'duedate' date,
'owner1' varchar(25),
'owner2' varchar(25),
'owner3' varchar(25),
'note' text,
'timestamp' timestamp(14))"""%table
    else:
        sql = """CREATE TABLE `%s` (`id` varchar(36) NOT NULL default '',
`priority` int(1) NOT NULL default '1',
`name` varchar(150) NOT NULL default '',
`createdate` datetime NOT NULL default '0000-00-00 00:00:00',
`finisheddate` date default '0000-00-00',
`duedate` date default '0000-00-00',
`owner1` varchar(25) default '',
`owner2` varchar(25) default '',
`owner3` varchar(25) default '',
`note` text,
`timestamp` timestamp(14) NOT NULL,PRIMARY KEY  (`id`)) TYPE=MyISAM"""%table
        
    cursor.execute(sql)
</t>
<t tx="ekr.20051104081502.456">def ReadFromDB(self):
    L = self.L
    Properties = self.PropertyDicts[L]
    
    host = Properties['host']
    cursor = self.GetCursor(host)
    if cursor is None:
        return None
        
    table = Properties['table']
    
    owner = Properties['owner']
    if owner == '*ALL':
        WHERE = ""
    else:
        WHERE = 'WHERE (owner1 = "%s" OR owner2 = "%s" OR owner3 = "%s")'%(owner,owner,owner)
    
    #-1 show them all; 0 show none; integer show for that many days
    days = Properties['showfinished']	
    if days != -1:
        if days:
            date = mx.DateTime.now() - days
            t = "(finisheddate IS NULL OR finisheddate &gt; '%s')"%date
        else:
            t = "finisheddate IS NULL"
        
        if WHERE:
            WHERE = "%s AND %s"%(WHERE,t)
        else:
            WHERE = " WHERE %s"%t

    Sort = Properties['sort']
    if Sort:
        sort_attr = Sort['attribute']
        if sort_attr == 'date':
            sort_attr = Properties['LCdate']
        elif sort_attr == 'owners':
            sort_attr = 'owner1'
        
        WHERE = WHERE + " ORDER BY " + sort_attr
        #if not direction: WHERE = WHERE + " DESC"   works because ASC is the default
        if not Sort['direction']:
            WHERE = WHERE + " DESC" 

    sql = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp FROM %s %s"%(table,WHERE)
            
    try:
        cursor.execute(sql)
    except:
        g.pr("Cannot read %s: %s"%(Properties['host'],table))
        return None #[]
    else:
        return cursor.fetchall()
        


</t>
<t tx="ekr.20051104081502.457">def CreateAndDisplayList(self, results):
    LCtrl = self.ListCtrls[self.L]
    LCdate = self.PropertyDicts[self.L]['LCdate']
    if LCdate == 'timestamp':
        format = '%m/%d %H:%M:%S'
    else:
        format = '%m/%d/%y'
    itemlist = []

    LCtrl.DeleteAllItems()
    class Item: pass
    
    for x,row in enumerate(results):
        
        item = Item()
        &lt;&lt; assign item attributes &gt;&gt;
        itemlist.append(item)
        
        &lt;&lt; draw item &gt;&gt;

    return itemlist


</t>
<t tx="ekr.20051104081502.458">item.priority = int(row[0]) #int(row[0]) needs int because it seems to come back as a long from MySQL
item.name = row[1]
item.createdate = row[2]
item.finisheddate = row[3]
item.duedate = row[4]
item.owners = [y for y in row[5:8] if y] #if you carry around ['tom',None,None] Note this is 5:8 not 5:7
item.id = row[8]
item.timestamp = row[9]

</t>
<t tx="ekr.20051104081502.459">LCtrl.InsertImageStringItem(x, str(item.priority), LCtrl.idx1)
LCtrl.SetStringItem(x,1,item.name)
LCtrl.SetStringItem(x,2,'; '.join(item.owners))
date = item.__dict__[LCdate]
LCtrl.SetStringItem(x,3,date and date.Format(format) or "")

if item.finisheddate:
    LC_Item = LCtrl.GetItem(x)
    LC_Item.SetImage(LCtrl.idx0) #might just want generic number or greyed one two three
    LC_Item.SetTextColour(wxLIGHT_GREY)
    LCtrl.SetItem(LC_Item)
    
elif item.priority==2:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #resetting weight
    LCtrl.SetItem(LC_Item)

elif item.priority==3:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #return to normal
    LC_Item.SetTextColour(wxRED)
    LCtrl.SetItem(LC_Item)</t>
<t tx="ekr.20051104081502.460">def OnSync(self, evt=None):
    if self.modified:
        self.OnUpdate()
    #Note that the results of an sqlite query are an instance that you need to turn into a tuple or MySQL gets unhappy

    if OFFLINE_ONLY:
        dlg = wxMessageDialog(self, "You need to be online to synchronize!", style = wxOK|wxICON_ERROR)
        dlg.ShowModal()
        dlg.Destroy()
        return
        
    dlg = wxMessageDialog(self,"Synchronize Table(s): "+" and ".join(SYNC_TABLES),"Synchronize...",wxICON_QUESTION|wxYES_NO)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return
    
    if REMOTE_HOST is None:
        g.pr("There doesn't appear to be a Remote Server")
        return

    if LOCAL_HOST is None:
        g.pr("There doesn't appear to be a Local Server")
        return
        
    g.pr("LOCAL_HOST=",LOCAL_HOST)
    g.pr("REMOTE_HOST=",REMOTE_HOST)

    r_cursor = self.GetCursor(REMOTE_HOST)
    if r_cursor is None:
        g.pr("Couldn't get a cursor for %s"%REMOTE_HOST)
        return

    l_cursor = self.GetCursor(LOCAL_HOST)
    if l_cursor is None:
        g.pr("Couldn't get a cursor for %s"%LOCAL_HOST)
        return

    # moving the sync time back a second to make sure that we don't lose track of any nodes
    #that are being updated or inserted at the same time as we are syncing
    r_cursor.execute("SELECT NOW()")
    l_now = mx.DateTime.now()-mx.DateTime.oneSecond
    r_now = r_cursor.fetchone()[0]-mx.DateTime.oneSecond
    #because of some inconsistent rounding appears necessary to make sure the sqlite timestamp is less than l_now
    #having seen same issue for mysql but for consistency (and because sqlite could also be "server" rdbms
    l_ts = l_now - mx.DateTime.DateTimeDelta(0,0,0,0.02)
    r_ts = r_now - mx.DateTime.DateTimeDelta(0,0,0,0.02)
    g.pr("l_now=",l_now, "l_ts =",l_ts)
    g.pr("r_now=",r_now, "r_ts=",r_ts)

    r_cursor.execute("SELECT MAX(last_sync) FROM user_sync WHERE user = %s", (USER,))
    r_last_sync = r_cursor.fetchone()[0]
    g.pr("last sync (remote time) =",r_last_sync)

    l_cursor.execute("SELECT MAX(last_sync) FROM user_sync")
    l_last_sync = l_cursor.fetchone()[0] #note MAX returns a string with sqlite so we turn it make into DateTime
    l_last_sync = mx.DateTime.DateTimeFrom(l_last_sync)
    g.pr("last sync (local time) =",l_last_sync)

    for table in SYNC_TABLES:
        # Need to pick up changes for both so syncing one doesn't add new things and screw up the second sync
        g.pr("Checking "+table+" on the Remote Server; changes (excluding deletes) are:")
        r_cursor.execute("SELECT id,createdate from "+table+" WHERE timestamp &gt; %s AND timestamp &lt;= %s",(r_last_sync,r_now)) 
        r_results = r_cursor.fetchall()
        g.pr("Server changes (excluding deletes)")
        g.pr(r_results)
        
        g.pr("Checking "+table+" on Local; changes (excluding deletes) are:")
        l_cursor.execute("SELECT id,createdate from "+table+" WHERE timestamp &gt; %s AND timestamp &lt;= %s",(l_last_sync,l_now))
        l_results = l_cursor.fetchall()
        g.pr("Local changes (excluding deletes)")
        g.pr(l_results)

        for id, createdate in r_results:
            r_cursor.execute("SELECT priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id FROM "+table+" WHERE ID = %s",(id,))
            row = r_cursor.fetchone()
            if row:
                if createdate &gt; r_last_sync:
                    l_cursor.execute("INSERT INTO "+table+" (priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)", row) #*row also works
                    g.pr("Created %s in %s on Local"%(id,table))
                else:
                    l_cursor.execute("UPDATE "+table+" SET priority = %s, name =%s, owner1 = %s, owner2 = %s, owner3 = %s, createdate = %s, finisheddate = %s, duedate = %s, note = %s WHERE id = %s", row)
                    g.pr("Updated %s in %s on Local"%(id,table))
                # for reasons I don't understand l_now here is a 1/100 ahead of l_now when inserted into user_sync
                l_cursor.execute("UPDATE "+table+" SET timestamp = %s WHERE id = %s", (l_ts,id))
        
        for id, createdate in l_results:
            l_cursor.execute("SELECT priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id FROM "+table+" WHERE ID = %s",(id,))
            row = l_cursor.fetchone()
            if row:
                row = tuple(row)
                #above needed because sqlite returns an enhanced tuple-like object that is not a tuple
                if createdate &gt; l_last_sync:
                    r_cursor.execute("INSERT INTO "+table+" (priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)", row)
                    g.pr("Created %s in %s on Server"%(id,table))
                else:
                    r_cursor.execute("UPDATE "+table+" SET priority = %s, name =%s, owner1 = %s, owner2 = %s, owner3 = %s, createdate = %s, finisheddate = %s, duedate = %s, note = %s WHERE id = %s", row)
                    g.pr("Updated %s in %s on Server"%(id,table))
                r_cursor.execute("UPDATE "+table+" SET timestamp = %s WHERE id = %s", (r_ts,id))
    
    #Handle the deletes; Note if at some point only 'd's are being written won't have to check for 'd'
    r_cursor.execute("SELECT id,table_name FROM sync WHERE timestamp &gt; %s AND timestamp &lt;= %s AND action = 'd'",(r_last_sync,r_now))
    r_results = r_cursor.fetchall()

    l_cursor.execute("SELECT id,table_name FROM sync WHERE timestamp &gt; %s AND timestamp &lt;= %s AND action = 'd'",(l_last_sync,l_now))
    l_results = l_cursor.fetchall()

    for id,table in l_results:
        r_cursor.execute("DELETE from "+table+" WHERE id = %s", (id,))
        g.pr("Deleted %s from %s on Server (if it existed there)"%(id,table))

    for id,table in r_results:
        l_cursor.execute("DELETE from "+table+" WHERE id = %s", (id,))
        g.pr("Deleted %s from %s on Local (if it existed there)"%(id,table)	)
    #End of deletes code
    
    #update the user_sync database with the latest sync times
    l_cursor.execute("INSERT INTO user_sync (user,last_sync) VALUES (%s,%s)", (USER,l_now)) #don't really need USER for local
    r_cursor.execute("INSERT INTO user_sync (user,last_sync) VALUES (%s,%s)", (USER,r_now)) 
    
    g.pr("Synchronization completed")

</t>
<t tx="ekr.20051104081502.461">def TimeStamper(self, host, cursor, table, id):
    #note that you can insert a timestamp value into an mysql timestamp field
    if host.split(':')[1] == 'sqlite': #host -&gt; location:rdbms
        timestamp = mx.DateTime.now()
        cursor.execute("UPDATE "+table+" SET timestamp = %s WHERE id = %s", (timestamp,id))
    else:
        cursor.execute("Select timestamp from "+table+" WHERE id = %s", (id,))
        timestamp = cursor.fetchone()[0]
        
    return timestamp
</t>
<t tx="ekr.20051104081502.462"></t>
<t tx="ekr.20051104081502.463">def OnShowEvaluate(self, evt=None):
    
    self.EvalDialog.Show(True)
    self.EvalDialog.EvalText.SetSelection(-1,-1)
    self.EvalDialog.EvalText.SetFocus()
    
</t>
<t tx="ekr.20051104081502.464">def OnEvaluate(self, evt=None):
    expr = self.EvalDialog.EvalText.GetValue()
    g.pr("%s =&gt; "%expr,newline=False)
    g.pr(eval(expr))
    
</t>
<t tx="ekr.20051104081502.465"></t>
<t tx="ekr.20051104081502.466">def OnShowAbout(self, evt=None):
    from about import AboutBox
    dlg = AboutBox(self, app_version = VERSION)
    dlg.ShowModal()
    dlg.Destroy()
    
</t>
<t tx="ekr.20051104081502.467">def OnShowHelp(self, evt=None):
    os.startfile('ListManager.chm')
    
</t>
<t tx="ekr.20051104081502.468">def GetUID(self):
    pyiid = CreateGuid()
    # the str(pyiid) looks like {....} and doing [1:-1] strips that off
    return str(pyiid)[1:-1]
    
</t>
<t tx="ekr.20051104081502.469">def OnIdle(self, evt):	
    &lt;&lt; Check for Transfers From Outlook &gt;&gt;
    &lt;&lt; Check if Edited File has Changed &gt;&gt;
    
</t>
<t tx="ekr.20051104081502.471">if OUTLOOK:
    input,output,exc = select.select([self.sock],[],[],0)
    if input:
        client,addr = self.sock.accept() # Get a connection
        rec = client.recv(8192)
        d = pickle.loads(rec)
        
        class Item: pass
        
        item = Item()
        item.id = self.GetUID()
        item.priority = 1
        item.createdate = mx.DateTime.now()
        item.duedate = item.finisheddate = None
        
        #outlook strings are unicode; ascii encode makes sure no chars above 127
        name = d['Subject'].encode('ascii','replace') 
        item.name = name[:150]
        
        owner = d['SenderName'].encode('ascii','replace') #encode takes unicode to standard strings
        owner = owner[:25]
        item.owners = [owner]
        
        note = d['CreationTime'] + '\n' + d['Body'].encode('ascii','replace')
        #foldername = d['Parent.Name']
        
        #location, rdbms, table = MAIL_LIST_PATH.split(':')
        #host = '%s:%s'%(location,rdbms)
        host, table = re.split('(.*?:.*?):', MAIL_LIST_PATH)[1:3] #really just for fun
        
        cursor = self.Cursors[host]
        
        cursor.execute("INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,owner1,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s)",
            (item.priority, name, item.createdate, item.finisheddate, item.duedate, owner, note, item.id))
        
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)
        
        #check to see if table is open
        for L,Properties in enumerate(self.PropertyDicts):
            if Properties['table'] == table and Properties['host'] == host:
                break
        else:
            g.pr("Table not open but wrote to database anyway") #Needs to be a dialog box
            return
        
        # could have started to edit something and never finished it
        if self.modified:
            self.OnUpdate()
        
        if self.L != L:
            self.nb.SetSelection(L) # Note that this does not call OnPageChange if the page doesn't change
        
        LCtrl = self.ListCtrls[L]
        
        if self.curIdx != -1:
            LCtrl.SetItemState(self.curIdx, 0, wxLIST_STATE_SELECTED)
        
        self.ItemLists[L].insert(0,item)    
        LCtrl.InsertImageStringItem(0,"1", LCtrl.idx1)
        LCtrl.SetStringItem(0,self.attr2col_num['name'],name)
        LCtrl.SetStringItem(0, self.attr2col_num['owners'], owner)
        
        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(0, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
        elif Properties['LCdate'] == 'createdate':
            LCtrl.SetStringItem(0, self.attr2col_num['date'], item.createdate.Format('%m/%d/%y'))
        
        LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = 0 

</t>
<t tx="ekr.20051104081502.473">for ed in self.editor:
    path = ed['path']
    t = os.path.getmtime(path)
    if t != ed['time']:
        f = file(path,'r')
        note = f.read()
        f.close()
        ed['time'] = t
        
        host = ed['host']
        cursor = self.Cursors[host]
        table = ed['table']
        id = ed['id']
        cursor.execute("UPDATE "+table+" SET note = %s WHERE id = %s", (note,id)) 
        # see @rst documentation note
        ts = self.TimeStamper(host, cursor, table, id)
        
        idx = self.curIdx
        L = self.L
        if idx != -1:
            item = self.ItemLists[L][idx]
            if item.id == id:
                self.note.SetValue(note)
                item.timestamp = ts
                
                if self.PropertyDicts[L]['LCdate'] == 'timestamp':
                    self.ListCtrls[L].SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
    
                if 'note' in self.modified: #if necessary only if somehow note text didn't change
                    del self.modified['note']

</t>
<t tx="ekr.20051104081502.475">class ListCtrl(wxListCtrl, wxListCtrlAutoWidthMixin):
    @others
</t>
<t tx="ekr.20051104081502.476">def __init__(self, parent, ID, pos=wxDefaultPosition, size=wxDefaultSize, style=0):
    wxListCtrl.__init__(self, parent, ID, pos, size, style)
    wxListCtrlAutoWidthMixin.__init__(self)

    self.il = wxImageList(16,16)

    sm_up = self.il.Add(wxBitmap('bitmaps\\up_arrow.bmp')) #(images.getSmallUpArrowBitmap())
    sm_dn = self.il.Add(wxBitmap('bitmaps\\down_arrow.bmp'))
    self.arrows = (sm_up,sm_dn)
    
    self.idx1 = self.il.Add(wxBitmap('bitmaps\\box.bmp'))
    self.idx0 = self.il.Add(wxBitmap('bitmaps\\filledwhitebox.bmp'))    

    self.SetImageList(self.il, wxIMAGE_LIST_SMALL)

    EVT_LIST_COL_BEGIN_DRAG(self, self.GetId(), self.OnColBeginDrag)    

    self.SetUpColumns()

</t>
<t tx="ekr.20051104081502.477">def SetUpColumns(self):
    #Need to to construct column heads for columns with sorting by hand to get sorting images on columns
    info = wxListItem()
    info.m_mask = wxLIST_MASK_TEXT | wxLIST_MASK_IMAGE | wxLIST_MASK_FORMAT
    info.m_image = -1

    #Oth column is priority which is sortable
    info.m_format = wxLIST_FORMAT_LEFT
    info.m_text = "P"
    self.InsertColumnInfo(0, info)
    self.SetColumnWidth(0, 35)
    
    self.InsertColumn(1, "Name")
    self.SetColumnWidth(1, 590)

    self.InsertColumn(2, "Owner")
    self.SetColumnWidth(2, 100)
    
    #3th column is create ate and same as with priority - needs to constructed by hand
    info.m_format = wxLIST_FORMAT_LEFT
    info.m_text = "Due Date"
    self.InsertColumnInfo(3, info)
    self.SetColumnWidth(3, 75)                

</t>
<t tx="ekr.20051104081502.478">def OnColBeginDrag(self, evt):
    #if inplace editor then change its dimensions
    if evt.GetColumn() == 0:
        evt.Veto()
</t>
<t tx="ekr.20051104081502.479">class MyApp(wxApp):
    @others
</t>
<t tx="ekr.20051104081502.480">def OnInit(self):
    global OFFLINE_ONLY, CANCEL
    wxInitAllImageHandlers()
    
    if STARTUP_DIALOG:
        startup = StartupDialog(None, 'List Manager')
        val = startup.ShowModal()
        startup.Destroy()
        if val == wxID_YES:
            OFFLINE_ONLY = True
        elif val == wxID_NO:
            OFFLINE_ONLY = False
        elif val == wxID_CANCEL:
            CANCEL = True
            return True

    if OFFLINE_ONLY is False:
        server = REMOTE_HOST.split(':')[0]
        try:
            socket.gethostbyname(server)
        except:
            dlg = wxMessageDialog(None, "Cannot connect to remote server! Only offline access is possible.", "ListManager", style=wxOK|wxICON_EXCLAMATION|wxSTAY_ON_TOP)
            dlg.ShowModal()
            dlg.Destroy()
            OFFLINE_ONLY = True
            
    frame = ListManager(None, -1, "List Manager", size = (X,Y))
    frame.Show(True)
    self.SetTopWindow(frame)
    CANCEL = False
    return True


</t>
<t tx="ekr.20051104081502.481">class Logger:
    def __init__(self):
        self.dlg = LoggerDialog(None, "", "Alerts and Exceptions", dir=DIRECTORY)
    def write(self, error_msg):
        if not self.dlg.IsShown():
            self.dlg.text.AppendText("\n%s\n"%time.asctime())
            self.dlg.Show(True)
        
        self.dlg.text.AppendText(error_msg)

</t>
<t tx="ekr.20051104081502.482">def run():
    app = MyApp(0)
    if not CANCEL:
        sys.stderr = sys.stdout = Logger()
        app.MainLoop()
    
if __name__ == '__main__':
    run()
</t>
<t tx="ekr.20051104081502.483">@ @rst-options
code_mode = True
@c


@language python
from wxPython.wx import *
# the following two are needed for the calendar
from wxPython.calendar import *
from wxPython.utils import *
import os
@others</t>
<t tx="ekr.20051104081502.484">class TicklerDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.485">def __init__(self, parent, msg, caption, pos = wxDefaultPosition, size = wxDefaultSize):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP | wxTHICK_FRAME | wxCAPTION)

    TC = wxTextCtrl(self, -1, msg, wxDefaultPosition,
                    (450,250),
                    wxTE_MULTILINE | wxTE_READONLY | wxTE_RICH2)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)        
    
    sizer.Add(TC, 1, wxALIGN_CENTRE|wxALL, 5)
    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    
    sizer.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)
    btn = wxButton(self, wxID_OK, "GO TO ITEM")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_FORWARD, "SHOW NEXT")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_APPLY, "MAIL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)        

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    
    sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)

    EVT_LEFT_DOWN(TC, self.OnLeftDown)
    EVT_BUTTON(self, wxID_FORWARD, self.OnForward)
    EVT_BUTTON(self, wxID_APPLY, self.OnMail)

    TC.SetCursor(wxStockCursor(wxCURSOR_ARROW))        

    self.TC = TC
</t>
<t tx="ekr.20051104081502.486">def OnLeftDown(self, evt):
    self.EndModal(wxID_OK)
</t>
<t tx="ekr.20051104081502.487">def OnForward(self, evt):
    self.EndModal(wxID_FORWARD)
</t>
<t tx="ekr.20051104081502.488">def OnMail(self, evt):
    self.EndModal(wxID_APPLY)        
</t>
<t tx="ekr.20051104081502.489">class StartupDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.490">def __init__(self, parent, caption, pos=wxDefaultPosition, size=(300,115)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)

    msg = "You can connect to the server using the network,\nor work offline, or cancel this logon."

    image = wxStaticBitmap(self, -1, wxBitmap('bitmaps\\wxpdemo.bmp'), (-1,-1), size=(32,32)) #sizer determines position
    text = wxStaticText(self, -1, msg, (-1,-1), size=(250,32)) #sizer determines position

    rect = wxBoxSizer(wxHORIZONTAL)
    rect.Add(image, 0, wxALIGN_LEFT|wxALL, 4)
    rect.Add(text, 1, wxALIGN_CENTER|wxTOP, 7)
    sizer = wxBoxSizer(wxVERTICAL)


    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_NO, 'Connect')
    box.Add(btn, 0, wxALL, 10)
    btn.SetDefault()

    btn = wxButton(self, wxID_YES, 'Work Offline')
    box.Add(btn, 0, wxALL, 10)

    btn = wxButton(self, wxID_CANCEL, 'Cancel')
    box.Add(btn, 0, wxALL, 10)

    sizer.AddSizer(rect)
    sizer.AddSizer(box)

    self.SetSizer(sizer)

    EVT_BUTTON(self, wxID_NO, self.OnSelection)
    EVT_BUTTON(self, wxID_YES, self.OnSelection)
    EVT_BUTTON(self, wxID_CANCEL, self.OnSelection)</t>
<t tx="ekr.20051104081502.491">def OnSelection(self,evt):
    val = evt.GetId()
    self.EndModal(val)</t>
<t tx="ekr.20051104081502.492">class ModifierDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.493">def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxCAPTION,
             modifierlist=None,
             curselections = ''):
    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    sizer1 = wxBoxSizer(wxVERTICAL)
    sizer2 = wxBoxSizer(wxHORIZONTAL)
    
    tc = wxTextCtrl(self, -1, "", size = (150,-1))
    sizer1.Add(tc, 0, wxALIGN_CENTRE|wxALL, 5)
    self.tc = tc

    if not modifierlist:
        modifierlist = []
    lb = wxListBox(self, -1,  wxDefaultPosition, (150,300), #wxPoint(90, 80)
                    modifierlist, wxLB_MULTIPLE|wxLB_SORT)

    sizer1.Add(lb, 1, wxALIGN_CENTRE|wxALL, 5)

    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    sizer1.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)
    

    btn = wxButton(self, wxID_OK, "OK")
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer1.AddSizer(sizer2, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer1)
    self.SetAutoLayout(True)
    sizer1.Fit(self)

    for sel in curselections:
        index = lb.FindString(sel)
        if index !=-1:
            lb.SetSelection(index)

    self.lb = lb

    EVT_BUTTON(self, wxID_CANCEL, self.ClearSelections)


</t>
<t tx="ekr.20051104081502.494">def GetUserInput(self):
    idx_list = self.lb.GetSelections()
    mod_list =[]
    for i in idx_list:
        mod_list.append(self.lb.GetString(i))
        self.lb.Deselect(i) #071203

    new_list = []
    manual_string = self.tc.GetValue() #text entry box
    
    if manual_string:
        manual_list = [x.strip() for x in manual_string.split(';')]
        for name in manual_list:
            clean_name = ", ".join([x.strip().title() for x in name.split(',')])
            if clean_name not in mod_list:
                mod_list.append(clean_name)
                new_list.append(clean_name)

        
    return (mod_list, new_list)</t>
<t tx="ekr.20051104081502.495">def SelectCurrent(self, cur_sel):
    for sel in cur_sel:
        index = self.lb.FindString(sel)
        if index !=-1:
            self.lb.SetSelection(index)


</t>
<t tx="ekr.20051104081502.496">def ClearSelections(self, evt=None):
    idx_list = self.lb.GetSelections() #note you can't just use the indexes of the SelectCurrent since they may have clicked before cancelling
    for i in idx_list:
        self.lb.Deselect(i)

    evt.Skip()</t>
<t tx="ekr.20051104081502.497">class MailDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.498">def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxSTAY_ON_TOP| wxTHICK_FRAME|wxCAPTION|wxSYSTEM_MENU,
             recipients='',
             subject = '',
             body = ''):
    
    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)

    recipients = "; ".join(recipients)
    label = wxStaticText(self, -1, "To:",wxDefaultPosition, size=(40,-1), style=wxALIGN_LEFT)
    RTC = wxTextCtrl(self, -1, recipients, size = (480,-1))
    box.Add(label)
    box.Add(RTC)

    #sizer.Add(10,10,0)      

    sizer.AddSizer(box)        

    box = wxBoxSizer(wxHORIZONTAL)       
    label = wxStaticText(self, -1, "Subject:",wxDefaultPosition, size=(40,-1),style=wxALIGN_LEFT)
    STC = wxTextCtrl(self, -1, subject, size = (480,-1)) 
    box.Add(label)
    box.Add(STC)

    sizer.AddSizer(box)
    sizer.Add(1, 5, 0)
    
    BTC = wxTextCtrl(self, -1, body, wxDefaultPosition, size = (500,400), style=wxTE_MULTILINE|wxTE_RICH2)

    sizer.Add(BTC)

    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_OK, "SEND MAIL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer.AddSizer(box)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)

    self.RTC = RTC
    self.STC = STC
    self.BTC = BTC

</t>
<t tx="ekr.20051104081502.499">class CalendarDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.5"></t>
<t tx="ekr.20051104081502.500">def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxCAPTION,
             date=0):
    
    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    if not date:
        date = wxDateTime_Now()

    cal = wxCalendarCtrl(self, -1, date, #pos = (25,50),
                         style = wxCAL_SHOW_HOLIDAYS | wxCAL_SUNDAY_FIRST)

    EVT_CALENDAR(self, cal.GetId(), self.OnCalSelected)

    #EVT_CLOSE(self, self.OnCloseWindow)          
    
    self.cal = cal

    # Set up control to display a set of holidays:
    EVT_CALENDAR_MONTH(self, cal.GetId(), self.OnChangeMonth)
    
    self.holidays = [(1,1), (10,31), (12,25) ]    # (these don't move around)
    
    self.OnChangeMonth()        

#-------------------------------------------------------------------------        
    sizer1 = wxBoxSizer(wxVERTICAL)
    sizer2 = wxBoxSizer(wxHORIZONTAL)
 
    sizer1.Add(cal, 0, wxALIGN_CENTRE|wxALL, 5)

    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    sizer1.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxRIGHT|wxTOP, 5)
    

    btn = wxButton(self, wxID_OK, "OK")
    btn.SetDefault()
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    #btn.SetDefault()
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer1.AddSizer(sizer2, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer1)
    self.SetAutoLayout(True)
    sizer1.Fit(self)
</t>
<t tx="ekr.20051104081502.501">def OnCalSelected(self, evt):
    self.result = evt.GetDate()
    self.EndModal(wxID_OK)
</t>
<t tx="ekr.20051104081502.502">def OnChangeMonth(self, evt=None):
    cur_month = self.cal.GetDate().GetMonth() + 1   # convert wxDateTime 0-11 =&gt; 1-12
    for month, day in self.holidays:
        if month == cur_month:
            self.cal.SetHoliday(day)        
</t>
<t tx="ekr.20051104081502.503">def OnCloseWindow(self, event):
    #self.cal.Destroy
    #self.Destroy()
    g.pr("I got to close window")
</t>
<t tx="ekr.20051104081502.504">def GetDate(self):
    return self.result
</t>
<t tx="ekr.20051104081502.505">class FindDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.506">def __init__(self, parent, caption, msg, pos=wxDefaultPosition, size=(300,120)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)    

    self.FindText = wxTextCtrl(self, -1, msg, wxDefaultPosition,(200,24))
         
    box_a = wxBoxSizer(wxHORIZONTAL)
    box_a.Add(self.FindText, 1, wxALIGN_CENTER|wxALL, 5)

    box_b = wxBoxSizer(wxVERTICAL)        
    btn = wxButton(self, wxID_OK, "OK")
    box_b.Add(btn, 0, wxALIGN_CENTER|wxALL,5)
    btn.SetDefault()               

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box_b.Add(btn, 0, wxALIGN_CENTER)

    box_a.AddSizer(box_b)

    self.MatchCase = wxCheckBox(self, -1, "Match Case")
    self.MatchWhole = wxCheckBox(self, -1, "Match Whole Word")
    box_c = wxBoxSizer(wxVERTICAL)
    box_c.Add(self.MatchCase, 0, wxLEFT|wxBOTTOM, 5)
    box_c.Add(self.MatchWhole, 0, wxLEFT, 5)

    self.SearchNotes = wxCheckBox(self, -1, "Search Notes")
    self.SearchFinished = wxCheckBox(self, -1, "Search Finished")
    box_d = wxBoxSizer(wxVERTICAL)
    box_d.Add(self.SearchNotes, 0, wxLEFT|wxBOTTOM, 5)
    box_d.Add(self.SearchFinished, 0, wxLEFT, 5)

    box_e = wxBoxSizer(wxHORIZONTAL)
    box_e.AddSizer(box_c)
    box_e.AddSizer(box_d)

    sizer = wxBoxSizer(wxVERTICAL)
    sizer.AddSizer(box_a)
    sizer.AddSizer(box_e)

    self.SetSizer(sizer)

    EVT_BUTTON(self, wxID_OK, parent.FindString)


</t>
<t tx="ekr.20051104081502.507">class EvalDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.508">def __init__(self, parent, caption, msg, pos=wxDefaultPosition, size=(300,80)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)    

    EvalText = wxTextCtrl(self, -1, msg, wxDefaultPosition,(200,24))

         
    box_a = wxBoxSizer(wxHORIZONTAL)
    box_a.Add(EvalText, 1, wxALIGN_CENTER|wxALL, 5)

    box_b = wxBoxSizer(wxVERTICAL)        
    btn = wxButton(self, wxID_OK, "OK")
    box_b.Add(btn, 0, wxALIGN_CENTER|wxALL,5)
    btn.SetDefault()               

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box_b.Add(btn, 0, wxALIGN_CENTER)

    box_a.AddSizer(box_b)

    self.SetSizer(box_a)

    self.EvalText = EvalText
    self.parent = parent

    #EVT_BUTTON(self, wxID_OK, self.PostOKEvent)
    EVT_BUTTON(self, wxID_OK, parent.OnEvaluate)



</t>
<t tx="ekr.20051104081502.509">def PostOKEvent(self, evt=None):
    wxPostEvent(self.parent, evt)
</t>
<t tx="ekr.20051104081502.510">class LoggerDialog(wxDialog):
    @others</t>
<t tx="ekr.20051104081502.511">def __init__(self, parent, msg, caption, pos=(-1,-1), size=(500,300), dir=None):
    wxDialog.__init__(self, parent, -1, caption, pos, size)
    #if pos == (-1,-1):
        #self.CenterOnScreen(wxBOTH)
        
    if dir:
        self.dir = dir
    else:
        self.dir = os.getcwd()
        
    text = wxTextCtrl(self, -1, msg, (-1,-1), (450,250), wxTE_MULTILINE | wxTE_READONLY)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)        
    
    sizer.Add(text, 1, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_OK, "Close")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()
    
    ID_SAVE = wxNewId()

    btn = wxButton(self, ID_SAVE, "Save to File")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)        

    sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)
    
    self.text = text
    
    EVT_BUTTON(self, ID_SAVE, self.OnSave)
</t>
<t tx="ekr.20051104081502.512">def OnSave(self, evt):
        
    path = os.path.join(self.dir, 'logfile.txt')
        
    f = file(path,'a')
    f.write(self.text.GetValue())
    f.close()

    dlg = wxMessageDialog(self,"Appended text to logfile.text", "Notice", wxICON_INFORMATION|wxOK)
    dlg.ShowModal()
    dlg.Destroy()
    
    self.text.Clear()
</t>
<t tx="ekr.20051104081502.513">class FinishedDialog(wxDialog):
    @others</t>
<t tx="ekr.20051104081502.514">def __init__(self, parent, title,
            pos=wxDefaultPosition,
            size=wxDefaultSize,
            style=wxCAPTION,
            days=0,
            spin_label="",
            check_label=""):
             
    wxDialog.__init__(self, parent, -1, title, pos, size)
    self.Centre()
    
    self.check = wxCheckBox(self, -1, check_label)
    
    if days == -1:
        self.check.SetValue(True)
        days = 0
    
    panel = wxPanel(self, -1, (-1,-1),(225,75))
    wxStaticText(panel, -1, spin_label,(15, 15))
    self.text = wxTextCtrl(panel, -1, str(days), (30, 50), (30, -1))
    h = self.text.GetSize().height
    self.spin = wxSpinButton(panel, -1, (56, 50), (h, h), wxSP_VERTICAL)
    wxStaticText(panel, -1, 'days',(76, 53))
    self.spin.SetRange(0, 14)
    self.spin.SetValue(days)
    
    H_sizer = wxBoxSizer(wxHORIZONTAL)
    
    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    
    btn = wxButton(self, wxID_OK, "OK")
    H_sizer.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    H_sizer.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    
    V_sizer = wxBoxSizer(wxVERTICAL)
    V_sizer.Add(panel,1,wxALIGN_CENTER|wxEXPAND)
    V_sizer.Add(-1,5)
    V_sizer.Add(self.check,0,wxALIGN_LEFT|wxALL,5)
    V_sizer.Add(line,0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)
    V_sizer.AddSizer(H_sizer, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    
    self.SetSizer(V_sizer)
    self.SetAutoLayout(True)
    V_sizer.Fit(self)

    EVT_SPIN(self, self.spin.GetId(), self.OnSpin)
    EVT_CHECKBOX(self, self.check.GetId(), self.OnCheck)
    
    if self.check.GetValue():
        self.spin.Enable(False)
        self.text.Enable(False)
        
    self.Layout() #doesn't appear necessary


</t>
<t tx="ekr.20051104081502.515">def OnSpin(self, evt):
    self.text.SetValue(str(evt.GetPosition()))</t>
<t tx="ekr.20051104081502.516">def OnCheck(self, evt=None):
    if self.check.GetValue():
        self.spin.Enable(False)
        self.text.Enable(False)
    else:
        self.spin.Enable(True)
        self.text.Enable(True)
</t>
<t tx="ekr.20051104081502.517">class TreeDialog(wxDialog):
    @others</t>
<t tx="ekr.20051104081502.518">def __init__(self, parent, caption, pos=wxDefaultPosition, size=(300,400), tree={}):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)

    TreeCtrl = wxTreeCtrl(self, -1, wxDefaultPosition, (300,400), wxTR_HAS_BUTTONS)    #|wxTR_HIDE_ROOT)#wxDefaultSize,
    
    sizer = wxBoxSizer(wxVERTICAL)
    sizer.Add(TreeCtrl, 1, wxALIGN_CENTER|wxALL, 5)

    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_OK, "OK")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer.AddSizer(box)
    self.SetAutoLayout(1)
    self.SetSizer(sizer)

    il = wxImageList(16,16)
    
    fldridx = il.Add(wxBitmap('bitmaps\\folder.bmp'))
    fldropenidx = il.Add(wxBitmap('bitmaps\\folder_open.bmp'))
    listidx =  il.Add(wxBitmap('bitmaps\\list.bmp'))

    TreeCtrl.SetImageList(il)

    root = TreeCtrl.AddRoot("List Manager")
    TreeCtrl.SetItemImage(root, fldridx, wxTreeItemIcon_Normal)
    TreeCtrl.SetItemImage(root, fldropenidx, wxTreeItemIcon_Expanded)

    for host in tree:
        child = TreeCtrl.AppendItem(root, host)
        TreeCtrl.SetItemImage(child, fldridx, wxTreeItemIcon_Normal)
        TreeCtrl.SetItemImage(child, fldropenidx, wxTreeItemIcon_Expanded)
        for listname in tree[host]:
            last = TreeCtrl.AppendItem(child, listname)
            TreeCtrl.SetItemImage(last, listidx, wxTreeItemIcon_Normal)
            TreeCtrl.SetItemImage(last, listidx, wxTreeItemIcon_Selected)

    TreeCtrl.Expand(root)

    self.TreeCtrl= TreeCtrl
    self.il = il #? prevents GC

    EVT_LEFT_DCLICK(TreeCtrl, self.OnLeftDClick)
</t>
<t tx="ekr.20051104081502.519">def OnLeftDClick(self, event=None):
    self.EndModal(wxID_OK)
</t>
<t tx="ekr.20051104081502.520">@ @rst-options
code_mode = True
@c

@language python
&lt;&lt; outlookAddin declarations &gt;&gt;
@others

if __name__ == '__main__':
    import win32com.server.register
    win32com.server.register.UseCommandLine(OutlookAddin)
    if "--unregister" in sys.argv:
        UnregisterAddin(OutlookAddin)
    else:
        RegisterAddin(OutlookAddin)</t>
<t tx="ekr.20051104081502.521"># This is mainly stolen from Mark Hammond's demo plugin for win32com.client
# A demo plugin for Microsoft Outlook (NOT Outlook Express)

from win32com import universal
from win32com.server.exception import COMException
from win32com.client import gencache, DispatchWithEvents
from win32com.client import Dispatch
import winerror
import pythoncom
from win32com.client import constants
import win32ui ##
import sys
from socket import *
import pickle

# Support for COM objects we use.
#sz comment gencache.EnsureModule makes sure you are using makepy if the makepy-derived
#file doesn't already exist
#but as long as you did run makepy then you should just be alble to do a normal dispatch

mod = gencache.EnsureModule('{00062FFF-0000-0000-C000-000000000046}', 0, 9, 0, bForDemand=True) # Outlook 9
gencache.EnsureModule('{2DF8D04C-5BFA-101B-BDE5-00AA0044DE52}', 0, 2, 1, bForDemand=True) # Office 9

# The TLB defining the interfaces we implement
universal.RegisterInterfaces('{AC0714F2-3D04-11D1-AE7D-00A0C90F26F4}', 0, 1, 0, ["_IDTExtensibility2"])

Target = 'mail_transfer'


</t>
<t tx="ekr.20051104081502.522">class ButtonEvent:
    @others
</t>
<t tx="ekr.20051104081502.523">def OnClick(self, button, cancel):
    #activeExplorer and MailTransferFolder are globals defined in OnConnection
    sel = activeExplorer.Selection

    for i in range(1,sel.Count+1):
        item = sel.Item(i)
        item.Move(MailTransferFolder)

    return cancel

</t>
<t tx="ekr.20051104081502.524">class FolderEvent:
    @others
</t>
<t tx="ekr.20051104081502.525">def OnItemAdd(self, item):
    try:
        s = socket(AF_INET,SOCK_STREAM)
        s.connect(('localhost', 8888))
        d = {}
        d['Parent.Name'] = item.Parent.Name
        d['SenderName'] = item.SenderName
        d['Subject'] = item.Subject
        d['Body'] = item.Body[:5000]
        d['CreationTime'] = item.CreationTime.Format()
        str = pickle.dumps(d)
        s.send(str) # ?Receive no more than 1024 bytes
        s.close()
        win32ui.MessageBox("Sent %s to ListManager"%item.Subject)
    except:
        pass
</t>
<t tx="ekr.20051104081502.526">class OutlookAddin:
    &lt;&lt; class OutlookAddin declarations &gt;&gt;
    @others
</t>
<t tx="ekr.20051104081502.527">_com_interfaces_ = ['_IDTExtensibility2']
_public_methods_ = []
_reg_clsctx_ = pythoncom.CLSCTX_INPROC_SERVER
_reg_clsid_ = "{0F47D9F3-598B-4d24-B7E3-92AC15ED27E2}"
_reg_progid_ = "Python.Test.OutlookAddin"
_reg_policy_spec_ = "win32com.server.policy.EventHandlerPolicy"
</t>
<t tx="ekr.20051104081502.528">def OnConnection(self, application, connectMode, addin, custom):
    global MailTransferFolder
    global activeExplorer
    # ActiveExplorer may be none when started without a UI (eg, WinCE synchronisation)
    activeExplorer = application.ActiveExplorer()
    if activeExplorer:
        bars = activeExplorer.CommandBars
        toolbar = bars.Item("Standard")
        item = toolbar.Controls.Add(Type=constants.msoControlButton, Temporary=True)
        item = self.toolbarButton = DispatchWithEvents(item, ButtonEvent) #? just need this to be an ivar
        item.Caption="List Manager"
        item.TooltipText = "Click to move"
        item.Enabled = True
        #self.toolbarButton = DispatchWithEvents(item, ButtonEvent) #need something that won't get GC'd. Note Dispatch returns item

    ns = application.GetNamespace("MAPI")
    Folders = ns.Folders

    for i in range(1,len(Folders)+1):
        if Folders[i].Name.find("Mailbox") != -1:
            folders = Folders[i].Folders
            break
    else:
        win32ui.MessageBox("Can't find Mailbox!")
        return	
    
    for i in range(1,len(folders)+1):
        if folders[i].Name == Target:
            MailTransferFolder = folders[i]
            self.targetMailbox = DispatchWithEvents(folders[i].Items, FolderEvent) #? just need this to be an ivar
            win32ui.MessageBox("Enabled: %s\nOutlookAddin3"%Target)
            break
    else:
        win32ui.MessageBox("Could not find mail folder: %s\nOutlookAddin3"%Target)</t>
<t tx="ekr.20051104081502.529">def OnDisconnection(self, mode, custom):
    g.pr("OnDisconnection")
</t>
<t tx="ekr.20051104081502.530">def OnAddInsUpdate(self, custom):
    g.pr("OnAddInsUpdate", custom)
</t>
<t tx="ekr.20051104081502.531">def OnStartupComplete(self, custom):
    g.pr("OnStartupComplete", custom)
</t>
<t tx="ekr.20051104081502.532">def OnBeginShutdown(self, custom):
    g.pr("OnBeginShutdown", custom)
</t>
<t tx="ekr.20051104081502.533">def RegisterAddin(klass):
    import _winreg
    key = _winreg.CreateKey(_winreg.HKEY_CURRENT_USER, "Software\\Microsoft\\Office\\Outlook\\Addins")
    subkey = _winreg.CreateKey(key, klass._reg_progid_)
    _winreg.SetValueEx(subkey, "CommandLineSafe", 0, _winreg.REG_DWORD, 0)
    _winreg.SetValueEx(subkey, "LoadBehavior", 0, _winreg.REG_DWORD, 3)
    _winreg.SetValueEx(subkey, "Description", 0, _winreg.REG_SZ, klass._reg_progid_)
    _winreg.SetValueEx(subkey, "FriendlyName", 0, _winreg.REG_SZ, klass._reg_progid_)
</t>
<t tx="ekr.20051104081502.534">def UnregisterAddin(klass):
    import _winreg
    try:
        _winreg.DeleteKey(_winreg.HKEY_CURRENT_USER, "Software\\Microsoft\\Office\\Outlook\\Addins\\" + klass._reg_progid_)
    except WindowsError:
        pass
</t>
<t tx="ekr.20051104081502.535">########
Headline
########

@ @rst-options
.. These options have NO EFFECT for rst2 plugin!
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=c:\prog\leoCVS\leo\doc
write_intermediate_file = True
verbose=True
@c

This is a test of pdf stuff

.. contents::</t>
<t tx="ekr.20051104081502.536"></t>
<t tx="ekr.20051104081502.537">child node text</t>
<t tx="ekr.20051104081502.538">import sys
sys.path.append(r'c:\reportlab_1_20')

debug = True

@others

from reportlab.pdfgen import canvas
c = canvas.Canvas('hello.pdf')
for i in (10,50):
    text(c,'x'*10,i,i)
# pencil(c,text='Note')

key = 'key1'

c.bookmarkPage(key)
c.addOutlineEntry('OutlineEntry',key)


c.showPage()
c.save()</t>
<t tx="ekr.20051104081502.539">def text(c,text,i=100,j=100):
    c.drawString(i,j,text)</t>
<t tx="ekr.20051104081502.540">def pencil(canvas, text="No.2"):
    from reportlab.lib.colors import yellow, red, black,white
    from reportlab.lib.units import inch
    u = inch/10.0
    canvas.setStrokeColor(black)
    canvas.setLineWidth(4)
    # draw erasor
    canvas.setFillColor(red)
    canvas.circle(30*u, 5*u, 5*u, stroke=1, fill=1)
    # draw all else but the tip (mainly rectangles with different fills)
    canvas.setFillColor(yellow)
    canvas.rect(10*u,0,20*u,10*u, stroke=1, fill=1)
    canvas.setFillColor(black)
    canvas.rect(23*u,0,8*u,10*u,fill=1)
    canvas.roundRect(14*u, 3.5*u, 8*u, 3*u, 1.5*u, stroke=1, fill=1)
    canvas.setFillColor(white)
    canvas.rect(25*u,u,1.2*u,8*u, fill=1,stroke=0)
    canvas.rect(27.5*u,u,1.2*u,8*u, fill=1, stroke=0)
    canvas.setFont("Times-Roman", 3*u)
    canvas.drawCentredString(18*u, 4*u, text)
    # now draw the tip
    penciltip(canvas,debug=0)
    # draw broken lines across the body.
    canvas.setDash([10,5,16,10],0)
    canvas.line(11*u,2.5*u,22*u,2.5*u)
    canvas.line(22*u,7.5*u,12*u,7.5*u)
</t>
<t tx="ekr.20051104081502.541">def penciltip(canvas, debug=1):
    from reportlab.lib.colors import tan, black, green
    from reportlab.lib.units import inch
    u = inch/10.0
    canvas.setLineWidth(4)
    if debug:
        canvas.scale(2.8,2.8) # make it big
        canvas.setLineWidth(1) # small lines
    canvas.setStrokeColor(black)
    canvas.setFillColor(tan)
    p = canvas.beginPath()
    p.moveTo(10*u,0)
    p.lineTo(0,5*u)
    p.lineTo(10*u,10*u)
    p.curveTo(11.5*u,10*u, 11.5*u,7.5*u, 10*u,7.5*u)
    p.curveTo(12*u,7.5*u, 11*u,2.5*u, 9.7*u,2.5*u)
    p.curveTo(10.5*u,2.5*u, 11*u,0, 10*u,0)
    canvas.drawPath(p, stroke=1, fill=1)
    canvas.setFillColor(black)
    p = canvas.beginPath()
    p.moveTo(0,5*u)
    p.lineTo(4*u,3*u)
    p.lineTo(5*u,4.5*u)
    p.lineTo(3*u,6.5*u)
    canvas.drawPath(p, stroke=1, fill=1)
    if debug:
        canvas.setStrokeColor(green) # put in a frame of reference
        canvas.grid([0,5*u,10*u,15*u], [0,5*u,10*u])</t>
<t tx="ekr.20051104081502.542"></t>
<t tx="ekr.20051104081502.543">part 1, line 1
part 2, line 2, no newline
</t>
<t tx="ekr.20051104081502.544">part 2, line 1, no newline
</t>
<t tx="ekr.20051104081502.545">part 3, line 1
part 3, line 2, newline
</t>
<t tx="ekr.20051104081502.546"># g.app.config.updateSettings(c)
g.es('test_setting',c.config.getBool('test_setting'))</t>
<t tx="ekr.20051104081502.547"># This problem has been around forever.
g.pr('-' * 40)
# Yes. We *do* want to warn in c.config.exists.
g.pr('exists',g.app.config.exists(c,'showMinibuffer','bool'))
val = c.config.getBool('showMinibuffer')
g.pr('bool:showMinibuffer',val)
val = c.config.getShortcut('showMinibuffer')
g.pr('shortcut:showMinibuffer',val)</t>
<t tx="ekr.20051104081502.548">c.frame.log.selectTab('Test')
g.es('Test',color='red',tabName='Test')</t>
<t tx="ekr.20051104081502.549">c.frame.log.selectTab('Log')
g.es('Test',color='blue')</t>
<t tx="ekr.20051104081502.551">k = c.keyHandler

def f (event):
    g.es_print('Hello',color='purple')
    
def f2 (event):
    g.es_print('Hello2',color='purple')

k.registerCommand('print-hello','Alt-Ctrl-Shift-p',f)
k.registerCommand('print-hello2',None,f2)</t>
<t tx="ekr.20051104081502.552">g.es('my-command',color='red')</t>
<t tx="ekr.20051104081502.553">g.pr('This is my command 3')</t>
<t tx="ekr.20051104081502.554">g.es('hi',color='red')</t>
<t tx="ekr.20051104081502.555">g.pr('Rebound control E')</t>
<t tx="ekr.20051104081502.556">@language python
@tabwidth -4

---*---*---*
ab</t>
<t tx="ekr.20051104081502.6"></t>
<t tx="ekr.20051104081502.7"></t>
<t tx="ekr.20051104081502.8"></t>
<t tx="ekr.20051104081502.9"></t>
<t tx="ekr.20051104081502.99"></t>
<t tx="ekr.20051107115231"># These are mysteriously fragile tests, so they go first
</t>
<t tx="ekr.20051107115231.1"># This is used by a unit test.
g.es_print('Test of @command')
g.app.unitTestDict ['unit-test-command1'] = True</t>
<t tx="ekr.20051107115231.13"></t>
<t tx="ekr.20051107115231.14">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)

h = '@test return ends editing of headline'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
guiName = g.app.gui.guiName()
wName = g.app.gui.widget_name(w)
assert wName.startswith('head'),'w.name:%s' % wName
w.event_generate('&lt;Return&gt;')
c.outerUpdate()
assert w != c.get_focus(),'oops2: focus in headline'</t>
<t tx="ekr.20051107115231.15">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = '@test editLabel selects entire headline'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
assert w
s = w.getAllText()
selectAll = c.config.getBool('select_all_text_when_editing_headlines')
# g.trace('editLabel selects entire headline',selectAll)
i,j = w.getSelectionRange()
if selectAll:
    assert i == 0 and j == len(s),'oops1: i: %d, j: %d' % (i,j)
else:
    assert i == len(s) and j == len(s),'oops2: i: %d, j: %d' % (i,j)
</t>
<t tx="ekr.20051107115231.16">trace = False ; verbose = False
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
if trace: print('='*20)
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
g.app.gui.set_focus(c,w)
w2 = g.app.gui.get_focus(c)
if trace: print('focus 1',w2)
if trace: print('*** w ***',w)
if 0: # The tkGui.set_focus now does an update to force the focus.
    w2 = g.app.gui.get_focus(c)
    if w != w2:
        print('*** FAIL ***\nw: %s\nw2: %s' % (w,w2))
    assert w == w2 or hasattr(w,'widget') and w.widget == w2,'w: %s\nw2: %s' % (w,w2)
    if trace: print('focus',w2)
# For the qt gui w is a wrapper and w.widget is the actual widget.

try:
    assert w
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    if trace: print('focus 1',w2)
    w.setSelectionRange('end','end')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    if 0: # Easiest.
        c.endEditing()
    else: # More thorough test.
        w.event_generate('&lt;Return&gt;')
        w.update()
    if 1:
        assert p.h == h + paste,'Expected: %s, got %s' % (
            h + paste,p.h)
finally:
    if trace: print('-'*20)
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)</t>
<t tx="ekr.20051107115231.17">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.k

if k.defaultUnboundKeyAction == 'insert':
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = u.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redrawAndEdit(p) # To make the node visible.
    w = c.edit_widget(p)
    # print('guiName',g.app.gui.guiName())
    try:
        assert w, 'oops1'
        wName = g.app.gui.widget_name(w)
        assert wName.startswith('head'),'w.name:%s' % wName
        w.setSelectionRange('end','end')
        w.event_generate('X')
        w.event_generate('Y')
        w.event_generate('Z')
        w.event_generate('&lt;Return&gt;')
        assert p.h == h + 'XYZ',(
            'oops2: expected: %s, got: %s' % (
                h + 'XYZ',p.h))
        if g.app.gui.guiName() != 'nullGui':
            assert c.undoer.undoMenuLabel == 'Undo Typing','oops3: %s' % (
                c.undoer.undoMenuLabel)
        k.manufactureKeyPressForCommandName(w,'undo')
        if g.app.gui.guiName() != 'nullGui':
            assert c.undoer.redoMenuLabel == 'Redo Typing','oops4'
        assert p.h == h,'oops5 got: %s, expected: %s' % (
            p.h,h)
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)</t>
<t tx="ekr.20051107115231.18">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    w.event_generate('&lt;Return&gt;')
    assert p.h == h + paste,'oops2 got: %s' % p.h
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'oops3 got: %s' % p.h
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)</t>
<t tx="ekr.20051107115231.20">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w, 'Null w'
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('1.1','1.2')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    w.event_generate('&lt;Return&gt;')
    assert p.h == h[0] + paste + h[2:]
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h, 'head mismatch'
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)</t>
<t tx="ekr.20051107115231.21">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.k

if k.defaultUnboundKeyAction == 'insert':
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = u.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w
        w.setSelectionRange('end','end')
        w.event_generate('X')
        w.event_generate('Y')
        w.event_generate('Z')
        w.event_generate('&lt;Return&gt;')
        assert p.h == h + 'XYZ'
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)</t>
<t tx="ekr.20051107115231.24"># Should be a comment# Should be a comment# Should be a comment# Should be a comment
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.bodyWantsFocusNow()
paste = '# Should be a comment'
g.app.gui.replaceClipboardWith(paste)
c.outerUpdate()
n = c.frame.body.colorizer.count
if 1:
    event = g.Bunch(widget=c.frame.body.bodyCtrl)
    c.frame.pasteText(event)
else:
    menu = c.frame.menu.getMenu('Edit')
    i = menu.index('Paste')
    menu.invoke(i)
# Move around and and make sure it doesn't change.
try:
    # There is no colorizer to test for wx.
    if g.app.gui.guiName() == 'tkinter':
        c.outerUpdate() # Force the coloring before doing the test.
        assert c.frame.body.colorizer.count &gt; n, 'did not recolor text'
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)</t>
<t tx="ekr.20051107115231.25">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    # assert w == w2 or hasattr(w,'widget') and w.widget == w2,'w: %s\nw2: %s' % (w,w2)
    w.setSelectionRange('end','end')
    n = w.getWidth()
    w.event_generate('X')
    w.event_generate('Y')
    w.event_generate('Z')
    w.update()
    if 1: # Easiest.
        c.endEditing()
    else: # More thorough test.
        w.event_generate('&lt;Return&gt;')
        w.update()
    assert w, 'fail 2'
    n2 = w.getWidth()
    if g.app.gui.guiName() == 'tkinter':
        assert n2 &gt; n, '%s %s' % (n2,n)
    # g.trace(n,n2)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)</t>
<t tx="ekr.20051107115231.28">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    c.selectPosition(p.visBack(c))
    assert p.h == h + paste
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'expected: %s, got: %s' % (
        h,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)</t>
<t tx="ekr.20051107115231.29">import leo.core.leoEditCommands as leoEditCommands
s = 'foo' ; bodyCtrl = c.frame.body.bodyCtrl

c.searchCommands.openFindTab()
h = c.searchCommands.findTabHandler
w = h.find_ctrl
w.setAllText(s)
c.bodyWantsFocus()
bodyCtrl.setInsertPoint(0)
c.searchCommands.findTabFindNext()
w = c.get_focus()
wName = g.app.gui.widget_name(w)

# in wxPython w != bodyCtrl (it's a proxy)
assert 'body' in wName, 'focus: %s = %s, expected %s = %s' % (
    w,wName,bodyCtrl,g.app.gui.widget_name(bodyCtrl))</t>
<t tx="ekr.20051107115231.9">c.redraw(p) # To make node visible

c2 = c.new()
p2 = c2.p

try:
    # This fails, but it is possible to edit the headline.
    # assert c2.edit_widget(p2),'c2.edit_widget(p2) failed: %s' % repr(p2)
    assert p2,'p2 failed: %s' % repr(p2)
    # assert c.edit_widget(p),'c.edit_widget(p) failed: %s' % repr(p)
finally:
    c2.setChanged(False)
    c2.close()</t>
<t tx="ekr.20051109091333"># Not ready yet: generating a backspace seems impossible!

import leo.core.leoTest as leoTest
u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.setBodyString(p,'a')
c.redraw_now() # To make node visible and to set the icon.
try:
    c.bodyWantsFocusNow()
    n = c.frame.tree.redrawCount
    w = c.frame.body.bodyCtrl
    w.setInsertPoint('end')
    w.event_generate('&lt;BackSpace&gt;')
    n2 = c.frame.tree.redrawCount
    assert n2 == n + 1,'too many or too few redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw_now()</t>
<t tx="ekr.20051109091731">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)

h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.setBodyString(p,'a')
c.redraw(p) # To make node visible
# print('after redraw_now')
c.bodyWantsFocusNow()
n = c.frame.tree.redrawCount
try:
    c.frame.body.bodyCtrl.event_generate('a')
    n2 = c.frame.tree.redrawCount
    assert n2 == n,'too many redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)</t>
<t tx="ekr.20051109143831"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractAllHeadlines()
g.app.unitTestDict['restoreSelectedNode']=False

    </t>
<t tx="ekr.20051120110335">u = c.undoer
c.insertHeadline()
assert u.undoMenuLabel == 'Undo Insert Node',repr(c.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node',repr(u.undoMenuLabel)</t>
<t tx="ekr.20051120115046">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
body = 'This is a test'
c.setBodyString(p,body)

try:
    assert p.b == body
    c.insertHeadline()
    c.undoer.undo()
    assert p.b == body
finally:
    c.setBodyString(p,'')</t>
<t tx="ekr.20051122095426"></t>
<t tx="ekr.20051125155134">n = c.frame.tree.redrawCount
# print('before')
c.insertHeadline()
c.outerUpdate() # Not actually needed, but should not matter.
# print('after')

try:
    n2 = c.frame.tree.redrawCount
    assert n2 == n + 1,'redraws: %d' % (n2 - n)
finally:
    c.undoer.undo()</t>
<t tx="ekr.20051125170139">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    w.setSelectionRange('end','end')
    # w.event_generate('X')
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)</t>
<t tx="ekr.20051216171321"></t>
<t tx="ekr.20060106211922">n = g.app.positions
assert c.isCurrentPosition(None) is False
assert c.isCurrentPosition(p) is True
assert g.app.positions == n</t>
<t tx="ekr.20060106211922.1">n = g.app.positions
assert c.isRootPosition(None) is False
assert c.isRootPosition(p) is False
assert g.app.positions == n</t>
<t tx="ekr.20060127120604"></t>
<t tx="ekr.20060130151716.1">table = (
    # 'toggle-find-clone-find-all-option',
    'toggle-find-ignore-case-option',
    'toggle-find-in-body-option',
    'toggle-find-in-headline-option',
    'toggle-find-mark-changes-option',
    'toggle-find-mark-finds-option',
    'toggle-find-regex-option',
    'toggle-find-reverse-option',
    'toggle-find-word-option',
    'toggle-find-wrap-around-option',
)

for command in table:
    c.k.simulateCommand(command)
    c.k.simulateCommand(command)
    </t>
<t tx="ekr.20060130151716.2">table = (
    'set-find-everywhere',
    'set-find-node-only',
    'set-find-suboutline-only',
)

# show-find-tab-options     = Ctrl-o
# show-find-options         = o

for command in table:
    c.k.simulateCommand(command)
</t>
<t tx="ekr.20060130151716.3">table = (
    're-search-forward',
    're-search-backward',
    'search-forward',
    'search-backward',
    'word-search-forward',
    'word-search-backward',
)

for command in table:
    # This is not a full test.  We must use keyboardQuit here!
    c.k.simulateCommand(command)
    c.k.keyboardQuit(None)</t>
<t tx="ekr.20060130151716.4">c.k.simulateCommand('show-find-options')</t>
<t tx="ekr.20060131102450">print('\nEnd of typing and undo tests')</t>
<t tx="ekr.20060208072307">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)

if c.k.defaultUnboundKeyAction == 'insert':
    h = 'Test headline abc'
    p = u.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p)
    c.bodyWantsFocusNow()
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    if 1: # New code calls pasteText directly.
        event = g.Bunch(widget=c.frame.body.bodyCtrl)
        c.frame.pasteText(event)
    else: # old code uses menu.invoke.
        # Post by hand.
        menu = c.frame.menu.getMenu('Edit')
        i = menu.index('Paste')
        menu.invoke(i)
    # Move around and and make sure it doesn't change.
    try:
        assert p.b == paste, 'paste1 failed'
        c.selectPosition(p.threadBack())
        assert p.b == paste, 'stick failed'
        c.selectPosition(p)
        assert p.b == paste, 'revisit failed'
    finally:
        if 1:
            c.setBodyString(p,'')
            c.redraw(p)
</t>
<t tx="ekr.20060208072331">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
w.setSelectionRange('end','end',insert='end')
paste = 'ABC'
g.app.gui.replaceClipboardWith(paste)
if 1: # New code calls pasteText directly.
    event = g.Bunch(widget=w)
    c.frame.pasteText(event)
else:
    menu = c.frame.menu.getMenu('Edit')
    i = menu.index('Paste')
    menu.invoke(i)
# Move around and and make sure it doesn't change.
try:
    # g.trace('before select',w,w.getAllText())
    c.selectPosition(p.threadBack())
    assert p.h == h + paste,'oops1: expected: %s, got %s' % (h + paste,p.h)
    c.selectPosition(p)
    assert p.h == h + paste,'oops2: expected: %s, got %s' % (h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)</t>
<t tx="ekr.20060208072358"># This test is too flaky for Tk.
if g.app.gui.guiName() != 'tkinter':

    import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
    
    h = 'Test headline abc'
    p = u.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.selectPosition(p)
    c.bodyWantsFocusNow()
    c.redraw(p) # To make node visible
    n = c.frame.tree.redrawCount
    assert not p.b, 'oops1'
    try:
        # print('before insert a',c.p)
        assert p == c.p,'position has changed!'
        c.frame.body.bodyCtrl.event_generate('a')
        assert p.b == 'a', 'expected "a", got: %s' % repr(p.b)
        if g.app.gui.guiName() != 'nullGui':
            n2 = c.frame.tree.redrawCount
            c.outerUpdate() # Force the coloring before doing the test.
            assert n2 == n + 1,'too many or too few redraws: expected 1: got: %d' % (n2-n)
    finally:
        if 1:
            c.setBodyString(p,'')
            c.redraw(p)</t>
<t tx="ekr.20060208072415">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
s = 'ABC'
c.setBodyString(p,s)
try:
    c.bodyWantsFocusNow()
    w = c.frame.body.bodyCtrl
    w.setInsertPoint(2)
    c.outerUpdate() # This fixed the problem.
    w.event_generate('&lt;Delete&gt;') # Calls c.outerUpdate()
    assert p.b == s[:-1],'oops1: expected "AB", got %s' % p.b
    c.selectPosition(p.threadBack())
    c.selectPosition(p)
    assert p.b == s[:-1],'oops2: expected "AB", got %s' % p.b
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)</t>
<t tx="ekr.20060208195054"># c.commandsDict: keys are emacs command names, values are functions f.
# k.inverseCommandsDict: keys are f.__name__, values are emacs command names.

@others

d1 = c.commandsDict ; d2 = c.k.inverseCommandsDict

if 0:
    vals = d2.values() ; vals.sort()
    vals = [z for z in vals if z.startswith('contract')]
    g.pr('inverseCommandsDict.values()',vals)

keys1 = d1.keys() ; keys1.sort()
vals1 = d1.values()
vals1 = [f.__name__ for f in vals1]
vals1.sort()

keys2 = d2.keys() ; keys2.sort()
vals2 = d2.values(); vals2.sort()

if 0:
    g.pr(keys1,'\n\n')
    g.pr(vals2,'\n\n')
    g.pr(keys2,'\n\n')
    g.pr(vals1)
    
# g.trace(g.dictToString(c.k.abbreviationsDict))

abbrevDict = c.config.getAbbrevDict()

# Find @button and @command nodes in this file.
@others
buttonKeys = []
for p in c.allNodes_iter():
    h = p.h.strip().lower()
    for kind in ('@button','@command'):
        if h.startswith(kind):
            key1 = mungeKey(h,kind,substitute=False)
            if key1 not in buttonKeys:
                buttonKeys.append(key1)
            key = mungeKey(h,kind,substitute=True)
            if key not in buttonKeys:
                buttonKeys.append(key)
                
for z in g.app.config.atCommonButtonsList:
    h,junk = z
    key = mungeKey(h,'@button')
    # g.trace(key)
    if key not in buttonKeys:
        buttonKeys.append(key)
        
# g.pr('buttonKeys',buttonKeys)

for key in keys1:
    if key not in vals2 and key.lower() not in vals2:
        if (
            key.startswith('enter-') and key.endswith('-mode') or
            key.startswith('press-') and key.endswith('-button') or
            key.startswith('delete-') and key.endswith('-button') or
            key.startswith('nav-') and key.endswith('-menu')
        ):
            vals2.append(key)
        elif key in buttonKeys or key.lower() in buttonKeys:
            # List of buttons defined in this file, or in @settings tree.
            vals2.append(key)
        elif key.startswith('open-with-'):
            vals2.append(key)
        elif key in abbrevDict.keys():
            pass # g.trace('abbrev',key)
        else:
            assert False, '%s not in inverseCommandsDict.values()' % key

vals2.sort()
for val in vals2:
    if val not in keys1:
        assert False, '%s not in commandsDict.keys()' % (val)</t>
<t tx="ekr.20060325071703.1">import sys

win32  = c.config.getBool('test_win32_setting')
darwin = c.config.getBool('test_darwin_setting')

if sys.platform == 'win32':
    assert(win32)
    assert(not darwin)

elif sys.platform== 'darwin':
    assert(win32)
    assert(not darwin)
    </t>
<t tx="ekr.20060325071703.2">guiname = g.app.gui.guiName()

tkinter = c.config.getBool('test_tkinter_setting')
wx      = c.config.getBool('test_wxWindows_setting')

print(guiname)

if guiname == 'tkinter':
    assert(tkinter)
    assert(not wx)
    
if guiname == 'wxWindows':
    assert(not tkinter)
    assert(wx)</t>
<t tx="ekr.20060325072919"></t>
<t tx="ekr.20060325072919.1"></t>
<t tx="ekr.20060325072919.2"></t>
<t tx="ekr.20060325072919.3"></t>
<t tx="ekr.20060602195313">at = c.atFileCommands
child = p.firstChild()
child2 = child.next()
result = str(child2.b)
at.write(child,nosentinels=False,thinFile=False,scriptWrite=False,toString=True)
s = str(at.stringOutput)

if s != result:
    print('-' * 30)
    print(s)
    print('-' * 30)
    print(result)
    
assert s == result</t>
<t tx="ekr.20060602195313.2">@language c
#ifdef COMMENT
@comment /* */ 
#endif
@tabwidth 4
@lineending crlf

@others

&lt;&lt; Get LRR Task &gt;&gt;
&lt;&lt; Start LRR &gt;&gt;</t>
<t tx="ekr.20060602195313.3"></t>
<t tx="ekr.20060602195313.4"></t>
<t tx="ekr.20060602195914">/*@+leo-ver=5*/
/*@+node:root*/
/*@@language c*/
#ifdef COMMENT
/*@@comment /* */ */
#endif
/*@@tabwidth 4*/
/*@@lineending crlf*/

/*@+others*/
/*@-others*/

/*@+&lt;&lt; Get LRR Task &gt;&gt;*/
/*@+node:&lt;&lt; Get LRR Task &gt;&gt;*/
/*@-&lt;&lt; Get LRR Task &gt;&gt;*/
/*@+&lt;&lt; Start LRR &gt;&gt;*/
/*@+node:&lt;&lt; Start LRR &gt;&gt;*/
/*@-&lt;&lt; Start LRR &gt;&gt;*/
/*@-leo*/
</t>
<t tx="ekr.20060912091510.1">import time

c.frame.body.addEditor()

time.sleep(0.5)

c.frame.body.deleteEditor()

time.sleep(0.5)
</t>
<t tx="ekr.20060913084600">import leo.core.leoNodes as leoNodes

if leoNodes.use_zodb:
    p.v.__hash__()</t>
<t tx="ekr.20060921115303"># for condition in ('&lt;','&lt;=','&gt;','&gt;='):

for v1,condition,v2 in (
    ('8.4.12','&gt;','8.4.3'),
    ('1','==','1.0'),
    ('2','&gt;','1'),
    ('1.2','&gt;','1'),
    ('2','&gt;','1.2.3'),
    ('1.2.3','&lt;','2'),
    ('1','&lt;','1.1'),
):
    assert g.CheckVersion(v1,v2,condition=condition,trace=False)</t>
<t tx="ekr.20061001114236" unit_test="58040000006162636471002e">fc = c.fileCommands # self is a dummy
p.v.unknownAttributes = {g.u('unit_test'):g.u('abcd')}
s = fc.putUnknownAttributes (p.v)
expected = g.u(' unit_test="58040000006162636471002e"')
assert s == expected, '\nexpected: %s\ngot:      %s' % (repr(expected),repr(s))
</t>
<t tx="ekr.20061001114637"># 3 failures with Alt-5</t>
<t tx="ekr.20061001124008"># New in Leo 4.7 b2: Leo never sets the tnodeList of any node.
fc = c.fileCommands
v = p.v
child = p.firstChild()
assert child,'no child'
grandChild = child.firstChild()
assert grandChild,'no grandChild'
assert not v.tnodeList,repr(v.tnodeList)
   
try:
    v.tnodeList = [v,child.v,grandChild.v]
    s = fc.putTnodeList(p.v)
    expected = ' tnodeList="ekr.20061001124008,ekr.20061001124008.1,ekr.20061001124008.2"'
    assert s == expected, 'expected: %s, got: %s' % (repr(expected),repr(s))
finally:
    v.tnodeList = []</t>
<t tx="ekr.20061001124008.1"></t>
<t tx="ekr.20061001124008.2"></t>
<t tx="ekr.20061008162912">assert p.firstChild(), 'no child node'
assert p.firstChild().b.startswith('@ignore'), 'No @ignore in child'
ok = c.fileCommands.write_Leo_file(
    'file-name',outlineOnlyFlag=True,toString=True,toOPML=False)
assert ok, 'error writing file'
count = 0
for line in g.splitLines(g.app.write_Leo_file_string):
    if line.find('@ignore') != -1:
        count += 1
assert count &gt;=3, "not enough @ignore's in written file"
</t>
<t tx="ekr.20061008162912.1">@ignore # Test that this node gets written.</t>
<t tx="ekr.20061014152506"></t>
<t tx="ekr.20061014152506.1"># Do not delete this button.  It is needed for unit tests.

# Careful: the command gets truncated as well as the button text.
</t>
<t tx="ekr.20061014152506.2"># Only the button text gets truncated.

assert c.commandsDict.get('test-at-button-node'), 'no test-at-button-node command'
assert c.commandsDict.get('delete-test-at-button-node-button'), 'no delete-test-at-button-node-button command'

# g.pr(c.commandsDict.get('test-at-button'))
</t>
<t tx="ekr.20061101121602.100">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.101">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.102">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.103">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.104">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.105">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.106">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.107">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.108">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.109">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.110">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.111">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.112">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.113">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.114">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.115">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.116">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.117">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.118">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.119">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.120">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.121">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.122">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.123">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.124">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.125">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.126">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.127">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.128">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.129">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.130">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.131">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.132">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.133">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.134">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.135">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.136">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.137">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.138">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.139">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.140">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.141">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.142">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.143">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.144">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.145">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.146">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.147">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.148">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.149">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.150">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.151">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.152">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.153">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.154">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.155">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20061101121602.156">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20061101121602.157">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20061101121602.158">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.159">first line
line    line b
line c
last line
</t>
<t tx="ekr.20061101121602.160">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.161">first line
line    line b
line c
last line
</t>
<t tx="ekr.20061101121602.162">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.163">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.164">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.165">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.166">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.167">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.168">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.169">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.170">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.171">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.172">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.173">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.174">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20061101121602.175">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.176">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.177">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.178">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
assert g.app.unitTestDict.get('colorized')</t>
<t tx="ekr.20061101121602.179">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.180">XYZZY line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.181">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.182">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.183">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.184">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.185">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.186">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.187">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.188">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.189">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.190">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.191">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.192">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.193">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.194">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.195">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.196">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.197">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.198">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.199">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.200">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.201">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.202">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.203">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.204">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.205">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.206">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.207">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.208">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.209">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.210">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.211">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.212">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.213">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.214">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.215">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.216">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.217">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.218">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.219">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.220">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.221">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.222">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.223">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.224">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.225">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.226">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.227">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.228">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.229">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.230">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.231">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.232">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.233">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.234">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.235">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.236">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.237">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.238">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.239">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.240">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.241">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.242">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.243">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.244">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.245">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.246">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.247">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.248">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.249">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.250">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.251">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.252">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.253">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.254">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.255">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.256">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.257">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.258">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.259">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.260">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.261">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.262">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.263">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.264">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.265">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20061101121602.266">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.267">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20061101121602.268">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.269">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20061101121602.270">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.271">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20061101121602.272">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.273">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20061101121602.274">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.275">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.276">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.277">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.278">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.279">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.280">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.281">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.282">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.283">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.284">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.285">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.286">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.287">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20061101121602.288">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.289">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20061101121602.290">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
</t>
<t tx="ekr.20061101121602.291">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.292">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.293">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.294">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.295">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.296">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.297">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.298">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.299">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.300">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.301">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.302">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.303">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.304">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.305">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.306">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.307">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.308">first line

line 1
    line a
        line b
        
line c
last line
</t>
<t tx="ekr.20061101121602.309">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.310">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.311">first line

line 1
   line a
       line b
       
line c
last line
</t>
<t tx="ekr.20061101121602.312">first line

line 1
    line a
        line b
        
line c
last line
</t>
<t tx="ekr.20061101121602.313">first line

line 1
   line a
       line b
       
line c
last line
</t>
<t tx="ekr.20061101121602.314">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.315">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20061101121602.316">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.317">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20061101121602.318">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.319">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20061101121602.320">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.321">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20061101121602.322">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.323">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20061101121602.324">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.325">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20061101121602.326">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.327">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20061101121602.328">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.329">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20061101121602.330">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.331">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.332">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.333">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.334">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.335">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20061101121602.336">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.337">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20061101121602.338">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.339">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.340">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.341">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.342">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.343">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.344">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.345">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.346">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.347">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.348">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20061101121602.349">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.350">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
assert g.app.unitTestDict.get('colorized')</t>
<t tx="ekr.20061101121602.351">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.352">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.353">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.354">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
assert g.app.unitTestDict.get('colorized')</t>
<t tx="ekr.20061101121602.355">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.356">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.357">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.78">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.79">first line
 line 1
     line a
 line b
last line</t>
<t tx="ekr.20061101121602.80">first line
line 1
    line a
line b
last line</t>
<t tx="ekr.20061101121602.81">first line
 line 1
     line a
 line b
last line</t>
<t tx="ekr.20061101121602.82">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.83">first line
    line 1
        line a
            line b
    line c
last line</t>
<t tx="ekr.20061101121602.84">first line
line 1
    line a
        line b
line c
last line</t>
<t tx="ekr.20061101121602.85">first line
    line 1
        line a
            line b
    line c
last line</t>
<t tx="ekr.20061101121602.86">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.87">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.88">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.89">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.90">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.91">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.92">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.93">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.94">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.95">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.96">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.97">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061101121602.98">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061101121602.99">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20061104172236.1"></t>
<t tx="ekr.20061104172236.11">s = 'abc xy_z5 pdq'
i,j = g.getWord(s,5)
assert s[i:j] == 'xy_z5','got %s' % s[i:j]
</t>
<t tx="ekr.20061104172236.15">s = 'a\n\nc'

for i,result in (
    (-1,2), # One too few.
    (0,2),(1,2),
    (2,3),
    (3,4),
    (4,4), # One too many.
):
    j = g.skip_line(s,i)
    assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)</t>
<t tx="ekr.20061104172236.16">s = 'a\n\nc'

for i,result in (
    (-1,1), # One too few.
    (0,1),(1,1),
    (2,2),
    (3,4),
    (4,4), # One too many.
):
    j = g.skip_to_end_of_line(s,i)
    assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)</t>
<t tx="ekr.20061104172236.17">s1 = 'a\n\nc'
table1 = (
    (-1,0), # One too few.
    (0,0),(1,0),
    (2,2),
    (3,3),
    (4,4), # One too many.
)
s2 = 'a\n'
table2 = ((1,0),(2,2)) # A special case at end.

for s,table in ((s1,table1),(s2,table2)):
    for i,result in table:
        j = g.skip_to_start_of_line(s,i)
        assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)
</t>
<t tx="ekr.20061104172236.18">s = 'a\ncd\n\ne'

for i,result in (
    (-1,(0,2)), # One too few.
    (0,(0,2)),(1,(0,2)),
    (2,(2,5)),(3,(2,5)),(4,(2,5)),
    (5,(5,6)),
    (6,(6,7)),
    (7,(6,7)), # One too many.
):
    j,k = g.getLine(s,i)
    assert (j,k) == result, 'i: %d, expected %d,%d, got %d,%d' % (i,result[0],result[1],j,k)</t>
<t tx="ekr.20061104172236.2"># targetWord

e = c.editCommands
k = c.k ; w = c.frame.body.bodyCtrl
w.setInsertPoint(0)
k.arg = 't' # 'targetWord'
k.setState('find-word',1)
for val in (True,False):
    e.oneLineFlag = val
    f = e.findWordInLine(event=None)
    i,j = w.getSelectionRange()
    assert i == 2, 'expected 2, got' % (i)
    # s = w.getAllText()
    # ch = s[i]
    # assert word == 'targetWord', 'got: %s' % word

</t>
<t tx="ekr.20061104172236.22"># target.

try:
    w = c.frame.body.bodyCtrl
    s = w.getAllText()
    w.setInsertPoint(len(s))
    c.k.previousSelection = 2,8
    event = g.Bunch(widget=w)
    c.frame.pasteText(event=event,middleButton=True)
    s2 = w.getAllText()
    assert len(s2) == len(s) + len('target')
finally:
    w.setAllText(s)
    p.setBodyString(s)
    # g.trace(repr(s))
    c.recolor()

# end</t>
<t tx="ekr.20061104172236.23">w = c.frame.body.bodyCtrl
y = 10
for x in range(0,100,10):
    event = g.Bunch(c=c,x=x,y=y,widget=w)
    c.frame.body.onClick(event)
</t>
<t tx="ekr.20061104172236.3"># TARGETWORD

w = c.frame.body.bodyCtrl

for (which,result) in (('cap','Targetword'),('low','targetword'),('up','TARGETWORD')):
    w.setInsertPoint(5)
    c.editCommands.capitalizeHelper(event=None,which=which,undoType=None)
    s = w.getAllText()
    word = s[2:12]
    assert word == result, 'Expected %s, got: %s' % (result,repr(word))
    i = w.getInsertPoint()
    assert i == 5, 'Expected 5, got: %d' % i
</t>
<t tx="ekr.20061104172236.4">w = c.frame.body.bodyCtrl
ec = c.editCommands

for spot,result in (('1.0',0),(5,5)):
    ec.setMoveCol(w,spot)
    assert ec.moveSpot == result
    assert ec.moveCol == result
</t>
<t tx="ekr.20061104172236.5">ec = c.editCommands ; w = c.frame.body.bodyCtrl

for i,j,python in (
    # ('1.0','4.5',False),
    (5,50,True),
):
    extend = True
    ec.moveSpot = None # It's hard to init this properly.
    ec.extendHelper(w,extend,j)
    i2,j2 = w.getSelectionRange()
    # print(i2,j2)
    #assert 0==i2, 'Expected i=%s, got %s' % (repr(i),repr(i2))
    #assert j==j2, 'Expected j=%s, got %s' % (repr(j),repr(j2))
</t>
<t tx="ekr.20061104172236.6">ec = c.editCommands ; w = c.frame.body.bodyCtrl

for i,j,python in (
    #('1.0','4.5',False),
    (5,50,True),
):
    event = None ; extend = True ; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveToHelper (event,j,extend)
    i2,j2 = w.getSelectionRange()
    assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
    assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
    w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20061104172236.7">ec = c.editCommands

for direction in ('up','down'):
    for distance in ('line','page','half-page'):
        event = g.Bunch(widget=c.frame.body.bodyCtrl)
        ec.scrollHelper(event,direction,distance)
</t>
<t tx="ekr.20061106112522">w = c.frame.body.bodyCtrl
s = w.getAllText()

try:
    w.setInsertPoint(len(s))
    c.insertBodyTime()
finally:
    w.setAllText(s)
    p.setBodyString(s)
    # c.recolor()

# end:</t>
<t tx="ekr.20061106201509.6"># line 1
# line 2
# line 3

w = c.frame.body.bodyCtrl
index = 11 # in the second line.
w.setInsertPoint(index)
before,ins,after = c.frame.body.getInsertLines()
assert before == '# line 1\n','Got %s' % repr(before)
assert ins    == '# line 2\n','Got %s' % repr(ins)
assert after.startswith('# line 3\n')
assert after.endswith('# end.')

# end.</t>
<t tx="ekr.20061106201509.7"># line 1
# line 2
# line 3

w = c.frame.body.bodyCtrl
s = w.getAllText()
start,end = 11,15
w.setSelectionRange(start,end)
before,ins,after = c.frame.body.getSelectionAreas()
assert before == s[0:start],'Got %s' % repr(before)
assert ins    == s[start:end],'Got %s' % repr(ins)
assert after == s[end:]

# end.</t>
<t tx="ekr.20061110094226">ec = c.editCommands ; w = c.frame.body.bodyCtrl

for i,result,direction in (('5.8','4.8','up'),('5.8','6.8','down')):
    event = None ; extend = False; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveUpOrDownHelper (event,direction,extend)
    i2,j2 = w.getSelectionRange()
    if 1:
        break
    else:
        assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
        assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
        w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20061128082002">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061128082002.1">first line
line 1
    line a
        line b
line c
last line</t>
<t tx="ekr.20061128082002.2">first line
line 1
    line a
        line b
line c
last line</t>
<t tx="ekr.20061128082002.3">first line
line 1
    line a
        line b
line c
last line</t>
<t tx="ekr.20061128090021">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061128090021.1">line 1
line 2

line 4</t>
<t tx="ekr.20061128090021.2">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20061128090021.3">line 1
line 2

line 4</t>
<t tx="ekr.20061128090147">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061128090147.1">line 1
line 2
line 4</t>
<t tx="ekr.20061128090147.2">line 1
line 2

line 4</t>
<t tx="ekr.20061128090147.3">line 1
line 2
line 4</t>
<t tx="ekr.20061128090338">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061128090338.1">line 1
line 2
</t>
<t tx="ekr.20061128090338.2">line 1
line 2
line 3</t>
<t tx="ekr.20061128090338.3">line 1
line 2
</t>
<t tx="ekr.20061128090441">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061128090441.1">line 1
line 2</t>
<t tx="ekr.20061128090441.2">line 1
line 2</t>
<t tx="ekr.20061128090441.3">line 1
line 2
</t>
<t tx="ekr.20070113145100"># Not part of cvs distributions, but needed for two unit tests.

dir = g.os_path_join(g.app.loadDir,'..','test','unittest',g.u('chinese\u8116folder'),encoding='utf-8')
s   = g.os_path_join(dir,g.u('chinese\u8116test.leo'),encoding='utf-8')
    
if not g.os_path_exists(dir):
    import os
    os.mkdir(dir)
    g.pr('created chinese folder')
    
if not g.os_path_exists(s):
    f = file(s,'w')
    f.close()
    g.pr('created chinese file')
    
</t>
<t tx="ekr.20070114140212"># Important: many unit tests are now in leoPy.leo.
# All the following should pass when run locally (Alt-4).
# All the following have errors when run externally (Alt-5).
@language python</t>
<t tx="ekr.20070131162935">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070131162935.1">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20070131162935.2">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20070131162935.3">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20070131171218.1"></t>
<t tx="ekr.20070131171218.2">first line
line 1
    line a
        line b
line c
last line</t>
<t tx="ekr.20070131172706">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070131172706.1">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20070131172706.2">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20070131172706.3">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20070131173932">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070131173932.1">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20070131173932.2">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20070131173932.3">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20070131175538"></t>
<t tx="ekr.20070131175538.1"></t>
<t tx="ekr.20070131175646"></t>
<t tx="ekr.20070201065053">w = c.frame.body.bodyCtrl
c.bodyWantsFocusNow()
w.setSelectionRange('3.0','3.07')
# w.setInsertPoint('3.169')</t>
<t tx="ekr.20070217065840">@nocolor
@
To make unit tests, do the following:
    
- Use the make-test script (Alt-5) to create a suboutline for a unit test.
- Put text in the before node, selected desired text, then do the do-before script (Alt-6).
- Execute the command, then do the do-after script (Alt-7).

@color</t>
<t tx="ekr.20070217065840.1">try:
    p1 = p.insertAfter()
    c.setHeadString(p1,'@test ')
    body = 'import leoTest\nleoTest.runEditCommandTest(c,p)'
    c.setBodyString(p1,body)
    for s in ('work','before','after'):
        p2 = p1.insertAsLastChild()
        c.setHeadString(p2,s)
    p1.expand()
finally:
    c.redraw()
    c.editPosition(p1)</t>
<t tx="ekr.20070217065840.10">import leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070217065840.11">line 1

line 3</t>
<t tx="ekr.20070217065840.12">line 1
line 2
line 3</t>
<t tx="ekr.20070217065840.13">line 1

line 3</t>
<t tx="ekr.20070217065840.2">@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. The work node should have body text. If all is as expected,
copy the body text the work node to the before node, and represent the selection
range of the work in the headline of the before node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top and work.b:

    c.setBodyString(before,work.b)
    c.setBodyString(after,'')
    putSelectionInHeadline(c,before,'before',sel)
    c.redraw()
else:
    g.es_print('do-before: not in a proper @test tree')</t>
<t tx="ekr.20070217065840.3">def getSel(c):
    
    w = c.frame.body.bodyCtrl
    i,j= w.getSelectionRange()
    if i == j:
        i = j = w.getInsertPoint()
        sel = (i,i)
    return i,j</t>
<t tx="ekr.20070217065840.4">def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.h.startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild() 
    before = work and work.next()     
    after  = before and before.next()
    if (
        work   and work.h.startswith('work') and
        before and before.h.startswith('before') and
        after  and after.h.startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None</t>
<t tx="ekr.20070217065840.5">def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.h,repr(sel))

    w = c.frame.body.bodyCtrl
    i,j = sel
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    s = '%s sel=%s,%s' % (prefix,i,j)
    c.setHeadString(p,s)
</t>
<t tx="ekr.20070217065840.6">@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. If all is as expected, copy the work node to the after node,
and represent the selection range of the work node in the headline of the after node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top:
    c.setBodyString(after,work.b)
    putSelectionInHeadline(c,after,'after',sel)
    c.redraw()
else:
    g.es_print('do-after: not in @test tree')</t>
<t tx="ekr.20070217065840.8">def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.h.startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild()
    before = work and work.next()
    after  = before and before.next()
    if (
        work   and work.h.startswith('work') and
        before and before.h.startswith('before') and
        after  and after.h.startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None</t>
<t tx="ekr.20070217065840.9">def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.h,repr(sel))
    
    w = c.frame.body.bodyCtrl
    i,j = sel
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    s = '%s sel=%s,%s' % (prefix,i,j)
    c.setHeadString(p,s)
</t>
<t tx="ekr.20070217071121.1">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070217071121.10">before
aaabbb
aaabbb
aaabbb
aaabbb
after</t>
<t tx="ekr.20070217071121.11">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after</t>
<t tx="ekr.20070217071121.12">before
aaabbb
aaabbb
aaabbb
aaabbb
after</t>
<t tx="ekr.20070217071121.13">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070217071121.14">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after</t>
<t tx="ekr.20070217071121.15">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after</t>
<t tx="ekr.20070217071121.16">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after</t>
<t tx="ekr.20070217071121.17">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070217071121.18">before
aaabbb
aaabbb
aaabbb
aaabbb
after</t>
<t tx="ekr.20070217071121.19">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after</t>
<t tx="ekr.20070217071121.2">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after</t>
<t tx="ekr.20070217071121.20">before
aaabbb
aaabbb
aaabbb
aaabbb
after</t>
<t tx="ekr.20070217071121.21">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070217071121.22">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after</t>
<t tx="ekr.20070217071121.23">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after</t>
<t tx="ekr.20070217071121.24">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after</t>
<t tx="ekr.20070217071121.25">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070217071121.26">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after</t>
<t tx="ekr.20070217071121.27">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after</t>
<t tx="ekr.20070217071121.28">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after</t>
<t tx="ekr.20070217071121.3">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after</t>
<t tx="ekr.20070217071121.4">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after</t>
<t tx="ekr.20070217071121.5">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070217071121.6">before
aaabbb
aaabbb
aaabbb
aaabbb
after</t>
<t tx="ekr.20070217071121.7">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after</t>
<t tx="ekr.20070217071121.8">before
aaabbb
aaabbb
aaabbb
aaabbb
after</t>
<t tx="ekr.20070217071121.9">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070217072822">def getSel(c):
    
    w = c.frame.body.bodyCtrl
    i,j= w.getSelectionRange()
    if i == j:
        i = j = w.getInsertPoint()
        sel = (i,i)
    return i,j</t>
<t tx="ekr.20070301064408">print('\nAll plugins tests complete.')</t>
<t tx="ekr.20070303143846.1"># Plugin_manager.py needs plugins_menu.py
# Plugins_manager is not functional at present.
# plugin_manager.py

# qtGui.py
# tkGui.py

plugins_menu.py

# Standard plugins...
open_with.py
leo_to_html.py
mod_scripting.py
UNL.py

# Other plugins...
# vim.py

# Tk plugins.
# cleo.py
# hoist.py
# image.py
# nav_buttons.py
# rClick.py
# threading_colorizer.py
</t>
<t tx="ekr.20070303143951"></t>
<t tx="ekr.20070305095401">p = c.p.copy()
c.selectPosition(p.threadBack())
p1 = c.p
# print(p1)
c.goPrevVisitedNode()
p2 = c.p
# print(p2)
c.goNextVisitedNode()
p3 = c.p
# print(p3)
# assert p == p3
</t>
<t tx="ekr.20070306091949"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
    
print('\nEnd of leoEditCommands tests.')</t>
<t tx="ekr.20070315065720">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070315065720.1">a

b</t>
<t tx="ekr.20070315065720.2">a

b</t>
<t tx="ekr.20070315065720.3">a

b</t>
<t tx="ekr.20070315065849">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20070315065849.1">a

b</t>
<t tx="ekr.20070315065849.2">a

b</t>
<t tx="ekr.20070315065849.3">a

b</t>
<t tx="ekr.20070417092935"></t>
<t tx="ekr.20070417092935.1"></t>
<t tx="ekr.20070503064257"></t>
<t tx="ekr.20070515150433"></t>
<t tx="ekr.20070528100318"># Required to make a typing test work.</t>
<t tx="ekr.20070611071101">p1 = p.copy()
a = p.firstChild()
b = a.firstChild()
c2 = b.firstChild()
limit = a.next()
d = limit.firstChild()
e = limit.next()
assert e.h == 'e'
for p2,h in ((a,'a'),(b,'b'),(c2,'c2'),(d,'d'),(limit,'limit')):
    p2.expand()
    assert p2.h==h,'headString mismatch'

try: # Tests without hoist...
    p1.expand()
    assert not c.hoistStack
    c.selectPosition(limit)
    result = limit.copy().moveToVisBack(c)
    assert result==c2,'visBack != c2: %s' % result
    #
    result = limit.copy().moveToVisNext(c)
    assert result==d,'visNext != d: %s' % result
finally:
    p1.contract()

try: # Tests with hoist.
    p1.expand()
    c.selectPosition(limit)
    c.hoist()
    result = limit.copy().moveToVisBack(c)
    assert not result,'limited visBack: %s' % result
    #
    result = limit.copy().moveToVisNext(c)
    assert result==d,'limited visNext !=d: %s' % result
finally:
    c.dehoist()
    c.selectPosition(p1)
    p1.contract()
    c.redraw_now()
    </t>
<t tx="ekr.20070611071101.1"></t>
<t tx="ekr.20070611071101.2"></t>
<t tx="ekr.20070611071101.3"></t>
<t tx="ekr.20070611071101.4"></t>
<t tx="ekr.20070611071101.5"></t>
<t tx="ekr.20070611071954"></t>
<t tx="ekr.20070611081718"></t>
<t tx="ekr.20070611081718.1"></t>
<t tx="ekr.20070611081718.2"></t>
<t tx="ekr.20070611081718.4"></t>
<t tx="ekr.20070611105423.1">c.contractAllHeadlines()</t>
<t tx="ekr.20070611105728"># Remove any previous children.
while p.hasChildren():
    p.firstChild().doDelete()
# Create two cloned children.
c.selectPosition(p)
c.insertHeadline()
p2 = c.p
p2.moveToFirstChildOf(p)
p2.setHeadString('aClone')
c.selectPosition(p2)
c.clone()
assert 2 == p.numberOfChildren()

# Select the first clone and demote (it should be illegal)
c.selectPosition(p2)
c.demote() # This should do nothing.
assert g.app.unitTestDict.get('checkMoveWithParentWithWarning'),'fail 1'
assert 0 == c.checkOutline(event=None,verbose=False,unittest=True,full=True), 'fail 2'
assert 2 == p.numberOfChildren(), 'fail 3'
# Delete the children, but only if there are no errors.
while p.hasChildren():
    p.firstChild().doDelete()</t>
<t tx="ekr.20070615070259"></t>
<t tx="ekr.20070626153940">'''
This script runs all @test nodes as follows:

- Copies all @suite and @tests nodes to dynamicUnitTests.leo.
- Runs dynamicUnitTests.leo in a separate process.

This ensures that all unit tests will be run with the latest Leo sources.
'''

import os,sys
import leoGui

@others

path = g.os_path_abspath(g.os_path_join(
    g.app.loadDir,'..','test','dynamicUnitTest.leo'))

g.pr('-'*20)
found = searchOutline(p.copy())
if found:
    gui = leoGui.nullGui("nullGui")
    c2 = c.new(gui=gui)
    found = createOutline(c,c2,p.copy())
    createFileFromOutline(c2,path)
    runDynamicTests(path)
    c.selectPosition(p.copy())
else:
    g.es_print('no @test or @suite nodes in selected outline')
</t>
<t tx="ekr.20070626153940.1">def searchOutline(p):

    for p in p.self_and_subtree_iter():
        h = p.h
        if h.startswith('@test') or h.startswith('@suite'):
            return True
    else:
        return False</t>
<t tx="ekr.20070626153940.2">def createOutline(c,c2,p):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c2root = c2.rootPosition()
    c2root.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.

    c2root.expand()
    for p in p.self_and_subtree_iter():
        h = p.h
        if h.startswith('@test') or h.startswith('@suite'):
            # g.pr(h)
            # c.copyOutline is too slow.
            p2 = p.copyTreeAfter()
            p2.unlink()
            p2.moveToLastChildOf(c2root)


</t>
<t tx="ekr.20070626153940.3">def createFileFromOutline(c2,path):

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
</t>
<t tx="ekr.20070626153940.4">def runDynamicTests(path):

    runDynamicTests = g.os_path_abspath(g.os_path_join(
        g.app.loadDir,'..','test','leoDynamicTest.py'))

    args = [sys.executable, runDynamicTests ]

    # Use a pristine environment.
    os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
</t>
<t tx="ekr.20070807104632">import leoTest
leoTest.doTests (c,all=False)</t>
<t tx="ekr.20070926090757"></t>
<t tx="ekr.20070926095117">def mungeKey (h,kind,substitute=True):
    
    key = h[len(kind):].strip()
    i = key.find('@key')
    if i &gt; -1: key = key[:i].strip()
    if substitute:
        key = key.replace(' ','-')
    # g.trace(key)
    return key
    
    </t>
<t tx="ekr.20071007120750.3">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20071007120750.4">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20071007120750.5">import leo.core.leoTest as leoTest
c.editCommands.ccolumn = 4 # Set the comment column
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20071007120750.6"># xxxx.yyyy

s = p.b
w = c.frame.body.bodyCtrl
w.setSelectionRange(2,11)
c.editCommands.setFillPrefix(event=None)
assert c.editCommands.fillPrefix == 'xxxx.yyyy'
</t>
<t tx="ekr.20071007120947">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20071007120947.6">first line
last lin</t>
<t tx="ekr.20071007120947.7">first line
last line</t>
<t tx="ekr.20071007120947.8">first line
last lin</t>
<t tx="ekr.20071007121115.1">first line
line 1
last line</t>
<t tx="ekr.20071007121115.2">first line
    line 1
last line</t>
<t tx="ekr.20071007121115.3">first line
line 1
last line</t>
<t tx="ekr.20071007121312.1">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20071007121312.2">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms,
2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes.
Potentially deadly
weather impacts every American.
Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20071007121312.3">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20071007121312.5">first line
    line b
last line</t>
<t tx="ekr.20071007121312.6">first line
line b
last line</t>
<t tx="ekr.20071007121312.7">first line
    line b
last line</t>
<t tx="ekr.20071007121529">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20071007121529.1">firstline
last line</t>
<t tx="ekr.20071007121529.2">first line
last line</t>
<t tx="ekr.20071007121529.3">firstline
last line</t>
<t tx="ekr.20071007124202">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20071007124202.1">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20071007124202.2">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms,
2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes.
Potentially deadly
weather impacts every American.
Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20071007124202.3">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?</t>
<t tx="ekr.20071113081247">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20071113081247.1">z
x
e
d
a
</t>
<t tx="ekr.20071113081247.10">x
z
A
c
B</t>
<t tx="ekr.20071113081247.11">A
B
c
x
z
</t>
<t tx="ekr.20071113081247.2">a
d
e
z
x</t>
<t tx="ekr.20071113081247.3">z
x
e
d
a
</t>
<t tx="ekr.20071113081247.8">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20071113081247.9">A
B
c
x
z
</t>
<t tx="ekr.20071113082531">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20071113082531.1">z
Y
X
c
b
A
</t>
<t tx="ekr.20071113082531.2">c
A
z
X
Y
b</t>
<t tx="ekr.20071113082531.3">z
Y
X
c
b
A
</t>
<t tx="ekr.20071113090055.4"># This will work regardless of where this method is.
@language python
@tabwidth -4
# @path xyzzy # Creates folder called xyzzy: interferes with other unit tests.
@pagewidth 120

d = c.atFileCommands.scanAllDirectives(p)

assert d.get('language') == 'python'
assert d.get('tabwidth') == -4
# assert d.get('path').endswith('xyzzy')
assert d.get('pagewidth') == 120
</t>
<t tx="ekr.20071113090055.5"># This will work regardless of where this method is.
@language python
@tabwidth -4
# @path xyzzy # Creates folder called xyzzy: interferes with other unit tests.
@pagewidth 120

d = c.atFileCommands.scanAllDirectives(p)
# print(d)
assert d.get('language') == 'python'
assert d.get('tabwidth') == -4
# assert d.get('path').endswith('xyzzy')
assert d.get('pagewidth') == 120
</t>
<t tx="ekr.20071113105654.1">c.hoist()
c.dehoist()</t>
<t tx="ekr.20071113140035">fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src','leoPy.leo'))
flag,frame2 = g.openWithFileName(fileName,old_c=None,enableLog=False)
c.frame.bringToFront()
g.app.setLog(c.frame.log)
c2 = frame2.c
c1 = c

d1 = {} ; d2 = {}
for c,d in ( (c1,d1),(c2,d2)):
    for t in c.all_unique_tnodes_iter():
        h = t.h
        if h.startswith('@test'):
            d[h]=h

d1.keys().sort() ; d2.keys().sort()

if 0: # not important
    g.pr()
    g.pr('----- Only in unitTest.leo')
    for h in d1.keys():
        if not d2.get(h):
            g.pr(h)

g.pr('\n----- Only in leoPy.leo')
for h in d2.keys():
    if not d1.get(h):
        g.pr(h)</t>
<t tx="ekr.20071113143844.5">assert c.atFileCommands.isSignificantTree(p)

</t>
<t tx="ekr.20071113143844.6">@first # -*- coding: utf-8 -*-

encoding = 'ascii'

if g.isPython3:
    s = ''
    s2,ok = g.toUnicodeWithErrorCode(s,encoding)
    assert ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s
    
    s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
    assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s
else:
    s = ''
    s2,ok = g.toUnicodeWithErrorCode(s,encoding)
    assert not ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s
    
    s = g.ue('','utf-8')
    s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
    assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s
</t>
<t tx="ekr.20071113143844.9">assert g.CheckVersionToInt('12') == 12,'fail 1'
assert g.CheckVersionToInt('2a5') == 2, 'fail 2'
assert g.CheckVersionToInt('b2') == 0, 'fail 3'</t>
<t tx="ekr.20071113145804.10">c.contractAllHeadlines()
p = c.rootPosition()
while p.hasNext():
    p.moveToNext()
c.selectPosition(p)
</t>
<t tx="ekr.20071113145804.15">c.helpCommands.helpForMinibuffer()
</t>
<t tx="ekr.20071113145804.16">c.helpCommands.aproposBindings()
</t>
<t tx="ekr.20071113145804.17">c.helpCommands.aproposFindCommands()
</t>
<t tx="ekr.20071113145804.18">fc=c.fileCommands
fc.deleteFileWithMessage('xyzzy','test')

if 0: # one-time test of es statements.
    fileName = 'fileName' ; kind = 'kind'
    g.es("read only",color="red")
    g.es("exception deleting %s file: %s" % (fileName,kind))
    g.es("exception deleting backup file:" + fileName)
</t>
<t tx="ekr.20071113145804.19">import sys

# Not a good unit test; it probably will never fail.
def aFunction(): pass
assert type(g.pdb)==type(aFunction), 'wrong type for g.pdb: %s' % type(g.pdb)

class myStdout:
    def write(self,s):
        pass # g.es('From pdb:',s)

class myStdin:
    def readline (self):
        return 'c' # Return 'c' (continue) for all requests for input.

def restore():
    sys.stdout,sys.stdin = sys.__stdout__,sys.__stdin__

try:
    sys.stdin = myStdin() # Essential
    sys.stdout=myStdout() # Optional
    g.pdb()
    restore()
    # assert False,'test of reraising'
except Exception:
    restore()
    raise
</t>
<t tx="ekr.20071113145804.20">if c.config.redirect_execute_script_output_to_log_pane:
    pass # Test doesn't work when redirection is on.
else:
    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) &gt; -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) &gt; -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20071113145804.21">theFile,fn = g.create_temp_file()
assert theFile
assert g.isString(fn)
</t>
<t tx="ekr.20071113145804.22">@first # -*- coding: utf-8 -*-

if 0: # Not usually enabled.
    g.es_trace('\ntest of es_trace: ',color='red')
</t>
<t tx="ekr.20071113145804.23">@first # -*- coding: utf-8 -*-

if g.isPython3:
    table = (
        ('ab',    'ascii'),
        ('',               'ascii'),
        ('ab',            'utf-8'),
        ('',               'utf-8'),
    ) 
else:
    table = (
        ('ab',                    'ascii'),
        (g.ue('ab','utf-8'),      'ascii'),
        ('',                       'ascii'),
        (g.ue('','utf-8'),         'ascii'),
        ('ab',                     'utf-8'),
        (g.ue('ab','utf-8'),       'utf-8'),
        ('',                       'utf-8'),
        (g.ue('','utf-8'),         'utf-8'),
    )
for s,encoding in table:
    g.reportBadChars(s,encoding)
</t>
<t tx="ekr.20071113145804.24">@first # -*- coding: utf-8 -*-

if not g.isPython3: # Does not work with Python 3.x

    table = [
        ('a',    'utf-8'),
        ('a',    'ascii'),
        ('',  'utf-8'),
        ('',  'mbcs'),
        ('',   'utf-8'),
    ]
    
    # __pychecker__ = '--no-reimport'
    import sys
    
    if sys.platform.startswith('win'):
        data = '','mbcs'
        table.append(data)
    
    for s,encoding in table:
        if g.isValidEncoding(encoding):
            s2,ok = g.toUnicodeWithErrorCode(s,encoding)
            assert ok, 'toUnicodeWithErrorCode fails for %s' %s
            s3,ok = g.toEncodedStringWithErrorCode(s2,encoding)
            assert ok, 'toEncodedStringWithErrorCode fails for %s' % s2
            assert s3 == s, 'Round-trip one failed for %s' %s
    
            s2 = g.toUnicode(s,encoding)
            s3 = g.toEncodedString(s2,encoding)
            assert s3 == s, 'Round-trip two failed for %s' %s</t>
<t tx="ekr.20071113145804.26">s1 = 'abc\n\np\nxy'
table1 = (
    (-1,(0,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)),
    (3,(0,3)), # The newline ends a row.
    (4,(1,0)),
    (5,(2,0)),
    (6,(2,1)),
    (7,(3,0)),
    (8,(3,1)),
    (9,(3,2)), # One too many.
    (10,(3,2)), # Two too many.
)
s2 = 'abc\n\np\nxy\n'
table2 = (
    (9,(3,2)),
    (10,(4,0)), # One too many.
    (11,(4,0)), # Two too many.
)
s3 = 'ab' # Test special case.  This was the cause of off-by-one problems.
table3 = (
    (-1,(0,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)), # One too many.
    (3,(0,3)), # Two too many.
)

for s,table in ((s1,table1),(s2,table2)):
    for i,result in table:
        row,col = g.convertPythonIndexToRowCol(s,i)
        assert row == result[0], 'i: %d, expected row %d, got %d' % (i,result[0],row)
        assert col == result[1], 'i: %d, expected col %d, got %d' % (i,result[1],col)
</t>
<t tx="ekr.20071113145804.27">s1 = 'abc\n\np\nxy'
s2 = 'abc\n\np\nxy\n'
table1 = (
    (0,(-1,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)),
    (3,(0,3)), # The newline ends a row.
    (4,(1,0)),
    (5,(2,0)),
    (6,(2,1)),
    (7,(3,0)),
    (8,(3,1)),
    (9,(3,2)), # One too large.
)
table2 = (
    (9,(3,2)),
    (10,(4,0)), # One two many.
)
for s,table in ((s1,table1),(s2,table2)):
    for i,data in table:
        row,col = data
        result = g.convertRowColToPythonIndex(s,row,col)
        assert i == result, 'row: %d, col: %d, expected: %d, got: %s' % (row,col,i,result)</t>
<t tx="ekr.20071113145804.28">script = g.getScript(c,p) # This will get the text of this node.
assert script.find('\r\n') == -1, repr(script)
</t>
<t tx="ekr.20071113145804.29">for s,expected in (
    (' a\n b\n c', 'a\nb\nc'),
    (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
):
    result = g.removeExtraLws(s,c.tab_width)
    assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
        repr(s),repr(expected),repr(result))
</t>
<t tx="ekr.20071113145804.32"># line 1
# line 2
# line 3

w = c.frame.body.bodyCtrl
s = w.getAllText()
start,end = 11,15
w.setSelectionRange(start,end)
before,ins,after = c.frame.body.getSelectionAreas()
assert before == s[0:start],'Got %s' % repr(before)
assert ins    == s[start:end],'Got %s' % repr(ins)
assert after == s[end:]

# end.</t>
<t tx="ekr.20071113145804.33"># target

try:
    w = c.frame.body.bodyCtrl
    # print((w))
    s2 = p.b
    s = w.getAllText()
    assert s == s2, 'w.getAllText() != p.b: len(w)=%d, len(p)=%d' % (len(s),len(s2))
    w.setInsertPoint(len(s))
    c.k.previousSelection = 2,8
    event = g.Bunch(widget=w)
    c.frame.pasteText(event=event,middleButton=True)
    s2 = w.getAllText()
    assert len(s2) == len(s) + len('target')
finally:
    w.setAllText(s)
    p.setBodyString(s)
    # g.trace(repr(s))
    c.recolor()

# end5targettargettargettargettargettargettargettargettargettargettargettargettargettargettargettarget</t>
<t tx="ekr.20071113145804.4">@first # -*- coding: utf-8 -*-
@language python

try:
    ec = c.editCommands ; w = c.frame.body.bodyCtrl
    s = w.getAllText()
    
    # This strings tests unicode, paren matching, and auto-indentation.
    u = g.u('(a\u00c9\u03a9B\u3045\u4e7cz):\n') # '(aBcz):\n'
    u = g.u('(pdq):\n')
    w.setInsertPoint(len(s))
    for char in u:
        event = g.Bunch(widget=w,char=char,keysym=None)
        ec.selfInsertCommand(event)
    result = w.getAllText()
    #g.trace('result',repr(result))
    assert result.endswith('    '),'result:\n%s' % result
    # Test of autocompleter.
finally:
    if 1:
        w.setAllText(s)
        p.setBodyString(s)
        # g.trace(repr(s))
        c.recolor()

# end:</t>
<t tx="ekr.20071113145804.5">@language python
@tabwidth -4

try:
    ec = c.editCommands ; w = c.frame.body.bodyCtrl
    s = w.getAllText()
    w.setSelectionRange(len(s)-9,len(s)-6)
    event = g.Bunch(widget=w,char='\t',keysym=None)
    ec.selfInsertCommand(event)
    result = w.getAllText()
    # print('result %s' % result)
    assert result.endswith('\n    ###abcdef'),'result\n%s' % (repr(result))
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor_now()

###abcdef</t>
<t tx="ekr.20071113145804.7">s1 = '#@+leo-ver=4-thin-encoding=utf-8,.'  # 4.2 format.
s2 = '#@+leo-ver=4-thin-encoding=utf-8.' # pre-4.2 format.

at=c.atFileCommands # Self is a dummy argument.

for s in (s1,s2):
    valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    # g.trace('start',start,'end',repr(end),'len(s)',len(s))
    assert valid, 'not valid'
    assert new_df, 'not new_df'
    assert isThinDerivedFile, 'not thin'
    assert end == '', 'invalid end: %s' % repr(end)
    assert at.encoding == 'utf-8', 'bad encoding: %s' % repr(at.encoding)
</t>
<t tx="ekr.20071113145804.8">at=c.atFileCommands
table = [
    ('@=',0,at.noDirective),
    ('@',0,at.atDirective),
    ('@ ',0,at.atDirective),
    ('@\t',0,at.atDirective),
    ('@\n',0,at.atDirective),
    ('@all',0,at.allDirective),
    ('    @all',4,at.allDirective),
    ("@c",0,at.cDirective),
    ("@code",0,at.codeDirective),
    ("@doc",0,at.docDirective),
    ("@end_raw",0,at.endRawDirective),
    ('@others',0,at.othersDirective),
    ('    @others',4,at.othersDirective),
    ("@raw",0,at.rawDirective),
]
for name in g.globalDirectiveList:
    # Note: entries in g.globalDirectiveList do not start with '@'
    if name not in ('all','c','code','doc','end_raw','others','raw',):
        table.append(('@' + name,0,at.miscDirective),)

for s,i,expected in table:
    result = at.directiveKind4(s,i)
    assert result == expected, '%d %s result: %s expected: %s' % (
        i,repr(s),at.sentinelName(result),at.sentinelName(expected))
</t>
<t tx="ekr.20071113192611"># 24 failures, 2 errors with Alt-5
</t>
<t tx="ekr.20071113193527"># 4 failures with Alt-5
</t>
<t tx="ekr.20071113193624"># 7 failures with Alt-5
</t>
<t tx="ekr.20071113193729">@

9 failures with Alt-5.

Any unit test that changes the structure of the outline should do the
following:

- The setUp method should do
    self.undoMark = c.undoer.getMark()
before altering the outline.

- The tearDown method should do
    c.undoer.rollBackToMark(self.undoMark)
after restoring the outline.

u.rollBackToMark deletes all entries in the undo stack following the saved mark.
This eliminates references to nodes that no longer exist in the present outline.</t>
<t tx="ekr.20071113194033"></t>
<t tx="ekr.20071113194033.3"># No failures with Alt-5 but warnings about no tnode lists.</t>
<t tx="ekr.20071113194216"># 3 failurs with Alt-5
</t>
<t tx="ekr.20071113194424"># 3 failures with Alt-5</t>
<t tx="ekr.20071113194424.1"># 4 failures with Alt-5</t>
<t tx="ekr.20071113194858"># All the following files have problems when run with Alt-5.</t>
<t tx="ekr.20071113201736"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
    
print('\nEnd of leoAtFile tests')</t>
<t tx="ekr.20071113201833"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
    
print('\nEnd of leoCommands tests')</t>
<t tx="ekr.20071113201854"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
    
print('\nEnd of leoConfig tests')</t>
<t tx="ekr.20071113202045"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
  
print('\nEnd of leoFileCommands tests.')</t>
<t tx="ekr.20071113202153"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
    
# print('\nEnd of leoFind tests.')</t>
<t tx="ekr.20071113202153.1"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
    
# print('\nEnd of leoFrame tests.')</t>
<t tx="ekr.20071113202153.2"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
    
# print('\nEnd of leoGlobals tests.')</t>
<t tx="ekr.20071113202452"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
    
print('\nEnd of leoNodes tests.')</t>
<t tx="ekr.20071113202510"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
    
print('\nEnd of leoUndo tests.')</t>
<t tx="ekr.20071113203234"></t>
<t tx="ekr.20080309193654.1"></t>
<t tx="ekr.20080310073711.1">gnx = g.app.nodeIndices.toString(None)
assert(gnx not in (None,'None'))
assert(len(gnx) &gt; 1)</t>
<t tx="ekr.20080312090030.1"></t>
<t tx="ekr.20080324133327.2">True: allow linux-like pastes using a mouse's middle button.

Important: this may cause crashes on some platforms.</t>
<t tx="ekr.20080405082101.1">import leoTest
leoTest.doTests(c, all=True)</t>
<t tx="ekr.20080405085247.1"></t>
<t tx="ekr.20080405085247.2"></t>
<t tx="ekr.20080408094623.1"># start
# targetWord

e = c.editCommands
k = c.k ; w = c.frame.body.bodyCtrl
w.setInsertPoint(0)
k.arg = 't' # 'targetWord'
k.setState('find-word',1)
e.oneLineFlag = False
f = e.findWord(event=None)
i,j = w.getSelectionRange()
assert i == 10, 'expected 15, got %s' % (i)
</t>
<t tx="ekr.20080423110627.11">while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p5 = p.insertAsNthChild(3)
    p5.setHeadString('D')
    p.expand()
    c.setCurrentPosition(p3)
    c.moveOutlineDown()
    moved = c.p
    assert moved.h == 'B',          'fail 1: %s' % moved.h
    assert moved.back().h == 'C',   'fail 2'
    assert moved.next().h == 'D',   'fail 3'
    # This assert fails because p4._childIndex != moved.back()._childIndex.
    # assert moved.back() == p4, 'fail 4: %s != %s' % (moved.back(),p4)
    assert moved.next() == p5,      'fail 5: %s != %s' % (moved.next(),p5)
    c.undoer.undo()
    moved = c.p
    assert moved.back() == p2,      'fail 4'
    assert moved.next() == p4,      'fail 5'
    c.undoer.redo()
    moved = c.p
    assert moved.h == 'B',          'fail 1-2: %s' % moved.h
    assert moved.back().h == 'C',   'fail 2-2'
    assert moved.next().h == 'D',   'fail 3-2'
    c.undoer.undo()
    moved = c.p
    assert moved.back() == p2,      'fail 4-2'
    assert moved.next() == p4,      'fail 5-2'
    c.undoer.redo()
    moved = c.p
    assert moved.h == 'B',          'fail 1-3'
    assert moved.back().h == 'C',   'fail 2-3'
    assert moved.next().h == 'D',   'fail 3-3'

finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    c.redraw_now()</t>
<t tx="ekr.20080423110627.12">while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p5 = p.insertAsNthChild(3)
    p5.setHeadString('D')
    p.expand()
    c.setCurrentPosition(p4)
    c.moveOutlineUp()
    moved = c.p
    assert moved.h == 'C',          'fail 1'
    assert moved.back().h == 'A',   'fail 2'
    assert moved.next().h == 'B',   'fail 3'
    assert moved.back() == p2,      'fail 4: %s != %s' % (moved.back(),p2)
    # This assert fails because p4._childIndex != moved.back()._childIndex.
    # assert moved.next() == p3,    'fail 5: %s != %s' % (moved.next(),p3)
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now()</t>
<t tx="ekr.20080423110627.13">import leo.core.leoNodes as leoNodes

while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
    
child = p.insertAsNthChild(0)
child.setHeadString('child')

try:
    oldRoot = c.rootPosition()
    child.moveToRoot(oldRoot=oldRoot) # Does not change child position.
    c.setRootPosition(child)
    assert c.positionExists(child)
    assert c.rootPosition().h == 'child', 'fail 1'
    next = c.rootPosition().next()
    assert next.h == 'Startup', 'fail 2: next: %s' % next
    c.rootPosition().doDelete(newNode=next)
    c.setRootPosition(next)
finally:
    while p.hasChildren():
        p.firstChild().doDelete(newNode=None)
    # c.selectPosition(p)
    c.redraw_now()</t>
<t tx="ekr.20080423110627.2">n = 0
for v in c.all_unique_vnodes_iter():
    if hasattr(v,'unknownAttributes'):
        d = v.unknownAttributes
        if d.get('str_leo_pos'):
            n += 1
            
# print(n)
assert n &lt; 2</t>
<t tx="ekr.20080423110627.3"># Delete all children.
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
    
child = p.insertAsNthChild(0)
c.setHeadString(child,'child') # Force the headline to update.

try:
    assert child, 'no child'
    c.selectPosition(child)
    clone = c.clone()
    assert clone == c.p
    assert clone.h == 'child','fail headstring: %s' % clone.h
    assert child.isCloned(), 'fail 1'
    assert clone.isCloned(), 'fail 2'
    assert child.isCloned(), 'fail 3'
    assert clone.isCloned(), 'fail 4'
    c.undoer.undo()
    assert not child.isCloned(), 'fail 1-a'
    c.undoer.redo()
    assert child.isCloned(),    'fail 1-b'
    c.undoer.undo()
    assert not child.isCloned(), 'fail 1-c'
    c.undoer.redo()
    assert child.isCloned(),    'fail 1-d'
    oldRoot = c.rootPosition()
    clone.moveToRoot(oldRoot=oldRoot) # Does not change child position.
    assert child.isCloned(),    'fail 3-2'
    assert clone.isCloned(),    'fail 4-2'
    assert not clone.parent(),  'fail 5'
    assert not clone.back(),    'fail 6'
    clone.doDelete()
    assert not child.isCloned(), 'fail 7'
finally:
    # Delete all children.
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    c.redraw_now()</t>
<t tx="ekr.20080423110627.5">while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
    
child = p.insertAsNthChild(0)
child.setHeadString('child')
child2 = p.insertAsNthChild(1)
child2.setHeadString('child2')
grandChild = child.insertAsNthChild(0)
grandChild.setHeadString('grand child')
c.selectPosition(grandChild)
c.clone()
c.selectPosition(child)

try:
    p.expand()
    c.selectPosition(child)
    assert c.p.h == 'child','fail 1'
    c.copyOutline()
    oldVnodes = [p2.v for p2 in child.self_and_subtree()]
    c.selectPosition(child)
    c.p.contract() # Essential
    c.pasteOutline()
    assert c.p != child, 'fail 2'
    assert c.p.h == 'child','fail 3'
    newVnodes = [p2.v for p2 in c.p.self_and_subtree()]
    for v in newVnodes:
        assert v not in oldVnodes, 'fail 4'
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()

finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now()</t>
<t tx="ekr.20080423110627.8">while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
    
child = p.insertAsNthChild(0)
child.setHeadString('child')
assert child, 'no child'
grandChild = child.insertAsNthChild(0)
grandChild.setHeadString('grand child')

try:
    c.selectPosition(child)
    c.copyOutline()
    oldVnodes = [p2.v for p2 in child.self_and_subtree()]
    c.p.contract() # Essential
    c.pasteOutlineRetainingClones()
    assert c.p != child, 'fail 2'
    newVnodes = [p2.v for p2 in c.p.self_and_subtree()]
    for v in newVnodes:
        assert v in oldVnodes, 'fail 3'
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now()</t>
<t tx="ekr.20080501121449.1"></t>
<t tx="ekr.20080501121449.3">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p.expand()
    c.setCurrentPosition(p2)
    c.insertHeadline()
    p = c.p
    p.setHeadString('inserted')
    assert p.back().h == 'A', 'fail 1'
    assert p.next().h == 'B', 'fail 2'
    c.undoer.undo()
    p = c.p
    assert p == p2,         'fail 3'
    assert p.next() == p3,  'fail 4'
    c.undoer.redo()
    p = c.p
    assert p.back().h == 'A', 'fail 1-2'
    assert p.next().h == 'B', 'fail 2-2'
    c.undoer.undo()
    p = c.p
    assert p == p2,         'fail 3-2'
    assert p.next() == p3,  'fail 3-2'
    c.undoer.redo()
    p = c.p
    assert p.back().h == 'A', 'fail 1-3'
    assert p.next().h == 'B', 'fail 2-3'

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()</t>
<t tx="ekr.20080503073030.1">while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p.expand()
    c.setCurrentPosition(p2)
    c.moveOutlineLeft()
    moved = c.p
    assert moved.h == 'A','fail 1'
    # This assert fails because p4._childIndex != moved.back()._childIndex.
    assert moved.back() == p, 'fail 2: %s != %s' % (moved.back(),p4)
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()
    
    
    
    moved.doDelete(newNode=p)
    
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
        c.redraw_now()</t>
<t tx="ekr.20080503073030.2">while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p.expand()
    c.setCurrentPosition(p3)
    c.moveOutlineRight()
    moved = c.p
    assert moved.h == 'B', 'fail 1'
    assert moved.parent() == p2
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now()</t>
<t tx="ekr.20080503082625.3">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p.expand()
    c.selectPosition(p3)
    c.deleteOutline()
    c.redraw_now()
    p = c.p
    assert p.h == 'A', 'fail 1: got %s' % p.h
    assert p.next().h == 'C', 'fail 2'
    c.undoer.undo()
    c.outerUpdate()
    p = c.p
    assert p.back() == p2, 'fail 4 %s' % p.back()
    assert p.next() == p4, 'fail 5'
    c.undoer.redo()
    c.outerUpdate()
    p = c.p
    assert p.h == 'A',          'fail 1-2'
    assert p.next().h == 'C',   'fail 2-2'
    c.undoer.undo()
    c.outerUpdate()
    p = c.p
    assert p.back() == p2,  'fail 4-2'
    assert p.next() == p4,  'fail 5-2'
    c.undoer.redo()
    c.outerUpdate()
    p = c.p
    assert p.h == 'A',          'fail 1-3'
    assert p.next().h == 'C',   'fail 2-3'

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()</t>
<t tx="ekr.20080503082625.4">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p3.insertAsNthChild(0)
    p4.setHeadString('child 1')
    p5 = p3.insertAsNthChild(1)
    p5.setHeadString('child 2')
    p.expand()
    p6 = p.insertAsNthChild(2)
    p6.setHeadString('C')
    c.setCurrentPosition(p3)
    c.promote()
    p = c.p
    assert p == p3,         'fail 1'
    assert p.h == 'B',      'fail 2'
    assert p.next().h=='child 1',            'fail 3'
    assert p.next().next().h == 'child 2',   'fail child 1'
    assert p.next().next().next().h == 'C',  'fail child 2'
    c.undoer.undo()
    p = c.p
    assert p == p3
    assert p.back() == p2,  'fail 5'
    assert p.next() == p6,  'fail 6'
    assert p.firstChild().h=='child 1',          'fail child 3'
    assert p.firstChild().next().h == 'child 2', 'fail child 4'
    c.undoer.redo()
    p = c.p
    assert p == p3,         'fail 1-2'
    assert p.h == 'B',      'fail 2-2'
    assert p.next().h=='child 1',            'fail 3-2'
    assert p.next().next().h == 'child 2',   'fail child 1-2'
    assert p.next().next().next().h == 'C',  'fail child 2-2'
    c.undoer.undo()
    p = c.p
    assert p == p3
    assert p.back() == p2,                      'fail 5-2'
    assert p.next() == p6,                      'fail 6-2'
    assert p.firstChild().h=='child 1',         'fail child 3-2'
    assert p.firstChild().next().h == 'child 2','fail child 4-2'
    c.undoer.redo()
    p = c.p
    assert p == p3,     'fail 1-3'
    assert p.h == 'B',  'fail 2-3'
    assert p.next().h=='child 1',            'fail 3-3'
    assert p.next().next().h == 'child 2',   'fail child 1-3'
    assert p.next().next().next().h == 'C',  'fail child 2-3'
    
finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()</t>
<t tx="ekr.20080503082625.5">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p5 = p.insertAsNthChild(3)
    p5.setHeadString('D')
    p.expand()
    c.setCurrentPosition(p3)
    c.demote()
    p = c.p
    assert p == p3,         'fail 1'
    assert p.h == 'B',      'fail 2'
    assert not p.next(),    'fail 3'
    assert p.firstChild().h == 'C',          'fail child 1'
    assert p.firstChild().next().h == 'D',   'fail child 2'
    c.undoer.undo()
    p = c.p
    assert p == p3
    assert p.back() == p2, 'fail 5'
    assert p.next() == p4, 'fail 6'
    c.undoer.redo()
    assert p == p3,         'fail 1-2'
    assert p.h == 'B',      'fail 2-2'
    assert not p.next(),    'fail 3-2'
    assert p.firstChild().h == 'C',         'fail child 1-2'
    assert p.firstChild().next().h == 'D',  'fail child 2-2'
    c.undoer.undo()
    p = c.p
    assert p.back() == p2, 'fail 4-2'
    assert p.next() == p4, 'fail 5-2'
    c.undoer.redo()
    assert p == p3,         'fail 1-3'
    assert p.h == 'B',      'fail 2-3'
    assert not p.next(),    'fail 3-3'
    assert p.firstChild().h == 'C',         'fail child 1-3'
    assert p.firstChild().next().h == 'D',  'fail child 2-3'

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()</t>
<t tx="ekr.20080503132221.1">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
    
child = p.insertAsNthChild(0)
c.setHeadString(child,'child') # Force the headline to update.
c.selectPosition(child)

try:
    for undoType in ('Create Chapter From Node','Create Chapter'):
        c.chapterController.createChapterByName('new-chapter',p,undoType)
        c.undoer.undo()
        c.undoer.redo()
        c.undoer.undo()
        c.undoer.redo()
        c.undoer.undo() # Don't pollute future unit tests.

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()</t>
<t tx="ekr.20080529114722.1">import leo.core.leoTest as leoTest
leoTest.runTimerOnNode(c,p,count=100)</t>
<t tx="ekr.20080529115911.1">import leo.core.leoTest as leoTest
leoTest.runProfileOnNode(p,outputPath=None) # Defaults to leo\test\profileStats.txt</t>
<t tx="ekr.20080701183239.1">if 0:
    @others

</t>
<t tx="ekr.20080701183239.2">def quickConvertRowColToPythonIndex(row,col):
    return lineIndices[row-1] + col

s = p.b
lines = g.splitLines(s)
lineIndices = [0]
for i in range(1,len(lines)):
    lineIndices.append(lineIndices[i-1] + len(lines[i-1]))

n = 0
for row in range(len(lines)):
    line = lines[row]
    for col in range(len(line)):
        assert quickConvertRowColToPythonIndex(row+1,col) == n
        n += 1
print('pass')

</t>
<t tx="ekr.20080701183239.3"># aaaaaaaaaaaaaaaaaa add some more characters.

total_count_chars = total_rfind_chars = 0

def quickConvertPythonIndexToRowCol(i,last_row,last_col,last_i):
    global total_count_chars, total_rfind_chars
    trace = False
    if trace: g.trace('i',i,'last_row',last_row,'last_col',last_col,'last_i',last_i)
    row = s.count('\n',last_i,i) # Don't include i
    total_count_chars += i-last_i
    if trace: g.trace('row',row)
    if row == 0:
        if trace: g.trace('returns',last_row,last_col+i-last_i)
        return last_row,last_col+i-last_i
    else:
        prevNL = s.rfind('\n',last_i,i) # Don't include i
        total_rfind_chars += i-last_i
        if trace: g.trace('prevNL',prevNL)
        if trace: g.trace('returns',last_row+row,i-prevNL-1)
        return last_row+row,i-prevNL-1

def fail(kind,expected,got):
    return 'n: %d, expected %s %d, got %s %d last_row %d last_col %d' % (
        n,kind,expected,kind,got,last_row,last_col)

# This is fast because we never look at characters more than once.
s = p.b
print('-'*40)
last_col = 0 ; last_row = 0 ; last_i = 0 ; n = 0
while n &lt; len(s):
    expected_row, expected_col = g.convertPythonIndexToRowCol(s,n)
    row,col = quickConvertPythonIndexToRowCol(n,last_row,last_col,last_i=last_i)
    assert row == expected_row,fail('row',expected_row,row)
    assert col == expected_col,fail('col',expected_col,col)
    last_row = row ; last_col = col ; last_i = n
    n += 20
n = len(s)
expected_row, expected_col = g.convertPythonIndexToRowCol(s,n)
row,col = quickConvertPythonIndexToRowCol(n,last_row,last_col,last_i=last_i)
assert row == expected_row,fail('row',expected_row,row)
assert col == expected_col,fail('col',expected_col,col)
print('pass','len(s)',len(s),'total_count_chars',total_count_chars,'total_rfind_chars',total_rfind_chars)
</t>
<t tx="ekr.20080703104536.1"></t>
<t tx="ekr.20080805104144.1">fc = c.fileCommands
child = p.firstChild()
grandChild = child.firstChild()
child.v.unknownAttributes = {'unit_test_child':'abcd'}
grandChild.v.unknownAttributes = {'unit_test_grandchild':'wxyz'}

try:

    s = fc.putDescendentVnodeUas (p)

    if g.isPython3:
        expected = ' descendentVnodeUnknownAttributes="\
7d7100285803000000302e3071017d7102580f000000756e6974\
5f746573745f6368696c64710358040000006162636471047358\
05000000302e302e3071057d71065814000000756e69745f7465\
73745f6772616e646368696c64710758040000007778797a710873752e"'

    else:
        expected = ' descendentVnodeUnknownAttributes="\
7d7100285503302e3071017d7102550f756e69745f746573745f\
6368696c6471035504616263647104735505302e302e3071057d\
71065514756e69745f746573745f6772616e646368696c647107\
55047778797a710873752e"'
        
    assert s == expected, 'expected: %s, got: %s' % (repr(expected),repr(s))
finally:
    del child.v.unknownAttributes
    del grandChild.v.unknownAttributes
</t>
<t tx="ekr.20080805104144.2"></t>
<t tx="ekr.20080805104144.3"></t>
<t tx="ekr.20080805105541.1">val = p.archivedPosition(root_p=p)
assert val == [0],'expected %s, got %s' % ([0],val)

i = 0
for z in p.parent().children_iter():
    val = z.archivedPosition(root_p=p.parent())
    assert val == [0,i],'expected %s, got %s'%([0,i],val)
    i += 1

i = 0
for z in p.children_iter():
    val = z.archivedPosition(root_p=p)
    assert val == [0,i],'expected %s, got %s'%([0,i],val)
    i += 1
    
i = 0
for z in p.firstChild().next().children_iter():
    val = z.archivedPosition(root_p=p)
    assert val == [0,1,i],'expected %s, got %s'%([0,1,i],val)
    i += 1</t>
<t tx="ekr.20080805122315.1"></t>
<t tx="ekr.20080805122315.2"></t>
<t tx="ekr.20080805122315.3"></t>
<t tx="ekr.20080805122315.4"></t>
<t tx="ekr.20080806072412.1">child1 = p.firstChild()
child2 = p.firstChild().next()
grandChild1 = child2.firstChild()
grandChild2 = grandChild1.next()
greatGrandChild11 = grandChild1.firstChild()
greatGrandChild12 = greatGrandChild11.next()
greatGrandChild21 = grandChild2.firstChild()
greatGrandChild22 = greatGrandChild21.next()
root_v = p.v

table = (
    # Errors.
    (None,'-1'),
    (None,'1'),
    (None,'0.2'),
    (None,'0.0.0'),
    (None,'0.1.2'),
    # Valid.
    (root_v,'0'),
    (child1.v,'0.0'),
    (child2.v,'0.1'),
    (grandChild1.v,'0.1.0'),
    (greatGrandChild11.v,'0.1.0.0'),
    (greatGrandChild12.v,'0.1.0.1'),
    (grandChild2.v,'0.1.1'),
    (greatGrandChild21.v,'0.1.1.0'),
    (greatGrandChild22.v,'0.1.1.1'),
)

for v,archivedPosition in table:
    v2 = c.fileCommands.resolveArchivedPosition(archivedPosition,root_v)
    assert v == v2,'got %s, expected %s' % (v2,v)
</t>
<t tx="ekr.20080806072412.2"></t>
<t tx="ekr.20080806072412.3"></t>
<t tx="ekr.20080806072412.4"></t>
<t tx="ekr.20080806072412.5"></t>
<t tx="ekr.20080806080425.1"></t>
<t tx="ekr.20080806080425.2"></t>
<t tx="ekr.20080806080425.3"></t>
<t tx="ekr.20080806080425.4"></t>
<t tx="ekr.20080806084924.2">@others</t>
<t tx="ekr.20080806084924.3">pass</t>
<t tx="ekr.20080806084924.4">pass
</t>
<t tx="ekr.20080806084924.5">pass</t>
<t tx="ekr.20080806095923.2">root = p.firstChild()
uA = 'unknownAttributes'
tag = 'round-trip-u.uA'
ttag = 'round-trip-t.uA'
trace = False

if 0: # Set the uA's.
    for p2 in root.self_and_subtree_iter():
        p2.v.unknownAttributes = {tag: p2.h}
else: # Test the uA's.
    # The root is a special case.
    v = root.v
    assert hasattr(v,uA),'no v.uA for %s' % v
    assert getattr(v,uA),'empty v.uA for %s' % v
    for p2 in root.self_and_subtree_iter():
        v = p2.v
        assert hasattr(v,uA),'no v.uA for %s' % v
        a = getattr(v,uA)
        d = {tag: v.h}
        if trace: print(d)
        assert a == d, 'expected v.uA: "%s", got "%s"' % (d,a)</t>
<t tx="ekr.20080806211453.1">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080806211453.5">root = p.firstChild()
uA = 'unknownAttributes'
tag = 'round-trip-u.uA'
ttag = 'round-trip-t.uA'
trace = False

if 0: # Set the uA's.
    for p2 in root.self_and_subtree_iter():
        p2.v.unknownAttributes = {tag: p2.h}
else: # Test the uA's.
    # The root is a special case.
    v = root.v
    assert hasattr(v,uA),'no v.uA for %s' % v
    assert getattr(v,uA),'empty v.uA for %s' % v
    for p2 in root.self_and_subtree_iter():
        v = p2.v
        assert hasattr(v,uA),'no v.uA for %s' % v
        a = getattr(v,uA)
        d = {tag: v.h}
        if trace: print(d)
        assert a == d, 'expected v.uA: "%s", got "%s"' % (d,a)</t>
<t tx="ekr.20080821123427.2">@first # -*- coding: utf-8 -*-

import sys

print('=' * 40)

e = sys.getdefaultencoding()
print('encoding',e)

table = (
    'La Pea',
    g.u('La Pea'),
    # u'La Pea',
    g.u('La Pe\xf1a')
)

for s in table:
    print(type(s))
    g.es_print('g.es_print',s)
    if type(s) != type(u'a'):
        s = unicode(s,e)
    print('print     ',s)
    print('repr(s)   ',repr(s))</t>
<t tx="ekr.20080822160527.1">pass
pass
pass
</t>
<t tx="ekr.20080904095020.1">@nocolor-node

c.gotoLineNumber is called in just two ways:
    
- from goto-global-line with root=None,lines=None and scriptFile = False.
- from c.goToScriptLineNumber with valid root and lines and scriptFile = True.
</t>
<t tx="ekr.20080904102243.2">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080904102243.3">def child():
    pass
</t>
<t tx="ekr.20080904110148.1">root = p.parent().parent()
h = '@auto unittest/at-auto-line-number-test.py'
target = g.findNodeInTree(c,root,h)
assert target

p,n,found = c.goto_countLines (target,3)
assert found,found
assert n == 3,n
assert p.h == 'at_auto_child',p.h
</t>
<t tx="ekr.20080904110148.4">h = '@auto unittest/at-auto-line-number-test.py'
root = g.findNodeAnywhere(c,h)
assert root
p,n,found = c.goto_countLines (root,20)
assert not found
assert p.h == 'at_auto_child'
# print('p:%s, n:%s, found: %s' % (p,n,found))</t>
<t tx="ekr.20080904110148.5">h = '@auto unittest/at-auto-line-number-test.py'
root1 = g.findNodeAnywhere(c,h)
assert root1
assert root1.isAnyAtFileNode()

fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n=3,p=root1)
assert isRaw,isRaw
assert fileName == h[6:],fileName
assert root == root1

if 0:
    print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
        root and root.h,isRaw,n,len(lines)))</t>
<t tx="ekr.20080904113003.2">h = '@auto unittest/at-auto-line-number-test.py'
root1 = g.findNodeAnywhere(c,h)
assert root1
assert root1.isAnyAtFileNode()

scriptData = {'p':root1.copy(),'lines':['a','b','c']}
fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n=2,scriptData=scriptData)

assert isRaw,isRaw
assert fileName == h[6:],fileName
assert root == root1,root
assert n == 2,n

if 0:
    print('root:%s, n:%s, len(lines): %s' % (
        root and root.h,n,len(lines)))</t>
<t tx="ekr.20080904120258.2">c.goto_showResults(found=True,p=p,n=3,n2=3,lines=3)</t>
<t tx="ekr.20080904120258.3">c.goToLineNumber(c).showResults(
    found=False,p=p,n=3,n2=3,lines=['a','b'])



</t>
<t tx="ekr.20080904120258.6">root = p.parent().parent()
h = '@file unittest/at-file-line-number-test.py'
target = g.findNodeInTree(c,root,h)
assert target,'no target'

gnx = g.app.nodeIndices.toString(target.v.fileIndex)
assert gnx,'no gnx'

p,found = c.goto_findGnx(root,gnx,h)
assert found,found
assert p == target,'\np:     %s\ntarget:%s' % (p,target)
</t>
<t tx="ekr.20080905112230.3"></t>
<t tx="ekr.20080905112230.4"># Can not clone @auto children!</t>
<t tx="ekr.20080905113550.2"></t>
<t tx="ekr.20080905113550.3"></t>
<t tx="ekr.20080905113550.4"></t>
<t tx="ekr.20080905130723.1">root = p.parent().parent()
h = '@file unittest/at-file-line-number-test.py'
target = g.findNodeInTree(c,root,h)
assert target,target

n = 2
fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n,p=target)
assert fileName == h[6:]
# print('lines\n%s' % g.listToString(lines))
assert root == target

vnodeName,gnx,offset,delim = c.goto_findVnode (root,lines,n,ignoreSentinels)

assert lines,'no lines'
assert not gnx,repr(gnx)
assert offset is not None,repr(offset)
assert vnodeName,repr(vnodeName)

# print('vnodeName',vnodeName,'gnx',gnx,'offset',offset,'delim',delim)

</t>
<t tx="ekr.20080905130723.4">def child():
    pass
</t>
<t tx="ekr.20080905165432.1">root = p.parent().parent()
h = '@auto unittest/at-auto-line-number-test.py'
target = g.findNodeInTree(c,root,h)
assert target
child = target.firstChild()
assert child.h == 'at_auto_child'

p,found = c.goto_findRoot(child)

assert p == target,p and p.h
assert found,found
</t>
<t tx="ekr.20080905165432.3">root = p.parent().parent()

# Find the cloned nodes that doesn't have an @file node for a parent.
clones = g.findNodeInTree(c,root,'goto-line-number tests: clones')
assert clones
child = g.findNodeInTree(c,clones,'at-file-child')
assert child and child.h == 'at-file-child',child

h = '@file unittest/at-file-line-number-test.py'
p,found = c.goto_findRoot(child)

assert p and p.h==h,p and p.h
assert found,found
</t>
<t tx="ekr.20080907122804.2"></t>
<t tx="ekr.20080907122804.3">h = '@shadow unittest/at-shadow-line-number-test.py'
root1 = g.findNodeAnywhere(c,h)
assert root1
assert root1.isAnyAtFileNode()

fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n=6,p=root1)
assert not isRaw,isRaw
assert fileName == h[8:],fileName
assert root == root1

if 0:
    print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
        root and root.h,isRaw,n,len(lines)))</t>
<t tx="ekr.20080907123324.2">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080907123324.3">def child():
    pass

#
#
#
#
#
#</t>
<t tx="ekr.20080907123324.4"></t>
<t tx="ekr.20080907123324.5">h = '@nosent unittest/at-nosent-line-number-test.py'
root1 = g.findNodeAnywhere(c,h)
assert root1
assert root1.isAnyAtFileNode()

fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n=6,p=root1)
assert isRaw,isRaw
assert ignoreSentinels,ignoreSentinels
assert fileName == h[8:],fileName
assert root == root1

if 0:
    print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
        root and root.h,isRaw,n,len(lines)))</t>
<t tx="ekr.20080917151620.10">@root-code

aList = g.get_directives_dict_list(p)
s = c.scanAtRootDirectives(aList)

assert s == 'code',repr(s)</t>
<t tx="ekr.20080917151620.11">@root-doc

aList = g.get_directives_dict_list(p)
s = c.scanAtRootDirectives(aList)

assert s == 'doc',repr(s)</t>
<t tx="ekr.20080917151620.13">@header

aList = g.get_directives_dict_list(p)
g.scanAtHeaderDirectives(aList)
</t>
<t tx="ekr.20080917151620.14">@noheader

aList = g.get_directives_dict_list(p)
g.scanAtHeaderDirectives(aList)
</t>
<t tx="ekr.20080917151620.15">@lineending cr

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\r'
</t>
<t tx="ekr.20080917151620.16">@lineending crlf

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)
# print('@lineending: %s'%repr(s))

assert s == '\r\n'
</t>
<t tx="ekr.20080917151620.17">@lineending lf

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\n'
</t>
<t tx="ekr.20080917151620.18">@lineending nl

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\n'
</t>
<t tx="ekr.20080917151620.19">@lineending platform

import sys

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

if sys.platform.startswith('win'):
    assert s == '\r\n'
else:
    assert s == '\n'
</t>
<t tx="ekr.20080917151620.21">@pagewidth 40

aList = g.get_directives_dict_list(p)
n = g.scanAtPagewidthDirectives(aList)

assert n == 40</t>
<t tx="ekr.20080917151620.22">aList = g.get_directives_dict_list(p.firstChild())
s = c.scanAtPathDirectives(aList,force=True)
end = g.os_path_normpath(r'leo/test')

assert s.endswith(end),repr(s)</t>
<t tx="ekr.20080917151620.24">grandChild = p.firstChild().firstChild()
aList = g.get_directives_dict_list(grandChild)
s = c.scanAtPathDirectives(aList,force=True)
end = g.os_path_normpath(r'leo/test/unittest')

assert s.endswith(end),repr(s)</t>
<t tx="ekr.20080917151620.25"></t>
<t tx="ekr.20080917151620.27">greatGrandChild = p.firstChild().firstChild().firstChild()
aList = g.get_directives_dict_list(greatGrandChild)
s = c.scanAtPathDirectives(aList,force=True)
end = g.os_path_normpath(r'leo/test/unittest')

assert s.endswith(end),repr(s)</t>
<t tx="ekr.20080917151620.28"></t>
<t tx="ekr.20080917151620.29"></t>
<t tx="ekr.20080917151620.31">@tabwidth 6

aList = g.get_directives_dict_list(p)
n = g.scanAtTabwidthDirectives(aList)

assert n == 6,repr(n)</t>
<t tx="ekr.20080917151620.32">@tabwidth -6

aList = g.get_directives_dict_list(p)
n = g.scanAtTabwidthDirectives(aList)

assert n == -6</t>
<t tx="ekr.20080917151620.33">@nowrap

aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is False,repr(s)</t>
<t tx="ekr.20080917151620.34">@wrap

aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is True,repr(s)</t>
<t tx="ekr.20080917151620.35">aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is None,repr(s)</t>
<t tx="ekr.20080917151620.9">@language python
@comment a b c
    # @comment must follow @language
@tabwidth -4
@pagewidth 72
@encoding utf-8
@lineending crlf

d = c.scanAllDirectives(p)
# print(g.dictToString(d))

table = (
    ('delims', ('a','b','c'),),
    ('encoding','utf-8'),
    ('language','python'),
    ('lineending','\r\n'),
    ('pagewidth',72),
    ('tabwidth',-4),
)

for kind,expected in table:
    got = d.get(kind)
    assert got == expected, 'kind: %s, expected %s, got %s' % (
        kind,repr(expected),repr(got))
</t>
<t tx="ekr.20081001094920.2"></t>
<t tx="ekr.20081001094920.3">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode = None)

try:
    
    p1 = p.insertAsLastChild()
    assert p1.textOffset() == 0

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode = None)
    c.redraw_now()
</t>
<t tx="ekr.20081001094920.4">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode = None)

try:
    
    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    assert p1.textOffset() == 0

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode = None)
    c.redraw_now()
</t>
<t tx="ekr.20081001094920.5">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode = None)

try:
    
    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    p2 = p1.insertAsLastChild()
    assert p1.textOffset() == 0
    assert p2.textOffset() == 0
    
finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode = None)
    c.redraw_now()
</t>
<t tx="ekr.20081001094920.6">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode = None)
    
try:
    
    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    body = '''   %s
    ''' % (g.angleBrackets(' section '))
    p1.setBodyString(body)
    p2 = p1.insertAsLastChild()
    head = g.angleBrackets(' section ')
    p2.setHeadString(head)
    assert p1.textOffset() == 0
    assert p2.textOffset() == 3

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode = None)
    c.redraw_now()
</t>
<t tx="ekr.20081001094920.7">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode = None)

try:
    
    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    body = '''     %s
    ''' % (chr(64) + 'others') # ugly hack
    p1.setBodyString(body)
    p2 = p1.insertAsLastChild()
    assert p1.textOffset() == 0
    assert p2.textOffset() == 5
    root.firstChild().doDelete(newNode = None)

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode = None)
    c.redraw_now()
</t>
<t tx="ekr.20081111082931.1"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
</t>
<t tx="ekr.20081111084046.1"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
    </t>
<t tx="ekr.20081111084046.2"></t>
<t tx="ekr.20081111084046.3"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
</t>
<t tx="ekr.20081111084046.4"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

</t>
<t tx="ekr.20081111084046.6"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
</t>
<t tx="ekr.20081111150402.11"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.selectPosition(p)
c.contractParent()
c.selectPosition(p.parent())
c.save() # Only good way to save the present expansion/selection state.
g.app.unitTestDict['restoreSelectedNode']=False

# Print does not work: it is redirected.
g.es('all unit tests done',color='blue')
</t>
<t tx="ekr.20081121164135.1">import leo.core.leoTest as leoTest

path = g.os_path_join(g.app.loadDir,"..","plugins","leoGuiPluginsRef.leo")
leoTest.runLeoTest(c,path,verbose=False,full=True)
</t>
<t tx="ekr.20081215084144.10">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20081215084144.2">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20081215084144.3">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20081215084144.4">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20081215084144.5">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20081215084144.7">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20081215084144.8">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20081215084144.9">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20090102061858.2">child = p.insertAsLastChild()
assert c.positionExists(child)
child.doDelete()
assert not c.positionExists(child)

# also check the same on root level
child = c.rootPosition().insertAfter()
assert c.positionExists(child)
child.doDelete()
assert not c.positionExists(child)</t>
<t tx="ekr.20090102062037.2">root = c.rootPosition()

for p in c.all_positions():
    assert c.positionExists(p,root)</t>
<t tx="ekr.20090104053806.1"># Disabled because modifying errorTest.py creates annoying bzr conflicts.

import os

path = g.os_path_finalize_join(g.app.testDir,'unittest','errorTest.py')
assert g.os_path_exists(path),path
timeStamp = c.timeStampDict.get(path)
val = c.checkFileTimeStamp(path)
assert val == True

f = open(path)
s = f.read()
lines = g.splitLines(s)
result = [] ; found = False
tag = '# timestamp:'
for line in lines:
    if line.startswith(tag):
        timeStamp = os.path.getmtime(path)
        result.append('%s %s\n' % (tag,timeStamp))
        found = True
    else:
        result.append(line)
f.close()

assert found,' no line starts with "%s"' % tag

f = open(path,'w')
f.write(''.join(result))
f.close()

timeStamp2 = os.path.getmtime(path)
assert timeStamp != timeStamp2
val = c.checkFileTimeStamp(path)
assert not val,repr(val)
c.setFileTimeStamp(path)
val = c.checkFileTimeStamp(path)
assert val,repr(val)
</t>
<t tx="ekr.20090128184952.3"></t>
<t tx="ekr.20090130133404.2">v = p.v
b = p.b
p.b = b
assert p.b == b
v.b = b
assert v.b == b

h = p.h
p.h = h
assert p.h == h
v.h = h
assert v.h == h

for p in c.all_positions():
    assert p.b == p.bodyString()
    assert p.v.b == p.v.bodyString()
    assert p.h == p.headString()
    assert p.v.h == p.v.headString()</t>
<t tx="ekr.20090225102051.2">import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20090225102051.3">Line 1

Last line: no newline</t>
<t tx="ekr.20090225102051.4">Line 1

Last line: no newline</t>
<t tx="ekr.20090306091634.1">tree = c.frame.tree
if hasattr(tree,'redrawCount'):
    print('tree.redrawCount:',tree.redrawCount)</t>
<t tx="ekr.20090427104851.10">if a:
    b = 'xyz'</t>
<t tx="ekr.20090427104851.11">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20090427104851.12">if a:
    b = 'xyz'</t>
<t tx="ekr.20090427104851.13">if a:
    b = 'xyz'</t>
<t tx="ekr.20090427104851.14">if a:
    b = 'xyz'</t>
<t tx="ekr.20090427104851.15">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20090427104851.16">if a:
    b = 'xyz'</t>
<t tx="ekr.20090427104851.17">if a:
    b = 'xyz'</t>
<t tx="ekr.20090427104851.18">if a:
    b = 'xyz'</t>
<t tx="ekr.20090427104851.7">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20090427104851.8">if a:
    b = 'xyz'</t>
<t tx="ekr.20090427104851.9">if a:
    b = 'xyz'</t>
<t tx="ekr.20090507084947.5152">assert p.v.fileIndex == ('ekr', '20090507084947', 5152)
</t>
<t tx="ekr.20090529115704.4396"></t>
<t tx="ekr.20090529115704.4397">import unittest

if 1:
    x = c.shadowController
else:
    import leo.core.leoShadow as leoShadow
    x = leoShadow.shadowController(c,trace=False,trace_writers=False)

suite = unittest.makeSuite(unittest.TestCase)
root = g.findNodeAnywhere(c,'@shadow-tests')
assert root, 'Node not found: @shadow-tests'

trace = False ; vrbose = False
for p in root.children_iter():
    h = p.h.strip()
    if h.startswith('@shadow-test-lax'):
        test = x.atShadowTestCase(c,p,x,lax=True)
    elif h.startswith('@shadow-test'):
        test = x.atShadowTestCase(c,p,x,lax=False)
    else:
        test = None
    if test:
        if trace and verbose: print(h)
        suite.addTest(test)
if suite:
    g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20090529115704.4398">@

All the tags should be tested at least once (equal, replace, delete, insert).

The replace, delete, insert operations should happen at least once:
    1. At the beginning of a node.
    2. In the middle of a node.
    3. At the end of a node.

For the delete and replace operators we must also test the case that the
deletion or replacement spans more than one block.
</t>
<t tx="ekr.20090529115704.4399"></t>
<t tx="ekr.20090529115704.4400"></t>
<t tx="ekr.20090529115704.4401">line 1
line 2
line 3</t>
<t tx="ekr.20090529115704.4402">line 1
line 2 changed
line 3</t>
<t tx="ekr.20090529115704.4403"></t>
<t tx="ekr.20090529115704.4404">line 1
line 2
line 3</t>
<t tx="ekr.20090529115704.4405">line 1 changed
line 2
line 3</t>
<t tx="ekr.20090529115704.4406"></t>
<t tx="ekr.20090529115704.4407">line 1
line 2
line 3</t>
<t tx="ekr.20090529115704.4408">line 1
line 2
line 3 changed</t>
<t tx="ekr.20090529115704.4409"></t>
<t tx="ekr.20090529115704.4410">line 1
line 2
line 3</t>
<t tx="ekr.20090529115704.4411">line 2
line 3</t>
<t tx="ekr.20090529115704.4412"></t>
<t tx="ekr.20090529115704.4413">line 1
line 2
line 3</t>
<t tx="ekr.20090529115704.4414">line 1
line 3</t>
<t tx="ekr.20090529115704.4415"></t>
<t tx="ekr.20090529115704.4416">line 1
line 2
line 3</t>
<t tx="ekr.20090529115704.4417">line 1
line 2</t>
<t tx="ekr.20090529115704.4418"></t>
<t tx="ekr.20090529115704.4419">line 1
line 2
line 3</t>
<t tx="ekr.20090529115704.4420">inserted line
line 1
line 2
line 3</t>
<t tx="ekr.20090529115704.4421"></t>
<t tx="ekr.20090529115704.4422">line 1
line 2
line 3</t>
<t tx="ekr.20090529115704.4423">line 1
inserted line
line 2
line 3</t>
<t tx="ekr.20090529115704.4424"></t>
<t tx="ekr.20090529115704.4425">line 1
line 2
line 3</t>
<t tx="ekr.20090529115704.4426">line 1
line 2
inserted line
line 3</t>
<t tx="ekr.20090529115704.4427"></t>
<t tx="ekr.20090529115704.4428">line 1
line 2
line 3</t>
<t tx="ekr.20090529115704.4429">line 1
line 2
line 3
inserted line</t>
<t tx="ekr.20090529115704.4430"></t>
<t tx="ekr.20090529115704.4431">@others</t>
<t tx="ekr.20090529115704.4432">node 1 line 1</t>
<t tx="ekr.20090529115704.4433">node 2 line 1</t>
<t tx="ekr.20090529115704.4434">@others</t>
<t tx="ekr.20090529115704.4435">node 1 line 1
inserted node at end of node 1</t>
<t tx="ekr.20090529115704.4436">node 2 line 1</t>
<t tx="ekr.20090529115704.4437"></t>
<t tx="ekr.20090529115704.4438">@others</t>
<t tx="ekr.20090529115704.4439">node 1 line 1</t>
<t tx="ekr.20090529115704.4440">node 2 line 1</t>
<t tx="ekr.20090529115704.4441">@others</t>
<t tx="ekr.20090529115704.4442">node 1 line 1</t>
<t tx="ekr.20090529115704.4443">inserted node at start of node 2
node 2 line 1</t>
<t tx="ekr.20090529115704.4444"></t>
<t tx="ekr.20090529115704.4445">@others</t>
<t tx="ekr.20090529115704.4446">node 1 line 1
node 1 line 2</t>
<t tx="ekr.20090529115704.4447">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4448">@others</t>
<t tx="ekr.20090529115704.4449">node 1 line 1</t>
<t tx="ekr.20090529115704.4450">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4451"></t>
<t tx="ekr.20090529115704.4452">@others</t>
<t tx="ekr.20090529115704.4453">node 1 line 1</t>
<t tx="ekr.20090529115704.4454">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4455">@others</t>
<t tx="ekr.20090529115704.4456">node 1 line 1</t>
<t tx="ekr.20090529115704.4457">node 2 line 2</t>
<t tx="ekr.20090529115704.4458"></t>
<t tx="ekr.20090529115704.4459">@others</t>
<t tx="ekr.20090529115704.4460">node 1 line 1
node 1 line 2</t>
<t tx="ekr.20090529115704.4461">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4462">@others</t>
<t tx="ekr.20090529115704.4463">node 1 line 1
node 1 line 1 changed</t>
<t tx="ekr.20090529115704.4464">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4465"></t>
<t tx="ekr.20090529115704.4466">@others</t>
<t tx="ekr.20090529115704.4467">node 1 line 1
node 1 line 2</t>
<t tx="ekr.20090529115704.4468">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4469">@others</t>
<t tx="ekr.20090529115704.4470">node 1 line 1
node 1 line 2</t>
<t tx="ekr.20090529115704.4471">node 2 line 1 changed
node 2 line 2</t>
<t tx="ekr.20090529115704.4472"></t>
<t tx="ekr.20090529115704.4473">@others</t>
<t tx="ekr.20090529115704.4474">node 1 line 1</t>
<t tx="ekr.20090529115704.4475">node 2 line 1</t>
<t tx="ekr.20090529115704.4476">@others</t>
<t tx="ekr.20090529115704.4477">node 1 line 1
inserted node 1 at end of node 1
inserted node 2 at end of node 1</t>
<t tx="ekr.20090529115704.4478">node 2 line 1</t>
<t tx="ekr.20090529115704.4479"></t>
<t tx="ekr.20090529115704.4480">@others</t>
<t tx="ekr.20090529115704.4481">node 1 line 1</t>
<t tx="ekr.20090529115704.4482">node 2 line 1</t>
<t tx="ekr.20090529115704.4483">@others</t>
<t tx="ekr.20090529115704.4484">node 1 line 1</t>
<t tx="ekr.20090529115704.4485">inserted node 1 at start of node 2
inserted node 2 at start of node 2
node 2 line 1</t>
<t tx="ekr.20090529115704.4486"></t>
<t tx="ekr.20090529115704.4487">@others</t>
<t tx="ekr.20090529115704.4488">node 1 line 1
node 1 line 2
node 1 line 3</t>
<t tx="ekr.20090529115704.4489">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4490">@others</t>
<t tx="ekr.20090529115704.4491">node 1 line 1
node 1 line 2 changed
node 1 line 3 changed</t>
<t tx="ekr.20090529115704.4492">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4493"></t>
<t tx="ekr.20090529115704.4494">@others</t>
<t tx="ekr.20090529115704.4495">node 1 line 1
node 1 line 2</t>
<t tx="ekr.20090529115704.4496">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4497">@others</t>
<t tx="ekr.20090529115704.4498">node 1 line 1
node 1 line 2</t>
<t tx="ekr.20090529115704.4499">node 2 line 1 changed
node 2 line 2 changed</t>
<t tx="ekr.20090529115704.4500"></t>
<t tx="ekr.20090529115704.4501">@others</t>
<t tx="ekr.20090529115704.4502">node 1 line 1
node 1 line 2
node 1 line 3</t>
<t tx="ekr.20090529115704.4503">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4504">@others</t>
<t tx="ekr.20090529115704.4505">node 1 line 1</t>
<t tx="ekr.20090529115704.4506">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4507"></t>
<t tx="ekr.20090529115704.4508">@others</t>
<t tx="ekr.20090529115704.4509">node 1 line 1</t>
<t tx="ekr.20090529115704.4510">node 2 line 1
node 2 line 2
node 2 line 3</t>
<t tx="ekr.20090529115704.4511">@others</t>
<t tx="ekr.20090529115704.4512">node 1 line 1</t>
<t tx="ekr.20090529115704.4513">node 2 line 3</t>
<t tx="ekr.20090529115704.4514"></t>
<t tx="ekr.20090529115704.4515">@others</t>
<t tx="ekr.20090529115704.4516">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3</t>
<t tx="ekr.20090529115704.4517">node 2 line 1
node 2 line 2
node 2 line 3</t>
<t tx="ekr.20090529115704.4518">@others</t>
<t tx="ekr.20090529115704.4519">node 1 line 1
line 1 line 3</t>
<t tx="ekr.20090529115704.4520">node 2 line 1
node 2 line 2
node 2 line 3</t>
<t tx="ekr.20090529115704.4521"></t>
<t tx="ekr.20090529115704.4522">@others</t>
<t tx="ekr.20090529115704.4523">node 1 line 1</t>
<t tx="ekr.20090529115704.4524">@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
node 2 line 2</t>
<t tx="ekr.20090529115704.4525">@others</t>
<t tx="ekr.20090529115704.4526">node 1 line 1</t>
<t tx="ekr.20090529115704.4527">node 2 line 2</t>
<t tx="ekr.20090529115704.4528"></t>
<t tx="ekr.20090529115704.4529">@others</t>
<t tx="ekr.20090529115704.4530">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3</t>
<t tx="ekr.20090529115704.4531">node 2 line 1
node 2 line 2
node 2 line 3</t>
<t tx="ekr.20090529115704.4532">@others</t>
<t tx="ekr.20090529115704.4533">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3</t>
<t tx="ekr.20090529115704.4534">node 2 line 1
node 2 line 2
node 2 line 3</t>
<t tx="ekr.20090529115704.4535"></t>
<t tx="ekr.20090529115704.4536">@others</t>
<t tx="ekr.20090529115704.4537">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim</t>
<t tx="ekr.20090529115704.4538">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4539">@others</t>
<t tx="ekr.20090529115704.4540">node 1 line 1</t>
<t tx="ekr.20090529115704.4541">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4542"># This fails because the @all read logic inserts a second verbatim, I think.</t>
<t tx="ekr.20090529115704.4543">@others</t>
<t tx="ekr.20090529115704.4544">node 1 line 1
node 1 line 2</t>
<t tx="ekr.20090529115704.4545">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4546">@others</t>
<t tx="ekr.20090529115704.4547">node 1 line 1
@verbatim
#@ should be handled by verbatim
node 1 line 2</t>
<t tx="ekr.20090529115704.4548">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20090529115704.4550">x = c.shadowController

path = x.baseDirName()
expected = g.os_path_dirname(g.os_path_abspath(g.os_path_join(c.fileName())))

# print(path)
# print(expected)

assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)</t>
<t tx="ekr.20090529115704.4551">x = c.shadowController

filename = 'xyzzy'

path = x.pathName(filename)
expected = g.os_path_abspath(g.os_path_join(x.baseDirName(),filename))

# print(path)
# print(expected)

assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)</t>
<t tx="ekr.20090529115704.4552">x = c.shadowController

filename = 'xyzzy'
path = x.dirName(filename)
expected = g.os_path_dirname(g.os_path_abspath(
    g.os_path_join(g.os_path_dirname(c.fileName()),filename)))

# print(path)
# print(expected)

assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)</t>
<t tx="ekr.20090529115704.4553">x = c.shadowController

# print(c.config.getString('shadow_subdir'))

subdir = c.config.getString('shadow_subdir') or '.leo_shadow'
prefix = c.config.getString('shadow_prefix') or ''

# print('c.fileName',c.fileName())
# print('c.relativeFileName',c.relativeFileName())

filename = 'xyzzy'
path = x.shadowPathName(filename)
expected = g.os_path_abspath(g.os_path_join(
    g.os_path_dirname(c.fileName()),subdir,prefix+filename))

if 0:
    print('prefix',prefix)
    print(path)
    print(expected)

assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)</t>
<t tx="ekr.20090529115704.4554">x = c.shadowController

subdir = c.config.getString('shadow_subdir') or '.leo_shadow'
prefix = c.config.getString('shadow_prefix') or ''

# print('c.fileName',c.fileName())
# print('c.relativeFileName',c.relativeFileName())

filename = 'xyzzy'
path = x.shadowDirName(filename)
expected = g.os_path_abspath(
    g.os_path_join(g.os_path_dirname(c.fileName()),subdir))

# print(path)
# print(expected)

assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)</t>
<t tx="ekr.20090529115704.4555">if 0: # x.rename no longer exists
    x = c.shadowController
    
    filename = x.pathName('xyzzy')
    assert not g.os_path_exists(filename)
    n = x.errors
    x.rename('xyzzy','xyzzy2',silent=True)
    assert x.errors == n+1
    assert x.last_error.startswith('can not rename')
    # print(x.last_error)</t>
<t tx="ekr.20090529115704.4556">x = c.shadowController

filename = x.pathName('xyzzy')
# print(filename)
assert not g.os_path_exists(filename)
n = x.errors
x.unlink('xyzzy',silent=True)
assert x.errors == n+1
assert x.last_error.startswith('can not delete xyzzy')
# print(x.last_error)</t>
<t tx="ekr.20090529115704.4557">import glob
import os

x = c.shadowController

@others

shadow_fn  = x.shadowPathName('unittest/xyzzy')
shadow_dir = x.shadowDirName('unittest/xyzzy')

if g.os_path_exists(shadow_fn):
    g.utils_remove(shadow_fn,verbose=True)
    assert not os.path.exists(shadow_fn),'still exists: %s' % shadow_fn

deleteShadowDir(shadow_dir)

x.makeShadowDirectory(shadow_dir)
assert os.path.exists(shadow_dir)

deleteShadowDir(shadow_dir)
</t>
<t tx="ekr.20090529115704.4558">def deleteShadowDir(shadowDir):

    if g.os_path_exists(shadow_dir):
        files = g.os_path_abspath(g.os_path_join(shadow_dir,"*.*"))
        files = glob.glob(files)
        for z in files:
            if z != shadow_dir:
                os.unlink(z)
        os.rmdir(shadow_dir)
        assert not os.path.exists(shadow_dir),'still exists: %s' % shadow_dir</t>
<t tx="ekr.20090529115704.4559">x = c.shadowController
s = 'abc'

fn = '../test/unittest/replaceFileWithStringTestFile.py'
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,fn))

x.replaceFileWithString(path,s)
f = open(path)
s2 = f.read()
f.close()
assert s == s2</t>
<t tx="ekr.20090529115704.4560">x = c.shadowController

lines1 = ('a','b','c')
lines2 = ('a','x','c')

x.show_error(
    lines1,lines2,
    message = "Test of x.show_error",
    lines1_message = "lines1",
    lines2_message = "lines2")
</t>
<t tx="ekr.20090529115704.4562">at = c.atFileCommands

# at.toString is set by the execute-script command.

f = at.openStringFile('abc')

assert f.__class__.__name__ == 'fileLikeObject'

s = 'abc'
f.write(s)
s2 = at.closeStringFile(f)

assert s == s2

# assert at.toString

</t>
<t tx="ekr.20090529115704.4563">at = c.atFileCommands
x = c.shadowController

filename = x.pathName('xyzzy')
assert not g.os_path_exists(filename)

try:
    kind,theFile = at.openForWrite(filename)
    assert kind == 'check'
    # print(repr(theFile))
    if theFile: theFile.close()

finally:
    if g.os_path_exists(filename):
        x.unlink(filename)
        assert not g.os_path_exists(filename)</t>
<t tx="ekr.20090529115704.4564">at = c.atFileCommands
x = c.shadowController

changed = c.changed
child = p.firstChild()
s = child.b

try:
    fn = 'unittest/read_test.py'
    child.setHeadString('@shadow %s' % fn)
    # shadow_fn = x.shadowPathName(fn)
    at.writeOneAtShadowNode(child,toString=False,force=True)
    at.readOneAtShadowNode(fn,child)
finally:
    child.setHeadString('@@shadow %s' % fn)
    c.setChanged(changed)
    # c.redraw_now()</t>
<t tx="ekr.20090529115704.4565">@language python
@tabwidth -4
@others
# body of @shadow test node
# The last line.
</t>
<t tx="ekr.20090529115704.4566">import os
s = 'abc'
fn = 'unitTestFile.py'
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','unittest',fn))
try:
    c.atFileCommands.replaceFileWithString(path,s)
    f = open(path)
    s2 = f.read()
    f.close()
    assert s == s2
finally:
    if g.os_path_exists(path):
        os.unlink(path)</t>
<t tx="ekr.20090529115704.4567">at = c.atFileCommands
x = c.shadowController
changed = c.changed
child = p.firstChild()
s = child.b

try:
    child.setHeadString('@shadow unittest/test_1.py')
    fn = 'unittest/test_1.py'
    shadow_fn = x.shadowPathName(fn)
    shadow_dir = x.shadowDirName(fn)
    x.makeShadowDirectory(shadow_dir)
    if g.os_path_exists(shadow_fn):
        g.utils_remove(shadow_fn,verbose=True)
    at.writeOneAtShadowNode(child,toString=True,force=True)
    assert at.startSentinelComment == '#','startSentinelComment: %s' % (
        repr(at.startSentinelComment))
    assert at.endSentinelComment == '','endSentinelComment: %s' % (
        repr(at.endSentinelComment))
    if 0:
        print('public...\n',at.public_s)
        print('private...\n',at.private_s)
    at.writeOneAtShadowNode(child,toString=False,force=True)
    assert g.os_path_exists(shadow_fn),'not found: %s' % shadow_fn
    # No need to remove this: it's in the unittest directory.
    # g.utils_remove(shadow_fn,verbose=True)
finally:

    child.setHeadString('@@shadow unittest/test_1.py')
    c.setChanged(changed)
    # c.redraw_now()</t>
<t tx="ekr.20090529115704.4568"># body of @shadow test node
# The last line.</t>
<t tx="ekr.20090529115704.4569"># This unit test should come last.

import glob
import os

x = c.shadowController

shadow_dir = x.shadowDirName('unittest/xyzzy')

if g.os_path_exists(shadow_dir):
    files = g.os_path_abspath(g.os_path_join(shadow_dir,"*.*"))
    files = glob.glob(files)
    for z in files:
        if z != shadow_dir:
            os.unlink(z)
    os.rmdir(shadow_dir)
    assert not os.path.exists(shadow_dir)
    # g.es_print('deleted directory',shadow_dir,color='red')
</t>
<t tx="ekr.20090529141856.4682"># These test are inconvenient to include in leoPy.leo
# because they would need a @mark-for-unit-tests node,
# and Alt-5 would execute all the tests.</t>
<t tx="ekr.20090529141856.4684">@language python
@tabwidth -4</t>
<t tx="ekr.20090529141856.4685"># Create unit tests in g.app.scriptDict["suite"]


import unittest
import leo.core.leoTest as leoTest

@others

suite = leoTest.makeImportExportSuite(c,"exportTests",doImport=False)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20090529141856.4686">@language plain</t>
<t tx="ekr.20090529141856.4687"></t>
<t tx="ekr.20090529141856.4688"></t>
<t tx="ekr.20090529141856.4689">saveFileDialog
test\\unittest\\output\\exportHeadlines.txt</t>
<t tx="ekr.20090529141856.4690"></t>
<t tx="ekr.20090529141856.4691">saveFileDialog
test\\unittest\\output\\flattenOutline.txt</t>
<t tx="ekr.20090529141856.4692"></t>
<t tx="ekr.20090529141856.4693">saveFileDialog
test\\unittest\\output\\weave.txt</t>
<t tx="ekr.20090529141856.4694"></t>
<t tx="ekr.20090529141856.4695">saveFileDialog
test\\unittest\\output\\outlineToNoweb.txt</t>
<t tx="ekr.20090529141856.4696"></t>
<t tx="ekr.20090529141856.4697">saveFileDialog
test\\unittest\\output\\outlineToCweb.txt</t>
<t tx="ekr.20090529141856.4698"></t>
<t tx="ekr.20090529141856.4699"># Create unit tests in g.app.scriptDict["suite"]

import unittest
import leo.core.leoTest as leoTest

@others

suite = leoTest.makeImportExportSuite(c,"importTests",doImport=True)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20090529141856.4700">@language plain</t>
<t tx="ekr.20090529141856.4701"></t>
<t tx="ekr.20090529141856.4702"></t>
<t tx="ekr.20090529141856.4703">openFileDialog
test\\unittest\\perfectImport\\formatter.py</t>
<t tx="ekr.20090529141856.4704"></t>
<t tx="ekr.20090529141856.4705">openFileDialog
core\\runLeo.py</t>
<t tx="ekr.20090529141856.4706"></t>
<t tx="ekr.20090529141856.4707">openFileDialog
test\\unittest\\input\\noweave.nw.txt</t>
<t tx="ekr.20090529141856.4708"></t>
<t tx="ekr.20090529141856.4709">openFileDialog
test\\unittest\\input\\flat.txt</t>
<t tx="ekr.20090529141856.4710"></t>
<t tx="ekr.20090529141856.4711">openFileDialog
test\\unittest\\input\\cweave.w</t>
<t tx="ekr.20090529141856.4712"></t>
<t tx="ekr.20090529141856.4713">openFileDialog
test\\unittest\\input\\testLeoAtFile.py</t>
<t tx="ekr.20090529141856.4714"></t>
<t tx="ekr.20090529141856.4715">openFileDialog
test\\unittest\\perfectImport\\formatter.py</t>
<t tx="ekr.20090529141856.4716">@tabwidth -4
@language python</t>
<t tx="ekr.20090529141856.4717"></t>
<t tx="ekr.20090529141856.4718">fileName = p.h

s = '''\
class cTestClass1 {

    int foo (int a) {
        a = 2 ;
    }

    char bar (float c) {
        ;
    }
}
'''

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4719">fileName = p.h

s = '''\
class cTestClass1 {

    int foo (int a) {
# an underindented line.
        a = 2 ;
    }

    # This should go with the next function.

    char bar (float c) {
        ;
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 1
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4720">fileName = p.h

s = '''\
class cTestClass1 {

    int foo (int a) {
        a = 2 ;
    }

    char bar (float c) {
        ;
    }
}
'''

c.importCommands.defaultImporterUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4721">fileName = p.h

s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) //  &lt;---------------------problem
{
    return true;
}
'''

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4722">fileName = p.h

s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) 
{
    return true;
} //  &lt;---------------------problem
'''

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4723">fileName = p.h

s = '''
void
aaa::bbb::doit
    (
    awk* b  // leading blank
    )
{
	assert(false); // leading tab
}

'''

g.app.unitTestDict ['expectedErrors'] = 0 # Intermixed blanks and tabs are ok for C.

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4724">fileName = p.h

s = '''\
static void
ReleaseCharSet(cset)
    CharSet *cset;
{
    ckfree((char *)cset-&gt;chars);
    if (cset-&gt;ranges) {
    ckfree((char *)cset-&gt;ranges);
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4725">fileName = p.h

s = '''\
Tcl_Obj *
Tcl_NewLongObj(longValue)
    register long longValue;	/* Long integer used to initialize the
         * new object. */
{
    return Tcl_DbNewLongObj(longValue, "unknown", 0);
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4726">fileName = p.h

s = '''\
extern  "C"
{
#include "stuff.h"
void    init(void);
#include "that.h"
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4727"></t>
<t tx="ekr.20090529141856.4728">s = '''\
namespace {
    class cTestClass1 {
        ;
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cSharpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4729">s = '''\
namespace {
class cTestClass1 {
    ;
}
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cSharpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4730">import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','big-c#-test.c#'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.cSharpUnitTest(p,s=s,fileName=fileName,showTree=False)</t>
<t tx="ekr.20090529141856.4731"></t>
<t tx="ekr.20090529141856.4732">s = '''\
;;; a.el --- Test

;; some other verbose comment
;; some other verbose comment
;; some other verbose comment

(defun abc (a1 a2)
  "Return blah blah."
  (+ 1 2))

(defun fgh (a1 a2)
  "Return blah blah."
  (- 1 2))

;;; a.el ends here
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.elispUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4733">s = '''\
;;; comment
;;; continue
;;;

(defun abc (a b)
   (+ 1 2 3))

; comm
(defun cde (a b)
   (+ 1 2 3))
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.elispUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4734"></t>
<t tx="ekr.20090529141856.4735">s = '''
unit Unit1;

interface

uses
Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
Forms,
Dialogs;

type
TForm1 = class(TForm)
procedure FormCreate(Sender: TObject);
private
{ Private declarations }
public
{ Public declarations }
end;

var
Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.FormCreate(Sender: TObject);
var
x,y: double;
begin
x:= 4;
Y := x/2;
end;

end.
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pascalUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4736"># Warning: setting atAuto=True can wipe out unit tests.</t>
<t tx="ekr.20090529141856.4737">s = '''\
NS = { 'i': 'http://www.inkscape.org/namespaces/inkscape',
      's': 'http://www.w3.org/2000/svg',
      'xlink' : 'http://www.w3.org/1999/xlink'}

tabLevels = 4  # number of defined tablevels, FIXME, could derive from template?
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4738">s = '''\
NS = { 'i': 'http://www.inkscape.org/namespaces/inkscape',
      's': 'http://www.w3.org/2000/svg',
      'xlink' : 'http://www.w3.org/1999/xlink'}

tabLevels = 4  # number of defined tablevels, FIXME, could derive from template?
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4739">s = '''\
class Index:
    """docstring"""
    @cherrypy.nocolor
    @cherrypy.expose
    def index(self):
        return "Hello world!"
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4740">s = '''\
class aClass:
    def outerDef(self):
        """docstring.
        line two."""

        def pr(*args,**keys):
            g.es_print(color='blue',*args,**keys)

        a = 3
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4741">s = '''\
"""A file consisting only of a docstring.
"""
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4742">s = '''\
class aClass:
    def def1(self):
        pass

    if False or g.unitTesting:

        def pr(*args,**keys): # reportMismatch test
            g.es_print(color='blue',*args,**keys)

        pr('input...')
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4743">s = '''\
class aClass:
    def def1(self):
        pass

    if False or g.unitTesting:

        def pr(*args,**keys): # reportMismatch test
            g.es_print(color='blue',*args,**keys)

        pr('input...')

    def def2(self):
        pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4744">@language python

# This caused PyParse.py not to be imported properly.

s = '''\

import re

if 0: # Causes the 'overindent'
   if 0:   # for throwaway debugging output
      def dump(*stuff):
        sys.__stdout__.write(" ".join(map(str, stuff)) + "\n")

for ch in "({[":
   _tran[ord(ch)] = '('

class testClass1:
    pass
# '''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4745">s = '''\
class testClass1 # no colon
    pass

def spam():
    pass
'''

g.app.unitTestDict ['expectedErrors'] = 0 # Not really an error.

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4746">s = '''\
class testClass2:
    pass
'''

tree = c.importCommands.pythonUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4747">s = '''\
class testClass1:
    """A docstring"""
    def __init__ (self):
        pass
    def f1(self):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4748">s = '''\
import leo.core.leoGlobals as g

a = 3
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4749">s = '''\

class test:

    def importFilesCommand (self,files=None,treeType=None,
        perfectImport=True,testing=False,verbose=False):
            # Not a command.  It must *not* have an event arg.

        c = self.c
        if c == None: return
        p = c.currentPosition()

    # Used by paste logic.

    def convertMoreStringToOutlineAfter (self,s,firstVnode):
        s = string.replace(s,"\\r","")
        strings = string.split(s,"\\n")
        return self.convertMoreStringsToOutlineAfter(strings,firstVnode)
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4750">s = '''\

class test:
    def spam(b):
        pass

    # Used by paste logic.

    def foo(a):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4751">s = '''\
import leo.core.leoGlobals as g

a = 3
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4752">s = '''\

class cls:
     def fun(): # one extra space.
        pass
'''

g.app.unitTestDict ['expectedErrors'] = None # No error unless we get an unexpected mismatch line.
g.app.unitTestDict ['expectedMismatchLine'] = 3 # The error happens before any lines are checked.
g.app.unitTestDict ['expectedErrorMessage'] = 'leading whitespace not consistent with @tabwidth -4'

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4753">s = '''\

class mammalProviderBase(object):
    """Root class for content providers used by DWEtree.py"""
    def __init__(self, params):
        """store reference to parameters"""
        self.params = params
    def provide(self, what):
        """default &lt;BASE&gt; value"""
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/'])
        return None

    def imagePath(self, sppdat):
        """return path to images and list of images for *species*"""
        path = 'MNMammals/imglib/Mammalia'
        for i in 'Order', 'Family', 'Genus', 'Species':
            path = os.path.join(path, sppdat['%sName' % (i,)])
        imglib = os.path.join('/var/www',path)
        imglib = os.path.join(imglib, '*.[Jj][Pp][Gg]')
        path = os.path.join('/',path)
        lst = [os.path.split(i)[1] for i in glob.glob(imglib)]
        lst.sort()
        return path, lst

class mainPages(mammalProviderBase):
    """provide content for pages in 'main' folder"""
    __parent = mammalProviderBase
    def provide(self, what):
        """add one layer to &lt;BASE&gt;"""
        ans = self.__parent.provide(self, what)
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/']+'main/')
        return ans
''' 

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4754">s = '''\

class ItasException(Exception):

    pass

def gpRun(gp, cmd, args, log = None):

    """Wrapper for making calls to the geoprocessor and reporting errors"""

    if log:

        log('gp: %s: %s\\n' % (cmd, str(args)))
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)


</t>
<t tx="ekr.20090529141856.4755">s = '''\

class emptyClass: pass

def followingDef():
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4756">s = '''\

class emptyClass: pass # comment

def followingDef(): # comment
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4757">s = '''\

class emptyClass: 

    def spam():

        """docstring line 1
under-indented docstring line"""
        pass

def followingDef(): # comment
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4758">@encoding utf-8
# leoImport.py uses unicode characters, so *this* test must have the directive above.

fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'leoImport.py'))

f = open(fileName)
s = f.read()
f.close()

g.app.unitTestDict['testingLeoImport.py'] = True

c.importCommands.pythonUnitTest(p,s=None,fileName=fileName,showTree=False)</t>
<t tx="ekr.20090529141856.4759">s = '''\
class baseScannerClass:

        """The base class for all import scanner classes."""

        def __init__ (self,importCommands,language):

            self.c = ic.c

        def createHeadline (self,parent,body,headline):
            # g.trace("parent,headline:",parent,headline)
            return p
'''

# We expect mismatches because the indentation does not match @tabwidth -4.
g.app.unitTestDict ['expectedErrors'] = None # No error unless we get an unexpected mismatch line.
g.app.unitTestDict ['expectedMismatchLine'] = 3
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4760">s = '''\
class baseScannerClass:
    def containsUnderindentedComment(self):
        a = 2
    # A true underindented comment.
        b = 3
    # This underindented comment should be placed with next function.
    def empty(self):
        pass
'''

g.app.unitTestDict ['expectedErrors'] = 0 # underindented comments are no longer an error.
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4761">s = '''\
class baseScannerClass:
    def containsUnderindentedComment(self):
        a = 2
    #
        b = 3
        # This comment is part of the present function.

    def empty(self):
        pass
'''

g.app.unitTestDict ['expectedErrors'] = 0 # underindented comments are no longer an error.
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4762">s = '''\
class aClass: # trailing comment


    def def1(self):             # trailing comment
        pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4763">s = '''\

xyz = 6 # trailing comment
pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4764">s = '''\

def foo():
    pass

def bar():
    pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4765">s = '''\

def foo():

    error("""line1
line2.
""")

    a = 5

def bar():
    pass
'''

showTree = False
keepTree = False

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=showTree)

if showTree:
    try:
        child = p.firstChild()
        n = child.numberOfChildren()
        assert n == 2, 'expected 2 children, got %s' % n
    finally:
        if keepTree:
            h = child.h
            print('h',h)
            child.setHeadString('@'+h)
        else:
            while p.hasChildren():
                p.firstChild().doDelete()
        c.redraw(p)</t>
<t tx="ekr.20090529141856.4766"></t>
<t tx="ekr.20090529141856.4767">s = '''\
interface Bicycle {
    void changeCadence(int newValue);
    void changeGear(int newValue);
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4768">s = '''\
interface Bicycle {
void changeCadence(int newValue);
void changeGear(int newValue);
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4769">import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','constants.java'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=None,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20090529141856.4770">s = '''\
/**
 * Indicates the caller's authority to perform lifecycle operations on
 */

public final class AdminPermission extends BasicPermission
{
    /**
     * Creates a new &lt;tt&gt;AdminPermission&lt;/tt&gt; object.
     */
    public AdminPermission()
    {
        super("AdminPermission");
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)

</t>
<t tx="ekr.20090529141856.4771">import sys

if sys.platform.lower().startswith('win'):


    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','AdminPermission.java'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=s,fileName=fileName,showTree=False)</t>
<t tx="ekr.20090529141856.4772">@tabwidth 8</t>
<t tx="ekr.20090529141856.4773">@language python

s = '''\
/*
 * $Header: /cvs/leo/test/unitTest.leo,v 1.247 2008/02/14 14:59:04 edream Exp $
 * 
 * Copyright (c) OSGi Alliance (2000, 2005). All Rights Reserved.
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this 
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html.
 */

package org.osgi.framework;

/**
 * A Framework exception used to indicate that a bundle lifecycle problem
 * occurred.
 * 
 * &lt;p&gt;
 * &lt;code&gt;BundleException&lt;/code&gt; object is created by the Framework to denote
 * an exception condition in the lifecycle of a bundle.
 * &lt;code&gt;BundleException&lt;/code&gt;s should not be created by bundle developers.
 * 
 * &lt;p&gt;
 * This exception is updated to conform to the general purpose exception
 * chaining mechanism.
 * 
 * @version $Revision: 1.247 $
 */

public class BundleException extends Exception {
	static final long	serialVersionUID	= 3571095144220455665L;
	/**
	 * Nested exception.
	 */
	private Throwable	cause;

	/**
	 * Creates a &lt;code&gt;BundleException&lt;/code&gt; that wraps another exception.
	 * 
	 * @param msg The associated message.
	 * @param cause The cause of this exception.
	 */
	public BundleException(String msg, Throwable cause) {
		super(msg);
		this.cause = cause;
	}
}

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4774"></t>
<t tx="ekr.20090529141856.4775">@language javascript

// regexps that look like section references.

{
	name: "macro",
	match: "&lt;&lt;",
	lookaheadRegExp: /&lt;&lt;([^&gt;\s]+)(?:\s*)((?:[^&gt;]|(?:&gt;(?!&gt;)))*)&gt;&gt;/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch &amp;&amp; lookaheadMatch.index == w.matchStart &amp;&amp; lookaheadMatch[1]) {
			w.nextMatch = this.lookaheadRegExp.lastIndex;
			invokeMacro(w.output,lookaheadMatch[1],lookaheadMatch[2],w,w.tiddler);
		}
	}
},

// Comments that look like section references.

// &lt;&lt;gradient [[tiddler name]] vert|horiz rgb rgb rgb rgb... &gt;&gt;

config.macros.gradient.handler = function(place,macroName,params,wikifier)
{
	var panel = wikifier ? createTiddlyElement(place,"div",null,"gradient") : place;
	panel.style.position = "relative";
	panel.style.overflow = "hidden";
	panel.style.zIndex = "0";
	if(wikifier) {
		var styles = config.formatterHelpers.inlineCssHelper(wikifier);
		config.formatterHelpers.applyCssHelper(panel,styles);
	}
	var colours = [];
	for(var t=1; t&lt;params.length; t++) {
		var c = new RGB(params[t]);
		if(c)
			colours.push(c);
	}
	drawGradient(panel,params[0] != "vert",colours);
	if(wikifier)
		wikifier.subWikify(panel,"&gt;&gt;");
	if(document.all) {
		panel.style.height = "100%";
		panel.style.width = "100%";
	}
};

// @Deprecated: Use &lt;br&gt; or &lt;br /&gt; instead of &lt;&lt;br&gt;&gt;
config.macros.br = {};
config.macros.br.handler = function(place)
{
	createTiddlyElement(place,"br");
};
</t>
<t tx="ekr.20090529141856.4776">s = '''\

String.prototype.toJSONString = function()
{
    if(/["\\\\\\x00-\\x1f]/.test(this))
		return '"' + this.replace(/([\\x00-\\x1f\\"])/g,replaceFn) + '"';

	return '"' + this + '"';
};

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4777">    s = '''\

// Convert a string to it's JSON representation by encoding control characters, double quotes and backslash. See json.org
String.prototype.toJSONString = function()
{
	var m = {
		'\\b': '\\\\b',
		'\\f': '\\\\f',
		'\\n': '\\\\n',
		'\\r': '\\\\r',
		'\\t': '\\\\t',
		'"' : '\\\\"',
		'\\\\': '\\\\\\\\'
		};
	var replaceFn = function(a,b) {
		var c = m[b];
		if(c)
			return c;
		c = b.charCodeAt();
		return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
		};
    if(/["\\\\\\x00-\\x1f]/.test(this))
		return '"' + this.replace(/([\\x00-\\x1f\\"])/g,replaceFn) + '"';

	return '"' + this + '"';
};

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4778">s = '''\

// Restarting
function restart()
{
	invokeParamifier(params,"onstart");
	if(story.isEmpty()) {
		var tiddlers = store.filterTiddlers(store.getTiddlerText("DefaultTiddlers"));
		for(var t=0; t&lt;tiddlers.length; t++) {
			story.displayTiddler("bottom",tiddlers[t].title);
		}
	}
	window.scrollTo(0,0);
}

'''

# Double each backslash (they are in a docstring).
# chars = [z for z in s]
# s = []
# for z in char:
    # if z == '\\': s.append('\\\\')
    # else: s.append(z)
# s = s.join('')

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4779">f = open('test.js')
s = f.read()
f.close()

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4780"></t>
<t tx="ekr.20090529141856.4781">s = '''\
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/head&gt;
&lt;body class='bodystring'&gt;
&lt;div id='bodydisplay'&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.xmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4782">@first # -*- coding: utf-8 -*-

import leo.core.leoImport as leoImport
ic = c.importCommands
runner = leoImport.baseScannerClass(ic,atAuto=True,language='python')
runner.root = p.copy()

g.app.unitTestDict ['expectedMismatchLine'] = 1

s1 = g.toUnicode('line , ,  ,  end',encoding='utf-8')
s2 = g.toUnicode('line , ,  ,  x end',encoding='utf-8')

ok = runner.checkTrialWrite(s1=s1,s2=s2)

assert ok
</t>
<t tx="ekr.20090529141856.4783">c.contractAllHeadlines()</t>
<t tx="ekr.20090529141856.4784"></t>
<t tx="ekr.20090529141856.4785">s = '''\
.. toc

====
top
====

The top section

section 1
---------

section 1, line 1
--
selction 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.rstUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4786">s = '''\
.. toc

top
====

The top section

section 1
---------

section 1, line 1
--
selction 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.rstUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4787">s = '''\
.. toc

top
-------------

The top section
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.rstUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4788">s = '''\
.. toc

======
top
======

The top section
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.rstUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4789">s = '''\
.. toc

.. The section name contains trailing whitespace.

======
top 
======

The top section.
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.rstUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20090529141856.4790">import leo.core.leoImport as leoImport
ic = c.importCommands
runner = leoImport.baseScannerClass(ic,atAuto=True,language='python')
i = 0
lines1 = ['abc',]
lines2 = ['xyz',]

g.app.unitTestDict ['expectedErrors'] = 1
g.app.unitTestDict ['expectedMismatchLine'] = 1

runner.compareHelper(lines1,lines2,i,strict=True)
</t>
<t tx="ekr.20090529141856.4791">import leo.core.leoImport as leoImport
ic = c.importCommands
runner = leoImport.baseScannerClass(ic,atAuto=True,language='java')
runner.tab_width = -4
i = 0
lines1 = ['abc',]
lines2 = [' abc',]

# g.unitTesting = False # force the warning.

g.app.unitTestDict ['expectedErrors'] = 0
g.app.unitTestDict ['expectedMismatchLine'] = 1

runner.compareHelper(lines1,lines2,i,strict=False)</t>
<t tx="ekr.20090529141856.4792">s = '''\
    a
\tb
'''

import leo.core.leoImport as leoImport
ic = c.importCommands
runner = leoImport.pythonScanner(c.importCommands,atAuto=False)
runner.tab_width = -4
runner.regularizeWhitespace(s)
assert runner.errors == 1</t>
<t tx="ekr.20090529141856.4793">d = g.app.extra_extension_dict

for ext in g.app.extension_dict.keys():
    language =  c.importCommands.languageForExtension(ext)
    language2 = c.importCommands.languageForExtension('.'+ext)
    assert language == language2

    # Now a many-one relationship.
    if language:
        # Do not test extensions that have 'none' as the value of d.get(ext)
        # Otherwise, test only d.get(ext).
        language2 = d.get(ext)
        if language2 in ('None','none'):  continue
        if language2: language = language2
        # Made-up languages do not have mode files.
        if not language.endswith('_language') and language not in ('autohotkey','rest',):
            path = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
            assert g.os_path_exists(path), 'for ext=%s does not exist: %s' % (ext,path)

    if 0:
        if language is None:
            print('no language for ext=%s' % (ext))
</t>
<t tx="ekr.20090608174319.4791"># This causes trouble if executed quickly after the add-editor command.
# Presumably this is a timing condition that will never happen in practice.

if 0:
    c.frame.body.deleteEditor()</t>
<t tx="ekr.20090615053403.4876"></t>
<t tx="ekr.20090615053403.4877">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4878">@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
continues */

More plain text.</t>
<t tx="ekr.20090615053403.4879">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4880">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="ekr.20090615053403.4881">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4882">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="ekr.20090615053403.4883">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4884">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield</t>
<t tx="ekr.20090615053403.4885">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4886">@language css
/* New in 4.2. */

/*html tags*/
address, applet, area, a, base, basefont,
big, blockquote, body, br, b, caption, center,
cite, code, dd, dfn, dir, div, dl, dt, em, font,
form, h1, h2, h3, h4, h5, h6, head, hr, html, img,
input, isindex, i, kbd, link, li, link, map, menu,
meta, ol, option, param, pre, p, samp,
select, small, span, strike, strong, style, sub, sup,
table, td, textarea, th, title, tr, tt, ul, u, var,
/*units*/
mm, cm, in, pt, pc, em, ex, px,
/*colors*/
aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, yellow, white,
/*important directive*/
!important,
/*font rules*/
font, font-family, font-style, font-variant, font-weight, font-size,
/*font values*/
cursive, fantasy, monospace, normal, italic, oblique, small-caps,
bold, bolder, lighter, medium, larger, smaller,
serif, sans-serif,
/*background rules*/
background, background-color, background-image, background-repeat, background-attachment, background-position,
/*background values*/
contained, none, top, center, bottom, left, right, scroll, fixed,
repeat, repeat-x, repeat-y, no-repeat,
/*text rules*/
word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, text-transform, text-shadow, unicode-bidi, line-height,
/*text values*/
normal, none, underline, overline, blink, sub, super, middle, top, text-top, text-bottom,
capitalize, uppercase, lowercase, none, left, right, center, justify,
line-through,
/*box rules*/
margin, margin-top, margin-bottom, margin-left, margin-right,
margin, padding-top, padding-bottom, padding-left, padding-right,
border, border-width, border-style, border-top, border-top-width, border-top-style, border-bottom, border-bottom-width, border-bottom-style, border-left, border-left-width, border-left-style, border-right, border-right-width, border-right-style, border-color,
/*box values*/
width, height, float, clear,
auto, thin, medium, thick, left, right, none, both,
none, dotted, dashed, solid, double, groove, ridge, inset, outset,
/*display rules*/
display, white-space, 
min-width, max-width, min-height, max-height,
outline-color, outline-style, outline-width,
/*display values*/
run-in, inline-block, list-item, block, inline, none, normal, pre, nowrap, table-cell, table-row, table-row-group, table-header-group, inline-table, table-column, table-column-group, table-cell, table-caption
/*list rules*/
list-style, list-style-type, list-style-image, list-style-position,
/*list values*/
disc, circle, square, decimal, decimal-leading-zero, none,
lower-roman, upper-roman, lower-alpha, upper-alpha, lower-latin, upper-latin,
/*table rules*/
border-collapse, caption-side,
/*table-values*/
empty-cells, table-layout,
/*misc values/rules*/
counter-increment, counter-reset,
marker-offset, z-index,
cursor, direction, marks, quotes,
clip, content, orphans, overflow, visibility,
/*aural rules*/
pitch, range, pitch-during, cue-after, pause-after, cue-before, pause-before, speak-header, speak-numeral, speak-punctuation, speed-rate, play-during, voice-family,
/*aural values*/
stress, azimuth, elevation, pitch, richness, volume,
page-break, page-after, page-inside</t>
<t tx="ekr.20090615053403.4887">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4888">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section references are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="ekr.20090615053403.4889">&lt;&lt; section def &gt;&gt;=

    my \c code goes here // This is \LaTeX text
    /* This is also \LaTeX text */</t>
<t tx="ekr.20090615053403.4890">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4891">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20090615053403.4892">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4893">@language erlang

halt()

-module()</t>
<t tx="ekr.20090615053403.4894">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4895">@language forth

\ tiny demo of Leo forth syntax colouring

: some-forth-word ( x1 x2 -- x3 ) \ blue :, black/bold some-forth-word
   label: y  \ blue label:
   asm[ s" some string" type ]asm cr
   asm[ abc ]asm
   a
   s" abc "
   s" abc"
   a
   tty" abc "
   lcd2" abc "
   until

@ test
@c

{ abc }

a b @ c

asm[ abc ]asm

.( ab ) \ a string

: foo [ .s ] ;

   [ a b c
   x y z]
;</t>
<t tx="ekr.20090615053403.4896">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4897">@language html

b = "cd"
d
</t>
<t tx="ekr.20090615053403.4898">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4899">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</t>
<t tx="ekr.20090615053403.4900">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4901">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""</t>
<t tx="ekr.20090615053403.4902">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4903">@ doc part
@c

@language java /* Colored by match_leo_keyword: tag = leoKeyword. */

@whatever /* Colored by java match_following rule: tag = keyword4. */

/** A javadoc: tag = comment3 */

/** &lt;!-- comment --&gt; tag = comment1. */

/** @see tag = label */</t>
<t tx="ekr.20090615053403.4904">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4905">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}

The following should be colored:

\documentclass{report}

The following 2-letter words should be colored, regardless of what follows:

\(\)\{\}\@
\(abc\)abc\{abc\}abc\@abc</t>
<t tx="ekr.20090615053403.4906">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4907">@language lisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20090615053403.4908">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4909">@language perl

# From a perl tutorial.

print 'Hello world.';		# Print a message

$a = $b;	# Assign $b to $a

@food  = ("apples", "pears", "eels");

$grub = pop(@food);	# Now $grub = "eels"

$#food

@lines = &lt;INFO&gt;;

#!/usr/local/bin/perl
print "Password? ";		# Ask for input
$a = &lt;STDIN&gt;;			# Get input
chop $a;			# Remove the newline at end
while ($a ne "fred")		# While input is wrong...
{
    print "sorry. Again? ";	# Ask again
    $a = &lt;STDIN&gt;;		# Get input again
    chop $a;			# Chop off newline again
}

if ($sentence =~ /under/)
{
	print "We're talking about rugby\\n";
}

$sentence =~ s/london/London/

$_ = "Capes:Geoff::Shot putter:::Big Avenue";
@personal = split(/:/);

foreach $age (values %ages)
{
	print "Somebody is $age\\n";
}

&amp;mysubroutine;		# Call the subroutine
&amp;mysubroutine($_);	# Call it with a parameter
&amp;mysubroutine(1+2, $_);	# Call it with two parameters

sub inside
{
	local($a, $b);			# Make local variables
	($a, $b) = ($_[0], $_[1]);	# Assign values
	$a =~ s/ //g;			# Strip spaces from
	$b =~ s/ //g;			#   local variables
	($a =~ /$b/ || $b =~ /$a/);	# Is $b inside $a
					#   or $a inside $b?
}</t>
<t tx="ekr.20090615053403.4910">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4911">@language php
@ doc
This is a doc part.
@c

and or
array
array()
/* Multi-line comment
*/
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
&lt;?PHP and or array() ?&gt;</t>
<t tx="ekr.20090615053403.4912">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4913">@language plsql

"a string"
-- reserved keywords
ABORT,
abort,
ACceSS,
access,
add,
all,
allocate,
alter,
analyze,
and,
any,
archive,
archivelog,
array,
arraylen,
as,
asc,
assert,
assign,
at,
audit,
authorization,
avg,
backup,
base_table,
become,
before,
begin,
between,
binary_integer,
block,
body,
boolean,
by,
cache,
cancel,
cascade,
case,
change,
char,
char_base,
character,
check,
checkpoint,
close,
cluster,
clusters,
cobol,
colauth,
column,
columns,
comment,
commit,
compile,
compress,
connect,
constant,
constraint,
constraints,
contents,
continue,
controlfile,
count,
crash,
create,
current,
currval,
cursor,
cycle,
data_base,
database,
datafile,
date,
dba,
debugoff,
debugon,
dec,
decimal,
declare,
default,
definition,
delay,
delete,
delta,
desc,
digits,
disable,
dismount,
dispose,
distinct,
distinct,
do,
double,
drop,
drop,
dump,
each,
else,
else,
elsif,
enable,
end,
end,
entry,
escape,
events,
except,
exception,
exception_init,
exceptions,
exclusive,
exec,
execute,
exists,
exists,
exit,
explain,
extent,
externally,
false,
fetch,
fetch,
file,
float,
float,
flush,
for,
for,
force,
foreign,
form,
fortran,
found,
freelist,
freelists,
from,
from,
function,
generic,
go,
goto,
grant,
group,
groups,
having,
identified,
if,
immediate,
in,
including,
increment,
index,
indexes,
indicator,
initial,
initrans,
insert,
instance,
int,
integer,
intersect,
into,
is,
key,
language,
layer,
level,
like,
limited,
link,
lists,
lock,
logfile,
long,
loop,
manage,
manual,
max,
maxdatafiles,
maxextents,
maxinstances,
maxlogfiles,
maxloghistory,
maxlogmembers,
maxtrans,
maxvalue,
min,
minextents,
minus,
minvalue,
mlslabel,
mod,
mode,
modify,
module,
mount,
natural,
new,
new,
next,
nextval,
noarchivelog,
noaudit,
nocache,
nocompress,
nocycle,
nomaxvalue,
nominvalue,
none,
noorder,
noresetlogs,
normal,
nosort,
not,
notfound,
nowait,
null,
number,
number_base,
numeric,
of,
off,
offline,
old,
on,
online,
only,
open,
open,
optimal,
option,
or,
order,
others,
out,
own,
package,
package,
parallel,
partition,
pctfree,
pctincrease,
pctused,
plan,
pli,
positive,
pragma,
precision,
primary,
prior,
private,
private,
privileges,
procedure,
procedure,
profile,
public,
quota,
raise,
range,
raw,
read,
real,
record,
recover,
references,
referencing,
release,
remr,
rename,
resetlogs,
resource,
restricted,
return,
reuse,
reverse,
revoke,
role,
roles,
rollback,
row,
rowid,
rowlabel,
rownum,
rows,
rowtype,
run,
savepoint,
schema,
scn,
section,
segment,
select,
select,
separate,
sequence,
session,
set,
set,
share,
shared,
size,
size,
smallint,
smallint,
snapshot,
some,
sort,
space,
sql,
sqlbuf,
sqlcode,
sqlerrm,
sqlerror,
sqlstate,
start,
start,
statement,
statement_id,
statistics,
stddev,
stop,
storage,
subtype,
successful,
sum,
sum,
switch,
synonym,
sysdate,
system,
tabauth,
table,
tables,
tables,
tablespace,
task,
temporary,
terminate,
then,
thread,
time,
to,
tracing,
transaction,
trigger,
triggers,
true,
truncate,
type,
uid,
under,
union,
unique,
unlimited,
until,
update,
use,
user,
using,
validate,
values,
varchar,
varchar2,
variance,
view,
views,
when,
whenever,
where,
while,
with,
work,
write,
xor</t>
<t tx="ekr.20090615053403.4914">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4915">@language html

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;
&lt;&lt; remarks &gt;&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" /&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="#" /&gt;
    &lt;/PROPS&gt;
    &lt;RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
        &lt;&lt; comments &gt;&gt;
        &lt;&lt; literals &gt;&gt;
        &lt;&lt; operators &gt;&gt;
        &lt;MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE"&gt;(&lt;/MARK_PREVIOUS&gt;
        &lt;&lt; keywords &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="ekr.20090615053403.4916">&lt;!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by --&gt;
&lt;!-- Jonathan Revusky --&gt;

&lt;!-- Modified 19-Jul-00 by Ivan Frohne to: --&gt;
&lt;!--  (a) implement 'indentOnEnter'; --&gt;
&lt;!--  (b) indent next line automatically after control structures followed --&gt;
&lt;!--	  by ':'; --&gt;
&lt;!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; --&gt;
&lt;!--  (d) add TYPE FUNCTION identified by a following '(' --&gt;
&lt;!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); --&gt;
&lt;!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and --&gt;
&lt;!--  (g) add all builtin functions, builtin exceptions, --&gt;
&lt;!--	  builtin type methods, File object methods, and special type --&gt;
&lt;!--	  attributes as TYPE KEYWORD3. --&gt;</t>
<t tx="ekr.20090615053403.4917">&lt;!-- Comment --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;#&lt;/EOL_SPAN&gt;

&lt;!-- Triple-quotes --&gt;
&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;"""&lt;/BEGIN&gt;
    &lt;END&gt;"""&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;'''&lt;/BEGIN&gt;
    &lt;END&gt;'''&lt;/END&gt;
&lt;/SPAN&gt;</t>
<t tx="ekr.20090615053403.4918">&lt;!-- Standard literals --&gt;
&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;"&lt;/BEGIN&gt;
    &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;'&lt;/BEGIN&gt;
    &lt;END&gt;'&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="ekr.20090615053403.4919">&lt;SEQ TYPE="OPERATOR"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;%&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;~&lt;/SEQ&gt;</t>
<t tx="ekr.20090615053403.4920">&lt;KEYWORDS&gt;
    &lt;&lt; reserved words &gt;&gt;
    &lt;&lt; builtins &gt;&gt;
    &lt;&lt; exceptions &gt;&gt;
    &lt;&lt; types &gt;&gt;
&lt;/KEYWORDS&gt;</t>
<t tx="ekr.20090615053403.4921">&lt;!--  Reserved Words  --&gt;
&lt;KEYWORD1&gt;and&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;as&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;assert&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;break&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;class&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;continue&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;def&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;del&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;elif&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;except&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;exec&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;finally&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;for&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;from&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;global&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;import&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;in&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;is&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;lambda&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;not&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;or&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;pass&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;print&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;raise&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;return&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;try&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;while&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;yield&lt;/KEYWORD1&gt;</t>
<t tx="ekr.20090615053403.4922">&lt;!-- builtins --&gt;
&lt;KEYWORD2&gt;abs&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;apply&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;bool&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;buffer&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;callable&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;chr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;classmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;cmp&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;coerce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;compile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;complex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;delattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dict&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dir&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;divmod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;eval&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;execfile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;file&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;filter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;float&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;getattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;globals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hasattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hash&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;id&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;int&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;intern&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;isinstance&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;issubclass&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;iter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;len&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;list&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;locals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;long&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;map&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;max&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;min&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;object&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;oct&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;open&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;ord&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;pow&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;property&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;range&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;raw_input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reduce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reload&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;repr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;round&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;setattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;slice&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;staticmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;str&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;super&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;tuple&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;type&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unichr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unicode&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;vars&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;xrange&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;zip&lt;/KEYWORD2&gt;</t>
<t tx="ekr.20090615053403.4923">&lt;!-- exceptions --&gt;
&lt;KEYWORD3&gt;ArithmeticError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AssertionError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AttributeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DeprecationWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EOFError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EnvironmentError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Exception&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatingPointError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IOError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ImportError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndentationError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndexError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyboardInterrupt&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LookupError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MemoryError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NameError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplemented&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplementedError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OSError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ReferenceError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StandardError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StopIteration&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemExit&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TabError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundLocalError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UserWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ValueError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Warning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;WindowsError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ZeroDivisionError&lt;/KEYWORD3&gt;</t>
<t tx="ekr.20090615053403.4924">&lt;!-- types (from types module) --&gt;
&lt;KEYWORD3&gt;BufferType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinFunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ClassType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;CodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ComplexType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictProxyType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictionaryType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EllipsisType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FileType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FrameType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;GeneratorType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;InstanceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IntType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LambdaType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ListType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LongType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ModuleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NoneType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ObjectType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SliceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringTypes&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TracebackType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TupleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;XRangeType&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;False&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;None&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;True&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;__abs__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__add__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__all__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__author__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__bases__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__builtins__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__call__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__class__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__cmp__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__coerce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__contains__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__debug__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__del__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__dict__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__div__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__divmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__doc__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__eq__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__file__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__float__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__floordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__future__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ge__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattribute__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__gt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hash__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hex__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iadd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__import__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__imul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__init__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__int__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__invert__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iter__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__le__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__len__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__long__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__members__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__metaclass__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mro__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__name__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ne__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__neg__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__new__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__nonzero__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__oct__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__or__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__path__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pos__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__radd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdivmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__reduce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__repr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rfloordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rlshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ror__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rpow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rrshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rsub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rtruediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rxor__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__self__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__slots__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__str__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__sub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__truediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__version__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__xor__&lt;/KEYWORD3&gt;</t>
<t tx="ekr.20090615053403.4925">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4926">@language plsql

"a string"
-- reserved keywords
abort
accept,
access,
add,
admin,
after,
all,
allocate,
alter,
analyze,
and,
any,
archive,
archivelog,
array,
arraylen,
as,
asc,
assert,
assign,
at,
audit,
authorization,
avg,
backup,
base_table,
become,
before,
begin,
between,
binary_integer,
block,
body,
boolean,
by,
cache,
cancel,
cascade,
case,
change,
char,
char_base,
character,
check,
checkpoint,
close,
cluster,
clusters,
cobol,
colauth,
column,
columns,
comment,
commit,
compile,
compress,
connect,
constant,
constraint,
constraints,
contents,
continue,
controlfile,
count,
crash,
create,
current,
currval,
cursor,
cycle,
data_base,
database,
datafile,
date,
dba,
debugoff,
debugon,
dec,
decimal,
declare,
default,
definition,
delay,
delete,
delta,
desc,
digits,
disable,
dismount,
dispose,
distinct,
distinct,
do,
double,
drop,
drop,
dump,
each,
else,
else,
elsif,
enable,
end,
end,
entry,
escape,
events,
except,
exception,
exception_init,
exceptions,
exclusive,
exec,
execute,
exists,
exists,
exit,
explain,
extent,
externally,
false,
fetch,
fetch,
file,
float,
float,
flush,
for,
for,
force,
foreign,
form,
fortran,
found,
freelist,
freelists,
from,
from,
function,
generic,
go,
goto,
grant,
group,
groups,
having,
identified,
if,
immediate,
in,
including,
increment,
index,
indexes,
indicator,
initial,
initrans,
insert,
instance,
int,
integer,
intersect,
into,
is,
key,
language,
layer,
level,
like,
limited,
link,
lists,
lock,
logfile,
long,
loop,
manage,
manual,
max,
maxdatafiles,
maxextents,
maxinstances,
maxlogfiles,
maxloghistory,
maxlogmembers,
maxtrans,
maxvalue,
min,
minextents,
minus,
minvalue,
mlslabel,
mod,
mode,
modify,
module,
mount,
natural,
new,
new,
next,
nextval,
noarchivelog,
noaudit,
nocache,
nocompress,
nocycle,
nomaxvalue,
nominvalue,
none,
noorder,
noresetlogs,
normal,
nosort,
not,
notfound,
nowait,
null,
number,
number_base,
numeric,
of,
off,
offline,
old,
on,
online,
only,
open,
open,
optimal,
option,
or,
order,
others,
out,
own,
package,
package,
parallel,
partition,
pctfree,
pctincrease,
pctused,
plan,
pli,
positive,
pragma,
precision,
primary,
prior,
private,
private,
privileges,
procedure,
procedure,
profile,
public,
quota,
raise,
range,
raw,
read,
real,
record,
recover,
references,
referencing,
release,
remr,
rename,
resetlogs,
resource,
restricted,
return,
reuse,
reverse,
revoke,
role,
roles,
rollback,
row,
rowid,
rowlabel,
rownum,
rows,
rowtype,
run,
savepoint,
schema,
scn,
section,
segment,
select,
select,
separate,
sequence,
session,
set,
set,
share,
shared,
size,
size,
smallint,
smallint,
snapshot,
some,
sort,
space,
sql,
sqlbuf,
sqlcode,
sqlerrm,
sqlerror,
sqlstate,
start,
start,
statement,
statement_id,
statistics,
stddev,
stop,
storage,
subtype,
successful,
sum,
sum,
switch,
synonym,
sysdate,
system,
tabauth,
table,
tables,
tables,
tablespace,
task,
temporary,
terminate,
then,
thread,
time,
to,
tracing,
transaction,
trigger,
triggers,
true,
truncate,
type,
uid,
under,
union,
unique,
unlimited,
until,
update,
use,
user,
using,
validate,
values,
varchar,
varchar2,
variance,
view,
views,
when,
whenever,
where,
while,
with,
work,
write,
xor</t>
<t tx="ekr.20090615053403.4927">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4928">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""

def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c)
    # Copy the headline and icon values v.copyNode(root,v)
    # Copy the rest of tree.
    v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v = leoNodes.vnode(c)
        v = v.threadNext()
    return result</t>
<t tx="ekr.20090615053403.4929">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4930">@language r

x &lt;- rnorm(10) 

vv &lt;- function(z) return(z) 

def python_funct(uu): 
return uu</t>
<t tx="ekr.20090615053403.4931">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4932">' New in 4.2.
@language rapidq
' a comment.

$APPTYPE,$DEFINE,$ELSE,$ENDIF,$ESCAPECHARS,$IFDEF,$IFNDEF,
$INCLUDE,$MACRO,$OPTIMIZE,$OPTION,$RESOURCE,$TYPECHECK,$UNDEF,
ABS,ACOS,ALIAS,AND,AS,ASC,ASIN,ATAN,ATN,BIN$,BIND,BYTE,
CALL,CALLBACK,CALLFUNC,CASE,CEIL,CHDIR,CHDRIVE,CHR$,CINT,
CLNG,CLS,CODEPTR,COMMAND$,COMMANDCOUNT,CONSOLE,CONST,CONSTRUCTOR,
CONVBASE$,COS,CREATE,CSRLIN,CURDIR$,DATA,DATE$,DEC,DECLARE,
DEFBYTE,DEFDBL,DEFDWORD,DEFINT,DEFLNG,DEFSHORT,DEFSNG,DEFSTR,
DEFWORD,DELETE$,DIM,DIR$,DIREXISTS,DO,DOEVENTS,DOUBLE,DWORD,
ELSE,ELSEIF,END,ENVIRON,ENVIRON$,EVENT,EXIT,EXP,EXTENDS,
EXTRACTRESOURCE,FIELD$,FILEEXISTS,FIX,FLOOR,FOR,FORMAT$,FRAC,
FUNCTION,FUNCTIONI,GET$,GOSUB,GOTO,HEX$,IF,INC,INITARRAY,
INKEY$,INP,INPUT,INPUT$,INPUTHANDLE,INSERT$,INSTR,INT,INTEGER,
INV,IS,ISCONSOLE,KILL,KILLMESSAGE,LBOUND,LCASE$,LEFT$,LEN,
LFLUSH,LIB,LIBRARYINST,LOCATE,LOG,LONG,LOOP,LPRINT,LTRIM$,
MEMCMP,MESSAGEBOX,MESSAGEDLG,MID$,MKDIR,MOD,MOUSEX,MOUSEY,
NEXT,NOT,OFF,ON,OR,OUT,OUTPUTHANDLE,PARAMSTR$,PARAMSTRCOUNT,
PARAMVAL,PARAMVALCOUNT,PCOPY,PEEK,PLAYWAV,POKE,POS,POSTMESSAGE,
PRINT,PROPERTY,QUICKSORT,RANDOMIZE,REDIM,RENAME,REPLACE$,
REPLACESUBSTR$,RESOURCE,RESOURCECOUNT,RESTORE,RESULT,RETURN,
REVERSE$,RGB,RIGHT$,RINSTR,RMDIR,RND,ROUND,RTRIM$,RUN,
SCREEN,SELECT,SENDER,SENDMESSAGE,SETCONSOLETITLE,SGN,SHELL,
SHL,SHORT,SHOWMESSAGE,SHR,SIN,SINGLE,SIZEOF,SLEEP,SOUND,
SPACE$,SQR,STACK,STATIC,STEP,STR$,STRF$,STRING,STRING$,
SUB,SUBI,SWAP,TALLY,TAN,THEN,TIME$,TIMER,TO,TYPE,UBOUND,
UCASE$,UNLOADLIBRARY,UNTIL,VAL,VARIANT,VARPTR,VARPTR$,VARTYPE,
WEND,WHILE,WITH,WORD,XOR</t>
<t tx="ekr.20090615053403.4933">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4934">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="ekr.20090615053403.4935">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4936">@language rest

@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

. Links used in this document...

.. _`Pmw`:                  http://pmw.sourceforge.net/
.. _run:                    `Running Leo`_

.. WARNING: image targets may not have upper case letters!

.. |back| image:: arrow_lt.gif
    :target: FAQ.html

.. |leo| image:: leo.gif
    :target: front.html

.. |next| image:: arrow_rt.gif
    :target: intro.html

|back| |leo| |next|

###########################
Chapter 1: Installing Leo
###########################

This chapter tells how to install and run Leo.

**Important**:

If you have *any* problems installing Leo,
please ask for help on Leo's help forum:

.. contents::

**Windows**
    If you have `associated .leo files with Leo`_ you may run Leo by double-clicking any .leo file.
    You can also use a batch file.
    Put the following .bat file in c:\\Windows::

        cd c:\prog\LeoCVS\leo
        c:\python22\python c:\prog\LeoCVS\leo\leo.py %1

-   Download the latest version of Leo from `Leo's download page`_.

-   In Windows 2K or XP, go to ``Start-&gt;Settings-&gt;Control panel``, open the ``Folder Options`` tab.

    **Warning**: When building Tcl on Linux, do **not** specify
    "--enable-threads".
    Only use Tcl with the default "threads not enabled" case.

-------------

|back| |leo| |next|</t>
<t tx="ekr.20090615053403.4937">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4938"># New in 4.2.

@language shell

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait</t>
<t tx="ekr.20090615053403.4939">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4940">@language shellscript

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait</t>
<t tx="ekr.20090615053403.4941">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4942">@language html

&lt;!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ --&gt;

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="%" /&gt;
    &lt;/PROPS&gt;

    &lt;RULES&gt;
        &lt;&lt; general rules &gt;&gt;
    &lt;/RULES&gt;

    &lt;RULES SET="MATH" DEFAULT="MARKUP"&gt;
        &lt;&lt; math rules &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="ekr.20090615053403.4943">&lt;!-- $$...$$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$$&lt;/BEGIN&gt;
    &lt;END&gt;$$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- $...$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$&lt;/BEGIN&gt;
    &lt;END&gt;$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- \[...\] (LaTeX math mode) --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;\[&lt;/BEGIN&gt;
    &lt;END&gt;\]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD1"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="OPERATOR"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;]&lt;/SEQ&gt;</t>
<t tx="ekr.20090615053403.4944">&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD3"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;)&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;(&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;]&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;~&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;.&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;,&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;?&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;:&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;'&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;"&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;`&lt;/SEQ&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;</t>
<t tx="ekr.20090615053403.4945">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4946"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text"""

if 1 and 2:
    pass

print(g.app().loadDir)</t>
<t tx="ekr.20090615053403.4947">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4948"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""


if 1 and 2:
    pass

print(g.app().loadDir)
</t>
<t tx="ekr.20090615053403.4949">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4950"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""

if 1 and 2:
    pass</t>
<t tx="ekr.20090615053403.4951">&lt;&lt; test defined &gt;&gt;</t>
<t tx="ekr.20090615053403.4952">pass</t>
<t tx="ekr.20090615053403.4953">try:
    mode = c.frame.body.colorizer.modes.get('python')
    mode.keywords['as'] = 1 # append the keyword, colorize with 'keyword1' tag.
except AttributeError:
    pass # modes only exists for new colorizer.</t>
<t tx="ekr.20090615053403.4954"># This will work regardless of where this method is.
@language python

language = g.findLanguageDirectives(c,p)
assert language == 'python','got:%s' % language
</t>
<t tx="ekr.20090615053403.4955">p = c.p.firstChild()

c.selectPosition(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4956">@language vbscript

if
IF
</t>
<t tx="ekr.20090615053403.4957"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of leoColor tests')</t>
<t tx="ekr.20090620110118.5829">@language rest

@
Here is something that should generate a verbtim sentinel::

    #@+leo-encoding=iso-8859-1.
    
The length of this node should remain constant.
@c

assert len(p.b) == 199,len(p.b)</t>
<t tx="ekr.20090627070131.4971">import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20090627070131.4975">@language python
@tabwidth -4
@others
#end
</t>
<t tx="ekr.20090627070131.4976">def spam(cheese):

    print(cheese)
</t>
<t tx="ekr.20090627070131.4977">def cheese():

    pass
</t>
<t tx="ekr.20090627070131.4978">def spam(cheese):

    print(cheese)
def cheese():

    pass
#end
</t>
<t tx="ekr.20090629104856.4992"></t>
<t tx="ekr.20090703080553.5000">import unittest
import leo.core.leoTest as leoTest
import sys

# WARNING: this causes strange problems when run externally.
if g.isPython3:
    # Some tests now fail on Python 2.x.
    path = g.os_path_join(g.app.loadDir,"..","core")
    if 0:
        &lt;&lt; define exclude &gt;&gt;
    else:
        exclude = []
    modules = leoTest.importAllModulesInPath(path,exclude=exclude)
    suite = leoTest.createUnitTestsFromDoctests(modules)
    if suite: g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20090703093925.5003">exclude = [
    # These cause no problems, but will not have unit tests.
    'leo_Debugger.py',
    'leo_FileList.py',
    'leo_RemoteDebugger.py',
    'leo_run.py',
    'leo_Shell.py',
    'leoDynamicTest.py',
    'leoBridge.py',
    'leoBridgeTest.py',
    # 'leoApp.py','leoChapters.py',
    # 'leoAtFile.py',
    # 'leoColor.py',
    # 'leoCommands.py',
    # 'leoCompare.py',
    # 'leoConfig.py',
    # 'leoDebugger.py',
    # 'leoEditCommands.py',
    ####'leoFileCommands.py', # Causes problems!
    # 'leoFind.py',
    # 'leoFrame.py',
    # 'leoGlobals.py',
    # 'leoGui.py',
    # 'leoImport.py',
    # 'leoKeys.py',
    # 'leoMenu.py',
    # 'leoNodes.py',
    # 'leoPlugins.py',
    # 'leoPymacs.py',
    # 'leoRst.py',
    # 'leoShadow.py',
    # 'leoTangle.py',
    # 'leoTest.py',
    # 'leoUndo.py',
]</t>
<t tx="ekr.20090704085350.5007">@language python
@others</t>
<t tx="ekr.20090704085350.5010">h = '@file ../test/unittest/at-file-test.py'
p = g.findNodeAnywhere(c,h)
assert p
assert not p.isDirty(),p.h # Do not ignore this failure!

table = (
    (p.firstChild(),'spam'),
    (p.firstChild().next(),'eggs')
)

for p2,h2 in table:
    assert p2.h == h2
    assert len(p2.b) &gt; 10</t>
<t tx="ekr.20090704085350.5018">h = '@shadow ../test/unittest/at-shadow-test.py'
p = g.findNodeAnywhere(c,h)
assert p

table = (
    (p.firstChild(),'spam'),
    (p.firstChild().next(),'eggs')
)

assert not p.isDirty(),p.h # Do not ignore this failure!

for p2,h2 in table:
    assert len(p2.h) == len(h2)</t>
<t tx="ekr.20090704085350.5028">@language python
@others</t>
<t tx="ekr.20090704085350.5029">def spam():
    pass</t>
<t tx="ekr.20090704085350.5030">def eggs():
    pass</t>
<t tx="ekr.20090704085350.5034">@language python
@others</t>
<t tx="ekr.20090704085350.5035">def spam():
    pass</t>
<t tx="ekr.20090704085350.5036">def eggs():
    pass</t>
<t tx="ekr.20090704085350.5040">@language python
@others</t>
<t tx="ekr.20090704085350.5044">h = '@asis ../test/unittest/at-asis-test.py'
p = g.findNodeAnywhere(c,h)
assert p

table = (
    (p.firstChild(),'spam'),
    (p.firstChild().next(),'eggs')
)

assert not p.isDirty(),p.h # Do not ignore this failure!

for p2,h2 in table:
    assert p2.h == h2
    assert len(p2.b) &gt; 10</t>
<t tx="ekr.20090704085350.5046">h = '@thin ../test/unittest/at-thin-test.py'
p = g.findNodeAnywhere(c,h)
assert p

table = (
    (p.firstChild(),'spam'),
    (p.firstChild().next(),'eggs')
)

assert not p.isDirty(),p.h # Do not ignore this failure!

for p2,h2 in table:
    assert p2.h == h2
    assert len(p2.b) &gt; 10</t>
<t tx="ekr.20090704085350.5052">h = '@auto ../test/unittest/at-auto-test.py'
p = g.findNodeAnywhere(c,h)
assert p

table = (
    (p.firstChild(),'spam'),
    (p.firstChild().next(),'eggs')
)

assert not p.isDirty(),p.h # Do not ignore this failure!

for p2,h2 in table:
    assert p2.h == h2
    assert len(p2.b) &gt; 10</t>
<t tx="ekr.20090704085350.5062">@language python
@root ../test/unittest/at-root-test.py
@others</t>
<t tx="ekr.20090704085350.5063">def spam():
    pass</t>
<t tx="ekr.20090704085350.5064">def eggs():
    pass</t>
<t tx="ekr.20090704093658.5061">h = '@root ../test/unittest/at-root-test.py'
p = g.findNodeAnywhere(c,h)
assert p

table = (
    (p.firstChild(),'spam'),
    (p.firstChild().next(),'eggs')
)

assert not p.isDirty(),p.h # Do not ignore this failure!

for p2,h2 in table:
    assert p2.h == h2
    assert len(p2.b) &gt; 10</t>
<t tx="ekr.20090704093658.5062">h = '@root ../test/unittest/at-root-test.py'
p = g.findNodeAnywhere(c,h)
assert p,'fail 1: no p'

c.selectPosition(p)
c.tangleCommands.tangle()

expectedDir = g.os_path_finalize_join(g.app.loadDir,
    '..','test')
expectedFn = g.os_path_finalize_join(g.app.loadDir,
    '..','test','unittest','at-root-test.py')

d = g.app.unitTestDict
assert d.get('tangle') is True

tangle_dir = d.get('tangle_directory')
assert  tangle_dir.lower() == expectedDir.lower(),'fail 2: expected: %s got: %s' % (
    expectedDir,tangle_dir)

tangle_fn = d.get('tangle_output_fn')
assert expectedFn.lower() == tangle_fn.lower(),'fail 3: expected: %s got: %s' % (
    expectedFn,tangle_fn)</t>
<t tx="ekr.20091206090247.5060"># Use these with caution.</t>
<t tx="ekr.20091206090247.5061">count = 0
for p in c.all_unique_positions():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print(s) ; g.es(s)</t>
<t tx="ekr.20091206090247.5062"># About the only time you should run this script is when:
# - changing the format of timestamps in nodeIndices.setTimestamp or
# - when making a retroactive change to leoID.txt.

if 0: # This is usually a very bad idea.

    for p in c.all_positions():
        p.v.fileIndex = None

    g.es("all timestamps cleared")</t>
<t tx="ekr.20091206090247.5063">put = g.es_print
for p in c.all_positions():
    if p.v.u:
        put("deleting v.u:",p.h,
            g.listToString(p.v.u.keys()))
        p.v.u = None
put('done') 
c.redraw()</t>
<t tx="ekr.20091219121039.5065">x = c.rstCommands

result = x.handleMissingStyleSheetArgs(s=None)
assert result == {},'expected {}, got %s' % result

expected = {
    'documentoptions':'[english,12pt,lettersize]',
    'language':'ca',
    'use-latex-toc':'1',
}

for s in (
    '--language=ca, --use-latex-toc,--documentoptions=[english,12pt,lettersize]',
    '--documentoptions=[english,12pt,lettersize],--language=ca, --use-latex-toc',
    '--use-latex-toc,--documentoptions=[english,12pt,lettersize],--language=ca, ',
):

    result = x.handleMissingStyleSheetArgs(s=s)
    assert result == expected,'expected %s\ngot %s' % (expected,result)</t>
<t tx="ekr.20091219122958.5066"></t>
<t tx="ekr.20100102164959.5088">nodes = 0 ; lines = 0
for p in c.all_unique_positions():
    nodes += 1
    lines += len(g.splitLines(p.b))

pages = ((nodes * 10) + lines) / 50
s = "%d nodes,  %d lines, %d pages" % (nodes,lines,pages)
print(s); g.es(s)</t>
<t tx="ekr.20100107110353.5105"></t>
<t tx="ekr.20100107110353.5106">@others</t>
<t tx="ekr.20100107110353.5107">node 1 line 1
node 1 line 2</t>
<t tx="ekr.20100107110353.5108">node 2 line 1
node 2 line 2</t>
<t tx="ekr.20100107110353.5109">@others</t>
<t tx="ekr.20100107110353.5110">node 1 line 1
node 1 line 2 changed</t>
<t tx="ekr.20100107110353.5111">node 2 line 1 changed
node 2 line 2 changed</t>
<t tx="ekr.20100119102849.5108"># backward-find-character and find-character
# can't be tested this way because they require k.getarg.
# They pass hand tests.

&lt;&lt; define table &gt;&gt;

w = c.frame.body.bodyCtrl
child = g.findNodeInChildren(c,p,'work')
assert child
c.selectPosition(child)

for commandName in table:
    # Put the cursor in the middle of the middle line
    # so all cursor moves will actually do something.
    w.setInsertPoint(15) # for move-past-close
    try:
        c.editCommands.extendMode = True
        c.keyHandler.simulateCommand(commandName)
        i,j = w.getSelectionRange()
        assert i != j,'i == j: %s %s' % (i,commandName)
    finally:
        c.editCommands.extendMode = False

</t>
<t tx="ekr.20100119102849.5109"># Cursor movement commands affected by extend mode.
# The x-extend-selection commands are not so affected.
table = (
    'back-to-indentation',
    'back-to-home',
    'back-char',
    'back-page',
    'back-paragraph',
    'back-sentence',
    'back-word',
    'beginning-of-buffer',
    'beginning-of-line',
    'end-of-buffer',
    'end-of-line',
    'forward-char',
    'forward-page',
    'forward-paragraph',
    'forward-sentence',
    'forward-end-word',
    'forward-word',
    'move-past-close',
    'next-line',
    'previous-line',
)</t>
<t tx="ekr.20100119102849.5110">line 1.
line 2(xxx).
line 3.</t>
<t tx="ekr.20100123093044.5115">def spam():
    pass</t>
<t tx="ekr.20100123093044.5117">def eggs():
    pass</t>
<t tx="ekr.20100123172713.5114"></t>
<t tx="ekr.20100123172713.5116">count = 0
for p in c.all_unique_positions():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList"): # and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print s ; g.es(s)</t>
<t tx="ekr.20100125180231.5120">@first # -*- coding: utf-8 -*-

s = g.ue('','utf-8')
g.es(s)
g.pr(s)
s = ''
g.pr(s)
</t>
<t tx="ekr.20100127162342.5123">import glob,os

tkPass = (
    'EditAttributes','Library',
    'URLloader','UniversalScrolling','UASearch',
    'autotrees','chapter_hoist','cleo','dump_globals',
    'expfolder','geotag','graphed','groupOperations',
    'hoist','import_cisco_config',
    'keybindings','leoupdate',
    'maximizeNewWindows', 'mnplugins','mod_labels',
    'mod_read_dir_outline','mod_tempfname','multifile',
    'newButtons','nodeActions','nodenavigator',
    'open_with','pie_menus','pluginsTest',
    'read_only_nodes','rClick',
    'scheduler','searchbar','searchbox','shortcut_button',
    'script_io_to_body','searchbox',
    'templates','textnode','tkGui','toolbar',
    'xcc_nodes',
)
tkPassWithProblems = (
    'at_view', # at_view plugin not loaded: win32Clipboard not present.
    'image', # can not import ImageTk.
    'table', # failed to import 'tktable'
    'xsltWithNodes', # Can not import Ft from plugin leo.plugins.xsltWithNodes.
)
tkFail = (
    'ConceptualSort','at_produce','autocompleter','rowcol',
)
passList = (
    '__init__','FileActions','UNL',
    'active_path','add_directives','attrib_edit',
    'backlink','base64Packager','baseNativeTree','bibtex','bookmarks',
    'codewisecompleter','colorize_headlines','contextmenu',
    'ctagscompleter','cursesGui','datenodes','debugger_pudb',
    'detect_urls','dtest','empty_leo_file','enable_gc','initinclass',
    'leo_to_html','leo_interface','leo_pdf','leo_to_rtf',
    'leoOPML','leoremote','lineNumbers',
    'macros','mime','mod_autosave','mod_framesize','mod_leo2ascd',
    'mod_scripting','mod_speedups','mod_timestamp',
    'nav_buttons','nav_qt','niceNosent','nodeActions','nodebar',
    'open_shell','outline_export','quit_leo',
    'paste_as_headlines','plugins_menu','pretty_print','projectwizard',
    'qtGui','qt_main','qt_quicksearch','qtframecommands',
    'quickMove',
        # Warning: changed this line by guessing!
        # func = types.MethodType(func, quickMove)
    'quicksearch','redirect_to_log','rClickBasePluginClasses',
    'run_nodes', # Changed thread.allocate_lock to threading.lock().acquire()
    'rst3',
    'scrolledmessage','setHomeDirectory','slideshow','spydershell','startfile',
    'testRegisterCommand','todo','trace_gc_plugin','trace_keys','trace_tags',
    'vim','xemacs',
)
passWithImportProblems = ( # Other than tk input problems.
    'ipython','word_export',
)
dead = (
    'at_folder','exampleTemacsExtension','ironPythonGui','LeoN',
    'rst2','swing_gui','temacs','usetemacs','wxGui',)
error = ( # Real errors with tracebacks.
)
fail = (
    'stickynotes_plus', # requires markdown.
    'zenity_file_dialogs', # requires zenity, and probably ubuntu.
)
noAttribute = (
    # AttributeError: 'module' object has no attribute &lt;module name&gt;
    # This was a sign of a missing init top-level function.
)
changed = (
    'LeoN',
)
plugins = g.os_path_abspath(g.os_path_join(
    g.app.loadDir,'..','plugins','*.py'))
files = glob.glob(plugins)
files.sort()
os.system('cls') # Clear the screen on windows.
for fn in files:
    m = g.shortFileName(fn)[:-3]
    # Change the next line to choose different plugins.
    if m in passList:
        try:
            __import__('leo.plugins.%s' % m)
            if 1: print('pass %s' % m)
        except ImportError:
            if 1: print('fail %s' % m)
        except Exception:
            if 1: g.es_exception()
            if 1: print('error %s' % m)
</t>
<t tx="ekr.20100131171342.5459">'''
Run all the unit tests in the .leo file given by the path.
The path is relative to the leo\test directory.
'''

# This button used to be in leoPy.leo

import leo.core.leoTest as leoTest

leoTest.runUnitTestLeoFile(gui='nullGui',path='../core/leoPy.leo')

g.es_print('unit tests done',color='blue')</t>
<t tx="ekr.20100131171342.5471"></t>
<t tx="ekr.20100131171342.5472"></t>
<t tx="ekr.20100131171342.5473"></t>
<t tx="ekr.20100131171342.5474">if g.app.gui.guiName() == 'tkinter':

    import leo.core.leoPlugins as leoPlugins
    tkGui = leoPlugins.loadOnePlugin ('tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect,sys

    baseClass = leoFrame.leoBody
    subClasses  = (tkGui.leoTkinterBody,leoFrame.nullBody)
    baseObject = c.frame.body

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        try:
            assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)
        except AssertionError:
            exctype, value = sys.exc_info()[:2]
            print(value)
            raise

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                #raise
                exctype, value = sys.exc_info()[:2]
                print(value)</t>
<t tx="ekr.20100131171342.5475">if g.app.gui.guiName() == 'tkinter':

    import leo.core.leoPlugins as leoPlugins
    tkGui = leoPlugins.loadOnePlugin ('tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoFrame
    subClasses  = (tkGui.leoTkinterFrame,leoFrame.nullFrame)
    baseObject = c.frame

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
</t>
<t tx="ekr.20100131171342.5476">if g.app.gui.guiName() == 'tkinter':

    import leo.core.leoPlugins as leoPlugins
    tkGui = leoPlugins.loadOnePlugin ('tkGui',verbose=False)

    import leo.core.leoGui as leoGui
    import inspect

    baseClass = leoGui.leoGui
    subClasses  = (tkGui.tkinterGui,) # nullGui can inherit almost all leoGui dummy methods.
    baseObject = g.app.gui

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                raise
</t>
<t tx="ekr.20100131171342.5477">if g.app.gui.guiName() == 'tkinter':

    import leo.core.leoPlugins as leoPlugins
    tkGui = leoPlugins.loadOnePlugin ('tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoTree
    subClasses  = (tkGui.leoTkinterTree,leoFrame.nullTree)
    baseObject = c.frame.tree

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
</t>
<t tx="ekr.20100131171342.5478">if g.app.gui.guiName() == 'qt':

    logCtrl = c.frame.log.logCtrl

    table = (
        ('mustBeDefinedInSubclasses',logCtrl.mustBeDefinedInHighLevelSubclasses),
        ('mustBeDefinedInBaseClass',logCtrl.mustBeDefinedOnlyInBaseClass),
        ('mustBeDefined',logCtrl.mustBeDefined),
    )

    # Check existence.
    for tag,aList in table:
        for z in aList:
            assert hasattr(c.frame.log,z),'%s %s' % (tag,z)
            assert hasattr(c.frame.body,z),'%s %s' % (tag,z)

    # Check signatures.
    import inspect
    for tag,aList in table:
        for z in aList:
            func = getattr(c.frame.body.bodyCtrl,z)
            func2 = getattr(c.frame.log.logCtrl,z)
            assert func,z
            assert func2,z
            d1 = inspect.getargspec(func)
            d2 = inspect.getargspec(func2)
            assert d1==d2,'\n%s\n\nd1 %s\n\nd2 %s' % (z,d1,d2)
</t>
<t tx="ekr.20100131171342.5479">f = c.frame
assert(f.c==c)
assert(c.frame==f)

ivars = (
    # Subcommanders...
    'atFileCommands','fileCommands','importCommands','tangleCommands','undoer',
    # Positions...
    '_currentPosition','_rootPosition','_topPosition',
    # Data structures...
    'hoistStack','recentFiles',
    # Args...
    'output_doc_flag','page_width','tab_width',
    # 'tangle_directory',
    'tangle_errors','tangle_batch_flag','target_language',
    'untangle_batch_flag','use_header_flag',
    # Others...
    'mFileName',
)

for ivar in ivars:
    assert hasattr(c,ivar), 'missing commander ivar: %s' % ivar
    val = getattr(c,ivar)
    assert val is not None,'null commander ivar: %s'% ivar</t>
<t tx="ekr.20100131171342.5480">f = c.frame
assert(f.c==c)
assert(c.frame==f)

if g.app.gui.guiName() == 'tkinter':
    ivars = (
        'bar1','bar2',
        'body',
        #'bodyBar','bodyXBar', # 2007: 10/31: There are now injected in c.frame.body.bodyCtrl.
        #'bodyCtrl', # 2007/10/27: this ivar is evil and has been removed.
        'canvas',
        'f1','f2',
        'iconBar','iconFrame',
        'log','outerFrame',
        'statusLine','statusFrame','statusLabel','statusText',
        'title','top','tree',
        #'treeBar', # leo_treeBar is now injected into frame.canvas.
    )
else: ivars = ()

for ivar in ivars:
    assert hasattr(f,ivar), 'missing frame ivar: %s' % ivar
    val = getattr(f,ivar)
    assert val is not None,'null frame ivar: %s'% ivar

# These do not have to be initied.
for ivar in ('findPanel',):
    assert hasattr(f,ivar), 'missing frame ivar: %s' % ivar</t>
<t tx="ekr.20100131171342.5481">ivars = ('extensionsDir','globalConfigDir','loadDir','testDir')

for ivar in ivars:
    assert hasattr(g.app,ivar), 'missing g.app directory: %s' % ivar
    val = getattr(g.app,ivar)
    assert val is not None, 'null g.app directory: %s'% ivar
    assert g.os_path_exists(g.os_path_abspath(val)), 'non-existent g.app directory: %s' % ivar

assert hasattr(g.app,'homeDir') # May well be None.</t>
<t tx="ekr.20100131171342.5482">
ivars = (
    # These are non-official and might be removed...
        # 'afterHandler','count','positions',
        # 'menuWarningsGiven','unicodeErrorGiven',
    'batchMode','config',
    'debug','debugSwitch','disableSave',
    'gui','hasOpenWithMenu','hookError','hookFunction',
    'idle_imported','idleTimeDelay','idleTimeHook','initing','killed',
    'leoID','loadedPlugins','log','logIsLocked','logWaiting',
    'nodeIndices','numberOfWindows',
    'quitting','realMenuNameDict','searchDict','scriptDict',
    'trace','tracePositions','trace_list',
    'unitTestDict','unitTesting','use_psyco','windowList',
)

for ivar in ivars:
    assert hasattr(g.app,ivar), 'missing app ivar: %s' % ivar
    val = getattr(g.app,ivar)
    assert val is not None, 'null app ivar: %s'% ivar

# These do not have to be initied.
for ivar in (
    'commandName',
    'openWithFiles','openWithFileNum','openWithTable',
    'root',
):
    assert hasattr(g.app,ivar), 'missing app ivar: %s' % ivar</t>
<t tx="ekr.20100131171342.5483">import os
import sys

trace = False

python_interp = sys.executable
test_path = g.os_path_join(g.app.loadDir,"..","test","unittest")
src_path  = g.os_path_join(g.app.loadDir,"..","..")

leo_file   = g.os_path_join(src_path,"launchLeo.py")
batch_file = g.os_path_join(test_path,"batchTest.py")
test_file  = g.os_path_join(test_path,"createdFile.txt")

# Execute this command: python launchLeo.py --script test\unittest\batchTest.py

if 1:
    command = r"%s %s --silent --script %s" % (python_interp,leo_file,batch_file)
else:
    command = r"%s %s --script %s" % (python_interp,leo_file,batch_file)

@others

if trace:
    print('@test batch mode: loadDir: %s' % g.app.loadDir)

removeFile(test_file)
os.system(command)

assert(g.os_path_exists(test_file))</t>
<t tx="ekr.20100131171342.5484">def removeFile(path):

    trace = False

    if os.path.exists(test_file):
        if trace:
            print("@test batch mode: removeFile: deleting",test_file)
        os.remove(test_file)
    else:
        if trace:
            print("@test batch mode: removeFile: not found:",test_file)
</t>
<t tx="ekr.20100131171342.5485">import inspect

d = c.commandsDict ; keys = list(d.keys()) ; keys.sort()

for key in keys:
    f = d.get(key) ; name = f and f.__name__
    args, varargs, varkw, defaults = data = inspect.getargspec(f)
    # print('%-28s' % (name),data)
    arg0 = len(args) &gt; 0 and args[0]
    arg1 = len(args) &gt; 1 and args[1]
    assert arg0 == 'self' and arg1 == 'event' or arg0 == 'event',\
       'no event arg for %s, args: %s' % (name,data)</t>
<t tx="ekr.20100131171342.5486"># print('-' * 30)

@others

# This can't be run externally,
# And it is no longer an effective test.

p = c.rootPosition()
ok = True
while p and ok:
    if p.isAnyAtFileNode():
        h = p.h
        if h.endswith('.py'):
            ok = checkFile(p)
        p.moveToNodeAfterTree()
    else:
        p.moveToThreadNext()
assert ok</t>
<t tx="ekr.20100131171342.5487">def checkFile(p):

    print('checking',p.h)
    # Check all the descendant nodes.
    ok = True
    for p2 in p.subtree_iter():
        h = p2.h
        for tag in ('@test','@suite'):
            if h.startswith(tag):
                s = p2.b
                lines = g.splitLines(s)
                for line in lines:
                    # print('line',line)
                    if not line.strip() or line.startswith('#'):
                        continue
                    elif line.startswith('if g.unitTesting:'):
                        break
                    else:
                        print('in %s' % p.h)
                        print('missing "if g.unitTesting:" %s' % h)
                        ok = False
    return ok</t>
<t tx="ekr.20100131171342.5495">if g.app.gui.guiName() == 'tkinter':

    import rClick
    rClick.init()
</t>
<t tx="ekr.20100131171342.5496"></t>
<t tx="ekr.20100131171342.5497">import detect_urls

w = c.frame.body.bodyCtrl
s = w.getAllText()
w.setInsertPoint(len(s))
url = detect_urls.openURL(tag='test',keywords={'c':c})
assert url == 'http://webpages.charter.net/edreamleo/front.html','Got:%s' % repr(url)

@ The last line is the url
http://webpages.charter.net/edreamleo/front.html</t>
<t tx="ekr.20100131171342.5498"># Only tk gui colorizers with tag_ranges.

if g.app.gui.guiName() == 'tkinter':

    import detect_urls
    w = c.frame.body.bodyCtrl
    s = w.getAllText()
    detect_urls.colorizeURLs(tag='test',keywords={'c':c})
    assert w.tag_ranges('URL'),'no URL tags'

@ The last line is the url
http://webpages.charter.net/edreamleo/front.html</t>
<t tx="ekr.20100131171342.5500">import macros

controller = macros.paramClass(c)
controller.parameterize()
    # Not much will happen because there are no children.
    # However, this does test recent changes.</t>
<t tx="ekr.20100131171342.5501" annotate="7d71002e"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.
import leo.core.leoTest as leoTest
u = leoTest.testUtils(c) # This *is* used

c.contractAllHeadlines()
h = 'All unit tests'
p = u.findNodeAnywhere(h)
if p:
    p.expand()
    g.app.unitTestDict['restoreSelectedNode']=False
    c.selectPosition(p)
    c.redraw()

print('\nEnd of plugins unit tests')</t>
<t tx="ekr.20100131171342.5502"></t>
<t tx="ekr.20100131171342.5503">trace = False

if trace: print('=' * 20)

for p in c.all_positions():

    p2 = c.vnode2position(p.v)

    if trace: print(p2.level(), p2.headString())

    # We can *not* assert that p == p2, only that
    # p2.v == p.v and c.positionExists(p2)
    assert p2
    assert p2.v == p.v,'p2.v: %s, p.v: %s' % (p2.v,v)
    assert c.positionExists(p2),'does not exist: %s' % p2
</t>
<t tx="ekr.20100131171342.5504">tree = c.frame.tree

if hasattr(tree,'position2item'): # and hasattr(tree,'item2vnode'):

    c.redraw()

    p = c.rootPosition()
    while p:
        item = tree.position2item(p)
        v = tree.item2vnode(item)
        assert v == p.v, 'item2: %s, p.v: %s' % (item,p.v)
        p.moveToVisNext(c)</t>
<t tx="ekr.20100131171342.5505">def test_sibs(parent_p,parent_item):

    trace = False
    tree = c.frame.tree
    sib_items = tree.childItems(parent_item)
    sibs = [z for z in parent_p.self_and_siblings_iter(copy=True)]

    assert len(sib_items) == len(sibs),(
        'child_items: %s, children: %s' % (
            g.listToString(sib_items),g.listToString(sibs)))

    for item,p in zip(sib_items,sibs):
        p2 = tree.item2position(item)
        if trace: print (id(item),p2 and p2.headString() or not p2 and '**None**')
        assert p == p2, 'item: %s, p: %s, p2: %s' % (id(item),p,p2)

        # Recursively test.
        child = p.firstChild()
        if child.isVisible(c):
            test_sibs(child,parent_item=item)

if hasattr(c.frame.tree,'item2position'):
    c.redraw()
    test_sibs(c.rootPosition(),None)
</t>
<t tx="ekr.20100131171342.5506"></t>
<t tx="ekr.20100131171342.5507">@
language_delims_dict 
    # Keys are languages, values are 1,2 or 3-tuples of delims. 
language_extension_dict
    # Keys are languages, values are extensions.
extension_dict = {
    # Keys are extensions, values are languages.
@c

delims_d    = g.app.language_delims_dict
lang_d      = g.app.language_extension_dict
ext_d       = g.app.extension_dict

for lang in lang_d:
    ext = lang_d.get(lang)
    assert lang in delims_d,'fail 1: %s' % lang
    assert ext in ext_d,'fail 2: %s' % ext
for ext in ext_d:
    lang = ext_d.get(ext)
    assert lang in lang_d,'fail 3: %s' % lang</t>
<t tx="ekr.20100131171342.5508"></t>
<t tx="ekr.20100131171342.5509">import leo.core.leoBridge as leoBridge

if 0: # This can not be run locally: it contains another Tk event loop.
    controller = leoBridge.controller(gui='nullGui',verbose=False)
    g = controller.globals()
</t>
<t tx="ekr.20100131171342.5592"></t>
<t tx="ekr.20100131171342.5593"># For some reason these don't select the dialog properly when run as a script.
# However, the main reason for the tests is to make sure the ctors don't crash.
# Also, for unit testing the value of c doesn't matter.

oldGui = g.app.gui ; guis = [g.app.gui]

import leo.core.leoGui as leoGui
guis.append(leoGui.unitTestGui())

for gui in guis:
    gui.runAboutLeoDialog(c,'version','copyright','url','email')
    gui.runAskLeoIDDialog()
    gui.runAskOkDialog(c,'title','message')
    gui.runAskOkCancelNumberDialog(c,'title','message')
    gui.runAskOkCancelStringDialog(c,'title','message')
    gui.runAskYesNoDialog(c,'title','message')
    gui.runAskYesNoCancelDialog(c,'title','message')
    # gui.runCompareDialog(c) # Removed.

g.app.gui = oldGui</t>
<t tx="ekr.20100131171342.5599"></t>
<t tx="ekr.20100131171342.5600">w = c.frame.body.bodyCtrl
s = w.getAllText()

for i in range(len(s)):
    i2 = w.toGuiIndex(i)
    i3 = w.toPythonIndex(i2)
    assert(i3==i)
</t>
<t tx="ekr.20100131171342.5601">#ab
#

w = c.frame.body.bodyCtrl

# This test applies only to tkinter indices.
if g.app.gui.guiName() == 'tkinter':

    table = (
        (-1,'1.0'), # One too small.
        (0,'1.0'),
        (1,'1.1'),
        (2,'1.2'),
        (3,'1.3'), # The newline ends a row.
        (4,'2.0'),
        (5,'2.1'),
    )

    for i,expected in table:
        result = w.toGuiIndex(i)
        assert result == expected,'toGuiIndex(i): %s, expected: %s, got: %s' % (i,expected,result)</t>
<t tx="ekr.20100131171342.5602">if g.app.gui.guiName() == 'tkinter':

    import leo.core.leoPlugins as leoPlugins
    tkGui = leoPlugins.loadOnePlugin ('tkGui',verbose=False)
    import Tkinter as Tk
    w = tkGui.leoTkTextWidget()
    w.setAllText('abcdef\n')
    s = w.getAllText()
    assert s == 'abcdef\n'
    s1 = w.get(0,len(s))
    assert s1 == 'abcdef\n'
    w.delete(0,len(s))
    assert len(w.getAllText()) == 0
    w.setAllText('')
    w.insert(0,'abcdef\n')
    s = w.getAllText()
    assert s == 'abcdef\n','got: %s' % repr(s)
    w.setInsertPoint(2)
    i = w.getInsertPoint()
    assert i == 2
    w.setSelectionRange(2,4)
    assert w.hasSelection()
    i,j = w.getSelectionRange()
    assert i==2 and j==4
    s3 = w.getSelectedText()
    assert s3 == 'cd'
    w.deleteTextSelection()
    s4 = w.getAllText()
    assert s4 == 'abef\n'
    w.selectAllText()
    i,j = w.getSelectionRange()
    assert i==0 and j==5,'getSelectionRange failed: i=%d,j=%d' % (i,j)
    w.replace(0,3,'wxyz')
    s5 = w.getAllText()
    assert s5 == 'wxyzf\n','getAllText failed'
    w.flashCharacter(3)
    i = w.xyToGuiIndex(0,0)
    assert i == '1.0','wxToGuiIndex failed'
    i = w.xyToPythonIndex(0,0)
    assert i == 0
    w.mark_set('insert','1.3'),'xyToPythonIndex failed'
    i = w.getInsertPoint()
    assert i == 3
    w.tag_add('test',4,6)
    aTuple = w.tag_ranges('test')
    assert aTuple == (4,6),'tag_add failed: %s' % aTuple
</t>
<t tx="ekr.20100131171342.5603" annotate="7d71002e"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

# print('\nEnd of leoGui tests.')</t>
<t tx="ekr.20100131171342.5604"></t>
<t tx="ekr.20100131171342.5605">import string

k = c.k

for ch in (string.printable):
    if ch == '\n': continue # A special case.
    assert k.isPlainKey(ch), 'wrong: not plain: %s' % (ch)

special = (
    'Return', # A special case.
    'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
    'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
    'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
    'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
    'KP_F1','KP_F2','KP_F3','KP_F4',
    'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
    'Home','Left','Linefeed','Next','Num_Lock',
    'PageDn','PageUp','Pause','Prior','Right','Up',
    'Sys_Req',
)

for ch in special:
    assert not k.isPlainKey(ch), 'wrong: is plain: %s' % (ch)
</t>
<t tx="ekr.20100131171342.5606">try:
    k = c.k ; ac = k.autoCompleter
    w = c.frame.body.bodyCtrl
    ac.widget = w
    s = w.getAllText()
    import string
    # Just test that this doesn't crash.
    for obj in (None,g,string,c,p):
        w.setInsertPoint('end')
        c.k.autoCompleter.calltip(obj=g)
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor()

# end:</t>
<t tx="ekr.20100131171342.5607">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.k ; p = c.p ; w = c.edit_widget(p)
commandName = 'test-registerCommand'

def callback (event=None,c=c): # Must have an event param to pass later unit test.
    g.app.unitTestDict[commandName] = True

# Test 1
g.app.unitTestDict[commandName] = False
k.registerCommand(commandName,'Alt-Ctrl-Shift-z',callback,pane='all',verbose=True)
k.simulateCommand(commandName)
assert g.app.unitTestDict.get(commandName)

if 0: # Test 2
    g.app.unitTestDict[commandName] = False
    k.manufactureKeyPressForCommandName(w,commandName)
    assert g.app.unitTestDict.get(commandName)</t>
<t tx="ekr.20100131171342.5608"># print('settingsNameDict',c.k.settingsNameDict)

table = (
    ('a','a'),
    ('A','a'),
    ('Alt-a','Alt+a'),
    ('Alt-A','Alt+a'),
    ('Alt-Shift-a','Alt+A'),
    ('Alt-=','Alt+equal'),
    ('Alt-+','Alt+plus'),
    # We can no longer igtnore the shift.
    # ('Alt-Shift++','Alt+plus'), # Ignore the shift.
    ('Alt--','Alt+minus'),
    ('Shift-a','A'),
    ('Shift-A','A'),
    ('RtArrow','Right'),
    ('Shift-RtArrow','Shift+Right'),
    ('Ctrl-RtArrow','Ctrl+Right'),
    ('Control-Right','Ctrl+Right'),
    ('PageUp','Prior'), ('Prior','Prior'),('Shift-PageUp','Shift+Prior'),
    ('PageDn','Next'),('Next','Next'),('Shift-Next','Shift+Next'),
)
for setting, result in table:
    val = c.k.strokeFromSetting(setting)
    assert val==result,'Expected %s, Got %s' % (result,val)</t>
<t tx="ekr.20100131171342.5609" annotate="7d71002e"># This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

# print('\nEnd of leoKeys tests.')</t>
<t tx="ekr.20100131171342.5610"></t>
<t tx="ekr.20100131171342.5611">import leo.core.leoPlugins as leoPlugins

aList1 = leoPlugins.getHandlersForTag('select1')
aList2 = leoPlugins.getHandlersForOneTag('select1')

assert type(aList1) == type([])
assert type(aList2) == type([])
assert aList1 == aList2
</t>
<t tx="ekr.20100131171342.5612"></t>
<t tx="ekr.20100131171342.5613">def sendEmail(self):
    pass # g.trace('self2',self)

class test:
    pass

X = test()
sendEmail(X)
</t>
<t tx="ekr.20100131180007.5359">c.frame.tree.OnIconDoubleClick(p)
</t>
<t tx="ekr.20100131180007.5361">x = c.shadowController
table = (
    ('python','abc',False),
    ('python','#abc',False),
    ('python','#verbatim',False),
    ('python','#@verbatim',True),
    ('c','abc',False),
    ('c','//@',False),
    ('c','//@verbatim',True),
    ('html','#@abc',False),
    ('html','&lt;!--abc--&gt;',False),
    ('html','&lt;!--@verbatim --&gt;',True),
    ('xxxx','#--unknown-language--@verbatim',True)
)
for language,s,expected in table:
    delims = g.set_delims_from_language(language)
    marker = x.markerClass(delims)
    result = marker.isVerbatimSentinel(s)
    assert result==expected,'language %s s: %s expected %s got %s' % (
        language,s,expected,result)</t>
<t tx="ekr.20100131180007.5362">x = c.shadowController
table = (
    ('python','abc',False),
    ('python','#abc',False),
    ('python','#@abc',True),
    ('python','@abc#',False),
    ('c','abc',False),
    ('c','//@',True),
    ('c','// @abc',False),
    ('c','/*@ abc */',True),
    ('c','/*@ abc',False),
    ('html','#@abc',False),
    ('html','&lt;!--abc--&gt;',False),
    ('html','&lt;!--@ abc --&gt;',True),
    ('html','&lt;!--@ abc -&gt;',False),
    ('xxxx','#--unknown-language--@',True)
)
for language,s,expected in table:
    delims = g.set_delims_from_language(language)
    marker = x.markerClass(delims)
    result = marker.isSentinel(s)
    assert result==expected,'language %s s: %s expected %s got %s' % (
        language,s,expected,result)</t>
<t tx="ekr.20100131180007.5363">x = c.shadowController
table = (
    ('python','#',''),
    ('c','//',''),
    ('html','&lt;!--','--&gt;'),
    ('xxxx','#--unknown-language--',''),
)
for language,delim1,delim2 in table:
    delims = g.set_delims_from_language(language)
    marker = x.markerClass(delims)
    result = marker.getDelims()
    expected = delim1,delim2
    assert result==expected,'language %s expected %s got %s' % (
        language,expected,result)</t>
<t tx="ekr.20100131180007.5364">x = c.shadowController

table = (
    ('ini',';','',),
    ('c','//',''),
    ('h','//',''),
    ('py','#',''),
    ('xyzzy','#--unknown-language--',''),
)

for ext,delim1,delim2 in table:
    filename = 'x.%s' % ext
    marker = x.markerFromFileName(filename)
    result1,result2 = marker.getDelims()
    assert delim1==result1, 'ext=%s, got %s, expected %s' % (
        ext,delim1,result1)
    assert delim2==result2, 'ext=%s, got %s, expected %s' % (
        ext,delim2,result2)
</t>
<t tx="ekr.20100131180007.5365">x = c.shadowController
# Add -ver=4 so at.parseLeoSentinel does not complain.
table = (
    ('c',('//@+leo-ver=4','a'),                   '//',''),
    ('c',('//@first','//@+leo-ver=4','b'),        '//',''),
    ('c',('/*@+leo-ver=4*/','a'),                 '/*','*/'),
    ('c',('/*@first*/','/*@+leo-ver=4*/','b'),    '/*','*/'),
    ('python',('#@+leo-ver=4','a'),               '#',''),
    ('python',('#@first','#@+leo-ver=4','b'),     '#',''),
    ('error',('',),             '#--unknown-language--',''),
    ('html',('&lt;!--@+leo-ver=4--&gt;','a'),                '&lt;!--','--&gt;'),
    ('html',('&lt;!--@first--&gt;','&lt;!--@+leo-ver=4--&gt;','b'),'&lt;!--','--&gt;'),
)

for language,lines,delim1,delim2 in table:
    s = x.findLeoLine(lines)
    marker = x.markerFromFileLines(lines,'test-file-name')
    result1,result2 = marker.getDelims()
    assert delim1==result1, 'language %s expected1 %s got %s lines %s' % (
        language,delim1,result1,'\n'.join(lines))
    assert delim2==result2, 'language %s expected2 %s got %s lines %s' % (
        language,delim1,result1,'\n'.join(lines))</t>
<t tx="ekr.20100131180007.5366">x = c.shadowController
table = (
    ('c',('//@+leo','a'),                   '//@+leo'),
    ('c',('//@first','//@+leo','b'),        '//@+leo'),
    ('c',('/*@+leo*/','a'),                 '/*@+leo*/'),
    ('c',('/*@first*/','/*@+leo*/','b'),    '/*@+leo*/'),
    ('python',('#@+leo','a'),               '#@+leo'),
    ('python',('#@first','#@+leo','b'),     '#@+leo'),
    ('error',('',),''),
    ('html',('&lt;!--@+leo--&gt;','a'),                '&lt;!--@+leo--&gt;'),
    ('html',('&lt;!--@first--&gt;','&lt;!--@+leo--&gt;','b'),'&lt;!--@+leo--&gt;'),
)
for language,lines,expected in table:
    result = x.findLeoLine(lines)
    assert expected==result, 'language %s expected %s got %s lines %s' % (
        language,expected,result,'\n'.join(lines))</t>
<t tx="ekr.20100131180007.5367">c,p = g.getTestVars()
x = c.shadowController

fn = 'does/not/exist'
assert not g.os_path_exists(fn)
assert not x.replaceFileWithString (fn,'abc')
</t>
<t tx="ekr.20100131180007.5369">table = (
    '1',
    '1-1','1-1-1','1-1-2',
    '1-2','1-2-1','1-2-2',
    '2',
    '2-1','2-1-1','2-1-2',
    '2-2','2-2-1','2-2-2',
    '3',
    '3-1','3-1-1','3-1-2',
    '3-2','3-2-1','3-2-2',
)

for suffix in table:
    h = 'node %s' % suffix
    p2 = g.findNodeInTree(c,p,h)
    assert p2,h

table2 = (
    ('2-1-2','2-1-1','2-1-1'),
    ('3','2','2'),
)  

for h1,h2,h3 in table2:
    p1 = g.findNodeInTree(c,p,'node %s' % h1)
    p2 = g.findNodeInTree(c,p,'node %s' % h2)
    p3 = g.findNodeInTree(c,p,'node %s' % h3)
    p1._adjustPositionBeforeUnlink(p2)
    result = p1
    assert result.stack == p3.stack,'expected %s got %s' % (
        p3.h,result and result.h or '&lt;none&gt;')

# Data.
@others
</t>
<t tx="ekr.20100131180007.5370"># Node 1</t>
<t tx="ekr.20100131180007.5371"># node 1-1</t>
<t tx="ekr.20100131180007.5372"># node 1-1-1</t>
<t tx="ekr.20100131180007.5373"># node 1-1-2</t>
<t tx="ekr.20100131180007.5374"># node 1-2</t>
<t tx="ekr.20100131180007.5375"># node 1-2-1</t>
<t tx="ekr.20100131180007.5376"># node 1-2-2</t>
<t tx="ekr.20100131180007.5377"># node 2</t>
<t tx="ekr.20100131180007.5378"># node 2-1</t>
<t tx="ekr.20100131180007.5379"># node 2-1-1</t>
<t tx="ekr.20100131180007.5380"># node 2-1-2
</t>
<t tx="ekr.20100131180007.5381"># node 2-2</t>
<t tx="ekr.20100131180007.5382"># node 2-2-1</t>
<t tx="ekr.20100131180007.5383"># node 2-2-2
</t>
<t tx="ekr.20100131180007.5384"># node 3</t>
<t tx="ekr.20100131180007.5385"># node 3-1
</t>
<t tx="ekr.20100131180007.5386"># node 3-1-1</t>
<t tx="ekr.20100131180007.5387"># node 3-1-2
</t>
<t tx="ekr.20100131180007.5388"># node 3-2
</t>
<t tx="ekr.20100131180007.5389"># node 3-2-1</t>
<t tx="ekr.20100131180007.5390"># node 3-2-2
</t>
<t tx="ekr.20100131180007.5391">table = (
    ('@auto-rst rst-file','rst-file','rst-file'),
    ('@auto x','x',''),
    ('xyz','',''),
)

for s,expected1,expected2 in table:
    result1 = p.v.atAutoNodeName(h=s)
    result2 = p.v.atAutoRstNodeName(h=s)
    assert result1 == expected1,'fail1: given %s expected %s got %s' % (
        repr(s),repr(expected1),repr(result1))
    assert result2 == expected2,'fail2: given %s expected %s got %s' % (
        repr(s),repr(expected2),repr(result2))
</t>
<t tx="ekr.20100131180007.5393">import leo.core.leoImport as leoImport

ic = c.importCommands
scanner = leoImport.rstScanner(importCommands=ic,atAuto=True)
scanner.root = p
s1 = ["abc",]
s2 = ["xyz",]

scanner.reportMismatch(s1,s2,1)

# Why is leoSettings.leo scanned twice in dynamicUnitTest.leo?
</t>
<t tx="ekr.20100131180007.5395">for s,expected in (
    ('a\nb', 'a\nb'),
    ('\n  \nb\n', 'b\n'),
    (' \t \n\n\n c', ' c'),
):
    result = g.removeLeadingBlankLines(s)
    assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
        repr(s),repr(expected),repr(result))
</t>
<t tx="ekr.20100131180007.5396">for s,expected in (
    ('a\nb', 'a\nb'),
    ('\n  \n\nb\n', 'b\n'),
    (' \t \n\n  \n c\n\t\n', ' c\n'),
):
    result = g.removeBlankLines(s)
    assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
        repr(s),repr(expected),repr(result))
</t>
<t tx="ekr.20100131180007.5398">if 1: # The following must be indented.

    s = '''\
    a
      b

c
    d'''

    s2 = 'a\n  b\n\nc\nd'

    result = g.adjustTripleString(s,c.tab_width)
    assert result == s2,repr(result)


</t>
<t tx="ekr.20100131180007.5402">s = 'aa bc \n \n\t\n'
table = (
    ('\t\n ','aa bc'),
    ('abc\t\n ',''),
    ('c\t\n ','aa b'),
)

for arg,val in table:
    result = g.removeTrailing(s,arg)
    assert result == val, 'expected %s, got %s' % (val,result)
</t>
<t tx="ekr.20100131180007.5403">s = ' \n \n\t\naa bc'
s2 = 'aa bc'

for i in range(3):
    result = g.ensureLeadingNewlines(s,i)
    val = ('\n' * i) + s2
    assert result == val, 'expected %s, got %s' % (
        repr(val),repr(result))
</t>
<t tx="ekr.20100131180007.5404">s = 'aa bc \n \n\t\n'
s2 = 'aa bc'

for i in range(3):
    result = g.ensureTrailingNewlines(s,i)
    val = s2 + ('\n' * i)
    assert result == val, 'expected %s, got %s' % (
        repr(val),repr(result))
</t>
<t tx="ekr.20100131180007.5417">import zipfile

# Create a zip file for testing.
s = 'this is a test file'
testDir = g.os_path_join(g.app.loadDir,'..','test')
assert g.os_path_exists(testDir)
path = g.os_path_finalize_join(testDir,'testzip.zip')
theFile = zipfile.ZipFile(path,'w')
theFile.writestr('leo-zip-file',s)
theFile.close()

# Open the file, and use read (with no args) to get the contents.
theFile,ok = g.openLeoOrZipFile(path)
assert ok,'not ok'
s2 = theFile.read()
assert s == s2,'s:  %s\ns2: %s' % (repr(s),repr(s2))
</t>
<t tx="ekr.20100131180007.5421">c,p = g.getTestVars()

result,error = g.setDefaultDirectory(c,p,importing=False)
assert error == ''
assert result == c.openDirectory,result
</t>
<t tx="ekr.20100131180007.5422">theDir = g.findDefaultDirectory(c)
assert theDir == c.frame.openDirectory,theDir
</t>
<t tx="ekr.20100131180007.5423">result,error = g.getPathFromDirectives(c,p)
assert error==''
assert result</t>
<t tx="ekr.20100131180007.5424">path = g.os_path_finalize_join(g.app.loadDir,'whatever')
result = g.getAbsPathFromNode(c,p=None,name=path)
expected = g.app.loadDir
assert expected == result,'expected %s, got %s' % (
    expected,result)</t>
<t tx="ekr.20100131180007.5425"># New in Leo 4.6, set_delims_from_string returns '' instead of None.
table = (
    ('c','@comment // /* */',   ('//','/*','*/')),
    ('c','// /* */',            ('//','/*','*/')),
    ('python','@comment #',     ('#','','')),
    ('python','#',              ('#','','')),
    ('xxxyyy','@comment a b c', ('a','b','c')),
    ('xxxyyy','a b c',          ('a','b','c')),
)

for language,s,expected in table:
    result = g.set_delims_from_string(s)
    assert result==expected,'language %s expected %s, got %s' % (
        language,expected,result)
</t>
<t tx="ekr.20100131180007.5426"># New in Leo 4.6, set_delims_from_language returns '' instead of None.
table = (
    ('c',       ('//','/*','*/')),
    ('python',  ('#','','')),
    ('xxxyyy',  ('','','')),
)

for language, expected in table:
    result = g.set_delims_from_language(language)
    assert result==expected,'language %s expected %s, got %s' % (
        language,expected,result)
</t>
<t tx="ekr.20100131180007.5427">table =  (
    (None,None), # Retain empty paths for warnings.
    ('',''),
    (g.app.loadDir,g.app.loadDir),
    ('&lt;abc&gt;','abc'),
    ('"abc"','abc'),
    ("'abc'",'abc'),
)

for path,expected in table:
    result = g.stripPathCruft(path)
    assert result == expected</t>
<t tx="ekr.20100131180007.5428"># New in Leo 4.6, set_delims_from_language returns '' instead of None.
table = (
    ('.c',      ('//','/*','*/')),
    ('.html',   ('', '&lt;!--', '--&gt;')),
    ('.py',     ('#','','')),
    ('.xxx',    ('','','')),
)

for ext, expected in table:
    result = g.comment_delims_from_extension(ext)
    assert result==expected,'ext %s expected %s, got %s' % (
        ext,expected,result)
</t>
<t tx="ekr.20100131180007.5429">import os,stat

fc = c.fileCommands
path = g.os_path_finalize_join(g.app.loadDir,'..','test','test-read-only.txt')
if os.path.exists(path):
    os.chmod(path, stat.S_IREAD)
    fc.warnOnReadOnlyFiles(path)
    assert fc.read_only
else:
    fc.warnOnReadOnlyFiles(path)
</t>
<t tx="ekr.20100131180007.5434">@language python
@comment a b c
    # @comment must follow @language.
@tabwidth -8
@pagewidth 72
@encoding utf-8
@path: anError # @path ends with ':'.

# @path xyzzy # Creates folder called xyzzy: interferes with other unit tests.

d = g.get_directives_dict(p)

# assert d.get('_p') == p # Never used, and a bad idea.
assert d.get('language') == 'python'
assert d.get('tabwidth') == '-8'
assert d.get('pagewidth') == '72'
assert d.get('encoding') == 'utf-8'
assert d.get('comment') == 'a b c'
assert not d.get('path'),d.get('path')
# assert d.get('path').endswith('xyzzy')
</t>
<t tx="ekr.20100131180007.5435">@header

c,p = g.getTestVars()
aList = g.get_directives_dict_list(p)
g.scanAtHeaderDirectives(aList)
</t>
<t tx="ekr.20100131180007.5442">@pagewidth -40

aList = g.get_directives_dict_list(p)
n = g.scanAtPagewidthDirectives(aList)

# The @pagewidth directive in the parent should control.
# Depending on how this test is run, the result could be 80 or None.
assert n in (None,80),repr(n)</t>
<t tx="ekr.20100131180007.5450">expectedIconDictList = [
{
    'on': 'tnode',
    'where': 'beforeHeadline',
    'yoffset': 0,
    # 'file': u'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\add.png',
    'file': 'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\add.png',
    'xpad': 1,
    'type': 'file',
    'xoffset': 2,
    # 'relPath': u'Tango\\16x16\\actions\\add.png',
    'relPath': 'Tango\\16x16\\actions\\add.png',
},
{
    'on': 'tnode',
    'where': 'beforeHeadline',
    'yoffset': 0,
    # 'file': u'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\bottom.png',
    'file': 'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\bottom.png',
    'xpad': 1,
    'type': 'file',
    'xoffset': 2,
    # 'relPath': u'Tango\\16x16\\actions\\bottom.png',
    'relPath': 'Tango\\16x16\\actions\\bottom.png',
}]
table = (
('tx','raw',None,"ekr.20090701133940.1767"),
('lineYOffset',None,3,"4b032e"),
# A real icon
('icons',None,expectedIconDictList,
"5d7100287d71012855026f6e71025505746e6f6465710355047479\
70657104550466696c6571055507796f666673657471064b006805583700000\
0433a5c6c656f2e7265706f5c7472756e6b5c6c656f5c49636f6e735c54616e\
676f5c31367831365c616374696f6e735c6164642e706e67710755047870616\
471084b01550577686572657109550e6265666f7265486561646c696e65710a\
5507786f6666736574710b4b02550772656c50617468710c581b00000054616\
e676f5c31367831365c616374696f6e735c6164642e706e67710d757d710e28\
55026f6e710f68035504747970657110550466696c6571115507796f6666736\
57471124b006811583a000000433a5c6c656f2e7265706f5c7472756e6b5c6c\
656f5c49636f6e735c54616e676f5c31367831365c616374696f6e735c626f7\
4746f6d2e706e67711355047870616471144b01550577686572657115550e62\
65666f7265486561646c696e6571165507786f666673657471174b025507726\
56c506174687118581e00000054616e676f5c31367831365c616374696f6e73\
5c626f74746f6d2e706e67711975652e"),
)
for attr,kind,expected,val in table:
    result = c.fileCommands.getSaxUa(attr,val,kind=kind)
    if expected is None: expected = val
    assert expected==result,'expected %s got %s' % (
        expected,result)</t>
<t tx="ekr.20100131180007.5451">s = 'test%cthis' % 27

assert c.fileCommands.cleanSaxInputString(s) == 'test this'
</t>
<t tx="ekr.20100131180007.5452">@
OMG: the hack in tnodeAttributes to support this unit test was the cause of the
weird bug that had Leo work differently in scripts than it did in unit tests!!

Let us hope that this is the worst blunder that I shall ever make.
@c

if 0: # Do **not** try to make this work: it isn't worth it.

    import leo.core.leoFileCommands as leoFileCommands
    
    class saxAttrsClass:
        '''Simulating sax attributes'''
        def __init__(self):
            self.attrs = {
                'tx':'ekr.123','testAttr':'abc',
            }
        def getNames(self):
            return list(self.attrs.keys())
        def getValue(self,key):
            return self.attrs.get(key)
    
    handler = leoFileCommands.saxContentHandler(
        c,fileName='&lt;test file&gt;',
        silent=True,inClipboard=False)
    attributes = saxAttrsClass()
    handler.tnodeAttributes(attributes)
    aList = handler.nodeList
    assert len(aList) == 1,len(aList)
    b = aList[0]
    d = b.tnodeAttributes
    assert d.get('testAttr')=='abc',d.get('testAttr')</t>
<t tx="ekr.20100131180007.5453"># A totally wimpy test.
c.abbrevCommands.dynamicExpandHelper(prefix='',rlist=None,w=None)
</t>
<t tx="ekr.20100131180007.5454">at = c.atFileCommands

at.setPathUa(p,'abc')
d = p.v.tempAttributes
d2 = d.get('read-path')
val1 = d2.get('path')
val2 = at.getPathUa(p)

table = (
    ('d2.get',val1),
    ('at.getPathUa',val2),
)
for kind,val in table:
    assert val == 'abc','kind %s expected %s got %s' % (
        kind,'abc',val)
</t>
<t tx="ekr.20100131180007.5455">at = c.atFileCommands

p2 = p.firstChild().firstChild()
path = at.fullPath(p2,simulate=True)
end = g.os_path_normpath('abc/xyz')
assert path.endswith(end),repr(path)
</t>
<t tx="ekr.20100131180007.5456"></t>
<t tx="ekr.20100131180007.5457"></t>
<t tx="ekr.20100131180007.5458">at = c.atFileCommands
d = at.scanAllDirectives(p)
</t>
<t tx="ekr.20100131180007.5459">rst = c.rstCommands
rst.initAtAutoWrite(p,fileName='&lt;test file&gt;',outputFile=None)

# Ensure we are actually testing the default logic.
d = p.v.u.get('rst-import',{})
underlines = d.get('underline_characters')
assert underlines is None,'fail 1: %s' % repr(underlines)
assert d == {},'fail 2: %s' % repr(d)
# Now test the logic.
assert rst.underlines2 == '','fail 3: %s' % repr(rst.underlines2)
assert rst.underlines1 == '=+*^~"\'`-:&gt;&lt;_', 'fail4 %s' % repr(rst.underlines1)
assert rst.atAutoWriteUnderlines == '=+*^~"\'`-:&gt;&lt;_', 'fail 5: %s' % (
    repr(rst.atAutoWriteUnderlines))
</t>
<t tx="ekr.20100131180007.5460">sax_node = g.bunch(
    attributes={
'a':'M',
'lineYOffset':"4b032e",
# A real icon attribute, see the tests below for what we expect
'icons':"5d7100287d71012855026f6e71025505746e6f6465710355047479\
70657104550466696c6571055507796f666673657471064b006805583700000\
0433a5c6c656f2e7265706f5c7472756e6b5c6c656f5c49636f6e735c54616e\
676f5c31367831365c616374696f6e735c6164642e706e67710755047870616\
471084b01550577686572657109550e6265666f7265486561646c696e65710a\
5507786f6666736574710b4b02550772656c50617468710c581b00000054616\
e676f5c31367831365c616374696f6e735c6164642e706e67710d757d710e28\
55026f6e710f68035504747970657110550466696c6571115507796f6666736\
57471124b006811583a000000433a5c6c656f2e7265706f5c7472756e6b5c6c\
656f5c49636f6e735c54616e676f5c31367831365c616374696f6e735c626f7\
4746f6d2e706e67711355047870616471144b01550577686572657115550e62\
65666f7265486561646c696e6571165507786f666673657471174b025507726\
56c506174687118581e00000054616e676f5c31367831365c616374696f6e73\
5c626f74746f6d2e706e67711975652e"
})
try:
    p2 = p.insertAsLastChild()
    v = p2.v
    c.fileCommands.handleVnodeSaxAttributes(sax_node,v)
    # print v,v.u
    d = v.u
    for attr in ('lineYOffset','icons'):
        assert d.get(attr) is not None,attr
    # The a:M attribute should mark the node.
    assert d.get('a') is None
    assert v.isMarked()
    aList = d.get('icons')
    assert aList
    assert len(aList) == 2
    for d2 in aList:
        for key in ('on','where','yoffset','file'):
            assert d2.get(key) is not None,key
finally:
    if 1:
        while p.hasChildren():
            # print('deleting',p.firstChild())
            p.firstChild().doDelete()
</t>
<t tx="ekr.20100131180007.5461">at = c.atFileCommands

fn = 'does/not/exist'
assert not g.os_path_exists(fn)
assert not at.replaceFileWithString (fn,'abc')
</t>
<t tx="ekr.20100131180007.5462"># Here is something that should generate a verbtim sentinel::

#@+leo-encoding=iso-8859-1.

# The length of this node should remain constant.

assert len(p.b) == 175,len(p.b)
</t>
<t tx="ekr.20100131180007.5463">sax_node = g.bunch(
    tnodeAttributes={
# The 'tx' attribute is handled by contentHandler.tnodeAttributes.
# 'tx':"ekr.20090701133940.1767",
'lineYOffset':"4b032e",
# A real icon attribute, see the tests below for what we expect
'icons':"5d7100287d71012855026f6e71025505746e6f6465710355047479\
70657104550466696c6571055507796f666673657471064b006805583700000\
0433a5c6c656f2e7265706f5c7472756e6b5c6c656f5c49636f6e735c54616e\
676f5c31367831365c616374696f6e735c6164642e706e67710755047870616\
471084b01550577686572657109550e6265666f7265486561646c696e65710a\
5507786f6666736574710b4b02550772656c50617468710c581b00000054616\
e676f5c31367831365c616374696f6e735c6164642e706e67710d757d710e28\
55026f6e710f68035504747970657110550466696c6571115507796f6666736\
57471124b006811583a000000433a5c6c656f2e7265706f5c7472756e6b5c6c\
656f5c49636f6e735c54616e676f5c31367831365c616374696f6e735c626f7\
4746f6d2e706e67711355047870616471144b01550577686572657115550e62\
65666f7265486561646c696e6571165507786f666673657471174b025507726\
56c506174687118581e00000054616e676f5c31367831365c616374696f6e73\
5c626f74746f6d2e706e67711975652e"
})
try:
    p2 = p.insertAsLastChild()
    v = p2.v
    c.fileCommands.handleTnodeSaxAttributes(sax_node,v)
    # print v,v.u
    d = v.u
    for attr in ('lineYOffset','icons'):
        assert d.get(attr),attr
    for attr in ('tx','a'):
        assert d.get(attr) is None,attr # A known attribute.
finally:
    if 1:
        while p.hasChildren():
            # print('deleting',p.firstChild())
            p.firstChild().doDelete()
</t>
<t tx="ekr.20100131180007.5465">class StubConfig(g.nullObject):
    pass

x = StubConfig()
assert not x.getBool(c,'mySetting')
assert not x.enabledPluginsFileName
</t>
<t tx="ekr.20100131180007.5466">p2 = p.firstChild().firstChild().firstChild()

aList = g.get_directives_dict_list(p2)
path = c.scanAtPathDirectives(aList,createPath=False)
# print (path,p2.h)
endpath = g.os_path_normpath('one/two')
assert path and path.endswith(endpath),'expected ending %s got %s' % (
    endpath,path)
</t>
<t tx="ekr.20100131180007.5467"></t>
<t tx="ekr.20100131180007.5468"></t>
<t tx="ekr.20100131180007.5469"></t>
<t tx="ekr.20100203103015.5352"></t>
<t tx="ekr.20100203103015.5353"># A copy of the code from c.createOrRecreateTempFileAsNeeded.
# Not a perfect test, but stil significant.

assert c.conflict_message,'fail 1'

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", c.conflict_message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")

assert result in (None,'cancel'),'fail 2: %s' % result</t>
<t tx="ekr.20100203103015.5354">s = c.openWithTempFilePath(p,'.py')
assert s.find('LeoTemp') &gt; -1
assert s.endswith('.py')</t>
<t tx="ekr.20100203103015.5355">@language python

table = (
    (None,'.py'),
    ('','.py'),
    ('txt','.txt'),
    ('.txt','.txt'),
)

for ext,result in table:
    result2 = c.getOpenWithExt(p,ext)
    assert result==result2,'ext: %s, expected %s, got %s' % (
        repr(ext),repr(result),repr(result2))
</t>
<t tx="ekr.20100203103015.5356">arg = ''
arg0 = 'one'
fn = '&lt;fn&gt;'
filename = '' # g.os.path.basename(arg)
vtuple = [arg0,fn]

table = (
    ('os.system',       'os.system(%s)' % (arg+fn)),
    ('os.startfile',    'os.startfile(%s)' % (arg+fn)),
    ('exec',            'exec(%s)' % (arg+fn)),
    ('os.spawnl',       'os.spawnl(%s,%s,%s)' % (arg,filename,fn)),
    ('os.spawnv',       'os.spawnv(%s,%s)' % (arg0,vtuple)),
    ('subprocess.Popen','subprocess.Popen(%s)' % vtuple),
    ('huh?',            'bad command:'+'huh?'),
)

for openType,result in table:
    if openType in ('os.spawnv','subprocess.Popen'):
        arg2 = ['one']
    else:
        arg2 = None
    result2 = c.openTempFileInExternalEditor(
        arg2,fn,openType,testing=True)
    assert result==result2,'expected %s, got %s' % (
        repr(result),repr(result2))</t>
<t tx="ekr.20100203103015.5357">def spam(): pass
lam = lambda a: None
class aCallable:
    def __call__ (self):
        pass
c = aCallable()

table = (
    ('abc',False),
    (spam,True),
    (lam,True),
    (c,True)
)

for obj,val in table:
    val2 = g.isCallable(obj)
    assert val == val2,'%s, expected %s, got %s' % (
        repr(obj),val,val2)
</t>
<t tx="ekr.20100203163606.5365">import os

def run(files):
    args = [r'python c:\python26\Tools\Scripts\2to3.py']
    for z in files:
        args.append(z)
        # args.append('-xprint')
    args.append('&gt;out2')
    args = ','.join(args)
    os.system(args)

tkPass = (
    'EditAttributes','Library',
    'URLloader','UniversalScrolling','UASearch',
    'autotrees','chapter_hoist','cleo','dump_globals',
    'expfolder','geotag','graphed','groupOperations',
    'hoist','import_cisco_config',
    'keybindings','leoupdate',
    'maximizeNewWindows', 'mnplugins','mod_labels',
    'mod_read_dir_outline','mod_tempfname','multifile',
    'newButtons','nodeActions','nodenavigator',
    'open_with','pie_menus','pluginsTest',
    'read_only_nodes','rClick',
    'scheduler','searchbar','searchbox','shortcut_button',
    'script_io_to_body','searchbox',
    'templates','textnode','tkGui','toolbar',
    'xcc_nodes',
)

passList = (
    '__init__','FileActions','UNL',
    'active_path','add_directives','attrib_edit',
    'backlink','base64Packager','baseNativeTree','bibtex','bookmarks',
    'codewisecompleter','colorize_headlines','contextmenu',
    'ctagscompleter','cursesGui','datenodes','debugger_pudb',
    'detect_urls','dtest','empty_leo_file','enable_gc','initinclass',
    'leo_to_html','leo_interface','leo_pdf','leo_to_rtf',
    'leoOPML','leoremote','lineNumbers',
    'macros','mime','mod_autosave','mod_framesize','mod_leo2ascd',
    'mod_scripting','mod_speedups','mod_timestamp',
    'nav_buttons','nav_qt','niceNosent','nodeActions','nodebar',
    'open_shell','outline_export','quit_leo',
    'paste_as_headlines','plugins_menu','pretty_print','projectwizard',
    'qtGui','qt_main','qt_quicksearch','qtframecommands',
    'quickMove',
        # Warning: changed this line by guessing!
        # func = types.MethodType(func, quickMove)
    'quicksearch','redirect_to_log','rClickBasePluginClasses',
    'run_nodes', # Changed thread.allocate_lock to threading.lock().acquire()
    'rst3',
    'scrolledmessage','setHomeDirectory','slideshow','spydershell','startfile',
    'testRegisterCommand','todo','trace_gc_plugin','trace_keys','trace_tags',
    'vim','xemacs',
)
core_files = (
    'leoApp','leoAtFile','leoCache','leoChapters','leoCommands',
    'leoEditCommands','leoFileCommands','leoFind','leoFrame',
    'leoGlobals','leoGui','leoImport','leoMenu','leoNodes',
    'leoPlugins','leoShadow','leoTangle','leoUndo',
)
external_files = (
    'ipy_leo','lproto',
)
table = (
    ('plugins',passList),
    ('plugins',tkPass),
    ('core',core_files),
    ('external',external_files),
)
files = []
for theDir,aList in table:
    for z in aList:
        if not z.endswith('.py'): z = z + '.py'
        # print(z)
        fn = os.path.abspath(os.path.join('leo',theDir,z))
        if os.path.exists(fn): files.append(fn)
        else: print('*** file not found:',fn)

run(files)
print('done: results are in out2')
</t>
<t tx="ekr.20100204053330.5367">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode = None)
try:
    p1 = p.insertAsLastChild()
    s = '\xd4\xc5\xd3\xd4' # the word 'test' in Russian, koi8-r
    if g.isPython3:
        assert g.isUnicode(s)
    else:
        s = unicode(s,'koi8-r')
    p1.setBodyString(s)
    c.selectPosition(p1)
    c.copyOutline()
    c.pasteOutline()
    p2 = p1.next()
    # self.assertEqual(p1.b, p2.b) # 'self' defined only when unit-testing.
    assert p1.b == p2.b
finally:
    if 1:
         while root.hasChildren():
              root.firstChild().doDelete(newNode = None)
    c.redraw_now(p)</t>
<t tx="ekr.20100204153116.5369">import tempfile
import os

s = 'Select the following string: . Typing and undo now work.'
fd,fn = tempfile.mkstemp(text=False)
s = g.toEncodedString(s)
os.write(fd,s)
os.close(fd)
f = open(fn,'rb')
s2 = f.read()
f.close()
assert s==s2
os.remove(fn)
print('deleted',fn)</t>
<t tx="ekr.20100204165850.5371"># These tests will be important when revising config code.</t>
<t tx="ekr.20100204165850.5373">k = c.k
colorizer = c.frame.body.getColorizer()
ed = c.editCommands

# These don't set ivars
    # 'toggle-active-pane'),
    # 'toggle-angle-brackets',
    # 'toggle-input-state'),
    # 'toggle-mini-buffer'),
    # 'toggle-split-direction'),
    
table = (
    (k,'abbrevOn','abbrev-mode'),
    (k,'enable_autocompleter','toggle-autocompleter'),
    (k,'enable_calltips','toggle-calltips'),
    (ed,'extendMode','toggle-extend-mode'),
    (c,'sparse_find','toggle-find-collapses-nodes'),
    (colorizer,'showInvisibles','toggle-invisibles'),
    (c,'sparse_move','toggle-sparse-move'),
)

for obj,ivar,command in table:
    val1 = getattr(obj,ivar)
    try:
        k.simulateCommand(command)
        val2 = getattr(obj,ivar)
        assert val2 == (not val1),'failed 1 %s' % command
        k.simulateCommand(command)
        val3 = getattr(obj,ivar)
        assert val3 == val1,'failed 2 %s' % command
        # print('pass',command)
    finally:
        setattr(obj,ivar,val1)
</t>
<t tx="ekr.20100204173354.5375">table = (
    ('ignore_case','toggle-find-ignore-case-option'),
    ('search_body','toggle-find-in-body-option'),
    ('search_headline','toggle-find-in-headline-option'),
    ('mark_changes','toggle-find-mark-changes-option'),
    ('mark_finds','toggle-find-mark-finds-option'),
    ('pattern_match','toggle-find-regex-option'),
    ('reverse','toggle-find-reverse-option'),
    ('whole_word','toggle-find-word-option'),
    ('wrap','toggle-find-wrap-around-option'),
)

finder = c.searchCommands.getHandler().finder
for ivar,command in table:
    val1 = finder.getOption(ivar)
    try:
        c.k.simulateCommand(command)
        val2 = finder.getOption(ivar)
        assert val2 == (not val1),'failed 1 %s' % command
        c.k.simulateCommand(command)
        val3 = finder.getOption(ivar)
        assert val3 == val1,'failed 2 %s' % command
    finally:
        finder.setOption(ivar,val1)
</t>
<t tx="ekr.20100205223124.5377"></t>
<t tx="ekr.20100205223124.5378">table = (
    ('syntax-error','error'),
)

for h,expected in table:
    p2 = g.findNodeInTree(c,p,h)
    assert p2,'node not found: %s' % h
    result = c.checkPythonCode(event=None,
        unittest=True,ignoreAtIgnore=True,
        suppressErrors=True,checkOnSave=False)
    assert result==expected, 'expected %s got %s' % (
        expected,result)</t>
<t tx="ekr.20100205223124.5379">def abc
    pass</t>
<t tx="ekr.20100205230621.5383">import leo.core.leoTest as leoTest

s = '''
# syntax error
def spam:
    pass
'''

try:
    leoTest.checkFileSyntax('&lt;fileName&gt;',s,suppress=True)
    assert False
except SyntaxError:
    pass
</t>
<t tx="ekr.20100205231441.5386">at = c.atFileCommands

s = '''
# no error
def spam():
    pass
'''

assert at.checkPythonSyntax(p,s),'fail 1'

s2 = '''
# syntax error
def spam:
    pass
'''

assert not at.checkPythonSyntax(p,s2,supress=True),'fail2'

if not g.unitTesting: # A hand test of at.syntaxError
    at.checkPythonSyntax(p,s2)</t>
<t tx="ekr.20100205233116.5387">@tabwidth -4

at = c.atFileCommands

s = '''
# no error
def spam():
    pass
'''

at.tabNannyNode (p,body=s,suppress=True)

s2 = '''
# syntax error
def spam:
    pass
  a = 2
'''

try:
    at.tabNannyNode(p,body=s2,suppress=True)
except IndentationError:
    pass</t>
<t tx="ekr.20100205234837.5390">@tabwidth -4

s = '''
# no error
def spam():
    pass
'''

c.tabNannyNode(p,headline=p.h,body=s,unittest=True,suppressErrors=True)

s2 = '''
# syntax error
def spam:
    pass
  a = 2
'''

try:
    c.tabNannyNode(p,headline=p.h,body=s2,unittest=True,suppressErrors=True)
except IndentationError:
    pass</t>
<t tx="ekr.20100205235740.5391">c.checkPythonCode(event=None,
    unittest=True,ignoreAtIgnore=False,
    suppressErrors=True,checkOnSave=False)</t>
<t tx="ekr.20100205235740.5392">import leo.core.leoTest as leoTest
import os

tkPass = (
    'EditAttributes','Library',
    'URLloader','UniversalScrolling','UASearch',
    'autotrees','chapter_hoist','cleo','dump_globals',
    'expfolder','geotag','graphed','groupOperations',
    'hoist','import_cisco_config',
    'keybindings','leoupdate',
    'maximizeNewWindows', 'mnplugins','mod_labels',
    'mod_read_dir_outline','mod_tempfname','multifile',
    'newButtons','nodeActions','nodenavigator',
    'open_with','pie_menus','pluginsTest',
    'read_only_nodes','rClick',
    'scheduler','searchbar','searchbox','shortcut_button',
    'script_io_to_body','searchbox',
    'templates','textnode','tkGui','toolbar',
    'xcc_nodes',
)
passList = (
    '__init__','FileActions','UNL',
    'active_path','add_directives','attrib_edit',
    'backlink','base64Packager','baseNativeTree','bibtex','bookmarks',
    'codewisecompleter','colorize_headlines','contextmenu',
    'ctagscompleter','cursesGui','datenodes','debugger_pudb',
    'detect_urls','dtest','empty_leo_file','enable_gc','initinclass',
    'leo_to_html','leo_interface','leo_pdf','leo_to_rtf',
    'leoN','leoOPML','leoremote','lineNumbers',
    'macros','mime','mod_autosave','mod_framesize','mod_leo2ascd',
    'mod_scripting','mod_speedups','mod_timestamp',
    'nav_buttons','nav_qt','niceNosent','nodeActions','nodebar',
    'open_shell','outline_export','quit_leo',
    'paste_as_headlines','plugins_menu','pretty_print','projectwizard',
    'qtGui','qt_main','qt_quicksearch','qtframecommands',
    'quickMove',
        # Warning: changed this line by guessing!
        # func = types.MethodType(func, quickMove)
    'quicksearch','redirect_to_log','rClickBasePluginClasses',
    'run_nodes', # Changed thread.allocate_lock to threading.lock().acquire()
    'rst3',
    'scrolledmessage','setHomeDirectory','slideshow','spydershell','startfile',
    'testRegisterCommand','todo','trace_gc_plugin','trace_keys','trace_tags',
    'vim','xemacs',
)
core_files = (
    'leoApp','leoAtFile','leoCache','leoChapters','leoCommands',
    'leoEditCommands','leoFileCommands','leoFind','leoFrame',
    'leoGlobals','leoGui','leoImport','leoMenu','leoNodes',
    'leoPlugins','leoShadow','leoTangle','leoUndo',
)
external_files = (
    'ipy_leo','lproto',
)
recent = (
    #'leo_interface',
)
table = (
    ('plugins',recent),
    ('plugins',passList),
    ('plugins',tkPass),
    ('core',core_files),
    ('external',external_files),
)
files = []
for theDir,aList in table:
    for z in aList:
        if not z.endswith('.py'): z = z + '.py'
        fn = os.path.abspath(os.path.join('leo',theDir,z))
        if os.path.exists(fn): files.append(fn)
        else: print('*** file not found:',fn)

failed = []
for z in files:
    fn = g.shortFileName(z)
    s,e = g.readFileIntoString(z)
    if not leoTest.checkFileSyntax(fn,s,reraise=False,suppress=False):
        failed.append(fn)

assert not failed,'failed %s\n' % g.listToString(failed,sort=True)

</t>
<t tx="ekr.20100206001203.5395">try:
    assert False
except AssertionError:
    fn,n = g.getLastTracebackFileAndLineNumber()
assert fn == '&lt;string&gt;',repr(fn)
assert n == 4,repr(n)
</t>
<t tx="ekr.20100206002004.5397"># This is just a hand test.
if not g.unitTesting:
    try:
        assert False
    except AssertionError:
        g.es_exception(full=True,c=None,color='red')
</t>
<t tx="ekr.20100206165505.5386"># More suitable as a hand test:
# it makes no effort to delete the 'Recovered Nodes' node.

c.nodeConflictList = []

for i in range(2):
    c.nodeConflictList.append(g.bunch(
        tag='(uncached)',
        gnx='gnx %s' % (i),
        fileName ='filename %s' % (i),
        b_old='old body %s' % (i),
        b_new='new body %s' % (i),
        h_old='head %s' % (i),
        h_new='head %s' % (i),
    ))

c.fileCommands.handleNodeConflicts()

c.nodeConflictList = []

c.redraw()</t>
<t tx="ekr.20100208095817.5387">import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

assert cacher.test()</t>
<t tx="ekr.20100208230953.5383"></t>
<t tx="ekr.20100209155559.5386">c.createOpenWithTempFile(p,'.py')</t>
<t tx="ekr.20100210222021.5388">import os
c1 = c
fn = g.os_path_finalize_join(g.app.loadDir,'..','test','save-new-test.py')
# print(fn)
if g.os_path_exists(fn):
    os.remove(fn)
assert not g.os_path_exists(fn)
try:
    c = c1.new()
    assert c.cacher.db is None
    # Not a perfect unit test, but it similar to c.save.
    c.mFileName = fn
    c.openDirectory = c.frame.openDirectory = g.os_path_dirname(fn)
    c.fileCommands.save(c.mFileName)
    c.close()
    assert g.os_path_exists(fn)
finally:
    if g.os_path_exists(fn):
        os.remove(fn)
</t>
<t tx="ekr.20100211110729.5389">@first # -*- coding: utf-8 -*-

# On Windows, this works with or without the following line in sitecustomize.py
# sys.setdefaultencoding('utf-8')

import os

if g.isPython3:
    fn ='.leo'
else:
    fn = g.toUnicode('.leo')

g.app.config.writeRecentFilesFileHelper(fn)
assert g.os_path_exists(fn),'fail 1'
os.remove(fn)
assert not g.os_path_exists(fn),'fail 1'</t>
<t tx="ekr.20100212072149.5341">child = g.findNodeInChildren(c,p,'syntax-error')
assert child,'no child'
script = child.b
try:
    c.goToScriptLineNumber(child,script,1)
finally:
    p.contract()
    c.selectPosition(p)
    c.redraw()</t>
<t tx="ekr.20100212072149.5342">@language python
def spam:
    pass</t>
<t tx="ekr.20100212104817.5346">c.sortRecentFiles()</t>
<t tx="ekr.20100212104817.5347">child = p.firstChild()
assert child.h == 'b','fail 1'
try:
    c.selectPosition(child)
    c.sortSiblings()
    c.redraw_now()
    child = p.firstChild()
    assert child.h == 'a'
    child = child.next()
    assert child.h == 'b'
    child = child.next()
    assert child.h == 'c'
    assert not child.next()
finally:
    c.undoer.undo()
    p.contract()
    c.redraw(p)</t>
<t tx="ekr.20100212104817.5348"></t>
<t tx="ekr.20100212104817.5349"></t>
<t tx="ekr.20100212104817.5350"></t>
<t tx="ekr.20100212104817.5351">result = c.helpCommands.getBindingsForCommand('help-for-command')
assert result.strip().lower()=='f1'</t>
<t tx="ekr.20100212110954.5359">lines = c.k.printBindings()
assert lines[0].strip().endswith('Alt+Ctrl+Shift')</t>
<t tx="ekr.20100212112056.5361">g.printGcAll()</t>
<t tx="ekr.20100216142240.5371"># The @auto node must be a child of this node
# for findNodeAnywhere to succeed with Alt-6.
fn = '../test/at-auto-unit-test.py'
root = g.findNodeAnywhere(c,'@auto %s' % (fn))
assert root,'no root'

child1 = root.firstChild()
assert child1,'no child1'
grand11 = child1.firstChild()
assert grand11,'no grand11'
grand12 = grand11.next()
assert grand12,'no grand12'

child2 = child1.next()
assert child2,'no child2'
grand21 = child2.firstChild()
assert grand21,'no grand21'
grand22 = grand21.next()
assert grand22,'no grand22'

def oops(found,p2,node,n,n2):
    result = [' ']
    result.append('goto-global-line test failed at line %s' % (n))
    if not found:
        result.append('line %s not found',n)
    else:
        result.append('got node "%s", expected "%s"' % (p2.h,node.h))
        result.append('got offset %s, expected %s' % (n2,n))
    return '\n'.join(result)

table = (
    # Use 1-based numbers externally.
    # countLines converts to zero-based numbers.
    (1, child1,  0),
    (2, grand11, 0),
    (3, grand11, 1),
    (4, grand12, 0),
    (5, grand12, 1),
    (6, child2,  0),
    (7, grand21, 0),
    (8, grand21, 1),
    (9, grand22, 0),
    (10,grand22, 1),
    (11,root,    3),
)

# Test against actual lines of the file.
path = g.os_path_finalize_join(g.app.loadDir,'..','test',fn)
f = open(path,'r') ; s = f.read() ; f.close()
lines = g.splitLines(s) # The lines from the file.
for n,node,index in table:
    goto = c.goToLineNumber(c)
    p2,n2,found = goto.countLines(root,n)
        # n, the argument to countLines, is 1-based
        # n2, the returned index into p2.b, is zero-based
    n -= 1
        # Convert n to zero-based for the comparisons below.
    lines2 = g.splitLines(p2.b)
    ok = lines2[n2].lstrip() == lines[n].lstrip() 
    if not ok:
        i = 0
        for z in lines:
            print('%2d %s' % (i,repr(z)))
            i += 1
    if not ok:
        print('at line %s, index %s, node %s\ngot line %s\nexpected %s' % (
            n,n2,p2.h,repr(lines2[n2].lstrip()),repr(lines[n].lstrip())))
    assert ok</t>
<t tx="ekr.20100219080213.5365"></t>
<t tx="ekr.20100219080213.5366">s = '''\
&lt;?php

$type = 'cc';
$obj = new $type; // outputs "hi!"

class cc {
    function __construct() {
        echo 'hi!';
    }
}

?&gt;

'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.phpUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20100219080213.5367">s = '''\
&lt;?php

if (expr) {
    class cc {
        // version 1
    }
} else {
    class cc {
        // version 2
    }
}

?&gt;
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.phpUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20100219080213.5368">s = '''\
&lt;?php
class Enum {
    protected $self = array();
    public function __construct( /*...*/ ) {
        $args = func_get_args();
        for( $i=0, $n=count($args); $i&lt;$n; $i++ )
            $this-&gt;add($args[$i]);
    }
   
    public function __get( /*string*/ $name = null ) {
        return $this-&gt;self[$name];
    }
   
    public function add( /*string*/ $name = null, /*int*/ $enum = null ) {
        if( isset($enum) )
            $this-&gt;self[$name] = $enum;
        else
            $this-&gt;self[$name] = end($this-&gt;self) + 1;
    }
}

class DefinedEnum extends Enum {
    public function __construct( /*array*/ $itms ) {
        foreach( $itms as $name =&gt; $enum )
            $this-&gt;add($name, $enum);
    }
}

class FlagsEnum extends Enum {
    public function __construct( /*...*/ ) {
        $args = func_get_args();
        for( $i=0, $n=count($args), $f=0x1; $i&lt;$n; $i++, $f *= 0x2 )
            $this-&gt;add($args[$i], $f);
    }
}
?&gt;

'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.phpUnitTest(p,s=s,showTree=False)</t>
<t tx="ekr.20100223094723.5375"></t>
<t tx="ekr.20100223094723.5376">import leo.core.leoImport as leoImport
ic = c.importCommands

s = '''\

def one():
    pass
    
import a
from . import a

@language python

d = {} # An interior comment.

# This is a comment.
# and another comment.
@aDecorator
class cl: # An interior comment
    def method(self):
        pass

def two():
    pass
    
'''

# tree = c.importCommands.pythonUnitTest(p,s=s,showTree=True)

expected = s.find('# This is a comment')
scanner = leoImport.pythonScanner(importCommands=ic,atAuto=False)
i = s.find('import a')
assert i &gt; -1
i = scanner.skipToTheNextClassOrFunction(s,i,lastIndent=0)
assert i==expected,'expected %s, got %s %s' % (
    expected,i,repr(s[i:]))
</t>
<t tx="ekr.20100223094723.5377">import leo.core.leoImport as leoImport
ic = c.importCommands

s = '''\

def one():
    pass
    
import a
from . import a

d = {}

# This is a comment.
@tabwith -4 # This looks like a comment.
# and another comment.
@aDecorator
def two():
    pass
    
'''

# tree = c.importCommands.pythonUnitTest(p,s=s,showTree=True)

expected = s.find('# This is a comment')
scanner = leoImport.pythonScanner(importCommands=ic,atAuto=False)
i = s.find('import a')
assert i &gt; -1
i = scanner.skipToTheNextClassOrFunction(s,i,lastIndent=0)
assert i==expected,'expected %s, got %s %s' % (
    expected,i,repr(s[i:]))
</t>
<t tx="ekr.20100223094723.5378">import leo.core.leoImport as leoImport
ic = c.importCommands

s = '''\

def one():
    pass
    
import a
from . import a

d = {}

# This is a comment.
# and another comment.

@tabwidth -4

aList = ('a','b','def')

if __name__ == '__main__':
    pass

'''

lastLine = 'pass\n'
expected = s.find(lastLine) + len(lastLine) + 1
scanner = leoImport.pythonScanner(importCommands=ic,atAuto=False)
i = s.find('import a')
assert i &gt; -1
i = scanner.skipToTheNextClassOrFunction(s,i,lastIndent=0)
assert i==expected,'expected %s, got %s %s' % (
    expected,i,repr(s[i:]))
</t>
<t tx="ekr.20100223094723.5379">import leo.core.leoImport as leoImport
ic = c.importCommands

s = '''\

def one():
    pass
    
import a
from . import a

if 0:
    def two():
        pass

if __name__ == '__main__':
    pass

'''

scanner = leoImport.pythonScanner(importCommands=ic,atAuto=False)
expected = i = s.find('import a')
assert i &gt; -1
i = scanner.skipToTheNextClassOrFunction(s,i,lastIndent=0)
assert i==expected,'expected %s, got %s %s' % (
    expected,i,repr(s[i:]))
</t>
<t tx="ekr.20100223123103.5382"># These commands are implemented by qtGui.py

def closeEnough(f1,f2):
    return abs(f1-f2) &lt; 0.0001

f = c.frame
ratio,ratio2 = f.ratio,f.secondary_ratio

table = (
    c.bodyWantsFocusNow,
    c.logWantsFocusNow,
    c.treeWantsFocusNow,
)

for func in table:
    func()
    f.contractPane()
    if func == c.logWantsFocusNow:
        assert ratio2 != f.secondary_ratio,'fail 1'
    else:
        assert ratio != f.ratio,'fail 2'
    func()
    f.expandPane()
    assert closeEnough(ratio,f.ratio),'fail 3 %s != %s' % (
        ratio,f.ratio)
    assert closeEnough(ratio2,f.secondary_ratio),'fail 4 %s != %s' % (
        ratio2,f.secondary_ratio)
</t>
<t tx="ekr.20100225094004.5385">s1 = '''
#@+leo-ver=4
#@+node:#@file
Line 1
#@-node:#@file
#@-leo
'''

s2 = '''
#@+leo-ver=4-thin
#@+node:ekr.20040707141957.13:#@thin
#@-node:ekr.20040707141957.13:#@thin
#@-leo
'''

at = c.atFileCommands
assert at.isFileLike(s1),'fail1'
assert not at.isFileLike(s2),'fail2'
</t>
<t tx="ekr.20100225094004.5405"># test/at-file-test.leo contains tnodeList.
# test/at-file-test.py contains file-like sentinels.
g.app.unitTestDict={}
fn = g.os_path_finalize_join(g.app.loadDir,'..','test','unittest','at-file-test.leo')
ok,frame = g.openWithFileName(fn,c)
assert frame,'no frame'
try:
    ok = False
    c2 = frame.c
    assert c2.changed,'not changed'
    p2 = g.findNodeAnywhere(c2,'@file at-file-test.py')
    assert p2,'no p2'
    assert p2.isDirty(),'not dirty'
    assert g.app.unitTestDict.get('read-convert'),'not converted'
    ok = True
finally:
    if True: # and ok:
        # Close the frame without prompt.
        g.app.destroyWindow(frame)
        c.setLog()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20100421102506.6282">@first # -*- coding: utf-8 -*-

rst = c.rstCommands

name = g.os_path_finalize_join(g.app.loadDir,'..','test','unittest','rst_write_test.txt')

s = "test(U+1FB9: Greek Capital Letter Alpha With Macron)"

if g.isPython3:
    f = open(name,'w',encoding='utf-8')
else:
    f = open(name,'w')
    s = rst.encode(s)

f.write(s)
f.close()

assert g.os_path_exists(name)
</t>
<t tx="ekr.20100507152400.5388"></t>
<t tx="ekr.20100731163237.5778">@language python

# html uses block comments.  This is an important test.

h = '@thin ../test/unittest/at-thin-html-test.html'
p = g.findNodeAnywhere(c,h)
assert p

s = (
'@language html\n\n&lt;&lt; ' +
'a section reference &gt;&gt;\n\n' +
'after.\n')

# print(repr(p.b)) ; print(repr(s))

assert p.b == s,'body failure'</t>
<t tx="ekr.20100801125533.5787">import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20100801125533.5788">@language python
@tabwidth -4
@others
#end
</t>
<t tx="ekr.20100801125533.5789">def spam(cheese):

    print(cheese)</t>
<t tx="ekr.20100801125533.5790">def cheese():

    pass</t>
<t tx="ekr.20100801125533.5791">def spam(cheese):

    print(cheese)
def cheese():

    pass
#end
</t>
<t tx="ekr.20100802220019.5795">def clone (p,parent,n):
    p2 = p.clone()
    p2.moveToNthChildOf(parent,n)
    return p2

def make (parent,n,h):
    child = parent.insertAsNthChild(n)
    child.h = h
    return child
    
def delete_r():
    '''Delete all 'Resurrected Nodes' nodes.'''
    while True:
        r = g.findNodeAnywhere(c,'Resurrected Nodes')
        if r: r.doDelete(newNode=p)
        else: break

def delete_children():
    # Delete all children of p.
    while p.hasChildren():
        p.firstChild().doDelete(newNode=p)
        
def test(p,h,tag):
    assert p,'p'
    assert p.h == 'From root','p.h %s' % tag
    assert p.numberOfChildren() == 1,'number of children %s' % tag
    assert p.firstChild().h == h,'child.h %s' % tag
        
delete_r()
delete_children()
    
# Create some children.
root = make(p,0,'root')
child1 = make(root,0,'child1')
child2 = make(root,1,'child2')
child3 = make(root,2,'child3')
child11 = make(child1,0,'child11')
child21 = make(child2,0,'child21')
child31 = make(child3,0,'child31')
# Create some clones.
child4 = clone(child31,root,3)

for z in root.self_and_subtree():
    z.setVisited()
for z in child2,child31: # These should be moved.
    z.clearVisited()

c.atFileCommands.deleteUnvisitedNodes(root)

if 1:
    r = g.findNodeAnywhere(c,'Resurrected Nodes')
    assert r,'r'
    r1 = r.firstChild()
    r2 = r1.next()
    r3 = r2.next()
    test(r1,'child2','r1')
    test(r2,'child31','r2')
    assert root.numberOfChildren() == 3,'root.n'
if 1:
    delete_r()
    delete_children()

c.redraw_now()</t>
<t tx="ekr.20100803234640.5804"></t>
<t tx="ekr.20100803234640.5805">s = '''\
; last modified 1 April 2001 by John Doe
[owner]
name=John Doe
organization=Acme Widgets Inc.
 
[database]
server=192.0.2.62     ; use IP address in case network name resolution is not working
port=143
file = "payroll.dat"
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.iniUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20100806211605.5810"></t>
<t tx="ekr.20100806211747.5792"></t>
<t tx="ekr.20100806211747.5793"></t>
<t tx="ekr.20100812172232.5800">@others</t>
<t tx="ekr.20100812172232.5801">exec(g.findTestScript(c,'@common leoRst test code'))
rst3Test(c,p)
</t>
<t tx="ekr.20100812182942.5804">class rst3Test:
    
    def __init__ (self,c,p):
        self.c = c
        self.p = p.copy()
        self.run()

    @others
</t>
<t tx="ekr.20100812182942.5805">@language rest</t>
<t tx="ekr.20100812182942.5807">@language rest

#####
Title
#####

This is test.html</t>
<t tx="ekr.20100812182942.5808">@ This is a doc part
it has two lines.
@c
This is the body of the section.</t>
<t tx="ekr.20100812213445.5814">@language html</t>
<t tx="ekr.20100812213445.5824">exec(g.findTestScript(c,'@common leoRst test code'))

rst3Test(c,p)
</t>
<t tx="ekr.20100812213445.5825">@language rest</t>
<t tx="ekr.20100812213445.5826">@ @rst-options
show_doc_parts_as_paragraphs=True
@c
#####
Title
#####

This is test.html</t>
<t tx="ekr.20100812213445.5827">@ This is a doc part
it has two lines.
@c
This is the body of the section.</t>
<t tx="ekr.20100812213445.5828">@language html</t>
<t tx="ekr.20100813100841.5824">exec(g.findTestScript(c,'@common leoRst test code'))
rst3Test(c,p)
</t>
<t tx="ekr.20100813100841.5825"># Applies to options doc parts as well.</t>
<t tx="ekr.20100813100841.5827"></t>
<t tx="ekr.20100813100841.5828"></t>
<t tx="ekr.20100813100841.5829"></t>
<t tx="ekr.20100813100841.5839">@language rest</t>
<t tx="ekr.20100813100841.5840">#####
Title
#####

This is test.html</t>
<t tx="ekr.20100813100841.5841">@ This is a doc part
it has two lines.
@c
This is the body of the section.</t>
<t tx="ekr.20100813100841.5842"></t>
<t tx="ekr.20100813100841.5843">.. rst3: filename: test.html


#####
Title
#####

This is test.html

section
+++++++

@ This is a doc part
it has two lines.
@c

This is the body of the section.

</t>
<t tx="ekr.20100813100841.5844">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.8: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
&amp;#64;c&lt;/p&gt;
&lt;p&gt;This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100813100841.5847"></t>
<t tx="ekr.20100813100841.5848">.. rst3: filename: test.html


#####
Title
#####

This is test.html

section
+++++++

@ This is a doc part
it has two lines.
This is the body of the section.

</t>
<t tx="ekr.20100813100841.5849">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.8: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100813100841.5850">exec(g.findTestScript(c,'@common leoRst test code'))
rst3Test(c,p)
</t>
<t tx="ekr.20100813100841.5854">@language rest</t>
<t tx="ekr.20100813100841.5855">@language rest

#####
Title
#####

This is test.html</t>
<t tx="ekr.20100813100841.5856">This is the body of the section.</t>
<t tx="ekr.20100813100841.5857"></t>
<t tx="ekr.20100813100841.5858">.. rst3: filename: test.html


#####
Title
#####

This is test.html

This is the body of the section.

</t>
<t tx="ekr.20100813100841.5859">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.8: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;p&gt;This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100813124317.5868"></t>
<t tx="ekr.20100813124317.5869">.. rst3: filename: test.html

#####
Title
#####

This is test.html



section
*******

This is a doc part
it has two lines.

</t>
<t tx="ekr.20100813124317.5870">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.8: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;This is a doc part
it has two lines.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100813124317.5879">exec(g.findTestScript(c,'@common leoRst test code'))
rst3Test(c,p)
</t>
<t tx="ekr.20100813124317.5880">@language rest</t>
<t tx="ekr.20100813124317.5881">#####
Title
#####

This is test.html</t>
<t tx="ekr.20100813124317.5883">@ @rst-options
doc_only_mode=True
@c
@ This is a doc part
it has two lines.
@c
This is the body of the section.</t>
<t tx="ekr.20100813124317.5884"></t>
<t tx="ekr.20100813124317.5889">.. rst3: filename: test.html

#####
Title
#####

This is test.html

section
+++++++

This is a doc part
it has two lines.

</t>
<t tx="ekr.20100813124317.5890">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.8: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;This is a doc part
it has two lines.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100817131738.5886">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20100817131738.5887">aaaa cccc dddd</t>
<t tx="ekr.20100817131738.5888">aaaa bbbb cccc dddd</t>
<t tx="ekr.20100817131738.5889">aaaa cccc dddd</t>
<t tx="ekr.20100817131738.5894">import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20100817131738.5895">aaaa bbcc dddd</t>
<t tx="ekr.20100817131738.5896">aaaa bbbb cccc dddd</t>
<t tx="ekr.20100817131738.5897">aaaa bbcc dddd</t>
<t tx="ekr.20100827140832.5913">exec(g.findTestScript(c,'@common leoRst test code'))
rst3Test(c,p)
</t>
<t tx="ekr.20100827140832.5917">@language rest</t>
<t tx="ekr.20100827140832.5918">@language rest

@ @rst-options
show_leo_directives=False
@c

#####
Title
#####

This is test.html</t>
<t tx="ekr.20100827140832.5919">@ This is a doc part
it has two lines.
@c
This is the body of the section.</t>
<t tx="ekr.20100827140832.5926"></t>
<t tx="ekr.20100827140832.5929">.. rst3: filename: test.html



#####
Title
#####

This is test.html

section
+++++++

@ This is a doc part
it has two lines.
This is the body of the section.

</t>
<t tx="ekr.20100827140832.5930">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.8: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827182529.6840"></t>
<t tx="ekr.20100827182529.6841">.. rst3: filename: test.html


#####
Title
#####

This is test.html

section
+++++++

@ This is a doc part
it has two lines.
This is the body of the section.

</t>
<t tx="ekr.20100827182529.6842">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827182529.6843"></t>
<t tx="ekr.20100827182529.6844">.. rst3: filename: test.html


#####
Title
#####

This is test.html

This is the body of the section.

</t>
<t tx="ekr.20100827182529.6845">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;p&gt;This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827182529.6846"></t>
<t tx="ekr.20100827182529.6847">.. rst3: filename: test.html

#####
Title
#####

This is test.html



section
*******

This is a doc part
it has two lines.

</t>
<t tx="ekr.20100827182529.6848">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;This is a doc part
it has two lines.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827182529.6849"></t>
<t tx="ekr.20100827182529.6850">.. rst3: filename: test.html

#####
Title
#####

This is test.html

section
+++++++

This is a doc part
it has two lines.

</t>
<t tx="ekr.20100827182529.6851">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;This is a doc part
it has two lines.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827182529.6852"></t>
<t tx="ekr.20100827182529.6853">.. rst3: filename: test.html



#####
Title
#####

This is test.html

section
+++++++

@ This is a doc part
it has two lines.
This is the body of the section.

</t>
<t tx="ekr.20100827182529.6854">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827183358.5957">def run(self):
    c,p = self.c,self.p
    rc = c.rstCommands
    expected,got,source = self.setup()
    rc.processTree(p=source.firstChild(),ext='.html',toString=True,justOneFile=True)
    rst,html = rc.source,rc.stringOutput
    assert rst,'rst'
    assert html,'html'
    # Kludge: disregard version of docutils.
    html = html.replace('Docutils 0.6','Docutils 0.8')
    if expected.hasChildren():
        child1 = expected.firstChild()
        child2 = expected.firstChild().next()
        ok = rst == child1.b and html == child2.b
        if not ok:
            got_html,got_rst = self.set_got(expected,got)
            got_html.b = html
            got_rst.b = rst
        if rst != child1.b:
            self.report(child1,got_rst)
        if html != child2.b:
            self.report(child2,got_html)
        assert rst == child1.b,'rst mismatch'
        assert html == child2.b,'html mismatch'
    else:
        child = expected.insertAsNthChild(0)
        child.h,child.b = 'rst',rst
        child = expected.insertAsNthChild(1)
        child.h,child.b = ' html',html
    </t>
<t tx="ekr.20100827183358.5958">def setup (self):
    
    c,p = self.c, self.p

    expected = g.findNodeInTree(c,p,'expected')
    got = g.findNodeInTree(c,p,'got')
    source = g.findNodeInTree(c,p,'source')

    assert source,'source'
    assert expected,'expected'

    return expected,got,source</t>
<t tx="ekr.20100827183358.5959">def set_got (self,expected,got):
    
    c,p = self.c, self.p

    if got:
        got_rst = g.findNodeInTree(c,got,'rst')
        got_html = g.findNodeInTree(c,got,'html')
        assert got_rst
        assert got_html
    else:
        got = p.insertAsLastChild()
        got.h = 'got'
        got_rst = got.insertAsNthChild(0)
        got_rst.h = 'rst'
        got_html = got.insertAsNthChild(1)
        got_html.h = 'html'

    return got_html,got_rst
</t>
<t tx="ekr.20100827194549.5963">def report (self,expected,got):
    
    expected_lines = g.splitLines(expected.b)
    got_lines = g.splitLines(got.b)
    
    for i in xrange(min(len(expected_lines),len(got_lines))):
        print ('%3d %s' % (i,repr(expected_lines[i])))
        print ('%3d %s' % (i,repr(got_lines[i])))
        if expected_lines[i] != got_lines[i]: break</t>
<t tx="ekr.20100830113702.5969">exec(g.findTestScript(c,'@common leoEditCommands test code'))
runEditCommandTest(c,p,inHeadline=False)
runEditCommandTest(c,p,inHeadline=True)
</t>
<t tx="ekr.20100830113702.5970">aaaa bbbb dddd</t>
<t tx="ekr.20100830113702.5971">aaaa bbbb cccc dddd</t>
<t tx="ekr.20100830113702.5972">aaaa bbbb dddd</t>
<t tx="ekr.20100830113702.5977">exec(g.findTestScript(c,'@common leoEditCommands test code'))
runEditCommandTest(c,p,inHeadline=False)
runEditCommandTest(c,p,inHeadline=True)
</t>
<t tx="ekr.20100830113702.5978">aaaa bbcc dddd</t>
<t tx="ekr.20100830113702.5979">aaaa bbbb cccc dddd</t>
<t tx="ekr.20100830113702.5980">aaaa bbcc dddd</t>
<t tx="ekr.20100830114008.5967">@others</t>
<t tx="ekr.20100830114008.5968">import leo.core.leoTest as leoTest

@
This is an updated version of leo.core.leoTest.runEditCommandTest,
moved here to take advantage of EKR's new common-test-code-sharing
mechanism. It should be okay to delete the old code and replace
all uses with:

    exec(g.findTestScript(c,'@common leoEditCommands test code'))
    runEditCommandTest(c,p)
@c

def runEditCommandTest (c,p,inHeadline=False):
    '''
    This is a helper for testing edit commands. It takes the name of the
    command from the title of the test and the before and after conditions
    from child nodes.
    
    :param inHeadline: if True, tests the command in the headline; if False,
    tests the command in the body.
    '''
    
    u = leoTest.testUtils(c) ; atTest = p.copy()

    h = atTest.h
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)

    work,before,after = u.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.h
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.h[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    #g.trace(repr(sels))

    c.selectPosition(work)
    
    if inHeadline:
        c.setHeadString(work,before.b)
        # To make the node visible, and edit the label
        c.redrawAndEdit(work)
        w = c.edit_widget(work)
        g.app.gui.set_focus(c,w)
    else:
        w = c.frame.body.bodyCtrl
        c.setBodyString(work,before.b)
    
    try:
        #g.trace(repr(sel1[0]),repr(sel1[1]))
        w.setSelectionRange(sel1[0],sel1[1],insert=sel1[1])
        if inHeadline:
            # simulateCommand doesn't seem to work when editing a headline
            c.k.manufactureKeyPressForCommandName(w,commandName)
        else:
            c.k.simulateCommand(commandName)

        # Exit headline-editing mode
        if inHeadline: w.event_generate('&lt;Return&gt;')
                
        location = 'headline' if inHeadline else 'body'
        s1 = work.h if inHeadline else work.b
        s2 = after.b
        
        assert s1 == s2, 'mismatch in %s\nexpected: %s\n     got: %s' % (location,repr(s2),repr(s1))
        sel3 = w.getSelectionRange()
        ins = w.toGuiIndex(w.getInsertPoint())
        #g.trace('ins',ins,'s1[j:...]',repr(s1[j:j+10]))
        # Convert both selection ranges to gui indices.
        sel2_orig = sel2
        # g.trace(w)
        assert len(sel2) == 2,'Bad headline index.  Expected index,index.  got: %s' % sel2
        i,j = sel2 ; sel2 = w.toGuiIndex(i),w.toGuiIndex(j)
        assert len(sel3) == 2,'Bad headline index.  Expected index,index.  got: %s' % sel3
        i,j = sel3 ; sel3 = w.toGuiIndex(i),w.toGuiIndex(j)
        assert sel2 == sel3, 'mismatch in sel\nexpected: %s = %s, got: %s' % (sel2_orig,sel2,sel3)
        c.selectPosition(atTest)
        atTest.contract()
        # Don't redraw.
    finally:
        # Make sure to restore the headline so it can be used for future tests
        if inHeadline:
            c.setHeadString(work,'work')
</t>
<t tx="ekr.20100902074747.5970">f = c.abbrevCommands.addAbbrevHelper
d = c.abbrevCommands.abbrevs

table = (
    ('ut1','ut1=aa','aa'),
    ('ut2','ut2 =bb','bb'),
    ('ut3','ut3=cc=dd','cc=dd'),
    ('ut4','ut4= ee',' ee'),
    ('ut5','ut5= ff = gg',' ff = gg'),
    ('ut6','ut6= hh==ii',' hh==ii'),
    ('ut7','ut7=j=k','j=k'),
    ('ut8','ut8=l==m','l==m'),
    ('@ut1','@ut1=@a','@a'),
)

for name,s,expected in table:
    for s2,kind in ((s,'(no nl)'),(s+'\n','(nl)')):
        f(s2,tag='unit-test')
        result,tag = d.get(name,(None,None),)
        assert result==expected, '%s expected &lt;%s&gt;, got &lt;%s&gt;' % (
            kind,expected,result)</t>
<t tx="ekr.20100907003013.5979">ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
ic.run(
    screenshot,
    callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",
    ],
    numbers = [2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)</t>
<t tx="sps.20100531034136.20110">p2 = p.firstChild().firstChild().firstChild()

aList = g.get_directives_dict_list(p2)
path = c.scanAtPathDirectives(aList,createPath=False)
# print (path,p2.h)
endpath = g.os_path_normpath('again/again')
assert path and path.endswith(endpath),'expected ending %s got %s' % (
    endpath,path)
</t>
<t tx="sps.20100531034136.20111"></t>
<t tx="sps.20100531034136.20112"></t>
<t tx="sps.20100531034136.20113"></t>
<t tx="sps.20100609154419.5450">i,mode = g.scanAtRootOptions("@root foo",0,err_flag=True)
assert(i == 6)
assert(mode == 'doc')
</t>
<t tx="sps.20100609154419.5451">i,mode = g.scanAtRootOptions("@root\nother",0,err_flag=True)
assert(i == 5)
assert(mode == 'doc')
</t>
<t tx="sps.20100609154419.5452">i,mode = g.scanAtRootOptions("@root-doc foo\nother",0,err_flag=True)
assert(i == 9)
assert(mode == 'doc')
</t>
<t tx="sps.20100609154419.5453">i,mode = g.scanAtRootOptions("@root-doc\nother",0,err_flag=True)
assert(i == 9)
assert(mode == 'doc')
</t>
<t tx="sps.20100609154419.5454">i,mode = g.scanAtRootOptions("@root-code foo\nother",0,err_flag=True)
assert(i == 10) # should be 10
assert(mode == 'code')
</t>
<t tx="sps.20100609154419.5455">i,mode = g.scanAtRootOptions("@root-code\nother",0,err_flag=True)
assert(i == 10)
assert(mode == 'code')
</t>
<t tx="sps.20100609154419.5456">i,mode = g.scanAtRootOptions("@root-doc-code foo\nother",0,err_flag=True)
assert(i == 14)
assert(mode == 'doc')
</t>
<t tx="sps.20100609154419.5457">i,mode = g.scanAtRootOptions("@root-doc-code\nother",0,err_flag=True)
assert(i == 14)
assert(mode == 'doc')
</t>
<t tx="sps.20100609154419.5458">i,mode = g.scanAtRootOptions("@root-code-doc foo\nother",0,err_flag=True)
assert(i == 14)
assert(mode == 'code')
</t>
<t tx="sps.20100609154419.5459">i,mode = g.scanAtRootOptions("@root-code-doc\nother",0,err_flag=True)
assert(i == 14)
assert(mode == 'code')
</t>
<t tx="sps.20100609154419.5460"></t>
<t tx="sps.20100609234650.16094">end = g.skip_blank_lines("",0)
assert end == 0, "expected 0, got %d" % end
end = g.skip_blank_lines(" ",0)
assert end == 0, "expected 0, got %d" % end
end = g.skip_blank_lines("\n",0)
assert end == 1, "expected 1, got %d" % end
end = g.skip_blank_lines(" \n",0)
assert end == 2, "expected 1, got %d" % end
end = g.skip_blank_lines("\n\na\n",0)
assert end == 2, "expected 2, got %d" % end
end = g.skip_blank_lines("\n\n a\n",0)
assert end == 2, "expected 2, got %d" % end
</t>
<t tx="sps.20100624231018.20956"># 2 failures with Alt-4</t>
<t tx="sps.20100624231018.20957"></t>
<t tx="sps.20100624231018.20958">@
scanAllDirectives formerly set tangleCommands instance variables

single_comment_string
start_comment_string
end_comment_string

which acted as state for the entire tangleCommands operation.  To support multiple languages within a node (or even a tree) these variables are now treated more dynamically.
</t>
<t tx="sps.20100624231018.20959">@language python
@comment a b c
    # @comment must follow @language
@tabwidth -4
@pagewidth 72
@encoding utf-8
@lineending crlf
@silent

t=c.tangleCommands
t.init_ivars()
d = t.scanAllDirectives(p)

# print(g.dictToString(d))

assert t.print_mode=='silent',t.print_mode

table = (
    # ('delims', ('a','b','c'),),
    ('encoding','utf-8'),
    ('language','python'),
    ('lineending','\r\n'),
    ('pagewidth',72),
    ('tabwidth',-4),
)

for kind,expected in table:
    got = d.get(kind)
    assert got == expected, 'kind: %s, expected %s, got %s' % (
        kind,repr(expected),repr(got))
</t>
<t tx="sps.20100624231018.20960"># This will work regardless of where this method is.
@language python
@tabwidth -4
@silent

t=c.tangleCommands
t.init_ivars()
d = t.scanAllDirectives(p)

assert d.get('encoding') == 'utf-8','fail encoding'
assert d.get('language') == 'python','fail language'
assert d.get('pagewidth') == 80,'fail pagewidth'
path1 = d.get('path').lower()
path2 = g.os_path_finalize_join(g.app.loadDir,'..','test').lower()
assert path1==path2,'fail path: expected %s, got %s' % (path1,path2)
assert d.get('tabwidth') == -4,'fail tabwidth'

assert t.print_mode=='silent','fail print_mode: %s' % (
    t.print_mode)
</t>
<t tx="sps.20100624231018.20961">t=c.tangleCommands
t.init_ivars()
d = t.scanAllDirectives(p.firstChild())
# d['encoding']
assert d.get('encoding') == 'utf-8','fail encoding'
# d['lang-dict']
assert d.get('lang-dict') == None, "lang-dict set to %s" % repr(d.get('lang-dict'))
# d['language']
assert d.get('language') == 'python','fail language'
# d['lineending']
assert d.get('lineending') == '\n', "lineending not \\n, instead %s" % repr(d.get(lineending))
# d['pagewidth']
assert d.get('pagewidth') == 80,'fail pagewidth'
# d['path']
path1 = d.get('path').lower()
path2 = g.os_path_finalize_join(g.app.loadDir,'..','test').lower()
assert path1==path2,'fail path: expected %s, got %s' % (path1,path2)
# d['tabwidth']
assert d.get('tabwidth') == -4,'fail tabwidth'

# From init_directive_ivars
# Global options
# page_width
assert t.page_width == 80, "expected page_width 80, is %s " % repr(t.page_width)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
self.tab_width = c.tab_width

# New in Leo 4.5: get these from settings.
# output_doc_flag
assert t.output_doc_flag == None
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None


# Default tangle options.
# tangle_directory
assert t.tangle_directory == d.get('path')

# Default tangle language
# c.target_language
assert c.target_language == "python", "expected c.target_language python, is " + repr(c.target_language)
# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)

# Abbreviations for self.language.
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# Set only from directives.
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)

# support @first directive
# first_lines
assert t.first_lines == ""

# encoding
assert t.encoding == 'utf-8'

# output_newline
assert t.output_newline == '\n'


</t>
<t tx="sps.20100624231018.20962">@root 'root-test'

# A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.20963">t=c.tangleCommands
t.init_ivars()
d = t.scanAllDirectives(p.firstChild())
# d['encoding']
assert d.get('encoding') == 'utf-8','fail encoding'
# d['lang-dict']
assert d.get('lang-dict') == None, "lang-dict set to %s" % repr(d.get('lang-dict'))
# d['language']
assert d.get('language') == 'python','fail language'
# d['lineending']
assert d.get('lineending') == '\n', "lineending not \\n, instead %s" % repr(d.get(lineending))
# d['pagewidth']
assert d.get('pagewidth') == 80,'fail pagewidth'
# d['path']
path1 = d.get('path').lower()
path2 = g.os_path_finalize_join(g.app.loadDir,'..','test').lower()
assert path1==path2,'fail path: expected %s, got %s' % (path1,path2)
# d['tabwidth']
assert d.get('tabwidth') == -4,'fail tabwidth'

# From init_directive_ivars
# Global options
# page_width
assert t.page_width == 80, "expected page_width 80, is %s " % repr(t.page_width)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
self.tab_width = c.tab_width

# New in Leo 4.5: get these from settings.
# output_doc_flag
assert t.output_doc_flag == None
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None


# Default tangle options.
# tangle_directory
assert t.tangle_directory == d.get('path')

# Default tangle language
# c.target_language
assert c.target_language == "python", "expected c.target_language python, is " + repr(c.target_language)
# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)

# Abbreviations for self.language.
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# Set only from directives.
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)

# support @first directive
# first_lines
assert t.first_lines == ""

# encoding
assert t.encoding == 'utf-8'

# output_newline
assert t.output_newline == '\n'


</t>
<t tx="sps.20100624231018.20964">@root 'root-test1'

# A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc

@root 'root-test2'

&lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.20966">t = c.tangleCommands
t.init_directive_ivars()
kind, end = t.token_type("",0)
assert(kind == 1)
assert(end == -1)

kind, end = t.token_type("@root 'root-test'\n\n# A simple test of at root",0)
assert kind == 8, 'expected kind == 8, got %s' % repr(kind)
assert end == 17, 'expected end == 17, got %s' % repr(end)
assert t.root_name=="'root-test'","expected c.tangleCommands.root_name == 'root-test', got %s" % repr(t.root_name)


kind, end = t.token_type("@ignore\n@this\n@nonsense\n@root 'root-test'\n\n# A simple test of at root",24)
assert kind == 8, 'expected kind == 8, got %s' % repr(kind)
assert end == 17, 'expected end == 17, got %s' % repr(end)
assert t.root_name=="'root-test'","expected c.tangleCommands.root_name == 'root-test', got %s" % repr(t.root_name)

kind, end = t.token_type("foo bar\n",0)
assert kind == 1, 'expected kind == 1, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)

kind, end = t.token_type("@@ foo bar\n",0)
assert kind == 2, 'expected kind == 2, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)

kind, end = t.token_type("@chapter foo bar\n",0)
assert kind == 3, 'expected kind == 3, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)

kind, end = t.token_type("@c foo bar",0)
assert kind == 5, 'expected kind == 5, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)

kind, end = t.token_type("@code foo bar",0)
assert kind == 5, 'expected kind == 5, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)

assert not t.raw_cweb_flag, "raw_cweb_flag should default false, is %s" % repr(t.raw_cweb_flag)
kind, end = t.token_type("@ foo bar",0)
assert kind == 6, 'expected kind == 6, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)
kind, end = t.token_type("@doc foo bar",0)
assert kind == 6, 'expected kind == 6, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)

t.raw_cweb_flag = True
kind, end = t.token_type("@ foo bar",0)
assert kind == 1, 'expected kind == 6, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)
kind, end = t.token_type("@doc foo bar",0)
assert kind == 6, 'expected kind == 6, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)
t.raw_cweb_flag = False

# @space is a discontinued directive
kind, end = t.token_type("@space foo bar",0)
assert kind == 7, 'expected kind == 7, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)

# @language falls into the "other" grabbag
kind, end = t.token_type("@language foo bar",0)
assert kind == 7, 'expected kind == 7, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)

# note that spaces get included in file names, but not newlines
kind, end = t.token_type("@root foo bar",0)
assert kind == 8, 'expected kind == 7, got %s' % repr(kind)
assert end == 13, 'expected end == 13, got %s' % repr(end)
kind, end = t.token_type("@root foo bar\nbut not this\n",0)
assert kind == 8, 'expected kind == 7, got %s' % repr(kind)
assert end == 13, 'expected end == 13, got %s' % repr(end)

kind, end = t.token_type("@section foo bar\nbut not this\n",0)
assert kind == 9, 'expected kind == 7, got %s' % repr(kind)
assert end == -1, 'expected end == -1, got %s' % repr(end)

# (most) CWEB control codes are no longer recognized
# those still special:
#   @@ - literal @
#   @  - (@ followed by space) start doc mode
#   @c - start code mode
for s in "*dfsp&lt;(h^.:t=q!'&amp;l,/|#+;[]xyzi":
    kind, end = t.token_type("@%s foo" % s,0)
    assert kind == 7, 'for @%s expected kind == 7, got %s' % (s, repr(kind))
    assert end == -1, 'expected end == -1, got %s' % repr(end)

# token_type also calls skip_section_name
close_sect = "&gt;&gt;"
# section_ref
kind, end = t.token_type("&lt;&lt; section ref "+close_sect+"\nblah",0)
assert kind == 13, 'expected kind == 13, got %s' % repr(kind)
assert end == 17, 'expected end == 17, got %s' % repr(end)

# section_def
kind, end = t.token_type("&lt;&lt; section ref "+close_sect+"= blah",0)
assert kind == 14, 'expected kind == 12, got %s' % repr(kind)
assert end == 17, 'expected end == 17, got %s' % repr(end)

# would be at_root, but fails due to lack of @root headline support,
# so instead is bad_section_ref (i.e., don't interpret angle brackets
kind, end = t.token_type("&lt;&lt; * "+close_sect+"= blah",0)
assert kind == 12, 'expected kind == 12, got %s' % repr(kind)
assert end == 7, 'expected end == 7, got %s' % repr(end)
@
# The other token types which need to be tested are
at_web     = 11 # any CWEB control code, except at_at.

# Returned by self.skip_section_name() and allies and used by token_type.
bad_section_name = 12  # &lt; &lt; with no matching &gt; &gt;
section_ref  = 13  # &lt; &lt; name &gt; &gt;
section_def  = 14  # &lt; &lt; name &gt; &gt; =</t>
<t tx="sps.20100624231018.20968">g.app.scanErrors = 0
t = c.tangleCommands
t.init_directive_ivars()
end = t.setRootFromText("@root 'root-test'\n\n# A simple test of at root\n",True)
assert end == 17, "expected end == 17, got %s" % repr(end)
assert t.root_name == "'root-test'", "expected root_name == 'root-test', got %s" % repr(t.root_name)
assert g.app.scanErrors == 0, "expected g.app.scanError == 0, got %s" % repr(g.app.scanErrors)

end = t.setRootFromText("@root 'root-test'",True)
assert end == 17, "expected end == 17, got %s" % repr(end)
assert t.root_name == "'root-test'", "expected root_name == 'root-test', got %s" % repr(t.root_name)
assert g.app.scanErrors == 0, "expected g.app.scanError == 0, got %s" % repr(g.app.scanErrors)

end = t.setRootFromText("@root &lt; root-test &gt;",True)
assert end == 18, "expected end == 17, got %s" % repr(end)
assert t.root_name == "root-test", "expected root_name == 'root-test', got %s" % repr(t.root_name)
assert g.app.scanErrors == 0, "expected g.app.scanError == 0, got %s" % repr(g.app.scanErrors)

end = t.setRootFromText("@root &lt; root-test ",True)
assert end == 18, "expected end == 17, got %s" % repr(end)
assert t.root_name == None, "expected root_name == None, got %s" % repr(t.root_name)
assert g.app.scanErrors == 1, "expected g.app.scanError == 1, got %s" % repr(g.app.scanErrors)

end = t.setRootFromText("@root &lt; root-test \nfoo",True)
assert end == 18, "expected end == 17, got %s" % repr(end)
assert t.root_name == None, "expected root_name == None, got %s" % repr(t.root_name)
assert g.app.scanErrors == 2, "expected g.app.scanError == 2, got %s" % repr(g.app.scanErrors)

g.app.scanErrors = 0

</t>
<t tx="sps.20100624231018.20970">t=c.tangleCommands
t.init_ivars()
t.init_directive_ivars()
lang_dict = {'language':None,'delims':None}
t.parent_language_comment_settings(p,lang_dict)
t.language             = lang_dict.get('language')
t.init_delims          = lang_dict.get('delims')

delims = new_delims = t.init_delims
t.tangling = True
t.st_enter("'root-test'",False,False,delims,new_delims,is_root_flag=True)
# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 1, "expected root_list to have length 1, is %d" % len(t.root_list)
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))

</t>
<t tx="sps.20100624231018.20972">t=c.tangleCommands
t.init_ivars()
t.init_directive_ivars()
lang_dict = {'language':None,'delims':None}
t.parent_language_comment_settings(p,lang_dict)
t.language             = lang_dict.get('language')
t.init_delims          = lang_dict.get('delims')
delims = new_delims = t.init_delims
t.tangling = True
t.st_enter_root_name("'root-test'",False,False,delims,new_delims)
# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 1, "expected root_list to have length 1, is %d" % len(t.root_list)
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))

</t>
<t tx="sps.20100624231018.20973"></t>
<t tx="sps.20100624231018.20974">t=c.tangleCommands
t.init_ivars()
t.init_directive_ivars()
delims = t.init_delims
t.tangling = True
new_delims = t.skip_body(p.firstChild(),delims)
# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 1, "expected root_list to have length 1, is %d" % len(t.root_list)
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test'", "expected root_list[0].name to be 'root-test', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))
</t>
<t tx="sps.20100624231018.20975">@root 'root-test'

# A trivial test of @root.
</t>
<t tx="sps.20100624231018.20976">t=c.tangleCommands
t.init_ivars()
t.init_directive_ivars()
delims = t.init_delims
t.tangling = True
new_delims = t.skip_body(p.firstChild(),delims)
# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 2, "expected root_list to have length 2, is %d" % len(t.root_list)
# first @root
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test-one'", "expected root_list[0].name to be 'root-test-one', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))
# second @root
assert t.root_list[1].__class__ == leo.core.leoTangle.tst_node, "expected root_list[1] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[1]))
assert t.root_list[1].is_root
assert t.root_list[1].name == "'root-test-two'", "expected root_list[0].name to be 'root-test-two', is %s" % t.root_list[1].name
assert t.root_list[1].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[1].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[1].parts[0]))
</t>
<t tx="sps.20100624231018.20977">@root 'root-test-one'

# test of @root first.

@root 'root-test-two'

# test o @root second
</t>
<t tx="sps.20100624231018.20978"></t>
<t tx="sps.20100624231018.20979">t = c.tangleCommands
t.p = p.firstChild()
t.init_ivars()
t.scanAllDirectives(p)
delims = t.init_delims
assert delims == ("#", '', ''), "expected delims == ('#','','') got %s" % repr(delims)
t.tangling = True
t.tanglePass1(p.firstChild(),delims)

result = t.st_dump()
# avoid spurious interpolation
close_sect = "&gt;&gt;"
expect = """
dump of symbol table...

section: 'root-test', referenced:True, is root:True
----- parts of &lt;&lt;'root-test'""" + close_sect + """
----- Part 1
doc:  [u'']
code: [u'# A trivial test of @root.']
delims: &lt;#&gt;&lt;&gt;&lt;&gt;
----- end of partList

section delims: ('#', '', '')
"""
assert result[0:240] == expect[0:240]

# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 1, "expected root_list to have length 1, is %d" % len(t.root_list)
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test'", "expected root_list[0].name to be 'root-test', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))
</t>
<t tx="sps.20100624231018.20980">@root 'root-test'

# A trivial test of @root.
</t>
<t tx="sps.20100624231018.20981">t = c.tangleCommands
t.init_ivars()
t.init_directive_ivars()
delims = t.init_delims
t.tangling = True
t.tanglePass1(p.firstChild(),delims)

result = t.st_dump()
# avoid spurious interpolation
close_sect = "&gt;&gt;"
expect = """
dump of symbol table...

section: 'root-test-one', referenced:True, is root:True
----- parts of &lt;&lt;'root-test-one'"""+close_sect+"""
----- Part 1
doc:  [u'']
code: [u'# test of @root first.']
delims: &lt;#&gt;&lt;&gt;&lt;&gt;
----- end of partList

section delims: ('#', '', '')
section: 'root-test-two', referenced:True, is root:True
----- parts of &lt;&lt;'root-test-two'"""+close_sect+"""
----- Part 1
doc:  ['']
code: [u'# test o @root second']
delims: &lt;#&gt;&lt;&gt;&lt;&gt;
----- end of partList

section delims: ('#', '', '')"""
assert result == expect

# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 2, "expected root_list to have length 2, is %d" % len(t.root_list)
# first @root
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test-one'", "expected root_list[0].name to be 'root-test-one', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))
# second @root
assert t.root_list[1].__class__ == leo.core.leoTangle.tst_node, "expected root_list[1] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[1]))
assert t.root_list[1].is_root
assert t.root_list[1].name == "'root-test-two'", "expected root_list[0].name to be 'root-test-two', is %s" % t.root_list[1].name
assert t.root_list[1].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[1].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[1].parts[0]))
</t>
<t tx="sps.20100624231018.20982">@root 'root-test-one'

# test of @root first.

@root 'root-test-two'

# test o @root second
</t>
<t tx="sps.20100624231018.20983"></t>
<t tx="sps.20100624231018.20984">t=c.tangleCommands
t.init_ivars()
t.init_directive_ivars()
delims = t.init_delims
t.tangling = True
new_delims = t.tanglePass1(p.firstChild(),delims)
assert t.root_list
t.tangling = True
g.unitTesting = True
t.tanglePass2()
# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 1, "expected root_list to have length 1, is %d" % len(t.root_list)
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test'", "expected root_list[0].name to be 'root-test', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))
assert sorted(t.tangle_output) == ["'root-test'"], "expected one output file ["'root-test'"], got %s" % repr(t.tangle_output)
</t>
<t tx="sps.20100624231018.20985">@root 'root-test'

# A trivial test of @root.
</t>
<t tx="sps.20100624231018.20986">t=c.tangleCommands
t.init_ivars()
t.init_directive_ivars()
delims = t.init_delims
t.tangling = True
new_delims = t.tanglePass1(p.firstChild(),delims)
assert t.root_list
t.tanglePass2()
# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 2, "expected root_list to have length 2, is %d" % len(t.root_list)
# first @root
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test-one'", "expected root_list[0].name to be 'root-test-one', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))
# second @root
assert t.root_list[1].__class__ == leo.core.leoTangle.tst_node, "expected root_list[1] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[1]))
assert t.root_list[1].is_root
assert t.root_list[1].name == "'root-test-two'", "expected root_list[0].name to be 'root-test-two', is %s" % t.root_list[1].name
assert t.root_list[1].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[1].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[1].parts[0]))
# tanglePass2 conversion to file
assert sorted(t.tangle_output) == ["'root-test-one'", "'root-test-two'"], "expected two output files ["'root-test-one'", "'root-test-two'"], got %s" % repr(t.tangle_output)
</t>
<t tx="sps.20100624231018.20987">@root 'root-test-one'

# test of @root first.

@root 'root-test-two'

# test o @root second
</t>
<t tx="sps.20100624231018.20988"></t>
<t tx="sps.20100624231018.20989">t=c.tangleCommands
t.init_ivars()
t.init_directive_ivars()
delims = t.init_delims
t.tangling = True
new_delims = t.tanglePass1(p.firstChild(),delims)
assert t.root_list
assert g.app.scanErrors == 0
t.tangling = True
t.p = None
g.unitTesting = True
t.put_all_roots()
# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 1, "expected root_list to have length 1, is %d" % len(t.root_list)
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test'", "expected root_list[0].name to be 'root-test', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))
assert sorted(t.tangle_output) == ["'root-test'"], "expected one output file ["'root-test'"], got %s" % repr(t.tangle_output)
</t>
<t tx="sps.20100624231018.20990">@root 'root-test'

# A trivial test of @root.
</t>
<t tx="sps.20100624231018.20991">t=c.tangleCommands
t.init_ivars()
t.init_directive_ivars()
delims = t.init_delims
t.tangling = True
new_delims = t.tanglePass1(p.firstChild(),delims)
assert t.root_list
t.tangling = True
t.p = None
g.unitTesting = True
t.put_all_roots()
# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "python", "expected language python, is %s" % repr(c.tanglCommands.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 2, "expected root_list to have length 2, is %d" % len(t.root_list)
# first @root
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test-one'", "expected root_list[0].name to be 'root-test-one', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))
# second @root
assert t.root_list[1].__class__ == leo.core.leoTangle.tst_node, "expected root_list[1] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[1]))
assert t.root_list[1].is_root
assert t.root_list[1].name == "'root-test-two'", "expected root_list[0].name to be 'root-test-two', is %s" % t.root_list[1].name
assert t.root_list[1].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[1].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[1].parts[0]))
# tanglePass2 conversion to file
assert sorted(t.tangle_output) == ["'root-test-one'", "'root-test-two'"], "expected two output files ["'root-test-one'", "'root-test-two'"], got %s" % repr(t.tangle_output)
</t>
<t tx="sps.20100624231018.20992">@root 'root-test-one'

# test of @root first.

@root 'root-test-two'

# test o @root second
</t>
<t tx="sps.20100624231018.20993"></t>
<t tx="sps.20100624231018.20994"></t>
<t tx="sps.20100624231018.20995"></t>
<t tx="sps.20100624231018.20996"></t>
<t tx="sps.20100624231018.20997">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.20998">@language c
@root 'root-test'

// A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.20999">// A simple test of @root.

// &lt;&lt; secref &gt;&gt;
abc
// -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21000">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21001">@root 'root-test'

# A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21002"># A simple test of @root.

# &lt;&lt; secref &gt;&gt;
abc
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21003">@
Without a setting of @bool at_root_bodies_start_in_doc_mode = False, tangled
nodes begin in doc mode.  It is only in subnodes of root-code that the nodes
begin in code-mode.
</t>
<t tx="sps.20100624231018.21004">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21005">A comment to ignore

@root-doc 'root-test'

# A simple test of @root-doc.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21006"># A simple test of @root-doc.

# &lt;&lt; secref &gt;&gt;
abc
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21007">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21008">A comment to ignore

@root-doc 'root-test'

# A simple test of @root-code.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21009">&lt;&lt; secref &gt;&gt;=
xyz
</t>
<t tx="sps.20100624231018.21010"># A simple test of @root-code.

# &lt;&lt; secref &gt;&gt; (1 of 2)
abc
# &lt;&lt; secref &gt;&gt; (2 of 2)
xyz
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21011">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21012">A comment to ignore

@root-code 'root-test'

# A simple test of @root-code.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21013">&lt;&lt; secref &gt;&gt;=
xyz
@
A comment section

&lt;&lt; secref &gt;&gt;=
uvw
</t>
<t tx="sps.20100624231018.21014"># A simple test of @root-code.

# &lt;&lt; secref &gt;&gt; (1 of 3)
abc
# &lt;&lt; secref &gt;&gt; (2 of 3)
xyz
# &lt;&lt; secref &gt;&gt; (3 of 3)
uvw
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21015">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21016">@root 'root-test'

# A less simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
    &lt;&lt; secref one &gt;&gt;
    &lt;&lt; secref two &gt;&gt;
</t>
<t tx="sps.20100624231018.21017">Contents of secref one.
@c
plus some code
</t>
<t tx="sps.20100624231018.21018">Contents of secref two.
@c
and some more code
</t>
<t tx="sps.20100624231018.21019"># A less simple test of @root.

# &lt;&lt; secref &gt;&gt;
    # &lt;&lt; secref one &gt;&gt;
    plus some code
    # -- end -- &lt;&lt; secref one &gt;&gt;
    # &lt;&lt; secref two &gt;&gt;
    and some more code
    # -- end -- &lt;&lt; secref two &gt;&gt;
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21020">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21021">@root 'root-test'

# A less simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
    &lt;&lt; secref one &gt;&gt;
    &lt;&lt; secref two &gt;&gt;
</t>
<t tx="sps.20100624231018.21022">Contents of secref one.
@c
plus some code
</t>
<t tx="sps.20100624231018.21023">Contents of secref two.
@c
and some more code
</t>
<t tx="sps.20100624231018.21024"># A less simple test of @root.

# &lt;&lt; secref &gt;&gt;
    # &lt;&lt; secref one &gt;&gt;
    plus some code
    # -- end -- &lt;&lt; secref one &gt;&gt;
    # &lt;&lt; secref two &gt;&gt;
    and some more code
    # -- end -- &lt;&lt; secref two &gt;&gt;
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21025">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21026">@root-doc 'root-test'

# A less simple test of @root-doc.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
    &lt;&lt; secref one &gt;&gt;
    &lt;&lt; secref two &gt;&gt;
</t>
<t tx="sps.20100624231018.21027">Contents of secref one.
</t>
<t tx="sps.20100624231018.21028">Contents of secref two.
</t>
<t tx="sps.20100624231018.21029"># A less simple test of @root-doc.

# &lt;&lt; secref &gt;&gt;
    # &lt;&lt; secref one &gt;&gt;

    # -- end -- &lt;&lt; secref one &gt;&gt;
    # &lt;&lt; secref two &gt;&gt;

    # -- end -- &lt;&lt; secref two &gt;&gt;
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21030">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21031">@root-code 'root-test'

# A less simple test of @root-code.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
    &lt;&lt; secref one &gt;&gt;
    &lt;&lt; secref two &gt;&gt;
</t>
<t tx="sps.20100624231018.21032">Contents of secref one.
</t>
<t tx="sps.20100624231018.21033">Contents of secref two.
</t>
<t tx="sps.20100624231018.21034"># A less simple test of @root-code.

# &lt;&lt; secref &gt;&gt;
    # &lt;&lt; secref one &gt;&gt;
    Contents of secref one.
    # -- end -- &lt;&lt; secref one &gt;&gt;
    # &lt;&lt; secref two &gt;&gt;
    Contents of secref two.
    # -- end -- &lt;&lt; secref two &gt;&gt;
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21035">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21036">@comment #
@root 'root-test'

# A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21037"># A simple test of @root.

# &lt;&lt; secref &gt;&gt;
abc
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21038">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21039">@comment /* */
@root 'root-test'

/* A simple test of @root. */

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21040">/* A simple test of @root. */

/* &lt;&lt; secref &gt;&gt; */
abc
/* -- end -- &lt;&lt; secref &gt;&gt; */
</t>
<t tx="sps.20100624231018.21041">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21042">@comment // /* */
@root 'root-test'

/* A simple test of @root. */

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21043">/* A simple test of @root. */

// &lt;&lt; secref &gt;&gt;
abc
// -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21044">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21045">@language html
@root 'root-test'

&lt;!-- A simple test of @root. --&gt;

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21046">&lt;!-- A simple test of @root. --&gt;

&lt;!-- &lt;&lt; secref &gt;&gt; --&gt;
abc
&lt;!-- -- end -- &lt;&lt; secref &gt;&gt; --&gt;
</t>
<t tx="sps.20100624231018.21047"># directory foo must exist, or scanAtPathDirectives ignores it.
import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p.firstChild())</t>
<t tx="sps.20100624231018.21048">@path foo</t>
<t tx="sps.20100624231018.21049">@root 'root-test'

# A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21050"># A simple test of @root.

# &lt;&lt; secref &gt;&gt;
abc
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21051"># directory foo must exist or scanAtPathDirectives will ignore it
import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21052">@path foo
@root 'root-test'

# A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21053"># A simple test of @root.

# &lt;&lt; secref &gt;&gt;
abc
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21054">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21055">@path /tmp
@root 'root-test'

# A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21056"># A simple test of @root.

# &lt;&lt; secref &gt;&gt;
abc
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21057">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)
</t>
<t tx="sps.20100624231018.21058"># multiple @root directives
@root 'root-test-one'
# content of root-test-one
&lt;&lt; secref &gt;&gt;

@root 'root-test-two'
# content of root-test-two
&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
content common to both root files
</t>
<t tx="sps.20100624231018.21059"># content of root-test-one
# &lt;&lt; secref &gt;&gt;
content common to both root files
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21060"># content of root-test-two
# &lt;&lt; secref &gt;&gt;
content common to both root files
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21061">@
This code formerly generated the error "Multiple parts are not allowed for &lt;&lt; secref &gt;&gt;".
That restriction has been removed.
</t>
<t tx="sps.20100624231018.21062">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21063">A comment to ignore

@root-doc 'root-test'

# A simple test of @root-doc.
&lt;&lt; secref &gt;&gt;
@
ignored documentation
</t>
<t tx="sps.20100624231018.21064">ignored comment
@c
xyz

</t>
<t tx="sps.20100624231018.21065">
&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21066"># A simple test of @root-doc.
# &lt;&lt; secref &gt;&gt; (1 of 2)
xyz
# &lt;&lt; secref &gt;&gt; (2 of 2)
abc
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21067">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21068">A comment to ignore

@root-doc 'root-test'

# A simple test of @root-doc.
&lt;&lt; secref &gt;&gt;
@
ignored documentation
</t>
<t tx="sps.20100624231018.21069">ignored comment
@c
xyz
@
second ignored comment
&lt;&lt; secref &gt;&gt;=
abc
</t>
<t tx="sps.20100624231018.21070"># A simple test of @root-doc.
# &lt;&lt; secref &gt;&gt; (1 of 2)
xyz
# &lt;&lt; secref &gt;&gt; (2 of 2)
abc
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21071">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21072">A comment to ignore

@root-doc 'root-test'

# A simple test of @root-doc.
&lt;&lt; secref &gt;&gt;
@
ignored documentation
</t>
<t tx="sps.20100624231018.21073">
&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21074">ignored comment
@c
xyz

</t>
<t tx="sps.20100624231018.21075"># A simple test of @root-doc.
# &lt;&lt; secref &gt;&gt; (1 of 2)
abc
# &lt;&lt; secref &gt;&gt; (2 of 2)
xyz
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21076">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21077">A comment to ignore

@root-doc 'root-test'

# A simple test of @root-doc.
&lt;&lt; secref &gt;&gt;
@
ignored documentation
</t>
<t tx="sps.20100624231018.21078">ignored comment part 1
@c
abc
</t>
<t tx="sps.20100624231018.21079">ignored comment part 2
@c
xyz

</t>
<t tx="sps.20100624231018.21080"># A simple test of @root-doc.
# &lt;&lt; secref &gt;&gt; (1 of 2)
abc
# &lt;&lt; secref &gt;&gt; (2 of 2)
xyz
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100624231018.21082"># untangle places the recovered @comment directives as the very last line
# in a code section.  A blank line following an @comment is part of the
# code section, and the recovered @comment line gets put after it; if you
# want a blank line to survive a round trip, use an @ at the beginning of
# the line to make it a doc part belonging to the following section
import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)

</t>
<t tx="sps.20100624231018.21083">@language html
@root 'root-test'
&lt;&lt;Text section&gt;&gt;
&lt;&lt;Javascript section&gt;&gt;
&lt;&lt;Second text section&gt;&gt;

&lt;&lt;Text section&gt;&gt;=
Hi.  This is html text.
&lt;script language="javascript"&gt;&lt;!--
@comment //
@
&lt;&lt;Javascript section&gt;&gt;=
var s = "string";
--&gt;&lt;/script&gt;
@comment &lt;!-- --&gt;
@
&lt;&lt;Second text section&gt;&gt;=
This is a second piece of html text. </t>
<t tx="sps.20100624231018.21084">&lt;!-- &lt;&lt;Text section&gt;&gt; --&gt;
Hi.  This is html text.
&lt;script language="javascript"&gt;&lt;!--

// -- end -- &lt;&lt;Text section&gt;&gt;
// &lt;&lt;Javascript section&gt;&gt;
var s = "string";
--&gt;&lt;/script&gt;

&lt;!-- -- end -- &lt;&lt;Javascript section&gt;&gt; --&gt;
&lt;!-- &lt;&lt;Second text section&gt;&gt; --&gt;
This is a second piece of html text.
&lt;!-- -- end -- &lt;&lt;Second text section&gt;&gt; --&gt;
</t>
<t tx="sps.20100624231018.21086"># The javascript section is not correctly getting the
# @comment directive applied to its trailing sentinel

import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21087">@language html
@root 'root-test'

&lt;!-- A less simple test of @root. --&gt;

&lt;&lt; secref &gt;&gt;

@
secref governed by @lang html
&lt;&lt; secref &gt;&gt;=
abc

&lt;script type="text/javascript"&gt;&lt;!--
&lt;&lt; javascript section &gt;&gt;
@
End the secref definition before starting the
javascript section with the new comment convention
@comment //
&lt;&lt; javascript section &gt;&gt;=
var foo = 1;
@comment &lt;!-- --&gt;
--&gt;&lt;/script&gt;</t>
<t tx="sps.20100624231018.21089">&lt;!-- A less simple test of @root. --&gt;

&lt;!-- &lt;&lt; secref &gt;&gt; --&gt;
abc

&lt;script type="text/javascript"&gt;&lt;!--
// &lt;&lt; javascript section &gt;&gt;
var foo = 1;
--&gt;&lt;/script&gt;
&lt;!-- -- end -- &lt;&lt; javascript section &gt;&gt; --&gt;
&lt;!-- -- end -- &lt;&lt; secref &gt;&gt; --&gt;
</t>
<t tx="sps.20100624231018.21090"></t>
<t tx="sps.20100624231018.21091"># This is an unimplemented alternative design
# The question is whether (a) a section's delimiters are
# determined by what they were when it was defined or
# (b) whether they are determined by the context in which
# they are interpolated.  I've implemented (a)

import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21092">@language html
@root 'root-test'

&lt;!-- A less simple test of @root. --&gt;

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc

&lt;script type="text/javascript"&gt;
@comment //
&lt;&lt; javascript section &gt;&gt;
&lt;/script&gt;
@comment &lt;!-- --&gt;

&lt;&lt; javascript section &gt;&gt;=
var foo = 1;
</t>
<t tx="sps.20100624231018.21093">var i;
</t>
<t tx="sps.20100624231018.21094">&lt;!-- A less simple test of @root. --&gt;

&lt;!-- &lt;&lt; secref &gt;&gt; --&gt;
abc

&lt;script type="text/javascript"&gt;
// @comment //
// &lt;&lt; javascript section &gt;&gt;
var i;
// -- end -- &lt;&lt; javascript section &gt;&gt;
&lt;/script&gt;
&lt;!-- -- end -- &lt;&lt; secref &gt;&gt; --&gt;
</t>
<t tx="sps.20100624231018.21095"></t>
<t tx="sps.20100624231018.21096">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100624231018.21097">@silent
@root 'root-test'

# A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100624231018.21098"># A simple test of @root.

abc


</t>
<t tx="sps.20100624231018.21099"></t>
<t tx="sps.20100624231018.21100">import leo.core.leoTest as leoTest

leoTest.runRootFileUntangleTest(c,p)</t>
<t tx="sps.20100624231018.21101">@root foo

# A trivial test of @root.
</t>
<t tx="sps.20100624231018.21102">@root foo

# A trivial test of @root.
# A line added
</t>
<t tx="sps.20100624231018.21103"># A trivial test of @root.
# A line added
</t>
<t tx="sps.20100625103510.5658">t = c.tangleCommands
t.init_directive_ivars()

# input to t.skip_section_name must begin with &lt;&lt;
try:
    i, kind, end = t.skip_section_name("foo",0)
except AssertionError:
    pass

# bad section name
i, kind, end = t.skip_section_name("&lt;&lt; foo",0)
assert i == 2, "expected i == 0, got %s" % repr(i)
assert kind == 12, "expected kind == 12, got %s" % repr(kind)
assert end == -1, "expected end == -1, got %s" % repr(end)

close_sect = "&gt;&gt;" # avoid section reference in this code
i, kind, end = t.skip_section_name("&lt;&lt; foo "+close_sect,0)
assert i == 9, "expected i == 9, got %s" % repr(i)
assert end == 9, "expected end == 9, got %s" % repr(end)
assert kind == 13, "expected kind == 13, got %s" % repr(kind)

i, kind, end = t.skip_section_name("&lt;&lt; foo "+close_sect+" bar",0)
assert i == 9, "expected i == 9, got %s" % repr(i)
assert end == 9, "expected end == 9, got %s" % repr(end)
assert kind == 13, "expected kind == 13, got %s" % repr(kind)

i, kind, end = t.skip_section_name("&lt;&lt; foo "+close_sect+"= bar",0)
assert i == 10, "expected i == 10, got %s" % repr(i)
assert end == 9, "expected end == 9, got %s" % repr(end)
assert kind == 14, "expected kind == 14, got %s" % repr(kind)

# noweb style root ref.  requires implementation of @root in headline
i, kind, end = t.skip_section_name("&lt;&lt; * "+close_sect+"= bar",0)
assert i == 8, "expected i == 8, got %s" % repr(i)
assert end == 7, "expected end == 7, got %s" % repr(end)
assert kind == 8, "expected kind == 8, got %s" % repr(kind)
</t>
<t tx="sps.20100625103510.5793"># For tangling
t = c.tangleCommands
t.init_ivars()
t.scanAllDirectives(p.firstChild())
delims = t.init_delims
t.tangling = True
t.tanglePass1(p.firstChild(),delims)

result = t.st_dump()
# avoid spurious interpolation
close_sect = "&gt;&gt;"
expect = """
dump of symbol table...

section: 'root-test', referenced:True, is root:True
----- parts of &lt;&lt;'root-test'"""+close_sect+"""
----- Part 1
doc:  [u'@language html']
code: [u'&lt;!-- A less simple test of @root. --&gt;\\n\\n&lt;&lt; secref """+close_sect+"""']
delims: &lt;&gt;&lt;&lt;!--&gt;&lt;--"""+close_sect+"""
----- end of partList

section delims: ('', '&lt;!--', '--&gt;')
section: javascript section, referenced:True, is root:False
----- parts of &lt;&lt;javascript section"""+close_sect+"""
----- Part 1
doc:  ['']
code: [u'var foo = 1;\\n@comment &lt;!-- --&gt;\\n--&gt;&lt;/script&gt;']
delims: &lt;//&gt;&lt;&gt;&lt;&gt;
----- end of partList

section delims: ('', u'&lt;!--', u'--&gt;')
section: secref, referenced:True, is root:False
----- parts of &lt;&lt;secref"""+close_sect+"""
----- Part 1
doc:  [u'secref governed by @lang html']
code: [u'abc\\n\\n@comment //\\n&lt;script type="text/javascript"&gt;&lt;!--\\n&lt;&lt; javascript section """+close_sect+"""']
delims: &lt;&gt;&lt;&lt;!--&gt;&lt;--"""+close_sect+"""
----- end of partList

section delims: (u'//', '', '')"""

assert result == expect

# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "python", "expected language python, is %s" % repr(t.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 1, "expected root_list to have length 1, is %d" % len(t.root_list)
# first @root
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test'", "expected root_list[0].name to be 'root-test', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))

# Untangle, stage1
t.init_ivars()
t.scanAllDirectives(p)
delims = t.init_delims
t.tangling = False
t.untangle_stage1 = True

t.tanglePass1(p.firstChild(),delims)

result = t.st_dump()
# avoid spurious interpolation
close_sect = "&gt;&gt;"
expect = """
dump of symbol table...

section: 'root-test', referenced:True, is root:True
----- parts of &lt;&lt;'root-test'"""+close_sect+"""
----- Part 1
doc:  [u'@language html']
code: [u'&lt;!-- A less simple test of @root. --&gt;\\n\\n&lt;&lt; secref """+close_sect+"""']
delims: &lt;&gt;&lt;&lt;!--&gt;&lt;--"""+close_sect+"""
    ref: [u'secref']
----- end of partList

section delims: ('', '&lt;!--', '--&gt;')
section: javascript section, referenced:True, is root:False
----- parts of &lt;&lt;javascript section"""+close_sect+"""
----- Part 1
doc:  ['']
code: [u'var foo = 1;\\n@comment &lt;!-- --&gt;\\n--&gt;&lt;/script&gt;']
delims: &lt;//&gt;&lt;&gt;&lt;&gt;
----- end of partList

section delims: ('', u'&lt;!--', u'--&gt;')
section: secref, referenced:True, is root:False
----- parts of &lt;&lt;secref"""+close_sect+"""
----- Part 1
doc:  [u'secref governed by @lang html']
code: [u'abc\\n\\n@comment //\\n&lt;script type="text/javascript"&gt;&lt;!--\\n&lt;&lt; javascript section """+close_sect+"""']
delims: &lt;&gt;&lt;&lt;!--&gt;&lt;--"""+close_sect+"""
    ref: [u'javascript section']
----- end of partList

section delims: (u'//', '', '')"""

assert result == expect, """symbol table was supposed to be
===========================================================
%s
===========================================================
but was the following instead:
===========================================================
%s
===========================================================""" % (expect,result)

# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)
# language
assert t.language == "python", "expected language python, is %s" % repr(t.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 1, "expected root_list to have length 1, is %d" % len(t.root_list)
# first @root
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test'", "expected root_list[0].name to be 'root-test', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))
</t>
<t tx="sps.20100625103510.5794">@language html
@root 'root-test'

&lt;!-- A less simple test of @root. --&gt;

&lt;&lt; secref &gt;&gt;

@
secref governed by @lang html
&lt;&lt; secref &gt;&gt;=
abc

@comment //
&lt;script type="text/javascript"&gt;&lt;!--
&lt;&lt; javascript section &gt;&gt;

&lt;&lt; javascript section &gt;&gt;=
var foo = 1;
@comment &lt;!-- --&gt;
--&gt;&lt;/script&gt;
</t>
<t tx="sps.20100627223129.5655"></t>
<t tx="sps.20100627223129.5656">t=c.tangleCommands
t.language="python"
t.init_delims=("#","","")
@language html
lang_dict={'language':None, 'delims':None}
t.parent_language_comment_settings(p.firstChild(),lang_dict)
assert lang_dict['language'] == "html" and lang_dict['delims'] == ("","&lt;!--","--&gt;"), r'expected language html, delims "","&lt;!--","--&gt;", got '+repr(lang_dict)
</t>
<t tx="sps.20100627223129.5657"></t>
<t tx="sps.20100627223129.5660">t=c.tangleCommands
t.language="python"
t.init_delims=("#","","")
@language html
lang_dict={'language':None, 'delims':None}
t.parent_language_comment_settings(p.firstChild(),lang_dict)
assert lang_dict['language'] == "html" and lang_dict['delims'] == ("//","",""), r'expected language html, delims "//","","", got '+repr(lang_dict)
@comment //
</t>
<t tx="sps.20100627223129.5661"></t>
<t tx="sps.20100627225153.5667">t=c.tangleCommands
t.language="python"
t.init_delims=("#","","")
@language html
lang_dict={'language':None, 'delims':None}
t.parent_language_comment_settings(p.firstChild(),lang_dict)
assert lang_dict['language'] == "python" and lang_dict['delims'] == ("#","",""), r'expected language html, delims "//","","", got '+repr(lang_dict)
@comment //

@language python
</t>
<t tx="sps.20100627225153.5668"></t>
<t tx="sps.20100627232933.5673">t=c.tangleCommands
t.language="python"
t.init_delims=("#","","")
lang_dict={'language':None, 'delims':None}
t.parent_language_comment_settings(p.firstChild().firstChild(),lang_dict)
assert lang_dict['language'] == "html" and lang_dict['delims'] == ("","&lt;!--","--&gt;"), r'expected language html, delims "","&lt;!--","--&gt;", got '+repr(lang_dict)
</t>
<t tx="sps.20100627232933.5674"></t>
<t tx="sps.20100627232933.5677">@language html
@root 'root-test'

&lt;!-- A less simple test of @root. --&gt;

&lt;&lt; secref &gt;&gt;

@
secref governed by @lang html
&lt;&lt; secref &gt;&gt;=
abc

@comment //
&lt;script type="text/javascript"&gt;&lt;!--
&lt;&lt; javascript section &gt;&gt;

&lt;&lt; javascript section &gt;&gt;=
var foo = 1;
@comment &lt;!-- --&gt;
--&gt;&lt;/script&gt;
</t>
<t tx="sps.20100628022850.5677"># For tangling
t = c.tangleCommands
t.init_ivars()
t.scanAllDirectives(p.firstChild().firstChild())
delims = t.init_delims
t.tangling = True
t.tanglePass1(p.firstChild().firstChild(),delims)

result = t.st_dump()
# avoid spurious interpolation
close_sect = "&gt;&gt;"
expect = """
dump of symbol table...

section: 'root-test', referenced:True, is root:True
----- parts of &lt;&lt;'root-test'"""+close_sect+"""
----- Part 1
doc:  [u'@language html']
code: [u'&lt;!-- A less simple test of @root. --&gt;\\n\\n&lt;&lt; secref """+close_sect+"""']
delims: &lt;&gt;&lt;&lt;!--&gt;&lt;--"""+close_sect+"""
----- end of partList

section delims: ('', '&lt;!--', '--&gt;')
section: javascript section, referenced:True, is root:False
----- parts of &lt;&lt;javascript section"""+close_sect+"""
----- Part 1
doc:  ['']
code: [u'var foo = 1;\\n@comment &lt;!-- --&gt;\\n--&gt;&lt;/script&gt;']
delims: &lt;//&gt;&lt;&gt;&lt;&gt;
----- end of partList

section delims: ('', u'&lt;!--', u'--&gt;')
section: secref, referenced:True, is root:False
----- parts of &lt;&lt;secref"""+close_sect+"""
----- Part 1
doc:  [u'secref governed by @lang html']
code: [u'abc\\n\\n@comment //\\n&lt;script type="text/javascript"&gt;&lt;!--\\n&lt;&lt; javascript section """+close_sect+"""']
delims: &lt;&gt;&lt;&lt;!--&gt;&lt;--"""+close_sect+"""
----- end of partList

section delims: (u'//', '', '')"""

assert result == expect

# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)

# language
assert t.language == "html", "expected language html, is %s" % repr(t.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 1, "expected root_list to have length 1, is %d" % len(t.root_list)
# first @root
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test'", "expected root_list[0].name to be 'root-test', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))

# Untangle, stage1
t.init_ivars()
t.scanAllDirectives(p)
delims = t.init_delims
t.tangling = False
t.untangle_stage1 = True

t.tanglePass1(p.firstChild(),delims)

result = t.st_dump()
# avoid spurious interpolation
close_sect = "&gt;&gt;"
expect = """
dump of symbol table...

section: 'root-test', referenced:True, is root:True
----- parts of &lt;&lt;'root-test'"""+close_sect+"""
----- Part 1
doc:  [u'@language html']
code: [u'&lt;!-- A less simple test of @root. --&gt;\\n\\n&lt;&lt; secref """+close_sect+"""']
delims: &lt;&gt;&lt;&lt;!--&gt;&lt;--"""+close_sect+"""
    ref: [u'secref']
----- end of partList

section delims: ('', '&lt;!--', '--&gt;')
section: javascript section, referenced:True, is root:False
----- parts of &lt;&lt;javascript section"""+close_sect+"""
----- Part 1
doc:  ['']
code: [u'var foo = 1;\\n@comment &lt;!-- --&gt;\\n--&gt;&lt;/script&gt;']
delims: &lt;//&gt;&lt;&gt;&lt;&gt;
----- end of partList

section delims: ('', u'&lt;!--', u'--&gt;')
section: secref, referenced:True, is root:False
----- parts of &lt;&lt;secref"""+close_sect+"""
----- Part 1
doc:  [u'secref governed by @lang html']
code: [u'abc\\n\\n@comment //\\n&lt;script type="text/javascript"&gt;&lt;!--\\n&lt;&lt; javascript section """+close_sect+"""']
delims: &lt;&gt;&lt;&lt;!--&gt;&lt;--"""+close_sect+"""
    ref: [u'javascript section']
----- end of partList

section delims: (u'//', '', '')"""

assert result == expect, """symbol table was supposed to be
===========================================================
%s
===========================================================
but was the following instead:
===========================================================
%s
===========================================================""" % (expect,result)

# remainder: attributes of t
# cweb related
#     raw_cweb_flag
assert t.raw_cweb_flag == False, "raw_cweb_flag expected False, is %s" % repr(t.raw_cweb_flag)
# language
assert t.language == "html", "expected language html, is %s" % repr(t.language)
# output_doc_flag
assert t.output_doc_flag == None
# print_mode
assert t.print_mode == "verbose", "expected print_mode verbose, is %s " % repr(t.print_mode)
# tab_width
assert t.tab_width == -4, "expected tab_width -4, is %s " % repr(t.tab_width)
# tangle_batch_flag
assert t.tangle_batch_flag == None
# untangle_batch_flag
assert t.untangle_batch_flag == None
# use_header_flag
assert t.use_header_flag == None

import leo.core.leoTangle
# root_list
assert len(t.root_list) == 1, "expected root_list to have length 1, is %d" % len(t.root_list)
# first @root
assert t.root_list[0].__class__ == leo.core.leoTangle.tst_node, "expected root_list[0] to be instance of tst_node, dir() is %s " % repr(dir(t.root_list[0]))
assert t.root_list[0].is_root
assert t.root_list[0].name == "'root-test'", "expected root_list[0].name to be 'root-test', is %s" % t.root_list[0].name
assert t.root_list[0].parts[0].__class__ == leo.core.leoTangle.part_node, "expected root_list[0].parts[0] to be instance of part_node, dir() is %s " % repr(dir(t.root_list[0].parts[0]))
</t>
<t tx="sps.20100628022850.5678">@language html
@root 'root-test'

&lt;!-- A less simple test of @root. --&gt;

&lt;&lt; secref &gt;&gt;

@
secref governed by @lang html
&lt;&lt; secref &gt;&gt;=
abc

@comment //
&lt;script type="text/javascript"&gt;&lt;!--
&lt;&lt; javascript section &gt;&gt;

&lt;&lt; javascript section &gt;&gt;=
var foo = 1;
@comment &lt;!-- --&gt;
--&gt;&lt;/script&gt;
</t>
<t tx="sps.20100628022850.5679"></t>
<t tx="sps.20100629094515.16515">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100629094515.16516">@root 'root-test'

# A trivial test of @root.
@nocolor
abc</t>
<t tx="sps.20100629094515.16517"># A trivial test of @root.
@nocolor
abc
</t>
<t tx="sps.20100629164540.5728"># Untangle adds a line immediately *after* a section reference

import leo.core.leoTest as leoTest

leoTest.runRootFileUntangleTest(c,p)</t>
<t tx="sps.20100629164540.5729">@language html
@root 'root-test'

&lt;!-- A less simple test of @root. --&gt;

&lt;&lt; secref &gt;&gt;

@
secref governed by @lang html
&lt;&lt; secref &gt;&gt;=
abc

&lt;script type="text/javascript"&gt;&lt;!--
&lt;&lt; javascript section &gt;&gt;
@
End the secref definition before starting the
javascript section with the new comment convention
@comment //
&lt;&lt; javascript section &gt;&gt;=
var foo = 1;
@comment &lt;!-- --&gt;
--&gt;&lt;/script&gt;</t>
<t tx="sps.20100629164540.5730">&lt;!-- A less simple test of @root. --&gt;

&lt;!-- &lt;&lt; secref &gt;&gt; --&gt;
abc

&lt;script type="text/javascript"&gt;&lt;!--
// &lt;&lt; javascript section &gt;&gt;
var foo = 1;
--&gt;&lt;/script&gt;
&lt;!-- -- end -- &lt;&lt; javascript section &gt;&gt; --&gt;
add a line to secref
&lt;!-- -- end -- &lt;&lt; secref &gt;&gt; --&gt;
</t>
<t tx="sps.20100629164540.5733">@language html
@root 'root-test'

&lt;!-- A less simple test of @root. --&gt;

&lt;&lt; secref &gt;&gt;

@
secref governed by @lang html
&lt;&lt; secref &gt;&gt;=
abc

&lt;script type="text/javascript"&gt;&lt;!--
&lt;&lt; javascript section &gt;&gt;
add a line to secref
@
End the secref definition before starting the
javascript section with the new comment convention
@comment //
&lt;&lt; javascript section &gt;&gt;=
var foo = 1;
@comment &lt;!-- --&gt;
--&gt;&lt;/script&gt;</t>
<t tx="sps.20100629184507.5695"># Untangle adds a line immediately *before* a section reference

import leo.core.leoTest as leoTest

leoTest.runRootFileUntangleTest(c,p)</t>
<t tx="sps.20100629184507.5696">@language html
@root 'root-test'

&lt;!-- A less simple test of @root. --&gt;

&lt;&lt; secref &gt;&gt;

@
secref governed by @lang html
&lt;&lt; secref &gt;&gt;=
abc

&lt;script type="text/javascript"&gt;&lt;!--
&lt;&lt; javascript section &gt;&gt;
@
End the secref definition before starting the
javascript section with the new comment convention
@comment //
&lt;&lt; javascript section &gt;&gt;=
var foo = 1;
@comment &lt;!-- --&gt;
--&gt;&lt;/script&gt;</t>
<t tx="sps.20100629184507.5697">@language html
@root 'root-test'

&lt;!-- A less simple test of @root. --&gt;

&lt;&lt; secref &gt;&gt;

@
secref governed by @lang html
&lt;&lt; secref &gt;&gt;=
abc

&lt;script type="text/javascript"&gt;&lt;!--
add a line to secref
&lt;&lt; javascript section &gt;&gt;
@
End the secref definition before starting the
javascript section with the new comment convention
@comment //
&lt;&lt; javascript section &gt;&gt;=
var foo = 1;
@comment &lt;!-- --&gt;
--&gt;&lt;/script&gt;</t>
<t tx="sps.20100629184507.5698">&lt;!-- A less simple test of @root. --&gt;

&lt;!-- &lt;&lt; secref &gt;&gt; --&gt;
abc

&lt;script type="text/javascript"&gt;&lt;!--
add a line to secref
// &lt;&lt; javascript section &gt;&gt;
var foo = 1;
--&gt;&lt;/script&gt;
&lt;!-- -- end -- &lt;&lt; javascript section &gt;&gt; --&gt;
&lt;!-- -- end -- &lt;&lt; secref &gt;&gt; --&gt;
</t>
<t tx="sps.20100629215924.5705"># Untangle adds lines in seven different places

import leo.core.leoTest as leoTest

leoTest.runRootFileUntangleTest(c,p)</t>
<t tx="sps.20100629215924.5706">@language html
@root 'root-test'

&lt;!-- A less simple test of @root. --&gt;

&lt;&lt; secref &gt;&gt;

@
secref governed by @lang html
&lt;&lt; secref &gt;&gt;=
abc

&lt;script type="text/javascript"&gt;&lt;!--
&lt;&lt; javascript section &gt;&gt;
@
End the secref definition before starting the
javascript section with the new comment convention
@comment //
&lt;&lt; javascript section &gt;&gt;=
var foo = 1;
--&gt;&lt;/script&gt;
@comment &lt;!-- --&gt;
</t>
<t tx="sps.20100629215924.5707">@language html
@root 'root-test'

&lt;!-- A less simple test of @root. --&gt;
1 Add a line to the root node before the secref
&lt;&lt; secref &gt;&gt;
7 Add a line after secref at the end of the root node

@
secref governed by @lang html
&lt;&lt; secref &gt;&gt;=
2 Add a line at the beginning of secref
abc

&lt;script type="text/javascript"&gt;&lt;!--
3 Add a line to secref right before javascript section 
&lt;&lt; javascript section &gt;&gt;
6 Add a line after the javascript section and at the end of the secref section
@
End the secref definition before starting the
javascript section with the new comment convention
@comment //
&lt;&lt; javascript section &gt;&gt;=
4 Add a line to the beginning of the javascript section
var foo = 1;
--&gt;&lt;/script&gt;
5 Add a line to the end of the javascript section
@comment &lt;!-- --&gt;
</t>
<t tx="sps.20100629215924.5708">&lt;!-- A less simple test of @root. --&gt;
1 Add a line to the root node before the secref
&lt;!-- &lt;&lt; secref &gt;&gt; --&gt;
2 Add a line at the beginning of secref
abc

&lt;script type="text/javascript"&gt;&lt;!--
3 Add a line to secref right before javascript section 
// &lt;&lt; javascript section &gt;&gt;
4 Add a line to the beginning of the javascript section
var foo = 1;
--&gt;&lt;/script&gt;
5 Add a line to the end of the javascript section

&lt;!-- -- end -- &lt;&lt; javascript section &gt;&gt; --&gt;
6 Add a line after the javascript section and at the end of the secref section
&lt;!-- -- end -- &lt;&lt; secref &gt;&gt; --&gt;
7 Add a line after secref at the end of the root node
</t>
<t tx="sps.20100715131351.6756">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)

</t>
<t tx="sps.20100715131351.6757">@ Comment part of foo
Several lines
of
it
@c
// Foo contents
&lt;&lt;blorf&gt;&gt;
&lt;&lt;quux&gt;&gt;
&lt;&lt;blorf&gt;&gt;=
    bar
&lt;&lt;quux&gt;&gt;=
    more quux
</t>
<t tx="sps.20100715131351.6758">@language c
@root root_bug.c
&lt;&lt;foo&gt;&gt;
&lt;&lt;blorf&gt;&gt;=
@ comment for blorf: lack of code formerly caused untangle death
&lt;&lt;quux&gt;&gt;=
    quux
</t>
<t tx="sps.20100715131351.6759">// &lt;&lt;foo&gt;&gt;
// Foo contents
// &lt;&lt;blorf&gt;&gt;
    bar
// -- end -- &lt;&lt;blorf&gt;&gt;
// &lt;&lt;quux&gt;&gt; (1 of 2)
    quux
// &lt;&lt;quux&gt;&gt; (2 of 2)
    more quux
// -- end -- &lt;&lt;quux&gt;&gt;
// -- end -- &lt;&lt;foo&gt;&gt;
</t>
<t tx="sps.20100715131351.6762"></t>
<t tx="sps.20100720205345.16593">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100720205345.16594">@quiet
@root 'root-test'

# A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100720205345.16595"># A simple test of @root.

# &lt;&lt; secref &gt;&gt;
abc
</t>
<t tx="sps.20100720210022.5737">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100720210022.5738">@terse
@root 'root-test'

# A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100720210022.5739"># A simple test of @root.

# &lt;&lt; secref &gt;&gt;
abc
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="sps.20100720210022.5743">import leo.core.leoTest as leoTest

leoTest.runRootFileTangleTest(c,p)</t>
<t tx="sps.20100720210022.5744">&lt;&lt;*&gt;&gt;=

# A simple test of @root.

&lt;&lt; secref &gt;&gt;

&lt;&lt; secref &gt;&gt;=
abc</t>
<t tx="sps.20100720210022.5745"># A simple test of @root.

# &lt;&lt; secref &gt;&gt;
abc
# -- end -- &lt;&lt; secref &gt;&gt;
</t>
<t tx="ville.20090312195309.2">#if this starts failing due to much refacting in unitTest.leo,
# adjust accordingly

# These seem to fail if various nodes are cloned.
import random,fnmatch

all_h = [z.copy().h for z in c.find_h('.')]

assert len(all_h) &gt; 1000
    
sample = random.sample(all_h, 20)    

# Test that all nodes are found at least once.
for h in sample:
    pat = fnmatch.translate(h)
    pl = c.find_h(pat)
    assert len(pl) &gt; 0 and len(pl) &lt; len(all_h)

tests = c.find_h('@test(.*)')

bm = tests.select_b('(.*)all_positions')
forloops = 0
for node in bm:   
    # many of these are for loops
    for m in node.matchiter:
        if 'for' in m.group(1):
            forloops += 1
            
assert forloops &gt; 10

# all of these should also be found by find_b
all_bm = c.find_b('(.*)all_positions')
assert len(all_bm) &gt;= len(bm)

assert set(el.h for el in bm).issubset(set(el.h for el in all_bm))

itertest = c.find_h('@test p.iters and v.iters')
assert len(itertest) &gt;= 1
tn = itertest[0]
assert tn.h == '@test p.iters and v.iters'
assert len(itertest.select_b('notfound, really')) == 0
assert len(itertest.select_b('leoNodes')) == 1
chi = itertest.select_h('child?')
assert chi[0].h == 'child1'
assert chi[1].h == 'child2'
# twice, in clones
chi_b = chi.select_h('a').select_h('b')
assert len(chi_b) == 2

assert chi_b[0].h == chi_b[1].h == 'b'
chi_e = chi.select_h('d').select_h('e')
assert len(chi_e) == 1
assert chi_e[0].h == 'e'</t>
<t tx="ville.20090602190735.4770">_foo = 0

@g.command('my-test-command')
def mytestcommand(event):
    global _foo

    _foo = 1

c.k.simulateCommand('my-test-command')
assert _foo == 1

# bonus test: c.app.commanders()
assert c in g.app.commanders()



</t>
</tnodes>
</leo_file>
