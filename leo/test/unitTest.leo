<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.50" body_secondary_ratio="0.50">
	<global_window_position top="187" left="405" height="786" width="1161"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070417092935"><vh>Startup</vh>
<v t="ekr.20101220161557.6011"><vh>@file unitTestStartup.txt</vh></v>
</v>
<v t="ekr.20051012104957"><vh>@ignore Docs</vh>
<v t="bwmulder.20050108100437.1"><vh>How to run unit tests</vh></v>
<v t="ekr.20050618061835"><vh>How to use the @test directive, by Roger Erens</vh>
<v t="ekr.20050618061835.1"><vh>Intro</vh>
<v t="ekr.20050618061835.2"><vh>@url http://www.onlamp.com/pub/a/python/2005/02/03/tdd_pyunit2.html</vh></v>
</v>
<v t="ekr.20050618061835.3"><vh>Preparations: adding a button</vh>
<v t="ekr.20050618061835.4"><vh>@@button Do @test</vh></v>
</v>
<v t="ekr.20050618061835.5"><vh>Alpha</vh>
<v t="ekr.20050618061835.6"><vh>@test my first Leo test</vh></v>
<v t="ekr.20050618061835.7"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.8"><vh>Bravo</vh>
<v t="ekr.20050618061835.9"><vh>@@test my second Leo test</vh></v>
<v t="ekr.20050618061835.10"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.11"><vh>It takes two to tango</vh>
<v t="ekr.20050618061835.6"></v>
<v t="ekr.20050618061835.9"></v>
<v t="ekr.20050618061835.12"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.13"><vh>Life gets more interesting</vh>
<v t="ekr.20050618061835.14"><vh>@@test koekiemonster.wants()</vh>
<v t="ekr.20050618061835.15"><vh>input data</vh></v>
<v t="ekr.20050618061835.16"><vh>expected result</vh></v>
</v>
<v t="ekr.20050618061835.17"><vh>output on the console</vh></v>
<v t="ekr.20050618061835.18"><vh>output on the console using print statements</vh></v>
</v>
<v t="ekr.20050618061835.19"><vh>How about @suite?</vh></v>
<v t="ekr.20050618061835.20"><vh>Final remarks</vh></v>
</v>
<v t="ekr.20111211094936.3970"><vh>@ignore To do</vh>
<v t="ekr.20111115080347.3872"><vh>To do: tests of the high-level interface</vh>
<v t="ekr.20100131171342.5478"><vh>@@@test that log and body implements high-level interface</vh></v>
</v>
<v t="ekr.20100131171342.5473"><vh>Tk gui tests</vh>
<v t="ekr.20100131171342.5474"><vh>@test leoBody is subset of leoTkBody</vh></v>
<v t="ekr.20100131171342.5475"><vh>@test leoFrame is subset of leoTkFrame</vh></v>
<v t="ekr.20100131171342.5476"><vh>@test leoGui is subset of leoTkGui</vh></v>
<v t="ekr.20100131171342.5477"><vh>@test leoTree is subset of leoTkTree</vh></v>
</v>
<v t="ekr.20111125183140.3952"><vh>@test ic.createOutline changes back-slashes to slashes</vh></v>
<v t="ekr.20111125182408.3947"><vh>@test ic.createImportParent changes back-slashes to slashes</vh></v>
</v>
</v>
<v t="ekr.20071113203234"><vh>@ignore Test files</vh>
<v t="ekr.20111214104615.3942"><vh>@@@auto unittest/at-auto-section-ref-test.py</vh>
<v t="ekr.20161011092326.7"><vh>at-auto-section-ref-test declarations</vh></v>
</v>
<v t="ekr.20161130041921.1"><vh>@@auto-rst unittest/at-auto-rst-line-number-test.py</vh>
<v t="ekr.20161228071435.1"><vh>@nosent c:\test\bug-354-test.py</vh>
<v t="ekr.20161228071822.1"><vh>&lt;&lt; u:1 &gt;&gt;</vh></v>
<v t="ekr.20161228071836.1"><vh>&lt;&lt; ue:1 &gt;&gt;</vh></v>
<v t="ekr.20161228071849.1"><vh>&lt;&lt; u:2 &gt;&gt;</vh></v>
<v t="ekr.20161228071905.1"><vh>&lt;&lt; ue: 2&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20110615130436.3317"><vh>@@file nonexistent-directory/orphan-bit-test.txt</vh></v>
<v t="ekr.20080907122804.1"><vh>@@shadow unittest/at-shadow-line-number-test.py</vh>
<v t="ekr.20150208213643.15"><vh>spam</vh></v>
<v t="ekr.20150208213643.16"><vh>eggs</vh></v>
</v>
<v t="ekr.20090704085350.5014"><vh>@@shadow unittest/at-shadow-test.py</vh>
<v t="ekr.20150208213643.12"><vh>spam</vh></v>
<v t="ekr.20150208213643.13"><vh>eggs</vh></v>
</v>
<v t="ekr.20111213122041.3930"><vh>@@shadow unittest/at-shadow-unlink-clones.py</vh>
<v t="ekr.20150208213643.18"><vh>Node 1</vh></v>
<v t="ekr.20150208213643.19"><vh>Node 2</vh></v>
</v>
<v t="ekr.20090704085350.5028"><vh>@asis unittest/at-asis-test.py</vh>
<v t="ekr.20090704085350.5029"><vh>spam</vh></v>
<v t="ekr.20090704085350.5030"><vh>eggs</vh></v>
</v>
<v t="ekr.20080904084223.1"><vh>@auto unittest/at-auto-line-number-test.py</vh>
<v t="ekr.20170504122721.1"><vh>at_auto_child</vh></v>
</v>
<v t="ekr.20150626101842.1"><vh>@auto unittest/at-auto-md-line-number-test.md</vh>
<v t="ekr.20170504122721.2"><vh>section 1</vh></v>
<v t="ekr.20170504122721.3"><vh>section 2</vh></v>
</v>
<v t="ekr.20090704085350.5056"><vh>@auto unittest/at-auto-test.py</vh>
<v t="ekr.20170504122721.4"><vh>spam</vh></v>
<v t="ekr.20170504122721.5"><vh>eggs</vh></v>
</v>
<v t="ekr.20110610122533.3407"><vh>@auto unittest/at-auto-unit-test.py</vh>
<v t="ekr.20170504122721.6"><vh>class class1</vh>
<v t="ekr.20170504122721.7"><vh>class1_method1</vh></v>
<v t="ekr.20170504122721.8"><vh>class1_method2</vh></v>
</v>
<v t="ekr.20170504122721.9"><vh>class class2</vh>
<v t="ekr.20170504122721.10"><vh>class2_method1</vh></v>
<v t="ekr.20170504122721.11"><vh>class2_method2</vh></v>
</v>
</v>
<v t="ekr.20161130052935.1"><vh>@auto-ctext unittest/at-auto-ctext-test.txt</vh>
<v t="ekr.20170504122721.12"><vh>A level one node</vh></v>
<v t="ekr.20170504122721.13"><vh>Another level one node</vh>
<v t="ekr.20170504122721.14"><vh>A level 2 node</vh></v>
</v>
</v>
<v t="ekr.20150626101627.1"><vh>@auto-org unittest/at-auto-org-line-number-test.py</vh>
<v t="ekr.20170504122721.15"><vh>section 1</vh></v>
<v t="ekr.20170504122721.16"><vh>section 2</vh></v>
</v>
<v t="ekr.20150626100719.1"><vh>@auto-otl unittest/at-auto-otl-line-number-test.py</vh>
<v t="ekr.20170504122721.17"><vh>section 1</vh></v>
<v t="ekr.20170504122721.18"><vh>section 2</vh></v>
</v>
<v t="ekr.20150626093745.1"><vh>@auto-rst unittest/at-auto-rst-line-number-test.txt</vh></v>
<v t="ekr.20160403143048.1"><vh>@clean unittest/at-clean-line-number-test.c</vh>
<v t="ekr.20160403143048.2"><vh>spam</vh></v>
<v t="ekr.20160403150121.1"><vh>eggs</vh></v>
</v>
<v t="ekr.20160403143130.1"><vh>@clean unittest/at-clean-line-number-test.py</vh>
<v t="ekr.20160403150216.1"><vh>spam</vh></v>
<v t="ekr.20160403150222.1"><vh>eggs</vh></v>
</v>
<v t="ekr.20170401122024.7"><vh>@file C:/leo.repo/leo-editor/leo/test/unittest/input/cweave.w</vh></v>
<v t="ekr.20160403123754.1"><vh>@file unittest/at-file-line-number-test.c</vh>
<v t="ekr.20160403123754.2"><vh>at-file-child</vh></v>
</v>
<v t="ekr.20080904102243.2"><vh>@file unittest/at-file-line-number-test.py</vh>
<v t="ekr.20080904102243.3"><vh>at-file-child</vh></v>
</v>
<v t="ekr.20111021115306.3697"><vh>@file unittest/tex-error.tex</vh>
<v t="ekr.20111021115306.3711"><vh>&lt;&lt; Document &gt;&gt;</vh></v>
</v>
<v t="ekr.20130912092638.4150"><vh>@file unittest/utf-16-test.txt</vh></v>
<v t="ekr.20080907123324.2"><vh>@nosent unittest/at-nosent-line-number-test.py</vh>
<v t="ekr.20080907123324.3"><vh>spam</vh></v>
<v t="ekr.20160403152507.1"><vh>eggs</vh></v>
</v>
<v t="ekr.20090704085350.5034"><vh>@nosent unittest/at-nosent-test.py</vh>
<v t="ekr.20090704085350.5035"><vh>spam</vh></v>
<v t="ekr.20090704085350.5036"><vh>eggs</vh></v>
</v>
<v t="ekr.20100731163237.5782"><vh>@thin unittest/at-thin-html-test.html</vh>
<v t="ekr.20100731163237.5783"><vh>&lt;&lt; a section reference &gt;&gt;</vh></v>
</v>
<v t="ekr.20080905130723.3"><vh>@thin unittest/at-thin-line-number-test.py</vh>
<v t="ekr.20080905130723.4"><vh>at-thin-child</vh></v>
</v>
<v t="ekr.20090704085350.5022"><vh>@thin unittest/at-thin-test.py</vh>
<v t="ekr.20090704085350.5023"><vh>spam</vh></v>
<v t="ekr.20090704085350.5024"><vh>eggs</vh></v>
</v>
<v t="ekr.20070627082044.811"><vh>@thin unittest/batchTest.py</vh></v>
<v t="ekr.20070627082044.808"><vh>@thin unittest/errorTest.py</vh></v>
</v>
<v t="ekr.20170101134417.1"><vh>@ignore Slow tests</vh>
<v t="ekr.20161224111342.1"><vh>@test import all Leo's core files</vh></v>
</v>
<v t="ekr.20101220161557.6016"><vh>Active Unit Tests</vh>
<v t="edward.20160314170027.56" descendentVnodeUnknownAttributes="7d7100285809000000302e362e31392e343071017d710258090000006d795f706c7567696e7103580300000076616c7104735808000000302e362e32372e3771057d71065808000000616e6e6f7461746571077d7108735808000000302e362e31382e3771097d710a5808000000616e6e6f74617465710b7d710c735808000000302e362e31322e39710d7d710e5809000000756e69745f74657374710f5804000000616263647110735808000000302e362e31362e3371117d71125808000000616e6e6f7461746571137d711473752e"
marks="ekr.20070131175538,"><vh>@file activeUnitTests.txt</vh></v>
</v>
<v t="ekr.20161204040924.1"><vh>@ignore Failing unit tests</vh>
<v t="ekr.20161130041921.1"></v>
<v t="ekr.20161228071915.1"><vh>@@auto c:\test\bug-354-test.py</vh>
<v t="ekr.20161228072352.1"><vh>bug-354-test declarations</vh></v>
</v>
<v t="ekr.20150626093653.1"><vh>@@test find_file_line: @auto-rst</vh></v>
<v t="ekr.20160403143643.1"><vh>@@test find_file_line: @clean-c</vh></v>
<v t="ekr.20160403143655.1"><vh>@@test find_file_line: @clean-python</vh></v>
<v t="ekr.20160403143048.1"></v>
<v t="ekr.20160403143130.1"></v>
<v t="ekr.20161130051657.1"><vh>@test ctext</vh></v>
<v t="ekr.20150626101920.1"><vh>@test find_file_line: @auto-md</vh></v>
<v t="ekr.20161130053149.1"><vh>COPY @auto-ctext unittest/at-auto-ctext-test.txt</vh></v>
<v t="ekr.20161103075725.1"><vh>Python failing tests: parse-body</vh>
<v t="ekr.20140206132559.4567"><vh>@@@test ic.parse-body</vh>
<v t="ekr.20150919073819.1"><vh>copy</vh></v>
<v t="ekr.20140206132559.4560"><vh>before</vh>
<v t="ekr.20161112061414.1"><vh>class aClass</vh>
<v t="ekr.20161112061414.2"><vh>__init__</vh></v>
<v t="ekr.20161112061414.3"><vh>spam</vh></v>
</v>
<v t="ekr.20161112061414.4"><vh>bClass = aClass</vh></v>
</v>
<v t="ekr.20140206132559.4564"><vh>expected</vh>
<v t="ekr.20150919074321.1"><vh>class aClass</vh>
<v t="ekr.20150919074321.2"><vh>__init__</vh></v>
<v t="ekr.20150919074321.3"><vh>spam</vh></v>
</v>
</v>
</v>
<v t="ekr.20150919074122.1"><vh>@@@test ic.parse-body mypy</vh>
<v t="ekr.20150919074220.1"><vh>copy</vh></v>
<v t="ekr.20150919074132.1"><vh>before</vh>
<v t="ekr.20161112061406.1"><vh>class TypeJoinVisitor</vh></v>
</v>
<v t="ekr.20150919074154.1"><vh>expected</vh>
<v t="ekr.20150919074211.1"><vh>class TypeJoinVisitor</vh>
<v t="ekr.20150919074211.2"><vh>__init__</vh></v>
<v t="ekr.20150919074211.3"><vh>visit_unbound_type</vh></v>
<v t="ekr.20150919074211.4"><vh>visit_union_type</vh></v>
<v t="ekr.20150919074211.5"><vh>visit_error_type</vh></v>
<v t="ekr.20150919074211.6"><vh>visit_type_list</vh></v>
<v t="ekr.20150919074211.7"><vh>visit_any</vh></v>
<v t="ekr.20150919074211.8"><vh>visit_void</vh></v>
<v t="ekr.20150919074211.9"><vh>visit_none_type</vh></v>
<v t="ekr.20150919074211.10"><vh>visit_erased_type</vh></v>
<v t="ekr.20150919074211.11"><vh>visit_type_var</vh></v>
<v t="ekr.20150919074211.12"><vh>visit_instance</vh></v>
<v t="ekr.20150919074211.13"><vh>visit_callable_type</vh></v>
<v t="ekr.20150919074211.14"><vh>visit_overloaded</vh></v>
<v t="ekr.20150919074211.15"><vh>visit_tuple_type</vh></v>
<v t="ekr.20150919074211.16"><vh>join</vh></v>
<v t="ekr.20150919074211.17"><vh>default</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20170504122245.1"><vh>@ignore recent</vh>
<v t="ekr.20170504062625.1"><vh>Found:leoQt</vh>
<v t="ekr.20140904060337.4476"><vh>@test interfaces using API classes</vh></v>
<v t="ekr.20111123214629.3941"><vh>@test unbound Alt-9 key is completely ignored</vh></v>
<v t="ekr.20111121142012.4030"><vh>@test c.frame.log relationships</vh></v>
<v t="ekr.20141223125432.11"><vh>@test g.toUnicode(QString)</vh></v>
<v t="ekr.20111120124051.3992"><vh>@test Ctrl-I inserts only one headline</vh></v>
<v t="ekr.20111121224307.3934"><vh>@test k.handleDefaultChar from log pane</vh></v>
</v>
<v t="ekr.20170504102140.1"><vh>Found:print</vh>
<v t="ekr.20170504102649.1"><vh>Real prints</vh>
<v t="ekr.20110613143220.3314"><vh>@test All menus execute the proper command</vh></v>
<v t="ekr.20100131171342.5509"><vh>@test leoBridge init logic</vh></v>
<v t="ekr.20040712101754.188"><vh>@test p.iters and v.iters</vh>
<v t="ekr.20040712101754.189"><vh>child1</vh>
<v t="ekr.20040712101754.190"><vh>a</vh>
<v t="ekr.20040712101754.191"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.192"><vh>c</vh></v>
<v t="ekr.20040712101754.193"><vh>d</vh>
<v t="ekr.20040712101754.194"><vh>e</vh></v>
</v>
</v>
<v t="ekr.20040712101754.195"><vh>child2</vh></v>
<v t="ekr.20040712101754.196"><vh>&lt;&lt; tests of consistency of p and v iters &gt;&gt;</vh></v>
<v t="ekr.20040712101754.197"><vh>&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;</vh></v>
<v t="ekr.20040712101754.198"><vh>&lt;&lt; print nodes returned by iterators &gt;&gt;</vh></v>
</v>
<v t="ekr.20090306091634.1"><vh>@test print redraw count</vh></v>
<v t="ekr.20100131171342.5487"><vh>checkFile</vh></v>
<v t="ekr.20050120095423.20"><vh>class lastTestCase</vh></v>
<v t="ekr.20100827194549.5963"><vh>report</vh></v>
<v t="ekr.20050218015346.22"><vh>removeLeadingWs</vh></v>
</v>
<v t="ekr.20170504102726.1"><vh>zz tests</vh>
<v t="ekr.20081111150402.11"><vh>@test zz end of all tests</vh></v>
<v t="ekr.20071113201736"><vh>@test zz end of leoAtFile tests</vh></v>
<v t="ekr.20090615053403.4957"><vh>@test zz end of leoColor tests</vh></v>
<v t="ekr.20071113201833"><vh>@test zz end of leoCommands tests</vh></v>
<v t="ekr.20071113201854"><vh>@test zz end of leoConfig tests</vh></v>
<v t="ekr.20070306091949"><vh>@test zz end of leoEditCommands tests</vh></v>
<v t="ekr.20071113202045"><vh>@test zz end of leoFile tests</vh></v>
<v t="ekr.20071113202153"><vh>@test zz end of leoFind tests</vh></v>
<v t="ekr.20071113202153.1"><vh>@test zz end of leoFrame tests</vh></v>
<v t="ekr.20071113202153.2"><vh>@test zz end of leoGlobals tests</vh></v>
<v t="ekr.20100131171342.5603"><vh>@test zz end of leoGui tests</vh></v>
<v t="ekr.20140724164600.4590"><vh>@test zz end of leoImport tests</vh></v>
<v t="ekr.20100131171342.5609"><vh>@test zz end of leoKeys tests</vh></v>
<v t="ekr.20071113202452"><vh>@test zz end of leoNodes tests</vh></v>
<v t="ekr.20071113202510"><vh>@test zz end of leoUndo tests</vh></v>
<v t="ekr.20100131171342.5501"><vh>@test zz end of plugins unit tests</vh></v>
<v t="ekr.20060131102450"><vh>@test zz print end of typing tests</vh></v>
</v>
</v>
<v t="ekr.20161002020559.1"><vh>@test all generators return unique positions</vh>
<v t="ekr.20170504124652.1"><vh>parent</vh>
<v t="ekr.20170504124245.1"><vh>child1</vh>
<v t="ekr.20170504124249.1"><vh>grandchild</vh>
<v t="ekr.20170504124842.1"><vh>greatGrandChild</vh></v>
</v>
<v t="ekr.20170504124617.1"><vh>grandchild2</vh></v>
</v>
<v t="ekr.20170504124417.1"><vh>child2</vh></v>
<v t="ekr.20170504124637.1"><vh>child3</vh></v>
</v>
</v>
</v>
<v t="ekr.20071113194858"><vh>Organized by file</vh>
<v t="ekr.20100223123103.5382"><vh>@test expand/contract-pane</vh></v>
<v t="ekr.20100131171342.5506"><vh>leoApp</vh>
<v t="ekr.20100131171342.5507"><vh>@test consistency of leoApp tables</vh></v>
<v t="ekr.20100131180007.5417"><vh>@test lm.openLeoOrZipFile</vh></v>
<v t="ekr.20100211110729.5389"><vh>@test rfm.writeRecentFilesFileHelper</vh></v>
<v t="ekr.20130503061820.4186"><vh>@test consistency of leoApp tables</vh></v>
</v>
<v t="ekr.20160318094003.1"><vh>leoAst</vh>
<v t="ekr.20160318094009.1"><vh>@test Python3 features</vh></v>
<v t="ekr.20160523094102.1"><vh>@test leoAst traverser classes</vh></v>
</v>
<v t="ekr.20050112095306.1"><vh>leoAtFile</vh>
<v t="ekr.20041021065844"><vh>@test @asis</vh>
<v t="ekr.20041021065903"><vh>#@asis</vh>
<v t="ekr.20041021065903.1"><vh>&lt;&lt; section &gt;&gt;</vh></v>
<v t="ekr.20041021065903.2"><vh>unnamed node</vh></v>
</v>
<v t="ekr.20041021065844.1"><vh>Output</vh></v>
</v>
<v t="ekr.20090627070131.4971"><vh>@test @auto (newlines at end of nodes)</vh>
<v t="ekr.20090627070131.4975"><vh>#@auto</vh>
<v t="ekr.20090627070131.4976"><vh>spam</vh></v>
<v t="ekr.20090627070131.4977"><vh>cheese</vh></v>
</v>
<v t="ekr.20090627070131.4978"><vh>Output</vh></v>
</v>
<v t="ekr.20100801125533.5787"><vh>@test @auto (no newline at end of nodes)</vh>
<v t="ekr.20100801125533.5788"><vh>#@auto</vh>
<v t="ekr.20100801125533.5789"><vh>spam</vh></v>
<v t="ekr.20100801125533.5790"><vh>cheese</vh></v>
</v>
<v t="ekr.20100801125533.5791"><vh>Output</vh></v>
</v>
<v t="ekr.20090225102051.2"><vh>@test @edit</vh>
<v t="ekr.20090225102051.3"><vh>#@edit</vh></v>
<v t="ekr.20090225102051.4"><vh>Output</vh></v>
</v>
<v t="ekr.20110524120515.3489"><vh>@test @raw</vh>
<v t="ekr.20110524120515.3490"><vh>#@file</vh></v>
<v t="ekr.20110524120515.3491"><vh>Output</vh></v>
<v t="ekr.20170410084645.1"><vh>Old-Output</vh></v>
</v>
<v t="ekr.20071113145804.8"><vh>@test at.directiveKind4</vh></v>
<v t="ekr.20170123035753.1"><vh>@test at.directiveKind4 (new)</vh></v>
<v t="ekr.20100225094004.5385"><vh>@test at.isFileLike</vh></v>
<v t="ekr.20071113143844.5"><vh>@test at.isSignificantTree</vh></v>
<v t="ekr.20110524091618.3488"><vh>@test at.massageDocPart</vh></v>
<v t="ekr.20090529115704.4562"><vh>@test at.open/closeStringFile</vh></v>
<v t="ekr.20090529115704.4563"><vh>@test at.openForWrite: not a shadow file</vh></v>
<v t="ekr.20071113145804.7"><vh>@test at.parseLeoSentinel</vh></v>
<v t="ekr.20170408233251.1"><vh>@test at.putRefLine 1</vh>
<v t="ekr.20170408234524.1"><vh>&lt;&lt; a &gt;&gt;</vh></v>
<v t="ekr.20170408234531.1"><vh>&lt;&lt; b &gt;&gt;</vh></v>
</v>
<v t="ekr.20170409003052.1"><vh>@test at.putRefLine 2</vh>
<v t="ekr.20170409003052.2"><vh>&lt;&lt; a &gt;&gt;</vh></v>
<v t="ekr.20170409003052.3"><vh>&lt;&lt; b &gt;&gt;</vh></v>
</v>
<v t="ekr.20090529115704.4564"><vh>@test at.readOneAtShadowNode</vh>
<v t="ekr.20090529115704.4565"><vh>@@shadow unittest/read_test.py</vh></v>
</v>
<v t="ekr.20050105093136"><vh>@test at.remove</vh></v>
<v t="ekr.20050105093524"><vh>@test at.rename</vh></v>
<v t="ekr.20090529115704.4566"><vh>@test at.replaceFileWithString</vh></v>
<v t="ekr.20050105094311"><vh>@test at.replaceTargetFileIfDifferent (different)</vh></v>
<v t="ekr.20050105095743"><vh>@test at.replaceTargetFileIfDifferent (identical)</vh></v>
<v t="ekr.20050105100227"><vh>@test at.replaceTargetFileIfDifferent (no target file)</vh></v>
<v t="ekr.20060602195313"><vh>@test at.write using @comment</vh>
<v t="ekr.20060602195313.2"><vh>root</vh>
<v t="ekr.20060602195313.3"><vh>&lt;&lt; Get LRR Task &gt;&gt;</vh></v>
<v t="ekr.20060602195313.4"><vh>&lt;&lt; Start LRR &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4567"><vh>@test at.writeOneAtShadowNode</vh>
<v t="ekr.20090529115704.4568"><vh>@@shadow unittest/test_1.py</vh></v>
</v>
<v t="ekr.20130912092638.4151"><vh>@test utf-16 encoding</vh></v>
<v t="ekr.20100131180007.5462"><vh>@test verbatim sentinel</vh></v>
<v t="ekr.20071113201736"></v>
<v t="ekr.20101021205258.6011"><vh>at.Directives &amp; directories</vh>
<v t="ekr.20100131180007.5454"><vh>@test at.get/setPathUa</vh></v>
<v t="ekr.20100131180007.5461"><vh>@test at.replaceFileWithString</vh></v>
<v t="ekr.20100131180007.5458"><vh>@test at.scanAllDirectives (minimal)</vh></v>
<v t="ekr.20071113090055.4"><vh>@test at.scanAllDirectives</vh></v>
</v>
<v t="ekr.20120228174052.3929"><vh>Node 1</vh></v>
<v t="ekr.20111113091935.4786"><vh>Not valid when run externally</vh>
<v t="ekr.20090704085350.5044"><vh>@test @asis: shape of tree</vh></v>
<v t="ekr.20090704085350.5052"><vh>@test @auto: shape of tree</vh></v>
<v t="ekr.20090704085350.5018"><vh>@@test @shadow: shape of tree</vh></v>
<v t="ekr.20100731163237.5778"><vh>@test @thin: html section references</vh></v>
<v t="ekr.20090704085350.5046"><vh>@test @thin: shape of tree</vh></v>
<v t="ekr.20111021115306.3696"><vh>@test @file: tex bug</vh></v>
<v t="ekr.20100802220019.5795"><vh>@test at.deleteUnvistedNodes</vh></v>
<v t="ekr.20040707141957.12"><vh>@test @thin: @last</vh>
<v t="ekr.20040707141957.13"><vh>#@thin</vh></v>
<v t="ekr.20040707141957.14"><vh>Output</vh></v>
</v>
</v>
<v t="ekr.20101021210253.6018"><vh>Unused</vh>
<v t="ekr.20040712101754.103"><vh>@@test @file no newline</vh>
<v t="ekr.20040712101754.104"><vh>#@file</vh></v>
<v t="ekr.20040712101754.105"><vh>Output</vh></v>
</v>
<v t="ekr.20040712101754.106"><vh>@@test @file one newline</vh>
<v t="ekr.20040712101754.107"><vh>#@file</vh></v>
<v t="ekr.20040712101754.108"><vh>Output</vh></v>
</v>
<v t="ekr.20040712101754.109"><vh>@@test @file two newlines</vh>
<v t="ekr.20040712101754.110"><vh>#@file</vh></v>
<v t="ekr.20040712101754.111"><vh>Output</vh></v>
</v>
<v t="ekr.20090704085350.5010"><vh>@@test @file: shape of tree</vh></v>
</v>
</v>
<v t="ekr.20150521123343.1"><vh>leoBeautify</vh>
<v t="ekr.20111104171708.3843"><vh>@test leoBeautify.CPrettyPrinter</vh>
<v t="ekr.20111104171708.3844"><vh>c tokenize test</vh></v>
</v>
<v t="ekr.20150610064911.1"><vh>@test beautifier</vh>
<v t="ekr.20150610064930.1"><vh>before</vh></v>
<v t="ekr.20150610065241.1"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20100131171342.5508"><vh>leoBridge</vh>
<v t="ekr.20100131171342.5509"></v>
</v>
<v t="ekr.20110608135658.3377"><vh>leoChapters</vh>
<v t="ekr.20110608162543.3363"><vh>@test chapter-create/remove &amp; undo</vh></v>
<v t="ekr.20110608162543.3365"><vh>@test chapter-rename &amp; undo</vh></v>
<v t="ekr.20110608181936.3368"><vh>@test chapter-move/clone/copy-node-to</vh>
<v t="ekr.20160402043006.1"><vh>node a</vh></v>
<v t="ekr.20160402043006.2"><vh>node b</vh></v>
<v t="ekr.20160402043006.3"><vh>node c</vh></v>
</v>
<v t="ekr.20080503132221.1"><vh>@test chapter-create-from-node</vh></v>
</v>
<v t="ekr.20090615053403.4876"><vh>leoColorizer</vh>
<v t="ekr.20090615053403.4877"><vh>@test @comment after @language plain</vh>
<v t="ekr.20090615053403.4878"><vh>plain code</vh></v>
</v>
<v t="ekr.20170201143435.1"><vh>@test bc.scanLanguageDirectives</vh>
<v t="ekr.20170201143435.2"><vh>&lt;&lt; scanLanguageDirectives test tables &gt;&gt;</vh></v>
<v t="ekr.20170201143435.3"><vh>test-child</vh>
<v t="ekr.20170201143435.4"><vh>test-grandchild</vh></v>
</v>
</v>
<v t="ekr.20170201175441.1"><vh>@test bc.useSyntaxColoring</vh>
<v t="ekr.20170201175441.2"><vh>&lt;&lt; useSyntaxColoring test tables &gt;&gt;</vh></v>
<v t="ekr.20170201175441.3"><vh>test-child</vh>
<v t="ekr.20170201175441.4"><vh>test-grandchild</vh></v>
</v>
</v>
<v t="ekr.20090615053403.4879"><vh>@test colorizer Actionscript</vh>
<v t="ekr.20090615053403.4880"><vh>actionscript test</vh></v>
</v>
<v t="ekr.20090615053403.4881"><vh>@test colorizer C</vh>
<v t="ekr.20090615053403.4882"><vh>c code</vh></v>
</v>
<v t="ekr.20090615053403.4883"><vh>@test colorizer C#</vh>
<v t="ekr.20090615053403.4884"><vh>c# code</vh></v>
</v>
<v t="ekr.20090615053403.4885"><vh>@test colorizer css</vh>
<v t="ekr.20090615053403.4886"><vh>css</vh></v>
</v>
<v t="ekr.20090615053403.4887"><vh>@test colorizer CWEB</vh>
<v t="ekr.20090615053403.4888"><vh>CWEB</vh>
<v t="ekr.20090615053403.4889"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20110521073115.3486"><vh>@test colorizer cython</vh>
<v t="ekr.20110521073115.3490"><vh>cython</vh></v>
</v>
<v t="ekr.20090615053403.4890"><vh>@test colorizer elisp</vh>
<v t="ekr.20090615053403.4891"><vh>elisp</vh></v>
</v>
<v t="ekr.20090615053403.4892"><vh>@test colorizer erlang</vh>
<v t="ekr.20090615053403.4893"><vh>erlang</vh></v>
</v>
<v t="ekr.20090615053403.4894"><vh>@test colorizer forth</vh>
<v t="ekr.20090615053403.4895"><vh>forth</vh></v>
</v>
<v t="ekr.20090615053403.4896"><vh>@test colorizer HTML string bug</vh>
<v t="ekr.20090615053403.4897"><vh>html</vh></v>
</v>
<v t="ekr.20090615053403.4898"><vh>@test colorizer HTML1</vh>
<v t="ekr.20090615053403.4899"><vh>html</vh></v>
</v>
<v t="ekr.20090615053403.4900"><vh>@test colorizer HTML2</vh>
<v t="ekr.20090615053403.4901"><vh>html</vh></v>
</v>
<v t="ekr.20090615053403.4902"><vh>@test colorizer Java</vh>
<v t="ekr.20090615053403.4903"><vh>html</vh></v>
</v>
<v t="ekr.20090615053403.4904"><vh>@test colorizer LaTex</vh>
<v t="ekr.20090615053403.4905"><vh>LaTex</vh></v>
</v>
<v t="ekr.20090615053403.4906"><vh>@test colorizer lisp</vh>
<v t="ekr.20090615053403.4907"><vh>lisp</vh></v>
</v>
<v t="ekr.20101020123501.6005"><vh>@test colorizer objective-c</vh>
<v t="ekr.20101020123501.6006"><vh>objective-c</vh></v>
</v>
<v t="ekr.20090615053403.4908"><vh>@test colorizer perl</vh>
<v t="ekr.20090615053403.4909"><vh>perl</vh></v>
</v>
<v t="ekr.20090615053403.4910"><vh>@test colorizer PHP</vh>
<v t="ekr.20090615053403.4911"><vh>PHP</vh></v>
</v>
<v t="ekr.20090615053403.4912"><vh>@test colorizer plsql</vh>
<v t="ekr.20090615053403.4913"><vh>plsql</vh></v>
</v>
<v t="ekr.20090615053403.4914"><vh>@test colorizer python.xml (jEdit)</vh>
<v t="ekr.20090615053403.4915"><vh>python.xml</vh>
<v t="ekr.20090615053403.4916"><vh>&lt;&lt; remarks &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4917"><vh>&lt;&lt; comments &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4918"><vh>&lt;&lt; literals &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4919"><vh>&lt;&lt; operators &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4920"><vh>&lt;&lt; keywords &gt;&gt;</vh>
<v t="ekr.20090615053403.4921"><vh>&lt;&lt; reserved words &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4922"><vh>&lt;&lt; builtins &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4923"><vh>&lt;&lt; exceptions &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4924"><vh>&lt;&lt; types &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20090615053403.4925"><vh>@test colorizer Python1</vh>
<v t="ekr.20090615053403.4926"><vh>python</vh></v>
</v>
<v t="ekr.20090615053403.4927"><vh>@test colorizer Python2</vh>
<v t="ekr.20090615053403.4928"><vh>python</vh></v>
</v>
<v t="ekr.20090615053403.4929"><vh>@test colorizer r</vh>
<v t="ekr.20090615053403.4930"><vh>r</vh></v>
</v>
<v t="ekr.20090615053403.4931"><vh>@test colorizer rapidq</vh>
<v t="ekr.20090615053403.4932"><vh>rapidq</vh></v>
</v>
<v t="ekr.20090615053403.4933"><vh>@test colorizer Rebol</vh>
<v t="ekr.20090615053403.4934"><vh>Rebol</vh></v>
</v>
<v t="ekr.20090615053403.4935"><vh>@test colorizer rest</vh>
<v t="ekr.20090615053403.4936"><vh>rest</vh></v>
</v>
<v t="ekr.20110529215703.3494"><vh>@test colorizer scala</vh>
<v t="ekr.20110529215703.3495"><vh>scala</vh></v>
</v>
<v t="ekr.20090615053403.4937"><vh>@test colorizer shell</vh>
<v t="ekr.20090615053403.4938"><vh>shell</vh></v>
</v>
<v t="ekr.20090615053403.4939"><vh>@test colorizer shellscript</vh>
<v t="ekr.20090615053403.4940"><vh>shellscript</vh></v>
</v>
<v t="ekr.20090615053403.4941"><vh>@test colorizer tex.xml (jEdit)</vh>
<v t="ekr.20090615053403.4942"><vh>tex.xml</vh>
<v t="ekr.20090615053403.4943"><vh>&lt;&lt; general rules &gt;&gt;</vh></v>
<v t="ekr.20090615053403.4944"><vh>&lt;&lt; math rules &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090615053403.4945"><vh>@test colorizer wikiTest1</vh>
<v t="ekr.20090615053403.4946"><vh>wiki</vh></v>
</v>
<v t="ekr.20090615053403.4947"><vh>@test colorizer wikiTest2</vh>
<v t="ekr.20090615053403.4948"><vh>wiki</vh></v>
</v>
<v t="ekr.20090615053403.4949"><vh>@test colorizer wikiTest3</vh>
<v t="ekr.20090615053403.4950"><vh>wiki</vh></v>
</v>
<v t="ekr.20090615053403.4951"><vh>@test leoColor.doNowebSecRef</vh>
<v t="ekr.20090615053403.4952"><vh>&lt;&lt; test defined &gt;&gt;</vh></v>
</v>
<v t="ekr.20090615053403.4953"><vh>@test python keywords (new colorizer)</vh></v>
<v t="ekr.20090615053403.4954"><vh>@test scanColorDirectives</vh></v>
<v t="ekr.20090615053403.4955"><vh>@test vbscript</vh>
<v t="ekr.20090615053403.4956"><vh>vbscript</vh></v>
</v>
<v t="ekr.20090615053403.4957"></v>
</v>
<v t="ekr.20071113193624"><vh>@ignore leoCommands (1 failure)</vh>
<v t="ekr.20090104053806.1"><vh>@@@test c.checkFileTimeStamp &amp; c.setFileTimeStamp</vh></v>
<v t="ekr.20100203103015.5356"><vh>@@@test c.openTempFileInExternalEditor</vh></v>
<v t="ekr.20100209155559.5386"><vh>@@@test efc.create_temp_file</vh></v>
<v t="ekr.20120309155126.3949"><vh>@test add/delete comments with multiple @language directives</vh>
<v t="ekr.20120309155126.3950"><vh>rest and python</vh></v>
</v>
<v t="ekr.20111112171235.3854"><vh>@test add/delete html comments</vh>
<v t="ekr.20170128023431.1"><vh>@language html</vh>
<v t="ekr.20111112171235.3855"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20111112171235.3858"><vh>@test add/delete python comments</vh>
<v t="ekr.20111112171235.3859"><vh>python</vh></v>
</v>
<v t="ekr.20110510054817.3475"><vh>@test c.alert</vh></v>
<v t="ekr.20050512084850"><vh>@test c.checkOutline</vh>
<v t="ekr.20040713070526"><vh>Scripts</vh>
<v t="ekr.20040713123617"><vh>tempNode</vh></v>
<v t="ekr.20050726141158"><vh>before</vh></v>
<v t="ekr.20040713123828.1"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20071113145804.10"><vh>@test c.contractAllHeadlines</vh></v>
<v t="ekr.20070611105423.1"><vh>@test c.contractAllHeadlines</vh></v>
<v t="ekr.20070611105728"><vh>@test c.demote: illegal clone demote</vh></v>
<v t="ekr.20111121140833.3916"><vh>@test c.findMatchingBracket</vh></v>
<v t="ekr.20141016101308.4747"><vh>@test c.hiddenRootNode.fileIndex</vh></v>
<v t="ekr.20120310121839.3949"><vh>@test c.hoist @chapter node</vh></v>
<v t="ekr.20120311124038.3951"><vh>@test c.hoist followed by goto-first-node</vh></v>
<v t="ekr.20071113105654.1"><vh>@test c.hoist with no children</vh></v>
<v t="ekr.20061106112522"><vh>@test c.insertBodyTime</vh></v>
<v t="ekr.20050512083807.1"><vh>@test c.markAllAtFileNodesDirty</vh></v>
<v t="ekr.20050512083822.1"><vh>@test c.markSubheads</vh>
<v t="ekr.20050512084850.1"><vh>child 1</vh></v>
<v t="ekr.20050512084850.2"><vh>child 2</vh></v>
</v>
<v t="ekr.20111212142649.3971"><vh>@test c.pasteOutline does not clone top node</vh>
<v t="ekr.20111212142649.3972"><vh>child</vh></v>
</v>
<v t="ekr.20080917151620.9"><vh>@test c.scanAllDirectives</vh></v>
<v t="ekr.20100131180007.5466"><vh>@test c.scanAtPathDirectives</vh>
<v t="ekr.20100131180007.5467"><vh>@path one</vh>
<v t="ekr.20100131180007.5468"><vh>@path two</vh>
<v t="ekr.20100131180007.5469"><vh>xyz</vh></v>
</v>
</v>
</v>
<v t="sps.20100531034136.20110"><vh>@test c.scanAtPathDirectives same name subdirs</vh>
<v t="sps.20100531034136.20111"><vh>@path again</vh>
<v t="sps.20100531034136.20112"><vh>@path again</vh>
<v t="sps.20100531034136.20113"><vh>xyz</vh></v>
</v>
</v>
</v>
<v t="ekr.20040802065214"><vh>@test c.setHeadString marks descendent @thin nodes dirty</vh>
<v t="ekr.20040802065214.1"><vh>bogus</vh></v>
</v>
<v t="ekr.20050512083822.2"><vh>@test c.unmarkAll</vh></v>
<v t="ekr.20100131180007.5465"><vh>@test class StubConfig</vh></v>
<v t="ekr.20100203103015.5353"><vh>@test efc.ask</vh></v>
<v t="ekr.20100203103015.5355"><vh>@test efc.get_ext</vh></v>
<v t="ekr.20100203103015.5354"><vh>@test efc.temp_file_path</vh></v>
<v t="ville.20090602190735.4770"><vh>@test g.command decorator</vh></v>
<v t="ekr.20100203103015.5357"><vh>@test g.isCallable</vh></v>
<v t="ekr.20071113201833"></v>
</v>
<v t="ekr.20071113194216"><vh>leoConfig</vh>
<v t="ekr.20120201125738.3958"><vh>@@@test g.app.config.getShortcuts works when no local shortcuts</vh></v>
<v t="ekr.20060325071703.2"><vh>@@@test ifgui</vh></v>
<v t="ekr.20111115071700.3870"><vh>@test c.config.printSettings</vh></v>
<v t="ekr.20120201101804.3907"><vh>@test c.config.updateSetting with no @settings node</vh></v>
<v t="ekr.20111124090010.3939"><vh>@test g.app.config @buttons and @commands logic</vh></v>
<v t="ekr.20050203084930.1"><vh>@test g.app.config.get</vh></v>
<v t="ekr.20111105124216.3840"><vh>@test g.app.config.set</vh></v>
<v t="ekr.20060325071703.1"><vh>@test ifplatform</vh></v>
<v t="ekr.20050203001146"><vh>@test local settings (c.page_width)</vh></v>
<v t="ekr.20071113201854"></v>
</v>
<v t="ekr.20100131171342.5592"><vh>leoDialogs</vh>
<v t="ekr.20100131171342.5593"><vh>@test ctors for all dialogs</vh></v>
</v>
<v t="ekr.20071113192611"><vh>leoEditCommands (63 failures)</vh>
<v t="ekr.20070131175538" a="M"><vh> Commands A-B</vh>
<v t="ekr.20061101121602.78"><vh>@test add-space-to-lines</vh>
<v t="ekr.20061101121602.79"><vh>work</vh></v>
<v t="ekr.20061101121602.80"><vh>before sel=2.0,4.6</vh></v>
<v t="ekr.20061101121602.81"><vh>after sel=2.0,4.7</vh></v>
</v>
<v t="ekr.20061101121602.82"><vh>@test add-tab-to-lines</vh>
<v t="ekr.20061101121602.83"><vh>work</vh></v>
<v t="ekr.20061101121602.84"><vh>before sel=2.0,5.6</vh></v>
<v t="ekr.20061101121602.85"><vh>after sel=2.0,5.10</vh></v>
</v>
<v t="ekr.20071113145804.16"><vh>@test helpForbindings</vh></v>
<v t="ekr.20071113145804.17"><vh>@test helpForFindCommands</vh></v>
<v t="ekr.20061101121602.86"><vh>@test back-char</vh>
<v t="ekr.20061101121602.87"><vh>work</vh></v>
<v t="ekr.20061101121602.88"><vh>before sel=3.8,3.8</vh></v>
<v t="ekr.20061101121602.89"><vh>after sel=3.7,3.7</vh></v>
</v>
<v t="ekr.20061101121602.90"><vh>@test back-char-extend-selection</vh>
<v t="ekr.20061101121602.91"><vh>work</vh></v>
<v t="ekr.20061101121602.92"><vh>before sel=4.12,4.12</vh></v>
<v t="ekr.20061101121602.93"><vh>after sel=4.11,4.12</vh></v>
</v>
<v t="ekr.20061101121602.94"><vh>@test back-paragraph</vh>
<v t="ekr.20061101121602.95"><vh>work</vh></v>
<v t="ekr.20061101121602.96"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.97"><vh>after sel=6.7,6.7</vh></v>
</v>
<v t="ekr.20061101121602.98"><vh>@test back-paragraph-extend-selection</vh>
<v t="ekr.20061101121602.99"><vh>work</vh></v>
<v t="ekr.20061101121602.100"><vh>before sel=9.0,9.5</vh></v>
<v t="ekr.20061101121602.101"><vh>after sel=6.7,9.5</vh></v>
</v>
<v t="ekr.20061101121602.102"><vh>@test back-sentence</vh>
<v t="ekr.20061101121602.103"><vh>work</vh></v>
<v t="ekr.20061101121602.104"><vh>before sel=3.169,3.169</vh></v>
<v t="ekr.20061101121602.105"><vh>after sel=3.143,3.143</vh></v>
</v>
<v t="ekr.20061101121602.106"><vh>@test back-sentence-extend-selection</vh>
<v t="ekr.20061101121602.107"><vh>work</vh></v>
<v t="ekr.20061101121602.108"><vh>before sel=3.208,3.208</vh></v>
<v t="ekr.20061101121602.109"><vh>after sel=3.143,3.208</vh></v>
</v>
<v t="ekr.20061101121602.110"><vh>@test back-to-indentation</vh>
<v t="ekr.20061101121602.111"><vh>work</vh></v>
<v t="ekr.20061101121602.112"><vh>before sel=4.13,4.13</vh></v>
<v t="ekr.20061101121602.113"><vh>after sel=4.8,4.8</vh></v>
</v>
<v t="ekr.20090427104851.7"><vh>@test back-to-home (at start of line)</vh>
<v t="ekr.20090427104851.8"><vh>work</vh></v>
<v t="ekr.20090427104851.9"><vh>before sel=2.0,2.0</vh></v>
<v t="ekr.20090427104851.10"><vh>after sel=2.4,2.4</vh></v>
</v>
<v t="ekr.20090427104851.15"><vh>@test back-to-home (at indentation</vh>
<v t="ekr.20090427104851.16"><vh>work</vh></v>
<v t="ekr.20090427104851.17"><vh>before sel=2.4,2.4</vh></v>
<v t="ekr.20090427104851.18"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20090427104851.11"><vh>@test back-to-home (at end of line)</vh>
<v t="ekr.20090427104851.12"><vh>work</vh></v>
<v t="ekr.20090427104851.13"><vh>before sel=2.12,2.12</vh></v>
<v t="ekr.20090427104851.14"><vh>after sel=2.4,2.4</vh></v>
</v>
<v t="ekr.20061101121602.114"><vh>@test back-word</vh>
<v t="ekr.20061101121602.115"><vh>work</vh></v>
<v t="ekr.20061101121602.116"><vh>before sel=1.183,1.183</vh></v>
<v t="ekr.20061101121602.117"><vh>after sel=1.178,1.178</vh></v>
</v>
<v t="ekr.20061101121602.118"><vh>@test back-word-extend-selection</vh>
<v t="ekr.20061101121602.119"><vh>work</vh></v>
<v t="ekr.20061101121602.120"><vh>before sel=3.342,3.342</vh></v>
<v t="ekr.20061101121602.121"><vh>after sel=3.332,3.342</vh></v>
</v>
<v t="ekr.20061101121602.122"><vh>@test backward-delete-char</vh>
<v t="ekr.20061101121602.123"><vh>work</vh></v>
<v t="ekr.20061101121602.124"><vh>before sel=1.9,1.9</vh></v>
<v t="ekr.20061101121602.125"><vh>after sel=1.8,1.8</vh></v>
</v>
<v t="ekr.20071007121529"><vh>@test backward-delete-char  (middle of line)</vh>
<v t="ekr.20071007121529.1"><vh>work</vh></v>
<v t="ekr.20071007121529.2"><vh>before sel=1.6,1.6</vh></v>
<v t="ekr.20071007121529.3"><vh>after sel=1.5,1.5</vh></v>
</v>
<v t="ekr.20071007120947"><vh>@test backward-delete-char (last char)</vh>
<v t="ekr.20071007120947.6"><vh>work</vh></v>
<v t="ekr.20071007120947.7"><vh>before sel=2.9,2.9</vh></v>
<v t="ekr.20071007120947.8"><vh>after sel=2.8,2.8</vh></v>
</v>
<v t="ekr.20100817131738.5886"><vh>@test backward-delete-word (no selection)</vh>
<v t="ekr.20100817131738.5887"><vh>work</vh></v>
<v t="ekr.20100817131738.5888"><vh>before sel=1.10,1.10</vh></v>
<v t="ekr.20100817131738.5889"><vh>after sel=1.5,1.5</vh></v>
</v>
<v t="ekr.20100817131738.5894"><vh>@test backward-delete-word (selection)</vh>
<v t="ekr.20100817131738.5895"><vh>work</vh></v>
<v t="ekr.20100817131738.5896"><vh>before sel=1.7,1.12</vh></v>
<v t="ekr.20100817131738.5897"><vh>after sel=1.7,1.7</vh></v>
</v>
<v t="ekr.20061101121602.126"><vh>@test backward-kill-paragraph</vh>
<v t="ekr.20061101121602.127"><vh>work</vh></v>
<v t="ekr.20061101121602.128"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.129"><vh>after sel=7.0,7.0</vh></v>
</v>
<v t="ekr.20070131173932"><vh>@test backward-kill-sentence</vh>
<v t="ekr.20070131173932.1"><vh>work</vh></v>
<v t="ekr.20070131173932.2"><vh>before sel=3.2,3.2</vh></v>
<v t="ekr.20070131173932.3"><vh>after sel=2.23,2.23</vh></v>
</v>
<v t="ekr.20081215084144.2"><vh>@test backward-kill-word</vh>
<v t="ekr.20081215084144.3"><vh>work</vh></v>
<v t="ekr.20081215084144.4"><vh>before sel=3.7,3.7</vh></v>
<v t="ekr.20081215084144.5"><vh>after sel=3.5,3.5</vh></v>
</v>
<v t="ekr.20061101121602.130"><vh>@test beginning-of-buffer</vh>
<v t="ekr.20061101121602.131"><vh>work</vh></v>
<v t="ekr.20061101121602.132"><vh>before sel=5.56,5.56</vh></v>
<v t="ekr.20061101121602.133"><vh>after sel=1.0,1.0</vh></v>
</v>
<v t="ekr.20061101121602.134"><vh>@test beginning-of-buffer-extend-selection</vh>
<v t="ekr.20061101121602.135"><vh>work</vh></v>
<v t="ekr.20061101121602.136"><vh>before sel=3.423,3.423</vh></v>
<v t="ekr.20061101121602.137"><vh>after sel=1.0,3.423</vh></v>
</v>
<v t="ekr.20061101121602.138"><vh>@test beginning-of-line</vh>
<v t="ekr.20061101121602.139"><vh>work</vh></v>
<v t="ekr.20061101121602.140"><vh>before sel=3.10,3.10</vh></v>
<v t="ekr.20061101121602.141"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20061101121602.142"><vh>@test beginning-of-line-extend-selection</vh>
<v t="ekr.20061101121602.143"><vh>work</vh></v>
<v t="ekr.20061101121602.144"><vh>before sel=4.10,4.10</vh></v>
<v t="ekr.20061101121602.145"><vh>after sel=4.0,4.10</vh></v>
</v>
</v>
<v t="ekr.20081111084046.2"><vh> Commands C-E</vh>
<v t="ekr.20111104171708.3847"><vh>@test c-to-python</vh>
<v t="ekr.20111104171708.3848"><vh>c tokenize test</vh></v>
</v>
<v t="ekr.20061101121602.146"><vh>@test capitalize-word</vh>
<v t="ekr.20061101121602.147"><vh>work</vh></v>
<v t="ekr.20061101121602.148"><vh>before sel=3.6,3.6</vh></v>
<v t="ekr.20061101121602.149"><vh>after sel=3.6,3.6</vh></v>
</v>
<v t="ekr.20061101121602.150"><vh>@test center-line</vh>
<v t="ekr.20061101121602.151"><vh>work</vh></v>
<v t="ekr.20061101121602.152"><vh>before sel=3.0,9.0</vh></v>
<v t="ekr.20061101121602.153"><vh>after sel=3.0,9.0</vh></v>
</v>
<v t="ekr.20061101121602.154"><vh>@test center-region</vh>
<v t="ekr.20061101121602.155"><vh>work</vh></v>
<v t="ekr.20061101121602.156"><vh>before sel=1.0,7.0</vh></v>
<v t="ekr.20061101121602.157"><vh>after sel=1.0,7.0</vh></v>
</v>
<v t="ekr.20120525072421.3889"><vh>@test clean-lines</vh>
<v t="ekr.20120525072421.3890"><vh>work</vh></v>
<v t="ekr.20120525072421.3891"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20120525072421.3892"><vh>after sel=1.0,1.0</vh></v>
</v>
<v t="ekr.20061101121602.158"><vh>@test clear-selected-text</vh>
<v t="ekr.20061101121602.159"><vh>work</vh></v>
<v t="ekr.20061101121602.160"><vh>before sel=2.4,4.4</vh></v>
<v t="ekr.20061101121602.161"><vh>after sel=2.4,2.4</vh></v>
</v>
<v t="ekr.20111006105711.3544"><vh>@test clone-marked-nodes</vh></v>
<v t="ekr.20061101121602.162"><vh>@test count-region</vh>
<v t="ekr.20061101121602.163"><vh>work</vh></v>
<v t="ekr.20061101121602.164"><vh>before sel=2.4,4.8</vh></v>
<v t="ekr.20061101121602.165"><vh>after sel=2.4,4.8</vh></v>
</v>
<v t="ekr.20111120124051.3994"><vh>@test cycle-all-focus</vh></v>
<v t="ekr.20111121164644.3928"><vh>@test cycle-tab-focus</vh></v>
<v t="ekr.20150414144103.1"><vh>@test dabbrev-completion</vh></v>
<v t="ekr.20150414144038.1"><vh>@test dabbrev-expand</vh></v>
<v t="ekr.20061101121602.166"><vh>@test delete-char</vh>
<v t="ekr.20061101121602.167"><vh>work</vh></v>
<v t="ekr.20061101121602.168"><vh>before sel=1.5,1.5</vh></v>
<v t="ekr.20061101121602.169"><vh>after sel=1.5,1.5</vh></v>
</v>
<v t="ekr.20071007120750.3"><vh>@test delete-indentation</vh>
<v t="ekr.20071007121115.1"><vh>work</vh></v>
<v t="ekr.20071007121115.2"><vh>before sel=2.8,2.8</vh></v>
<v t="ekr.20071007121115.3"><vh>after sel=2.4,2.4</vh></v>
</v>
<v t="ekr.20111006064419.3491"><vh>@test delete-marked-nodes</vh></v>
<v t="ekr.20070131162935"><vh>@test delete-spaces</vh>
<v t="ekr.20070131162935.1"><vh>work</vh></v>
<v t="ekr.20070131162935.2"><vh>before sel=3.2,3.2</vh></v>
<v t="ekr.20070131162935.3"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20100830113702.5969"><vh>@test delete-word (no selection)</vh>
<v t="ekr.20100830113702.5970"><vh>work</vh></v>
<v t="ekr.20100830113702.5971"><vh>before sel=1.10,1.10</vh></v>
<v t="ekr.20100830113702.5972"><vh>after sel=1.10,1.10</vh></v>
</v>
<v t="ekr.20100830113702.5977"><vh>@test delete-word (selection)</vh>
<v t="ekr.20100830113702.5978"><vh>work</vh></v>
<v t="ekr.20100830113702.5979"><vh>before sel=1.7,1.12</vh></v>
<v t="ekr.20100830113702.5980"><vh>after sel=1.7,1.7</vh></v>
</v>
<v t="ekr.20061101121602.170"><vh>@test do-nothing</vh>
<v t="ekr.20061101121602.171"><vh>work</vh></v>
<v t="ekr.20061101121602.172"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20061101121602.173"><vh>after sel=1.0,1.0</vh></v>
</v>
<v t="ekr.20061101121602.174"><vh>@test downcase-region</vh>
<v t="ekr.20061101121602.175"><vh>work</vh></v>
<v t="ekr.20061101121602.176"><vh>before sel=3.0,4.0</vh></v>
<v t="ekr.20061101121602.177"><vh>after sel=3.0,4.0</vh></v>
</v>
<v t="ekr.20061101121602.178"><vh>@test downcase-word</vh>
<v t="ekr.20061101121602.179"><vh>work</vh></v>
<v t="ekr.20061101121602.180"><vh>before sel=1.4,1.4</vh></v>
<v t="ekr.20061101121602.181"><vh>after sel=1.4,1.4</vh></v>
</v>
<v t="ekr.20061101121602.182"><vh>@test end-of-buffer</vh>
<v t="ekr.20061101121602.183"><vh>work</vh></v>
<v t="ekr.20061101121602.184"><vh>before sel=1.3,1.3</vh></v>
<v t="ekr.20061101121602.185"><vh>after sel=7.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.186"><vh>@test end-of-buffer-extend-selection</vh>
<v t="ekr.20061101121602.187"><vh>work</vh></v>
<v t="ekr.20061101121602.188"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20061101121602.189"><vh>after sel=1.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.190"><vh>@test end-of-line</vh>
<v t="ekr.20061101121602.191"><vh>work</vh></v>
<v t="ekr.20061101121602.192"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20061101121602.193"><vh>after sel=1.10,1.10</vh></v>
</v>
<v t="ekr.20061128082002"><vh>@test end-of-line 2</vh>
<v t="ekr.20061128082002.1"><vh>work</vh></v>
<v t="ekr.20061128082002.2"><vh>before sel=6.0,6.0</vh></v>
<v t="ekr.20061128082002.3"><vh>after sel=6.9,6.9</vh></v>
</v>
<v t="ekr.20061101121602.194"><vh>@test end-of-line-extend-selection</vh>
<v t="ekr.20061101121602.195"><vh>work</vh></v>
<v t="ekr.20061101121602.196"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20061101121602.197"><vh>after sel=3.0,3.10</vh></v>
</v>
<v t="ekr.20061101121602.198"><vh>@test exchange-point-mark</vh>
<v t="ekr.20061101121602.199"><vh>work</vh></v>
<v t="ekr.20061101121602.200"><vh>before sel=1.0,1.10</vh></v>
<v t="ekr.20061101121602.201"><vh>after sel=1.0,1.10</vh></v>
</v>
<v t="ekr.20120303054735.3931"><vh>@test expand-and-go-right</vh>
<v t="ekr.20120303054735.3932"><vh>child</vh></v>
</v>
<v t="ekr.20061101121602.202"><vh>@test extend-to-line</vh>
<v t="ekr.20061101121602.203"><vh>work</vh></v>
<v t="ekr.20061101121602.204"><vh>before sel=3.3,3.3</vh></v>
<v t="ekr.20061101121602.205"><vh>after sel=3.0,3.10</vh></v>
</v>
<v t="ekr.20061101121602.206"><vh>@test extend-to-paragraph</vh>
<v t="ekr.20061101121602.207"><vh>work</vh></v>
<v t="ekr.20061101121602.208"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.209"><vh>after sel=8.0,13.33</vh></v>
</v>
<v t="ekr.20061101121602.210"><vh>@test extend-to-sentence</vh>
<v t="ekr.20061101121602.211"><vh>work</vh></v>
<v t="ekr.20061101121602.212"><vh>before sel=3.5,3.5</vh></v>
<v t="ekr.20061101121602.213"><vh>after sel=1.395,3.142</vh></v>
</v>
<v t="ekr.20061101121602.214"><vh>@test extend-to-word</vh>
<v t="ekr.20061101121602.215"><vh>work</vh></v>
<v t="ekr.20061101121602.216"><vh>before sel=3.10,3.10</vh></v>
<v t="ekr.20061101121602.217"><vh>after sel=3.4,3.12</vh></v>
</v>
<v t="ekr.20120212130242.3942"><vh>data</vh>
<v t="ekr.20120212130242.3948"><vh>a</vh>
<v t="ekr.20120212130242.3949"><vh>b</vh></v>
</v>
<v t="ekr.20120212130242.3945"><vh>c</vh></v>
<v t="ekr.20120212130242.3946"><vh>d</vh></v>
<v t="ekr.20120212130242.3947"><vh>e</vh>
<v t="ekr.20120212130242.3948"></v>
</v>
</v>
</v>
<v t="ekr.20070131175538.1"><vh> Commands F-L</vh>
<v t="ekr.20071007120750.4"><vh>@@test fill-region (one paragraph)</vh>
<v t="ekr.20071007121312.1"><vh>work</vh></v>
<v t="ekr.20071007121312.2"><vh>before sel=1.0,9.7</vh></v>
<v t="ekr.20071007121312.3"><vh>after sel=6.7,6.7</vh></v>
</v>
<v t="ekr.20071007124202"><vh>@@test fill-region (three paragraphs)</vh>
<v t="ekr.20071007124202.1"><vh>work</vh></v>
<v t="ekr.20071007124202.2"><vh>before sel=1.0,24.78</vh></v>
<v t="ekr.20071007124202.3"><vh>after sel=18.19,18.19</vh></v>
</v>
<v t="ekr.20061101121602.218"><vh>@test fill-paragraph</vh>
<v t="ekr.20061101121602.219"><vh>work</vh></v>
<v t="ekr.20061101121602.220"><vh>before sel=3.0,3.7</vh></v>
<v t="ekr.20061101121602.221"><vh>after sel=8.33,8.33</vh></v>
</v>
<v t="ekr.20061101121602.222"><vh>@test forward-char</vh>
<v t="ekr.20061101121602.223"><vh>work</vh></v>
<v t="ekr.20061101121602.224"><vh>before sel=1.2,1.2</vh></v>
<v t="ekr.20061101121602.225"><vh>after sel=1.3,1.3</vh></v>
</v>
<v t="ekr.20061101121602.226"><vh>@test forward-char-extend-selection</vh>
<v t="ekr.20061101121602.227"><vh>work</vh></v>
<v t="ekr.20061101121602.228"><vh>before sel=1.1,1.1</vh></v>
<v t="ekr.20061101121602.229"><vh>after sel=1.1,1.2</vh></v>
</v>
<v t="ekr.20061101121602.230"><vh>@test forward-end-word (end of line)</vh>
<v t="ekr.20061101121602.231"><vh>work</vh></v>
<v t="ekr.20061101121602.232"><vh>before sel=1.395,1.395</vh></v>
<v t="ekr.20061101121602.233"><vh>after sel=3.4,3.4</vh></v>
</v>
<v t="ekr.20061101121602.234"><vh>@test forward-end-word (start of word)</vh>
<v t="ekr.20061101121602.235"><vh>work</vh></v>
<v t="ekr.20061101121602.236"><vh>before sel=1.310,1.310</vh></v>
<v t="ekr.20061101121602.237"><vh>after sel=1.317,1.317</vh></v>
</v>
<v t="ekr.20061101121602.238"><vh>@test forward-end-word-extend-selection</vh>
<v t="ekr.20061101121602.239"><vh>work</vh></v>
<v t="ekr.20061101121602.240"><vh>before sel=3.20,3.20</vh></v>
<v t="ekr.20061101121602.241"><vh>after sel=3.20,3.30</vh></v>
</v>
<v t="ekr.20061101121602.242"><vh>@test forward-paragraph</vh>
<v t="ekr.20061101121602.243"><vh>work</vh></v>
<v t="ekr.20061101121602.244"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.245"><vh>after sel=15.0,15.0</vh></v>
</v>
<v t="ekr.20061101121602.246"><vh>@test forward-paragraph-extend-selection</vh>
<v t="ekr.20061101121602.247"><vh>work</vh></v>
<v t="ekr.20061101121602.248"><vh>before sel=10.0,10.0</vh></v>
<v t="ekr.20061101121602.249"><vh>after sel=10.0,15.0</vh></v>
</v>
<v t="ekr.20061101121602.250"><vh>@test forward-sentence</vh>
<v t="ekr.20061101121602.251"><vh>work</vh></v>
<v t="ekr.20061101121602.252"><vh>before sel=3.17,3.17</vh></v>
<v t="ekr.20061101121602.253"><vh>after sel=3.142,3.142</vh></v>
</v>
<v t="ekr.20061101121602.254"><vh>@test forward-sentence-extend-selection</vh>
<v t="ekr.20061101121602.255"><vh>work</vh></v>
<v t="ekr.20061101121602.256"><vh>before sel=1.264,1.264</vh></v>
<v t="ekr.20061101121602.257"><vh>after sel=1.264,1.395</vh></v>
</v>
<v t="ekr.20061101121602.258"><vh>@test forward-word</vh>
<v t="ekr.20061101121602.259"><vh>work</vh></v>
<v t="ekr.20061101121602.260"><vh>before sel=1.261,1.261</vh></v>
<v t="ekr.20061101121602.261"><vh>after sel=1.273,1.273</vh></v>
</v>
<v t="ekr.20061101121602.262"><vh>@test forward-word-extend-selection</vh>
<v t="ekr.20061101121602.263"><vh>work</vh></v>
<v t="ekr.20061101121602.264"><vh>before sel=1.395,1.395</vh></v>
<v t="ekr.20061101121602.265"><vh>after sel=1.395,3.0</vh></v>
</v>
<v t="ekr.20070305095401"><vh>@test goNext/PrevVisitedNode</vh></v>
<v t="ekr.20100212104817.5351"><vh>@test help-for-command</vh></v>
<v t="ekr.20061101121602.266"><vh>@test indent-relative</vh>
<v t="ekr.20061101121602.267"><vh>work</vh></v>
<v t="ekr.20061101121602.268"><vh>before sel=5.0,5.0</vh></v>
<v t="ekr.20061101121602.269"><vh>after sel=5.8,5.8</vh></v>
</v>
<v t="ekr.20061101121602.270"><vh>@test indent-rigidly</vh>
<v t="ekr.20061101121602.271"><vh>work</vh></v>
<v t="ekr.20061101121602.272"><vh>before sel=2.0,5.0</vh></v>
<v t="ekr.20061101121602.273"><vh>after sel=2.0,5.1</vh></v>
</v>
<v t="ekr.20071007120750.5"><vh>@test indent-to-comment-column</vh>
<v t="ekr.20071007121312.5"><vh>work</vh></v>
<v t="ekr.20071007121312.6"><vh>before sel=2.0,2.0</vh></v>
<v t="ekr.20071007121312.7"><vh>after sel=2.4,2.4</vh></v>
</v>
<v t="ekr.20061101121602.274"><vh>@test insert-newline</vh>
<v t="ekr.20061101121602.275"><vh>work</vh></v>
<v t="ekr.20061101121602.276"><vh>before sel=1.8,1.8</vh></v>
<v t="ekr.20061101121602.277"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20061101121602.278"><vh>@test insert-parentheses</vh>
<v t="ekr.20061101121602.279"><vh>work</vh></v>
<v t="ekr.20061101121602.280"><vh>before sel=1.5,1.5</vh></v>
<v t="ekr.20061101121602.281"><vh>after sel=1.6,1.6</vh></v>
</v>
<v t="ekr.20061101121602.282"><vh>@test kill-paragraph</vh>
<v t="ekr.20061101121602.283"><vh>work</vh></v>
<v t="ekr.20061101121602.285"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.284"><vh>after sel=8.0,8.0</vh></v>
</v>
<v t="ekr.20070131172706"><vh>@test kill-sentence</vh>
<v t="ekr.20070131172706.1"><vh>work</vh></v>
<v t="ekr.20070131172706.2"><vh>before sel=2.2,2.2</vh></v>
<v t="ekr.20070131172706.3"><vh>after sel=1.27,1.27</vh></v>
</v>
<v t="ekr.20081215084144.7"><vh>@test kill-word</vh>
<v t="ekr.20081215084144.8"><vh>work</vh></v>
<v t="ekr.20081215084144.9"><vh>before sel=2.6,2.6</vh></v>
<v t="ekr.20081215084144.10"><vh>after sel=2.7,2.7</vh></v>
</v>
<v t="ekr.20170401123840.1"><vh>goto-global-line tests</vh>
<v t="ekr.20170401123840.2"><vh>@test c.goToScriptLineNumber</vh>
<v t="ekr.20170401123840.3"><vh>syntax-error</vh></v>
</v>
<v t="ekr.20170401123840.4"><vh>@test find_file_line: @auto-md</vh></v>
<v t="ekr.20170401123840.5"><vh>@test find_file_line: @auto-org</vh></v>
<v t="ekr.20170401123840.6"><vh>@test find_file_line: @auto-otl</vh></v>
<v t="ekr.20170401123840.7"><vh>@test find_file_line: @auto-py</vh></v>
<v t="ekr.20170401123840.8"><vh>@@@test find_file_line: @auto-rst</vh></v>
<v t="ekr.20170401123840.9"><vh>@test find_file_line: @clean-c</vh></v>
<v t="ekr.20170401123840.10"><vh>@test find_file_line: @clean-python</vh></v>
<v t="ekr.20170401123840.11"><vh>@test find_file_line: @file-c</vh></v>
<v t="ekr.20170401123840.12"><vh>@test find_file_line: @file-python</vh></v>
<v t="ekr.20170401123840.13"><vh>@test find_file_line: @nosent-python</vh></v>
<v t="ekr.20170401123840.14"><vh>@test find_gnx @file</vh></v>
<v t="ekr.20170401123840.15"><vh>@test goto_show_results not found</vh></v>
</v>
<v t="ekr.20130918043621.4172"><vh>kill-line tests</vh>
<v t="ekr.20130918051958.4176"><vh>@test kill-line end-body-text</vh>
<v t="ekr.20130918051958.4177"><vh>work</vh></v>
<v t="ekr.20130918051958.4178"><vh>before sel=4.1,4.1</vh></v>
<v t="ekr.20130918051958.4179"><vh>after sel=3.6,3.6</vh></v>
</v>
<v t="ekr.20061128090338"><vh>@test kill-line end-line-text</vh>
<v t="ekr.20061128090338.1"><vh>work</vh></v>
<v t="ekr.20061128090338.2"><vh>before sel=3.5,3.5</vh></v>
<v t="ekr.20061128090338.3"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20061128090021"><vh>@test kill-line start-line</vh>
<v t="ekr.20061128090021.1"><vh>work</vh></v>
<v t="ekr.20061128090021.2"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20061128090021.3"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20061128090147"><vh>@test kill-line start-blank-line</vh>
<v t="ekr.20061128090147.1"><vh>work</vh></v>
<v t="ekr.20061128090147.2"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20061128090147.3"><vh>after sel=3.0,3.0</vh></v>
</v>
</v>
<v t="ekr.20130918043621.4190"><vh>kill-to-end-of-line tests</vh>
<v t="ekr.20130918043621.4195"><vh>@test kill-to-end-of-line end-body-text</vh>
<v t="ekr.20130918043621.4196"><vh>work</vh></v>
<v t="ekr.20130918043621.4197"><vh>before sel=4.1,4.1</vh></v>
<v t="ekr.20130918043621.4198"><vh>after sel=3.6,3.6</vh></v>
</v>
<v t="ekr.20130918050446.4202"><vh>@test kill-to-end-of-line end-line</vh>
<v t="ekr.20130918050446.4203"><vh>work</vh></v>
<v t="ekr.20130918050446.4204"><vh>before sel=2.6,2.6</vh></v>
<v t="ekr.20130918050446.4205"><vh>after sel=2.6,2.6</vh></v>
</v>
<v t="ekr.20130918052416.4180"><vh>@test kill-to-end-of-line after last visible char</vh>
<v t="ekr.20130918052416.4181"><vh>work</vh></v>
<v t="ekr.20130918052416.4182"><vh>before sel=3.6,3.6</vh></v>
<v t="ekr.20130918052416.4183"><vh>after sel=3.6,3.6</vh></v>
</v>
<v t="ekr.20130918043621.4199"><vh>@test kill-to-end-of-line start-line</vh>
<v t="ekr.20130918043621.4200"><vh>work</vh></v>
<v t="ekr.20130918043621.4201"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20130918043621.4202"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20130918050446.4210"><vh>@test kill-to-end-of-line start-blank-line</vh>
<v t="ekr.20130918050446.4211"><vh>work</vh></v>
<v t="ekr.20130918050446.4212"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20130918050446.4213"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20130918043621.4203"><vh>@test kill-to-end-of-line middle-line</vh>
<v t="ekr.20130918043621.4204"><vh>work</vh></v>
<v t="ekr.20130918043621.4205"><vh>before sel=2.2,2.2</vh></v>
<v t="ekr.20130918043621.4206"><vh>after sel=2.2,2.2</vh></v>
</v>
</v>
</v>
<v t="ekr.20070131175646"><vh> Commands M-Z</vh>
<v t="ekr.20070131171218.1"><vh>@@test zap-to-chararacter</vh>
<v t="ekr.20070131171218.2"><vh>work</vh></v>
</v>
<v t="ekr.20061101121602.286"><vh>@test move-lines-down</vh>
<v t="ekr.20061101121602.287"><vh>work</vh></v>
<v t="ekr.20061101121602.288"><vh>before sel=3.3,4.3</vh></v>
<v t="ekr.20061101121602.289"><vh>after sel=4.3,5.3</vh></v>
</v>
<v t="ekr.20061101121602.290"><vh>@test move-lines-up</vh>
<v t="ekr.20061101121602.291"><vh>work</vh></v>
<v t="ekr.20061101121602.292"><vh>before sel=2.2,2.2</vh></v>
<v t="ekr.20061101121602.293"><vh>after sel=1.2,1.2</vh></v>
</v>
<v t="ekr.20120306201833.3942"><vh>@test move-lines-up (into docstring)</vh>
<v t="ekr.20120306201833.3943"><vh>work</vh></v>
<v t="ekr.20120306201833.3944"><vh>before sel=7.1,7.1</vh></v>
<v t="ekr.20120306201833.3945"><vh>after sel=6.1,6.1</vh></v>
</v>
<v t="ekr.20111006064419.3493"><vh>@test move-marked-nodes</vh></v>
<v t="ekr.20061101121602.294"><vh>@test move-past-close</vh>
<v t="ekr.20061101121602.295"><vh>work</vh></v>
<v t="ekr.20061101121602.296"><vh>before sel=1.10,1.10</vh></v>
<v t="ekr.20061101121602.297"><vh>after sel=1.12,1.12</vh></v>
</v>
<v t="ekr.20061101121602.298"><vh>@test move-past-close-extend-selection</vh>
<v t="ekr.20061101121602.299"><vh>work</vh></v>
<v t="ekr.20061101121602.300"><vh>before sel=3.7,3.7</vh></v>
<v t="ekr.20061101121602.301"><vh>after sel=3.7,3.11</vh></v>
</v>
<v t="ekr.20061101121602.302"><vh>@test newline-and-indent</vh>
<v t="ekr.20061101121602.303"><vh>work</vh></v>
<v t="ekr.20061101121602.304"><vh>before sel=2.6,2.6</vh></v>
<v t="ekr.20061101121602.305"><vh>after sel=3.4,3.4</vh></v>
</v>
<v t="ekr.20070315065720"><vh>@test next-line</vh>
<v t="ekr.20070315065720.1"><vh>work</vh></v>
<v t="ekr.20070315065720.2"><vh>before sel=1.1,1.1</vh></v>
<v t="ekr.20070315065720.3"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20070315065849"><vh>@test previous-line</vh>
<v t="ekr.20070315065849.1"><vh>work</vh></v>
<v t="ekr.20070315065849.2"><vh>before sel=3.0,3.0</vh></v>
<v t="ekr.20070315065849.3"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20070217071121.1"><vh>@test rectangle-clear</vh>
<v t="ekr.20070217071121.2"><vh>work</vh></v>
<v t="ekr.20070217071121.3"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.4"><vh>after sel=2.3,5.6</vh></v>
</v>
<v t="ekr.20070217071121.5"><vh>@test rectangle-close</vh>
<v t="ekr.20070217071121.6"><vh>work</vh></v>
<v t="ekr.20070217071121.7"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.8"><vh>after sel=2.3,5.3</vh></v>
</v>
<v t="ekr.20070217071121.9"><vh>@test rectangle-delete</vh>
<v t="ekr.20070217071121.10"><vh>work</vh></v>
<v t="ekr.20070217071121.11"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.12"><vh>after sel=2.3,5.3</vh></v>
</v>
<v t="ekr.20070217071121.17"><vh>@test rectangle-kill</vh>
<v t="ekr.20070217071121.18"><vh>work</vh></v>
<v t="ekr.20070217071121.19"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.20"><vh>after sel=5.3,5.3</vh></v>
</v>
<v t="ekr.20070217071121.13"><vh>@test rectangle-open</vh>
<v t="ekr.20070217071121.14"><vh>work</vh></v>
<v t="ekr.20070217071121.15"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.16"><vh>after sel=2.3,5.6</vh></v>
</v>
<v t="ekr.20070217071121.21"><vh>@test rectangle-string</vh>
<v t="ekr.20070217071121.22"><vh>work</vh></v>
<v t="ekr.20070217071121.23"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.24"><vh>after sel=2.3,5.8</vh></v>
</v>
<v t="ekr.20070217071121.25"><vh>@test rectangle-yank</vh>
<v t="ekr.20070217071121.26"><vh>work</vh></v>
<v t="ekr.20070217071121.28"><vh>before sel=2.3,5.6</vh></v>
<v t="ekr.20070217071121.27"><vh>after sel=2.3,5.6</vh></v>
</v>
<v t="ekr.20061101121602.306"><vh>@test remove-blank-lines</vh>
<v t="ekr.20061101121602.307"><vh>work</vh></v>
<v t="ekr.20061101121602.308"><vh>before sel=1.0,9.0</vh></v>
<v t="ekr.20061101121602.309"><vh>after sel=1.0,6.9</vh></v>
</v>
<v t="ekr.20061101121602.310"><vh>@test remove-space-from-lines</vh>
<v t="ekr.20061101121602.311"><vh>work</vh></v>
<v t="ekr.20061101121602.312"><vh>before sel=1.0,9.0</vh></v>
<v t="ekr.20061101121602.313"><vh>after sel=1.0,9.0</vh></v>
</v>
<v t="ekr.20061101121602.314"><vh>@test remove-tab-from-lines</vh>
<v t="ekr.20061101121602.315"><vh>work</vh></v>
<v t="ekr.20061101121602.316"><vh>before sel=1.0,7.0</vh></v>
<v t="ekr.20061101121602.317"><vh>after sel=1.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.318"><vh>@test reverse-region</vh>
<v t="ekr.20061101121602.319"><vh>work</vh></v>
<v t="ekr.20061101121602.320"><vh>before sel=1.0,7.0</vh></v>
<v t="ekr.20061101121602.321"><vh>after sel=7.10,7.10</vh></v>
</v>
<v t="ekr.20071113081247"><vh>@test reverse-sort-lines</vh>
<v t="ekr.20071113081247.1"><vh>work</vh></v>
<v t="ekr.20071113081247.2"><vh>before sel=1.0,5.1</vh></v>
<v t="ekr.20071113081247.3"><vh>after sel=1.0,5.1</vh></v>
</v>
<v t="ekr.20071113082531"><vh>@test reverse-sort-lines-ignoring-case</vh>
<v t="ekr.20071113082531.1"><vh>work</vh></v>
<v t="ekr.20071113082531.2"><vh>before sel=1.0,6.1</vh></v>
<v t="ekr.20071113082531.3"><vh>after sel=1.0,6.1</vh></v>
</v>
<v t="ekr.20071113145804.4"><vh>@test selfInsertCommand-1</vh></v>
<v t="ekr.20071113145804.5"><vh>@test selfInsertCommand-2 (replacing tabs)</vh></v>
<v t="ekr.20071007120750.6"><vh>@test set-fill-prefix</vh></v>
<v t="ekr.20061101121602.322"><vh>@test sort-columns</vh>
<v t="ekr.20061101121602.323"><vh>work</vh></v>
<v t="ekr.20061101121602.324"><vh>before sel=1.0,6.2</vh></v>
<v t="ekr.20061101121602.325"><vh>after sel=1.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.326"><vh>@test sort-lines</vh>
<v t="ekr.20061101121602.327"><vh>work</vh></v>
<v t="ekr.20061101121602.328"><vh>before sel=2.0,5.6</vh></v>
<v t="ekr.20061101121602.329"><vh>after sel=2.0,5.6</vh></v>
</v>
<v t="ekr.20071113081247.8"><vh>@test sort-lines-ignoring-case</vh>
<v t="ekr.20071113081247.9"><vh>work</vh></v>
<v t="ekr.20071113081247.10"><vh>before sel=1.0,5.1</vh></v>
<v t="ekr.20071113081247.11"><vh>after sel=1.0,5.1</vh></v>
</v>
<v t="ekr.20100212104817.5346"><vh>@test sort-recent-files (new)</vh></v>
<v t="ekr.20100212104817.5347"><vh>@test sort-siblings (new)</vh>
<v t="ekr.20100212104817.5348"><vh>b</vh></v>
<v t="ekr.20100212104817.5349"><vh>a</vh></v>
<v t="ekr.20100212104817.5350"><vh>c</vh></v>
</v>
<v t="ekr.20061101121602.330"><vh>@test split-line</vh>
<v t="ekr.20061101121602.331"><vh>work</vh></v>
<v t="ekr.20061101121602.332"><vh>before sel=1.5,1.5</vh></v>
<v t="ekr.20061101121602.333"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20061101121602.334"><vh>@test tabify</vh>
<v t="ekr.20061101121602.335"><vh>work</vh></v>
<v t="ekr.20061101121602.336"><vh>before sel=1.0,7.0</vh></v>
<v t="ekr.20061101121602.337"><vh>after sel=7.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.338"><vh>@test transpose-chars</vh>
<v t="ekr.20061101121602.339"><vh>work</vh></v>
<v t="ekr.20061101121602.340"><vh>before sel=1.2,1.2</vh></v>
<v t="ekr.20061101121602.341"><vh>after sel=1.2,1.2</vh></v>
</v>
<v t="ekr.20061101121602.342"><vh>@test transpose-lines</vh>
<v t="ekr.20061101121602.343"><vh>work</vh></v>
<v t="ekr.20061101121602.344"><vh>before sel=2.2,2.2</vh></v>
<v t="ekr.20061101121602.345"><vh>after sel=2.10,2.10</vh></v>
</v>
<v t="ekr.20160314133351.1"><vh>@test transpose-words</vh>
<v t="ekr.20160314133351.2"><vh>work</vh></v>
<v t="ekr.20160314133351.3"><vh>before sel=2.9,2.9</vh></v>
<v t="ekr.20160314133351.4"><vh>after sel=2.11,2.11</vh></v>
</v>
<v t="ekr.20121016134831.3906"><vh>@test typescript-to-python</vh>
<v t="ekr.20121016134831.3907"><vh>typescript tokenize test</vh></v>
</v>
<v t="ekr.20061101121602.346"><vh>@test untabify</vh>
<v t="ekr.20061101121602.347"><vh>work</vh></v>
<v t="ekr.20061101121602.348"><vh>before sel=1.0,7.0</vh></v>
<v t="ekr.20061101121602.349"><vh>after sel=7.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.350"><vh>@test upcase-region</vh>
<v t="ekr.20061101121602.351"><vh>work</vh></v>
<v t="ekr.20061101121602.352"><vh>before sel=3.0,4.0</vh></v>
<v t="ekr.20061101121602.353"><vh>after sel=3.0,4.0</vh></v>
</v>
<v t="ekr.20061101121602.354"><vh>@test upcase-word</vh>
<v t="ekr.20061101121602.355"><vh>work</vh></v>
<v t="ekr.20061101121602.356"><vh>before sel=3.7,3.7</vh></v>
<v t="ekr.20061101121602.357"><vh>after sel=3.7,3.7</vh></v>
</v>
<v t="ekr.20110118082508.3729"><vh>reformat-paragraph tests</vh>
<v t="ekr.20110118082508.3793"><vh>@test reformat-paragraph list 1 of 5</vh>
<v t="ekr.20110118082508.3799"><vh>work</vh></v>
<v t="ekr.20110118082508.3800"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20110118082508.3803"><vh>after sel=2.21,2.21</vh></v>
</v>
<v t="ekr.20110118082508.3808"><vh>@test reformat-paragraph list 2 of 5</vh>
<v t="ekr.20110118082508.3809"><vh>work</vh></v>
<v t="ekr.20110118082508.3810"><vh>before sel=4.0,4.0</vh></v>
<v t="ekr.20110118082508.3811"><vh>after sel=7.0,7.0</vh></v>
</v>
<v t="ekr.20110118082508.3816"><vh>@test reformat-paragraph list 3 of 5</vh>
<v t="ekr.20110118082508.3817"><vh>work</vh></v>
<v t="ekr.20110118082508.3818"><vh>before sel=7.0,7.0</vh></v>
<v t="ekr.20110118082508.3819"><vh>after sel=8.29,8.29</vh></v>
</v>
<v t="ekr.20110118082508.3824"><vh>@test reformat-paragraph list 4 of 5</vh>
<v t="ekr.20110118082508.3825"><vh>work</vh></v>
<v t="ekr.20110118082508.3826"><vh>before sel=10.0,10.0</vh></v>
<v t="ekr.20110118082508.3827"><vh>after sel=11.28,11.28</vh></v>
</v>
<v t="ekr.20110118082508.3832"><vh>@test reformat-paragraph list 5 of 5</vh>
<v t="ekr.20110118082508.3833"><vh>work</vh></v>
<v t="ekr.20110118082508.3834"><vh>before sel=13.0,13.0</vh></v>
<v t="ekr.20110118082508.3835"><vh>after sel=14.19,14.19</vh></v>
</v>
<v t="ekr.20131103084038.4274"><vh>@test reformat-paragraph new code 1 of 8</vh>
<v t="ekr.20131103084038.4275"><vh>work</vh></v>
<v t="ekr.20131103084038.4276"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20131103084038.4277"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20131103084038.4282"><vh>@test reformat-paragraph new code 2 of 8</vh>
<v t="ekr.20131103084038.4283"><vh>work</vh></v>
<v t="ekr.20131103084038.4284"><vh>before sel=2.0,2.0</vh></v>
<v t="ekr.20131103084038.4285"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20131103084038.4290"><vh>@test reformat-paragraph new code 3 of 8</vh>
<v t="ekr.20131103084038.4291"><vh>work</vh></v>
<v t="ekr.20131103084038.4292"><vh>before sel=3.1,4.1</vh></v>
<v t="ekr.20131103084038.4293"><vh>after sel=3.26,3.26</vh></v>
</v>
<v t="ekr.20131103084038.4298"><vh>@test reformat-paragraph new code 4 of 8</vh>
<v t="ekr.20131103084038.4299"><vh>work</vh></v>
<v t="ekr.20131103084038.4300"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20131103084038.4301"><vh>after sel=2.10,2.10</vh></v>
</v>
<v t="ekr.20131103084038.4306"><vh>@test reformat-paragraph new code 5 of 8</vh>
<v t="ekr.20131103084038.4307"><vh>work</vh></v>
<v t="ekr.20131103084038.4308"><vh>before sel=1.0,2.0</vh></v>
<v t="ekr.20131103084038.4309"><vh>after sel=2.11,2.11</vh></v>
</v>
<v t="ekr.20131103084038.4314"><vh>@test reformat-paragraph new code 6 of 8</vh>
<v t="ekr.20131103084038.4315"><vh>work</vh></v>
<v t="ekr.20131103084038.4316"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20131103084038.4317"><vh>after sel=2.11,2.11</vh></v>
</v>
<v t="ekr.20131103084038.4322"><vh>@test reformat-paragraph new code 7 of 8</vh>
<v t="ekr.20131103084038.4323"><vh>work</vh></v>
<v t="ekr.20131103084038.4324"><vh>before sel=2.11,2.11</vh></v>
<v t="ekr.20131103084038.4325"><vh>after sel=3.1,3.1</vh></v>
</v>
<v t="ekr.20131103084038.4330"><vh>@test reformat-paragraph new code 8 of 8</vh>
<v t="ekr.20131103084038.4331"><vh>work</vh></v>
<v t="ekr.20131103084038.4332"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20131103084038.4333"><vh>after sel=3.0,3.0</vh></v>
</v>
<v t="ekr.20110118082508.3766"><vh>@test reformat-paragraph paragraph 1 of 3</vh>
<v t="ekr.20110118082508.3772"><vh>work</vh></v>
<v t="ekr.20110118082508.3773"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20110118082508.3792"><vh>after sel=11.14,11.14</vh></v>
</v>
<v t="ekr.20110118082508.3779"><vh>@test reformat-paragraph paragraph 2 of 3</vh>
<v t="ekr.20110118082508.3780"><vh>work</vh></v>
<v t="ekr.20110118082508.3781"><vh>before sel=13.0,13.0</vh></v>
<v t="ekr.20110118082508.3782"><vh>after sel=23.33,23.33</vh></v>
</v>
<v t="ekr.20110118082508.3787"><vh>@test reformat-paragraph paragraph 3 of 3</vh>
<v t="ekr.20110118082508.3788"><vh>work</vh></v>
<v t="ekr.20110118082508.3789"><vh>before sel=25.10,25.10</vh></v>
<v t="ekr.20110118082508.3790"><vh>after sel=32.11,32.11</vh></v>
</v>
<v t="ekr.20110118082508.3730"><vh>@test reformat-paragraph simple hanging indent</vh>
<v t="ekr.20110118082508.3745"><vh>work</vh></v>
<v t="ekr.20110118082508.3746"><vh>before sel= 1.0,1.0</vh></v>
<v t="ekr.20110118082508.3747"><vh>after sel= 5.8,5.8</vh></v>
</v>
<v t="ekr.20110118082508.3748"><vh>@test reformat-paragraph simple hanging indent 2</vh>
<v t="ekr.20110118082508.3754"><vh>work</vh></v>
<v t="ekr.20110118082508.3755"><vh>before sel=2.0,2.0</vh></v>
<v t="ekr.20110118082508.3756"><vh>after sel=5.8,5.8</vh></v>
</v>
<v t="ekr.20110118082508.3757"><vh>@test reformat-paragraph simple hanging indent 3</vh>
<v t="ekr.20110118082508.3763"><vh>work</vh></v>
<v t="ekr.20110118082508.3764"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20110118082508.3765"><vh>after sel=5.8,5.8</vh></v>
</v>
</v>
</v>
<v t="ekr.20061104172236.1"><vh> Function tests</vh>
<v t="ekr.20150430053825.1"><vh>@test abbrevCommands.next_place</vh>
<v t="ekr.20150430061225.1"><vh>child</vh></v>
</v>
<v t="ekr.20100902074747.5970"><vh>@test addAbbrevHelper</vh></v>
<v t="ekr.20061104172236.3"><vh>@test capitalizeHelper</vh></v>
<v t="ekr.20100131180007.5453"><vh>@test dynamicExpandHelper</vh></v>
<v t="ekr.20061104172236.5"><vh>@test extendHelper</vh></v>
<v t="ekr.20080408094623.1"><vh>@test findWord</vh></v>
<v t="ekr.20061104172236.2"><vh>@test findWordInLine</vh></v>
<v t="ekr.20071113145804.15"><vh>@test helpForMinibuffer</vh></v>
<v t="ekr.20061104172236.6"><vh>@test moveToHelper</vh></v>
<v t="ekr.20061110094226"><vh>@test moveUpOrDownHelper</vh></v>
<v t="ekr.20061104172236.7"><vh>@test scrollHelper</vh></v>
<v t="ekr.20061104172236.4"><vh>@test setMoveCol</vh></v>
</v>
<v t="ekr.20100204165850.5371"><vh>Toggle commands</vh>
<v t="ekr.20100119102849.5108"><vh>@test toggle-extend-mode</vh>
<v t="ekr.20100119102849.5109"><vh>&lt;&lt; define table &gt;&gt;</vh></v>
<v t="ekr.20100119102849.5110"><vh>work</vh></v>
</v>
<v t="ekr.20100204165850.5373"><vh>@test most toggle commands</vh></v>
<v t="ekr.20100204173354.5375"><vh>@test toggle-find-x</vh></v>
</v>
<v t="ekr.20051107115231"><vh> Typing</vh>
<v t="ekr.20060208072415"><vh>@test Delete key sticks in body</vh></v>
<v t="ekr.20051125170139"><vh>@test Delete key sticks in headline</vh></v>
<v t="ekr.20051109091333"><vh>@test deleting the last body character text redraws the screen (and icon)</vh></v>
<v t="ekr.20051107115231.15"><vh>@test editLabel selects entire headline</vh></v>
<v t="ekr.20051120110335"><vh>@test insert-node can be undone and redone</vh></v>
<v t="ekr.20130923090601.4178"><vh>@test insert-node-before node can be undone and redone</vh></v>
<v t="ekr.20051125155134"><vh>@test inserting a new node draws the screen exactly once</vh></v>
<v t="ekr.20051107115231.18"><vh>@test paste and undo in headline - at end</vh></v>
<v t="ekr.20051107115231.20"><vh>@test paste and undo in headline - with selection</vh></v>
<v t="ekr.20051107115231.16"><vh>@test paste at end of headline</vh></v>
<v t="ekr.20060208072307"><vh>@test paste from menu into body sticks</vh></v>
<v t="ekr.20060208072331"><vh>@test paste from menu into headline sticks</vh></v>
<v t="ekr.20051107115231.24"><vh>@test paste from menu to body recolors the body</vh></v>
<v t="ekr.20051107115231.14"><vh>@test return ends editing of headline</vh></v>
<v t="ekr.20051107115231.28"><vh>@test selecting new node retains paste in headline</vh></v>
<v t="ekr.20051107115231.21"><vh>@test selecting new node retains typing in headline</vh></v>
<v t="ekr.20051107115231.17"><vh>@test typing and undo in headline - at end</vh></v>
<v t="ekr.20060208072358"><vh>@test typing in empty body text redraws the screen (and icon)</vh></v>
<v t="ekr.20051109091731"><vh>@test typing in non-empty body text does not redraw the screen</vh></v>
<v t="ekr.20051120115046"><vh>@test undoing insert node restores previous node's body text</vh></v>
<v t="ekr.20060131102450"></v>
</v>
<v t="ekr.20070306091949"></v>
</v>
<v t="ekr.20061001114637"><vh>leoFileCommands</vh>
<v t="ekr.20100206165505.5386"><vh>@@test fc.handleNodeConflicts</vh></v>
<v t="ekr.20100131180007.5451"><vh>@test fc.cleanSaxInputString</vh></v>
<v t="ekr.20071113145804.18"><vh>@test fc.deleteFileWithMessage</vh></v>
<v t="ekr.20100131180007.5450"><vh>@test fc.getSaxUa</vh></v>
<v t="ekr.20100131180007.5463"><vh>@test fc.handleTnodeSaxAttributes</vh></v>
<v t="ekr.20100131180007.5460"><vh>@test fc.handleVnodeSaxAttributes</vh></v>
<v t="ekr.20080806072412.1"><vh>@test fc.resolveArchivedPosition</vh>
<v t="ekr.20080806072412.2"><vh>first child</vh></v>
<v t="ekr.20080806072412.3"><vh>second child</vh>
<v t="ekr.20080806072412.4"><vh>grandChild1</vh>
<v t="ekr.20080806080425.1"><vh>greatGrandChild11</vh></v>
<v t="ekr.20080806080425.2"><vh>greatGrandChild12</vh></v>
</v>
<v t="ekr.20080806072412.5"><vh>grandChild 2</vh>
<v t="ekr.20080806080425.3"><vh>greatGrandChild21</vh></v>
<v t="ekr.20080806080425.4"><vh>greatGrandChild22</vh></v>
</v>
</v>
</v>
<v t="ekr.20080805105541.1"><vh>@test p.archivedPosition</vh>
<v t="ekr.20080805122315.1"><vh>first child</vh></v>
<v t="ekr.20080805122315.2"><vh>second child</vh>
<v t="ekr.20080805122315.3"><vh>grandChild</vh></v>
<v t="ekr.20080805122315.4"><vh>grandChild 2</vh></v>
</v>
</v>
<v t="ekr.20080805104144.1"><vh>@test putDescendentVnodeUas</vh>
<v t="ekr.20080805104144.2"><vh>child</vh>
<v t="ekr.20080805104144.3"><vh>grandChild</vh></v>
</v>
</v>
<v t="ekr.20061001114236"><vh>@test putUa</vh></v>
<v t="ekr.20051107115231.9"><vh>@test Select a node when file is first loaded</vh></v>
<v t="ekr.20090507084947.5152"><vh>@test t.fileIndex remains the same</vh></v>
<v t="ekr.20071113202045"></v>
</v>
<v t="ekr.20071113193527"><vh>leoFind</vh>
<v t="ekr.20051107115231.29"><vh>@@test Find keeps focus in body &amp; shows selected text</vh></v>
<v t="ekr.20060130151716.3"><vh>@test minibuffer find commands</vh></v>
<v t="ekr.20060130151716.2"><vh>@test set find mode commands</vh></v>
<v t="ekr.20060130151716.4"><vh>@test show-find-options</vh></v>
<v t="ekr.20060130151716.1"><vh>@test toggle find options commands</vh></v>
<v t="ekr.20071113202153"></v>
</v>
<v t="ekr.20071113194424"><vh>leoFrame</vh>
<v t="ekr.20060912091510.1"><vh>@@test add-editor &amp; delete-editor</vh></v>
<v t="ekr.20090608174319.4791"><vh>@@test delete-editor</vh></v>
<v t="ekr.20061106201509.6"><vh>@test c.frame.body.getInsertLines</vh></v>
<v t="ekr.20061106201509.7"><vh>@test c.frame.body.getSelectionAreas</vh></v>
<v t="ekr.20071113145804.32"><vh>@test c.frame.body.getSelectionAreas &amp; test</vh></v>
<v t="ekr.20111121152019.3929"><vh>@test c.frame.body.updateEditors</vh></v>
<v t="ekr.20111121142012.4030"></v>
<v t="ekr.20111121081052.3908"><vh>@test c.frame.log.numberOfVisibleTabs</vh></v>
<v t="ekr.20111121140833.3917"><vh>@test c.frame.log.put &amp; putNl</vh></v>
<v t="ekr.20111107065245.3833"><vh>@test c.frame.minimize-all</vh></v>
<v t="ekr.20061104172236.22"><vh>@test c.frame.pasteText</vh></v>
<v t="ekr.20071113145804.33"><vh>@test c.frame.pasteText 2</vh></v>
<v t="ekr.20111107065530.3833"><vh>@test c.frame.resize-to-screen</vh></v>
<v t="ekr.20100131180007.5359"><vh>@test c.frame.tree.OnIconDoubleClick</vh></v>
<v t="ekr.20071113202153.1"></v>
</v>
<v t="ekr.20071113194033.3"><vh>leoGlobals</vh>
<v t="ekr.20100131180007.5398"><vh>@test g.adjustTripleString</vh></v>
<v t="ekr.20110510054817.3476"><vh>@test g.alert</vh></v>
<v t="ekr.20040917062206"><vh>@test g.cantImport returns None</vh></v>
<v t="ekr.20060921115303"><vh>@test g.checkVersion</vh></v>
<v t="ekr.20071113143844.9"><vh>@test g.CheckVersionToInt</vh></v>
<v t="ekr.20100131180007.5428"><vh>@test g.comment_delims_from_extension</vh></v>
<v t="ekr.20160327132053.1"><vh>@test g.compute_directives_re</vh></v>
<v t="ekr.20071113145804.26"><vh>@test g.convertPythonIndexToRowCol</vh></v>
<v t="ekr.20071113145804.27"><vh>@test g.convertRowColToPythonIndex</vh></v>
<v t="ekr.20071113145804.21"><vh>@test g.create_temp_file</vh></v>
<v t="ekr.20100131180007.5403"><vh>@test g.ensureLeadingNewlines</vh></v>
<v t="ekr.20100131180007.5404"><vh>@test g.ensureTrailingNewlines</vh></v>
<v t="ekr.20111110073834.3843"><vh>@test g.es_print</vh></v>
<v t="ekr.20071113145804.22"><vh>@test g.es_trace</vh></v>
<v t="ekr.20140702101937.4245"><vh>@test g.find_word</vh></v>
<v t="ekr.20100131180007.5455"><vh>@test g.fullPath</vh>
<v t="ekr.20100131180007.5456"><vh>@path abc</vh>
<v t="ekr.20100131180007.5457"><vh>xyz</vh></v>
</v>
</v>
<v t="ekr.20071113090055.5"><vh>@test g.get_directives_dict</vh></v>
<v t="ekr.20100131180007.5434"><vh>@test g.get_directives_dict 2</vh></v>
<v t="ekr.20111018163546.3690"><vh>@test g.getDocString</vh></v>
<v t="ekr.20061104172236.18"><vh>@test g.getLine</vh></v>
<v t="ekr.20071113145804.28"><vh>@test g.getScript strips crlf</vh></v>
<v t="ekr.20061104172236.11"><vh>@test g.getWord</vh></v>
<v t="ekr.20110612064437.3310"><vh>@test g.guessExternalEditor</vh></v>
<v t="ekr.20120307133953.3947"><vh>@test g.handleUrl</vh></v>
<v t="ekr.20111103213154.3824"><vh>@test g.importFromPath</vh></v>
<v t="ekr.20141208130803.11"><vh>@test g.importModule</vh></v>
<v t="ekr.20170122164330.1"><vh>@test g.isDirective</vh></v>
<v t="ekr.20101021205258.6010"><vh>@test g.makeAllNonExistentDirectories</vh></v>
<v t="ekr.20111104112332.3953"><vh>@test g.os_path_finalize_join with thumb drive</vh></v>
<v t="ekr.20071113145804.19"><vh>@test g.pdb</vh></v>
<v t="ekr.20111110073528.3843"><vh>@test g.pr</vh></v>
<v t="ekr.20100212112056.5361"><vh>@test g.printGcAll</vh></v>
<v t="ekr.20100131180007.5396"><vh>@test g.removeBlankLines</vh></v>
<v t="ekr.20071113145804.29"><vh>@test g.removeExtraLws</vh></v>
<v t="ekr.20100131180007.5395"><vh>@test g.removeLeadingBlankLines</vh></v>
<v t="ekr.20100131180007.5402"><vh>@test g.removeTrailing</vh></v>
<v t="ekr.20150328120706.1"><vh>@test g.sanitize_filename</vh></v>
<v t="ekr.20080917151620.13"><vh>@test g.scanAtHeaderDirectives header</vh></v>
<v t="ekr.20100131180007.5435"><vh>@test g.scanAtHeaderDirectives header</vh></v>
<v t="ekr.20080917151620.14"><vh>@test g.scanAtHeaderDirectives noheader</vh></v>
<v t="ekr.20080917151620.15"><vh>@test g.scanAtLineendingDirectives cr</vh></v>
<v t="ekr.20080917151620.16"><vh>@test g.scanAtLineendingDirectives crlf</vh></v>
<v t="ekr.20080917151620.17"><vh>@test g.scanAtLineendingDirectives lf</vh></v>
<v t="ekr.20080917151620.18"><vh>@test g.scanAtLineendingDirectives nl</vh></v>
<v t="ekr.20080917151620.19"><vh>@test g.scanAtLineendingDirectives platform</vh></v>
<v t="ekr.20100131180007.5442"><vh>@test g.scanAtPagewidthDirectives -40</vh></v>
<v t="ekr.20080917151620.21"><vh>@test g.scanAtPagewidthDirectives 40</vh></v>
<v t="ekr.20080917151620.22"><vh>@test g.scanAtPathDirectives ../test/unittest/at-path-test1.py</vh>
<v t="ekr.20120228145505.4834"><vh>@thin ../test/unittest/at-path-test1.py</vh></v>
</v>
<v t="ekr.20080917151620.27"><vh>@test g.scanAtPathDirectives @path ../test @path unittest @thin at-path-test3.py</vh>
<v t="ekr.20080917151620.28"><vh>@path ../test</vh>
<v t="ekr.20080917151620.29"><vh>@path unittest</vh>
<v t="ekr.20120228145505.4838"><vh>@thin at-path-test3.py</vh></v>
</v>
</v>
</v>
<v t="ekr.20080917151620.24"><vh>@test g.scanAtPathDirectives @path ../test/unittest @thin at-path-test2.py</vh>
<v t="ekr.20080917151620.25"><vh>@path ../test/unittest</vh>
<v t="ekr.20120228145505.4841"><vh>@thin at-path-test2.py</vh></v>
</v>
</v>
<v t="ekr.20080917151620.31"><vh>@test g.scanAtTabwidthDirectives +6</vh></v>
<v t="ekr.20080917151620.32"><vh>@test g.scanAtTabwidthDirectives -6</vh></v>
<v t="ekr.20080917151620.33"><vh>@test g.scanAtWrapDirectives nowrap</vh></v>
<v t="ekr.20080917151620.34"><vh>@test g.scanAtWrapDirectives wrap (with @wrap)</vh></v>
<v t="ekr.20080917151620.35"><vh>@test g.scanAtWrapDirectives wrap (without @nowrap)</vh></v>
<v t="ekr.20100131180007.5426"><vh>@test g.set_delims_from_language</vh></v>
<v t="ekr.20100131180007.5425"><vh>@test g.set_delims_from_string</vh></v>
<v t="ekr.20100131180007.5421"><vh>@test g.setDefaultDirectory</vh></v>
<v t="sps.20100609234650.16094"><vh>@test g.skip_blank_lines</vh></v>
<v t="ekr.20061104172236.15"><vh>@test g.skip_line</vh></v>
<v t="ekr.20061104172236.16"><vh>@test g.skip_to_end_of_line</vh></v>
<v t="ekr.20061104172236.17"><vh>@test g.skip_to_start_of_line</vh></v>
<v t="ekr.20150610130646.1"><vh>@test g.splitLongFileName</vh></v>
<v t="ekr.20130910062920.4149"><vh>@test g.stripBOM</vh></v>
<v t="ekr.20100131180007.5427"><vh>@test g.stripPathCruft</vh></v>
<v t="ekr.20141223125432.11"></v>
<v t="ekr.20111110072415.3841"><vh>@test g.trace</vh></v>
<v t="ekr.20050105084757.1"><vh>@test g.utils_remove</vh></v>
<v t="ekr.20050105091547"><vh>@test g.utils_rename</vh></v>
<v t="ekr.20100131180007.5429"><vh>@test g.warnOnReadOnlyFile</vh></v>
<v t="ekr.20050208135429"><vh>@test pre-definition of g in scripts</vh></v>
<v t="ekr.20071113202153.2"></v>
</v>
<v t="ekr.20100131171342.5599"><vh>leoGui &amp; leoQtGui</vh>
<v t="ekr.20111120124051.3992"></v>
<v t="ekr.20111003145300.3466"><vh>@test illegal drag gives warning</vh>
<v t="ekr.20111003145300.3467"><vh>a</vh></v>
</v>
<v t="ekr.20111123214629.3941"></v>
<v t="ekr.20100131171342.5603"></v>
</v>
<v t="ekr.20090529141856.4682"><vh>@ignore leoImport (3 failures)</vh>
<v t="ekr.20090529141856.4684"><vh>Export tests</vh>
<v t="ekr.20090529141856.4685"><vh>@suite Export tests</vh></v>
</v>
<v t="ekr.20090529141856.4698"><vh>Import tests</vh>
<v t="ekr.20090529141856.4699"><vh>@suite Import tests</vh></v>
</v>
<v t="ekr.20090529141856.4716"><vh>Tests of @auto</vh>
<v t="ekr.20090529141856.4783"><vh>@test collapse-all</vh></v>
<v t="ekr.20090529141856.4717"><vh>C tests</vh>
<v t="ekr.20090529141856.4718"><vh>@test c class 1</vh></v>
<v t="ekr.20090529141856.4719"><vh>@test c class--underindented line</vh></v>
<v t="ekr.20090529141856.4721"><vh>@test c comment follows arg list</vh></v>
<v t="ekr.20090529141856.4722"><vh>@test c comment follows block delim</vh></v>
<v t="ekr.20090529141856.4723"><vh>@test c intermixed blanks and tabs</vh></v>
<v t="ekr.20090529141856.4724"><vh>@test c old-style decl 1</vh></v>
<v t="ekr.20090529141856.4725"><vh>@test c old-style decl 2</vh></v>
<v t="ekr.20090529141856.4726"><vh>@test c extern</vh></v>
</v>
<v t="ekr.20090529141856.4727"><vh>c# tests</vh>
<v t="ekr.20090529141856.4728"><vh>@test c# namespace indent</vh></v>
<v t="ekr.20090529141856.4729"><vh>@test c# namespace no indent</vh></v>
<v t="ekr.20090529141856.4730"><vh>@@test c# ref card</vh></v>
</v>
<v t="ekr.20161108034116.1"><vh>coffeescript tests</vh>
<v t="ekr.20161108034138.1"><vh>@test coffeescript-1</vh></v>
<v t="ekr.20161109084732.1"><vh>@test coffeescript-2</vh></v>
<v t="ekr.20161118144658.1"><vh>@test coffeescript-3</vh></v>
</v>
<v t="ekr.20161123115047.1"><vh>dart tests</vh>
<v t="ekr.20161123120652.1"><vh>@test dart hello world</vh></v>
</v>
<v t="ekr.20090529141856.4731"><vh>elisp tests</vh>
<v t="ekr.20090529141856.4733"><vh>@test elisp</vh></v>
</v>
<v t="ekr.20111029112647.4099"><vh>html tests</vh>
<v t="ekr.20111107102431.3849"><vh>@@test html whitespace bug</vh></v>
<v t="ekr.20111029112647.4101"><vh>@test html: lowercase tags</vh></v>
<v t="ekr.20111109143012.3839"><vh>@test html: multiple tags on a line</vh></v>
<v t="ekr.20140218122321.4349"><vh>@test html: multple node completed on a line</vh></v>
<v t="ekr.20170416085619.1"><vh>@test html: multple node starts on a line</vh></v>
<v t="ekr.20111102164107.3975"><vh>@test html: underindented comment</vh></v>
<v t="ekr.20111029120441.3982"><vh>@test html: uppercase tags</vh></v>
<v t="ekr.20111112103320.3849"><vh>@test html: improperly nested tags</vh></v>
<v t="ekr.20111112103320.3887"><vh>@test html: improperly terminated tags</vh></v>
<v t="ekr.20111112103320.3893"><vh>@test html: improperly terminated tags2</vh></v>
</v>
<v t="ekr.20100803234640.5804"><vh>ini tests</vh>
<v t="ekr.20100803234640.5805"><vh>@test ini-test-1</vh></v>
</v>
<v t="ekr.20090529141856.4766"><vh>Java tests</vh>
<v t="ekr.20090529141856.4771"><vh>@@test AdminPermission.java</vh></v>
<v t="ekr.20090529141856.4769"><vh>@@test constants.java</vh></v>
<v t="ekr.20090529141856.4770"><vh>@test from AdminPermission.java</vh></v>
<v t="ekr.20090529141856.4773"><vh>@test from BundleException.java</vh></v>
<v t="ekr.20090529141856.4767"><vh>@test java interface test1</vh></v>
<v t="ekr.20090529141856.4768"><vh>@test java interface test2</vh></v>
</v>
<v t="ekr.20090529141856.4774"><vh>Javascript tests</vh>
<v t="ekr.20090529141856.4775"><vh>Problems</vh></v>
<v t="ekr.20090529141856.4776"><vh>@test Javascript-regex-1</vh></v>
<v t="ekr.20090529141856.4777"><vh>@@test JSON</vh></v>
<v t="ekr.20090529141856.4778"><vh>@test Javascript-3</vh></v>
<v t="ekr.20140218042220.4347"><vh>@test Javascript-4</vh></v>
<v t="ekr.20140218151418.4353"><vh>@test Javascript-5</vh></v>
</v>
<v t="ekr.20161123202857.1"><vh>org tests</vh>
<v t="ekr.20161123202924.1"><vh>@test org-1</vh></v>
</v>
<v t="ekr.20161124040933.1"><vh>otl (vim-outline) tests</vh>
<v t="ekr.20161124040933.2"><vh>@test otl-1</vh></v>
</v>
<v t="ekr.20090529141856.4734"><vh>Pascal tests</vh>
<v t="ekr.20090529141856.4735"><vh>@test pascal-to-delphi interface</vh></v>
</v>
<v t="ekr.20161103015908.1"><vh>Perl tests</vh>
<v t="ekr.20161103015940.1"><vh>@test perl-1</vh></v>
<v t="ekr.20161103021621.1"><vh>@test perlpod comment</vh></v>
<v t="ekr.20161103021420.1"><vh>@test perl multi-line string</vh></v>
<v t="ekr.20161119031833.1"><vh>@test perl regex-1</vh></v>
<v t="ekr.20161119032623.1"><vh>@test perl regex-2</vh></v>
</v>
<v t="ekr.20100219080213.5365"><vh>PHP tests</vh>
<v t="ekr.20100219080213.5366"><vh>@test php import class</vh></v>
<v t="ekr.20100219080213.5367"><vh>@test php import conditional class</vh></v>
<v t="ekr.20100219080213.5368"><vh>@test php import classes &amp; functions</vh></v>
<v t="ekr.20161129222003.1"><vh>@test php here doc</vh>
<v t="ekr.20161130042452.50"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161130042452.51"><vh>class foo</vh></v>
</v>
<v t="ekr.20161130050706.29"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161130050706.30"><vh>class foo</vh></v>
</v>
<v t="ekr.20161202053644.21"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161202053644.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20161202083956.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161202083956.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161202093505.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161202093505.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204034138.15"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204034138.16"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204035447.20"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204035447.21"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041306.21"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041306.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041354.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041354.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041426.33"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041426.34"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041641.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041641.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041720.21"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041720.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041755.29"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041755.30"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041842.20"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041842.21"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041902.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041902.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204041920.33"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204041920.34"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204042116.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204042116.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204042155.7"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204042155.8"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204042301.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204042301.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204042714.33"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204042714.34"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204042739.15"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204042739.16"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204043013.1"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204043013.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204043028.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204043028.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204043342.40"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204043342.41"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204045827.15"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204045827.16"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204045955.21"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204045955.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204154852.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204154852.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161204155218.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161204155218.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161206135449.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161206135449.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161206165824.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161206165824.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161216141227.1"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161216141227.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20161218104646.1"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161218104646.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20161220185154.21"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161220185154.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221062411.1"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221062411.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221063734.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221063734.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221065216.7"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221065216.8"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221080848.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221080848.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221091453.20"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221091453.21"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221091950.20"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221091950.21"><vh>class foo</vh></v>
</v>
<v t="ekr.20161221092230.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161221092230.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20161222122038.3"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161222122038.4"><vh>class foo</vh></v>
</v>
<v t="ekr.20161222123534.3"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161222123534.4"><vh>class foo</vh></v>
</v>
<v t="ekr.20161222123751.3"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161222123751.4"><vh>class foo</vh></v>
</v>
<v t="ekr.20161223153848.1"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161223153848.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20161231115630.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20161231115630.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20170101085120.25"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170101085120.26"><vh>class foo</vh></v>
</v>
<v t="ekr.20170101131839.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170101131839.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20170101134221.7"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170101134221.8"><vh>class foo</vh></v>
</v>
<v t="ekr.20170105122516.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170105122516.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20170112111339.7"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170112111339.8"><vh>class foo</vh></v>
</v>
<v t="ekr.20170112111900.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170112111900.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20170113162613.7"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170113162613.8"><vh>class foo</vh></v>
</v>
<v t="ekr.20170114055256.3"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170114055256.4"><vh>class foo</vh></v>
</v>
<v t="ekr.20170114080041.1"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170114080041.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20170114200550.3"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170114200550.4"><vh>class foo</vh></v>
</v>
<v t="ekr.20170115052901.10"><vh>@@clean c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170115052901.11"><vh>class foo</vh></v>
</v>
<v t="ekr.20170302201859.3"><vh>@@file c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170302201859.4"><vh>class foo</vh></v>
</v>
<v t="ekr.20170401122030.1"><vh>@@file c:/leo.repo/leo-editor/leo/test/php here doc</vh>
<v t="ekr.20170401122030.2"><vh>class foo</vh></v>
</v>
<v t="ekr.20170409174529.27"><vh>@@file @test php here doc</vh>
<v t="ekr.20170409174529.28"><vh>class foo</vh></v>
</v>
<v t="ekr.20170409174632.19"><vh>@@file @test php here doc</vh>
<v t="ekr.20170409174632.20"><vh>class foo</vh></v>
</v>
<v t="ekr.20170410190519.53"><vh>@@file @test php here doc</vh>
<v t="ekr.20170410190519.54"><vh>class foo</vh></v>
</v>
<v t="ekr.20170415061122.50"><vh>@@file @test php here doc</vh>
<v t="ekr.20170415061122.51"><vh>class foo</vh></v>
</v>
<v t="ekr.20170426033159.40"><vh>@@file @test php here doc</vh>
<v t="ekr.20170426033159.41"><vh>class foo</vh></v>
</v>
<v t="ekr.20170502211859.15"><vh>@@file @test php here doc</vh>
<v t="ekr.20170502211859.16"><vh>class foo</vh></v>
</v>
<v t="ekr.20170503133125.21"><vh>@@file @test php here doc</vh>
<v t="ekr.20170503133125.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20170503133258.21"><vh>@@file @test php here doc</vh>
<v t="ekr.20170503133258.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20170503133608.21"><vh>@@file @test php here doc</vh>
<v t="ekr.20170503133608.22"><vh>class foo</vh></v>
</v>
<v t="ekr.20170520193219.85"><vh>@@file @test php here doc</vh>
<v t="ekr.20170520193219.86"><vh>class foo</vh></v>
</v>
</v>
</v>
<v t="ekr.20090529141856.4736"><vh>Python tests</vh>
<v t="ekr.20161204042938.1"><vh>@@test print('end python tests')</vh></v>
<v t="ekr.20161204042916.1"><vh>@@test print('start python tests')</vh></v>
<v t="ekr.20161115092708.1"><vh>@test i.scan_state (for python)</vh></v>
<v t="ekr.20161224145026.1"><vh>@test leoApp fail</vh></v>
<v t="ekr.20161115063144.3"><vh>@test python bad class test</vh></v>
<v t="ekr.20161115063144.34"><vh>@test python basic nesting test</vh></v>
<v t="ekr.20161218103650.1"><vh>@test python bug #346</vh></v>
<v t="ekr.20161228070933.1"><vh>@test python bug #354</vh></v>
<v t="ekr.20170122033034.1"><vh>@test python bug #357</vh></v>
<v t="ekr.20170122032242.1"><vh>@test python bug #360</vh></v>
<v t="ekr.20170306041801.1"><vh>@test python bug @390</vh></v>
<v t="ekr.20161115063144.4"><vh>@test python bug 603720</vh></v>
<v t="ekr.20161115063144.5"><vh>@test python class test 2</vh></v>
<v t="ekr.20161115063144.6"><vh>@test python class tests 1</vh></v>
<v t="ekr.20161115063144.7"><vh>@test python comment after dict assign</vh></v>
<v t="ekr.20161115063144.8"><vh>@test python decls test 1</vh></v>
<v t="ekr.20161115063144.9"><vh>@test python decorator</vh></v>
<v t="ekr.20161224101046.1"><vh>@test python decorator 2</vh></v>
<v t="ekr.20161115063144.10"><vh>@test python def inside def</vh></v>
<v t="ekr.20161115063144.11"><vh>@test python def test 1</vh></v>
<v t="ekr.20161115063144.12"><vh>@test python def test 2</vh></v>
<v t="ekr.20161115063144.13"><vh>@test python docstring only</vh></v>
<v t="ekr.20161115063144.14"><vh>@test python empty decls</vh></v>
<v t="ekr.20161115063144.15"><vh>@test python extra leading ws test</vh></v>
<v t="ekr.20161115063144.16"><vh>@test python indent decls</vh></v>
<v t="ekr.20161117000902.1"><vh>@test python leoImport.py (small)</vh></v>
<v t="ekr.20161115063144.18"><vh>@test python looks like section ref</vh></v>
<v t="ekr.20161115063144.19"><vh>@test python minimal class 1</vh></v>
<v t="ekr.20161115063144.20"><vh>@test python minimal class 2</vh></v>
<v t="ekr.20161115063144.21"><vh>@test python minimal class 3</vh></v>
<v t="ekr.20161115063144.22"><vh>@test python overindent def--no following def</vh></v>
<v t="ekr.20161115063144.23"><vh>@test python overindent def--one following def</vh></v>
<v t="ekr.20161115063144.24"><vh>@test python overindented def 3</vh></v>
<v t="ekr.20161115063144.25"><vh>@test python string test: extra indent</vh></v>
<v t="ekr.20161115063144.26"><vh>@test python string underindent lines</vh></v>
<v t="ekr.20161115063144.27"><vh>@test python string underindent lines 2</vh></v>
<v t="ekr.20161222064421.1"><vh>@test python top-level later decl</vh></v>
<v t="ekr.20161115063144.28"><vh>@test python trailing comment</vh></v>
<v t="ekr.20161115063144.29"><vh>@test python trailing comment--outer levels</vh></v>
<v t="ekr.20161115063144.30"><vh>@test python two functions</vh></v>
<v t="ekr.20161115063144.31"><vh>@test python underindent method</vh></v>
<v t="ekr.20161115063144.32"><vh>@test python unindent in triple string does not end function</vh></v>
<v t="ekr.20161115063144.33"><vh>@test python unittest/perfectImport/formatter.py</vh></v>
</v>
<v t="ekr.20121011094154.3906"><vh>TypeScript tests</vh>
<v t="ekr.20121011094154.3911"><vh>@test TypeScript class</vh></v>
<v t="ekr.20121011100210.4035"><vh>@test TypeScript module</vh></v>
</v>
<v t="ekr.20090529141856.4780"><vh>xml tests</vh>
<v t="ekr.20170416060817.1"><vh>@test xml with standard opening elements</vh></v>
<v t="ekr.20090529141856.4781"><vh>@test xml 1</vh></v>
<v t="ekr.20111026105935.3966"><vh>@test xml 2</vh></v>
<v t="ekr.20120306173116.3933"><vh>@test xml non-ascii tags</vh></v>
</v>
</v>
<v t="ekr.20160410152100.1"><vh>Tests of @auto-md</vh>
<v t="ekr.20160410152100.2"><vh>@test md-import-test</vh>
<v t="ekr.20160411034540.1"><vh>&lt;&lt; define s &gt;&gt; (md-import-test)</vh></v>
<v t="ekr.20161202093709.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161202093709.2"><vh>!Declarations</vh>
<v t="ekr.20161202093709.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093709.4"><vh>Section 2</vh>
<v t="ekr.20161202093709.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093709.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093709.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093709.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034142.19"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204034142.20"><vh>Top</vh>
<v t="ekr.20161204034142.21"><vh>Section 1</vh></v>
<v t="ekr.20161204034142.22"><vh>Section 2</vh>
<v t="ekr.20161204034142.23"><vh>Section 2.1</vh>
<v t="ekr.20161204034142.24"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034142.25"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034142.26"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034207.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204034207.2"><vh>Top</vh>
<v t="ekr.20161204034207.3"><vh>Section 1</vh></v>
<v t="ekr.20161204034207.4"><vh>Section 2</vh>
<v t="ekr.20161204034207.5"><vh>Section 2.1</vh>
<v t="ekr.20161204034207.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034207.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034207.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204035451.19"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204035451.20"><vh>Top</vh>
<v t="ekr.20161204035451.21"><vh>Section 1</vh></v>
<v t="ekr.20161204035451.22"><vh>Section 2</vh>
<v t="ekr.20161204035451.23"><vh>Section 2.1</vh>
<v t="ekr.20161204035451.24"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204035451.25"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204035451.26"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041310.53"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041310.54"><vh>Top</vh>
<v t="ekr.20161204041310.55"><vh>Section 1</vh></v>
<v t="ekr.20161204041310.56"><vh>Section 2</vh>
<v t="ekr.20161204041310.57"><vh>Section 2.1</vh>
<v t="ekr.20161204041310.58"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041310.59"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041310.60"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041358.103"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041358.104"><vh>Top</vh>
<v t="ekr.20161204041358.105"><vh>Section 1</vh></v>
<v t="ekr.20161204041358.106"><vh>Section 2</vh>
<v t="ekr.20161204041358.107"><vh>Section 2.1</vh>
<v t="ekr.20161204041358.108"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041358.109"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041358.110"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041418.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041418.2"><vh>Top</vh>
<v t="ekr.20161204041418.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041418.4"><vh>Section 2</vh>
<v t="ekr.20161204041418.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041418.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041418.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041418.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041645.103"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041645.104"><vh>Top</vh>
<v t="ekr.20161204041645.105"><vh>Section 1</vh></v>
<v t="ekr.20161204041645.106"><vh>Section 2</vh>
<v t="ekr.20161204041645.107"><vh>Section 2.1</vh>
<v t="ekr.20161204041645.108"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041645.109"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041645.110"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041724.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041724.2"><vh>Top</vh>
<v t="ekr.20161204041724.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041724.4"><vh>Section 2</vh>
<v t="ekr.20161204041724.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041724.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041724.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041724.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041800.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041800.2"><vh>Top</vh>
<v t="ekr.20161204041800.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041800.4"><vh>Section 2</vh>
<v t="ekr.20161204041800.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041800.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041800.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041800.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042305.96"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204042305.97"><vh>Top</vh>
<v t="ekr.20161204042305.98"><vh>Section 1</vh></v>
<v t="ekr.20161204042305.99"><vh>Section 2</vh>
<v t="ekr.20161204042305.100"><vh>Section 2.1</vh>
<v t="ekr.20161204042305.101"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042305.102"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042305.103"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042719.4"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204042719.5"><vh>Top</vh>
<v t="ekr.20161204042719.6"><vh>Section 1</vh></v>
<v t="ekr.20161204042719.7"><vh>Section 2</vh>
<v t="ekr.20161204042719.8"><vh>Section 2.1</vh>
<v t="ekr.20161204042719.9"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042719.10"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042719.11"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042822.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204042822.2"><vh>Top</vh>
<v t="ekr.20161204042822.3"><vh>Section 1</vh></v>
<v t="ekr.20161204042822.4"><vh>Section 2</vh>
<v t="ekr.20161204042822.5"><vh>Section 2.1</vh>
<v t="ekr.20161204042822.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042822.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042822.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043017.19"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204043017.20"><vh>Top</vh>
<v t="ekr.20161204043017.21"><vh>Section 1</vh></v>
<v t="ekr.20161204043017.22"><vh>Section 2</vh>
<v t="ekr.20161204043017.23"><vh>Section 2.1</vh>
<v t="ekr.20161204043017.24"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043017.25"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043017.26"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043032.96"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204043032.97"><vh>Top</vh>
<v t="ekr.20161204043032.98"><vh>Section 1</vh></v>
<v t="ekr.20161204043032.99"><vh>Section 2</vh>
<v t="ekr.20161204043032.100"><vh>Section 2.1</vh>
<v t="ekr.20161204043032.101"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043032.102"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043032.103"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043346.4"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204043346.5"><vh>Top</vh>
<v t="ekr.20161204043346.6"><vh>Section 1</vh></v>
<v t="ekr.20161204043346.7"><vh>Section 2</vh>
<v t="ekr.20161204043346.8"><vh>Section 2.1</vh>
<v t="ekr.20161204043346.9"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043346.10"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043346.11"><vh>Section 3</vh></v>
</v>
</v>
</v>
<v t="ekr.20160411033840.1"><vh>@test md-import-test-rst-style</vh>
<v t="ekr.20161125230415.1"><vh>&lt;&lt; define s &gt;&gt; (md-import-test-rst-style)</vh></v>
<v t="ekr.20161202093319.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093319.2"><vh>Top</vh>
<v t="ekr.20161202093319.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093319.4"><vh>Section 2</vh>
<v t="ekr.20161202093319.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093319.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093319.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093319.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093322.9"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093322.10"><vh>Top</vh>
<v t="ekr.20161202093322.11"><vh>Section 1</vh></v>
<v t="ekr.20161202093322.12"><vh>Section 2</vh>
<v t="ekr.20161202093322.13"><vh>Section 2.1</vh>
<v t="ekr.20161202093322.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093322.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093322.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093409.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093409.2"><vh>Top</vh>
<v t="ekr.20161202093409.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093409.4"><vh>Section 2</vh>
<v t="ekr.20161202093409.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093409.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093409.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093409.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093410.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093410.2"><vh>Top</vh>
<v t="ekr.20161202093410.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093410.4"><vh>Section 2</vh>
<v t="ekr.20161202093410.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093410.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093410.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093410.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093509.22"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093509.23"><vh>Top</vh>
<v t="ekr.20161202093509.24"><vh>Section 1</vh></v>
<v t="ekr.20161202093509.25"><vh>Section 2</vh>
<v t="ekr.20161202093509.26"><vh>Section 2.1</vh>
<v t="ekr.20161202093509.27"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093509.28"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093509.29"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034142.27"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204034142.28"><vh>Top</vh>
<v t="ekr.20161204034142.29"><vh>Section 1</vh></v>
<v t="ekr.20161204034142.30"><vh>Section 2</vh>
<v t="ekr.20161204034142.31"><vh>Section 2.1</vh>
<v t="ekr.20161204034142.32"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034142.33"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034142.34"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034207.9"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204034207.10"><vh>Top</vh>
<v t="ekr.20161204034207.11"><vh>Section 1</vh></v>
<v t="ekr.20161204034207.12"><vh>Section 2</vh>
<v t="ekr.20161204034207.13"><vh>Section 2.1</vh>
<v t="ekr.20161204034207.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034207.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034207.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204035451.27"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204035451.28"><vh>Top</vh>
<v t="ekr.20161204035451.29"><vh>Section 1</vh></v>
<v t="ekr.20161204035451.30"><vh>Section 2</vh>
<v t="ekr.20161204035451.31"><vh>Section 2.1</vh>
<v t="ekr.20161204035451.32"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204035451.33"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204035451.34"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041310.61"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041310.62"><vh>Top</vh>
<v t="ekr.20161204041310.63"><vh>Section 1</vh></v>
<v t="ekr.20161204041310.64"><vh>Section 2</vh>
<v t="ekr.20161204041310.65"><vh>Section 2.1</vh>
<v t="ekr.20161204041310.66"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041310.67"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041310.68"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041359.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041359.2"><vh>Top</vh>
<v t="ekr.20161204041359.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041359.4"><vh>Section 2</vh>
<v t="ekr.20161204041359.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041359.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041359.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041359.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041418.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041418.10"><vh>Top</vh>
<v t="ekr.20161204041418.11"><vh>Section 1</vh></v>
<v t="ekr.20161204041418.12"><vh>Section 2</vh>
<v t="ekr.20161204041418.13"><vh>Section 2.1</vh>
<v t="ekr.20161204041418.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041418.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041418.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041646.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041646.2"><vh>Top</vh>
<v t="ekr.20161204041646.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041646.4"><vh>Section 2</vh>
<v t="ekr.20161204041646.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041646.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041646.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041646.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041724.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041724.10"><vh>Top</vh>
<v t="ekr.20161204041724.11"><vh>Section 1</vh></v>
<v t="ekr.20161204041724.12"><vh>Section 2</vh>
<v t="ekr.20161204041724.13"><vh>Section 2.1</vh>
<v t="ekr.20161204041724.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041724.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041724.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041800.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041800.10"><vh>Top</vh>
<v t="ekr.20161204041800.11"><vh>Section 1</vh></v>
<v t="ekr.20161204041800.12"><vh>Section 2</vh>
<v t="ekr.20161204041800.13"><vh>Section 2.1</vh>
<v t="ekr.20161204041800.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041800.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041800.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042305.104"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204042305.105"><vh>Top</vh>
<v t="ekr.20161204042305.106"><vh>Section 1</vh></v>
<v t="ekr.20161204042305.107"><vh>Section 2</vh>
<v t="ekr.20161204042305.108"><vh>Section 2.1</vh>
<v t="ekr.20161204042305.109"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042305.110"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042305.111"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042719.12"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204042719.13"><vh>Top</vh>
<v t="ekr.20161204042719.14"><vh>Section 1</vh></v>
<v t="ekr.20161204042719.15"><vh>Section 2</vh>
<v t="ekr.20161204042719.16"><vh>Section 2.1</vh>
<v t="ekr.20161204042719.17"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042719.18"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042719.19"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042822.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204042822.10"><vh>Top</vh>
<v t="ekr.20161204042822.11"><vh>Section 1</vh></v>
<v t="ekr.20161204042822.12"><vh>Section 2</vh>
<v t="ekr.20161204042822.13"><vh>Section 2.1</vh>
<v t="ekr.20161204042822.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042822.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042822.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043017.27"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204043017.28"><vh>Top</vh>
<v t="ekr.20161204043017.29"><vh>Section 1</vh></v>
<v t="ekr.20161204043017.30"><vh>Section 2</vh>
<v t="ekr.20161204043017.31"><vh>Section 2.1</vh>
<v t="ekr.20161204043017.32"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043017.33"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043017.34"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043032.104"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204043032.105"><vh>Top</vh>
<v t="ekr.20161204043032.106"><vh>Section 1</vh></v>
<v t="ekr.20161204043032.107"><vh>Section 2</vh>
<v t="ekr.20161204043032.108"><vh>Section 2.1</vh>
<v t="ekr.20161204043032.109"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043032.110"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043032.111"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043346.12"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204043346.13"><vh>Top</vh>
<v t="ekr.20161204043346.14"><vh>Section 1</vh></v>
<v t="ekr.20161204043346.15"><vh>Section 2</vh>
<v t="ekr.20161204043346.16"><vh>Section 2.1</vh>
<v t="ekr.20161204043346.17"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043346.18"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043346.19"><vh>Section 3</vh></v>
</v>
</v>
</v>
<v t="ekr.20161125134815.1"><vh>@test markdown importer-basic</vh></v>
<v t="ekr.20161126111517.1"><vh>@test markdown importer-implicit section</vh></v>
<v t="ekr.20161216141315.1"><vh>@test markdown importer-@@-section-name</vh></v>
<v t="ekr.20161127181028.1"><vh>@test markdown github syntax</vh></v>
</v>
<v t="ekr.20090529141856.4784"><vh>Tests of @auto-rst</vh>
<v t="ekr.20090529141856.4785"><vh>@test rST import test</vh></v>
<v t="ekr.20140725132959.4593"><vh>@test rST import test: simple</vh></v>
<v t="ekr.20090529141856.4786"><vh>@test rST import test: no double-underlines</vh></v>
<v t="ekr.20090529141856.4787"><vh>@test rST import test: long underlines</vh></v>
<v t="ekr.20090529141856.4788"><vh>@test rST import test: long overlines</vh></v>
<v t="ekr.20090529141856.4789"><vh>@test rST import test: trailing whitespace</vh></v>
<v t="ekr.20161129104243.1"><vh>@test leo_rst</vh></v>
</v>
<v t="ekr.20140724220921.5199"><vh>Tests of individual methods</vh>
<v t="ekr.20111214100515.3921"><vh>@@@test ic.createOutline: at-auto with lines that look like section references</vh></v>
<v t="ekr.20140206132559.4567"></v>
<v t="ekr.20150919074122.1"></v>
</v>
<v t="ekr.20161204041557.1"><vh>All other tests</vh>
<v t="ekr.20090529141856.4793"><vh>@@test test imports for modes</vh></v>
<v t="ekr.20140723134017.4464"><vh>@test @auto importers</vh></v>
<v t="ekr.20161109065940.1"><vh>@test Importer.get_leading_indent</vh></v>
<v t="ekr.20161117011147.1"><vh>@test Importer.get_str_lws</vh></v>
<v t="ekr.20161109065949.1"><vh>@test Importer.is_ws_line</vh></v>
<v t="ekr.20161011052016.1"><vh>@test importers.javascript.scan_line</vh></v>
<v t="ekr.20170407065952.1"><vh>@test importers.javascript.op_pattern</vh></v>
</v>
<v t="ekr.20140724164600.4590"></v>
</v>
<v t="ekr.20100131171342.5604"><vh>leoKeys</vh>
<v t="ekr.20100131171342.5606"><vh>@@test k.autoCompleterClass.calltip</vh></v>
<v t="ekr.20110509104953.3474"><vh>@test k.get_leo_completions</vh></v>
<v t="ekr.20111121224307.3934"></v>
<v t="ekr.20100131171342.5605"><vh>@test k.isPlainKey</vh></v>
<v t="ekr.20100212110954.5359"><vh>@test k.print-bindings</vh></v>
<v t="ekr.20100131171342.5607"><vh>@test k.registerCommand</vh></v>
<v t="ekr.20100131171342.5608"><vh>@test k.strokeFromSetting</vh></v>
<v t="ekr.20100131171342.5609"></v>
</v>
<v t="ekr.20071113194424.1"><vh>@ignore leoNodes  (5 failures, 3 errors)</vh>
<v t="ekr.20040712101754.181"><vh> inner @test: Test consistency between parents iter and v.parents</vh>
<v t="ekr.20040712101754.182"><vh>parent</vh>
<v t="ekr.20040712101754.183"><vh>@test consistency between parents_iter and v.parents</vh></v>
</v>
</v>
<v t="ville.20090312195309.2"><vh>@@@test find_h / find_b / filter_h / filter_b</vh></v>
<v t="ekr.20080310073711.1"><vh>@@@test nodeIndices.toString(None) allocates a new index</vh></v>
<v t="ekr.20040712101754.175"><vh>@@test p.t == p.v</vh></v>
<v t="ekr.20040712101754.200"><vh>@@test that clones share subtrees</vh></v>
<v t="ekr.20070611071101"><vh>@@test visback</vh>
<v t="ekr.20070611071101.1"><vh>a</vh>
<v t="ekr.20070611071101.2"><vh>b</vh>
<v t="ekr.20070611071101.3"><vh>c2</vh></v>
</v>
</v>
<v t="ekr.20070611071101.4"><vh>limit</vh>
<v t="ekr.20070611071101.5"><vh>d</vh></v>
</v>
<v t="ekr.20070611071954"><vh>e</vh></v>
</v>
<v t="ekr.20161002020559.1"></v>
<v t="ekr.20040712101754.99"><vh>@test c iters</vh>
<v t="ekr.20040712101754.100"><vh>&lt;&lt; coverage tests &gt;&gt;</vh></v>
<v t="ekr.20040712101754.101"><vh>&lt;&lt; duplicate tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20090102061858.2"><vh>@test c.positionExists</vh>
<v t="ekr.20120212130242.4704"><vh>newHeadline</vh></v>
</v>
<v t="ekr.20090102062037.2"><vh>@test c.positionExists for all nodes</vh></v>
<v t="ekr.20150317093233.11"><vh>@test c.safe_all_positions</vh></v>
<v t="ekr.20141022175515.11"><vh>@test check all gnx's exist and are unique</vh></v>
<v t="ekr.20040712101754.204"><vh>@test consistency of back/next links</vh></v>
<v t="ekr.20040712101754.201"><vh>@test consistency of c.all_positions() and p.ThreadNext()</vh></v>
<v t="ekr.20040712101754.202"><vh>@test consistency of firstChild &amp; children_iter()</vh></v>
<v t="ekr.20040712101754.203"><vh>@test consistency of level</vh></v>
<v t="ekr.20040712101754.205"><vh>@test consistency of parent &amp; parents_iter()</vh></v>
<v t="ekr.20040712101754.206"><vh>@test consistency of parent/child links</vh></v>
<v t="ekr.20040712101754.207"><vh>@test consistency of threadBack/Next links</vh></v>
<v t="ekr.20040712101754.177"><vh>@test convertTreeToString and allies</vh>
<v t="ekr.20040712101754.178"><vh>File Conversion</vh>
<v t="ekr.20040712101754.179"><vh>moreHead</vh></v>
<v t="ekr.20040712101754.180"><vh>moreBody</vh></v>
</v>
</v>
<v t="ekr.20090130133404.2"><vh>@test leoNodes properties</vh></v>
<v t="ekr.20130524112342.4137"><vh>@test new vnodes methods</vh>
<v t="ekr.20170520193221.1"><vh>insertAsFirstChild</vh></v>
<v t="ekr.20170520193221.3"><vh>insertAsNthChild(1)</vh></v>
<v t="ekr.20170520193221.2"><vh>insertAsLastChild</vh></v>
</v>
<v t="ekr.20141020110954.4750"><vh>@test newlines in headlines</vh></v>
<v t="ekr.20041013062906"><vh>@test onHyperLinkControlClick</vh></v>
<v t="ekr.20160123044102.1"><vh>@test p.__eq__</vh></v>
<v t="ekr.20131220083358.3982"><vh>@test p._relinkAsCloneOf</vh>
<v t="ekr.20131220083358.3983"><vh>a</vh></v>
<v t="ekr.20131220083358.3984"><vh>b</vh></v>
</v>
<v t="ekr.20100131180007.5369"><vh>@test p.adjustPositionBeforeUnlink</vh>
<v t="ekr.20100131180007.5370"><vh>node 1</vh>
<v t="ekr.20100131180007.5371"><vh>node 1-1</vh>
<v t="ekr.20100131180007.5372"><vh>node 1-1-1</vh></v>
<v t="ekr.20100131180007.5373"><vh>node 1-1-2</vh></v>
</v>
<v t="ekr.20100131180007.5374"><vh>node 1-2</vh>
<v t="ekr.20100131180007.5375"><vh>node 1-2-1</vh></v>
<v t="ekr.20100131180007.5376"><vh>node 1-2-2</vh></v>
</v>
</v>
<v t="ekr.20100131180007.5377"><vh>node 2</vh>
<v t="ekr.20100131180007.5378"><vh>node 2-1</vh>
<v t="ekr.20100131180007.5379"><vh>node 2-1-1</vh></v>
<v t="ekr.20100131180007.5380"><vh>node 2-1-2</vh></v>
</v>
<v t="ekr.20100131180007.5381"><vh>node 2-2</vh>
<v t="ekr.20100131180007.5382"><vh>node 2-2-1</vh></v>
<v t="ekr.20100131180007.5383"><vh>node 2-2-2</vh></v>
</v>
</v>
<v t="ekr.20100131180007.5384"><vh>node 3</vh>
<v t="ekr.20100131180007.5385"><vh>node 3-1</vh>
<v t="ekr.20100131180007.5386"><vh>node 3-1-1</vh></v>
<v t="ekr.20100131180007.5387"><vh>node 3-1-2</vh></v>
</v>
<v t="ekr.20100131180007.5388"><vh>node 3-2</vh>
<v t="ekr.20100131180007.5389"><vh>node 3-2-1</vh></v>
<v t="ekr.20100131180007.5390"><vh>node 3-2-2</vh></v>
</v>
</v>
</v>
<v t="ekr.20040712101754.199"><vh>@test p.comparisons</vh></v>
<v t="ekr.20130703132516.4188"><vh>@test p.deletePositionsInList</vh></v>
<v t="ekr.20040712101754.209"><vh>@test p.hasNextBack</vh></v>
<v t="ekr.20040712101754.210"><vh>@test p.hasParentChild</vh></v>
<v t="ekr.20040712101754.211"><vh>@test p.hasThreadNextBack</vh></v>
<v t="ekr.20040722055040"><vh>@test p.isAncestorOf</vh></v>
<v t="ekr.20060106211922"><vh>@test p.isCurrentPosition</vh></v>
<v t="ekr.20060106211922.1"><vh>@test p.isRootPosition</vh></v>
<v t="ekr.20040712101754.188"></v>
<v t="ekr.20111210104652.3958"><vh>@test p.moveToFirst/LastChild</vh>
<v t="ekr.20111210104652.3959"><vh>child</vh></v>
<v t="ekr.20120212130242.4755"><vh>test</vh></v>
</v>
<v t="ekr.20131227150324.3983"><vh>@test p.moveToVisBack in a chapter</vh></v>
<v t="ekr.20140218045755.4348"><vh>@test p.nosentinels</vh></v>
<v t="ekr.20040802071519"><vh>@test p.setBodyString</vh>
<v t="ekr.20040802071519.1"><vh>child</vh></v>
</v>
<v t="ekr.20160129082128.1"><vh>@test p.u</vh></v>
<v t="ekr.20110502130500.3471"><vh>@test p.unique_nodes</vh>
<v t="ekr.20110502130500.3472"><vh>node 1</vh>
<v t="ekr.20110502130500.3473"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20100131180007.5391"><vh>@test v.atAutoNodeName &amp; v.atAutoRstNodeName</vh></v>
<v t="ekr.20060913084600"><vh>@test v/t.__hash__</vh></v>
<v t="ekr.20071113202452"></v>
<v t="ekr.20080501121449.1"><vh>Fundamental node operations (undo operations fail)</vh>
<v t="ekr.20080423110627.2"><vh>@test at most one VNode has str_leo_pos attribute</vh></v>
<v t="ekr.20080423110627.3"><vh>@test clone and move the clone to the root</vh></v>
<v t="ekr.20080503082625.3"><vh>@test delete node</vh></v>
<v t="ekr.20080423110627.13"><vh>@test deleting the root should select another node</vh></v>
<v t="ekr.20080503082625.5"><vh>@test demote</vh>
<v t="ekr.20170520193223.7"><vh>C</vh></v>
<v t="ekr.20170520193223.8"><vh>D</vh></v>
<v t="ekr.20170520193223.7"></v>
<v t="ekr.20170520193223.8"></v>
<v t="ekr.20170520193223.7"></v>
<v t="ekr.20170520193223.8"></v>
</v>
<v t="ekr.20080501121449.3"><vh>@test insert node</vh>
<v t="ekr.20170520193223.9"><vh>A</vh></v>
<v t="ekr.20170520193223.10"><vh>B</vh></v>
</v>
<v t="ekr.20080423110627.11"><vh>@test move-outline-down &amp; undo/redo</vh></v>
<v t="ekr.20080503073030.1"><vh>@test move-outline-left</vh></v>
<v t="ekr.20170520193223.16"><vh>A</vh></v>
<v t="ekr.20080503073030.2"><vh>@test move-outline-right</vh></v>
<v t="ekr.20080423110627.12"><vh>@test move-outline-up</vh></v>
<v t="ekr.20080423110627.5"><vh>@test paste-node</vh></v>
<v t="ekr.20080423110627.8"><vh>@test paste-retaining-clones</vh></v>
<v t="ekr.20080503082625.4"><vh>@test promote</vh></v>
</v>
<v t="ekr.20081001094920.2"><vh>tests for p.textOffset()</vh>
<v t="ekr.20081001094920.3"><vh>@test node that doesn't belong to a derived file</vh></v>
<v t="ekr.20081001094920.4"><vh>@test root of a derived file</vh></v>
<v t="ekr.20081001094920.5"><vh>@test organizer node</vh></v>
<v t="ekr.20081001094920.6"><vh>@test section node</vh></v>
<v t="ekr.20081001094920.7"><vh>@test "others" directive</vh></v>
</v>
</v>
<v t="ekr.20140712142620.4458"><vh>leoPersistence tests (do not clone)</vh>
<v t="ekr.20140712142620.4537"><vh>@@@test pd.find_absolute_unl_node</vh></v>
<v t="ekr.20140712142620.4583"><vh>@@@test pd.pack &amp; pd.unpack</vh>
<v t="ekr.20140712142620.4587"><vh>clone</vh></v>
<v t="ekr.20140712142620.4585"><vh>@view test</vh>
<v t="ekr.20140712142620.4586"><vh>not a clone</vh></v>
<v t="ekr.20140712142620.4587"></v>
</v>
</v>
<v t="ekr.20140712142620.4503"><vh>@test p.sort_key</vh></v>
<v t="ekr.20140712142620.4550"><vh>@test pd.find_at_...</vh>
<v t="ekr.20140712142620.4551"><vh>root</vh>
<v t="ekr.20140712142620.4552"><vh>aClass</vh>
<v t="ekr.20140712142620.4556"><vh>clone</vh></v>
</v>
</v>
<v t="ekr.20140712142620.4556"></v>
</v>
<v t="ekr.20140712142620.4538"><vh>@test pd.find_at_persistence_node</vh></v>
<v t="ekr.20140712142620.4539"><vh>@test pd.find_position_for_relative_unl</vh>
<v t="ekr.20140712142620.4540"><vh>node1</vh>
<v t="ekr.20140712142620.4541"><vh>child11</vh></v>
<v t="ekr.20140712142620.4542"><vh>child12</vh></v>
</v>
<v t="ekr.20140712142620.4543"><vh>node2</vh>
<v t="ekr.20140712142620.4544"><vh>child21</vh></v>
<v t="ekr.20140712142620.4545"><vh>child22</vh></v>
</v>
<v t="ekr.20140715080507.4340"><vh>node3</vh>
<v t="ekr.20140715080507.4341"><vh>node3_child1</vh>
<v t="ekr.20140715080507.4339"><vh>child21</vh></v>
</v>
</v>
</v>
<v t="ekr.20140712142620.4546"><vh>@test pd.find_representative_node</vh>
<v t="ekr.20140712142620.4547"><vh>root</vh>
<v t="ekr.20140712142620.4549"><vh>clone</vh></v>
</v>
<v t="ekr.20140712142620.4549"></v>
</v>
<v t="ekr.20140712142620.4557"><vh>@test pd.has_..._node</vh>
<v t="ekr.20140712142620.4558"><vh>root</vh>
<v t="ekr.20140712142620.4559"><vh>aClass</vh>
<v t="ekr.20140712142620.4563"><vh>clone-test</vh></v>
<v t="ekr.20140712142620.4561"><vh>organizer node</vh>
<v t="ekr.20140712142620.4562"><vh>child2</vh></v>
</v>
</v>
</v>
<v t="ekr.20140712142620.4563"></v>
</v>
<v t="ekr.20170302110925.1"><vh>@@test pd.prepass</vh></v>
<v t="ekr.20140716115306.4345"><vh>@@test pd.recovery_ua_for_gnx</vh></v>
<v t="ekr.20140712142620.4507"><vh>@test pd.restore_gnxs</vh>
<v t="ekr.20140712142620.4508"><vh>@gnxs</vh></v>
<v t="ekr.20140923080452.6565"><vh>node1</vh></v>
<v t="ekr.20140712142620.4510"><vh>root</vh>
<v t="ekr.20140923080452.6565"></v>
</v>
</v>
<v t="ekr.20140712142620.4574"><vh>@test pd.unl</vh></v>
<v t="ekr.20140712142620.4575"><vh>@test pd.update_before_write_foreign_file</vh>
<v t="ekr.20140712142620.4576"><vh>root</vh>
<v t="ekr.20140712142620.4577"><vh>aClass</vh>
<v t="ekr.20140712142620.4582"><vh>clone</vh></v>
</v>
<v t="ekr.20140712142620.4579"><vh>organizer node</vh>
<v t="ekr.20140712142620.4580"><vh>child1</vh></v>
<v t="ekr.20140712142620.4581"><vh>child2</vh></v>
</v>
</v>
<v t="ekr.20140712142620.4582"></v>
</v>
<v t="ekr.20150216111306.25"><vh>@test delete all children of @persistence node</vh></v>
</v>
<v t="ekr.20100131171342.5610"><vh>leoPlugins</vh>
<v t="ekr.20100131171342.5611"><vh>@test getHandlersForTag</vh></v>
<v t="ekr.20100909082308.5990"><vh>@test regularizeName</vh></v>
</v>
<v t="ekr.20091219122958.5066"><vh>leoRst</vh>
<v t="ekr.20100813100841.5825"><vh>@@@test show_doc_parts_in_rst_mode</vh></v>
<v t="ekr.20100813100841.5847"><vh>@ignore</vh>
<v t="ekr.20100812213445.5824"><vh>@test code_mode: rst3 show_doc_parts_as_paragraphs</vh>
<v t="ekr.20100812213445.5825"><vh>source</vh>
<v t="ekr.20100812213445.5826"><vh>@rst test.html</vh>
<v t="ekr.20100812213445.5827"><vh>section</vh></v>
</v>
</v>
<v t="ekr.20100812213445.5828"><vh>expected</vh>
<v t="ekr.20100813100841.5843"><vh>rst</vh></v>
<v t="ekr.20100813100841.5844"><vh> html</vh></v>
</v>
</v>
<v t="ekr.20100813100841.5827"><vh>@test code_mode: show_leo_directives</vh></v>
<v t="ekr.20100813100841.5828"><vh>@test code_mode: show_markup_doc_parts</vh></v>
<v t="ekr.20100813100841.5829"><vh>@test code_mode: show_options_doc_parts</vh></v>
</v>
<v t="ekr.20091219121039.5065"><vh>@test c.rstCommands.handleMissingStyleSheetArgs</vh></v>
<v t="ekr.20111103213154.3823"><vh>@test c.rstCommands.writeToDocutils: pdf</vh></v>
<v t="ekr.20100131180007.5459"><vh>@test rst.initAtAutoWrite</vh></v>
<v t="ekr.20100813100841.5850"><vh>@test rst3Test @no-head</vh>
<v t="ekr.20100813100841.5854"><vh>source</vh>
<v t="ekr.20100813100841.5855"><vh>@rst test.html</vh>
<v t="ekr.20100813100841.5856"><vh>@rst-no-head section</vh></v>
</v>
</v>
<v t="ekr.20100813100841.5857"><vh>expected</vh>
<v t="ekr.20100813100841.5858"><vh>rst</vh></v>
<v t="ekr.20100813100841.5859"><vh>html</vh></v>
</v>
<v t="ekr.20100827182529.6843"><vh>got</vh>
<v t="ekr.20100827182529.6844"><vh>rst</vh></v>
<v t="ekr.20100827182529.6845"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20100812172232.5801"><vh>@test rst3Test default</vh>
<v t="ekr.20100812182942.5805"><vh>source</vh>
<v t="ekr.20100812182942.5807"><vh>@rst test.html</vh>
<v t="ekr.20100812182942.5808"><vh>section</vh></v>
</v>
</v>
<v t="ekr.20100812213445.5814"><vh>expected</vh>
<v t="ekr.20100813100841.5848"><vh>rst</vh></v>
<v t="ekr.20100813100841.5849"><vh> html</vh></v>
</v>
<v t="ekr.20100827182529.6840"><vh>got</vh>
<v t="ekr.20100827182529.6841"><vh>rst</vh></v>
<v t="ekr.20100827182529.6842"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20100813100841.5824"><vh>@test rst3Test doc_only_mode (set in headline)</vh>
<v t="ekr.20100813100841.5839"><vh>source</vh>
<v t="ekr.20100813100841.5840"><vh>@rst test.html</vh>
<v t="ekr.20100813124317.5868"><vh>@rst-option doc_only_mode=True</vh>
<v t="ekr.20100813100841.5841"><vh>section</vh></v>
</v>
</v>
</v>
<v t="ekr.20100813100841.5842"><vh>expected</vh>
<v t="ekr.20100813124317.5869"><vh>rst</vh></v>
<v t="ekr.20100813124317.5870"><vh> html</vh></v>
</v>
<v t="ekr.20100827182529.6846"><vh>got</vh>
<v t="ekr.20100827182529.6847"><vh>rst</vh></v>
<v t="ekr.20100827182529.6848"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20100813124317.5879"><vh>@test rst3Test doc_only_mode (set in options doc part)</vh>
<v t="ekr.20100813124317.5880"><vh>source</vh>
<v t="ekr.20100813124317.5881"><vh>@rst test.html</vh>
<v t="ekr.20100813124317.5883"><vh>section</vh></v>
</v>
</v>
<v t="ekr.20100813124317.5884"><vh>expected</vh>
<v t="ekr.20100813124317.5889"><vh>rst</vh></v>
<v t="ekr.20100813124317.5890"><vh> html</vh></v>
</v>
<v t="ekr.20100827182529.6849"><vh>got</vh>
<v t="ekr.20100827182529.6850"><vh>rst</vh></v>
<v t="ekr.20100827182529.6851"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20100827140832.5913"><vh>@test rst3Test show_leo_directives=False</vh>
<v t="ekr.20100827140832.5917"><vh>source</vh>
<v t="ekr.20100827140832.5918"><vh>@rst test.html</vh>
<v t="ekr.20100827140832.5919"><vh>section</vh></v>
</v>
</v>
<v t="ekr.20100827140832.5926"><vh>expected</vh>
<v t="ekr.20100827140832.5929"><vh>rst</vh></v>
<v t="ekr.20100827140832.5930"><vh>html</vh></v>
</v>
<v t="ekr.20100827182529.6852"><vh>got</vh>
<v t="ekr.20100827182529.6853"><vh>rst</vh></v>
<v t="ekr.20100827182529.6854"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20120307070541.3937"><vh>@test rst3Test unicode characters</vh>
<v t="ekr.20120307070541.3941"><vh>source</vh>
<v t="ekr.20120307070541.3942"><vh>@rst test.html</vh></v>
</v>
<v t="ekr.20120307070541.3944"><vh>expected</vh>
<v t="ekr.20120307070541.3946"><vh>rst</vh></v>
<v t="ekr.20120307070541.3947"><vh>html</vh></v>
</v>
<v t="ekr.20120307070541.3945"><vh>got</vh>
<v t="ekr.20120307070541.3948"><vh>rst</vh></v>
<v t="ekr.20120307070541.3949"><vh>html</vh></v>
</v>
</v>
</v>
<v t="ekr.20090529115704.4396"><vh>leoShadow</vh>
<v t="ekr.20090529115704.4560"><vh>@@test (minitest) x.show_error</vh></v>
<v t="ekr.20090529115704.4397"><vh>@suite run @shadow-test nodes in the @shadow-tests tree</vh>
<v t="ekr.20090529115704.4398"><vh>@shadow-tests</vh>
<v t="ekr.20101023195640.6033"><vh>@shadow-test replace in node new &gt; old</vh>
<v t="ekr.20101023195640.6034"><vh>old</vh>
<v t="ekr.20101023195640.6035"><vh>node 1</vh></v>
</v>
<v t="ekr.20101023195640.6037"><vh>new</vh>
<v t="ekr.20101023195640.6038"><vh>node 1</vh></v>
</v>
</v>
<v t="ekr.20101023204543.6042"><vh>@shadow-test replace in node new &lt; old</vh>
<v t="ekr.20101023204543.6043"><vh>old</vh>
<v t="ekr.20101023204543.6044"><vh>node 1</vh></v>
</v>
<v t="ekr.20101023204543.6045"><vh>new</vh>
<v t="ekr.20101023204543.6046"><vh>node 1</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4400"><vh>@shadow-test change middle line</vh>
<v t="ekr.20090529115704.4401"><vh>old</vh></v>
<v t="ekr.20090529115704.4402"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4403"><vh>@shadow-test change first line</vh>
<v t="ekr.20090529115704.4404"><vh>old</vh></v>
<v t="ekr.20090529115704.4405"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4406"><vh>@shadow-test change last line</vh>
<v t="ekr.20090529115704.4407"><vh>old</vh></v>
<v t="ekr.20090529115704.4408"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4409"><vh>@shadow-test delete first line</vh>
<v t="ekr.20090529115704.4410"><vh>old</vh></v>
<v t="ekr.20090529115704.4411"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4412"><vh>@shadow-test delete middle line</vh>
<v t="ekr.20090529115704.4413"><vh>old</vh></v>
<v t="ekr.20090529115704.4414"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4415"><vh>@shadow-test delete last line</vh>
<v t="ekr.20090529115704.4416"><vh>old</vh></v>
<v t="ekr.20090529115704.4417"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4418"><vh>@shadow-test insert before first line</vh>
<v t="ekr.20090529115704.4419"><vh>old</vh></v>
<v t="ekr.20090529115704.4420"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4421"><vh>@shadow-test insert middle line (after first line)</vh>
<v t="ekr.20090529115704.4422"><vh>old</vh></v>
<v t="ekr.20090529115704.4423"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4424"><vh>@shadow-test insert middle line (before last line)</vh>
<v t="ekr.20090529115704.4425"><vh>old</vh></v>
<v t="ekr.20090529115704.4426"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4427"><vh>@shadow-test insert after last line</vh>
<v t="ekr.20090529115704.4428"><vh>old</vh></v>
<v t="ekr.20090529115704.4429"><vh>new</vh></v>
</v>
<v t="ekr.20090529115704.4430"><vh>@shadow-test-lax insert between nodes: at end of prev node</vh>
<v t="ekr.20090529115704.4431"><vh>old</vh>
<v t="ekr.20090529115704.4432"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4433"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4434"><vh>new</vh>
<v t="ekr.20090529115704.4435"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4436"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4444"><vh>@shadow-test delete between nodes: at end of prev node</vh>
<v t="ekr.20090529115704.4445"><vh>old</vh>
<v t="ekr.20090529115704.4446"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4447"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4448"><vh>new</vh>
<v t="ekr.20090529115704.4449"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4450"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4451"><vh>@shadow-test delete between nodes: at start of next node</vh>
<v t="ekr.20090529115704.4452"><vh>old</vh>
<v t="ekr.20090529115704.4453"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4454"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4455"><vh>new</vh>
<v t="ekr.20090529115704.4456"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4457"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4458"><vh>@shadow-test change end of prev node</vh>
<v t="ekr.20090529115704.4459"><vh>old</vh>
<v t="ekr.20090529115704.4460"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4461"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4462"><vh>new</vh>
<v t="ekr.20090529115704.4463"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4464"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4465"><vh>@shadow-test change start of next node</vh>
<v t="ekr.20090529115704.4466"><vh>old</vh>
<v t="ekr.20090529115704.4467"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4468"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4469"><vh>new</vh>
<v t="ekr.20090529115704.4470"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4471"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4472"><vh>@shadow-test-lax multiple-line insert between nodes: at end of prev node</vh>
<v t="ekr.20090529115704.4473"><vh>old</vh>
<v t="ekr.20090529115704.4474"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4475"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4476"><vh>new</vh>
<v t="ekr.20090529115704.4477"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4478"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4486"><vh>@shadow-test multiple-line change end of prev node</vh>
<v t="ekr.20090529115704.4487"><vh>old</vh>
<v t="ekr.20090529115704.4488"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4489"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4490"><vh>new</vh>
<v t="ekr.20090529115704.4491"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4492"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4493"><vh>@shadow-test multiple-line change start of next node</vh>
<v t="ekr.20090529115704.4494"><vh>old</vh>
<v t="ekr.20090529115704.4495"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4496"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4497"><vh>new</vh>
<v t="ekr.20090529115704.4498"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4499"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20100107110353.5105"><vh>@shadow-test multiple-NODE changes</vh>
<v t="ekr.20100107110353.5106"><vh>old</vh>
<v t="ekr.20100107110353.5107"><vh>node 1</vh></v>
<v t="ekr.20100107110353.5108"><vh>node 2</vh></v>
</v>
<v t="ekr.20100107110353.5109"><vh>new</vh>
<v t="ekr.20100107110353.5110"><vh>node 1</vh></v>
<v t="ekr.20100107110353.5111"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4500"><vh>@shadow-test multiple-line delete between nodes: at end of prev node</vh>
<v t="ekr.20090529115704.4501"><vh>old</vh>
<v t="ekr.20090529115704.4502"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4503"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4504"><vh>new</vh>
<v t="ekr.20090529115704.4505"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4506"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4507"><vh>@shadow-test multiple-line delete between nodes: at start of next node</vh>
<v t="ekr.20090529115704.4508"><vh>old</vh>
<v t="ekr.20090529115704.4509"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4510"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4511"><vh>new</vh>
<v t="ekr.20090529115704.4512"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4513"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4514"><vh>@shadow-test verbatim sentinels-delete verbatim line</vh>
<v t="ekr.20090529115704.4515"><vh>old</vh>
<v t="ekr.20090529115704.4516"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4517"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4518"><vh>new</vh>
<v t="ekr.20090529115704.4519"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4520"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4521"><vh>@shadow-test verbatim sentinels-delete verbatim line: at start of node</vh>
<v t="ekr.20090529115704.4522"><vh>old</vh>
<v t="ekr.20090529115704.4523"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4524"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4525"><vh>new</vh>
<v t="ekr.20090529115704.4526"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4527"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4528"><vh>@shadow-test verbatim sentinels-no change</vh>
<v t="ekr.20090529115704.4529"><vh>old</vh>
<v t="ekr.20090529115704.4530"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4531"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4532"><vh>new</vh>
<v t="ekr.20090529115704.4533"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4534"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4535"><vh>@shadow-test verbatim sentinels-delete verbatim line: at end of node</vh>
<v t="ekr.20090529115704.4536"><vh>old</vh>
<v t="ekr.20090529115704.4537"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4538"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4539"><vh>new</vh>
<v t="ekr.20090529115704.4540"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4541"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20090529115704.4542"><vh>@shadow-test verbatim sentinels-add verbatim line</vh>
<v t="ekr.20090529115704.4543"><vh>old</vh>
<v t="ekr.20090529115704.4544"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4545"><vh>node 2</vh></v>
</v>
<v t="ekr.20090529115704.4546"><vh>new</vh>
<v t="ekr.20090529115704.4547"><vh>node 1</vh></v>
<v t="ekr.20090529115704.4548"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150210195923.11"><vh>@shadow-test no change, no ending newline</vh>
<v t="ekr.20150210195923.12"><vh>old</vh></v>
<v t="ekr.20150210195923.15"><vh>new</vh></v>
</v>
</v>
</v>
<v t="ekr.20150216070628.11"><vh>@@suite @nosent with javascript</vh>
<v t="ekr.20150216070628.12"><vh>@shadow-tests</vh>
<v t="ekr.20150216070628.168"><vh>@shadow-test equal @nosent @doc</vh>
<v t="ekr.20150216070628.14"><vh>old</vh>
<v t="ekr.20150216070628.15"><vh>node 1</vh></v>
</v>
<v t="ekr.20150216070628.16"><vh>new</vh>
<v t="ekr.20150216070628.17"><vh>node 1</vh></v>
</v>
</v>
<v t="ekr.20150216070628.18"><vh>@shadow-test replace in node new &lt; old</vh>
<v t="ekr.20150216070628.19"><vh>old</vh>
<v t="ekr.20150216070628.20"><vh>node 1</vh></v>
</v>
<v t="ekr.20150216070628.21"><vh>new</vh>
<v t="ekr.20150216070628.22"><vh>node 1</vh></v>
</v>
</v>
<v t="ekr.20150216070628.23"><vh>@shadow-test change middle line</vh>
<v t="ekr.20150216070628.24"><vh>old</vh></v>
<v t="ekr.20150216070628.25"><vh>new</vh></v>
</v>
<v t="ekr.20150216070628.26"><vh>@shadow-test change first line</vh>
<v t="ekr.20150216070628.27"><vh>old</vh></v>
<v t="ekr.20150216070628.28"><vh>new</vh></v>
</v>
<v t="ekr.20150216070628.29"><vh>@shadow-test change last line</vh>
<v t="ekr.20150216070628.30"><vh>old</vh></v>
<v t="ekr.20150216070628.31"><vh>new</vh></v>
</v>
<v t="ekr.20150216070628.32"><vh>@shadow-test delete first line</vh>
<v t="ekr.20150216070628.33"><vh>old</vh></v>
<v t="ekr.20150216070628.34"><vh>new</vh></v>
</v>
<v t="ekr.20150216070628.35"><vh>@shadow-test delete middle line</vh>
<v t="ekr.20150216070628.36"><vh>old</vh></v>
<v t="ekr.20150216070628.37"><vh>new</vh></v>
</v>
<v t="ekr.20150216070628.38"><vh>@shadow-test delete last line</vh>
<v t="ekr.20150216070628.39"><vh>old</vh></v>
<v t="ekr.20150216070628.40"><vh>new</vh></v>
</v>
<v t="ekr.20150216070628.41"><vh>@shadow-test insert before first line</vh>
<v t="ekr.20150216070628.42"><vh>old</vh></v>
<v t="ekr.20150216070628.43"><vh>new</vh></v>
</v>
<v t="ekr.20150216070628.44"><vh>@shadow-test insert middle line (after first line)</vh>
<v t="ekr.20150216070628.45"><vh>old</vh></v>
<v t="ekr.20150216070628.46"><vh>new</vh></v>
</v>
<v t="ekr.20150216070628.47"><vh>@shadow-test insert middle line (before last line)</vh>
<v t="ekr.20150216070628.48"><vh>old</vh></v>
<v t="ekr.20150216070628.49"><vh>new</vh></v>
</v>
<v t="ekr.20150216070628.50"><vh>@shadow-test insert after last line</vh>
<v t="ekr.20150216070628.51"><vh>old</vh></v>
<v t="ekr.20150216070628.52"><vh>new</vh></v>
</v>
<v t="ekr.20150216070628.53"><vh>@shadow-test-lax insert between nodes: at end of prev node</vh>
<v t="ekr.20150216070628.54"><vh>old</vh>
<v t="ekr.20150216070628.55"><vh>node 1</vh></v>
<v t="ekr.20150216070628.56"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.57"><vh>new</vh>
<v t="ekr.20150216070628.58"><vh>node 1</vh></v>
<v t="ekr.20150216070628.59"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.60"><vh>@shadow-test delete between nodes: at end of prev node</vh>
<v t="ekr.20150216070628.61"><vh>old</vh>
<v t="ekr.20150216070628.62"><vh>node 1</vh></v>
<v t="ekr.20150216070628.63"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.64"><vh>new</vh>
<v t="ekr.20150216070628.65"><vh>node 1</vh></v>
<v t="ekr.20150216070628.66"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.67"><vh>@shadow-test delete between nodes: at start of next node</vh>
<v t="ekr.20150216070628.68"><vh>old</vh>
<v t="ekr.20150216070628.69"><vh>node 1</vh></v>
<v t="ekr.20150216070628.70"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.71"><vh>new</vh>
<v t="ekr.20150216070628.72"><vh>node 1</vh></v>
<v t="ekr.20150216070628.73"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.74"><vh>@shadow-test change end of prev node</vh>
<v t="ekr.20150216070628.75"><vh>old</vh>
<v t="ekr.20150216070628.76"><vh>node 1</vh></v>
<v t="ekr.20150216070628.77"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.78"><vh>new</vh>
<v t="ekr.20150216070628.79"><vh>node 1</vh></v>
<v t="ekr.20150216070628.80"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.81"><vh>@shadow-test change start of next node</vh>
<v t="ekr.20150216070628.82"><vh>old</vh>
<v t="ekr.20150216070628.83"><vh>node 1</vh></v>
<v t="ekr.20150216070628.84"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.85"><vh>new</vh>
<v t="ekr.20150216070628.86"><vh>node 1</vh></v>
<v t="ekr.20150216070628.87"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.88"><vh>@shadow-test-lax multiple-line insert between nodes: at end of prev node</vh>
<v t="ekr.20150216070628.89"><vh>old</vh>
<v t="ekr.20150216070628.90"><vh>node 1</vh></v>
<v t="ekr.20150216070628.91"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.92"><vh>new</vh>
<v t="ekr.20150216070628.93"><vh>node 1</vh></v>
<v t="ekr.20150216070628.94"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.95"><vh>@shadow-test multiple-line change end of prev node</vh>
<v t="ekr.20150216070628.96"><vh>old</vh>
<v t="ekr.20150216070628.97"><vh>node 1</vh></v>
<v t="ekr.20150216070628.98"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.99"><vh>new</vh>
<v t="ekr.20150216070628.100"><vh>node 1</vh></v>
<v t="ekr.20150216070628.101"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.102"><vh>@shadow-test multiple-line change start of next node</vh>
<v t="ekr.20150216070628.103"><vh>old</vh>
<v t="ekr.20150216070628.104"><vh>node 1</vh></v>
<v t="ekr.20150216070628.105"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.106"><vh>new</vh>
<v t="ekr.20150216070628.107"><vh>node 1</vh></v>
<v t="ekr.20150216070628.108"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.109"><vh>@shadow-test multiple-NODE changes</vh>
<v t="ekr.20150216070628.110"><vh>old</vh>
<v t="ekr.20150216070628.111"><vh>node 1</vh></v>
<v t="ekr.20150216070628.112"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.113"><vh>new</vh>
<v t="ekr.20150216070628.114"><vh>node 1</vh></v>
<v t="ekr.20150216070628.115"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.116"><vh>@shadow-test multiple-line delete between nodes: at end of prev node</vh>
<v t="ekr.20150216070628.117"><vh>old</vh>
<v t="ekr.20150216070628.118"><vh>node 1</vh></v>
<v t="ekr.20150216070628.119"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.120"><vh>new</vh>
<v t="ekr.20150216070628.121"><vh>node 1</vh></v>
<v t="ekr.20150216070628.122"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.123"><vh>@shadow-test multiple-line delete between nodes: at start of next node</vh>
<v t="ekr.20150216070628.124"><vh>old</vh>
<v t="ekr.20150216070628.125"><vh>node 1</vh></v>
<v t="ekr.20150216070628.126"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.127"><vh>new</vh>
<v t="ekr.20150216070628.128"><vh>node 1</vh></v>
<v t="ekr.20150216070628.129"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.130"><vh>@shadow-test verbatim sentinels-delete verbatim line</vh>
<v t="ekr.20150216070628.131"><vh>old</vh>
<v t="ekr.20150216070628.132"><vh>node 1</vh></v>
<v t="ekr.20150216070628.133"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.134"><vh>new</vh>
<v t="ekr.20150216070628.135"><vh>node 1</vh></v>
<v t="ekr.20150216070628.136"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.137"><vh>@shadow-test verbatim sentinels-delete verbatim line: at start of node</vh>
<v t="ekr.20150216070628.138"><vh>old</vh>
<v t="ekr.20150216070628.139"><vh>node 1</vh></v>
<v t="ekr.20150216070628.140"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.141"><vh>new</vh>
<v t="ekr.20150216070628.142"><vh>node 1</vh></v>
<v t="ekr.20150216070628.143"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.144"><vh>@shadow-test verbatim sentinels-no change</vh>
<v t="ekr.20150216070628.145"><vh>old</vh>
<v t="ekr.20150216070628.146"><vh>node 1</vh></v>
<v t="ekr.20150216070628.147"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.148"><vh>new</vh>
<v t="ekr.20150216070628.149"><vh>node 1</vh></v>
<v t="ekr.20150216070628.150"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.151"><vh>@shadow-test verbatim sentinels-delete verbatim line: at end of node</vh>
<v t="ekr.20150216070628.152"><vh>old</vh>
<v t="ekr.20150216070628.153"><vh>node 1</vh></v>
<v t="ekr.20150216070628.154"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.155"><vh>new</vh>
<v t="ekr.20150216070628.156"><vh>node 1</vh></v>
<v t="ekr.20150216070628.157"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.158"><vh>@shadow-test verbatim sentinels-add verbatim line</vh>
<v t="ekr.20150216070628.159"><vh>old</vh>
<v t="ekr.20150216070628.160"><vh>node 1</vh></v>
<v t="ekr.20150216070628.161"><vh>node 2</vh></v>
</v>
<v t="ekr.20150216070628.162"><vh>new</vh>
<v t="ekr.20150216070628.163"><vh>node 1</vh></v>
<v t="ekr.20150216070628.164"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20150216070628.165"><vh>@shadow-test no change, no ending newline</vh>
<v t="ekr.20150216070628.166"><vh>old</vh></v>
<v t="ekr.20150216070628.167"><vh>new</vh></v>
</v>
</v>
</v>
<v t="ekr.20100131180007.5363"><vh>@test class Marker.getDelims</vh></v>
<v t="ekr.20100131180007.5362"><vh>@test class Marker.isSentinel</vh></v>
<v t="ekr.20100131180007.5361"><vh>@test class Marker.isVerbatimSentinel</vh></v>
<v t="ekr.20090529115704.4550"><vh>@test x.baseDirName</vh></v>
<v t="ekr.20090529115704.4552"><vh>@test x.dirName</vh></v>
<v t="ekr.20100131180007.5366"><vh>@test x.findAtLeoLine</vh></v>
<v t="ekr.20090529115704.4557"><vh>@test x.makeShadowDirectory</vh>
<v t="ekr.20090529115704.4558"><vh>deleteShadowDir</vh></v>
</v>
<v t="ekr.20100131180007.5365"><vh>@test x.markerFromFileLines</vh></v>
<v t="ekr.20100131180007.5364"><vh>@test x.markerFromFileName</vh></v>
<v t="ekr.20090529115704.4551"><vh>@test x.pathName</vh></v>
<v t="ekr.20090529115704.4555"><vh>@@test x.rename</vh></v>
<v t="ekr.20090529115704.4559"><vh>@test x.replaceFileWithString</vh></v>
<v t="ekr.20100131180007.5367"><vh>@test x.replaceFileWithString 2</vh></v>
<v t="ekr.20090529115704.4554"><vh>@test x.shadowDirName</vh></v>
<v t="ekr.20090529115704.4553"><vh>@test x.shadowPathName</vh></v>
<v t="ekr.20090529115704.4556"><vh>@test x.unlink</vh></v>
</v>
<v t="ekr.20100131171342.5612"><vh>leoTest</vh>
<v t="ekr.20111102122424.3975"><vh>@test all unit tests have access to sources</vh></v>
<v t="ekr.20111105221757.3833"><vh>@test TM.findAllUnitTestNodes</vh></v>
<v t="ekr.20100131171342.5613"><vh>@test unit testing with embedded class</vh></v>
</v>
<v t="ekr.20071113193729"><vh>leoUndo</vh>
<v t="ekr.20040712101754.37"><vh>@suite Edit body tests</vh>
<v t="ekr.20040712101754.38"><vh>editBodyTests</vh>
<v t="ekr.20060127120604"><vh>tempNode</vh></v>
<v t="ekr.20050417202713"><vh>addComments</vh>
<v t="ekr.20050417202713.1"><vh>before</vh></v>
<v t="ekr.20050417202713.2"><vh>after</vh></v>
<v t="ekr.20050417202713.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417204940"><vh>convertAllBlanks</vh>
<v t="ekr.20050417204940.1"><vh>before</vh></v>
<v t="ekr.20050417204940.2"><vh>after</vh></v>
<v t="ekr.20050417204940.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417205012"><vh>convertAllTabs</vh>
<v t="ekr.20050417205012.1"><vh>before</vh></v>
<v t="ekr.20050417205012.2"><vh>after</vh></v>
<v t="ekr.20050417205012.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417203114"><vh>convertBlanks</vh>
<v t="ekr.20050417203310"><vh>before</vh></v>
<v t="ekr.20050417203310.1"><vh>after</vh></v>
<v t="ekr.20050417203336"><vh>selection</vh></v>
</v>
<v t="ekr.20050417203114.1"><vh>convertTabs</vh>
<v t="ekr.20050417204834"><vh>before</vh></v>
<v t="ekr.20050417204830"><vh>after</vh></v>
<v t="ekr.20050417204901"><vh>selection</vh></v>
</v>
<v t="ekr.20040712101754.49"><vh>dedentBody</vh>
<v t="ekr.20040712101754.50"><vh>before</vh></v>
<v t="ekr.20040712101754.51"><vh>after</vh></v>
<v t="ekr.20040712101754.52"><vh>selection</vh></v>
</v>
<v t="ekr.20050417202817"><vh>deleteComments</vh>
<v t="ekr.20050417202817.1"><vh>before</vh></v>
<v t="ekr.20050417202817.2"><vh>after</vh></v>
<v t="ekr.20050417202817.3"><vh>selection</vh></v>
</v>
<v t="ekr.20111112211307.3910"><vh>deleteComments</vh>
<v t="ekr.20111112211307.3911"><vh>before</vh></v>
<v t="ekr.20111112211307.3912"><vh>after</vh></v>
<v t="ekr.20111112211307.3913"><vh>selection</vh></v>
</v>
<v t="ekr.20050417201845"><vh>extract test1</vh>
<v t="ekr.20050417201845.1"><vh>before</vh></v>
<v t="ekr.20050417201845.2"><vh>after</vh>
<v t="ekr.20050417201845.3"><vh>&lt;&lt; section &gt;&gt; @nonl</vh></v>
</v>
<v t="ekr.20050417201845.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050518070540"><vh>extract test2</vh>
<v t="ekr.20050518070540.1"><vh>before</vh></v>
<v t="ekr.20050518070545"><vh>after</vh></v>
<v t="ekr.20050518070540.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050518070927"><vh>extractSection test1</vh>
<v t="ekr.20050518070927.1"><vh>before</vh></v>
<v t="ekr.20050518070927.2"><vh>after</vh>
<v t="ekr.20050518070927.3"><vh>&lt;&lt; section &gt;&gt; @nonl</vh></v>
</v>
<v t="ekr.20050518070927.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050518071251"><vh>extractSection test2</vh>
<v t="ekr.20050518071251.1"><vh>before</vh></v>
<v t="ekr.20050518071258"><vh>after</vh></v>
<v t="ekr.20050518071251.4"><vh>selection</vh></v>
</v>
</v>
</v>
<v t="ekr.20071113202510"></v>
</v>
<v t="ekr.20140802074328.4471"><vh>leoVim.py</vh>
<v t="ekr.20140802074328.4472"><vh>@test vc.on_same_line</vh></v>
<v t="ekr.20140802074328.4473"><vh>@test vc.to_bol</vh></v>
<v t="ekr.20140802074328.4474"><vh>@test vc.to_eol</vh></v>
</v>
<v t="ekr.20050120095423"><vh>Plugins</vh>
<v t="ekr.20110610082755.3362"><vh> qt gui</vh>
<v t="ekr.20100131171342.5503"><vh>@test c.vnode2position</vh></v>
<v t="ekr.20100131171342.5504"><vh>@test position2Item</vh></v>
<v t="ekr.20100131171342.5505"><vh>@@test item2position</vh></v>
</v>
<v t="ekr.20050218015346"><vh>@@suite run all plugin test routines</vh>
<v t="ekr.20050218015346.11"><vh>&lt;&lt; class testRoutineTestCase &gt;&gt;</vh>
<v t="ekr.20050218015346.12"><vh>__init__</vh></v>
<v t="ekr.20050218015346.13"><vh> fail</vh></v>
<v t="ekr.20050218015346.16"><vh>runTest</vh></v>
<v t="ekr.20050218015346.17"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20050218015346.18"><vh>addTestRoutinesInPluginToSuite</vh></v>
<v t="ekr.20050218015346.19"><vh>findTestsInModule</vh>
<v t="ekr.20050218015346.20"><vh>&lt;&lt; print classes, methods &amp; functions &gt;&gt;</vh></v>
</v>
<v t="ekr.20050218015346.22"></v>
</v>
<v t="ekr.20100131171342.5497"><vh>@@test detect_urls.py</vh></v>
<v t="ekr.20100131171342.5500"><vh>@@test macros.parameterize</vh></v>
<v t="ekr.20050120095423.11"><vh>@suite import or test syntax of all plugins</vh>
<v t="ekr.20050120095423.12"><vh>makePluginsTestSuite</vh></v>
<v t="ekr.20050120095423.13"><vh>class pluginTestCase</vh>
<v t="ekr.20050120095423.14"><vh>__init__</vh></v>
<v t="ekr.20050120095423.15"><vh>fail</vh></v>
<v t="ekr.20050120095423.16"><vh>runTest</vh></v>
<v t="ekr.20050120095423.17"><vh>setUp</vh></v>
<v t="ekr.20050120095423.18"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20050120095423.20"></v>
</v>
<v t="ekr.20111104214341.3835"><vh>@test all plugins have top-level init method</vh></v>
<v t="ekr.20140217055617.4230"><vh>@test c.theScriptingController.atScriptNodes</vh></v>
<v t="ekr.20100131171342.5501"></v>
</v>
</v>
<v t="ekr.20170520204621.1"><vh>Curses gui failures</vh>
<v t="ekr.20071113193624"></v>
<v t="ekr.20071113192611"></v>
<v t="ekr.20090529141856.4682"></v>
<v t="ekr.20071113194424.1"></v>
<v t="ekr.20111212142649.3971"></v>
<v t="ekr.20111112103320.3849"></v>
<v t="ekr.20111102164107.3975"></v>
<v t="ekr.20111026105935.3966"></v>
<v t="ekr.20080501121449.1"></v>
<v t="ekr.20111006105711.3544"></v>
<v t="ekr.20111006072734.3641"><vh>setup_test</vh></v>
</v>
<v t="ekr.20070131175538" a="M"></v>
</vnodes>
<tnodes>
<t tx="bwmulder.20050108100437.1">@killcolor

Running unit tests from test.leo is easy, provided you have enabled the
Scripting plugin. When this plugin is enabled Leo will create a blue 'script
button' in the icon bar called 'unit test'. 

- To run all unit tests, select the node in test.leo called 'Unit tests...',
then do &lt;alt-4&gt; 

- To run a single test, select an @test node and do &lt;alt-4&gt;.

- To run a suite of tests, select an @suite node and do &lt;alt-4&gt;.

- To run any other collection of tests, create an outline containing those @test
or @suite nodes, select the root of that tree and do &lt;alt-4&gt; .

Several nodes in the tree @thin ../src/leoTest.py (in test.leo) contain support
code for @test, @suite, etc. so if you want all the gory details you can read
the code. It's not complicated: Leo creates UnitTest classes automatically whose
run method is the body of the @suite or @test node.
</t>
<t tx="ekr.20040707141957.12"># Doesn't work when run externally because the copy operation changes the gnx.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20040707141957.13">Line 1

@last last line 1: no newline
</t>
<t tx="ekr.20040707141957.14">#@+leo-ver=5-thin
#@+node:ekr.20040707141957.13: * #@thin
Line 1

#@@last
#@-leo
last line 1: no newline
</t>
<t tx="ekr.20040712101754.100">v1 = [p.v for p in c.all_positions()]
v2 = [v for v in c.all_nodes()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

# print("coverage tests pass")
</t>
<t tx="ekr.20040712101754.101">nodes = []
for v in c.all_unique_nodes():
    assert v not in nodes
    nodes.append(v)

# print("duplicate tests pass")
</t>
<t tx="ekr.20040712101754.103">c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20040712101754.104">Line 1

@last last line 1: no newline
</t>
<t tx="ekr.20040712101754.105">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@nonl
#@-node:#@file
#@-leo
last line 1: no newline
</t>
<t tx="ekr.20040712101754.106">c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20040712101754.107">Line 1

@last last line 1: newline
</t>
<t tx="ekr.20040712101754.108">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@-node:#@file
#@-leo
last line 1: newline
</t>
<t tx="ekr.20040712101754.109">c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20040712101754.110">Line 1

@last last line 1: two trailing newlines
</t>
<t tx="ekr.20040712101754.111">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@-node:#@file
#@-leo
last line 1: two trailing newlines
</t>
<t tx="ekr.20040712101754.175"># p.__getattr__ must be enabled for this test to work.

for p in c.all_positions():
    assert(p.t == p.v)
</t>
<t tx="ekr.20040712101754.177">p = p.firstChild()
assert(p.h=="File Conversion")
p.convertTreeToString()
</t>
<t tx="ekr.20040712101754.178">@
- convertTreeToString and moreHead can't be VNode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040712101754.179">def moreHead (self, firstLevel,useVerticalBar=False):

    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")

    return "%s%s %s" % ('\t'*level,plusMinus,p.h)
</t>
<t tx="ekr.20040712101754.180">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  

    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; list = []

    # Only escape the first non-blank character of the line.
    s =  p.b ; result = []
    lines = string.split(s,'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s):
            ch = s[i]
            if ch == '+' or ch == '-' or ch == '\\':
                s = s[:i] + '\\' + s[i:]
        result.append(s)
    return string.join(result,'\n')
</t>
<t tx="ekr.20040712101754.181"># The actual test is in a child node.
</t>
<t tx="ekr.20040712101754.182"></t>
<t tx="ekr.20040712101754.183">try:
    for p in c.all_positions():
        if 0: # Check all ancestors.  This is tricky and doesn't work yet.
            parents1 = [parent.v for parent in p.parents_iter()]
            parents2 = []
            parent2 = p.v.directParents()
            while parent2:
                v = parent2[0]
                parents2.append(v)
                parent2 = v.directParents()
        else:
            parents1 = p.v.parents
            parents2 = p.v.directParents()
        assert len(parents1) == len(parents2), "length mismatch: %s" % (p)
        for parent in parents1:
            assert parent in parents2, "%s not in %s" % (parent,parent1)
        for parent in parents2:
            assert parent in parents1, "%s not in %s" % (parent,parent2)
except AssertionError:
    print('FAIL: @test consistency between parents_iter and v.parents')
    print("parents1")
    for parent in parents1: print(parent)
    print("parents2")
    for parent in parents2: print(parent)
    raise
</t>
<t tx="ekr.20040712101754.188">import leo.core.leoNodes as leoNodes
current = c.p
child = current.firstChild()
allList = [p.v for p in c.all_positions_iter()]
vList1 = [v for v in c.p.vnodes_iter()]
vList2 = [v for v in c.p.unique_vnodes_iter()]
if 0:
    for v in vList1: print(v)
    for v in vList2: print(v)
if 0:
    print(len(allList),len(vList1),len(vList2))

if 0: # v.iters no longer exist.
    &lt;&lt; tests of consistency of p and v iters &gt;&gt;
&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;
&lt;&lt; print nodes returned by iterators &gt;&gt;
</t>
<t tx="ekr.20040712101754.189"></t>
<t tx="ekr.20040712101754.190"></t>
<t tx="ekr.20040712101754.191"></t>
<t tx="ekr.20040712101754.192"></t>
<t tx="ekr.20040712101754.193"></t>
<t tx="ekr.20040712101754.194"></t>
<t tx="ekr.20040712101754.195"></t>
<t tx="ekr.20040712101754.196">try:
    tag = "@test p.iters and v.itersL: test1"
    list1 = [v for v in current.vnodes_iter()]
    list2 = [v for v in current.v.self_and_subtree_iter()]
    assert(list1==list2)
    tag = "@test p.iters and v.iters: test2"
    list1 = [p.v for p in c.all_positions_iter()]
    list2 = [v   for v in c.all_vnodes_iter()]
    assert(list1==list2)
except AssertionError:
    print(tag)
    print("list1")
    for v in list1: print(v)
    print("list2")
    for v in list2: print(v)
    raise
</t>
<t tx="ekr.20040712101754.197">nodes = []
for v in current.unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)

nodes = []
for t in current.unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)

# print("duplicate tests pass")
</t>
<t tx="ekr.20040712101754.198">if 0:
    for v in current.vnodes_iter(): print(v)
    for v in current.unique_vnodes_iter(): print(v)

if 0: # subtree of root node:
    root = c.rootPosition()
    for v in root.vnodes_iter(): print(v)
    for t in root.tnodes_iter(): print(t)

if 0: # child1's tree.  child2 should not be included.
    for v in child.vnodes_iter(): print(v)
    for t in child.tnodes_iter(): print(t)
</t>
<t tx="ekr.20040712101754.199">copy = p.copy()
assert(p == copy)
assert(p != p.threadNext())

root = c.rootPosition()
# assert p.equal(p.copy()) is True
# assert p.equal(root) is False
assert p.__eq__(copy) is True
assert p.__ne__(copy) is False
assert p.__eq__(root) is False
assert p.__ne__(root) is True
</t>
<t tx="ekr.20040712101754.200">for p in c.all_positions():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        firstChild = p.v.children[0]
        assert childv == firstChild
</t>
<t tx="ekr.20040712101754.201">p2 = c.rootPosition()
for p in c.all_positions():
    assert p==p2, "%s != %s" % (p,p2)
    p2.moveToThreadNext()

assert not p2, repr(p2)
</t>
<t tx="ekr.20040712101754.202">for p in c.all_positions():
    p2 = p.firstChild()
    for p3 in p.children_iter():
        assert p3==p2, "%s != %s" % (p3,p2)
        p2.moveToNext()

assert not p2, repr(p2)
</t>
<t tx="ekr.20040712101754.203">for p in c.all_positions():

    if p.hasParent():
        assert(p.parent().level() == p.level() - 1)

    if p.hasChildren():
        assert(p.firstChild().level() == p.level() + 1)

    if p.hasNext():
        assert(p.next().level() == p.level())

    if p.hasBack():
        assert(p.back().level() == p.level())
</t>
<t tx="ekr.20040712101754.204">for p in c.all_positions():

    back = p.back()
    next = p.next()
    if back: assert(back.getNext() == p)
    if next: assert(next.getBack() == p)
</t>
<t tx="ekr.20040712101754.205">for p in c.all_positions():
    p2 = p.parent()
    for p3 in p.parents_iter():
        assert p3==p2, "%s != %s" % (p3,p2)
        p2.moveToParent()

    assert not p2, repr(p2)
</t>
<t tx="ekr.20040712101754.206"># Test consistency of p.parent, p.next, p.back and p.firstChild.
for p in c.all_positions():

    if p.hasParent():
        n = p.childIndex()
        assert(p == p.parent().moveToNthChild(n))

    for child in p.children_iter():
        assert(p == child.parent())

    if p.hasNext():
        assert(p.next().parent() == p.parent())

    if p.hasBack():
        assert(p.back().parent() == p.parent())
</t>
<t tx="ekr.20040712101754.207">for p in c.all_positions():

    threadBack = p.threadBack()
    threadNext = p.threadNext()

    if threadBack:
        assert(p == threadBack.getThreadNext())

    if threadNext:
        assert(p == threadNext.getThreadBack())
</t>
<t tx="ekr.20040712101754.209">for p in c.all_positions():

    back = p.back()
    next = p.next()

    assert(
        (back and p.hasBack()) or
        (not back and not p.hasBack()))

    assert(
        (next and p.hasNext()) or
        (not next and not p.hasNext()))
</t>
<t tx="ekr.20040712101754.210">for p in c.all_positions():

    child = p.firstChild()
    parent = p.parent()

    assert(
        (child and p.hasFirstChild()) or
        (not child and not p.hasFirstChild()))

    assert(
        (parent and p.hasParent()) or
        (not parent and not p.hasParent()))
</t>
<t tx="ekr.20040712101754.211">for p in c.all_positions():

    threadBack = p.getThreadBack()
    threadNext = p.getThreadNext()

    assert(
        (threadBack and p.hasThreadBack()) or
        (not threadBack and not p.hasThreadBack()))

    assert(
        (threadNext and p.hasThreadNext()) or
        (not threadNext and not p.hasThreadNext()))
</t>
<t tx="ekr.20040712101754.37"># Create unit tests in g.app.scriptDict["suite"]

suite = c.testManager.makeEditBodySuite(p)

# g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20040712101754.38">@language plain
@

The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:

- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
</t>
<t tx="ekr.20040712101754.49"></t>
<t tx="ekr.20040712101754.50">line 1
    line 2
    line 3
line 4
</t>
<t tx="ekr.20040712101754.51">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20040712101754.52">2.0
3.5
</t>
<t tx="ekr.20040712101754.99">&lt;&lt; coverage tests &gt;&gt;
&lt;&lt; duplicate tests &gt;&gt;

if 0:
    print("vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()]))
    print("tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()]))

if 0: # all nodes
    for v in c.all_vnodes_iter(): print(v)
    for t in c.all_tnodes_iter(): print(t)

if 0: # unique nodes
    for v in c.all_unique_vnodes_iter(): print(v)
    for t in c.all_unique_tnodes_iter(): print(t)
</t>
<t tx="ekr.20040713070526">@language python 
dump = False 
all = False 
tm = c.testManager
if all:
    c.prettyPrintAllPythonCode(dump=dump)
else:
    # Warning: at present the before and after text is unprotected:
    # Running Pretty Print on these nodes will negate the value of the test.
    temp = tm.findNodeInTree(p,"tempNode")
    c.setBodyString(temp,"")
    before = tm.findNodeInTree(p,"before")
    after = tm.findNodeInTree(p,"after")
    temp.scriptSetBodyString(before.b)
    c.prettyPrintPythonCode(p=temp,dump=dump)
    assert temp.b == after.b,"Pretty Print Test failed"
</t>
<t tx="ekr.20040713123617">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a == 3:
        g.pr("  ")

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others
</t>
<t tx="ekr.20040713123828.1">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a == 3:
        g.pr("  ")

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others
</t>
<t tx="ekr.20040722055040">for p in c.all_positions():

    child = p.firstChild()
    while child:
        for parent in p.self_and_parents_iter():
            assert parent.isAncestorOf(child)
        child.moveToNext()

    next = p.next()
    assert not p.isAncestorOf(next)
</t>
<t tx="ekr.20040802065214"># Make sure that changing this headline marks descendant @thin nodes dirty.
h = p.h

try:
    child = p.firstChild()
    child.initHeadString("@thin bogus")
    assert child.h == "@thin bogus", "setting headline failed"
    child.clearDirty()
    assert not child.isDirty(), "clearing dirty failed"
    c.setHeadString(p,"changed")
    assert child.isDirty(), "setting descendant @thin nodes dirty failed."
finally:
    try:
        c.setHeadString(p,h)
        c.setHeadString(child,"bogus")
        p.clearDirty()
        child.clearDirty()
    finally: pass
</t>
<t tx="ekr.20040802065214.1">test
</t>
<t tx="ekr.20040802071519"># Tests that c.setBodyString works immediately.
h = p.h

try:
    w = c.frame.body.wrapper
    child = p.firstChild()
    before = child.b
    after = "after"
    c.setBodyString(child,"after")
    c.selectPosition(child)
    s = w.get("1.0","end")
    assert s.rstrip() == after.rstrip(), 'expected %s, got %s' % (
        repr(after),repr(s))
finally:
    c.setBodyString(child,before)
    c.selectPosition(p)
</t>
<t tx="ekr.20040802071519.1">before
</t>
<t tx="ekr.20040917062206">assert(g.cantImport("xyzzy","during unit testing") is None)
</t>
<t tx="ekr.20041013062906"># This hack is needed only for tkinter gui.
if g.app.gui.guiName() == 'tkinter':
    p.OnHyperLinkControlClick(event=None)
</t>
<t tx="ekr.20041021065844">c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20041021065844.1"># Test that @nosent generates no sentinels

&lt;&lt; section &gt;&gt;

@others

last line
section line 1
unnamed node line 1
</t>
<t tx="ekr.20041021065903"># Test that @nosent generates no sentinels

&lt;&lt; section &gt;&gt;

@others

last line
</t>
<t tx="ekr.20041021065903.1">section line 1
</t>
<t tx="ekr.20041021065903.2">unnamed node line 1
</t>
<t tx="ekr.20050105084757.1">import os

exists = g.os_path_exists

path = g.os_path_join(g.app.testDir,'xyzzy')
if exists(path):
    os.remove(path)

assert not exists(path)
assert not g.utils_remove(path,verbose=False)

f = open(path,'w')
f.write('test')
f.close()

assert exists(path)
assert g.utils_remove(path,verbose=True)
assert not exists(path)
</t>
<t tx="ekr.20050105091547">import os

exists = g.os_path_exists
path = g.os_path_join(g.app.testDir,'xyzzy')
path2 = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths.
for p in (path,path2):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = open(p,'w')
    f.write('test %s' % p)
    f.close()
    assert exists(p)

assert g.utils_rename(c,path,path2) #,verbose=True)
assert exists(path2)
f = open(path2)
s = f.read()
f.close()
assert s == 'test %s' % path
os.remove(path2)
assert not exists(path)
</t>
<t tx="ekr.20050105093136">import os

at = c.atFileCommands
exists = g.os_path_exists

path = g.os_path_join(g.app.testDir,'xyzzy')
if exists(path):
    os.remove(path)

assert not exists(path)
assert not at.remove(path,verbose=False)

f = open(path,'w')
f.write('test')
f.close()

assert exists(path)
assert at.remove(path)
assert not exists(path)
</t>
<t tx="ekr.20050105093524">import os
at = c.atFileCommands
exists = g.os_path_exists
path = g.os_path_join(g.app.testDir,'xyzzy')
path2 = g.os_path_join(g.app.testDir,'xyzzy2')
# Create both paths.
for p in (path,path2):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = open(p,'w')
    f.write('test %s' % p)
    f.close()
    assert exists(p)
assert at.rename(path,path2,verbose=True)
assert exists(path2)
f = open(path2)
s = f.read()
f.close()
assert s == 'test %s' % path
os.remove(path2)
assert not exists(path)
</t>
<t tx="ekr.20050105094311">import os
import leo.core.leoAtFile as leoAtFile
at = c.atFileCommands
exists = g.os_path_exists
at.outputFileName = None
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2')
try:
    # Create both paths (different contents)
    table = (at.targetFileName,)
    at.outputContents = contents = g.toUnicode('test contents')
    for fn in table:
        if fn and exists(fn):
            os.remove(fn)
        assert not exists(fn)
        f = open(fn,'w')
        s = 'test %s' % fn
        f.write(s)
        f.close()
        assert exists(fn),fn
    at.toString = False # Set by execute script stuff.
    at.shortFileName = at.targetFileName
    val = at.replaceTargetFileIfDifferent(at.root)
    assert val
    if 0:
        print('%s exists %s' % (at.outputFileName,exists(at.outputFileName)))
        print('%s exists %s' % (at.targetFileName,exists(at.targetFileName)))
    assert not exists(at.outputFileName), 'oops, output file exists'
    assert exists(at.targetFileName), 'oops, target file does not exist'
    f = open(at.targetFileName)
    s = f.read()
    f.close()
    assert s == contents,s
finally:
    if 1:
        for fn in (at.outputFileName,at.targetFileName):
            if fn and exists(fn):
                os.remove(fn)
</t>
<t tx="ekr.20050105095743">import os
import leo.core.leoAtFile as leoAtFile
at = c.atFileCommands
exists = g.os_path_exists
at.outputFileName = None
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2')
# Create both paths (identical contents)
contents = g.toUnicode('test contents')
try:
    table = (at.targetFileName,)
    at.outputContents = contents
    for fn in table:
        if fn and exists(fn):
            os.remove(fn)
        assert not exists(fn)
        f = open(fn,'w')
        f.write(contents)
        f.close()
        assert exists(fn)
    at.toString = False # Set by execute script stuff.
    at.shortFileName = at.targetFileName
    assert not at.replaceTargetFileIfDifferent(at.root)
    if 0:
        print('%s exists %s' % (at.outputFileName,exists(at.outputFileName)))
        print('%s exists %s' % (at.targetFileName,exists(at.targetFileName)))
    assert not exists(at.outputFileName)
    assert exists(at.targetFileName)
    f = open(at.targetFileName)
    s = f.read()
    f.close()
    assert s == contents,contents
finally:
    if 1:
        for fn in (at.outputFileName,at.targetFileName):
            if fn and exists(fn):
                os.remove(fn)
</t>
<t tx="ekr.20050105100227">import os
import leo.core.leoAtFile as leoAtFile
at = c.atFileCommands
exists = g.os_path_exists
at.outputFileName = None # g.os_path_join(g.app.testDir,'xyzzy1.txt')
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2.txt')
# Remove both files.
for fn in (at.outputFileName,at.targetFileName):
    if fn and exists(fn):
        os.remove(fn)
try:
    # Create the output file or contents.
    at.outputContents = contents = g.toUnicode('test output')
    at.toString = False # Set by execute script stuff.
    at.shortFileName = at.targetFileName
    val = at.replaceTargetFileIfDifferent(at.root)
    assert not val
    if 0:
        print('%s exists %s' % (at.outputFileName,exists(at.outputFileName)))
        print('%s exists %s' % (at.targetFileName,exists(at.targetFileName)))
    assert not exists(at.outputFileName),at.outputFileName
    assert exists(at.targetFileName),at.targetFileName
    f = open(at.targetFileName)
    s = f.read()
    f.close()
    assert s == contents,'%s len(%s)' % (fn,len(s))
finally:
    if 1:
        for fn in (at.outputFileName,at.targetFileName):
            if fn and exists(fn):
                os.remove(fn)
</t>
<t tx="ekr.20050112095306.1"></t>
<t tx="ekr.20050120095423"># Do this last.
</t>
<t tx="ekr.20050120095423.11">'''Imports all plugins or just tests their syntax,
epending on a switch in PluginTestCase.runTest.'''

import glob
import sys
import unittest

@others

suite = makePluginsTestSuite(c)

# g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20050120095423.12">def makePluginsTestSuite(c):

    '''Create a plugin test for .py file in the plugins directory'''

    # Create the suite.
    suite = unittest.makeSuite(unittest.TestCase)

    # Add a test case for every plugin.
    paths = (
        g.os_path_join(g.app.loadDir,'..','plugins','*.py'),
        g.os_path_join(g.app.loadDir,'..','plugins','examples','*.py'),
    )
    all_files = []
    for path in paths:
        plugins = g.os_path_join(path)
        plugins = g.os_path_abspath(plugins)
        files = glob.glob(plugins)
        files = [g.os_path_abspath(f) for f in files]
        all_files.extend(files)
    all_files.sort()
    
    for fn in all_files:
        test = pluginTestCase(c,fn)
        suite.addTest(test)

    if 0:
        # Open a new window after all tests are completed.  Tests many plugins.
        lastTest = lastTestCase(c,openFlag=True)
        suite.addTest(lastTest)

    return suite
</t>
<t tx="ekr.20050120095423.13">class pluginTestCase(unittest.TestCase):

    '''A test case to test a single Leo plugin.'''

    @others
</t>
<t tx="ekr.20050120095423.14">def __init__ (self,c,path):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
</t>
<t tx="ekr.20050120095423.15">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)
</t>
<t tx="ekr.20050120095423.16">def runTest(self):

    trace = False
    c = self.c ; path = self.path
    path,base = g.os_path_split(path)
    fn = base[:-3]
    
    ignore = (
        # Read error.
        'chinese_menu',
        # Unfinished/obsolute gui's.
        'gtkDialogs','gtkGui','ironPython','ironPythonGui',
        'swing_gui','tkGui','wxGui','temacs',
        # Tk-only.
        'ipython',
        # Imports path &amp; win32clipboard.
        'at_view',
        # Experimental.
        'stickynotes_plus',
        # Generated by unit tests.
        'pluginsTest',
        # Imports non-standard modules.
        'interact',         # import pexpect
        'jinjarender',      # import jinga2
        'leofeeds',         # import feedparser
    )

    if fn in ignore:
        return
    
    if trace: g.trace(fn)
    
    if 1:
        # Just check the syntax.  Doesn't pollute other unit tests.
        f = open(self.path,'r')
        s = f.read()
        f.close
        assert c.testManager.checkFileSyntax(fn,s,reraise=False,suppress=False)
    else: # Good for initial tests, but pollutes all other unit tests.
        exec('import leo.plugins.%s' % fn)
    
</t>
<t tx="ekr.20050120095423.17">def setUp(self):

    g.app.unitTestDict = {}
</t>
<t tx="ekr.20050120095423.18">def shortDescription (self):

    return "pluginTestCase: %s" % g.shortFileName(self.path)
</t>
<t tx="ekr.20050120095423.20">class lastTestCase(unittest.TestCase):

    '''A test case to print a message at the end of plugin tests.'''

    def __init__ (self,c,openFlag):
        # Init the base class.
        unittest.TestCase.__init__(self)
        self.c = c
        self.openFlag = openFlag

    def runTest(self):
        c = self.c
        print('\n%s a new window to test more plugin logic\n' % g.choose(
            self.openFlag,'opening','open'))
        if self.openFlag:
            self.new_c = new_c = c.new() # Create the new window.
            new_c.frame.setTitle("unit test for 'new' hook")

    if 0: # Doesn't work
        def shutDown(self):
            c = self.new_c
            c.close()
</t>
<t tx="ekr.20050203001146">assert c.page_width == c.config.getInt('page_width'),c.page_width
</t>
<t tx="ekr.20050203084930.1">w = g.app.config.get('global_setting_for_unit_tests','int')

assert w in (None,132) # Will be None when tests run dynamically.
</t>
<t tx="ekr.20050208135429">for ivar in ('c','g','p'):
    assert ivar in dir()
</t>
<t tx="ekr.20050218015346"># This test, if run at all, should be run elsewhere:
# Actually importing plugins affects other unit tests.

import glob
import inspect
import unittest

changed = c.isChanged() ; p1 = c.p
&lt;&lt; class testRoutineTestCase &gt;&gt;
@others

plugins = getAllPlugins()

# g.printList(plugins)

print('@suite run all plugin test routines')

if 1:
    g.app.unitTestDict["fail"] = False
    suite = unittest.makeSuite(unittest.TestCase)
    for plugin in plugins:
        n = addTestRoutinesInPluginToSuite(c,g,plugin,suite)
        if n:
            plural = g.choose(n==1,'','s')
            s = 'found %2d test routine%s for %s' % (n,plural,plugin)
            g.es_print(s)
    # if 1: # For @suite nodes.  Better for unit testing.
        # g.app.scriptDict['suite'] = suite
    # else: # For script button nodes.  Good for testing.
        # # Verbosity: 1: print just dots.
        # unittest.TextTestRunner(verbosity=1).run(suite)
        # c.setChanged(changed) # Restore changed state.
        # c.selectVnode(p1) # N.B. Restore the selected node.
</t>
<t tx="ekr.20050218015346.11">class testRoutineTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
</t>
<t tx="ekr.20050218015346.12">def __init__ (self,c,g,moduleName,theClass,f,code,verbose=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.moduleName = moduleName
    self.theClass = theClass
    self.f = f
    self.g = g
    self.code = code
    self.p = c.p.copy()
    self.verbose = verbose
</t>
<t tx="ekr.20050218015346.13">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)
</t>
<t tx="ekr.20050218015346.16">def runTest (self):

    f = self.f ; name = f.__name__ ; theClass = self.theClass

    d = {'c':self.c,'g':self.g,'p':self.p}

    if 1: # Use dead text to ensure a clean environment.
        # The present code assumes all leading whitespace is consistent.
        code = removeLeadingWs(self.code)
        # The code is a def statement.  We concoct a call to the function or method.
        if theClass:
            s = '%s\n%s(self=None)\n' % (code,name)
        else:
            s = '%s\n%s()\n' % (code,name)

        if self.verbose:
            g.trace('executing...\n\n%s' % s)

        exec(s,d) # Execute s in a environment containing c, g and p.

    else: # Use live objects.
        if theClass:
            # Create a subclass of f's original class.
            class __dummyClass(theClass):
                # Create a ctor with a known signature.
                def __init__(self): pass
            # Make f a method of the dummyClass with name 'f'.
            # N.B. f is still a method of theClass, and must be called as such!
            if 0: # Override the method with f's actual name.
                g.funcToMethod(f,__dummyClass,name)
                obj = __dummyClass()
                f = getattr(obj,name)
                f(obj)
            else:
                # Use the name 'f' for f's name.
                g.funcToMethod(f,__dummyClass,'f')
                # Create an instance of __dummyClass and call it's f method.
                obj = __dummyClass()
                obj.f()
        else: # Execute a plain function.
            f(**keys)
</t>
<t tx="ekr.20050218015346.17">def shortDescription (self):

    return 'test function',repr(self.f)
</t>
<t tx="ekr.20050218015346.18">def addTestRoutinesInPluginToSuite (c,g,pluginName,suite):

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))

    plugin = g.importFromPath(pluginName,path,verbose=True)
    if not plugin:
        return len([])

    tests = findTestsInModule(plugin,pluginName)

    for test in tests:
        theClass,f = test
        code = inspect.getsource(f)
        testCase = testRoutineTestCase(c,g,pluginName,theClass,f,code,verbose=False)
        suite.addTest(testCase)

    return len(tests)
</t>
<t tx="ekr.20050218015346.19">def findTestsInModule (module,moduleName):

    # g.trace(moduleName)

    toString = g.listToString
    try:
        functions = inspect.getmembers(module,inspect.isfunction)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isfunction) for %s' % moduleName)
        functions = []
    try:
        classes = inspect.getmembers(module,inspect.isclass)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isclass) for %s' % moduleName)
        classes = []

    # Ignore subclasses of TestCase.
    classes = [theClass for className,theClass in classes
        if not issubclass(theClass,unittest.TestCase)]

    allMethods = []
    for theClass in classes:
        try:
            methods = inspect.getmembers(theClass,inspect.ismethod)
        except Exception:
            # This looks like a bug in inspect: The zodb classes have no methods.
            # g.trace('Exception in inspect.getmembers(theClass,inspect.ismethod) for %s' % moduleName)
            methods = []
        # print('\nmethods of class %s...\n\n%s' % (theClass,toString(methods)))
        methods = [(theClass,f) for name,f in methods if name.startswith('test_')]
        allMethods.extend(methods)

    # Hack: remove duplicate tests from leoGlobals.py.
    functions = [(None,f) for name,f in functions
        if name.startswith('test_') and not name.startswith('test_g_')]
    if 0:
        &lt;&lt; print classes, methods &amp; functions &gt;&gt;
    result = functions
    result.extend(allMethods)
    return result
</t>
<t tx="ekr.20050218015346.20">print('=' * 40)

if classes:
    print('classes in %s...\n%s' % (moduleName,toString(classes)))
else:
    print('no classes in %s' % (moduleName))
if allMethods:
    print('test methods in %s...\n%s'   % (moduleName,toString(allMethods)))
else:
    print('no test methods in %s' % (moduleName))
if functions:
    print('test functions in %s...\n%s' % (moduleName,toString(functions)))
else:
    print('no test functions in %s' % (moduleName))
</t>
<t tx="ekr.20050218015346.22">def removeLeadingWs (code):

    if not code.strip():
        return ''
    lines = g.splitLines(code)
    line = lines[0]
    i = g.skip_ws(line,0)
    ws = line[0:i]
    if not ws:
        return code
    result = [] ; n = len(ws)
    for line in lines:
        if line.startswith(ws):
            result.append(line[n:])
        elif not line.strip() and line.endswith('\n'):
            result.append('\n')
        else:
            print('unitTest.leo:underindented line:%s' % repr(line))
            result.append(line)
    result = ''.join(result)
    return result
</t>
<t tx="ekr.20050417201845"></t>
<t tx="ekr.20050417201845.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20050417201845.2">before
    &lt;&lt; section &gt;&gt;
after
</t>
<t tx="ekr.20050417201845.3">sec line 1
    sec line 2 indented
sec line 3
</t>
<t tx="ekr.20050417201845.4">2.0
5.10
</t>
<t tx="ekr.20050417202713"></t>
<t tx="ekr.20050417202713.1">@language python

def addCommentTest():

    if 1:
        a = 2
        b = 3

    pass
</t>
<t tx="ekr.20050417202713.2">@language python

def addCommentTest():

    # if 1:
        # a = 2
        # b = 3

    pass
</t>
<t tx="ekr.20050417202713.3">5.0
7.8
</t>
<t tx="ekr.20050417202817"># created by new add-comments
</t>
<t tx="ekr.20050417202817.1">@language python

def deleteCommentTest():

#     if 1:
#         a = 2
#         b = 3

    pass
</t>
<t tx="ekr.20050417202817.2">@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3

    pass
</t>
<t tx="ekr.20050417202817.3">5.0
7.8
</t>
<t tx="ekr.20050417203114"></t>
<t tx="ekr.20050417203114.1"></t>
<t tx="ekr.20050417203310">@tabwidth -4

line 1
    line 2
      line 3
line4
</t>
<t tx="ekr.20050417203310.1">@tabwidth -4

line 1
	line 2
	  line 3
line4
</t>
<t tx="ekr.20050417203336">1.0
6.5
</t>
<t tx="ekr.20050417204830">@tabwidth -4

line 1
    line 2
      line 3
line4
</t>
<t tx="ekr.20050417204834">@tabwidth -4

line 1
	line 2
	  line 3
line4
</t>
<t tx="ekr.20050417204901">1.0
6.5
</t>
<t tx="ekr.20050417204940"></t>
<t tx="ekr.20050417204940.1">@tabwidth -4

line 1
    line 2
      line 3
line4
</t>
<t tx="ekr.20050417204940.2">@tabwidth -4

line 1
	line 2
	  line 3
line4
</t>
<t tx="ekr.20050417204940.3">1.0
6.5
</t>
<t tx="ekr.20050417205012"></t>
<t tx="ekr.20050417205012.1">@tabwidth -4

line 1
	line 2
	  line 3
line4
</t>
<t tx="ekr.20050417205012.2">@tabwidth -4

line 1
    line 2
      line 3
line4
</t>
<t tx="ekr.20050417205012.3">1.0
6.5
</t>
<t tx="ekr.20050512083807.1">marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.markAllAtFileNodesDirty()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
</t>
<t tx="ekr.20050512083822.1">marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.markSubheads()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
</t>
<t tx="ekr.20050512083822.2">marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.unmarkAll()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
</t>
<t tx="ekr.20050512084850">errors = c.checkOutline()
assert errors == 0, "Check Outline reported %d errors" % errors
</t>
<t tx="ekr.20050512084850.1">pass
</t>
<t tx="ekr.20050512084850.2">pass
</t>
<t tx="ekr.20050518070540"></t>
<t tx="ekr.20050518070540.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20050518070540.4">2.0
2.16
</t>
<t tx="ekr.20050518070545">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20050518070927"></t>
<t tx="ekr.20050518070927.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20050518070927.2">before
    &lt;&lt; section &gt;&gt;
after
</t>
<t tx="ekr.20050518070927.3">sec line 1
    sec line 2 indented
sec line 3
</t>
<t tx="ekr.20050518070927.4">2.0
5.10
</t>
<t tx="ekr.20050518071251"></t>
<t tx="ekr.20050518071251.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20050518071251.4">2.0
2.16
</t>
<t tx="ekr.20050518071258">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20050618061835">@killcolor

Here is a tutorial written by Roger Erens.

Version Date        LeoID       Remarks
------- ----        -----       -------
0.1     20050519    rogererens  Initial version</t>
<t tx="ekr.20050618061835.1">So you think "Well, since I've written this piece of funky Python software, and everybody keeps saying how useful unit testing is, I really ought to start using unit tests." And since Leo's creator has said countless times in the Leo forums how easy unit testing in Leo is, a few uncomplicated examples might help convince you that he's not spamming.

Beware: this How-To should be the last time that you write tests AFTER having written your funky software! Test Driven Development dictates that tests have to be prepared BEFORE you get down to writing your actual code. See a nice tutorial on O'Reilly's website (url given in the descendant node).</t>
<t tx="ekr.20050618061835.10">Start of Do @test
F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Documents and Settings\re1705\My Documents\PythonStuff\leo\src\leoTes
t.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.010s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.11">A real fun feature of Leo is that Leo saves you from having to select each and single @test node and press the 'Do @test' button to obtain testing results. Just collecting the @test nodes under an organizing node, selecting that organizing node, and pressing the 'Do @test' button will suffice.
Of course, this was one of the key ideas of unit testing, but it's nice to see it being implemented by Leo so smoothly!

So, press the button while having this node selected, and see if your console's output matches the third child node more or less. </t>
<t tx="ekr.20050618061835.12">Start of Do @test
.F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 2 tests in 0.040s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.13">Okay: so you've seen now some simple stand-alone tests to get your toes wet.
Now, we get to the 'grande finale' and see real-life usage of the @test nodes.

The @test child node below illustrates the following points:

1.  The node imports the module to test (and keeps it up to date by reloading it).
2.  It also obtains data to use as input and referral. This is what you might call
    the setUp methods in traditional unit tests. If more tests need the same data,
    you can put the nodes in a central place where all the @test nodes can find
    them. Likewise, common code for several unit tests might be collected in a
    central place.
3.  Comparable with the traditional unit tests' tearDown method, some statements
    can follow the test itself, if neccessary. You might also consider using a
    try/finally construct.
4.  I have used g.es() statements instead of print statements, since the latter
    clutter the console. Try replacing the g.es() statements by corresponding
    print statements to see what I mean. With more than one @test node being tested,
    this will give quite a dreadful look.</t>
<t tx="ekr.20050618061835.14">@color

try:
    # SETUP
    import koekiemonster # this module defines a function want() which we want to test
    reload(koekiemonster) # changes in koekiemonster need to propagate to the test

    # obtaining the input parameter for the function
    inputNode = p.firstChild()
    inputData = inputNode.b
    
    # obtaining the expected result from the function with above input parameter
    expectedResultNode = inputNode.next()
    expected = expectedResultNode.b
    
    # execute the function with above input parameter
    result = koekiemonster.wants(inputData)
    
    # TEST
    assert(result == expected)
    
    # TEARDOWN
    g.es("Now it's time to clean up")

except AssertionError:
    # TEARDOWN
    g.es("Oh oh! %s failed:" % p.h.strip())
    g.es("koekiemonster.wants(%s)==%s" % (inputData, result))
    g.es("Expected: %s" % expected)
    raise # pass the exception on to the unit test machinery</t>
<t tx="ekr.20050618061835.15">vegetables</t>
<t tx="ekr.20050618061835.16">Yuck!</t>
<t tx="ekr.20050618061835.17">Start of Do @test
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.070s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.18">Start of Do @test
Oh oh: @test koekiemonster.wants() failed:
koekiemonster.wants(vegetables)=Yack!
Expected: Yuck!
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.051s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.19">With the aforementioned possibilities of running all @test nodes in a subtree
with a single click on a button, the sharing of input/expected data, and the
sharing of setUp/tearDown code, there hardly seems a need for the @suite nodes.

On Leo's website
(http://webpages.charter.net/edreamleo/scripting.html#unit-testing-with-test-and-suite)
I could still find some extra info on @suite nodes, not found in LeoDocs.leo:

&lt;quote&gt;

Using @suite nodes

Such nodes create a suite of tests. Leo executes the script in these nodes similar to @test nodes, but Leo assumes that the script in an @suite node will do the following:

    * Create a suite of unit tests
    * Put the suite in g.app.scriptDict["suite"]

The difference between @test and @suite is:

    * Leo creates a unit test from script in an @test node by creating an instance of generalTestCase, a subclass of unittest.TestCase.
    * The script in an @suite node creates the test suite.

An @suite nodes allows us to create "legacy" unit tests simply. For example,
rather than rewriting all the reformatParagraph unit tests to use @test nodes, I
simply wrote an @suite node with the following body.

    suite = c.testManager.makeReformatParagraphSuite()
    g.app.scriptDict['suite'] = suite

&lt;/quote&gt;

Well, that's almost, but not quite completely, totally incomprehensible to me.
Fortunately, since Leo's creator removed most of this quote from LeoDocs.leo and
test.leo, this information appears to be outdated
.</t>
<t tx="ekr.20050618061835.2"></t>
<t tx="ekr.20050618061835.20">Don't forget to read the node
Users Guide--&gt;Chapter 7: Scripting Leo with Python--&gt;Unit testing with @test, @suite
in LeoDocs.leo, especially the final notes. Also investigate a little further in test.leo to see some heavy weight lifting.

This concludes my How-To on using @test. It was not written by an expert on (unit) testing;
it is more or less the result of keeping notes on my way to find out how I could get started
with unit tests in Leo. Maybe it's useful for other newbies as well.

Please post any remarks on one of the Leo Fora, and if deemed helpful, I'll be glad to incorporate them into a next version.

Happy testing!</t>
<t tx="ekr.20050618061835.3">Comment by EKR: There is no need to do this if you use test.leo for your unit tests:  just use the unit test button.

From the console, start up a Leo instance. On MS Windows: go to the folder in which you installed Leo 4.3, open up the 'src' folder and double click the 'leo.py' file. Opening a command window, and typing "python leo.py" may be another way.

Use the File--&gt;Open... menu item to open the outline containing your code.

Choose a good-looking position to insert a new node called 'Test zone'. Copy the child node of the node you're reading right now, and paste it as a child node of 'Test zone'. The code it contains is essentially the same as found in the node
Unit tests...--&gt;Do @test
in the file 'test.leo' in the 'test' folder. I just added my 0.2 cents by adding some starting and finishing remarks. Remove them if they clutter your console too much.

Also, make sure that you have an entry 'Scripting' in the 'Plugins' menu (enable the plugin if neccessary). Now is a good time to save your leo file.

With the 'Scripting' plugin (also known as the 'mod_scripting' plugin) enabled, the net effect will be that the next time you open your outline, a blue button with the caption 'Do @test' shows up in the tool bar of Leo, if your screen is wide enough.
To get the button right away in the tool bar, I have to assume that you started Leo with the scripting plugin enabled. In this case, a yellow button with the caption 'script Button' can be pressed while having the node '@button Do @test' selected. Note: the resulting button will not be blue, but pink. Removing a button from the tool bar can be done by right-clicking it.

We'll see the use of this added button soon, but before that, read up on the 'assert' function in the Python manuals, since it is used a lot in testing. It won't be long before you're back here!</t>
<t tx="ekr.20050618061835.4">@color

g.pr("\nStart of Do @test")
c.testManager.doTests(all=False)
g.pr("End of Do @test")</t>
<t tx="ekr.20050618061835.5">The first child node of the node you're reading right now, contains the simplest succeeding test possible.
Select it, and press the button 'Do @test'.
You can find the verbatim result as it got sent to my console in the second child node.

A few things are worth noting here:

1.  The node containing the test must have its headline start with '@test'.
2.  Whenever the 'assert' statement finds out that the expression given to it
    is 'True', a test passes successfully. There are more ways to pass a test, but
    for now, let us stick to the use of assert functions.
3.  A passed test is denoted with a single dot in the output. See the line between
    'Start of Do @test' and the line filled with dashes. This is compatible with the
    way traditional unit testing shows its progress.
4.  Below the dashed line in the output, a summary is printed. This one surely gives
    us a reason to lean back for a moment, and congratualate ourselves with another
    piece of robust, funky code!</t>
<t tx="ekr.20050618061835.6">@color
assert(True)</t>
<t tx="ekr.20050618061835.7">Start of Do @test
.
----------------------------------------------------------------------
Ran 1 test in 0.010s

OK
End of Do @test</t>
<t tx="ekr.20050618061835.8">Now that you've seen a passing test, it should be obvious to imagine how a failing test would look like. See the first child node, and then run it by pressing the 'Do @test' button as before.

Instead of a dot denoting success, we get an 'F' denoting a failure on the line following 'Start of Do @test'. When running a lot of tests, the next part, following the lines filled with '='s, helps to identify which test failed.
It also includes a trace back, but for AssertionErrors, it does not seem to offer much added value to me right now. On second thought: when you have multiple asserts in a test, the trace back can tell you which assert function failed. Still, I would choose for only one assert function per test and get rid of this trace back altogether. This would keep the console much cleaner, IMHO.</t>
<t tx="ekr.20050618061835.9">@color
assert('Spam' == 'Ham')</t>
<t tx="ekr.20050726141158">@ This is    a test of stuff.in doc parts.

         I wonder           what will happen.
@c

def        spam (self         )  :   

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a==3:
        g.pr("  ")

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others
</t>
<t tx="ekr.20051012104957"></t>
<t tx="ekr.20051107115231"># These are mysteriously fragile tests, so they go first
</t>
<t tx="ekr.20051107115231.14">h = '@test return ends editing of headline'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
guiName = g.app.gui.guiName()
wName = g.app.gui.widget_name(w)
assert wName.startswith('head'),'w.name:%s' % wName
g.app.gui.event_generate(c,'\n','Return',w)
c.outerUpdate()
assert w != c.get_focus(),'oops2: focus in headline'
</t>
<t tx="ekr.20051107115231.15">k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = '@test editLabel selects entire headline'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
assert w
s = w.getAllText()
selectAll = c.config.getBool('select_all_text_when_editing_headlines')
# g.trace('editLabel selects entire headline',selectAll)
i,j = w.getSelectionRange()
if selectAll:
    assert i == 0 and j == len(s),'oops1: i: %d, j: %d' % (i,j)
else:
    assert i == len(s) and j == len(s),'oops2: i: %d, j: %d' % (i,j)
</t>
<t tx="ekr.20051107115231.16">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.keyHandler
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redrawAndEdit(p) # To make node visible
    w = c.edit_widget(p)
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    
    try:
        assert w
        paste = 'ABC'
        g.app.gui.replaceClipboardWith(paste)
        g.app.gui.set_focus(c,w)
        w2 = g.app.gui.get_focus(c)
        w.setSelectionRange('end','end')
        k.manufactureKeyPressForCommandName(w,'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
        assert p.h == h + paste,'Expected: %s, got %s' % (
            h + paste,p.h)
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20051107115231.17">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.k
    if k.defaultUnboundKeyAction == 'insert':
        frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
        h = 'Test headline abc'
        p = c.testManager.findNodeAnywhere(h)
        assert p,'node not found: %s' % h
        c.redrawAndEdit(p) # To make the node visible.
        w = c.edit_widget(p)
        try:
            assert w, 'oops1'
            wName = g.app.gui.widget_name(w)
            assert wName.startswith('head'),'w.name:%s' % wName
            w.setSelectionRange('end','end')
            g.app.gui.event_generate(c,'X','Shift+X',w)
            g.app.gui.event_generate(c,'Y','Shift+Y',w)
            g.app.gui.event_generate(c,'Z','Shift+Z',w)
            g.app.gui.event_generate(c,'\n','Return',w)
            assert p.h == h + 'XYZ',(
                'oops2: expected: %s, got: %s' % (
                    h + 'XYZ',p.h))
            if g.app.gui.guiName() != 'nullGui':
                assert c.undoer.undoMenuLabel == 'Undo Typing','oops3: %s' % (
                    c.undoer.undoMenuLabel)
            k.manufactureKeyPressForCommandName(w,'undo')
            if g.app.gui.guiName() != 'nullGui':
                assert c.undoer.redoMenuLabel == 'Redo Typing','oops4'
            assert p.h == h,'oops5 got: %s, expected: %s' % (
                p.h,h)
        finally:
            if 1:
                c.setHeadString(p,h) # Essential
                c.redraw(p)
</t>
<t tx="ekr.20051107115231.18">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.keyHandler
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    frame = c.frame
    tree = frame.tree
    canvas = tree.canvas
    c.redrawAndEdit(p) # To make node visible
    w = c.edit_widget(p)
    try:
        assert w,'oops1'
        w.setSelectionRange('end','end')
        paste = 'ABC'
        g.app.gui.replaceClipboardWith(paste)
        w.setSelectionRange('end','end')
        k.manufactureKeyPressForCommandName(w,'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
        assert p.h == h + paste,'oops2 got: %s' % p.h
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h,'oops3 got: %s' % p.h
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20051107115231.20">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.keyHandler
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w, 'Null w'
        paste = 'ABC'
        g.app.gui.replaceClipboardWith(paste)
        w.setSelectionRange('1.1','1.2')
        k.manufactureKeyPressForCommandName(w,'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
        assert p.h == h[0] + paste + h[2:]
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, 'head mismatch'
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20051107115231.21">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.k
    if k.defaultUnboundKeyAction == 'insert':
        frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
        h = 'Test headline abc'
        p = c.testManager.findNodeAnywhere(h)
        assert p,'node not found: %s' % h
        c.redraw(p) # To make node visible
        tree.editLabel(p)
        w = c.edit_widget(p)
        try:
            assert w
            w.setSelectionRange('end','end')
            g.app.gui.event_generate(c,'X','Shift+X',w)
            g.app.gui.event_generate(c,'Y','Shift+Y',w)
            g.app.gui.event_generate(c,'Z','Shift+Z',w)
            g.app.gui.event_generate(c,'\n','Return',w)
            assert p.h == h + 'XYZ'
            k.manufactureKeyPressForCommandName(w,'undo')
            assert p.h == h
        finally:
            if 1:
                c.setHeadString(p,h) # Essential
                c.redraw(p)
</t>
<t tx="ekr.20051107115231.24"># Should be a comment
if g.app.gui.guiName() == 'curses':
    self.skipTest('not valid for curses gui')
else:
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    w = c.frame.body.wrapper
    n = c.frame.body.colorizer.recolorCount
    assert p,'node not found: %s' % h
    c.selectPosition(p)
    c.bodyWantsFocus()
    paste = '# Should be a comment'
    g.app.gui.replaceClipboardWith(paste)
    c.outerUpdate()
    event = g.app.gui.create_key_event(c,None,None,c.frame.body.wrapper)
    c.frame.pasteText(event)
    try:
        assert c.frame.body.colorizer.recolorCount &gt; n
    finally:
        if 1:
            c.setBodyString(p,'')
            c.redraw(p)
</t>
<t tx="ekr.20051107115231.28">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.keyHandler
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w,'oops1'
        w.setSelectionRange('end','end')
        paste = 'ABC'
        g.app.gui.replaceClipboardWith(paste)
        w.setSelectionRange('end','end')
        k.manufactureKeyPressForCommandName(w,'paste-text')
        c.selectPosition(p.visBack(c))
        assert p.h == h + paste
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h,'expected: %s, got: %s' % (
            h,p.h)
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20051107115231.29">import leo.core.leoEditCommands as leoEditCommands
s = 'foo' ; wrapper = c.frame.body.wrapper
c.searchCommands.openFindTab()
h = c.searchCommands.findTabHandler
w = h.find_ctrl
w.setAllText(s)
c.bodyWantsFocus()
wrapper.setInsertPoint(0)
c.searchCommands.findTabFindNext()
w = c.get_focus()
wName = g.app.gui.widget_name(w)
assert 'body' in wName, 'focus: %s = %s, expected %s = %s' % (
    w,wName,wrapper,g.app.gui.widget_name(wrapper))
</t>
<t tx="ekr.20051107115231.9">c.redraw(p) # To make node visible

c2 = c.new()
p2 = c2.p

try:
    # This fails, but it is possible to edit the headline.
    # assert c2.edit_widget(p2),'c2.edit_widget(p2) failed: %s' % repr(p2)
    assert p2,'p2 failed: %s' % repr(p2)
    # assert c.edit_widget(p),'c.edit_widget(p) failed: %s' % repr(p)
finally:
    c2.setChanged(False)
    c2.close()
</t>
<t tx="ekr.20051109091333">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.setBodyString(p,'a')
c.redraw_now() # To make node visible and to set the icon.
try:
    c.bodyWantsFocus()
    n = c.frame.tree.redrawCount
    w = c.frame.body.wrapper
    w.setInsertPoint('end')
    g.app.gui.event_generate(c,'\b','BackSpace',w)
    n2 = c.frame.tree.redrawCount
    if not g.app.isExternalUnitTest:
        # This test is meaningless with a nullGui.
        assert n2 == n + 1,'too many or too few redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw_now()
</t>
<t tx="ekr.20051109091731">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.setBodyString(p,'a')
c.redraw(p) # To make node visible
c.bodyWantsFocus()
n = c.frame.tree.redrawCount
try:
    w = c.frame.body.wrapper
    g.app.gui.event_generate(c,'a','a',w)
    n2 = c.frame.tree.redrawCount
    assert n2 == n,'too many redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20051120110335">u = c.undoer
assert u
c.insertHeadline()
assert u.undoMenuLabel == 'Undo Insert Node',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node',repr(u.undoMenuLabel)
</t>
<t tx="ekr.20051120115046">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
body = 'This is a test'
c.setBodyString(p,body)

try:
    assert p.b == body
    c.insertHeadline()
    c.undoer.undo()
    assert p.b == body
finally:
    c.setBodyString(p,'')
</t>
<t tx="ekr.20051125155134">n = c.frame.tree.redrawCount
c.insertHeadline()
c.outerUpdate() # Not actually needed, but should not matter.
try:
    n2 = c.frame.tree.redrawCount
    if g.app.isExternalUnitTest:
        self.skipTest('Can not be run externally')
    else:
        assert n2 == n + 1,'redraws: %d' % (n2 - n)
finally:
    c.undoer.undo()
</t>
<t tx="ekr.20051125170139">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    w.setSelectionRange('end','end')
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20060106211922">n = g.app.positions
assert c.isCurrentPosition(None) is False
assert c.isCurrentPosition(p) is True
assert g.app.positions == n
</t>
<t tx="ekr.20060106211922.1">assert not c.isRootPosition(None),'fail 1'
assert not c.isRootPosition(p),'fail 2'
</t>
<t tx="ekr.20060127120604"></t>
<t tx="ekr.20060130151716.1">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    table = (
        # 'toggle-find-clone-find-all-option',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        # 'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    )
    for command in table:
        c.k.simulateCommand(command)
        c.k.simulateCommand(command)
</t>
<t tx="ekr.20060130151716.2">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    table = (
        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
    )
    # show-find-tab-options     = Ctrl-o
    # show-find-options         = o
    for command in table:
        c.k.simulateCommand(command)
</t>
<t tx="ekr.20060130151716.3">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    table = (
        're-search-forward',
        're-search-backward',
        'search-forward',
        'search-backward',
        'word-search-forward',
        'word-search-backward',
    )
    
    for command in table:
        # This is not a full test.  We must use keyboardQuit here!
        c.k.simulateCommand(command)
        c.k.keyboardQuit(None)
</t>
<t tx="ekr.20060130151716.4">c.k.simulateCommand('show-find-options')
</t>
<t tx="ekr.20060131102450"># Print does not work with the curses gui: it is redirected.
s = '\nEnd of typing tests'
if False and g.app.gui.guiName() == 'curses':
    import logging
    logging.info(s)
else:
    g.pr(s)
</t>
<t tx="ekr.20060208072307">if c.k.defaultUnboundKeyAction == 'insert':
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p)
    c.bodyWantsFocus()
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    event = g.app.gui.create_key_event(c,None,None,c.frame.body.wrapper)
    c.frame.pasteText(event)
    
    # Move around and and make sure it doesn't change.
    try:
        assert p.b == paste, 'paste1 failed'
        c.selectPosition(p.threadBack())
        assert p.b == paste, 'stick failed'
        c.selectPosition(p)
        assert p.b == paste, 'revisit failed'
    finally:
        if 1:
            c.setBodyString(p,'')
            c.redraw(p)
</t>
<t tx="ekr.20060208072331">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
w.setSelectionRange('end','end',insert='end')
paste = 'ABC'
g.app.gui.replaceClipboardWith(paste)
event = g.app.gui.create_key_event(c,None,None,w)
c.frame.pasteText(event)
# Move around and and make sure it doesn't change.
try:
    # g.trace('before select',w,w.getAllText())
    c.selectPosition(p.threadBack())
    assert p.h == h + paste,'oops1: expected: %s, got %s' % (h + paste,p.h)
    c.selectPosition(p)
    assert p.h == h + paste,'oops2: expected: %s, got %s' % (h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20060208072358"># This test is too flaky for Tk.
import sys
if False and sys.platform.startswith('linux'):
    # Fails for strange reasons.
    self.skipTest('linux')
else:
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.selectPosition(p)
    c.bodyWantsFocus()
    c.redraw(p) # To make node visible
    n = c.frame.tree.redrawCount
    assert not p.b, 'oops1'
    try:
        assert p == c.p,'position has changed!'
        w = c.frame.body.wrapper
        if c.vim_mode and c.vimCommands:
            if c.vimCommands.state == 'normal':
                # Enter insert mode ;-)
                g.app.gui.event_generate(c,'i','i',w)
        g.app.gui.event_generate(c,'a','a',w)
        assert p.b == 'a', 'expected "a", got: %s' % repr(p.b)
        if g.app.gui.guiName() != 'nullGui':
            n2 = c.frame.tree.redrawCount
            c.outerUpdate() # Force the coloring before doing the test.
            assert n2 == n + 1,'too many or too few redraws: expected 1: got: %d' % (n2-n)
    finally:
        if 1:
            c.setBodyString(p,'')
            c.redraw(p)
</t>
<t tx="ekr.20060208072415">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
s = 'ABC'
c.setBodyString(p,s)
try:
    c.bodyWantsFocus()
    w = c.frame.body.wrapper
    w.setInsertPoint(2)
    c.outerUpdate() # This fixed the problem.
    if 1:
        c.k.simulateCommand('delete-char')
    else:
        # This fails unless Delete is bound to delete-char
        g.app.gui.event_generate(c,'Delete','Delete',w) # Calls c.outerUpdate()
    assert p.b == s[:-1],'oops1: expected "AB", got %s' % p.b
    c.selectPosition(p.threadBack())
    c.selectPosition(p)
    assert p.b == s[:-1],'oops2: expected "AB", got %s' % p.b
finally:
    if 0:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20060325071703.1">import sys

win32  = c.config.getBool('test_win32_setting')
darwin = c.config.getBool('test_darwin_setting')

if sys.platform == 'win32':
    assert(win32)
    assert(not darwin)

elif sys.platform== 'darwin':
    assert(not win32)
    assert(darwin)

</t>
<t tx="ekr.20060325071703.2">guiname = g.app.gui.guiName()

tkinter = c.config.getBool('test_tkinter_setting')
wx      = c.config.getBool('test_wxWindows_setting')

print(guiname)

if guiname == 'tkinter':
    assert(tkinter)
    assert(not wx)

if guiname == 'wxWindows':
    assert(not tkinter)
    assert(wx)
</t>
<t tx="ekr.20060602195313">import re
at = c.atFileCommands
expected = '''\
/*@+leo-ver=5-thin*/
/*@+node:GNX: * root*/
/*@@language c*/
#ifdef COMMENT
/*@@comment /* */ */
#endif
/*@@tabwidth 4*/
/*@@lineending crlf*/

/*@+others*/
/*@-others*/

/*@+&lt; &lt; Get LRR Task &gt; &gt;*/
/*@+node:GNX: ** &lt; &lt; Get LRR Task &gt; &gt;*/
/*@-&lt; &lt; Get LRR Task &gt; &gt;*/
/*@+&lt; &lt; Start LRR &gt; &gt;*/
/*@+node:GNX: ** &lt; &lt; Start LRR &gt; &gt;*/
/*@-&lt; &lt; Start LRR &gt; &gt;*/
/*@-leo*/
'''.replace('AT','#@').replace('&gt; &gt;', '&gt;&gt;').replace('&lt; &lt;', '&lt;&lt;')

child = p.firstChild()
at.write(child, toString=True)
    # Default: nosentinels=False
result = str(at.stringOutput)
result = re.sub(r'@\+node:(.+):', '@+node:GNX:', result)
if 0: # Show unexpected mismatches.
    result = g.splitLines(result)
    expected = g.splitLines(expected)
    print('len(expected): %s, len(result): %s' % (len(expected), len(result)))
    for i, s in enumerate(result):
        if expected[i] != result[i]:
            print(i)
            print('expected: %r' % expected[i])
            print('result:   %r' % result[i])
            break

assert result == expected
</t>
<t tx="ekr.20060602195313.2">@language c
#ifdef COMMENT
@comment /* */ 
#endif
@tabwidth 4
@lineending crlf

@others

&lt;&lt; Get LRR Task &gt;&gt;
&lt;&lt; Start LRR &gt;&gt;
</t>
<t tx="ekr.20060602195313.3"></t>
<t tx="ekr.20060602195313.4"></t>
<t tx="ekr.20060912091510.1">import time

c.frame.body.addEditor()

time.sleep(0.5)

c.frame.body.deleteEditor()

time.sleep(0.5)
</t>
<t tx="ekr.20060913084600">import leo.core.leoNodes as leoNodes

if leoNodes.use_zodb:
    p.v.__hash__()
</t>
<t tx="ekr.20060921115303"># for condition in ('&lt;','&lt;=','&gt;','&gt;='):

for v1,condition,v2 in (
    ('8.4.12','&gt;','8.4.3'),
    ('1','==','1.0'),
    ('2','&gt;','1'),
    ('1.2','&gt;','1'),
    ('2','&gt;','1.2.3'),
    ('1.2.3','&lt;','2'),
    ('1','&lt;','1.1'),
):
    assert g.CheckVersion(v1,v2,condition=condition,trace=False)
</t>
<t tx="ekr.20061001114236" unit_test="58040000006162636471002e">fc = c.fileCommands # self is a dummy
p.v.unknownAttributes = {g.u('unit_test'):g.u('abcd')}
s = fc.putUnknownAttributes (p.v)
expected = g.u(' unit_test="58040000006162636471002e"')
assert s == expected, '\nexpected: %s\ngot:      %s' % (repr(expected),repr(s))
</t>
<t tx="ekr.20061001114637"># 3 failures with Alt-5
</t>
<t tx="ekr.20061101121602.100">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.101">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.102">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.103">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.104">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.105">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.106">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.107">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.108">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.109">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.110">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.111">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.112">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.113">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.114">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.115">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.116">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.117">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.118">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.119">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.120">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.121">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.122">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.123">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.124">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.125">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.126">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.127">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.128">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.129">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.130">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.131">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.132">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.133">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.134">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.135">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.136">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.137">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.138">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.139">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.140">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.141">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.142">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.143">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.144">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.145">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.146">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.147">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.148">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.149">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.150">@pagewidth 70 # Required for unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.151">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.152">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.153">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.154">@pagewidth 70 # Required for unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.155">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20061101121602.156">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20061101121602.157">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20061101121602.158">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.159">first line
line    line b
line c
last line
</t>
<t tx="ekr.20061101121602.160">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.161">first line
line    line b
line c
last line
</t>
<t tx="ekr.20061101121602.162">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.163">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.164">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.165">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.166">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.167">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.168">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.169">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.170">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.171">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.172">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.173">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.174">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20061101121602.175">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.176">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.177">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.178">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20061101121602.179">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.180">XYZZY line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.181">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.182">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.183">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.184">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.185">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.186">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.187">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.188">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.189">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.190">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.191">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.192">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.193">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.194">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.195">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.196">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.197">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.198">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.199">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.200">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.201">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.202">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.203">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.204">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.205">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.206">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.207">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.208">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.209">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.210">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.211">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.212">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.213">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.214">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.215">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.216">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.217">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.218">@pagewidth 80
    # Required for external unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.219">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.220">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially
declared disasters are weather related,
leading to around 500 deaths per year
and nearly $14 billion in damage.
StormReady, a program
started in 1999 in Tulsa, OK,
helps arm America's
communities with the communication and
safety skills needed to save lives and
property--before and during the event.
StormReady helps community leaders and
emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.221">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.222">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.223">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.224">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.225">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.226">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.227">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.228">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.229">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.230">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.231">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.232">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.233">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.234">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.235">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.236">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.237">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.238">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.239">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.240">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.241">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.242">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.243">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.244">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.245">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.246">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.247">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.248">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.249">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.250">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.251">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.252">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.253">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.254">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.255">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.256">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.257">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.258">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.259">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.260">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.261">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.262">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.263">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.264">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.265">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.266">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.267">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20061101121602.268">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.269">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20061101121602.270">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.271">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20061101121602.272">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.273">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20061101121602.274">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.275">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.276">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.277">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.278">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.279">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.280">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.281">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.282">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.283">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.284">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.285">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.286">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.287">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20061101121602.288">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.289">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20061101121602.290">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.291">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.292">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.293">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.294">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.295">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.296">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.297">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.298">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.299">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.300">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.301">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.302">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.303">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.304">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.305">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.306">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.307">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.308">first line

line 1
    line a
        line b

line c
last line
</t>
<t tx="ekr.20061101121602.309">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.310">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.311">first line

line 1
   line a
       line b

line c
last line
</t>
<t tx="ekr.20061101121602.312">first line

line 1
    line a
        line b

line c
last line
</t>
<t tx="ekr.20061101121602.313">first line

line 1
   line a
       line b

line c
last line
</t>
<t tx="ekr.20061101121602.314">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.315">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20061101121602.316">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.317">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20061101121602.318">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.319">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20061101121602.320">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.321">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20061101121602.322">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.323">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20061101121602.324">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.325">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20061101121602.326">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.327">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20061101121602.328">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.329">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20061101121602.330">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.331">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.332">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.333">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.334">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.335">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20061101121602.336">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.337">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20061101121602.338">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.339">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.340">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.341">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.342">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.343">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.344">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.345">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.346">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.347">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.348">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20061101121602.349">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.350">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20061101121602.351">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.352">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.353">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.354">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20061101121602.355">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.356">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.357">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.78">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.79">first line
 line 1
     line a
 line b
last line
</t>
<t tx="ekr.20061101121602.80">first line
line 1
    line a
line b
last line
</t>
<t tx="ekr.20061101121602.81">first line
 line 1
     line a
 line b
last line
</t>
<t tx="ekr.20061101121602.82">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.83">first line
    line 1
        line a
            line b
    line c
last line
</t>
<t tx="ekr.20061101121602.84">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.85">first line
    line 1
        line a
            line b
    line c
last line
</t>
<t tx="ekr.20061101121602.86">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.87">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.88">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.89">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.90">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.91">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.92">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.93">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061101121602.94">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.95">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.96">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.97">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.98">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.99">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061104172236.1"></t>
<t tx="ekr.20061104172236.11">s = 'abc xy_z5 pdq'
i,j = g.getWord(s,5)
assert s[i:j] == 'xy_z5','got %s' % s[i:j]
</t>
<t tx="ekr.20061104172236.15">s = 'a\n\nc'

for i,result in (
    (-1,2), # One too few.
    (0,2),(1,2),
    (2,3),
    (3,4),
    (4,4), # One too many.
):
    j = g.skip_line(s,i)
    assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)
</t>
<t tx="ekr.20061104172236.16">s = 'a\n\nc'

for i,result in (
    (-1,1), # One too few.
    (0,1),(1,1),
    (2,2),
    (3,4),
    (4,4), # One too many.
):
    j = g.skip_to_end_of_line(s,i)
    assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)
</t>
<t tx="ekr.20061104172236.17">s1 = 'a\n\nc'
table1 = (
    (-1,0), # One too few.
    (0,0),(1,0),
    (2,2),
    (3,3),
    (4,4), # One too many.
)
s2 = 'a\n'
table2 = ((1,0),(2,2)) # A special case at end.

for s,table in ((s1,table1),(s2,table2)):
    for i,result in table:
        j = g.skip_to_start_of_line(s,i)
        assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)
</t>
<t tx="ekr.20061104172236.18">s = 'a\ncd\n\ne'

for i,result in (
    (-1,(0,2)), # One too few.
    (0,(0,2)),(1,(0,2)),
    (2,(2,5)),(3,(2,5)),(4,(2,5)),
    (5,(5,6)),
    (6,(6,7)),
    (7,(6,7)), # One too many.
):
    j,k = g.getLine(s,i)
    assert (j,k) == result, 'i: %d, expected %d,%d, got %d,%d' % (i,result[0],result[1],j,k)
</t>
<t tx="ekr.20061104172236.2"># targetWord
e = c.editCommands
k = c.k
w = c.frame.body.wrapper
for val in (True,False):
    k.arg = 't' # 'targetWord'
    w.setInsertPoint(0)
    e.w = w
    e.oneLineFlag = val
    f = e.findWord1(event=None)
    i,j = w.getSelectionRange()
    assert i == 2, 'expected 2, got %s' % (i)
    # s = w.getAllText()
    # ch = s[i]
    # assert word == 'targetWord', 'got: %s' % word

</t>
<t tx="ekr.20061104172236.22"># target.

try:
    w = c.frame.body.wrapper
    s = w.getAllText()
    w.setInsertPoint(len(s))
    c.k.previousSelection = 2,8
    event = g.app.gui.create_key_event(c,None,None,w)
    c.frame.pasteText(event=event,middleButton=True)
    s2 = w.getAllText()
    assert len(s2) == len(s) + len('target')
finally:
    w.setAllText(s)
    p.setBodyString(s)
    # g.trace(repr(s))
    c.recolor()

# end
</t>
<t tx="ekr.20061104172236.3"># TARGETWORD

w = c.frame.body.wrapper

for (which,result) in (('cap','Targetword'),('low','targetword'),('up','TARGETWORD')):
    w.setInsertPoint(5)
    c.editCommands.capitalizeHelper(event=None,which=which,undoType=None)
    s = w.getAllText()
    word = s[2:12]
    assert word == result, 'Expected %s, got: %s' % (result,repr(word))
    i = w.getInsertPoint()
    assert i == 5, 'Expected 5, got: %d' % i
</t>
<t tx="ekr.20061104172236.4">w = c.frame.body.wrapper
ec = c.editCommands

for spot,result in (('1.0',0),(5,5)):
    ec.setMoveCol(w,spot)
    assert ec.moveSpot == result
    assert ec.moveCol == result
</t>
<t tx="ekr.20061104172236.5">ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    # ('1.0','4.5',False),
    (5,50,True),
):
    extend = True
    ec.moveSpot = None # It's hard to init this properly.
    ec.extendHelper(w,extend,j)
    i2,j2 = w.getSelectionRange()
    #assert 0==i2, 'Expected i=%s, got %s' % (repr(i),repr(i2))
    #assert j==j2, 'Expected j=%s, got %s' % (repr(j),repr(j2))
</t>
<t tx="ekr.20061104172236.6">ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    #('1.0','4.5',False),
    (5,50,True),
):
    event = None ; extend = True ; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveToHelper (event,j,extend)
    i2,j2 = w.getSelectionRange()
    assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
    assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
    w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20061104172236.7">ec = c.editCommands
w = c.frame.body.wrapper

for direction in ('up','down'):
    for distance in ('line','page','half-page'):
        event = g.app.gui.create_key_event(c,None,None,w)
        ec.scrollHelper(event,direction,distance)
</t>
<t tx="ekr.20061106112522">w = c.frame.body.wrapper
s = w.getAllText()

try:
    w.setInsertPoint(len(s))
    c.insertBodyTime()
finally:
    w.setAllText(s)
    p.setBodyString(s)
    # c.recolor()

# end:
</t>
<t tx="ekr.20061106201509.6"># line 1
# line 2
# line 3

w = c.frame.body.wrapper
index = 11 # in the second line.
w.setInsertPoint(index)
before,ins,after = c.frame.body.getInsertLines()
assert before == '# line 1\n','Got %s' % repr(before)
assert ins    == '# line 2\n','Got %s' % repr(ins)
assert after.startswith('# line 3\n'),'line3'
assert after.endswith('# end.\n'),'end'

# end.
</t>
<t tx="ekr.20061106201509.7"># line 1
# line 2
# line 3

w = c.frame.body.wrapper
s = w.getAllText()
start,end = 11,15
w.setSelectionRange(start,end)
before,ins,after = c.frame.body.getSelectionAreas()
assert before == s[0:start],'Got %s' % repr(before)
assert ins    == s[start:end],'Got %s' % repr(ins)
assert after == s[end:]

# end.
</t>
<t tx="ekr.20061110094226">ec = c.editCommands ; w = c.frame.body.wrapper

for i,result,direction in (('5.8','4.8','up'),('5.8','6.8','down')):
    event = None ; extend = False; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveUpOrDownHelper (event,direction,extend)
    i2,j2 = w.getSelectionRange()
    if 1:
        break
    else:
        assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
        assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
        w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20061128082002">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061128082002.1">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061128082002.2">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061128082002.3">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20061128090021">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061128090021.1">line 1
line 2

line 4
</t>
<t tx="ekr.20061128090021.2">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20061128090021.3">line 1
line 2

line 4
</t>
<t tx="ekr.20061128090147">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061128090147.1">line 1
line 2
line 4
</t>
<t tx="ekr.20061128090147.2">line 1
line 2

line 4
</t>
<t tx="ekr.20061128090147.3">line 1
line 2
line 4
</t>
<t tx="ekr.20061128090338">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061128090338.1">line 1
line 2

</t>
<t tx="ekr.20061128090338.2">line 1
line 2
line 3
</t>
<t tx="ekr.20061128090338.3">line 1
line 2

</t>
<t tx="ekr.20070131162935">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070131162935.1">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20070131162935.2">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20070131162935.3">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20070131171218.1"></t>
<t tx="ekr.20070131171218.2">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20070131172706">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070131172706.1">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20070131172706.2">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20070131172706.3">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20070131173932">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070131173932.1">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20070131173932.2">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20070131173932.3">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20070131175538"></t>
<t tx="ekr.20070131175538.1"></t>
<t tx="ekr.20070131175646"></t>
<t tx="ekr.20070217071121.1">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070217071121.10">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20070217071121.11">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20070217071121.12">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20070217071121.13">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070217071121.14">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
</t>
<t tx="ekr.20070217071121.15">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20070217071121.16">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
</t>
<t tx="ekr.20070217071121.17">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070217071121.18">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20070217071121.19">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20070217071121.2">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20070217071121.20">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20070217071121.21">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070217071121.22">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
</t>
<t tx="ekr.20070217071121.23">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20070217071121.24">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
</t>
<t tx="ekr.20070217071121.25">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070217071121.26">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
</t>
<t tx="ekr.20070217071121.27">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
</t>
<t tx="ekr.20070217071121.28">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20070217071121.3">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20070217071121.4">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20070217071121.5">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070217071121.6">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20070217071121.7">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20070217071121.8">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20070217071121.9">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070305095401">p = c.p.copy()
c.selectPosition(p.threadBack())
p1 = c.p
c.goPrevVisitedNode()
p2 = c.p
c.goNextVisitedNode()
p3 = c.p
</t>
<t tx="ekr.20070306091949"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoEditCommands tests.')
</t>
<t tx="ekr.20070315065720">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070315065720.1">a

b
</t>
<t tx="ekr.20070315065720.2">a

b
</t>
<t tx="ekr.20070315065720.3">a

b
</t>
<t tx="ekr.20070315065849">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20070315065849.1">a

b
</t>
<t tx="ekr.20070315065849.2">a

b
</t>
<t tx="ekr.20070315065849.3">a

b
</t>
<t tx="ekr.20070417092935" str_leo_pos="9">@nosearch</t>
<t tx="ekr.20070611071101">p1 = p.copy()
a = p.firstChild()
b = a.firstChild()
c2 = b.firstChild()
limit = a.next()
d = limit.firstChild()
e = limit.next()
assert e.h == 'e'
for p2,h in ((a,'a'),(b,'b'),(c2,'c2'),(d,'d'),(limit,'limit')):
    p2.expand()
    assert p2.h==h,'headString mismatch'

try: # Tests without hoist...
    p1.expand()
    assert not c.hoistStack
    c.selectPosition(limit)
    result = limit.copy().moveToVisBack(c)
    assert result==c2,'visBack != c2: %s' % result
    #
    result = limit.copy().moveToVisNext(c)
    assert result==d,'visNext != d: %s' % result
finally:
    p1.contract()

try: # Tests with hoist.
    p1.expand()
    c.selectPosition(limit)
    c.hoist()
    result = limit.copy().moveToVisBack(c)
    assert not result,'limited visBack: %s' % result
    #
    result = limit.copy().moveToVisNext(c)
    assert result==d,'limited visNext !=d: %s' % result
finally:
    c.dehoist()
    c.selectPosition(p1)
    p1.contract()
    c.redraw_now()

</t>
<t tx="ekr.20070611071101.1"></t>
<t tx="ekr.20070611071101.2"></t>
<t tx="ekr.20070611071101.3"></t>
<t tx="ekr.20070611071101.4"></t>
<t tx="ekr.20070611071101.5"></t>
<t tx="ekr.20070611071954"></t>
<t tx="ekr.20070611105423.1">c.contractAllHeadlines()
</t>
<t tx="ekr.20070611105728"># Remove any previous children.
while p.hasChildren():
    p.firstChild().doDelete()
# Create two cloned children.
c.selectPosition(p)
c.insertHeadline()
p2 = c.p
p2.moveToFirstChildOf(p)
p2.setHeadString('aClone')
c.selectPosition(p2)
c.clone()
assert 2 == p.numberOfChildren()

# Select the first clone and demote (it should be illegal)
c.selectPosition(p2)
c.demote() # This should do nothing.
assert g.app.unitTestDict.get('checkMoveWithParentWithWarning'),'fail 1'
assert 0 == c.checkOutline(), 'fail 2'
assert 2 == p.numberOfChildren(), 'fail 3'
# Delete the children, but only if there are no errors.
while p.hasChildren():
    p.firstChild().doDelete()
</t>
<t tx="ekr.20070627082044.808"># A file that contains functions with errors in them.
# This is used to test error reporting in scripts

@language python
@tabwidth -4

def testIndexError():

    a = []
    b = a[2]

# The next line is used by @test c.checkFileTimeStamp.   
# timestamp: 1231502468.77
</t>
<t tx="ekr.20070627082044.811"># A file to be executed in batch mode as part of unit testing.
# This file is defined in unitTest.leo

@language python
@tabwidth -4

trace = False

path = g.os_path_join(g.app.loadDir,"..","test","unittest","createdFile.txt")

if trace: print("batchTest.py: creating: %s" % path)

try:
    try:
        f = open(path,"w")
        f.write("This file was written by unittest/batchTest.py")
    except IOError:
        print("batchTest.py: Can not create", path)
        f = None
finally:
    if f:
        f.close()

assert(g.os_path_exists(path))
</t>
<t tx="ekr.20071007120750.3">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20071007120750.4">@pagewidth 80
    # Required for external unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20071007120750.5">c.editCommands.ccolumn = 4 # Set the comment column
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20071007120750.6"># xxxx.yyyy

s = p.b
w = c.frame.body.wrapper
w.setSelectionRange(2,11)
c.editCommands.setFillPrefix(event=None)
prefix = c.editCommands.fillPrefix
assert prefix == 'xxxx.yyyy',repr(prefix)
</t>
<t tx="ekr.20071007120947">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20071007120947.6">first line
last lin
</t>
<t tx="ekr.20071007120947.7">first line
last line
</t>
<t tx="ekr.20071007120947.8">first line
last lin
</t>
<t tx="ekr.20071007121115.1">first line
line 1
last line
</t>
<t tx="ekr.20071007121115.2">first line
    line 1
last line
</t>
<t tx="ekr.20071007121115.3">first line
line 1
last line
</t>
<t tx="ekr.20071007121312.1">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20071007121312.2">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms,
2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes.
Potentially deadly
weather impacts every American.
Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20071007121312.3">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20071007121312.5">first line
    line b
last line
</t>
<t tx="ekr.20071007121312.6">first line
line b
last line
</t>
<t tx="ekr.20071007121312.7">first line
    line b
last line
</t>
<t tx="ekr.20071007121529">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20071007121529.1">firstline
last line
</t>
<t tx="ekr.20071007121529.2">first line
last line
</t>
<t tx="ekr.20071007121529.3">firstline
last line
</t>
<t tx="ekr.20071007124202">@pagewidth 80
    # Required for external unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20071007124202.1">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20071007124202.2">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms,
2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes.
Potentially deadly
weather impacts every American.
Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20071007124202.3">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20071113081247">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20071113081247.1">z
x
e
d
a
</t>
<t tx="ekr.20071113081247.10">x
z
A
c
B
</t>
<t tx="ekr.20071113081247.11">A
B
c
x
z
</t>
<t tx="ekr.20071113081247.2">a
d
e
z
x
</t>
<t tx="ekr.20071113081247.3">z
x
e
d
a
</t>
<t tx="ekr.20071113081247.8">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20071113081247.9">A
B
c
x
z
</t>
<t tx="ekr.20071113082531">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20071113082531.1">z
Y
X
c
b
A
</t>
<t tx="ekr.20071113082531.2">c
A
z
X
Y
b
</t>
<t tx="ekr.20071113082531.3">z
Y
X
c
b
A
</t>
<t tx="ekr.20071113090055.4"># This will work regardless of where this method is.
@language python
@tabwidth -4
# @path xyzzy # Creates folder called xyzzy: interferes with other unit tests.
@pagewidth 120

d = c.atFileCommands.scanAllDirectives(p)

assert d.get('language') == 'python'
assert d.get('tabwidth') == -4
# assert d.get('path').endswith('xyzzy')
assert d.get('pagewidth') == 120
</t>
<t tx="ekr.20071113090055.5"># This will work regardless of where this method is.
@language python
@tabwidth -4
# @path xyzzy # Creates folder called xyzzy: interferes with other unit tests.
@pagewidth 120

d = c.atFileCommands.scanAllDirectives(p)
assert d.get('language') == 'python'
assert d.get('tabwidth') == -4
# assert d.get('path').endswith('xyzzy')
assert d.get('pagewidth') == 120
</t>
<t tx="ekr.20071113105654.1">c.hoist()
c.dehoist()
</t>
<t tx="ekr.20071113143844.5">assert c.atFileCommands.isSignificantTree(p)

</t>
<t tx="ekr.20071113143844.9">assert g.CheckVersionToInt('12') == 12,'fail 1'
assert g.CheckVersionToInt('2a5') == 2, 'fail 2'
assert g.CheckVersionToInt('b2') == 0, 'fail 3'
</t>
<t tx="ekr.20071113145804.10">c.contractAllHeadlines()
p = c.rootPosition()
while p.hasNext():
    p.moveToNext()
c.selectPosition(p)
</t>
<t tx="ekr.20071113145804.15">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    c.helpCommands.helpForMinibuffer()
</t>
<t tx="ekr.20071113145804.16"># vr plugin not loaded externally.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    c.helpCommands.helpForBindings()
</t>
<t tx="ekr.20071113145804.17"># vr plugin not loaded externally.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    c.helpCommands.helpForFindCommands()
</t>
<t tx="ekr.20071113145804.18">fc=c.fileCommands
fc.deleteFileWithMessage('xyzzy','test')

if 0: # one-time test of es statements.
    fileName = 'fileName' ; kind = 'kind'
    g.es("read only",color="red")
    g.es("exception deleting %s file: %s" % (fileName,kind))
    g.es("exception deleting backup file:" + fileName)
</t>
<t tx="ekr.20071113145804.19">import sys

# Not a good unit test; it probably will never fail.
def aFunction(): pass
assert type(g.pdb)==type(aFunction), 'wrong type for g.pdb: %s' % type(g.pdb)

class myStdout:
    def write(self,s):
        pass # g.es('From pdb:',s)

class myStdin:
    def readline (self):
        return 'c' # Return 'c' (continue) for all requests for input.

def restore():
    sys.stdout,sys.stdin = sys.__stdout__,sys.__stdin__

try:
    sys.stdin = myStdin() # Essential
    sys.stdout=myStdout() # Optional
    g.pdb()
    restore()
    # assert False,'test of reraising'
except Exception:
    restore()
    raise
</t>
<t tx="ekr.20071113145804.21">theFile,fn = g.create_temp_file()
assert theFile
assert g.isString(fn)
</t>
<t tx="ekr.20071113145804.22">@first # -*- coding: utf-8 -*-

import sys

s = 'test '

def test():
    g.es_trace(s,color='red')

try:
    # Don't worry about the exact output.
    # Just test that it doesn't throw an exception.
    sys.stdout = g.fileLikeObject()
    test()

finally:
    sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20071113145804.26">s1 = 'abc\n\np\nxy'
table1 = (
    (-1,(0,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)),
    (3,(0,3)), # The newline ends a row.
    (4,(1,0)),
    (5,(2,0)),
    (6,(2,1)),
    (7,(3,0)),
    (8,(3,1)),
    (9,(3,2)), # One too many.
    (10,(3,2)), # Two too many.
)
s2 = 'abc\n\np\nxy\n'
table2 = (
    (9,(3,2)),
    (10,(4,0)), # One too many.
    (11,(4,0)), # Two too many.
)
s3 = 'ab' # Test special case.  This was the cause of off-by-one problems.
table3 = (
    (-1,(0,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)), # One too many.
    (3,(0,3)), # Two too many.
)

for s,table in ((s1,table1),(s2,table2)):
    for i,result in table:
        row,col = g.convertPythonIndexToRowCol(s,i)
        assert row == result[0], 'i: %d, expected row %d, got %d' % (i,result[0],row)
        assert col == result[1], 'i: %d, expected col %d, got %d' % (i,result[1],col)
</t>
<t tx="ekr.20071113145804.27">s1 = 'abc\n\np\nxy'
s2 = 'abc\n\np\nxy\n'
table1 = (
    (0,(-1,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)),
    (3,(0,3)), # The newline ends a row.
    (4,(1,0)),
    (5,(2,0)),
    (6,(2,1)),
    (7,(3,0)),
    (8,(3,1)),
    (9,(3,2)), # One too large.
)
table2 = (
    (9,(3,2)),
    (10,(4,0)), # One two many.
)
for s,table in ((s1,table1),(s2,table2)):
    for i,data in table:
        row,col = data
        result = g.convertRowColToPythonIndex(s,row,col)
        assert i == result, 'row: %d, col: %d, expected: %d, got: %s' % (row,col,i,result)
</t>
<t tx="ekr.20071113145804.28">script = g.getScript(c,p) # This will get the text of this node.
assert script.find('\r\n') == -1, repr(script)
</t>
<t tx="ekr.20071113145804.29">for s,expected in (
    (' a\n b\n c', 'a\nb\nc'),
    (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
):
    result = g.removeExtraLws(s,c.tab_width)
    assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
        repr(s),repr(expected),repr(result))
</t>
<t tx="ekr.20071113145804.32"># line 1
# line 2
# line 3

w = c.frame.body.wrapper
s = w.getAllText()
start,end = 11,15
w.setSelectionRange(start,end)
before,ins,after = c.frame.body.getSelectionAreas()
assert before == s[0:start],'Got %s' % repr(before)
assert ins    == s[start:end],'Got %s' % repr(ins)
assert after == s[end:]

# end.
</t>
<t tx="ekr.20071113145804.33"># target

try:
    w = c.frame.body.wrapper
    s2 = p.b
    s = w.getAllText()
    assert s == s2, 'w.getAllText() != p.b: len(w)=%d, len(p)=%d' % (len(s),len(s2))
    w.setInsertPoint(len(s))
    c.k.previousSelection = 2,8
    event = g.app.gui.create_key_event(c,None,None,w)
    c.frame.pasteText(event=event,middleButton=True)
    s2 = w.getAllText()
    assert len(s2) == len(s) + len('target')
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor()

# end5target
</t>
<t tx="ekr.20071113145804.4">@first # -*- coding: utf-8 -*-
@language python

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()

    # This strings tests unicode, paren matching, and auto-indentation.
    u = g.u('(a\u00c9\u03a9B\u3045\u4e7cz):\n') # '(aBE|cz):\n'
    u = g.u('(pdq):\n')
    w.setInsertPoint(len(s))
    for char in u:
        stroke = g.choose(char=='\n','Return',char)
        event = g.app.gui.create_key_event(c,char,stroke,w)
        ec.selfInsertCommand(event)
    result = w.getAllText()
    #g.trace('result',repr(result))
    assert result.endswith('    '),'result:\n%s' % result
    # Test of autocompleter.
finally:
    if 1:
        w.setAllText(s)
        p.setBodyString(s)
        # g.trace(repr(s))
        c.recolor()

# end:
</t>
<t tx="ekr.20071113145804.5">@language python
@tabwidth -4

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()
    w.setSelectionRange(len(s)-9,len(s)-6)
    event = g.app.gui.create_key_event(c,'\t','Tab',w)
    ec.selfInsertCommand(event)
    result = w.getAllText()
    assert result.endswith('\n    ###abcdef\n'),'result\n%s' % (repr(result))
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor_now()
    
###abcdef
</t>
<t tx="ekr.20071113145804.7">at=c.atFileCommands # self is a dummy argument.
table = (
    # start, end, new_df, isThin, encoding
    # pre 4.2 formats...
    ('#',   '',   False,  True, 'utf-8', '#@+leo-thin-encoding=utf-8.'),
    ('#',   '',   False,  False,'utf-8', '#@+leo-encoding=utf-8.'),
    # 4.2 formats...
    ('#',   '',   True,   True, 'utf-8',  '#@+leo-ver=4-thin-encoding=utf-8,.'),
    ('/*',  '*/', True,   True, 'utf-8',  '\*@+leo-ver=5-thin-encoding=utf-8,.*/'),
    ('#',   '',   True,   True, 'utf-8',  '#@+leo-ver=5-thin'),
    ('#',   '',   True,   True, 'utf-16', '#@+leo-ver=5-thin-encoding=utf-16,.'),
)
try:
    for start, end, new_df, isThin, encoding, s in table:
        valid, new_df2, start2, end2, isThin2 = at.parseLeoSentinel(s)
        # g.trace('start',start,'end',repr(end),'len(s)',len(s))
        assert valid, s
        assert new_df == new_df2, s
        assert isThin == isThin2, s
        assert end == end2, (end, end2, s)
        assert at.encoding == encoding, s
finally:
    at.encoding = 'utf-8'
</t>
<t tx="ekr.20071113145804.8">at=c.atFileCommands
table = [
    ('@=',0,at.noDirective),
    ('@',0,at.atDirective),
    ('@ ',0,at.atDirective),
    ('@\t',0,at.atDirective),
    ('@\n',0,at.atDirective),
    ('@all',0,at.allDirective),
    ('    @all',4,at.allDirective),
    ("@c",0,at.cDirective),
    ("@code",0,at.codeDirective),
    ("@doc",0,at.docDirective),
    ("@end_raw",0,at.endRawDirective),
    ('@others',0,at.othersDirective),
    ('    @others',4,at.othersDirective),
    ("@raw",0,at.rawDirective),
]
for name in g.globalDirectiveList:
    # Note: entries in g.globalDirectiveList do not start with '@'
    if name not in ('all','c','code','doc','end_raw','others','raw',):
        table.append(('@' + name,0,at.miscDirective),)

for s,i,expected in table:
    result = at.directiveKind4(s,i)
    assert result == expected, '%d %s result: %s expected: %s' % (
        i,repr(s),at.sentinelName(result),at.sentinelName(expected))
</t>
<t tx="ekr.20071113192611"></t>
<t tx="ekr.20071113193527"># 4 failures with Alt-5
</t>
<t tx="ekr.20071113193624"># 7 failures with Alt-5
</t>
<t tx="ekr.20071113193729">@

9 failures with Alt-5.

Any unit test that changes the structure of the outline should do the
following:

- The setUp method should do
    self.undoMark = c.undoer.getMark()
before altering the outline.

- The tearDown method should do
    c.undoer.rollBackToMark(self.undoMark)
after restoring the outline.

u.rollBackToMark deletes all entries in the undo stack following the saved mark.
This eliminates references to nodes that no longer exist in the present outline.
</t>
<t tx="ekr.20071113194033.3"># No failures with Alt-5 but warnings about no tnode lists.
</t>
<t tx="ekr.20071113194216"># 3 failurs with Alt-5
</t>
<t tx="ekr.20071113194424"># 3 failures with Alt-5
</t>
<t tx="ekr.20071113194424.1"></t>
<t tx="ekr.20071113194858"># All the following files have problems when run with Alt-5.
</t>
<t tx="ekr.20071113201736"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoAtFile tests')
</t>
<t tx="ekr.20071113201833"># Print does not work with the curses gui: it is redirected.
g.pr('End of leoCommands tests')
</t>
<t tx="ekr.20071113201854"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoConfig tests')
</t>
<t tx="ekr.20071113202045"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoFileCommands tests.')
</t>
<t tx="ekr.20071113202153"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoFind tests.')
</t>
<t tx="ekr.20071113202153.1"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoFrame tests.')
</t>
<t tx="ekr.20071113202153.2"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoGlobals tests.')
</t>
<t tx="ekr.20071113202452"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoNodes tests.')
</t>
<t tx="ekr.20071113202510"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoUndo tests.')
</t>
<t tx="ekr.20071113203234"></t>
<t tx="ekr.20080310073711.1">gnx = g.app.nodeIndices.toString(None)
assert(gnx not in (None,'None'))
assert(len(gnx) &gt; 1)
</t>
<t tx="ekr.20080408094623.1"># start
# targetWord

e = c.editCommands
k = c.k
w = c.frame.body.wrapper
w.setInsertPoint(0)
k.arg = 't' # 'targetWord'
e.w = w
e.oneLineFlag = False
e.findWord1(event=None)
i,j = w.getSelectionRange()
assert i == 10, 'expected 10, got %s' % (i)
</t>
<t tx="ekr.20080423110627.11">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p5 = p.insertAsNthChild(3)
    p5.setHeadString('D')
    p.expand()
    c.setCurrentPosition(p3)
    c.moveOutlineDown()
    moved = c.p
    assert moved.h == 'B',          'fail 1: %s' % moved.h
    assert moved.back().h == 'C',   'fail 2'
    assert moved.next().h == 'D',   'fail 3'
    # This assert fails because p4._childIndex != moved.back()._childIndex.
    # assert moved.back() == p4, 'fail 4: %s != %s' % (moved.back(),p4)
    assert moved.next() == p5,      'fail 5: %s != %s' % (moved.next(),p5)
    c.undoer.undo()
    moved = c.p
    assert moved.back() == p2,      'fail 4'
    assert moved.next() == p4,      'fail 5'
    c.undoer.redo()
    moved = c.p
    assert moved.h == 'B',          'fail 1-2: %s' % moved.h
    assert moved.back().h == 'C',   'fail 2-2'
    assert moved.next().h == 'D',   'fail 3-2'
    c.undoer.undo()
    moved = c.p
    assert moved.back() == p2,      'fail 4-2'
    assert moved.next() == p4,      'fail 5-2'
    c.undoer.redo()
    moved = c.p
    assert moved.h == 'B',          'fail 1-3'
    assert moved.back().h == 'C',   'fail 2-3'
    assert moved.next().h == 'D',   'fail 3-3'

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now(root)
</t>
<t tx="ekr.20080423110627.12">while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p5 = p.insertAsNthChild(3)
    p5.setHeadString('D')
    p.expand()
    c.setCurrentPosition(p4)
    c.moveOutlineUp()
    moved = c.p
    assert moved.h == 'C',          'fail 1'
    assert moved.back().h == 'A',   'fail 2'
    assert moved.next().h == 'B',   'fail 3'
    assert moved.back() == p2,      'fail 4: %s != %s' % (moved.back(),p2)
    # This assert fails because p4._childIndex != moved.back()._childIndex.
    # assert moved.next() == p3,    'fail 5: %s != %s' % (moved.next(),p3)
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now(p)
</t>
<t tx="ekr.20080423110627.13"># Do not change the root during external unit tests!
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    import leo.core.leoNodes as leoNodes
    
    while p.hasChildren():
        p.firstChild().doDelete(newNode=None)
    
    child = p.insertAsNthChild(0)
    child.setHeadString('child')
    
    try:
        oldRoot = c.rootPosition()
        child.moveToRoot(oldRoot=oldRoot) # Does not change child position.
        c.setRootPosition(child)
        assert c.positionExists(child)
        assert c.rootPosition().h == 'child', 'fail 1'
        next = c.rootPosition().next()
        assert next.h == 'Startup', 'fail 2: next: %s' % next
        c.rootPosition().doDelete(newNode=next)
        c.setRootPosition(next)
    finally:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
        # c.selectPosition(p)
        c.redraw_now()
</t>
<t tx="ekr.20080423110627.2">n = 0
for v in c.all_unique_vnodes_iter():
    if hasattr(v,'unknownAttributes'):
        d = v.unknownAttributes
        if d.get('str_leo_pos'):
            n += 1
assert n &lt; 2
</t>
<t tx="ekr.20080423110627.3"># Delete all children.
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

child = p.insertAsNthChild(0)
c.setHeadString(child,'child') # Force the headline to update.

try:
    assert child, 'no child'
    c.selectPosition(child)
    clone = c.clone()
    assert clone == c.p
    assert clone.h == 'child','fail headstring: %s' % clone.h
    assert child.isCloned(), 'fail 1'
    assert clone.isCloned(), 'fail 2'
    assert child.isCloned(), 'fail 3'
    assert clone.isCloned(), 'fail 4'
    c.undoer.undo()
    assert not child.isCloned(), 'fail 1-a'
    c.undoer.redo()
    assert child.isCloned(),    'fail 1-b'
    c.undoer.undo()
    assert not child.isCloned(), 'fail 1-c'
    c.undoer.redo()
    assert child.isCloned(),    'fail 1-d'
    oldRoot = c.rootPosition()
    clone.moveToRoot(oldRoot=oldRoot) # Does not change child position.
    assert child.isCloned(),    'fail 3-2'
    assert clone.isCloned(),    'fail 4-2'
    assert not clone.parent(),  'fail 5'
    assert not clone.back(),    'fail 6'
    clone.doDelete()
    assert not child.isCloned(), 'fail 7'
finally:
    # Delete all children.
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    c.redraw_now(p)
</t>
<t tx="ekr.20080423110627.5">while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

child = p.insertAsNthChild(0)
child.setHeadString('child')
child2 = p.insertAsNthChild(1)
child2.setHeadString('child2')
grandChild = child.insertAsNthChild(0)
grandChild.setHeadString('grand child')
c.selectPosition(grandChild)
c.clone()
c.selectPosition(child)

try:
    p.expand()
    c.selectPosition(child)
    assert c.p.h == 'child','fail 1'
    c.copyOutline()
    oldVnodes = [p2.v for p2 in child.self_and_subtree()]
    c.selectPosition(child)
    c.p.contract() # Essential
    c.pasteOutline()
    assert c.p != child, 'fail 2'
    assert c.p.h == 'child','fail 3'
    newVnodes = [p2.v for p2 in c.p.self_and_subtree()]
    for v in newVnodes:
        assert v not in oldVnodes, 'fail 4'
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()

finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now(p)
</t>
<t tx="ekr.20080423110627.8">while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

child = p.insertAsNthChild(0)
child.setHeadString('child')
assert child, 'no child'
grandChild = child.insertAsNthChild(0)
grandChild.setHeadString('grand child')

try:
    c.selectPosition(child)
    c.copyOutline()
    oldVnodes = [p2.v for p2 in child.self_and_subtree()]
    c.p.contract() # Essential
    c.pasteOutlineRetainingClones()
    assert c.p != child, 'fail 2'
    newVnodes = [p2.v for p2 in c.p.self_and_subtree()]
    for v in newVnodes:
        assert v in oldVnodes, 'fail 3'
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now(p)
</t>
<t tx="ekr.20080501121449.1"></t>
<t tx="ekr.20080501121449.3">assert p.h == '@test insert node',repr(p.h)
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
try:
    assert p.h == '@test insert node',repr(p.h)
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p.expand()
    c.setCurrentPosition(p2)
    p4 = c.insertHeadline()
    assert p4 == c.p
    p = c.p
    assert p,'no p'
    p.setHeadString('inserted')
    assert p.back(),'no p.back(): %s' % (p)
    assert p.back().h == 'A', 'fail 1'
    assert p.next().h == 'B', 'fail 2'
    c.undoer.undo()
    # With the new undo logic, it takes 2 undoes.
    # The first undo undoes the headline changes,
    # the second undo undoes the insert node.
    if g.app.isExternalUnitTest:
        # The situation is different in a null Gui.
        pass
    else:
        c.undoer.undo() 
    p = c.p
    assert p == p2,         'fail 3:\n p: %s\np2: %s' % (p,p2)
    assert p.next() == p3,  'fail 4'
    c.undoer.redo()
    p = c.p
    assert p.back(),          'fail 0-2'
    assert p.back().h == 'A', 'fail 1-2'
    assert p.next().h == 'B', 'fail 2-2'
    c.undoer.undo()
    p = c.p
    assert p == p2,         'fail 3-2'
    assert p.next() == p3,  'fail 3-2'
    c.undoer.redo()
    p = c.p
    assert p.back().h == 'A', 'fail 1-3'
    assert p.next().h == 'B', 'fail 2-3'
finally:
    if 0:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now(root)
</t>
<t tx="ekr.20080503073030.1">while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p.expand()
    c.setCurrentPosition(p2)
    c.moveOutlineLeft()
    moved = c.p
    assert moved.h == 'A','fail 1'
    # This assert fails because p4._childIndex != moved.back()._childIndex.
    assert moved.back() == p, 'fail 2: %s != %s' % (moved.back(),p4)
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()

    moved.doDelete(newNode=p)

finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
        c.redraw_now(p)
</t>
<t tx="ekr.20080503073030.2">while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p.expand()
    c.setCurrentPosition(p3)
    c.moveOutlineRight()
    moved = c.p
    assert moved.h == 'B', 'fail 1'
    assert moved.parent() == p2
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now(p)
</t>
<t tx="ekr.20080503082625.3">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p.expand()
    c.selectPosition(p3)
    c.deleteOutline()
    c.redraw_now()
    p = c.p
    assert p.h == 'A', 'fail 1: got %s' % p.h
    assert p.next().h == 'C', 'fail 2'
    c.undoer.undo()
    c.outerUpdate()
    p = c.p
    assert p.back() == p2, 'fail 4 %s' % p.back()
    assert p.next() == p4, 'fail 5'
    c.undoer.redo()
    c.outerUpdate()
    p = c.p
    assert p.h == 'A',          'fail 1-2'
    assert p.next().h == 'C',   'fail 2-2'
    c.undoer.undo()
    c.outerUpdate()
    p = c.p
    assert p.back() == p2,  'fail 4-2'
    assert p.next() == p4,  'fail 5-2'
    c.undoer.redo()
    c.outerUpdate()
    p = c.p
    assert p.h == 'A',          'fail 1-3'
    assert p.next().h == 'C',   'fail 2-3'

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now(root)
</t>
<t tx="ekr.20080503082625.4">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p3.insertAsNthChild(0)
    p4.setHeadString('child 1')
    p5 = p3.insertAsNthChild(1)
    p5.setHeadString('child 2')
    p.expand()
    p6 = p.insertAsNthChild(2)
    p6.setHeadString('C')
    c.setCurrentPosition(p3)
    c.promote()
    p = c.p
    assert p == p3,         'fail 1'
    assert p.h == 'B',      'fail 2'
    assert p.next().h=='child 1',            'fail 3'
    assert p.next().next().h == 'child 2',   'fail child 1'
    assert p.next().next().next().h == 'C',  'fail child 2'
    c.undoer.undo()
    p = c.p
    assert p == p3
    assert p.back() == p2,  'fail 5'
    assert p.next() == p6,  'fail 6'
    assert p.firstChild().h=='child 1',          'fail child 3'
    assert p.firstChild().next().h == 'child 2', 'fail child 4'
    c.undoer.redo()
    p = c.p
    assert p == p3,         'fail 1-2'
    assert p.h == 'B',      'fail 2-2'
    assert p.next().h=='child 1',            'fail 3-2'
    assert p.next().next().h == 'child 2',   'fail child 1-2'
    assert p.next().next().next().h == 'C',  'fail child 2-2'
    c.undoer.undo()
    p = c.p
    assert p == p3
    assert p.back() == p2,                      'fail 5-2'
    assert p.next() == p6,                      'fail 6-2'
    assert p.firstChild().h=='child 1',         'fail child 3-2'
    assert p.firstChild().next().h == 'child 2','fail child 4-2'
    c.undoer.redo()
    p = c.p
    assert p == p3,     'fail 1-3'
    assert p.h == 'B',  'fail 2-3'
    assert p.next().h=='child 1',            'fail 3-3'
    assert p.next().next().h == 'child 2',   'fail child 1-3'
    assert p.next().next().next().h == 'C',  'fail child 2-3'

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now(root)
</t>
<t tx="ekr.20080503082625.5">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p5 = p.insertAsNthChild(3)
    p5.setHeadString('D')
    p.expand()
    c.setCurrentPosition(p3)
    c.demote()
    p = c.p
    assert p == p3,         'fail 1'
    assert p.h == 'B',      'fail 2'
    assert not p.next(),    'fail 3'
    assert p.firstChild().h == 'C',          'fail child 1'
    assert p.firstChild().next().h == 'D',   'fail child 2'
    c.undoer.undo()
    p = c.p
    assert p == p3
    assert p.back() == p2, 'fail 5'
    assert p.next() == p4, 'fail 6'
    c.undoer.redo()
    assert p == p3,         'fail 1-2'
    assert p.h == 'B',      'fail 2-2'
    assert not p.next(),    'fail 3-2'
    assert p.firstChild().h == 'C',         'fail child 1-2'
    assert p.firstChild().next().h == 'D',  'fail child 2-2'
    c.undoer.undo()
    p = c.p
    assert p.back() == p2, 'fail 4-2'
    assert p.next() == p4, 'fail 5-2'
    c.undoer.redo()
    assert p == p3,         'fail 1-3'
    assert p.h == 'B',      'fail 2-3'
    assert not p.next(),    'fail 3-3'
    assert p.firstChild().h == 'C',         'fail child 1-3'
    assert p.firstChild().next().h == 'D',  'fail child 2-3'

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now(root)
</t>
<t tx="ekr.20080503132221.1"># cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('create-from-node no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    root = p.copy()
    # Init the children
    while p.hasChildren():
        p.firstChild().doDelete(newNode=None)
    child = p.insertAsNthChild(0)
    # c.setHeadString(child,'child') # Force the headline to update.
    child.h = 'child'
    child.b = '# child'
    # Kill the chapter so the test will not fail if run twice.
    chapter = cc.chaptersDict.get('new-chapter')
    if chapter:
        cc.removeChapterByName('new-chapter')
    try:
        c.selectPosition(child)
        c.chapterController.createChapterByName(
            'new-chapter',child,'Create Chapter From Node')
        if 0:
            c.undoer.undo()
            c.undoer.redo()
            c.undoer.undo()
            c.undoer.redo()
            c.undoer.undo() # Don't pollute future unit tests.
        else:
            c.redraw_now() # Required.
            chapterNode = cc.findChapterNode('new-chapter')
            assert chapterNode,'fail 1: %s' % (undoType)
            chapterNode.doDelete()
            c.redraw_now()
    finally:
        cc.selectChapterByName('main',collapse=True)
        if 1: # Do this so the activeUnitTests.txt does not change.
            while root.hasChildren():
                root.firstChild().doDelete(newNode=None)
        c.redraw_now()
else:
    self.skipTest('Can not be run locally')

</t>
<t tx="ekr.20080805104144.1">fc = c.fileCommands
child = p.firstChild()
grandChild = child.firstChild()
child.v.unknownAttributes = {'unit_test_child':'abcd'}
grandChild.v.unknownAttributes = {'unit_test_grandchild':'wxyz'}


try:
    s = fc.putDescendentVnodeUas (p)
    
    if 0: # This test is too flaky to be useful.
        if g.isPython3:
            expected = ' descendentVnodeUnknownAttributes=\
7d7100285803000000302e3071017d7102580f000000756e6974\
5f746573745f6368696c64710358040000006162636471047358\
05000000302e302e3071057d71065814000000756e69745f7465\
73745f6772616e646368696c64710758040000007778797a710873752e"'
        else:
            expected = ' descendentVnodeUnknownAttributes="\
7d7100285503302e3071017d7102550f756e69745f746573745f\
6368696c6471035504616263647104735505302e302e3071057d\
71065514756e69745f746573745f6772616e646368696c647107\
55047778797a710873752e"'
    
        assert s == expected, 'expected: %s, got: %s' % (repr(expected),repr(s))
finally:
    del child.v.unknownAttributes
    del grandChild.v.unknownAttributes
</t>
<t tx="ekr.20080805104144.2"></t>
<t tx="ekr.20080805104144.3"></t>
<t tx="ekr.20080805105541.1">val = p.archivedPosition(root_p=p)
assert val == [0],'expected %s, got %s' % ([0],val)

i = 0
for z in p.parent().children_iter():
    val = z.archivedPosition(root_p=p.parent())
    assert val == [0,i],'expected %s, got %s'%([0,i],val)
    i += 1

i = 0
for z in p.children_iter():
    val = z.archivedPosition(root_p=p)
    assert val == [0,i],'expected %s, got %s'%([0,i],val)
    i += 1

i = 0
for z in p.firstChild().next().children_iter():
    val = z.archivedPosition(root_p=p)
    assert val == [0,1,i],'expected %s, got %s'%([0,1,i],val)
    i += 1
</t>
<t tx="ekr.20080805122315.1"></t>
<t tx="ekr.20080805122315.2"></t>
<t tx="ekr.20080805122315.3"></t>
<t tx="ekr.20080805122315.4"></t>
<t tx="ekr.20080806072412.1">child1 = p.firstChild()
child2 = p.firstChild().next()
grandChild1 = child2.firstChild()
grandChild2 = grandChild1.next()
greatGrandChild11 = grandChild1.firstChild()
greatGrandChild12 = greatGrandChild11.next()
greatGrandChild21 = grandChild2.firstChild()
greatGrandChild22 = greatGrandChild21.next()
root_v = p.v

table = (
    # Errors.
    (None,'-1'),
    (None,'1'),
    (None,'0.2'),
    (None,'0.0.0'),
    (None,'0.1.2'),
    # Valid.
    (root_v,'0'),
    (child1.v,'0.0'),
    (child2.v,'0.1'),
    (grandChild1.v,'0.1.0'),
    (greatGrandChild11.v,'0.1.0.0'),
    (greatGrandChild12.v,'0.1.0.1'),
    (grandChild2.v,'0.1.1'),
    (greatGrandChild21.v,'0.1.1.0'),
    (greatGrandChild22.v,'0.1.1.1'),
)

for v,archivedPosition in table:
    v2 = c.fileCommands.resolveArchivedPosition(archivedPosition,root_v)
    assert v == v2,'got %s, expected %s' % (v2,v)
</t>
<t tx="ekr.20080806072412.2"></t>
<t tx="ekr.20080806072412.3"></t>
<t tx="ekr.20080806072412.4"></t>
<t tx="ekr.20080806072412.5"></t>
<t tx="ekr.20080806080425.1"></t>
<t tx="ekr.20080806080425.2"></t>
<t tx="ekr.20080806080425.3"></t>
<t tx="ekr.20080806080425.4"></t>
<t tx="ekr.20080904084223.1"># changed.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20080904102243.2">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080904102243.3">def child():
    pass
</t>
<t tx="ekr.20080905130723.3">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080905130723.4">def child():
    pass
</t>
<t tx="ekr.20080907122804.1">@others</t>
<t tx="ekr.20080907123324.2">@language python
@tabwidth -4
# before @others: line 1
@others
# last line: line 6</t>
<t tx="ekr.20080907123324.3">def spam(): # line 2
    pass
</t>
<t tx="ekr.20080917151620.13">@header

aList = g.get_directives_dict_list(p)
g.scanAtHeaderDirectives(aList)
</t>
<t tx="ekr.20080917151620.14">@noheader

aList = g.get_directives_dict_list(p)
g.scanAtHeaderDirectives(aList)
</t>
<t tx="ekr.20080917151620.15">@lineending cr

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\r'
</t>
<t tx="ekr.20080917151620.16">@lineending crlf

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)
assert s == '\r\n', repr(s)

</t>
<t tx="ekr.20080917151620.17">@lineending lf

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\n'
</t>
<t tx="ekr.20080917151620.18">@lineending nl

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\n'
</t>
<t tx="ekr.20080917151620.19">@lineending platform

import sys

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

if sys.platform.startswith('win'):
    assert s == '\r\n'
else:
    assert s == '\n'
</t>
<t tx="ekr.20080917151620.21">@pagewidth 40

aList = g.get_directives_dict_list(p)
n = g.scanAtPagewidthDirectives(aList)

assert n == 40
</t>
<t tx="ekr.20080917151620.22">aList = g.get_directives_dict_list(p.firstChild())
s = c.scanAtPathDirectives(aList)
end = g.os_path_normpath(r'leo/test')

assert s.endswith(end),repr(s)
</t>
<t tx="ekr.20080917151620.24">grandChild = p.firstChild().firstChild()
aList = g.get_directives_dict_list(grandChild)
s = c.scanAtPathDirectives(aList)
end = g.os_path_normpath(r'leo/test/unittest')

assert s.endswith(end),repr(s)
</t>
<t tx="ekr.20080917151620.25"></t>
<t tx="ekr.20080917151620.27">greatGrandChild = p.firstChild().firstChild().firstChild()
aList = g.get_directives_dict_list(greatGrandChild)
s = c.scanAtPathDirectives(aList)
end = g.os_path_normpath(r'leo/test/unittest')

assert s.endswith(end),repr(s)
</t>
<t tx="ekr.20080917151620.28"></t>
<t tx="ekr.20080917151620.29"></t>
<t tx="ekr.20080917151620.31">@tabwidth 6

aList = g.get_directives_dict_list(p)
n = g.scanAtTabwidthDirectives(aList)

assert n == 6,repr(n)
</t>
<t tx="ekr.20080917151620.32">@tabwidth -6

aList = g.get_directives_dict_list(p)
n = g.scanAtTabwidthDirectives(aList)

assert n == -6
</t>
<t tx="ekr.20080917151620.33">@nowrap

aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is False,repr(s)
</t>
<t tx="ekr.20080917151620.34">@wrap

aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is True,repr(s)
</t>
<t tx="ekr.20080917151620.35">aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is None,repr(s)
</t>
<t tx="ekr.20080917151620.9">@language python
@comment a b c
    # @comment must follow @language
@tabwidth -4
@pagewidth 72
@encoding utf-8
@lineending crlf

d = c.scanAllDirectives(p)

table = (
    ('delims', ('a','b','c'),),
    ('encoding','utf-8'),
    ('language','python'),
    ('lineending','\r\n'),
    ('pagewidth',72),
    ('tabwidth',-4),
)

for kind,expected in table:
    got = d.get(kind)
    assert got == expected, 'kind: %s, expected %s, got %s' % (
        kind,repr(expected),repr(got))
</t>
<t tx="ekr.20081001094920.2"></t>
<t tx="ekr.20081001094920.3"># Change @file activeUnitTests.txt to @@file activeUnitTests.txt
for parent in p.parents():
    if parent.isAnyAtFileNode():
        parent.h = '@' + parent.h
        break
else:
    parent = None
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
try:
    p1 = p.insertAsLastChild()
    assert p1.textOffset() is None
finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    if parent:
        parent.h = parent.h[1:]
    c.redraw_now()
</t>
<t tx="ekr.20081001094920.4">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
try:
    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    assert p1.textOffset() == 0
finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()
</t>
<t tx="ekr.20081001094920.5">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
try:
    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    p2 = p1.insertAsLastChild()
    assert p1.textOffset() == 0
    assert p2.textOffset() == 0
finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()
</t>
<t tx="ekr.20081001094920.6">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
try:
    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    body = '''   %s
    ''' % (g.angleBrackets(' section '))
    p1.setBodyString(body)
    p2 = p1.insertAsLastChild()
    head = g.angleBrackets(' section ')
    p2.setHeadString(head)
    assert p1.textOffset() == 0
    assert p2.textOffset() == 3
        # Section nodes can appear in with @others nodes,
        # so they don't get special treatment.
finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()
</t>
<t tx="ekr.20081001094920.7">root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)
try:
    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    body = '''     %s
    ''' % (chr(64) + 'others') # ugly hack
    p1.setBodyString(body)
    p2 = p1.insertAsLastChild()
    assert p1.textOffset() == 0
    assert p2.textOffset() == 5
    root.firstChild().doDelete(newNode=None)
finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()
</t>
<t tx="ekr.20081111084046.2"></t>
<t tx="ekr.20081111150402.11"># Print does not work with the curses gui: it is redirected.
g.pr('\nall unit tests done', color='blue')
</t>
<t tx="ekr.20081215084144.10">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20081215084144.2">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20081215084144.3">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20081215084144.4">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20081215084144.5">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20081215084144.7">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20081215084144.8">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20081215084144.9">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20090102061858.2">child = p.insertAsLastChild()
assert c.positionExists(child)
child.doDelete()
assert not c.positionExists(child),'fail 1'

# also check the same on root level
child = c.rootPosition().insertAfter()
assert c.positionExists(child)
child.doDelete()
assert not c.positionExists(child),'fail 2'
</t>
<t tx="ekr.20090102062037.2">for p in c.all_positions():
    assert c.positionExists(p)
        # 2012/03/08: If a root is given, the search is confined to that root only.

</t>
<t tx="ekr.20090104053806.1"># Disabled because modifying errorTest.py creates annoying bzr conflicts.

import os

path = g.os_path_finalize_join(g.app.testDir,'unittest','errorTest.py')
assert g.os_path_exists(path),path
timeStamp = c.timeStampDict.get(path)
val = c.checkFileTimeStamp(path)
assert val == True

f = open(path)
s = f.read()
lines = g.splitLines(s)
result = [] ; found = False
tag = '# timestamp:'
for line in lines:
    if line.startswith(tag):
        timeStamp = os.path.getmtime(path)
        result.append('%s %s\n' % (tag,timeStamp))
        found = True
    else:
        result.append(line)
f.close()

assert found,' no line starts with "%s"' % tag

f = open(path,'w')
f.write(''.join(result))
f.close()

timeStamp2 = os.path.getmtime(path)
assert timeStamp != timeStamp2
val = c.checkFileTimeStamp(path)
assert not val,repr(val)
c.setFileTimeStamp(path)
val = c.checkFileTimeStamp(path)
assert val,repr(val)
</t>
<t tx="ekr.20090130133404.2">v = p.v
b = p.b
p.b = b
assert p.b == b
v.b = b
assert v.b == b

h = p.h
p.h = h
assert p.h == h
v.h = h
assert v.h == h

for p in c.all_positions():
    assert p.b == p.bodyString()
    assert p.v.b == p.v.bodyString()
    assert p.h == p.headString()
    assert p.v.h == p.v.headString()
</t>
<t tx="ekr.20090225102051.2">c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20090225102051.3">Line 1

Last line: no newline
</t>
<t tx="ekr.20090225102051.4">Line 1

Last line: no newline
</t>
<t tx="ekr.20090306091634.1">tree = c.frame.tree
if hasattr(tree,'redrawCount'):
    print('%s: %s' % (p.h,tree.redrawCount))
</t>
<t tx="ekr.20090427104851.10">if a:
    b = 'xyz'
</t>
<t tx="ekr.20090427104851.11">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20090427104851.12">if a:
    b = 'xyz'
</t>
<t tx="ekr.20090427104851.13">if a:
    b = 'xyz'
</t>
<t tx="ekr.20090427104851.14">if a:
    b = 'xyz'
</t>
<t tx="ekr.20090427104851.15">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20090427104851.16">if a:
    b = 'xyz'
</t>
<t tx="ekr.20090427104851.17">if a:
    b = 'xyz'
</t>
<t tx="ekr.20090427104851.18">if a:
    b = 'xyz'
</t>
<t tx="ekr.20090427104851.7">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20090427104851.8">if a:
    b = 'xyz'
</t>
<t tx="ekr.20090427104851.9">if a:
    b = 'xyz'
</t>
<t tx="ekr.20090507084947.5152">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    # new_gnxs:
    assert p.v.fileIndex == 'ekr.20090507084947.5152',p.v.fileIndex
    # old gnxs:
    # assert p.v.fileIndex == ('ekr', '20090507084947', 5152)
</t>
<t tx="ekr.20090529115704.4396"></t>
<t tx="ekr.20090529115704.4397">import unittest
import leo.core.leoShadow as leoShadow
# Possible: replace this suite with individual @test nodes
# exec(g.findTestScript(c,'@common @shadow test code'))
x = c.shadowController
suite = unittest.makeSuite(unittest.TestCase)
root = g.findNodeInTree(c,p,'@shadow-tests')
assert root, 'Node not found: @shadow-tests'
for p in root.children_iter():
    h = p.h.strip()
    if h.startswith('@shadow-test'):
        test = x.AtShadowTestCase(c,p,x,trace=False)
        suite.addTest(test)
</t>
<t tx="ekr.20090529115704.4398">@

All the tags should be tested at least once (equal, replace, delete, insert).

The replace, delete, insert operations should happen at least once:
    1. At the beginning of a node.
    2. In the middle of a node.
    3. At the end of a node.

For the delete and replace operators we must also test the case that the
deletion or replacement spans more than one block.
</t>
<t tx="ekr.20090529115704.4400"></t>
<t tx="ekr.20090529115704.4401">line 1
line 2
line 3
</t>
<t tx="ekr.20090529115704.4402">line 1
line 2 changed
line 3
</t>
<t tx="ekr.20090529115704.4403"></t>
<t tx="ekr.20090529115704.4404">line 1
line 2
line 3
</t>
<t tx="ekr.20090529115704.4405">line 1 changed
line 2
line 3
</t>
<t tx="ekr.20090529115704.4406"></t>
<t tx="ekr.20090529115704.4407">line 1
line 2
line 3
</t>
<t tx="ekr.20090529115704.4408">line 1
line 2
line 3 changed
</t>
<t tx="ekr.20090529115704.4409"></t>
<t tx="ekr.20090529115704.4410">line 1
line 2
line 3
</t>
<t tx="ekr.20090529115704.4411">line 2
line 3
</t>
<t tx="ekr.20090529115704.4412"></t>
<t tx="ekr.20090529115704.4413">line 1
line 2
line 3
</t>
<t tx="ekr.20090529115704.4414">line 1
line 3
</t>
<t tx="ekr.20090529115704.4415"></t>
<t tx="ekr.20090529115704.4416">line 1
line 2
line 3
</t>
<t tx="ekr.20090529115704.4417">line 1
line 2
</t>
<t tx="ekr.20090529115704.4418"></t>
<t tx="ekr.20090529115704.4419">line 1
line 2
line 3
</t>
<t tx="ekr.20090529115704.4420">inserted line
line 1
line 2
line 3
</t>
<t tx="ekr.20090529115704.4421"></t>
<t tx="ekr.20090529115704.4422">line 1
line 2
line 3
</t>
<t tx="ekr.20090529115704.4423">line 1
inserted line
line 2
line 3
</t>
<t tx="ekr.20090529115704.4424"></t>
<t tx="ekr.20090529115704.4425">line 1
line 2
line 3
</t>
<t tx="ekr.20090529115704.4426">line 1
line 2
inserted line
line 3
</t>
<t tx="ekr.20090529115704.4427"></t>
<t tx="ekr.20090529115704.4428">line 1
line 2
line 3
</t>
<t tx="ekr.20090529115704.4429">line 1
line 2
line 3
inserted line
</t>
<t tx="ekr.20090529115704.4430"></t>
<t tx="ekr.20090529115704.4431">@others
</t>
<t tx="ekr.20090529115704.4432">node 1 line 1
</t>
<t tx="ekr.20090529115704.4433">node 2 line 1
</t>
<t tx="ekr.20090529115704.4434">@others
</t>
<t tx="ekr.20090529115704.4435">node 1 line 1
inserted node at end of node 1
</t>
<t tx="ekr.20090529115704.4436">node 2 line 1
</t>
<t tx="ekr.20090529115704.4444"></t>
<t tx="ekr.20090529115704.4445">@others
</t>
<t tx="ekr.20090529115704.4446">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20090529115704.4447">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4448">@others
</t>
<t tx="ekr.20090529115704.4449">node 1 line 1
</t>
<t tx="ekr.20090529115704.4450">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4451"></t>
<t tx="ekr.20090529115704.4452">@others
</t>
<t tx="ekr.20090529115704.4453">node 1 line 1
</t>
<t tx="ekr.20090529115704.4454">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4455">@others
</t>
<t tx="ekr.20090529115704.4456">node 1 line 1
</t>
<t tx="ekr.20090529115704.4457">node 2 line 2
</t>
<t tx="ekr.20090529115704.4458"></t>
<t tx="ekr.20090529115704.4459">@others
</t>
<t tx="ekr.20090529115704.4460">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20090529115704.4461">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4462">@others
</t>
<t tx="ekr.20090529115704.4463">node 1 line 1
node 1 line 1 changed
</t>
<t tx="ekr.20090529115704.4464">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4465"></t>
<t tx="ekr.20090529115704.4466">@others
</t>
<t tx="ekr.20090529115704.4467">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20090529115704.4468">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4469">@others
</t>
<t tx="ekr.20090529115704.4470">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20090529115704.4471">node 2 line 1 changed
node 2 line 2
</t>
<t tx="ekr.20090529115704.4472"></t>
<t tx="ekr.20090529115704.4473">@others
</t>
<t tx="ekr.20090529115704.4474">node 1 line 1
inserted node 1 at end of node 1
inserted node 2 at end of node 1
</t>
<t tx="ekr.20090529115704.4475">node 2 line 1
</t>
<t tx="ekr.20090529115704.4476">@others
</t>
<t tx="ekr.20090529115704.4477">node 1 line 1
</t>
<t tx="ekr.20090529115704.4478">node 2 line 1
</t>
<t tx="ekr.20090529115704.4486"></t>
<t tx="ekr.20090529115704.4487">@others
</t>
<t tx="ekr.20090529115704.4488">node 1 line 1
node 1 line 2
node 1 line 3
</t>
<t tx="ekr.20090529115704.4489">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4490">@others
</t>
<t tx="ekr.20090529115704.4491">node 1 line 1
node 1 line 2 changed
node 1 line 3 changed
</t>
<t tx="ekr.20090529115704.4492">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4493"></t>
<t tx="ekr.20090529115704.4494">@others
</t>
<t tx="ekr.20090529115704.4495">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20090529115704.4496">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4497">@others
</t>
<t tx="ekr.20090529115704.4498">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20090529115704.4499">node 2 line 1 changed
node 2 line 2 changed
</t>
<t tx="ekr.20090529115704.4500"></t>
<t tx="ekr.20090529115704.4501">@others
</t>
<t tx="ekr.20090529115704.4502">node 1 line 1
node 1 line 2
node 1 line 3
</t>
<t tx="ekr.20090529115704.4503">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4504">@others
</t>
<t tx="ekr.20090529115704.4505">node 1 line 1
</t>
<t tx="ekr.20090529115704.4506">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4507"></t>
<t tx="ekr.20090529115704.4508">@others
</t>
<t tx="ekr.20090529115704.4509">node 1 line 1
</t>
<t tx="ekr.20090529115704.4510">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20090529115704.4511">@others
</t>
<t tx="ekr.20090529115704.4512">node 1 line 1
</t>
<t tx="ekr.20090529115704.4513">node 2 line 3
</t>
<t tx="ekr.20090529115704.4514"></t>
<t tx="ekr.20090529115704.4515">@others
</t>
<t tx="ekr.20090529115704.4516">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3
</t>
<t tx="ekr.20090529115704.4517">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20090529115704.4518">@others
</t>
<t tx="ekr.20090529115704.4519">node 1 line 1
line 1 line 3
</t>
<t tx="ekr.20090529115704.4520">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20090529115704.4521"></t>
<t tx="ekr.20090529115704.4522">@others
</t>
<t tx="ekr.20090529115704.4523">node 1 line 1
</t>
<t tx="ekr.20090529115704.4524">@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
node 2 line 2
</t>
<t tx="ekr.20090529115704.4525">@others
</t>
<t tx="ekr.20090529115704.4526">node 1 line 1
</t>
<t tx="ekr.20090529115704.4527">node 2 line 2
</t>
<t tx="ekr.20090529115704.4528"></t>
<t tx="ekr.20090529115704.4529">@others
</t>
<t tx="ekr.20090529115704.4530">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3
</t>
<t tx="ekr.20090529115704.4531">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20090529115704.4532">@others
</t>
<t tx="ekr.20090529115704.4533">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3
</t>
<t tx="ekr.20090529115704.4534">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20090529115704.4535"></t>
<t tx="ekr.20090529115704.4536">@others
</t>
<t tx="ekr.20090529115704.4537">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
</t>
<t tx="ekr.20090529115704.4538">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4539">@others
</t>
<t tx="ekr.20090529115704.4540">node 1 line 1
</t>
<t tx="ekr.20090529115704.4541">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4542"># This fails because the @all read logic inserts a second verbatim, I think.
</t>
<t tx="ekr.20090529115704.4543">@others
</t>
<t tx="ekr.20090529115704.4544">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20090529115704.4545">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4546">@others
</t>
<t tx="ekr.20090529115704.4547">node 1 line 1
@verbatim
#@ should be handled by verbatim
node 1 line 2
</t>
<t tx="ekr.20090529115704.4548">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20090529115704.4550">x = c.shadowController
path = x.baseDirName()
expected = g.os_path_dirname(g.os_path_abspath(g.os_path_join(c.fileName())))
assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)
</t>
<t tx="ekr.20090529115704.4551">x = c.shadowController
filename = 'xyzzy'
path = x.pathName(filename)
expected = g.os_path_abspath(g.os_path_join(x.baseDirName(),filename))
assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)
</t>
<t tx="ekr.20090529115704.4552">x = c.shadowController
filename = 'xyzzy'
path = x.dirName(filename)
expected = g.os_path_dirname(g.os_path_abspath(
    g.os_path_join(g.os_path_dirname(c.fileName()),filename)))
assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)
</t>
<t tx="ekr.20090529115704.4553">x = c.shadowController
subdir = c.config.getString('shadow_subdir') or '.leo_shadow'
prefix = c.config.getString('shadow_prefix') or ''
filename = 'xyzzy'
path = x.shadowPathName(filename)
expected = g.os_path_abspath(g.os_path_join(
    g.os_path_dirname(c.fileName()),subdir,prefix+filename))
assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)
</t>
<t tx="ekr.20090529115704.4554">x = c.shadowController
subdir = c.config.getString('shadow_subdir') or '.leo_shadow'
prefix = c.config.getString('shadow_prefix') or ''
filename = 'xyzzy'
path = x.shadowDirName(filename)
expected = g.os_path_abspath(
    g.os_path_join(g.os_path_dirname(c.fileName()),subdir))
assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)
</t>
<t tx="ekr.20090529115704.4555">if 0: # x.rename no longer exists
    x = c.shadowController

    filename = x.pathName('xyzzy')
    assert not g.os_path_exists(filename)
    n = x.errors
    x.rename('xyzzy','xyzzy2',silent=True)
    assert x.errors == n+1
    assert x.last_error.startswith('can not rename')
    # print(x.last_error)
</t>
<t tx="ekr.20090529115704.4556">x = c.shadowController
filename = x.pathName('xyzzy')
assert not g.os_path_exists(filename)
n = x.errors
x.unlink('xyzzy',silent=True)
assert x.errors == n+1
assert x.last_error.startswith('can not delete xyzzy'), x.last_error

</t>
<t tx="ekr.20090529115704.4557">import glob
import os

x = c.shadowController

@others

shadow_fn  = x.shadowPathName('unittest/xyzzy/test.py')
shadow_dir = x.shadowDirName('unittest/xyzzy/test.py')

if g.os_path_exists(shadow_fn):
    g.utils_remove(shadow_fn,verbose=True)
    assert not os.path.exists(shadow_fn),'still exists: %s' % shadow_fn

deleteShadowDir(shadow_dir)

x.makeShadowDirectory(shadow_dir)
assert os.path.exists(shadow_dir)

deleteShadowDir(shadow_dir)
</t>
<t tx="ekr.20090529115704.4558">def deleteShadowDir(shadowDir):

    if g.os_path_exists(shadow_dir):
        files = g.os_path_abspath(g.os_path_join(shadow_dir,"*.*"))
        files = glob.glob(files)
        for z in files:
            if z != shadow_dir:
                # g.trace(z)
                os.unlink(z)
        # g.trace(shadow_dir)
        os.rmdir(shadow_dir)
        assert not os.path.exists(shadow_dir),'still exists: %s' % shadow_dir
</t>
<t tx="ekr.20090529115704.4559">x = c.shadowController
s = 'abc'

fn = '../test/unittest/replaceFileWithStringTestFile.py'
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,fn))

x.replaceFileWithString(path,s)
f = open(path)
s2 = f.read()
f.close()
assert s == s2
</t>
<t tx="ekr.20090529115704.4560">x = c.shadowController

lines1 = ('a','b','c')
lines2 = ('a','x','c')

x.show_error(
    lines1,lines2,
    message = "Test of x.show_error",
    lines1_message = "lines1",
    lines2_message = "lines2")
</t>
<t tx="ekr.20090529115704.4562">at = c.atFileCommands

# at.toString is set by the execute-script command.
# at.outputFile = f = g.fileLikeObject() # Re-allocate for the test.
f = at.openStringFile('abc')
assert isinstance(f,g.fileLikeObject)
s = 'abc'
f.write(s)
s2 = at.closeStringFile(f)
assert s == s2,s2
# assert at.toString
</t>
<t tx="ekr.20090529115704.4563">at = c.atFileCommands
x = c.shadowController
filename = x.pathName('xyzzy')
assert not g.os_path_exists(filename)
try:
    kind,theFile = at.openForWrite(filename)
    assert kind == 'check'
    if theFile: theFile.close()
finally:
    if g.os_path_exists(filename):
        x.unlink(filename)
        assert not g.os_path_exists(filename)
</t>
<t tx="ekr.20090529115704.4564">at = c.atFileCommands
x = c.shadowController

changed = c.changed
child = p.firstChild()
s = child.b

try:
    fn = 'unittest/read_test.py'
    child.setHeadString('@shadow %s' % fn)
    at.writeOneAtShadowNode(child,toString=False,force=True)
    at.readOneAtShadowNode(fn,child)
finally:
    child.setHeadString('@@shadow %s' % fn)
    c.setChanged(changed)
</t>
<t tx="ekr.20090529115704.4565">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20090529115704.4566">import os
s = 'abc'
fn = 'unitTestFile.py'
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','unittest',fn))
try:
    c.atFileCommands.replaceFileWithString(path,s)
    f = open(path)
    s2 = f.read()
    f.close()
    assert s == s2
finally:
    if g.os_path_exists(path):
        os.unlink(path)
</t>
<t tx="ekr.20090529115704.4567">at = c.atFileCommands
x = c.shadowController
changed = c.changed
child = p.firstChild()
s = child.b

try:
    child.setHeadString('@shadow unittest/test_1.py')
    fn = 'unittest/test_1.py'
    shadow_fn = x.shadowPathName(fn)
    shadow_dir = x.shadowDirName(fn)
    x.makeShadowDirectory(shadow_dir)
    if g.os_path_exists(shadow_fn):
        g.utils_remove(shadow_fn,verbose=True)
    at.writeOneAtShadowNode(child,toString=True,force=True)
    assert at.startSentinelComment == '#','startSentinelComment: %s' % (
        repr(at.startSentinelComment))
    assert at.endSentinelComment == '','endSentinelComment: %s' % (
        repr(at.endSentinelComment))
    if 0:
        print('public...\n',at.public_s)
        print('private...\n',at.private_s)
    at.writeOneAtShadowNode(child,toString=False,force=True)
    assert g.os_path_exists(shadow_fn),'not found: %s' % shadow_fn
    # No need to remove this: it's in the unittest directory.
    # g.utils_remove(shadow_fn,verbose=True)
finally:

    child.setHeadString('@@shadow unittest/test_1.py')
    c.setChanged(changed)
    # c.redraw_now()
</t>
<t tx="ekr.20090529115704.4568"># body of @shadow test node
# The last line.
</t>
<t tx="ekr.20090529141856.4682"></t>
<t tx="ekr.20090529141856.4684">@language python
@tabwidth -4
</t>
<t tx="ekr.20090529141856.4685"># Create unit tests in g.app.scriptDict["suite"]

suite = c.testManager.makeImportExportSuite("exportTests",doImport=False)

# g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20090529141856.4698"></t>
<t tx="ekr.20090529141856.4699"># Create unit tests in g.app.scriptDict["suite"]

suite = c.testManager.makeImportExportSuite("importTests",doImport=True)

# g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20090529141856.4716">@tabwidth -4
@language python
</t>
<t tx="ekr.20090529141856.4717"></t>
<t tx="ekr.20090529141856.4718">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
class cTestClass1 {

    int foo (int a) {
        a = 2 ;
    }

    char bar (float c) {
        ;
    }
}
'''
table = (
    'class cTestClass1',
    'int foo',
    'char bar',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4719">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
class cTestClass1 {

    int foo (int a) {
// an underindented line.
        a = 2 ;
    }

    // This should go with the next function.

    char bar (float c) {
        ;
    }
}
'''
table = (
    'class cTestClass1',
    'int foo',
    'char bar',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4721">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) //  &lt;---------------------problem
{
    return true;
}
'''
table = (
    'void aaa::bbb::doit',
    'bool aaa::bbb::dothat',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children 
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4722">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) 
{
    return true;
} //  &lt;---------------------problem
'''
table = (
    'void aaa::bbb::doit',
    'bool aaa::bbb::dothat',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4723">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
s = '''
void
aaa::bbb::doit
    (
    awk* b  // leading blank
    )
{
	assert(false); // leading tab
}

'''
table = (
    'void aaa::bbb::doit',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4724">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
static void
ReleaseCharSet(cset)
    CharSet *cset;
{
    ckfree((char *)cset-&gt;chars);
    if (cset-&gt;ranges) {
    ckfree((char *)cset-&gt;ranges);
    }
}
'''
table = (
    'static void ReleaseCharSet',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4725">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
Tcl_Obj *
Tcl_NewLongObj(longValue)
    register long longValue;	/* Long integer used to initialize the
         * new object. */
{
    return Tcl_DbNewLongObj(longValue, "unknown", 0);
}
'''
table = (
    'Tcl_Obj * Tcl_NewLongObj',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4726">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.c)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
extern "C"
{
#include "stuff.h"
void    init(void);
#include "that.h"
}
'''
table = (
    'extern "C"',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4727"></t>
<t tx="ekr.20090529141856.4728">s = '''\
namespace {
    class cTestClass1 {
        ;
    }
}
'''
try:
    c.importCommands.cSharpUnitTest(p,s=s,showTree=True)
    table = [
        'namespace',
        'class cTestClass1',
    ]
    root = c.p.firstChild()
    assert root.h.endswith('c# namespace indent'), root.h
    p2 = root.firstChild()
    for i, h in enumerate(table):
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20090529141856.4729">s = '''\
namespace {
class cTestClass1 {
    ;
}
}
'''
try:
    c.importCommands.cSharpUnitTest(p,s=s,showTree=True)
    table = [
        'namespace',
        'class cTestClass1',
    ]
    root = c.p.firstChild()
    assert root.h.endswith('c# namespace no indent'), root.h
    p2 = root.firstChild()
    for i, h in enumerate(table):
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20090529141856.4730">import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(
        g.app.loadDir,'..','test','big-c#-test.c#'))
    f = open(fileName)
    s = f.read()
    f.close()
    c.importCommands.cSharpUnitTest(p,s=s,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20090529141856.4731"></t>
<t tx="ekr.20090529141856.4733">if 0:
    # The preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.elisp
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.elisp)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
;;; comment
;;; continue
;;;

(defun abc (a b)
   (+ 1 2 3))

; comm
(defun cde (a b)
   (+ 1 2 3))
'''

table = (
    'defun abc',
    'defun cde',
)
try:
    ic.elispUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()

</t>
<t tx="ekr.20090529141856.4734"></t>
<t tx="ekr.20090529141856.4735">if 0:
    # The preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.pascal
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.pascal)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''
unit Unit1;

interface

uses
Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
Forms,
Dialogs;

type
TForm1 = class(TForm)
procedure FormCreate(Sender: TObject);
private
{ Private declarations }
public
{ Public declarations }
end;

var
Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.FormCreate(Sender: TObject);
var
x,y: double;
begin
x:= 4;
Y := x/2;
end;

end. // interface
'''
table = (
    'interface',
    'procedure FormCreate',
    'procedure TForm1.FormCreate',
)
try:
    ic.pascalUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20090529141856.4736">
</t>
<t tx="ekr.20090529141856.4766"></t>
<t tx="ekr.20090529141856.4767">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.java)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
interface Bicycle {
    void changeCadence(int newValue);
    void changeGear(int newValue);
}
'''
table = (
    'interface Bicycle',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4768">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.java)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
interface Bicycle {
void changeCadence(int newValue);
void changeGear(int newValue);
}
'''
table = (
    'interface Bicycle',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4769">import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','constants.java'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=None,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20090529141856.4770">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.java)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
/**
 * Indicates the caller's authority to perform lifecycle operations on
 */

public final class AdminPermission extends BasicPermission
{
    /**
     * Creates a new &lt;tt&gt;AdminPermission&lt;/tt&gt; object.
     */
    public AdminPermission()
    {
        super("AdminPermission");
    }
}
'''
table = (
    'public final class AdminPermission extends BasicPermission',
    'public AdminPermission',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4771">import sys

if sys.platform.lower().startswith('win'):


    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','AdminPermission.java'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=s,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20090529141856.4773">@language python
@tabwidth 8
    # Must be in this node when run externally.
    
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.java)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
/*
 * $Header: /cvs/leo/test/unitTest.leo,v 1.247 2008/02/14 14:59:04 edream Exp $
 * 
 * Copyright (c) OSGi Alliance (2000, 2005). All Rights Reserved.
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this 
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html.
 */

package org.osgi.framework;

/**
 * A Framework exception used to indicate that a bundle lifecycle problem
 * occurred.
 * 
 * &lt;p&gt;
 * &lt;code&gt;BundleException&lt;/code&gt; object is created by the Framework to denote
 * an exception condition in the lifecycle of a bundle.
 * &lt;code&gt;BundleException&lt;/code&gt;s should not be created by bundle developers.
 * 
 * &lt;p&gt;
 * This exception is updated to conform to the general purpose exception
 * chaining mechanism.
 * 
 * @version $Revision: 1.247 $
 */

public class BundleException extends Exception {
	static final long	serialVersionUID	= 3571095144220455665L;
	/**
	 * Nested exception.
	 */
	private Throwable	cause;

	/**
	 * Creates a &lt;code&gt;BundleException&lt;/code&gt; that wraps another exception.
	 * 
	 * @param msg The associated message.
	 * @param cause The cause of this exception.
	 */
	public BundleException(String msg, Throwable cause) {
		super(msg);
		this.cause = cause;
	}
}

'''
table = (
    'public class BundleException extends Exception',
    'public BundleException',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4774">@language python
</t>
<t tx="ekr.20090529141856.4775">@language javascript

// regexps that look like section references.

{
	name: "macro",
	match: "&lt;&lt;",
	lookaheadRegExp: /&lt;&lt;([^&gt;\s]+)(?:\s*)((?:[^&gt;]|(?:&gt;(?!&gt;)))*)&gt;&gt;/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch &amp;&amp; lookaheadMatch.index == w.matchStart &amp;&amp; lookaheadMatch[1]) {
			w.nextMatch = this.lookaheadRegExp.lastIndex;
			invokeMacro(w.output,lookaheadMatch[1],lookaheadMatch[2],w,w.tiddler);
		}
	}
},

// Comments that look like section references.

// &lt;&lt;gradient [[tiddler name]] vert|horiz rgb rgb rgb rgb... &gt;&gt;

config.macros.gradient.handler = function(place,macroName,params,wikifier)
{
	var panel = wikifier ? createTiddlyElement(place,"div",null,"gradient") : place;
	panel.style.position = "relative";
	panel.style.overflow = "hidden";
	panel.style.zIndex = "0";
	if(wikifier) {
		var styles = config.formatterHelpers.inlineCssHelper(wikifier);
		config.formatterHelpers.applyCssHelper(panel,styles);
	}
	var colours = [];
	for(var t=1; t&lt;params.length; t++) {
		var c = new RGB(params[t]);
		if(c)
			colours.push(c);
	}
	drawGradient(panel,params[0] != "vert",colours);
	if(wikifier)
		wikifier.subWikify(panel,"&gt;&gt;");
	if(document.all) {
		panel.style.height = "100%";
		panel.style.width = "100%";
	}
};

// @Deprecated: Use &lt;br&gt; or &lt;br /&gt; instead of &lt;&lt;br&gt;&gt;
config.macros.br = {};
config.macros.br.handler = function(place)
{
	createTiddlyElement(place,"br");
};
</t>
<t tx="ekr.20090529141856.4776">s = '''\

String.prototype.toJSONString = function()
{
    if(/["\\\\\\x00-\\x1f]/.test(this))
		return '"' + this.replace(/([\\x00-\\x1f\\"])/g,replaceFn) + '"';

	return '"' + this + '"';
};

'''


c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4777">s = '''\

// Convert a string to it's JSON representation by encoding control characters, double quotes and backslash. See json.org
String.prototype.toJSONString = function()
{
	var m = {
		'\\b': '\\\\b',
		'\\f': '\\\\f',
		'\\n': '\\\\n',
		'\\r': '\\\\r',
		'\\t': '\\\\t',
		'"' : '\\\\"',
		'\\\\': '\\\\\\\\'
		};
	var replaceFn = function(a,b) {
		var c = m[b];
		if(c)
			return c;
		c = b.charCodeAt();
		return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
		};
    if(/["\\\\\\x00-\\x1f]/.test(this))
		return '"' + this.replace(/([\\x00-\\x1f\\"])/g,replaceFn) + '"';

	return '"' + this + '"';
};

'''


c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4778">s = '''\

// Restarting
function restart()
{
	invokeParamifier(params,"onstart");
	if(story.isEmpty()) {
		var tiddlers = store.filterTiddlers(store.getTiddlerText("DefaultTiddlers"));
		for(var t=0; t&lt;tiddlers.length; t++) {
			story.displayTiddler("bottom",tiddlers[t].title);
		}
	}
	window.scrollTo(0,0);
}

'''


c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20090529141856.4780"></t>
<t tx="ekr.20090529141856.4781">s = '''\
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/head&gt;
&lt;body class='bodystring'&gt;
&lt;div id='bodydisplay'&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
ic = c.importCommands
table = (
    (1, "&lt;html&gt;"),
    (2, "&lt;head&gt;"),
    (2, "&lt;body class='bodystring'&gt;"),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.xmlUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20090529141856.4783"># Not a real unit test.
c.contractAllHeadlines()
</t>
<t tx="ekr.20090529141856.4784"></t>
<t tx="ekr.20090529141856.4785">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

====
top
====

The top section

section 1
---------

section 1, line 1
--
section 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''
table = (
    '!Dummy chapter',
    'top',
    'section 1',
    'section 2',
    'section 2.1',
    'section 2.1.1',
    'section 3',
    'placeholder',
    'section 3.1.1',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4786">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

top
====

The top section

section 1
---------

section 1, line 1
--
section 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''
table = (
    '!Dummy chapter',
    'top',
    'section 1',
    'section 2',
    'section 2.1',
    'section 2.1.1',
    'section 3',
    'placeholder',
    'section 3.1.1',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4787">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

top
-------------

The top section
'''
table = (
    '!Dummy chapter',
    'top',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4788">if 0: # Preamble
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

======
top
======

The top section
'''
table = (
    "!Dummy chapter",
    "top",
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4789">s = '''\
.. toc

.. The section name contains trailing whitespace.

======
top 
======

The top section.
'''
table = (
    "!Dummy chapter",
    "top",
)
try:
    c.importCommands.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4793">d = g.app.extra_extension_dict

for ext in g.app.extension_dict.keys():
    language =  c.importCommands.languageForExtension(ext)
    language2 = c.importCommands.languageForExtension('.'+ext)
    assert language == language2

    # Now a many-one relationship.
    if language:
        # Do not test extensions that have 'none' as the value of d.get(ext)
        # Otherwise, test only d.get(ext).
        language2 = d.get(ext)
        if language2 in ('None','none'):  continue
        if language2: language = language2
        # Made-up languages do not have mode files.
        if not language.endswith('_language') and language not in ('autohotkey','rest','rst','typescript',):
            path = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
            assert g.os_path_exists(path), 'for ext=%s does not exist: %s' % (ext,path)

    if 0:
        if language is None:
            print('no language for ext=%s' % (ext))
</t>
<t tx="ekr.20090608174319.4791"># This causes trouble if executed quickly after the add-editor command.
# Presumably this is a timing condition that will never happen in practice.

if 0:
    c.frame.body.deleteEditor()
</t>
<t tx="ekr.20090615053403.4876"></t>
<t tx="ekr.20090615053403.4877">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4878">@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
continues */

More plain text.
</t>
<t tx="ekr.20090615053403.4879">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4880">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket
</t>
<t tx="ekr.20090615053403.4881">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4882">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;
</t>
<t tx="ekr.20090615053403.4883">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4884">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield
</t>
<t tx="ekr.20090615053403.4885">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4886">@language css
/* New in 4.2. */

/*html tags*/
address, applet, area, a, base, basefont,
big, blockquote, body, br, b, caption, center,
cite, code, dd, dfn, dir, div, dl, dt, em, font,
form, h1, h2, h3, h4, h5, h6, head, hr, html, img,
input, isindex, i, kbd, link, li, link, map, menu,
meta, ol, option, param, pre, p, samp,
select, small, span, strike, strong, style, sub, sup,
table, td, textarea, th, title, tr, tt, ul, u, var,
/*units*/
mm, cm, in, pt, pc, em, ex, px,
/*colors*/
aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, yellow, white,
/*important directive*/
!important,
/*font rules*/
font, font-family, font-style, font-variant, font-weight, font-size,
/*font values*/
cursive, fantasy, monospace, normal, italic, oblique, small-caps,
bold, bolder, lighter, medium, larger, smaller,
serif, sans-serif,
/*background rules*/
background, background-color, background-image, background-repeat, background-attachment, background-position,
/*background values*/
contained, none, top, center, bottom, left, right, scroll, fixed,
repeat, repeat-x, repeat-y, no-repeat,
/*text rules*/
word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, text-transform, text-shadow, unicode-bidi, line-height,
/*text values*/
normal, none, underline, overline, blink, sub, super, middle, top, text-top, text-bottom,
capitalize, uppercase, lowercase, none, left, right, center, justify,
line-through,
/*box rules*/
margin, margin-top, margin-bottom, margin-left, margin-right,
margin, padding-top, padding-bottom, padding-left, padding-right,
border, border-width, border-style, border-top, border-top-width, border-top-style, border-bottom, border-bottom-width, border-bottom-style, border-left, border-left-width, border-left-style, border-right, border-right-width, border-right-style, border-color,
/*box values*/
width, height, float, clear,
auto, thin, medium, thick, left, right, none, both,
none, dotted, dashed, solid, double, groove, ridge, inset, outset,
/*display rules*/
display, white-space, 
min-width, max-width, min-height, max-height,
outline-color, outline-style, outline-width,
/*display values*/
run-in, inline-block, list-item, block, inline, none, normal, pre, nowrap, table-cell, table-row, table-row-group, table-header-group, inline-table, table-column, table-column-group, table-cell, table-caption
/*list rules*/
list-style, list-style-type, list-style-image, list-style-position,
/*list values*/
disc, circle, square, decimal, decimal-leading-zero, none,
lower-roman, upper-roman, lower-alpha, upper-alpha, lower-latin, upper-latin,
/*table rules*/
border-collapse, caption-side,
/*table-values*/
empty-cells, table-layout,
/*misc values/rules*/
counter-increment, counter-reset,
marker-offset, z-index,
cursor, direction, marks, quotes,
clip, content, orphans, overflow, visibility,
/*aural rules*/
pitch, range, pitch-during, cue-after, pause-after, cue-before, pause-before, speak-header, speak-numeral, speak-punctuation, speed-rate, play-during, voice-family,
/*aural values*/
stress, azimuth, elevation, pitch, richness, volume,
page-break, page-after, page-inside
</t>
<t tx="ekr.20090615053403.4887">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4888">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section references are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.
</t>
<t tx="ekr.20090615053403.4889">&lt;&lt; section def &gt;&gt;=

    my \c code goes here // This is \LaTeX text
    /* This is also \LaTeX text */
</t>
<t tx="ekr.20090615053403.4890">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4891">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while
</t>
<t tx="ekr.20090615053403.4892">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4893">@language erlang

halt()

-module()
</t>
<t tx="ekr.20090615053403.4894">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4895">@language forth

\ tiny demo of Leo forth syntax colouring

: some-forth-word ( x1 x2 -- x3 ) \ blue :, black/bold some-forth-word
   label: y  \ blue label:
   asm[ s" some string" type ]asm cr
   asm[ abc ]asm
   a
   s" abc "
   s" abc"
   a
   tty" abc "
   lcd2" abc "
   until

@ test
@c

{ abc }

a b @ c

asm[ abc ]asm

.( ab ) \ a string

: foo [ .s ] ;

   [ a b c
   x y z]
;
</t>
<t tx="ekr.20090615053403.4896">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4897">@language html

b = "cd"
d
</t>
<t tx="ekr.20090615053403.4898">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4899">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</t>
<t tx="ekr.20090615053403.4900">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4901">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""
</t>
<t tx="ekr.20090615053403.4902">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4903">@ doc part
@c

@language java /* Colored by match_leo_keyword: tag = leoKeyword. */

@whatever /* Colored by java match_following rule: tag = keyword4. */

/** A javadoc: tag = comment3 */

/** &lt;!-- comment --&gt; tag = comment1. */

/** @see tag = label */
</t>
<t tx="ekr.20090615053403.4904">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4905">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}

The following should be colored:

\documentclass{report}

The following 2-letter words should be colored, regardless of what follows:

\(\)\{\}\@
\(abc\)abc\{abc\}abc\@abc
</t>
<t tx="ekr.20090615053403.4906">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4907">@language lisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while
</t>
<t tx="ekr.20090615053403.4908">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4909">@language perl

# From a perl tutorial.

print 'Hello world.';		# Print a message

$a = $b;	# Assign $b to $a

@food  = ("apples", "pears", "eels");

$grub = pop(@food);	# Now $grub = "eels"

$#food

@lines = &lt;INFO&gt;;

#!/usr/local/bin/perl
print "Password? ";		# Ask for input
$a = &lt;STDIN&gt;;			# Get input
chop $a;			# Remove the newline at end
while ($a ne "fred")		# While input is wrong...
{
    print "sorry. Again? ";	# Ask again
    $a = &lt;STDIN&gt;;		# Get input again
    chop $a;			# Chop off newline again
}

if ($sentence =~ /under/)
{
	print "We're talking about rugby\\n";
}

$sentence =~ s/london/London/

$_ = "Capes:Geoff::Shot putter:::Big Avenue";
@personal = split(/:/);

foreach $age (values %ages)
{
	print "Somebody is $age\\n";
}

&amp;mysubroutine;		# Call the subroutine
&amp;mysubroutine($_);	# Call it with a parameter
&amp;mysubroutine(1+2, $_);	# Call it with two parameters

sub inside
{
	local($a, $b);			# Make local variables
	($a, $b) = ($_[0], $_[1]);	# Assign values
	$a =~ s/ //g;			# Strip spaces from
	$b =~ s/ //g;			#   local variables
	($a =~ /$b/ || $b =~ /$a/);	# Is $b inside $a
					#   or $a inside $b?
}
</t>
<t tx="ekr.20090615053403.4910">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4911">@language php
@ doc
This is a doc part.
@c

and or
array
array()
/* Multi-line comment
*/
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
&lt;?PHP and or array() ?&gt;
</t>
<t tx="ekr.20090615053403.4912">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4913">@language plsql

"a string"
-- reserved keywords
ABORT,
abort,
ACceSS,
access,
add,
all,
allocate,
alter,
analyze,
and,
any,
archive,
archivelog,
array,
arraylen,
as,
asc,
assert,
assign,
at,
audit,
authorization,
avg,
backup,
base_table,
become,
before,
begin,
between,
binary_integer,
block,
body,
boolean,
by,
cache,
cancel,
cascade,
case,
change,
char,
char_base,
character,
check,
checkpoint,
close,
cluster,
clusters,
cobol,
colauth,
column,
columns,
comment,
commit,
compile,
compress,
connect,
constant,
constraint,
constraints,
contents,
continue,
controlfile,
count,
crash,
create,
current,
currval,
cursor,
cycle,
data_base,
database,
datafile,
date,
dba,
debugoff,
debugon,
dec,
decimal,
declare,
default,
definition,
delay,
delete,
delta,
desc,
digits,
disable,
dismount,
dispose,
distinct,
distinct,
do,
double,
drop,
drop,
dump,
each,
else,
else,
elsif,
enable,
end,
end,
entry,
escape,
events,
except,
exception,
exception_init,
exceptions,
exclusive,
exec,
execute,
exists,
exists,
exit,
explain,
extent,
externally,
false,
fetch,
fetch,
file,
float,
float,
flush,
for,
for,
force,
foreign,
form,
fortran,
found,
freelist,
freelists,
from,
from,
function,
generic,
go,
goto,
grant,
group,
groups,
having,
identified,
if,
immediate,
in,
including,
increment,
index,
indexes,
indicator,
initial,
initrans,
insert,
instance,
int,
integer,
intersect,
into,
is,
key,
language,
layer,
level,
like,
limited,
link,
lists,
lock,
logfile,
long,
loop,
manage,
manual,
max,
maxdatafiles,
maxextents,
maxinstances,
maxlogfiles,
maxloghistory,
maxlogmembers,
maxtrans,
maxvalue,
min,
minextents,
minus,
minvalue,
mlslabel,
mod,
mode,
modify,
module,
mount,
natural,
new,
new,
next,
nextval,
noarchivelog,
noaudit,
nocache,
nocompress,
nocycle,
nomaxvalue,
nominvalue,
none,
noorder,
noresetlogs,
normal,
nosort,
not,
notfound,
nowait,
null,
number,
number_base,
numeric,
of,
off,
offline,
old,
on,
online,
only,
open,
open,
optimal,
option,
or,
order,
others,
out,
own,
package,
package,
parallel,
partition,
pctfree,
pctincrease,
pctused,
plan,
pli,
positive,
pragma,
precision,
primary,
prior,
private,
private,
privileges,
procedure,
procedure,
profile,
public,
quota,
raise,
range,
raw,
read,
real,
record,
recover,
references,
referencing,
release,
remr,
rename,
resetlogs,
resource,
restricted,
return,
reuse,
reverse,
revoke,
role,
roles,
rollback,
row,
rowid,
rowlabel,
rownum,
rows,
rowtype,
run,
savepoint,
schema,
scn,
section,
segment,
select,
select,
separate,
sequence,
session,
set,
set,
share,
shared,
size,
size,
smallint,
smallint,
snapshot,
some,
sort,
space,
sql,
sqlbuf,
sqlcode,
sqlerrm,
sqlerror,
sqlstate,
start,
start,
statement,
statement_id,
statistics,
stddev,
stop,
storage,
subtype,
successful,
sum,
sum,
switch,
synonym,
sysdate,
system,
tabauth,
table,
tables,
tables,
tablespace,
task,
temporary,
terminate,
then,
thread,
time,
to,
tracing,
transaction,
trigger,
triggers,
true,
truncate,
type,
uid,
under,
union,
unique,
unlimited,
until,
update,
use,
user,
using,
validate,
values,
varchar,
varchar2,
variance,
view,
views,
when,
whenever,
where,
while,
with,
work,
write,
xor
</t>
<t tx="ekr.20090615053403.4914">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4915">@language html

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;
&lt;&lt; remarks &gt;&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" /&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="#" /&gt;
    &lt;/PROPS&gt;
    &lt;RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
        &lt;&lt; comments &gt;&gt;
        &lt;&lt; literals &gt;&gt;
        &lt;&lt; operators &gt;&gt;
        &lt;MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE"&gt;(&lt;/MARK_PREVIOUS&gt;
        &lt;&lt; keywords &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;
</t>
<t tx="ekr.20090615053403.4916">&lt;!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by --&gt;
&lt;!-- Jonathan Revusky --&gt;

&lt;!-- Modified 19-Jul-00 by Ivan Frohne to: --&gt;
&lt;!--  (a) implement 'indentOnEnter'; --&gt;
&lt;!--  (b) indent next line automatically after control structures followed --&gt;
&lt;!--	  by ':'; --&gt;
&lt;!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; --&gt;
&lt;!--  (d) add TYPE FUNCTION identified by a following '(' --&gt;
&lt;!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); --&gt;
&lt;!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and --&gt;
&lt;!--  (g) add all builtin functions, builtin exceptions, --&gt;
&lt;!--	  builtin type methods, File object methods, and special type --&gt;
&lt;!--	  attributes as TYPE KEYWORD3. --&gt;
</t>
<t tx="ekr.20090615053403.4917">&lt;!-- Comment --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;#&lt;/EOL_SPAN&gt;

&lt;!-- Triple-quotes --&gt;
&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;"""&lt;/BEGIN&gt;
    &lt;END&gt;"""&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;'''&lt;/BEGIN&gt;
    &lt;END&gt;'''&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="ekr.20090615053403.4918">&lt;!-- Standard literals --&gt;
&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;"&lt;/BEGIN&gt;
    &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;'&lt;/BEGIN&gt;
    &lt;END&gt;'&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="ekr.20090615053403.4919">&lt;SEQ TYPE="OPERATOR"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;%&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;~&lt;/SEQ&gt;
</t>
<t tx="ekr.20090615053403.4920">&lt;KEYWORDS&gt;
    &lt;&lt; reserved words &gt;&gt;
    &lt;&lt; builtins &gt;&gt;
    &lt;&lt; exceptions &gt;&gt;
    &lt;&lt; types &gt;&gt;
&lt;/KEYWORDS&gt;
</t>
<t tx="ekr.20090615053403.4921">&lt;!--  Reserved Words  --&gt;
&lt;KEYWORD1&gt;and&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;as&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;assert&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;break&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;class&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;continue&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;def&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;del&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;elif&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;except&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;exec&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;finally&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;for&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;from&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;global&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;import&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;in&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;is&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;lambda&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;not&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;or&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;pass&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;print&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;raise&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;return&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;try&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;while&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;yield&lt;/KEYWORD1&gt;
</t>
<t tx="ekr.20090615053403.4922">&lt;!-- builtins --&gt;
&lt;KEYWORD2&gt;abs&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;apply&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;bool&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;buffer&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;callable&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;chr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;classmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;cmp&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;coerce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;compile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;complex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;delattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dict&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dir&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;divmod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;eval&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;execfile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;file&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;filter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;float&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;getattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;globals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hasattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hash&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;id&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;int&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;intern&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;isinstance&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;issubclass&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;iter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;len&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;list&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;locals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;long&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;map&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;max&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;min&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;object&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;oct&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;open&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;ord&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;pow&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;property&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;range&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;raw_input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reduce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reload&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;repr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;round&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;setattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;slice&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;staticmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;str&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;super&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;tuple&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;type&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unichr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unicode&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;vars&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;xrange&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;zip&lt;/KEYWORD2&gt;
</t>
<t tx="ekr.20090615053403.4923">&lt;!-- exceptions --&gt;
&lt;KEYWORD3&gt;ArithmeticError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AssertionError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AttributeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DeprecationWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EOFError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EnvironmentError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Exception&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatingPointError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IOError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ImportError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndentationError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndexError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyboardInterrupt&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LookupError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MemoryError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NameError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplemented&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplementedError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OSError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ReferenceError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StandardError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StopIteration&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemExit&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TabError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundLocalError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UserWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ValueError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Warning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;WindowsError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ZeroDivisionError&lt;/KEYWORD3&gt;
</t>
<t tx="ekr.20090615053403.4924">&lt;!-- types (from types module) --&gt;
&lt;KEYWORD3&gt;BufferType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinFunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ClassType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;CodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ComplexType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictProxyType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictionaryType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EllipsisType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FileType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FrameType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;GeneratorType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;InstanceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IntType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LambdaType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ListType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LongType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ModuleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NoneType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ObjectType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SliceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringTypes&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TracebackType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TupleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;XRangeType&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;False&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;None&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;True&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;__abs__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__add__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__all__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__author__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__bases__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__builtins__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__call__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__class__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__cmp__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__coerce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__contains__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__debug__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__del__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__dict__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__div__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__divmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__doc__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__eq__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__file__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__float__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__floordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__future__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ge__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattribute__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__gt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hash__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hex__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iadd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__import__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__imul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__init__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__int__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__invert__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iter__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__le__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__len__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__long__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__members__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__metaclass__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mro__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__name__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ne__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__neg__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__new__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__nonzero__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__oct__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__or__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__path__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pos__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__radd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdivmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__reduce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__repr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rfloordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rlshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ror__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rpow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rrshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rsub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rtruediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rxor__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__self__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__slots__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__str__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__sub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__truediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__version__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__xor__&lt;/KEYWORD3&gt;
</t>
<t tx="ekr.20090615053403.4925">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4926">@language python

int
float
dict
</t>
<t tx="ekr.20090615053403.4927">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4928">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""

def copyTree(self,root):

    c = self
    # Create the root VNode.
    result = v = leoNodes.VNode(c)
    # Copy the headline and icon values v.copyNode(root,v)
    # Copy the rest of tree.
    v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v = leoNodes.VNode(c)
        v = v.threadNext()
    return result
</t>
<t tx="ekr.20090615053403.4929">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4930">@language r

x &lt;- rnorm(10) 

vv &lt;- function(z) return(z) 

def python_funct(uu): 
return uu
</t>
<t tx="ekr.20090615053403.4931">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4932">' New in 4.2.
@language rapidq
' a comment.

$APPTYPE,$DEFINE,$ELSE,$ENDIF,$ESCAPECHARS,$IFDEF,$IFNDEF,
$INCLUDE,$MACRO,$OPTIMIZE,$OPTION,$RESOURCE,$TYPECHECK,$UNDEF,
ABS,ACOS,ALIAS,AND,AS,ASC,ASIN,ATAN,ATN,BIN$,BIND,BYTE,
CALL,CALLBACK,CALLFUNC,CASE,CEIL,CHDIR,CHDRIVE,CHR$,CINT,
CLNG,CLS,CODEPTR,COMMAND$,COMMANDCOUNT,CONSOLE,CONST,CONSTRUCTOR,
CONVBASE$,COS,CREATE,CSRLIN,CURDIR$,DATA,DATE$,DEC,DECLARE,
DEFBYTE,DEFDBL,DEFDWORD,DEFINT,DEFLNG,DEFSHORT,DEFSNG,DEFSTR,
DEFWORD,DELETE$,DIM,DIR$,DIREXISTS,DO,DOEVENTS,DOUBLE,DWORD,
ELSE,ELSEIF,END,ENVIRON,ENVIRON$,EVENT,EXIT,EXP,EXTENDS,
EXTRACTRESOURCE,FIELD$,FILEEXISTS,FIX,FLOOR,FOR,FORMAT$,FRAC,
FUNCTION,FUNCTIONI,GET$,GOSUB,GOTO,HEX$,IF,INC,INITARRAY,
INKEY$,INP,INPUT,INPUT$,INPUTHANDLE,INSERT$,INSTR,INT,INTEGER,
INV,IS,ISCONSOLE,KILL,KILLMESSAGE,LBOUND,LCASE$,LEFT$,LEN,
LFLUSH,LIB,LIBRARYINST,LOCATE,LOG,LONG,LOOP,LPRINT,LTRIM$,
MEMCMP,MESSAGEBOX,MESSAGEDLG,MID$,MKDIR,MOD,MOUSEX,MOUSEY,
NEXT,NOT,OFF,ON,OR,OUT,OUTPUTHANDLE,PARAMSTR$,PARAMSTRCOUNT,
PARAMVAL,PARAMVALCOUNT,PCOPY,PEEK,PLAYWAV,POKE,POS,POSTMESSAGE,
PRINT,PROPERTY,QUICKSORT,RANDOMIZE,REDIM,RENAME,REPLACE$,
REPLACESUBSTR$,RESOURCE,RESOURCECOUNT,RESTORE,RESULT,RETURN,
REVERSE$,RGB,RIGHT$,RINSTR,RMDIR,RND,ROUND,RTRIM$,RUN,
SCREEN,SELECT,SENDER,SENDMESSAGE,SETCONSOLETITLE,SGN,SHELL,
SHL,SHORT,SHOWMESSAGE,SHR,SIN,SINGLE,SIZEOF,SLEEP,SOUND,
SPACE$,SQR,STACK,STATIC,STEP,STR$,STRF$,STRING,STRING$,
SUB,SUBI,SWAP,TALLY,TAN,THEN,TIME$,TIMER,TO,TYPE,UBOUND,
UCASE$,UNLOADLIBRARY,UNTIL,VAL,VARIANT,VARPTR,VARPTR$,VARTYPE,
WEND,WHILE,WITH,WORD,XOR
</t>
<t tx="ekr.20090615053403.4933">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4934">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?
</t>
<t tx="ekr.20090615053403.4935">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4936">@language rest

@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

. Links used in this document...

.. _`Pmw`:                  http://pmw.sourceforge.net/
.. _run:                    `Running Leo`_

.. WARNING: image targets may not have upper case letters!

.. |back| image:: arrow_lt.gif
    :target: FAQ.html

.. |leo| image:: leo.gif
    :target: front.html

.. |next| image:: arrow_rt.gif
    :target: intro.html

|back| |leo| |next|

###########################
Chapter 1: Installing Leo
###########################

This chapter tells how to install and run Leo.

**Important**:

If you have *any* problems installing Leo,
please ask for help on Leo's help forum:

.. contents::

**Windows**
    If you have `associated .leo files with Leo`_ you may run Leo by double-clicking any .leo file.
    You can also use a batch file.
    Put the following .bat file in c:\\Windows::

        cd c:\prog\LeoCVS\leo
        c:\python22\python c:\prog\LeoCVS\leo\leo.py %1

-   Download the latest version of Leo from `Leo's download page`_.

-   In Windows 2K or XP, go to ``Start-&gt;Settings-&gt;Control panel``, open the ``Folder Options`` tab.

    **Warning**: When building Tcl on Linux, do **not** specify
    "--enable-threads".
    Only use Tcl with the default "threads not enabled" case.

-------------

|back| |leo| |next|
</t>
<t tx="ekr.20090615053403.4937">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4938"># New in 4.2.

@language shell

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait
</t>
<t tx="ekr.20090615053403.4939">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4940">@language shellscript

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait
</t>
<t tx="ekr.20090615053403.4941">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4942">@language html

&lt;!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ --&gt;

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="%" /&gt;
    &lt;/PROPS&gt;

    &lt;RULES&gt;
        &lt;&lt; general rules &gt;&gt;
    &lt;/RULES&gt;

    &lt;RULES SET="MATH" DEFAULT="MARKUP"&gt;
        &lt;&lt; math rules &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;
</t>
<t tx="ekr.20090615053403.4943">&lt;!-- $$...$$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$$&lt;/BEGIN&gt;
    &lt;END&gt;$$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- $...$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$&lt;/BEGIN&gt;
    &lt;END&gt;$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- \[...\] (LaTeX math mode) --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;\[&lt;/BEGIN&gt;
    &lt;END&gt;\]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD1"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="OPERATOR"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;]&lt;/SEQ&gt;
</t>
<t tx="ekr.20090615053403.4944">&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD3"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;)&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;(&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;]&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;~&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;.&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;,&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;?&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;:&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;'&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;"&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;`&lt;/SEQ&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;
</t>
<t tx="ekr.20090615053403.4945">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4946"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text"""

if 1 and 2:
    pass

print(g.app().loadDir)
</t>
<t tx="ekr.20090615053403.4947">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4948"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""


if 1 and 2:
    pass

print(g.app().loadDir)
</t>
<t tx="ekr.20090615053403.4949">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4950"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""

if 1 and 2:
    pass
</t>
<t tx="ekr.20090615053403.4951">&lt;&lt; test defined &gt;&gt;
</t>
<t tx="ekr.20090615053403.4952">pass
</t>
<t tx="ekr.20090615053403.4953">try:
    mode = c.frame.body.colorizer.modes.get('python')
    mode.keywords['as'] = 1 # append the keyword, colorize with 'keyword1' tag.
except AttributeError:
    pass # modes only exists for new colorizer.
</t>
<t tx="ekr.20090615053403.4954"># This will work regardless of where this method is.
@language python

language = g.findLanguageDirectives(c,p)
assert language == 'python','got:%s' % language
</t>
<t tx="ekr.20090615053403.4955">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20090615053403.4956">@language vbscript

if
IF
</t>
<t tx="ekr.20090615053403.4957"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoColor tests')
</t>
<t tx="ekr.20090627070131.4971">c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20090627070131.4975">@language python
@tabwidth -4
@others
#end
</t>
<t tx="ekr.20090627070131.4976">def spam(cheese):

    print(cheese)
</t>
<t tx="ekr.20090627070131.4977">def cheese():

    pass
</t>
<t tx="ekr.20090627070131.4978">def spam(cheese):

    print(cheese)
def cheese():

    pass
#end
</t>
<t tx="ekr.20090704085350.5010">h = '@file ../test/unittest/at-file-test.py'
p = g.findNodeAnywhere(c,h)
assert p
assert not p.isDirty(),p.h # Do not ignore this failure!

table = (
    (p.firstChild(),'spam'),
    (p.firstChild().next(),'eggs')
)

for p2,h2 in table:
    assert p2.h == h2
    assert len(p2.b) &gt; 10
</t>
<t tx="ekr.20090704085350.5014">@others</t>
<t tx="ekr.20090704085350.5018"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:

    h = '@shadow ../test/unittest/at-shadow-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert len(p2.h) == len(h2)
</t>
<t tx="ekr.20090704085350.5022">@language python
@others
</t>
<t tx="ekr.20090704085350.5023">def spam():
    pass
</t>
<t tx="ekr.20090704085350.5024">def eggs():
    pass
</t>
<t tx="ekr.20090704085350.5028">@language python
@others</t>
<t tx="ekr.20090704085350.5029">def spam():
    pass</t>
<t tx="ekr.20090704085350.5030">def eggs():
    pass</t>
<t tx="ekr.20090704085350.5034">@first
@language python
@others
</t>
<t tx="ekr.20090704085350.5035">def spam():
    pass # Unicode test:  after.
</t>
<t tx="ekr.20090704085350.5036">def eggs():
    pass
</t>
<t tx="ekr.20090704085350.5044"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:

    h = '@asis unittest/at-asis-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert p2.h == h2
        assert len(p2.b) &gt; 10
</t>
<t tx="ekr.20090704085350.5046"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:

    h = '@thin unittest/at-thin-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert p2.h == h2
        assert len(p2.b) &gt; 10
</t>
<t tx="ekr.20090704085350.5052"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:

    h = '@auto unittest/at-auto-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert p2.h == h2
        assert len(p2.b) &gt; 10
</t>
<t tx="ekr.20090704085350.5056">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20091219121039.5065">x = c.rstCommands
result = x.handleMissingStyleSheetArgs(p,s=None)
assert result == {},'expected {}, got %s' % result
expected = {
    'documentoptions':'[english,12pt,lettersize]',
    'language':'ca',
    'use-latex-toc':'1',
}
for s in (
    '--language=ca, --use-latex-toc,--documentoptions=[english,12pt,lettersize]',
    '--documentoptions=[english,12pt,lettersize],--language=ca, --use-latex-toc',
    '--use-latex-toc,--documentoptions=[english,12pt,lettersize],--language=ca, ',
):
    result = x.handleMissingStyleSheetArgs(p,s=s)
    assert result == expected,'expected %s\ngot %s' % (expected,result)
</t>
<t tx="ekr.20091219122958.5066"># Warning: these depend on the .css files in leo\test\unittest.
</t>
<t tx="ekr.20100107110353.5105"></t>
<t tx="ekr.20100107110353.5106">@others
</t>
<t tx="ekr.20100107110353.5107">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20100107110353.5108">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20100107110353.5109">@others
</t>
<t tx="ekr.20100107110353.5110">node 1 line 1
node 1 line 2 changed
</t>
<t tx="ekr.20100107110353.5111">node 2 line 1 changed
node 2 line 2 changed
</t>
<t tx="ekr.20100119102849.5108"># backward-find-character and find-character
# can't be tested this way because they require k.getarg.
# They pass hand tests.

&lt;&lt; define table &gt;&gt;

w = c.frame.body.wrapper
child = g.findNodeInChildren(c,p,'work')
assert child
c.selectPosition(child)

for commandName in table:
    # Put the cursor in the middle of the middle line
    # so all cursor moves will actually do something.
    w.setInsertPoint(15) # for move-past-close
    try:
        c.editCommands.extendMode = True
        c.keyHandler.simulateCommand(commandName)
        i,j = w.getSelectionRange()
        assert i != j,'i == j: %s %s' % (i,commandName)
    finally:
        c.editCommands.extendMode = False

</t>
<t tx="ekr.20100119102849.5109"># Cursor movement commands affected by extend mode.
# The x-extend-selection commands are not so affected.
table = (
    'back-to-indentation',
    'back-to-home',
    'back-char',
    'back-page',
    'back-paragraph',
    'back-sentence',
    'back-word',
    'beginning-of-buffer',
    'beginning-of-line',
    'end-of-buffer',
    'end-of-line',
    'forward-char',
    'forward-page',
    'forward-paragraph',
    'forward-sentence',
    'forward-end-word',
    'forward-word',
    'move-past-close',
    'next-line',
    'previous-line',
)
</t>
<t tx="ekr.20100119102849.5110">line 1.
line 2(xxx).
line 3.
</t>
<t tx="ekr.20100131171342.5473"></t>
<t tx="ekr.20100131171342.5474">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)
    assert(tkGui)

    import leo.core.leoFrame as leoFrame
    import inspect,sys

    baseClass = leoFrame.leoBody
    subClasses  = (tkGui.leoTkinterBody,leoFrame.nullBody)
    baseObject = c.frame.body

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        try:
            assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)
        except AssertionError:
            exctype, value = sys.exc_info()[:2]
            print(value)
            raise

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                #raise
                exctype, value = sys.exc_info()[:2]
                print(value)
</t>
<t tx="ekr.20100131171342.5475">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoFrame
    subClasses  = (tkGui.leoTkinterFrame,leoFrame.NullFrame)
    baseObject = c.frame

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
</t>
<t tx="ekr.20100131171342.5476">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoGui as leoGui
    import inspect

    baseClass = leoGui.leoGui
    subClasses  = (tkGui.tkinterGui,) # nullGui can inherit almost all leoGui dummy methods.
    baseObject = g.app.gui

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                raise
</t>
<t tx="ekr.20100131171342.5477">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoTree
    subClasses  = (tkGui.leoTkinterTree,leoFrame.nullTree)
    baseObject = c.frame.tree

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
</t>
<t tx="ekr.20100131171342.5478">logCtrl = c.frame.log.logCtrl

table = (
    ('mustBeDefinedInSubclasses',logCtrl.mustBeDefinedInSubclasses),
    ('mustBeDefinedInBaseClass',logCtrl.mustBeDefinedOnlyInBaseClass),
    ('mustBeDefined',logCtrl.mustBeDefined),
)

# Check existence.
for tag,aList in table:
    for z in aList:
        assert hasattr(c.frame.log,z),'%s %s %s' % (tag,c.frame.log,z)
        assert hasattr(c.frame.body,z),'%s %s %s' % (tag,c.frame.body,z)

# Check signatures.
import inspect
for tag,aList in table:
    for z in aList:
        func = getattr(c.frame.body.bodyCtrl,z)
        func2 = getattr(c.frame.log.logCtrl,z)
        assert func,z
        assert func2,z
        d1 = inspect.getargspec(func)
        d2 = inspect.getargspec(func2)
        assert d1==d2,'\n%s\n\nd1 %s\n\nd2 %s' % (z,d1,d2)
</t>
<t tx="ekr.20100131171342.5487">def checkFile(p):

    # print('checking',p.h)
    # Check all the descendant nodes.
    ok = True
    for p2 in p.subtree_iter():
        h = p2.h
        for tag in ('@test','@suite'):
            if h.startswith(tag):
                s = p2.b
                lines = g.splitLines(s)
                for line in lines:
                    # print('line',line)
                    if not line.strip() or line.startswith('#'):
                        continue
                    elif line.startswith('if g.unitTesting:'):
                        break
                    else:
                        print('in %s' % p.h)
                        print('missing "if g.unitTesting:" %s' % h)
                        ok = False
    return ok
</t>
<t tx="ekr.20100131171342.5497">import leo.plugins.detect_urls as detect_urls

# print(c.frame.body.wrapper)
w = c.frame.body.wrapper
s = w.getAllText()

# s will be empty when running unit tests dynamically.
if s:
    if s.endswith('\n'): s = s[:-1]
    w.setInsertPoint(len(s))
    url = detect_urls.openURL(tag='test',keywords={'c':c})
    assert url == 'http://webpages.charter.net/edreamleo/front.html','Got:%s' % repr(url)
    
@ The last line is the url
http://webpages.charter.net/edreamleo/front.html
</t>
<t tx="ekr.20100131171342.5500">import leo.plugins.macros as macros

controller = macros.ParamClass(c)
controller.parameterize()
    # Not much will happen because there are no children.
    # However, this does test recent changes.
</t>
<t tx="ekr.20100131171342.5501" annotate="7d71002e"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of plugins unit tests')
</t>
<t tx="ekr.20100131171342.5503">for p in c.all_positions():
    p2 = c.vnode2position(p.v)
    # print(p2.level(), p2.headString())
    # We can *not* assert that p == p2, only that
    # p2.v == p.v and c.positionExists(p2)
    assert p2
    assert p2.v == p.v,'p2.v: %s, p.v: %s' % (p2.v,v)
    assert c.positionExists(p2),'does not exist: %s' % p2
</t>
<t tx="ekr.20100131171342.5504">tree = c.frame.tree
# position2item does not exist when running unit tests dynamically.
if hasattr(tree,'position2item'):
    c.redraw()
    p = c.rootPosition()
    while p:
        item = tree.position2item(p)
        v = tree.item2vnode(item)
        if v: # New test needed with per-clone expansions.
            assert v == p.v, 'item2: %s, p.v: %s' % (item,p.v)
        p.moveToVisNext(c)
</t>
<t tx="ekr.20100131171342.5505"># This test is no longer valid because of per-position node expansions.
def test_sibs(parent_p,parent_item):
    trace = False
    tree = c.frame.tree
    sib_items = tree.childItems(parent_item)
    sibs = [z.copy() for z in parent_p.self_and_siblings_iter()]
    assert len(sib_items) == len(sibs),(
        'child_items: %s, children: %s' % (
            g.listToString(sib_items),g.listToString(sibs)))
    for item,p in zip(sib_items,sibs):
        p2 = tree.item2position(item)
        if trace: print (id(item),p2 and p2.headString() or not p2 and '**None**')
        assert p == p2, 'item: %s, p: %s, p2: %s' % (id(item),p,p2)
        # Recursively test.
        child = p.firstChild()
        if child.isVisible(c):
            test_sibs(child,parent_item=item)
if hasattr(c.frame.tree,'item2position'):
    c.redraw()
    test_sibs(c.rootPosition(),None)
</t>
<t tx="ekr.20100131171342.5506"></t>
<t tx="ekr.20100131171342.5507">@
language_delims_dict 
    # Keys are languages, values are 1,2 or 3-tuples of delims. 
language_extension_dict
    # Keys are languages, values are extensions.
extension_dict = {
    # Keys are extensions, values are languages.
@c

delims_d    = g.app.language_delims_dict
lang_d      = g.app.language_extension_dict
ext_d       = g.app.extension_dict

for lang in lang_d:
    ext = lang_d.get(lang)
    assert lang in delims_d,'fail 1: %s' % lang
    assert ext in ext_d,'fail 2: %s' % ext
for ext in ext_d:
    lang = ext_d.get(ext)
    assert lang in lang_d,'fail 3: %s' % lang
</t>
<t tx="ekr.20100131171342.5508"></t>
<t tx="ekr.20100131171342.5509">import leo.core.leoBridge as leoBridge

if g.app.isExternalUnitTest:
    print('running @test leoBridge init logic')
    # This can not be run locally!
    b = leoBridge.controller(gui='nullGui',
        loadPlugins=True,
        readSettings=True,
        silent=False,
        tracePlugins=True,
        verbose=True)
    g = b.globals()
    path = g.os_path_finalize_join(g.app.loadDir,'..','doc','LeoDocs.leo')
    assert g.os_path_exists(path)
    c = b.openLeoFile(path)
    assert c
    assert c.rootPosition()
else:
    self.skipTest('Can not be run locally')
</t>
<t tx="ekr.20100131171342.5592"></t>
<t tx="ekr.20100131171342.5593"># For some reason these don't select the dialog properly when run as a script.
# However, the main reason for the tests is to make sure the ctors don't crash.
# Also, for unit testing the value of c doesn't matter.
oldGui = g.app.gui
guis = [g.app.gui]

import leo.core.leoGui as leoGui
guis.append(leoGui.UnitTestGui())
for gui in guis:
    gui.runAboutLeoDialog(c,'version','copyright','url','email')
    gui.runAskLeoIDDialog()
    gui.runAskOkDialog(c,'title','message')
    gui.runAskOkCancelNumberDialog(c,'title','message')
    gui.runAskOkCancelStringDialog(c,'title','message')
    gui.runAskYesNoDialog(c,'title','message')
    gui.runAskYesNoCancelDialog(c,'title','message')
    # gui.runCompareDialog(c) # Removed.
g.app.gui = oldGui
</t>
<t tx="ekr.20100131171342.5599"></t>
<t tx="ekr.20100131171342.5603" annotate="7d71002e"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoGui tests.')
</t>
<t tx="ekr.20100131171342.5604"></t>
<t tx="ekr.20100131171342.5605">import string

k = c.k

for ch in (string.printable):
    if ch == '\n': continue # A special case.
    assert k.isPlainKey(ch), 'wrong: not plain: %s' % (ch)

special = (
    'Return', # A special case.
    'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
    'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
    'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
    'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
    'KP_F1','KP_F2','KP_F3','KP_F4',
    'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
    'Home','Left','Linefeed','Next','Num_Lock',
    'PageDn','PageUp','Pause','Prior','Right','Up',
    'Sys_Req',
)

for ch in special:
    assert not k.isPlainKey(ch), 'wrong: is plain: %s' % (ch)
</t>
<t tx="ekr.20100131171342.5606"># This test is difficult to get right on all platforms.
# It's not worth doing.

try:
    k = c.k
    w = c.frame.body.wrapper
    ac = k.autoCompleter
    # Set the insertion point.
    s = w.getAllText()
    w.setInsertPoint(len(s)-1)
    # Just test that this doesn't crash.
    ac.w = w
    ac.calltip()
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor()

# c.frame
</t>
<t tx="ekr.20100131171342.5607">k = c.k ; p = c.p
w = c.edit_widget(p)
commandName = 'test-registerCommand'

def callback (event=None,c=c): # Must have an event param to pass later unit test.
    g.app.unitTestDict[commandName] = True

# Test 1
g.app.unitTestDict[commandName] = False
k.registerCommand(commandName,'Alt-Ctrl-Shift-z',callback,pane='all',verbose=True)
k.simulateCommand(commandName)
assert g.app.unitTestDict.get(commandName)

if 0: # Test 2
    g.app.unitTestDict[commandName] = False
    k.manufactureKeyPressForCommandName(w,commandName)
    assert g.app.unitTestDict.get(commandName)
</t>
<t tx="ekr.20100131171342.5608">table = (
    ('Key-1','1'), # 2016/04/12
    ('key-1','1'), # 2016/04/12
    ('1', '1'), # 2016/04/12
    ('a','a'),
    ('A','a'),
    ('Alt-a','Alt+a'),
    ('Alt-A','Alt+a'),
    ('Alt-Shift-a','Alt+A'),
    ('Alt-=','Alt+equal'),
    ('Alt-+','Alt+plus'),
    # We can no longer igtnore the shift.
    # ('Alt-Shift++','Alt+plus'), # Ignore the shift.
    ('Alt--','Alt+minus'),
    ('Shift-a','A'),
    ('Shift-A','A'),
    ('RtArrow','Right'),
    ('Shift-RtArrow','Shift+Right'),
    ('Ctrl-RtArrow','Ctrl+Right'),
    ('Control-Right','Ctrl+Right'),
    ('PageUp','Prior'), ('Prior','Prior'),('Shift-PageUp','Shift+Prior'),
    ('PageDn','Next'),('Next','Next'),('Shift-Next','Shift+Next'),
)
for setting, result in table:
    val = c.k.strokeFromSetting(setting)
    assert val==result,'Expected %s, Got %s' % (result,val)
</t>
<t tx="ekr.20100131171342.5609" annotate="7d71002e"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoKeys tests.')
</t>
<t tx="ekr.20100131171342.5610"></t>
<t tx="ekr.20100131171342.5611">pc = g.app.pluginsController

aList1 = pc.getHandlersForTag('select1')
aList2 = pc.getHandlersForOneTag('select1')

assert type(aList1) == type([])
assert type(aList2) == type([])
assert aList1 == aList2
</t>
<t tx="ekr.20100131171342.5612"></t>
<t tx="ekr.20100131171342.5613">def sendEmail(self):
    pass # g.trace('self2',self)

class test:
    pass

X = test()
sendEmail(X)
</t>
<t tx="ekr.20100131180007.5359">c.frame.tree.OnIconDoubleClick(p)
</t>
<t tx="ekr.20100131180007.5361">x = c.shadowController
table = (
    ('python','abc',False),
    ('python','#abc',False),
    ('python','#verbatim',False),
    ('python','#@verbatim',True),
    ('c','abc',False),
    ('c','//@',False),
    ('c','//@verbatim',True),
    ('html','#@abc',False),
    ('html','&lt;!--abc--&gt;',False),
    ('html','&lt;!--@verbatim --&gt;',True),
    ('xxxx','#--unknown-language--@verbatim',True)
)
for language,s,expected in table:
    delims = g.set_delims_from_language(language)
    marker = x.Marker(delims)
    result = marker.isVerbatimSentinel(s)
    assert result==expected,'language %s s: %s expected %s got %s' % (
        language,s,expected,result)
</t>
<t tx="ekr.20100131180007.5362">x = c.shadowController
table = (
    ('python','abc',False),
    ('python','#abc',False),
    ('python','#@abc',True),
    ('python','@abc#',False),
    ('c','abc',False),
    ('c','//@',True),
    ('c','// @abc',False),
    ('c','/*@ abc */',True),
    ('c','/*@ abc',False),
    ('html','#@abc',False),
    ('html','&lt;!--abc--&gt;',False),
    ('html','&lt;!--@ abc --&gt;',True),
    ('html','&lt;!--@ abc -&gt;',False),
    ('xxxx','#--unknown-language--@',True)
)
for language,s,expected in table:
    delims = g.set_delims_from_language(language)
    marker = x.Marker(delims)
    result = marker.isSentinel(s)
    assert result==expected,'language %s s: %s expected %s got %s' % (
        language,s,expected,result)
</t>
<t tx="ekr.20100131180007.5363">x = c.shadowController
table = (
    ('python','#',''),
    ('c','//',''),
    ('html','&lt;!--','--&gt;'),
    ('xxxx','#--unknown-language--',''),
)
for language,delim1,delim2 in table:
    delims = g.set_delims_from_language(language)
    marker = x.Marker(delims)
    result = marker.getDelims()
    expected = delim1,delim2
    assert result==expected,'language %s expected %s got %s' % (
        language,expected,result)
</t>
<t tx="ekr.20100131180007.5364">x = c.shadowController

table = (
    ('ini',';','',),
    ('c','//',''),
    ('h','//',''),
    ('py','#',''),
    ('xyzzy','#--unknown-language--',''),
)

for ext,delim1,delim2 in table:
    filename = 'x.%s' % ext
    marker = x.markerFromFileName(filename)
    result1,result2 = marker.getDelims()
    assert delim1==result1, 'ext=%s, got %s, expected %s' % (
        ext,delim1,result1)
    assert delim2==result2, 'ext=%s, got %s, expected %s' % (
        ext,delim2,result2)
</t>
<t tx="ekr.20100131180007.5365">x = c.shadowController
# Add -ver=4 so at.parseLeoSentinel does not complain.
table = (
    ('c',('//@+leo-ver=4','a'),                   '//',''),
    ('c',('//@first','//@+leo-ver=4','b'),        '//',''),
    ('c',('/*@+leo-ver=4*/','a'),                 '/*','*/'),
    ('c',('/*@first*/','/*@+leo-ver=4*/','b'),    '/*','*/'),
    ('python',('#@+leo-ver=4','a'),               '#',''),
    ('python',('#@first','#@+leo-ver=4','b'),     '#',''),
    ('error',('',),             '#--unknown-language--',''),
    ('html',('&lt;!--@+leo-ver=4--&gt;','a'),                '&lt;!--','--&gt;'),
    ('html',('&lt;!--@first--&gt;','&lt;!--@+leo-ver=4--&gt;','b'),'&lt;!--','--&gt;'),
)

for language,lines,delim1,delim2 in table:
    s = x.findLeoLine(lines)
    marker = x.markerFromFileLines(lines,'test-file-name')
    result1,result2 = marker.getDelims()
    assert delim1==result1, 'language %s expected1 %s got %s lines %s' % (
        language,delim1,result1,'\n'.join(lines))
    assert delim2==result2, 'language %s expected2 %s got %s lines %s' % (
        language,delim1,result1,'\n'.join(lines))
</t>
<t tx="ekr.20100131180007.5366">x = c.shadowController
table = (
    ('c',('//@+leo','a'),                   '//@+leo'),
    ('c',('//@first','//@+leo','b'),        '//@+leo'),
    ('c',('/*@+leo*/','a'),                 '/*@+leo*/'),
    ('c',('/*@first*/','/*@+leo*/','b'),    '/*@+leo*/'),
    ('python',('#@+leo','a'),               '#@+leo'),
    ('python',('#@first','#@+leo','b'),     '#@+leo'),
    ('error',('',),''),
    ('html',('&lt;!--@+leo--&gt;','a'),                '&lt;!--@+leo--&gt;'),
    ('html',('&lt;!--@first--&gt;','&lt;!--@+leo--&gt;','b'),'&lt;!--@+leo--&gt;'),
)
for language,lines,expected in table:
    result = x.findLeoLine(lines)
    assert expected==result, 'language %s expected %s got %s lines %s' % (
        language,expected,result,'\n'.join(lines))
</t>
<t tx="ekr.20100131180007.5367">c,p = g.getTestVars()
x = c.shadowController

fn = 'does/not/exist'
assert not g.os_path_exists(fn)
assert not x.replaceFileWithString (fn,'abc')
</t>
<t tx="ekr.20100131180007.5369">table = (
    '1',
    '1-1','1-1-1','1-1-2',
    '1-2','1-2-1','1-2-2',
    '2',
    '2-1','2-1-1','2-1-2',
    '2-2','2-2-1','2-2-2',
    '3',
    '3-1','3-1-1','3-1-2',
    '3-2','3-2-1','3-2-2',
)

for suffix in table:
    h = 'node %s' % suffix
    p2 = g.findNodeInTree(c,p,h)
    assert p2,h

table2 = (
    ('2-1-2','2-1-1','2-1-1'),
    ('3','2','2'),
)  

for h1,h2,h3 in table2:
    p1 = g.findNodeInTree(c,p,'node %s' % h1)
    p2 = g.findNodeInTree(c,p,'node %s' % h2)
    p3 = g.findNodeInTree(c,p,'node %s' % h3)
    p1._adjustPositionBeforeUnlink(p2)
    result = p1
    assert result.stack == p3.stack,'expected %s got %s' % (
        p3.h,result and result.h or '&lt;none&gt;')

# Data.
@others
</t>
<t tx="ekr.20100131180007.5370"># Node 1
</t>
<t tx="ekr.20100131180007.5371"># node 1-1
</t>
<t tx="ekr.20100131180007.5372"># node 1-1-1
</t>
<t tx="ekr.20100131180007.5373"># node 1-1-2
</t>
<t tx="ekr.20100131180007.5374"># node 1-2
</t>
<t tx="ekr.20100131180007.5375"># node 1-2-1
</t>
<t tx="ekr.20100131180007.5376"># node 1-2-2
</t>
<t tx="ekr.20100131180007.5377"># node 2
</t>
<t tx="ekr.20100131180007.5378"># node 2-1
</t>
<t tx="ekr.20100131180007.5379"># node 2-1-1
</t>
<t tx="ekr.20100131180007.5380"># node 2-1-2
</t>
<t tx="ekr.20100131180007.5381"># node 2-2
</t>
<t tx="ekr.20100131180007.5382"># node 2-2-1
</t>
<t tx="ekr.20100131180007.5383"># node 2-2-2
</t>
<t tx="ekr.20100131180007.5384"># node 3
</t>
<t tx="ekr.20100131180007.5385"># node 3-1
</t>
<t tx="ekr.20100131180007.5386"># node 3-1-1
</t>
<t tx="ekr.20100131180007.5387"># node 3-1-2
</t>
<t tx="ekr.20100131180007.5388"># node 3-2
</t>
<t tx="ekr.20100131180007.5389"># node 3-2-1
</t>
<t tx="ekr.20100131180007.5390"># node 3-2-2
</t>
<t tx="ekr.20100131180007.5391">table = (
    ('@auto-rst rst-file','rst-file','rst-file'),
    ('@auto x','x',''),
    ('xyz','',''),
)

for s,expected1,expected2 in table:
    result1 = p.v.atAutoNodeName(h=s)
    result2 = p.v.atAutoRstNodeName(h=s)
    assert result1 == expected1,'fail1: given %s expected %s got %s' % (
        repr(s),repr(expected1),repr(result1))
    assert result2 == expected2,'fail2: given %s expected %s got %s' % (
        repr(s),repr(expected2),repr(result2))
</t>
<t tx="ekr.20100131180007.5395">for s,expected in (
    ('a\nb', 'a\nb'),
    ('\n  \nb\n', 'b\n'),
    (' \t \n\n\n c', ' c'),
):
    result = g.removeLeadingBlankLines(s)
    assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
        repr(s),repr(expected),repr(result))
</t>
<t tx="ekr.20100131180007.5396">for s,expected in (
    ('a\nb', 'a\nb'),
    ('\n  \n\nb\n', 'b\n'),
    (' \t \n\n  \n c\n\t\n', ' c\n'),
):
    result = g.removeBlankLines(s)
    assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
        repr(s),repr(expected),repr(result))
</t>
<t tx="ekr.20100131180007.5398">if 1: # The following must be indented.

    s = '''\
    a
      b

c
    d'''

    s2 = '    a\n      b\n\nc\n    d'

    result = g.adjustTripleString(s,c.tab_width)
    # print(c.tab_width)
    # print(result)
    # print('=====')
    # print(s2)
    assert result == s2,repr(result)
</t>
<t tx="ekr.20100131180007.5402">s = 'aa bc \n \n\t\n'
table = (
    ('\t\n ','aa bc'),
    ('abc\t\n ',''),
    ('c\t\n ','aa b'),
)

for arg,val in table:
    result = g.removeTrailing(s,arg)
    assert result == val, 'expected %s, got %s' % (val,result)
</t>
<t tx="ekr.20100131180007.5403">s = ' \n \n\t\naa bc'
s2 = 'aa bc'

for i in range(3):
    result = g.ensureLeadingNewlines(s,i)
    val = ('\n' * i) + s2
    assert result == val, 'expected %s, got %s' % (
        repr(val),repr(result))
</t>
<t tx="ekr.20100131180007.5404">s = 'aa bc \n \n\t\n'
s2 = 'aa bc'

for i in range(3):
    result = g.ensureTrailingNewlines(s,i)
    val = s2 + ('\n' * i)
    assert result == val, 'expected %s, got %s' % (
        repr(val),repr(result))
</t>
<t tx="ekr.20100131180007.5417">import zipfile
lm = g.app.loadManager

# Create a zip file for testing.
s = 'this is a test file'
testDir = g.os_path_join(g.app.loadDir,'..','test')
assert g.os_path_exists(testDir)
path = g.os_path_finalize_join(testDir,'testzip.zip')
theFile = zipfile.ZipFile(path,'w')
theFile.writestr('leo-zip-file',s)
theFile.close()

# Open the file, and use read (with no args) to get the contents.
theFile = lm.openLeoOrZipFile(path)
assert theFile
s2 = theFile.read()
assert s == s2,'s:  %s\ns2: %s' % (repr(s),repr(s2))
</t>
<t tx="ekr.20100131180007.5421">c,p = g.getTestVars()

# result,error = g.setDefaultDirectory(c,p,importing=False)
# assert error == ''
# assert result == c.openDirectory,result

result = g.setDefaultDirectory(c,p,importing=False)
assert result == c.openDirectory,result
</t>
<t tx="ekr.20100131180007.5425"># New in Leo 4.6, set_delims_from_string returns '' instead of None.
table = (
    ('c','@comment // /* */',   ('//','/*','*/')),
    ('c','// /* */',            ('//','/*','*/')),
    ('python','@comment #',     ('#','','')),
    ('python','#',              ('#','','')),
    ('xxxyyy','@comment a b c', ('a','b','c')),
    ('xxxyyy','a b c',          ('a','b','c')),
)

for language,s,expected in table:
    result = g.set_delims_from_string(s)
    assert result==expected,'language %s expected %s, got %s' % (
        language,expected,result)
</t>
<t tx="ekr.20100131180007.5426"># New in Leo 4.6, set_delims_from_language returns '' instead of None.
table = (
    ('c',       ('//','/*','*/')),
    ('python',  ('#','','')),
    ('xxxyyy',  ('','','')),
)

for language, expected in table:
    result = g.set_delims_from_language(language)
    assert result==expected,'language %s expected %s, got %s' % (
        language,expected,result)
</t>
<t tx="ekr.20100131180007.5427">table =  (
    (None,None), # Retain empty paths for warnings.
    ('',''),
    (g.app.loadDir,g.app.loadDir),
    ('&lt;abc&gt;','abc'),
    ('"abc"','abc'),
    ("'abc'",'abc'),
)

for path,expected in table:
    result = g.stripPathCruft(path)
    assert result == expected
</t>
<t tx="ekr.20100131180007.5428"># New in Leo 4.6, set_delims_from_language returns '' instead of None.
table = (
    ('.c',      ('//','/*','*/')),
    ('.html',   ('', '&lt;!--', '--&gt;')),
    ('.py',     ('#','','')),
    ('.xxx',    ('','','')),
)

for ext, expected in table:
    result = g.comment_delims_from_extension(ext)
    assert result==expected,'ext %s expected %s, got %s' % (
        ext,expected,result)
</t>
<t tx="ekr.20100131180007.5429">import os,stat

fc = c.fileCommands
path = g.os_path_finalize_join(g.app.loadDir,'..','test','test-read-only.txt')
if os.path.exists(path):
    os.chmod(path, stat.S_IREAD)
    fc.warnOnReadOnlyFiles(path)
    assert fc.read_only
else:
    fc.warnOnReadOnlyFiles(path)
</t>
<t tx="ekr.20100131180007.5434">@language python
@comment a b c
    # @comment must follow @language.
@tabwidth -8
@pagewidth 72
@encoding utf-8
# @path: anError # @path ends with ':'.

# @path xyzzy # Creates folder called xyzzy: interferes with other unit tests.

d = g.get_directives_dict(p)

# assert d.get('_p') == p # Never used, and a bad idea.
assert d.get('language') == 'python'
assert d.get('tabwidth') == '-8'
assert d.get('pagewidth') == '72'
assert d.get('encoding') == 'utf-8'
assert d.get('comment') == 'a b c'
assert not d.get('path'),d.get('path')
# assert d.get('path').endswith('xyzzy')
</t>
<t tx="ekr.20100131180007.5435">@header

c,p = g.getTestVars()
aList = g.get_directives_dict_list(p)
g.scanAtHeaderDirectives(aList)
</t>
<t tx="ekr.20100131180007.5442">@pagewidth -40

aList = g.get_directives_dict_list(p)
n = g.scanAtPagewidthDirectives(aList)

# The @pagewidth directive in the parent should control.
# Depending on how this test is run, the result could be 80 or None.
assert n in (None,80),repr(n)
</t>
<t tx="ekr.20100131180007.5450">expectedIconDictList = [
{
    'on': 'tnode',
    'where': 'beforeHeadline',
    'yoffset': 0,
    # 'file': u'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\add.png',
    'file': 'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\add.png',
    'xpad': 1,
    'type': 'file',
    'xoffset': 2,
    # 'relPath': u'Tango\\16x16\\actions\\add.png',
    'relPath': 'Tango\\16x16\\actions\\add.png',
},
{
    'on': 'tnode',
    'where': 'beforeHeadline',
    'yoffset': 0,
    # 'file': u'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\bottom.png',
    'file': 'C:\\leo.repo\\trunk\\leo\\Icons\\Tango\\16x16\\actions\\bottom.png',
    'xpad': 1,
    'type': 'file',
    'xoffset': 2,
    # 'relPath': u'Tango\\16x16\\actions\\bottom.png',
    'relPath': 'Tango\\16x16\\actions\\bottom.png',
}]
table = (
('tx','raw',None,"ekr.20090701133940.1767"),
('lineYOffset',None,3,"4b032e"),
# A real icon
('icons',None,expectedIconDictList,
"5d7100287d71012855026f6e71025505746e6f6465710355047479\
70657104550466696c6571055507796f666673657471064b006805583700000\
0433a5c6c656f2e7265706f5c7472756e6b5c6c656f5c49636f6e735c54616e\
676f5c31367831365c616374696f6e735c6164642e706e67710755047870616\
471084b01550577686572657109550e6265666f7265486561646c696e65710a\
5507786f6666736574710b4b02550772656c50617468710c581b00000054616\
e676f5c31367831365c616374696f6e735c6164642e706e67710d757d710e28\
55026f6e710f68035504747970657110550466696c6571115507796f6666736\
57471124b006811583a000000433a5c6c656f2e7265706f5c7472756e6b5c6c\
656f5c49636f6e735c54616e676f5c31367831365c616374696f6e735c626f7\
4746f6d2e706e67711355047870616471144b01550577686572657115550e62\
65666f7265486561646c696e6571165507786f666673657471174b025507726\
56c506174687118581e00000054616e676f5c31367831365c616374696f6e73\
5c626f74746f6d2e706e67711975652e"),
)
for attr,kind,expected,val in table:
    result = c.fileCommands.getSaxUa(attr,val,kind=kind)
    if expected is None: expected = val
    assert g.toEncodedString(expected)==result,'expected %s got %s' % (
        expected,result)
</t>
<t tx="ekr.20100131180007.5451">s = 'test%cthis' % 27

assert c.fileCommands.cleanSaxInputString(s) == 'test this'
</t>
<t tx="ekr.20100131180007.5453"># A totally wimpy test.
# And it somehow prints a newline to the console.
if 0:
    c.abbrevCommands.dynamicExpandHelper(event=None,prefix='',aList=[],w=None)
</t>
<t tx="ekr.20100131180007.5454">at = c.atFileCommands

at.setPathUa(p,'abc')
d = p.v.tempAttributes
d2 = d.get('read-path')
val1 = d2.get('path')
val2 = at.getPathUa(p)

table = (
    ('d2.get',val1),
    ('at.getPathUa',val2),
)
for kind,val in table:
    assert val == 'abc','kind %s expected %s got %s' % (
        kind,'abc',val)
</t>
<t tx="ekr.20100131180007.5455">p2 = p.firstChild().firstChild()
path = g.fullPath(c,p2,simulate=True)
end = g.os_path_normpath('abc/xyz')
assert path.endswith(end),repr(path)
</t>
<t tx="ekr.20100131180007.5456"></t>
<t tx="ekr.20100131180007.5457"></t>
<t tx="ekr.20100131180007.5458">at = c.atFileCommands
d = at.scanAllDirectives(p)
</t>
<t tx="ekr.20100131180007.5459">rst = c.rstCommands
rst.initAtAutoWrite(p,fileName='&lt;test file&gt;',outputFile=None)

# Ensure we are actually testing the default logic.
d = p.v.u.get('rst-import',{})
underlines = d.get('underline_characters')
assert underlines is None,'fail 1: %s' % repr(underlines)
assert d == {},'fail 2: %s' % repr(d)
# Now test the logic.
assert rst.underlines2 == '','fail 3: %s' % repr(rst.underlines2)
assert rst.underlines1 == '=+*^~"\'`-:&gt;&lt;_', 'fail4 %s' % repr(rst.underlines1)
assert rst.atAutoWriteUnderlines == '=+*^~"\'`-:&gt;&lt;_', 'fail 5: %s' % (
    repr(rst.atAutoWriteUnderlines))
</t>
<t tx="ekr.20100131180007.5460">sax_node = g.bunch(
    attributes={
'a':'M',
'lineYOffset':"4b032e",
# A real icon attribute, see the tests below for what we expect
'icons':"5d7100287d71012855026f6e71025505746e6f6465710355047479\
70657104550466696c6571055507796f666673657471064b006805583700000\
0433a5c6c656f2e7265706f5c7472756e6b5c6c656f5c49636f6e735c54616e\
676f5c31367831365c616374696f6e735c6164642e706e67710755047870616\
471084b01550577686572657109550e6265666f7265486561646c696e65710a\
5507786f6666736574710b4b02550772656c50617468710c581b00000054616\
e676f5c31367831365c616374696f6e735c6164642e706e67710d757d710e28\
55026f6e710f68035504747970657110550466696c6571115507796f6666736\
57471124b006811583a000000433a5c6c656f2e7265706f5c7472756e6b5c6c\
656f5c49636f6e735c54616e676f5c31367831365c616374696f6e735c626f7\
4746f6d2e706e67711355047870616471144b01550577686572657115550e62\
65666f7265486561646c696e6571165507786f666673657471174b025507726\
56c506174687118581e00000054616e676f5c31367831365c616374696f6e73\
5c626f74746f6d2e706e67711975652e"
})
try:
    p2 = p.insertAsLastChild()
    v = p2.v
    c.fileCommands.handleVnodeSaxAttributes(sax_node,v)
    d = v.u
    for attr in ('lineYOffset','icons'):
        assert d.get(attr) is not None,attr
    # The a:M attribute should mark the node.
    assert d.get('a') is None
    assert v.isMarked()
    aList = d.get('icons')
    assert aList
    assert len(aList) == 2
    for d2 in aList:
        for key in ('on','where','yoffset','file'):
            assert d2.get(key) is not None,key
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete()
</t>
<t tx="ekr.20100131180007.5461">at = c.atFileCommands

fn = 'does/not/exist'
assert not g.os_path_exists(fn)
assert not at.replaceFileWithString (fn,'abc')
</t>
<t tx="ekr.20100131180007.5462"># Here is something that should generate a verbtim sentinel::

#@+leo-encoding=iso-8859-1.

# The length of this node should remain constant.

assert len(p.b) == 175,len(p.b)
</t>
<t tx="ekr.20100131180007.5463">sax_node = g.bunch(
    tnodeAttributes={
# The 'tx' attribute is handled by contentHandler.tnodeAttributes.
# 'tx':"ekr.20090701133940.1767",
'lineYOffset':"4b032e",
# A real icon attribute, see the tests below for what we expect
'icons':"5d7100287d71012855026f6e71025505746e6f6465710355047479\
70657104550466696c6571055507796f666673657471064b006805583700000\
0433a5c6c656f2e7265706f5c7472756e6b5c6c656f5c49636f6e735c54616e\
676f5c31367831365c616374696f6e735c6164642e706e67710755047870616\
471084b01550577686572657109550e6265666f7265486561646c696e65710a\
5507786f6666736574710b4b02550772656c50617468710c581b00000054616\
e676f5c31367831365c616374696f6e735c6164642e706e67710d757d710e28\
55026f6e710f68035504747970657110550466696c6571115507796f6666736\
57471124b006811583a000000433a5c6c656f2e7265706f5c7472756e6b5c6c\
656f5c49636f6e735c54616e676f5c31367831365c616374696f6e735c626f7\
4746f6d2e706e67711355047870616471144b01550577686572657115550e62\
65666f7265486561646c696e6571165507786f666673657471174b025507726\
56c506174687118581e00000054616e676f5c31367831365c616374696f6e73\
5c626f74746f6d2e706e67711975652e"
})
try:
    p2 = p.insertAsLastChild()
    v = p2.v
    c.fileCommands.handleTnodeSaxAttributes(sax_node,v)
    d = v.u
    for attr in ('lineYOffset','icons'):
        assert d.get(attr),attr
    for attr in ('tx','a'):
        assert d.get(attr) is None,attr # A known attribute.
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete()
</t>
<t tx="ekr.20100131180007.5465">class StubConfig(g.nullObject):
    pass

x = StubConfig()
assert not x.getBool(c,'mySetting')
assert not x.enabledPluginsFileName
</t>
<t tx="ekr.20100131180007.5466">p2 = p.firstChild().firstChild().firstChild()
aList = g.get_directives_dict_list(p2)
path = c.scanAtPathDirectives(aList)
endpath = g.os_path_normpath('one/two')
assert path and path.endswith(endpath),'expected ending %s got %s' % (
    endpath,path)
</t>
<t tx="ekr.20100131180007.5467"></t>
<t tx="ekr.20100131180007.5468"></t>
<t tx="ekr.20100131180007.5469"></t>
<t tx="ekr.20100203103015.5353"># Not a perfect test, but stil significant.
efc = g.app.externalFilesController
result = efc.ask(c,p.h)
assert result in (True, False),result
</t>
<t tx="ekr.20100203103015.5354">efc = g.app.externalFilesController
s = efc.temp_file_path(c,p,'.py')
assert s.endswith('.py')
</t>
<t tx="ekr.20100203103015.5355">@language python

efc = g.app.externalFilesController

table = (
    # (None,'.py'),
    # ('','.py'),
    ('txt','.txt'),
    ('.txt','.txt'),
)

for ext,result in table:
    result2 = efc.get_ext(c,p,ext)
    assert result==result2,'ext: %s, expected %s, got %s' % (
        repr(ext),repr(result),repr(result2))
</t>
<t tx="ekr.20100203103015.5356">arg = ''
arg0 = 'one'
fn = '&lt;fn&gt;'
filename = '' # g.os.path.basename(arg)
vtuple = [arg0,fn]

table = (
    #('os.system',       'os.system(%s)' % (arg+fn)),
    #('os.startfile',    'os.startfile(%s)' % (arg+fn)),
    #('exec',            'exec(%s)' % (arg+fn)),
    #('os.spawnl',       'os.spawnl(%s,%s,%s)' % (arg,filename,fn)),
    #('os.spawnv',       'os.spawnv(%s,%s)' % (arg0,vtuple)),
    ('subprocess.Popen','subprocess.Popen(%s)' % vtuple),
    ('huh?',            'bad command:'+'huh?'),
)

for openType,result in table:
    if openType in ('os.spawnv','subprocess.Popen'):
        arg2 = ['one']
    else:
        arg2 = None
    result2 = c.openTempFileInExternalEditor(
        arg2,fn,openType,testing=True)
    assert result==result2,'expected %s, got %s' % (
        repr(result),repr(result2))
</t>
<t tx="ekr.20100203103015.5357">def spam(): pass
lam = lambda a: None
class aCallable:
    def __call__ (self):
        pass
c = aCallable()

table = (
    ('abc',False),
    (spam,True),
    (lam,True),
    (c,True)
)

for obj,val in table:
    val2 = g.isCallable(obj)
    assert val == val2,'%s, expected %s, got %s' % (
        repr(obj),val,val2)
</t>
<t tx="ekr.20100204165850.5371"># These tests will be important when revising config code.
</t>
<t tx="ekr.20100204165850.5373">k = c.k
colorizer = c.frame.body.getColorizer()
ed = c.editCommands
# These don't set ivars
    # 'toggle-active-pane'),
    # 'toggle-angle-brackets',
    # 'toggle-input-state'),
    # 'toggle-mini-buffer'),
    # 'toggle-split-direction'),
table = [
    (k,'abbrevOn','toggle-abbrev-mode'),
    (ed,'extendMode','toggle-extend-mode'),
]
# Not valid for external tests.
table2 = [
    (k,'enable_autocompleter','toggle-autocompleter'),
    (k,'enable_calltips','toggle-calltips'),
    (c,'sparse_find','toggle-find-collapses-nodes'),
    (colorizer,'showInvisibles','toggle-invisibles'),
    (c,'sparse_move','toggle-sparse-move'),
]
if not g.app.isExternalUnitTest:
    table.extend(table2)
for obj,ivar,command in table:
    val1 = getattr(obj,ivar)
    try:
        k.simulateCommand(command)
        val2 = getattr(obj,ivar)
        assert val2 == (not val1),'failed 1 %s' % command
        k.simulateCommand(command)
        val3 = getattr(obj,ivar)
        assert val3 == val1,'failed 2 %s' % command
    finally:
        setattr(obj,ivar,val1)
</t>
<t tx="ekr.20100204173354.5375">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    table = (
        # ('ignore_case','toggle-find-ignore-case-option'),
            # This option now can be set automagically.
        ('search_body','toggle-find-in-body-option'),
        ('search_headline','toggle-find-in-headline-option'),
        ('mark_changes','toggle-find-mark-changes-option'),
        ('mark_finds','toggle-find-mark-finds-option'),
        ('pattern_match','toggle-find-regex-option'),
        # ('reverse','toggle-find-reverse-option'),
        ('whole_word','toggle-find-word-option'),
        ('wrap','toggle-find-wrap-around-option'),
    )
    fc = c.findCommands
    for ivar,command in table:
        val1 = getattr(fc,ivar)
        try:
            c.k.simulateCommand(command)
            val2 = getattr(fc,ivar)
            assert val2 == (not val1),'failed 1 %s' % command
            c.k.simulateCommand(command)
            val3 = getattr(fc,ivar)
            assert val3 == val1,'failed 2 %s' % command
        finally:
            setattr(fc,ivar,val1)
</t>
<t tx="ekr.20100206165505.5386"># More suitable as a hand test:
# it makes no effort to delete the 'Recovered Nodes' node.

c.nodeConflictList = []

for i in range(2):
    c.nodeConflictList.append(g.bunch(
        tag='(uncached)',
        gnx='gnx %s' % (i),
        fileName ='filename %s' % (i),
        b_old='old body %s' % (i),
        b_new='new body %s' % (i),
        h_old='head %s' % (i),
        h_new='head %s' % (i),
    ))

c.fileCommands.handleNodeConflicts()

c.nodeConflictList = []

c.redraw()
</t>
<t tx="ekr.20100209155559.5386">efc = g.app.externalFilesController
d = {'ext':'.py',}
fn = efc.create_temp_file(c,d,p)
assert g.os_path_exists(fn),fn
efc.shut_down()
assert not g.os_path_exists(fn),fn
</t>
<t tx="ekr.20100211110729.5389">@first # -*- coding: utf-8 -*-

# On Windows, this works with or without the following line in sitecustomize.py
# sys.setdefaultencoding('utf-8')

import os

if g.isPython3:
    fn ='.leo'
else:
    fn = g.toUnicode('.leo')

g.app.recentFilesManager.writeRecentFilesFileHelper(fn)
assert g.os_path_exists(fn),'fail 1'
os.remove(fn)
assert not g.os_path_exists(fn),'fail 1'
</t>
<t tx="ekr.20100212104817.5346">c.sortRecentFiles()
</t>
<t tx="ekr.20100212104817.5347">child = p.firstChild()
assert child.h == 'b','fail 1'
try:
    c.selectPosition(child)
    c.sortSiblings()
    c.redraw_now()
    child = p.firstChild()
    assert child.h == 'a'
    child = child.next()
    assert child.h == 'b'
    child = child.next()
    assert child.h == 'c'
    assert not child.next()
finally:
    c.undoer.undo()
    p.contract()
    c.redraw(p)
</t>
<t tx="ekr.20100212104817.5348"></t>
<t tx="ekr.20100212104817.5349"></t>
<t tx="ekr.20100212104817.5350"></t>
<t tx="ekr.20100212104817.5351">result = c.helpCommands.getBindingsForCommand('help')
assert result.strip().lower()=='f1'
</t>
<t tx="ekr.20100212110954.5359">lines = c.k.printBindings()
# assert lines[0].strip().endswith('Alt+Ctrl+Shift')
</t>
<t tx="ekr.20100212112056.5361">g.printGcAll()
</t>
<t tx="ekr.20100219080213.5365"></t>
<t tx="ekr.20100219080213.5366">s = '''\
&lt;?php

$type = 'cc';
$obj = new $type; // outputs "hi!"

class cc {
    function __construct() {
        echo 'hi!';
    }
}

?&gt;

'''

c.importCommands.phpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20100219080213.5367">s = '''\
&lt;?php

if (expr) {
    class cc {
        // version 1
    }
} else {
    class cc {
        // version 2
    }
}

?&gt;
'''

c.importCommands.phpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20100219080213.5368">s = '''\
&lt;?php
class Enum {
    protected $self = array();
    public function __construct( /*...*/ ) {
        $args = func_get_args();
        for( $i=0, $n=count($args); $i&lt;$n; $i++ )
            $this-&gt;add($args[$i]);
    }

    public function __get( /*string*/ $name = null ) {
        return $this-&gt;self[$name];
    }

    public function add( /*string*/ $name = null, /*int*/ $enum = null ) {
        if( isset($enum) )
            $this-&gt;self[$name] = $enum;
        else
            $this-&gt;self[$name] = end($this-&gt;self) + 1;
    }
}

class DefinedEnum extends Enum {
    public function __construct( /*array*/ $itms ) {
        foreach( $itms as $name =&gt; $enum )
            $this-&gt;add($name, $enum);
    }
}

class FlagsEnum extends Enum {
    public function __construct( /*...*/ ) {
        $args = func_get_args();
        for( $i=0, $n=count($args), $f=0x1; $i&lt;$n; $i++, $f *= 0x2 )
            $this-&gt;add($args[$i], $f);
    }
}
?&gt;

'''

c.importCommands.phpUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20100223123103.5382">import leo.core.leoFrame as leoFrame

# Do nothing when run externally.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
if g.app.gui.guiName() == 'curses':
    self.skipTest('Not valid for curses gui')
else:
    assert not isinstance(c.frame,leoFrame.NullFrame)
    def closeEnough(f1,f2):
        return abs(f1-f2) &lt; 0.01
    f = c.frame
    ratio,ratio2 = f.ratio,f.secondary_ratio
    table = (
        c.bodyWantsFocusNow,
        c.logWantsFocusNow,
        c.treeWantsFocusNow,
    )
    for func in table:
        name = func.__name__
        func()
        f.contractPane()
        if func == c.logWantsFocusNow:
            assert ratio2 != f.secondary_ratio,'fail 1'
        else:
            assert ratio != f.ratio,'fail 2: %s, %s: %s' % (ratio,f.ratio,name)
        func()
        f.expandPane()
        assert closeEnough(ratio,f.ratio),'fail 3 %s != %s: %s' % (
            ratio,f.ratio,name)
        assert closeEnough(ratio2,f.secondary_ratio),'fail 4 %s != %s: %s' % (
            ratio2,f.secondary_ratio,name)
</t>
<t tx="ekr.20100225094004.5385">s1 = '''
#@+leo-ver=4
#@+node:#@file
Line 1
#@-node:#@file
#@-leo
'''

s2 = '''
#@+leo-ver=4-thin
#@+node:ekr.20040707141957.13:#@thin
#@-node:ekr.20040707141957.13:#@thin
#@-leo
'''

at = c.atFileCommands
assert at.isFileLike(s1),'fail1'
assert not at.isFileLike(s2),'fail2'
</t>
<t tx="ekr.20100731163237.5778">@language python

# Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:
    # html uses block comments.  This is an important test.
    h = '@thin unittest/at-thin-html-test.html'
    p = g.findNodeAnywhere(c,h)
    assert p
    s = (
        '@language html\n\n&lt;&lt; ' +
        'a section reference &gt;&gt;\n\n' +
        'after.\n')
    assert p.b == s,'body failure'
</t>
<t tx="ekr.20100731163237.5782">@language html

&lt;&lt; a section reference &gt;&gt;

after.
</t>
<t tx="ekr.20100731163237.5783">&lt;p&gt; a paragraph. &lt;/p&gt;
</t>
<t tx="ekr.20100801125533.5787">c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20100801125533.5788">@language python
@tabwidth -4
@others
#end
</t>
<t tx="ekr.20100801125533.5789">def spam(cheese):

    print(cheese)
</t>
<t tx="ekr.20100801125533.5790">def cheese():

    pass
</t>
<t tx="ekr.20100801125533.5791">def spam(cheese):

    print(cheese)
def cheese():

    pass
#end
</t>
<t tx="ekr.20100802220019.5795">def clone (p,parent,n):
    p2 = p.clone()
    p2.moveToNthChildOf(parent,n)
    return p2

def make (parent,n,h):
    child = parent.insertAsNthChild(n)
    child.h = h
    return child

def delete_r():
    '''Delete all 'Resurrected Nodes' nodes.'''
    while True:
        r = g.findNodeAnywhere(c,'Resurrected Nodes')
        if r: r.doDelete(newNode=p)
        else: break

def delete_children():
    # Delete all children of p.
    while p.hasChildren():
        p.firstChild().doDelete(newNode=p)

def test(p,h,tag):
    assert p,'p'
    assert p.h == 'From root','p.h %s' % tag
    assert p.numberOfChildren() == 1,'number of children %s' % tag
    assert p.firstChild().h == h,'child.h %s' % tag

delete_r()
delete_children()

# Create some children.
root = make(p,0,'root')
child1 = make(root,0,'child1')
child2 = make(root,1,'child2')
child3 = make(root,2,'child3')
child11 = make(child1,0,'child11')
child21 = make(child2,0,'child21')
child31 = make(child3,0,'child31')
# Create some clones.
if 0:
    child4 = clone(child31,root,3)
# Set all bits except for child2 &amp; child31.
for z in root.self_and_subtree():
    z.setVisited()
for z in child2,child31: # These should be moved.
    z.clearVisited()
if 1:
    c.atFileCommands.deleteUnvisitedNodes(root)
    c.redraw()
if 1:
    r = g.findNodeAnywhere(c,'Resurrected Nodes')
    assert r,'r'
    r1 = r.firstChild()
    r2 = r1.next()
    # r3 = r2.next()
    test(r1,'child31','r1')
    test(r2,'child2','r2')
    # assert root.numberOfChildren() == 3,'root.n'
if 1:
    delete_r()
if 1:
    delete_children()
c.redraw()
</t>
<t tx="ekr.20100803234640.5804"></t>
<t tx="ekr.20100803234640.5805">s = r'''; last modified 1 April 2001 by John Doe
[owner]
name=John Doe
organization=Acme Widgets Inc.

; [ not a section ]

[database]
server=192.0.2.62
    ; use IP address
port=143
file = "payroll.dat"
'''
table = ('[owner]', '[database]')
try:
    c.importCommands.iniUnitTest(p,s=s,showTree=True)
    root = c.p.firstChild()
    p2 = root.firstChild()
    for h in table:
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
    assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()

</t>
<t tx="ekr.20100812172232.5801">s = g.findTestScript(c,'@common leoRst test code',warn=False)
if s:
    exec(s)
    rst3Test(c,p)
</t>
<t tx="ekr.20100812182942.5805">@language rest
</t>
<t tx="ekr.20100812182942.5807">@language rest

#####
Title
#####

This is test.html
</t>
<t tx="ekr.20100812182942.5808">@ This is a doc part
it has two lines.
@c
This is the body of the section.
</t>
<t tx="ekr.20100812213445.5814">@language html
</t>
<t tx="ekr.20100812213445.5824">exec(g.findTestScript(c,'@common leoRst test code'))

rst3Test(c,p)
</t>
<t tx="ekr.20100812213445.5825">@language rest
</t>
<t tx="ekr.20100812213445.5826">@ @rst-options
show_doc_parts_as_paragraphs=True
@c
#####
Title
#####

This is test.html
</t>
<t tx="ekr.20100812213445.5827">@ This is a doc part
it has two lines.
@c
This is the body of the section.
</t>
<t tx="ekr.20100812213445.5828">@language html
</t>
<t tx="ekr.20100813100841.5824"># Skip test when running test dynamically.
s = g.findTestScript(c,'@common leoRst test code',warn=False)
if s:
    exec(s)
    rst3Test(c,p)
</t>
<t tx="ekr.20100813100841.5825"># Applies to options doc parts as well.
</t>
<t tx="ekr.20100813100841.5827"></t>
<t tx="ekr.20100813100841.5828"></t>
<t tx="ekr.20100813100841.5829"></t>
<t tx="ekr.20100813100841.5839">@language rest
</t>
<t tx="ekr.20100813100841.5840">#####
Title
#####

This is test.html
</t>
<t tx="ekr.20100813100841.5841">@ This is a doc part
it has two lines.
@c
This is the body of the section.
</t>
<t tx="ekr.20100813100841.5842"></t>
<t tx="ekr.20100813100841.5843">.. rst3: filename: test.html


#####
Title
#####

This is test.html

section
+++++++

@ This is a doc part
it has two lines.
@c

This is the body of the section.

</t>
<t tx="ekr.20100813100841.5844">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils 0.8: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
&amp;#64;c&lt;/p&gt;
&lt;p&gt;This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100813100841.5847"></t>
<t tx="ekr.20100813100841.5848">.. rst3: filename: test.html


#####
Title
#####

This is test.html

section
+++++++

@ This is a doc part
it has two lines.
This is the body of the section.

</t>
<t tx="ekr.20100813100841.5849">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100813100841.5850">s = g.findTestScript(c,'@common leoRst test code',warn=False)
if s:
    exec(s)
    rst3Test(c,p)
</t>
<t tx="ekr.20100813100841.5854">@language rest
</t>
<t tx="ekr.20100813100841.5855">@language rest

#####
Title
#####

This is test.html
</t>
<t tx="ekr.20100813100841.5856">This is the body of the section.
</t>
<t tx="ekr.20100813100841.5857"></t>
<t tx="ekr.20100813100841.5858">.. rst3: filename: test.html


#####
Title
#####

This is test.html

This is the body of the section.

</t>
<t tx="ekr.20100813100841.5859">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;p&gt;This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100813124317.5868"></t>
<t tx="ekr.20100813124317.5869">.. rst3: filename: test.html

#####
Title
#####

This is test.html



section
*******

This is a doc part
it has two lines.

</t>
<t tx="ekr.20100813124317.5870">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;This is a doc part
it has two lines.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100813124317.5879"># Skip test when running test dynamically.
s = g.findTestScript(c,'@common leoRst test code',warn=False)
if s:
    exec(s)
    rst3Test(c,p)
</t>
<t tx="ekr.20100813124317.5880">@language rest
</t>
<t tx="ekr.20100813124317.5881">#####
Title
#####

This is test.html
</t>
<t tx="ekr.20100813124317.5883">@ @rst-options
doc_only_mode=True
@c
@ This is a doc part
it has two lines.
@c
This is the body of the section.
</t>
<t tx="ekr.20100813124317.5884"></t>
<t tx="ekr.20100813124317.5889">.. rst3: filename: test.html

#####
Title
#####

This is test.html

section
+++++++

This is a doc part
it has two lines.

</t>
<t tx="ekr.20100813124317.5890">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;This is a doc part
it has two lines.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100817131738.5886">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20100817131738.5887">aaaa cccc dddd
</t>
<t tx="ekr.20100817131738.5888">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20100817131738.5889">aaaa cccc dddd
</t>
<t tx="ekr.20100817131738.5894">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20100817131738.5895">aaaa bbcc dddd
</t>
<t tx="ekr.20100817131738.5896">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20100817131738.5897">aaaa bbcc dddd
</t>
<t tx="ekr.20100827140832.5913"># Skip test when running test dynamically.
s = g.findTestScript(c,'@common leoRst test code',warn=False)
if s:
    exec(s)
    rst3Test(c,p)
</t>
<t tx="ekr.20100827140832.5917">@language rest
</t>
<t tx="ekr.20100827140832.5918">@language rest

@ @rst-options
show_leo_directives=False
@c

#####
Title
#####

This is test.html
</t>
<t tx="ekr.20100827140832.5919">@ This is a doc part
it has two lines.
@c
This is the body of the section.
</t>
<t tx="ekr.20100827140832.5926"></t>
<t tx="ekr.20100827140832.5929">.. rst3: filename: test.html



#####
Title
#####

This is test.html

section
+++++++

@ This is a doc part
it has two lines.
This is the body of the section.

</t>
<t tx="ekr.20100827140832.5930">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827182529.6840"></t>
<t tx="ekr.20100827182529.6841">.. rst3: filename: test.html


#####
Title
#####

This is test.html

section
+++++++

@ This is a doc part
it has two lines.
This is the body of the section.

</t>
<t tx="ekr.20100827182529.6842">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827182529.6843"></t>
<t tx="ekr.20100827182529.6844">.. rst3: filename: test.html


#####
Title
#####

This is test.html

This is the body of the section.

</t>
<t tx="ekr.20100827182529.6845">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;p&gt;This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827182529.6846"></t>
<t tx="ekr.20100827182529.6847">.. rst3: filename: test.html

#####
Title
#####

This is test.html



section
*******

@ This is a doc part
it has two lines.
This is the body of the section.

</t>
<t tx="ekr.20100827182529.6848">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827182529.6849"></t>
<t tx="ekr.20100827182529.6850">.. rst3: filename: test.html

#####
Title
#####

This is test.html

section
+++++++

@ This is a doc part
it has two lines.
This is the body of the section.

</t>
<t tx="ekr.20100827182529.6851">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827182529.6852"></t>
<t tx="ekr.20100827182529.6853">.. rst3: filename: test.html



#####
Title
#####

This is test.html

section
+++++++

@ This is a doc part
it has two lines.
This is the body of the section.

</t>
<t tx="ekr.20100827182529.6854">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document" id="title"&gt;
&lt;h1 class="title"&gt;Title&lt;/h1&gt;

&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;This is test.html&lt;/p&gt;
&lt;div class="section" id="section"&gt;
&lt;h1&gt;section&lt;/h1&gt;
&lt;p&gt;&amp;#64; This is a doc part
it has two lines.
This is the body of the section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20100827194549.5963">def report (self,expected,got):
    '''Report errors in an rst test.'''
    verbose = True
    expected_lines = g.splitLines(expected.b)
    got_lines = g.splitLines(got.b)
    for i in range(min(len(expected_lines),len(got_lines))):
        match = expected_lines[i]==got_lines[i]
        if verbose or not match:
            tag = g.choose(match,'  ','**')
            print ('%3d%s %s' % (i,tag,repr(expected_lines[i])))
            print ('%3d%s %s' % (i,tag,repr(got_lines[i])))
        if not verbose and not match:
            break
</t>
<t tx="ekr.20100830113702.5969">import sys
if g.app.gui.guiName() == 'qt':
    if sys.platform.startswith('linux'):
        self.skipTest('skip headline test')
    else:
        exec(g.findTestScript(c,'@common leoEditCommands test code'))
        runEditCommandTest(c,p,inHeadline=False)
        runEditCommandTest(c,p,inHeadline=True)
else:
    self.skipTest('skip qt test')
</t>
<t tx="ekr.20100830113702.5970">aaaa bbbb dddd
</t>
<t tx="ekr.20100830113702.5971">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20100830113702.5972">aaaa bbbb dddd
</t>
<t tx="ekr.20100830113702.5977">import sys
if g.app.gui.guiName() == 'qt':
    if sys.platform.startswith('linux'):
        self.skipTest('skip headline test')
    else:
        exec(g.findTestScript(c,'@common leoEditCommands test code'))
        runEditCommandTest(c,p,inHeadline=False)
        runEditCommandTest(c,p,inHeadline=True)
else:
    self.skipTest('skip qt test')
</t>
<t tx="ekr.20100830113702.5978">aaaa bbcc dddd
</t>
<t tx="ekr.20100830113702.5979">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20100830113702.5980">aaaa bbcc dddd
</t>
<t tx="ekr.20100902074747.5970">f = c.abbrevCommands.addAbbrevHelper
d = c.abbrevCommands.abbrevs

# New in Leo 4.10: whitespace (blank,tab,newline) *is* significant in definitions.
table = (
    ('ut1','ut1=aa','aa'),
    # ('ut2','ut2 =bb','bb'),
    ('ut3','ut3=cc=dd','cc=dd'),
    ('ut4','ut4= ee',' ee'),
    ('ut5','ut5= ff = gg',' ff = gg'),
    ('ut6','ut6= hh==ii',' hh==ii'),
    ('ut7','ut7=j=k','j=k'),
    ('ut8','ut8=l==m','l==m'),
    ('@ut1','@ut1=@a','@a'),
)

for name,s,expected in table:
    for s2,kind in ((s,'(no nl)'),(s+'\n','(nl)')):
        f(s2,tag='unit-test')
        result,tag = d.get(name,(None,None),)
        assert result==expected, '%s &lt;%s&gt; expected &lt;%s&gt;, got &lt;%s&gt;' % (
            kind,s,expected,result)
</t>
<t tx="ekr.20100909082308.5990">pc = g.app.pluginsController

table = (
    ('x',               'x'),
    ('foo.bar',         'foo.bar'),
    ('x.py',            'leo.plugins.x'),
    ('leo.plugins.x',   'leo.plugins.x')    
)

for fn,expected in table:
    result = pc.regularizeName(fn)
    assert result==expected,'expected %s, got %s' % (
        expected,result)
    # Make sure that calling regularizeName twice is benign.
    result2 = pc.regularizeName(result)
    assert result2==result
</t>
<t tx="ekr.20101020123501.6005">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20101020123501.6006">@language objective_c

@interface Application
    -(void) init;
    -(void) showMessage;
@end

@implementation Application 
    -(id) init {
        if (self = [super init]) {
            NSLog(@"Init ok");
            return self;
        }
        return nil;
    }
    -(void) showMessage {
        NSLog(@"Hello there");
    }
@end

@"Hello there"

,@interface
, @interface
the @interface

// By the way, I have noticed that such kind of words in doxygen block
// are highlighted properly, but they are labels here, not keywords1 as in my case.
/**
@var test
@todo
*/
</t>
<t tx="ekr.20101021205258.6010"></t>
<t tx="ekr.20101021205258.6011"></t>
<t tx="ekr.20101021210253.6018"></t>
<t tx="ekr.20101023195640.6033"></t>
<t tx="ekr.20101023195640.6034">@others
</t>
<t tx="ekr.20101023195640.6035">node 1 line 1
node 1 old line 1
node 1 old line 2
node 1 line 2
</t>
<t tx="ekr.20101023195640.6037">@others
</t>
<t tx="ekr.20101023195640.6038">node 1 line 1
node 1 new line 1
node 1 new line 2
node 1 new line 3
node 1 line 2
</t>
<t tx="ekr.20101023204543.6042"></t>
<t tx="ekr.20101023204543.6043">@others
</t>
<t tx="ekr.20101023204543.6044">node 1 line 1
node 1 old line 1
node 1 old line 2
node 1 old line 3
node 1 old line 4
node 1 line 2
</t>
<t tx="ekr.20101023204543.6045">@others
</t>
<t tx="ekr.20101023204543.6046">node 1 line 1
node 1 new line 1
node 1 new line 2
node 1 line 2
</t>
<t tx="ekr.20101220161557.6016"># Nov. 17, 2016: 878 tests.

# Some tests are disabled when g.app.isExternalUnitTest is True.
# Using self.skipTest(reason) is now preferred.</t>
<t tx="ekr.20110118082508.3729"></t>
<t tx="ekr.20110118082508.3730"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3745">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20110118082508.3746">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
</t>
<t tx="ekr.20110118082508.3747">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20110118082508.3748"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3754">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20110118082508.3755">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
</t>
<t tx="ekr.20110118082508.3756">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20110118082508.3757"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3763">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
</t>
<t tx="ekr.20110118082508.3764">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.

Next Paragraph.
</t>
<t tx="ekr.20110118082508.3765">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
</t>
<t tx="ekr.20110118082508.3766"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3772">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3773">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3779"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3780">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3781">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3782">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3787"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3788">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3789">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3790">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3792">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3793"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3799">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3800">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3803">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3808"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3809">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3810">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3811">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3816"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3817">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3818">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3819">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3824"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3825">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3826">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3827">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3832"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3833">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
</t>
<t tx="ekr.20110118082508.3834">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20110118082508.3835">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
</t>
<t tx="ekr.20110502130500.3471">aList = [z for z in p.unique_nodes()]
assert len(aList) == 3,len(aList)
v1,v2,v3 = aList
assert v1.h == p.h,p.h
assert v2.h == 'node 1',v2.h
assert v3.h == 'node 2',v3.h
</t>
<t tx="ekr.20110502130500.3472"># Node 1
</t>
<t tx="ekr.20110502130500.3473"># node 3
</t>
<t tx="ekr.20110509104953.3474">table = (
    ( 50,'c.'),
    (  3,'p.ins'),
    ( 17,'g.print'),
)
g.pr
ac = c.k.autoCompleter
ac.w = c.frame.body.wrapper
for expected,prefix in table:
    aList = ac.get_leo_completions(prefix)
    assert len(aList) &gt;= expected,'len(aList): %s, prefix: %s' % (len(aList),prefix)
</t>
<t tx="ekr.20110510054817.3475">c.alert('test of c.alert')
</t>
<t tx="ekr.20110510054817.3476">g.alert(c,'test of g.alert')
</t>
<t tx="ekr.20110521073115.3486">@language python

p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20110521073115.3490">@language cython

by cdef cimport cpdef ctypedef enum except?
extern gil include nogil property public
readonly struct union DEF IF ELIF ELSE
                    
NULL bint char dict double float int list
long object Py_ssize_t short size_t void

try:
    pass
except Exception:
    pass

</t>
<t tx="ekr.20110524091618.3488">at = c.atFileCommands

# A mininimal test.

at.startSentinelComment = '&lt;!--'
at.endSentinelComment = '--&gt;'

s1 = '&lt;!--\nline 2.\n--&gt;\n'
s2 = at.massageAtDocPart(s1)

assert s2 == 'line 2.\n',repr(s2)
</t>
<t tx="ekr.20110524120515.3489">c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20110524120515.3490"># before

@raw

@c

&lt;&lt; ref &gt;&gt;

@end_raw

#after
</t>
<t tx="ekr.20110524120515.3491">#@+leo-ver=5-thin
#@+node:ekr.20110524120515.3490: * #@file
# before

#@@raw

@c

&lt;&lt; ref &gt;&gt;

#@@end_raw

#after
#@-leo
</t>
<t tx="ekr.20110529215703.3494">p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
</t>
<t tx="ekr.20110529215703.3495">@language scala

/* A comment */

object HelloWorld {
    def main(args: Array[String]) {
      println("Hello, world!")
    }
  }
</t>
<t tx="ekr.20110608135658.3377"></t>
<t tx="ekr.20110608162543.3363"># cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('create/remove commands no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    chaptersNode = cc.findChaptersNode()
    assert chaptersNode
    chapterNode = (
        cc.findChapterNode('aaa') or
        cc.createChapterByName('aaa',p=None))
    cc.selectChapterByName('aaa',chaptersNode)
    cc.removeChapterByName('aaa')
    c.undoer.undo()
    assert cc.findChapterNode('aaa')
    cc.selectChapterByName('main',collapse=True)
else:
    self.skipTest('Can not be run locally')
</t>
<t tx="ekr.20110608162543.3365"># cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('create/remove commands no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    chaptersNode = cc.findChaptersNode()
    assert chaptersNode
    chapterNode = (
        cc.findChapterNode('aaa') or
        cc.createChapterByName('aaa',p=None))
    try:
        cc.selectChapterByName('aaa',chaptersNode)
        cc.renameChapterByName('bbb')
        cc.selectChapterByName('bbb',chaptersNode)
        cc.renameChapterByName('aaa')
        assert cc.findChapterNode('aaa'),'after undo'
    finally:
        cc.selectChapterByName('main',collapse=True)
else:
    self.skipTest('Can not be run locally')
</t>
<t tx="ekr.20110608181936.3368"># cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('move/clone/copy commands no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    chaptersNode = cc.findChaptersNode()
    assert chaptersNode,'fail 0'
    chapterNode = (
        cc.findChapterNode('aaa') or
        cc.createChapterByName('aaa',p=None))
    table = (
        ('node a',cc.moveNodeToChapterHelper),
        ('node b',cc.copyNodeToChapterHelper),
        ('node c',cc.cloneNodeToChapterHelper),
    )
    # Initialze 
    while p.hasChildren():
        p.firstChild().doDelete(newNode=None)
    for h,unused_f in table:
        p2 = p.insertAsLastChild()
        p2.h = h
        p2.b = '# %s' % h
    try:
        cc.selectChapterByName('aaa')
        for h,f in table:
            p2 = g.findNodeInTree(c,p,h)
            assert p2,'fail 1'
            c.selectPosition(p2) # All helpers work on c.p.
            f('aaa')
            assert g.findNodeInTree(c,chapterNode,h),(
                'fail 2', chapterNode.h, h, f.__name__)
        assert not g.findNodeInTree(c,p,'node a')
        assert g.findNodeInTree(c,p,'node b')
        assert g.findNodeInTree(c,p,'node c')
    finally:
        if 1: # Restore the tree so activeUnitTests.txt does not change.
            while p.hasChildren():
                p.firstChild().doDelete(newNode=None)
            for h,f in table:
                p3 = g.findNodeInTree(c,chapterNode,h)
                if p3: p3.doDelete()
        cc.selectChapterByName('main',collapse=True)
        c.redraw()
else:
    self.skipTest('Can not be run locally')
</t>
<t tx="ekr.20110610082755.3362"></t>
<t tx="ekr.20110610122533.3407">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20110612064437.3310">val = g.guessExternalEditor(c)
assert val,'no val' # This can be different on different platforms.
</t>
<t tx="ekr.20110613143220.3314">@ We want to ensure that when masterMenuHandler does::
    
    event = g.app.gui.create_key_event(c,None,stroke,w)
    return k.masterKeyHandler(event)
    
that the effect will be to call commandName, where commandName
is the arg passed to masterMenuHandler.

createMenuEntries creates the association of stroke to commandName.
@c

trace = False # False: the unit test can fail.
k = c.k
d = g.app.unitTestMenusDict
d2 = k.bindingsDict
d2name = 'k.bindingsDict'
commandNames = list(d.keys())
commandNames.sort()
exclude_strokes = ('Alt+F4','Ctrl+q','Ctrl+Shift+Tab',)

for name in commandNames:
    assert name in c.commandsDict,'unexpected command name: %s' % (
        repr(name))
    aSet = d.get(name)
    aList = list(aSet)
    aList.sort()
    for z in exclude_strokes:
        if z in aList:
            aList.remove(z)
    for stroke in aList:
        aList2 = d2.get(stroke)
        assert aList2,'stroke %s not in %s' % (
            repr(stroke),d2name)
        for b in aList2:
            if b.commandName == name:
                break
        else:
            if trace:
                inverseBindingDict = k.computeInverseBindingDict()
                print('%s: stroke %s not bound to %s in %s' % (
                    p.h,repr(stroke),repr(name),d2name))
                print('%s: inverseBindingDict.get(%s): %s' % (
                    p.h,name,inverseBindingDict.get(name)))
            else:
                assert False,'stroke %s not bound to %s in %s' % (
                    repr(stroke),repr(name),d2name)
</t>
<t tx="ekr.20110615130436.3317"># This was used by @test writing a .leo file retains orphan bits.
# but this test is moot because Leo no longer writes orphan bits.</t>
<t tx="ekr.20111003145300.3466">'''Test that dragging this node onto the child node generates a warning.'''
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
elif g.app.gui.guiName() == 'curses':
    self.skipTest('not valid for curses gui')
else:
    fn = '&lt;file name&gt;'
    p2 = p.firstChild()
    tree = c.frame.tree
    w = tree.treeWidget
    if hasattr(tree,'treeWidget'):
        for w.was_control_drag in (True,False):
            tree.treeWidget.intraFileDrop(fn,p,p2)
            assert True==g.app.unitTestDict['checkMoveWithParentWithWarning']
</t>
<t tx="ekr.20111003145300.3467"></t>
<t tx="ekr.20111006064419.3491">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        setup_test(p)
        c.deleteMarked()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
        c.undoer.undo()
        n = p.numberOfChildren()
        assert n == 4,'undo: children: %s' % (n)
        c.undoer.redo()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
    try:
        test(p)
    finally:
        tear_down(p)
</t>
<t tx="ekr.20111006064419.3493">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        setup_test(p)
        n = p.numberOfChildren()
        assert n == 4 ,'delete: children: %s' % (n)
        c.moveMarked()
        assert c.p.h == 'Moved marked nodes'
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
        if 0:
            # The new move-marked-nodes command doesn't
            # leave the result in the root node.
            root = c.rootPosition()
            assert root.h == 'Moved marked nodes',root.h
        if 0: # The move-marked-nodes command is no longer undoable.
            c.undoer.undo()
            n = p.numberOfChildren()
            assert n == 4,'undo: children: %s' % (n)
            c.undoer.redo()
            n = p.numberOfChildren()
            assert n == 2 ,'delete: children: %s' % (n)
    try:
        test(p)
    finally:
        tear_down(p,'Moved marked nodes')
</t>
<t tx="ekr.20111006072734.3641">def setup_test(target):
    
    c.unmarkAll() # Make sure we move only the test nodes!
    
    common = g.findNodeAnywhere(c,'@common x-marked-nodes test code')
    assert common,'no common'
    data = g.findNodeInTree(c,common,'data')
    assert data,'no data'
    
    delete_children(target)

    # Copy the nodes.
    c.selectPosition(data)
    c.copyOutline()
    c.selectPosition(target)
    c.pasteOutline()
    c.moveOutlineRight()
    c.promote()
    c.deleteOutline()
    c.redraw()
        
    for h in ('a','b','c'):
        p2 = g.findNodeInTree(c,target,h)
        assert p2,'not found: %s' % (h)
        p2.setMarked()
        
    for child in target.children():
        if child.h == 'a':
            assert child.isCloned(),'not cloned!: %s' % (child)
        else:
            assert not child.isCloned(),'cloned!: %s' % (child)
        
    # g.trace('setup complete')
    
</t>
<t tx="ekr.20111006105711.3544">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        setup_test(p)
        c.cloneMarked()
        h = 'Clones of marked nodes'
        assert c.p.h == h,c.p.h
        c.undoer.undo()
        assert not g.findNodeAnywhere(c,h)
        c.undoer.redo()
        assert c.p.h == h,c.p.h
    try:
        test(p)
    finally:
        tear_down(p,'Clones of marked nodes')
</t>
<t tx="ekr.20111018163546.3690">s1 = 'no docstring'
s2 = '''
# comment
"""docstring2."""
'''
s3 = '''
"""docstring3."""
\'\'\'docstring2.\'\'\'
'''

table = (
    (s1,''),
    (s2,'docstring2.'),
    (s3,'docstring3.'),
)

for s,result in table:
    s2 = g.getDocString(s)
    assert s2 == result,'Expected %s, got %s' % (repr(result),repr(s2))
</t>
<t tx="ekr.20111021115306.3696"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:
    
    p = g.findNodeAnywhere(c,"@file unittest/tex-error.tex")
    assert(p)
    s1 = r"""\begin{document}
&lt;&lt; Document """
    
    s2 = r"""&gt;&gt;
% hidden comment
\end{document}
"""
    s = s1 + s2
    s = g.adjustTripleString(s,c.tab_width)
    assert p.b == s, (repr(p.b), repr(s))
</t>
<t tx="ekr.20111021115306.3697">\begin{document}
&lt;&lt; Document &gt;&gt;
% hidden comment
\end{document}
</t>
<t tx="ekr.20111021115306.3711">@ Write master document here...........
</t>
<t tx="ekr.20111026105935.3966">s = '''\
&lt;nodeA&gt;
&lt;nodeB/&gt;
&lt;/nodeA&gt;
'''
ic = c.importCommands
table = (
    (1, "&lt;nodeA&gt;"),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.xmlUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20111029112647.4099"></t>
<t tx="ekr.20111029112647.4101">s = '''\
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/head&gt;
&lt;body class="bodystring"&gt;
&lt;div id='bodydisplay'&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
table = [
    '&lt;html&gt;',
    '&lt;head&gt;',
    '&lt;body class="bodystring"&gt;',
]
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    root = c.p.firstChild()
    assert root.h.endswith('lowercase tags'), root.h
    p2 = root.firstChild()
    for h in table:
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
    p.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20111029120441.3982">s = '''\
&lt;HTML&gt;
&lt;HEAD&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/HEAD&gt;
&lt;BODY class='bodystring'&gt;
&lt;DIV id='bodydisplay'&gt;&lt;/DIV&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
'''


c.importCommands.htmlUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20111102122424.3975">if c.shortFileName() == 'dynamicUnitTest.leo':
    
    setting = 'c.write_script_file'
    assert c.write_script_file is True,'fail1: %s should be hard set' % (setting)
    
else:
    setting = "c.config.getBool('write_script_file')"
    assert c.write_script_file is True,'fail2: check %s' % (setting)
</t>
<t tx="ekr.20111102164107.3975">s = r'''
&lt;td width="550"&gt;
&lt;table cellspacing="0" cellpadding="0" width="600" border="0"&gt;
    &lt;td class="blutopgrabot" height="28"&gt;&lt;/td&gt;
    
    &lt;!-- The indentation of this element causes the problem. --&gt;
    &lt;table&gt;
    
&lt;!--
&lt;div align="center"&gt;
&lt;iframe src="http://www.amex.com/atamex/regulation/listingStatus/index.jsp"&lt;/iframe&gt;
&lt;/div&gt;
--&gt;

&lt;/table&gt;
&lt;/table&gt;

&lt;p&gt;Paragraph&lt;/p&gt;
&lt;/td&gt;

'''
table = (
    '&lt;table cellspacing="0" cellpadding="0" width="600" border="0"&gt;',
    '&lt;table&gt;',
)
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    p2 = c.p.firstChild().firstChild()
    for h in table:
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
    p.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20111103213154.3823">@first # -*- coding: utf-8 -*-
@encoding utf-8

'''Test the interface between docutils and leo_pdf.py. No file is written.
'''
try:
    import docutils
    import reportlab.platypus
except ImportError:
    self.skipTest('No docutils')

path = g.os_path_finalize_join(g.app.loadDir,'..','plugins')
module = g.importFromPath(
    moduleName='leo_pdf',
    path=path,
    verbose = False)
assert module
s = '''This is a test.'''
result = c.rstCommands.writeToDocutils(p,s,'.pdf')
assert result,result
</t>
<t tx="ekr.20111103213154.3824">'''Make sure that trying to import a non-existent file does not crash g.importFromPath.'''

path = g.os_path_finalize_join(g.app.loadDir,'does_not_exist')
assert not g.os_path_exists(path)
module = g.importFromPath ('xyz',path,verbose=False)
assert not module,repr(module)
</t>
<t tx="ekr.20111104112332.3953">import os

path1 = r'C:\Python32\Lib\site-packages\leo-editor\leo\core'
path2 = r'\N:Home\PTC_Creo\Creo.wmv'
path3 = r'N:\Home\PTC_Creo\Creo.wmv'

path12 = os.path.join(path1,path2)
path13 = os.path.join(path1,path3)

if 0:
    print(path12,g.os.path.abspath(path12))
    print(path13,g.os.path.abspath(path13))
</t>
<t tx="ekr.20111104171708.3843">import leo.core.leoBeautify as leoBeautify
cpp = leoBeautify.CPrettyPrinter(c)
fn = 'c tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)

if 1: # test of indent.
    # import os ; os.system('cls')
    cpp.indent(p2)
if 0: # test of tokenize.
    aList = cpp.tokenize(p2.b)
    assert(p2.b == ''.join(aList))
</t>
<t tx="ekr.20111104171708.3844">@language c

static exit_values_ty indent_main_loop(void)
{
    codes_ty         hd_type         = code_eof;
    char           * t_ptr           = NULL;
    codes_ty         type_code       = start_token;
    exit_values_ty   file_exit_value = total_success;
    int              dec_ind         = 0; /* current indentation for declarations */

    BOOLEAN          scase           = false; /* true when we've just see a "case";
                                               * determines what to do with the
                                               * following colon */
    BOOLEAN          flushed_nl;              /* Used when buffering up comments to remember that
                                               * a newline was passed over */
    BOOLEAN          sp_sw           = false; /* true when in the expression part of if(...),
                                               * while(...), etc. */
    BOOLEAN          force_nl        = false;

    /* last_token_ends_sp: True if we have just encountered the end of an if (...),
     * etc. (i.e. the ')' of the if (...) was the last token).  The variable is
     * set to 2 in the middle of the main token reading loop and is decremented
     * at the beginning of the loop, so it will reach zero when the second token
     * after the ')' is read.
     */

    BOOLEAN          last_token_ends_sp = false;

    BOOLEAN          last_else = false; /* true if last keyword was an else */

    for (;;)
    {
        /* this is the main loop.  it will go until
         * we reach eof */

        BOOLEAN is_procname_definition;
        bb_code_ty can_break;

        if (type_code != newline)
        {
            can_break = parser_state_tos-&gt;can_break;
        }

        parser_state_tos-&gt;last_saw_nl = false;
        parser_state_tos-&gt;can_break = bb_none;

        type_code = lexi ();    /* lexi reads one token.  "token" points to
                                 * the actual characters. lexi returns a code
                                 * indicating the type of token */

        /* If the last time around we output an identifier or
         * a paren, then consider breaking the line here if it's
         * too long.
         *
         * A similar check is performed at the end of the loop, after
         * we've put the token on the line. */

        if ((settings.max_col &gt; 0) &amp;&amp;
            (buf_break != NULL) &amp;&amp;
            ( ( (parser_state_tos-&gt;last_token == ident) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                (type_code != newline) &amp;&amp;
                (type_code != form_feed) &amp;&amp;
                (type_code != rparen) &amp;&amp;
                (type_code != struct_delim)) ||
              ( (parser_state_tos-&gt;last_token == rparen) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != rparen) ) ) &amp;&amp;
            (output_line_length () &gt; settings.max_col))
        {
            break_line = 1;
        }

        if (last_token_ends_sp &gt; 0)
        {
            last_token_ends_sp--;
        }

        is_procname_definition =
                (((parser_state_tos-&gt;procname[0] != '\0') &amp;&amp;
                  parser_state_tos-&gt;in_parameter_declaration) ||
                 (parser_state_tos-&gt;classname[0] != '\0'));

        /* The following code moves everything following an if (), while (),
         * else, etc. up to the start of the following stmt to a buffer. This
         * allows proper handling of both kinds of brace placement.
         */

        flushed_nl = false;

        if (!search_brace(&amp;type_code, &amp;force_nl, &amp;flushed_nl, &amp;last_else, &amp;is_procname_definition))
        {
            /* Hit EOF unexpectedly in comment. */
            return indent_punt;
        }
        
        if (type_code == code_eof)
        {
            /* we got eof */
            if (s_lab != e_lab || s_code != e_code || s_com != e_com)   /* must dump end of line */
            {
                dump_line(true, &amp;paren_target);
            }

            if (parser_state_tos-&gt;tos &gt; 1)      /* check for balanced braces */
            {
                ERROR (_("Unexpected end of file"), 0, 0);
                file_exit_value = indent_error;
            }

            if (settings.verbose)
            {
                printf (_("There were %d non-blank output lines and %d comments\n"),
                        (int) out_lines, (int) com_lines);
                if (com_lines &gt; 0 &amp;&amp; code_lines &gt; 0)
                {
                    printf (_("(Lines with comments)/(Lines with code): %6.3f\n"),
                            (1.0 * com_lines) / code_lines);
                }
            }
            flush_output ();

            return file_exit_value;                                              /* RETURN */
        }

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            if (force_nl &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                ( (type_code != lbrace) ||
                  (!parser_state_tos-&gt;in_decl &amp;&amp; !settings.btype_2) ||
                  (parser_state_tos-&gt;in_decl &amp;&amp; !settings.braces_on_struct_decl_line) ||
                  (parser_state_tos-&gt;last_token == rbrace)))
            {
                if (settings.verbose &amp;&amp; !flushed_nl)
                {
                    WARNING (_("Line broken 2"), 0, 0);
                }

                flushed_nl = false;
                dump_line(true, &amp;paren_target);
                parser_state_tos-&gt;want_blank = false;
                force_nl = false;
            }

            parser_state_tos-&gt;in_stmt = true;   /* turn on flag which causes
                                                 * an extra level of
                                                 * indentation. this is
                                                 * turned off by a ; or } */
            if (s_com != e_com)
            {
                /* the code has an embedded comment in the
                 * line. Move it from the com buffer to the
                 * code buffer.
                 *
                 * Do not add a space before the comment if it is the first
                 * thing on the line.
                 */

                if (e_code != s_code)
                {
                    set_buf_break (bb_embedded_comment_start, paren_target);
                    *e_code++ = ' ';
                    embedded_comment_on_line = 2;
                }
                else
                {
                    embedded_comment_on_line = 1;
                }

                for (t_ptr = s_com; *t_ptr; ++t_ptr)
                {
                    check_code_size();
                    *e_code++ = *t_ptr;
                }

                set_buf_break (bb_embedded_comment_end, paren_target);
                *e_code++ = ' ';
                *e_code = '\0'; /* null terminate code sect */
                parser_state_tos-&gt;want_blank = false;
                e_com = s_com;
            }
        }
        else if ((type_code != comment) &amp;&amp;
                 (type_code != cplus_comment) &amp;&amp;
                 !(settings.break_function_decl_args &amp;&amp;
                   (parser_state_tos-&gt;last_token == comma)) &amp;&amp;
                 !( (parser_state_tos-&gt;last_token == comma) &amp;&amp;
                    !settings.leave_comma))
        {
            /* preserve force_nl thru a comment but
             * cancel forced newline after newline, form feed, etc.
             * however, don't cancel if last thing seen was comma-newline
             * and -bc flag is on. */

            force_nl = false;
        }

        /* Main switch on type of token scanned */

        check_code_size();
        
        /* now, decide what to do with the token */

        handle_the_token(type_code, &amp;scase, &amp;force_nl, &amp;sp_sw, &amp;flushed_nl,
                         &amp;hd_type, &amp;dec_ind, &amp;last_token_ends_sp, &amp;file_exit_value,
                         can_break, &amp;last_else, is_procname_definition);
        
        *e_code = '\0';         /* make sure code section is null terminated */

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            parser_state_tos-&gt;last_token = type_code;
        }

        /* Now that we've put the token on the line (in most cases),
         * consider breaking the line because it's too long.
         *
         * Don't consider the cases of `unary_op', newlines,
         * declaration types (int, etc.), if, while, for,
         * identifiers (handled at the beginning of the loop),
         * periods, or preprocessor commands. */

        if ((settings.max_col &gt; 0) &amp;&amp; (buf_break != NULL))
        {
            if ( ( (type_code == binary_op) ||
                   (type_code == postop) ||
                   (type_code == question) ||
                   ((type_code == colon) &amp;&amp; (scase || (squest &lt;= 0))) ||
                   (type_code == semicolon) ||
                   (type_code == sp_nparen) ||
                   (type_code == sp_else) ||
                   ((type_code == ident) &amp;&amp; (*token == '\"')) ||
                   (type_code == struct_delim) ||
                   (type_code == comma)) &amp;&amp;
                 (output_line_length () &gt; settings.max_col))
            {
                break_line = 1;
            }
        }
    }                           /* end of main infinite loop */
}
</t>
<t tx="ekr.20111104171708.3847">import leo.core.leoBeautify as leoBeautify
import leo.commands.convertCommands as convertCommands
cpp = leoBeautify.CPrettyPrinter(c)
# c2p = convertCommands.C_To_Python(c)
fn = 'c tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# c2p.convertCodeList(aList)
# s = ''.join(aList)
</t>
<t tx="ekr.20111104171708.3848">@language c

static exit_values_ty indent_main_loop(void)
{
    codes_ty         hd_type         = code_eof;
    char           * t_ptr           = NULL;
    codes_ty         type_code       = start_token;
    exit_values_ty   file_exit_value = total_success;
    int              dec_ind         = 0; /* current indentation for declarations */

    BOOLEAN          scase           = false; /* true when we've just see a "case";
                                               * determines what to do with the
                                               * following colon */
    BOOLEAN          flushed_nl;              /* Used when buffering up comments to remember that
                                               * a newline was passed over */
    BOOLEAN          sp_sw           = false; /* true when in the expression part of if(...),
                                               * while(...), etc. */
    BOOLEAN          force_nl        = false;

    /* last_token_ends_sp: True if we have just encountered the end of an if (...),
     * etc. (i.e. the ')' of the if (...) was the last token).  The variable is
     * set to 2 in the middle of the main token reading loop and is decremented
     * at the beginning of the loop, so it will reach zero when the second token
     * after the ')' is read.
     */

    BOOLEAN          last_token_ends_sp = false;

    BOOLEAN          last_else = false; /* true if last keyword was an else */

    for (;;)
    {
        /* this is the main loop.  it will go until
         * we reach eof */

        BOOLEAN is_procname_definition;
        bb_code_ty can_break;

        if (type_code != newline)
        {
            can_break = parser_state_tos-&gt;can_break;
        }

        parser_state_tos-&gt;last_saw_nl = false;
        parser_state_tos-&gt;can_break = bb_none;

        type_code = lexi ();    /* lexi reads one token.  "token" points to
                                 * the actual characters. lexi returns a code
                                 * indicating the type of token */

        /* If the last time around we output an identifier or
         * a paren, then consider breaking the line here if it's
         * too long.
         *
         * A similar check is performed at the end of the loop, after
         * we've put the token on the line. */

        if ((settings.max_col &gt; 0) &amp;&amp;
            (buf_break != NULL) &amp;&amp;
            ( ( (parser_state_tos-&gt;last_token == ident) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                (type_code != newline) &amp;&amp;
                (type_code != form_feed) &amp;&amp;
                (type_code != rparen) &amp;&amp;
                (type_code != struct_delim)) ||
              ( (parser_state_tos-&gt;last_token == rparen) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != rparen) ) ) &amp;&amp;
            (output_line_length () &gt; settings.max_col))
        {
            break_line = 1;
        }

        if (last_token_ends_sp &gt; 0)
        {
            last_token_ends_sp--;
        }

        is_procname_definition =
                (((parser_state_tos-&gt;procname[0] != '\0') &amp;&amp;
                  parser_state_tos-&gt;in_parameter_declaration) ||
                 (parser_state_tos-&gt;classname[0] != '\0'));

        /* The following code moves everything following an if (), while (),
         * else, etc. up to the start of the following stmt to a buffer. This
         * allows proper handling of both kinds of brace placement.
         */

        flushed_nl = false;

        if (!search_brace(&amp;type_code, &amp;force_nl, &amp;flushed_nl, &amp;last_else, &amp;is_procname_definition))
        {
            /* Hit EOF unexpectedly in comment. */
            return indent_punt;
        }
        
        if (type_code == code_eof)
        {
            /* we got eof */
            if (s_lab != e_lab || s_code != e_code || s_com != e_com)   /* must dump end of line */
            {
                dump_line(true, &amp;paren_target);
            }

            if (parser_state_tos-&gt;tos &gt; 1)      /* check for balanced braces */
            {
                ERROR (_("Unexpected end of file"), 0, 0);
                file_exit_value = indent_error;
            }

            if (settings.verbose)
            {
                printf (_("There were %d non-blank output lines and %d comments\n"),
                        (int) out_lines, (int) com_lines);
                if (com_lines &gt; 0 &amp;&amp; code_lines &gt; 0)
                {
                    printf (_("(Lines with comments)/(Lines with code): %6.3f\n"),
                            (1.0 * com_lines) / code_lines);
                }
            }
            flush_output ();

            return file_exit_value;                                              /* RETURN */
        }

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            if (force_nl &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                ( (type_code != lbrace) ||
                  (!parser_state_tos-&gt;in_decl &amp;&amp; !settings.btype_2) ||
                  (parser_state_tos-&gt;in_decl &amp;&amp; !settings.braces_on_struct_decl_line) ||
                  (parser_state_tos-&gt;last_token == rbrace)))
            {
                if (settings.verbose &amp;&amp; !flushed_nl)
                {
                    WARNING (_("Line broken 2"), 0, 0);
                }

                flushed_nl = false;
                dump_line(true, &amp;paren_target);
                parser_state_tos-&gt;want_blank = false;
                force_nl = false;
            }

            parser_state_tos-&gt;in_stmt = true;   /* turn on flag which causes
                                                 * an extra level of
                                                 * indentation. this is
                                                 * turned off by a ; or } */
            if (s_com != e_com)
            {
                /* the code has an embedded comment in the
                 * line. Move it from the com buffer to the
                 * code buffer.
                 *
                 * Do not add a space before the comment if it is the first
                 * thing on the line.
                 */

                if (e_code != s_code)
                {
                    set_buf_break (bb_embedded_comment_start, paren_target);
                    *e_code++ = ' ';
                    embedded_comment_on_line = 2;
                }
                else
                {
                    embedded_comment_on_line = 1;
                }

                for (t_ptr = s_com; *t_ptr; ++t_ptr)
                {
                    check_code_size();
                    *e_code++ = *t_ptr;
                }

                set_buf_break (bb_embedded_comment_end, paren_target);
                *e_code++ = ' ';
                *e_code = '\0'; /* null terminate code sect */
                parser_state_tos-&gt;want_blank = false;
                e_com = s_com;
            }
        }
        else if ((type_code != comment) &amp;&amp;
                 (type_code != cplus_comment) &amp;&amp;
                 !(settings.break_function_decl_args &amp;&amp;
                   (parser_state_tos-&gt;last_token == comma)) &amp;&amp;
                 !( (parser_state_tos-&gt;last_token == comma) &amp;&amp;
                    !settings.leave_comma))
        {
            /* preserve force_nl thru a comment but
             * cancel forced newline after newline, form feed, etc.
             * however, don't cancel if last thing seen was comma-newline
             * and -bc flag is on. */

            force_nl = false;
        }

        /* Main switch on type of token scanned */

        check_code_size();
        
        /* now, decide what to do with the token */

        handle_the_token(type_code, &amp;scase, &amp;force_nl, &amp;sp_sw, &amp;flushed_nl,
                         &amp;hd_type, &amp;dec_ind, &amp;last_token_ends_sp, &amp;file_exit_value,
                         can_break, &amp;last_else, is_procname_definition);
        
        *e_code = '\0';         /* make sure code section is null terminated */

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            parser_state_tos-&gt;last_token = type_code;
        }

        /* Now that we've put the token on the line (in most cases),
         * consider breaking the line because it's too long.
         *
         * Don't consider the cases of `unary_op', newlines,
         * declaration types (int, etc.), if, while, for,
         * identifiers (handled at the beginning of the loop),
         * periods, or preprocessor commands. */

        if ((settings.max_col &gt; 0) &amp;&amp; (buf_break != NULL))
        {
            if ( ( (type_code == binary_op) ||
                   (type_code == postop) ||
                   (type_code == question) ||
                   ((type_code == colon) &amp;&amp; (scase || (squest &lt;= 0))) ||
                   (type_code == semicolon) ||
                   (type_code == sp_nparen) ||
                   (type_code == sp_else) ||
                   ((type_code == ident) &amp;&amp; (*token == '\"')) ||
                   (type_code == struct_delim) ||
                   (type_code == comma)) &amp;&amp;
                 (output_line_length () &gt; settings.max_col))
            {
                break_line = 1;
            }
        }
    }                           /* end of main infinite loop */
}
</t>
<t tx="ekr.20111104214341.3835">'''Ensure all plugins have top-level init method *without* importing them.'''

import glob
import inspect

# Get a list of all plugins.
plugins = g.os_path_join(g.app.loadDir,'..','plugins','*.py')
plugins = g.os_path_abspath(plugins)
files = glob.glob(plugins)
files = [g.os_path_abspath(z) for z in files]
files = [z for z in files if not z.endswith('__init__.py')]
files.sort()

exclude = [
    # These are not real plugins...
    'baseNativeTree.py','leocursor.py',
    'qtGui.py',
    'qt_big_text.py',
    'qt_commands.py',
    'qt_events.py',
    'qt_frame.py',
    'qt_idle_time.py',
    'qt_main.py',
    'qt_quickheadlines.py',
    'qt_quicksearch_sub.py',
    'qt_text.py',
    'qt_tree.py',
    'qt_quicksearch.py',
    'swing_gui.py',
]

for fn in files:
    if not g.shortFileName(fn) in exclude:
        f = open(fn,'r')
        s = f.read()
        f.close()
        ok1 = s.find('def init():') &gt; -1
        ok2 = s.find('def init ():') &gt; -1
        assert ok1 or ok2,'fail: %s' % (fn)
    
</t>
<t tx="ekr.20111105124216.3840">setting = 'import_html_tags'
html_tags = ('body','head','html','table','xxx')

# When run externally, c.config.getData will return None.
existing_tags = c.config.getData(setting)
if not existing_tags:
    g.app.config.set(None,setting,'data',html_tags)
    tags = c.config.getData(setting)
    assert c.config.getData(setting) == html_tags
</t>
<t tx="ekr.20111105221757.3833">p1 = p.copy()

def found(p,result):
    return any([p.v == p2.v for p2 in result])

table = (('all',True,False),('marked',False,True))
try:
    p.setMarked()
    assert p.isMarked(),p
    for kind,all,marked in table:
        result = c.testManager.findAllUnitTestNodes(all,marked)
        assert found(p,result),(kind,len(result))
    assert p == p1,(p,p1)
finally:
    p1.clearMarked()
</t>
<t tx="ekr.20111107065245.3833"># The actual code contains the unit test.
# This test will have effect only when run locally.

if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
elif g.app.gui.guiName() == 'curses':
    self.skipTest('not valid for curses gui')
else:
    d = g.app.unitTestDict
    tag = 'minimize-all'
    assert not d.get(tag)
    c.frame.minimizeAll()
    assert d.get(tag) is True
</t>
<t tx="ekr.20111107065530.3833"># The actual code contains the unit test.
# This test will have effect only when run locally.

if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
elif g.app.gui.guiName() == 'curses':
    self.skipTest('not valid for curses gui')
else:
    d = g.app.unitTestDict
    tag = 'resize-to-screen'
    assert not d.get(tag)
    c.frame.resizeToScreen()
    assert d.get(tag) is True
</t>
<t tx="ekr.20111107102431.3849"># A good test, but we don't want this large a file included in the distro.

# fn = r'c:\recent\data4.html'
fn = r'c:\recent\data.html'

root = p.copy()

# Fails with more tags: a newline gets inserted between tags.

html_tags = ('body','head','html','table','xxx',)
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)
try:
    c.importCommands.importFilesCommand(files=[fn],treeType='@file')
finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete()
        c.redraw()
    assert not root.hasChildren()
fail = g.app.unitTestDict.get('fail')
assert not fail
</t>
<t tx="ekr.20111109143012.3839">@language python
# tags that cause nodes: html, head, body, div, table, nodeA, nodeB
# NOT: tr, td, tbody, etc.
@language html
s = '''
&lt;html&gt;
&lt;body&gt;
    &lt;table id="0"&gt;
        &lt;tr valign="top"&gt;
        &lt;td width="619"&gt;
        &lt;table id="2"&gt; &lt;tr valign="top"&gt; &lt;td width="377"&gt;
            &lt;table id="3"&gt;
            &lt;tr&gt;
            &lt;td width="368"&gt;
            &lt;table id="4"&gt;
                &lt;tbody id="5"&gt;
                &lt;tr valign="top"&gt;
                &lt;td width="550"&gt;
                &lt;table id="6"&gt;
                    &lt;tbody id="6"&gt;
                    &lt;tr&gt;
                    &lt;td class="blutopgrabot"&gt;&lt;a href="href1"&gt;Listing Standards&lt;/a&gt; | &lt;a href="href2"&gt;Fees&lt;/a&gt; | &lt;strong&gt;Non-compliant Issuers&lt;/strong&gt; | &lt;a href="href3"&gt;Form 25 Filings&lt;/a&gt; &lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;/tbody&gt;
                &lt;/table&gt;
                &lt;/td&gt;
                &lt;/tr&gt;&lt;tr&gt;
                &lt;td width="100%" colspan="2"&gt;
                &lt;br /&gt;
                &lt;/td&gt;
                &lt;/tr&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;	
            &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
        &lt;!-- View First part --&gt; &lt;/td&gt; &lt;td width="242"&gt; &lt;!-- View Second part --&gt;
        &lt;!-- View Second part --&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;
    &lt;DIV class="webonly"&gt;
        &lt;script src="/scripts/footer.js"&gt;&lt;/script&gt;
    &lt;/DIV&gt;
    &lt;/td&gt;
    &lt;/tr&gt;
    &lt;script language="JavaScript1.1"&gt;var SA_ID="nyse;nyse";&lt;/script&gt;
    &lt;script language="JavaScript1.1" src="/scripts/stats/track.js"&gt;&lt;/script&gt;
    &lt;noscript&gt;&lt;img src="/scripts/stats/track.js" height="1" width="1" alt="" border="0"&gt;&lt;/noscript&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
@language python

# c.importCommands.htmlUnitTest(p,s=s,showTree=True)
table = (
    '&lt;html&gt;',
    '&lt;body&gt;',
    '&lt;table id="0"&gt;',
)
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    p2 = c.p.firstChild().firstChild()
    for h in table:
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
    if 1:
        p.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20111110072415.3841">'''Make sure that g.trace doesn't add an extra newline.'''
if g.app.gui.guiName() == 'curses':
    self.skipTest('not valid for curses gui')
else:
    import sys

    def test():
        g.trace('a')
        g.trace('b')

    try:
        sys.stdout = g.fileLikeObject()
        test()
        result = sys.stdout.get()
        assert result == 'test a\ntest b\n',repr(result)
    finally:
        sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20111110073528.3843">'''Make sure that g.trace doesn't add an extra newline.'''
if g.app.gui.guiName() == 'curses':
    self.skipTest('not valid for curses gui')
else:
    import sys

    def test():
        g.pr('a')
        g.pr('b')

    try:
        sys.stdout = g.fileLikeObject()
        test()
        result = sys.stdout.get()
        assert result == 'a\nb\n',repr(result)
    finally:
        sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20111110073834.3843">'''Make sure that g.trace doesn't add an extra newline.'''
if g.app.gui.guiName() == 'curses':
    self.skipTest('not valid for curses gui')
else:
    import sys
    
    def test():
        g.es_print('a')
        g.es_print('b')
    
    try:
        sys.stdout = g.fileLikeObject()
        test()
        result = sys.stdout.get()
        assert result == 'a\nb\n',repr(result)
    finally:
        sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20111112103320.3849">s = '''\
&lt;body&gt;

&lt;!-- OOPS: the div and p elements not properly nested.--&gt;
&lt;!-- OOPS: this table got generated twice. --&gt;

&lt;p id="P1"&gt;
&lt;div id="D666"&gt;Paragraph&lt;/p&gt; &lt;!-- P1 --&gt;
&lt;p id="P2"&gt;

&lt;TABLE id="T666"&gt;&lt;/TABLE&gt;&lt;/p&gt; &lt;!-- P2 --&gt;
&lt;/div&gt;
&lt;/p&gt; &lt;!-- orphan --&gt;

&lt;/body&gt;
'''
table = (
    ('&lt;body&gt;'),
    ('&lt;div id="D666"&gt;'),
)
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    p2 = c.p.firstChild().firstChild()
    for h in table:
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
    if 1:
        p.deleteAllChildren()
finally:
    c.redraw()

</t>
<t tx="ekr.20111112103320.3887">s = r'''
&lt;html&gt;

&lt;head&gt;
    &lt;!-- oops: link elements terminated two different ways --&gt;
    &lt;link id="L1"&gt;
    &lt;link id="L2"&gt;
    &lt;link id="L3" /&gt;
    &lt;link id='L4' /&gt;
    
    &lt;title&gt;TITLE&lt;/title&gt;
    
&lt;!-- oops: missing tags. --&gt;
'''
table = (
    '&lt;html&gt;',
    '&lt;head&gt;',
)
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    p2 = c.p.firstChild().firstChild()
    for i, h in enumerate(table):
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
    if 1:
        p.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20111112103320.3893">s = '''
&lt;html&gt;
&lt;head&gt;
    &lt;!-- oops: link elements terminated two different ways --&gt;
    &lt;link id="L1"&gt;
    &lt;link id="L2"&gt;
    &lt;link id="L3" /&gt;
    &lt;link id='L4' /&gt;
    
    &lt;title&gt;TITLE&lt;/title&gt;
    
&lt;/head&gt;
&lt;/html&gt;
'''
table = ('&lt;html&gt;', '&lt;head&gt;') # , '&lt;link id="L1"&gt;'
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    p2 = c.p.firstChild().firstChild()
    for h in table:
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
    if 1:
        p.deleteAllChildren()
finally:
        c.redraw()
</t>
<t tx="ekr.20111112171235.3854">w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'html')
assert p,'no test node'
s = p.b
indent = c.config.getBool('indent_added_comments',default=True)
try:
    i = p.b.find('text')
    assert i &gt; -1,'fail1: %s' % (repr(p.b))
    c.selectPosition(p)
    w.setSelectionRange(i,i+4)
    c.addComments()
    if indent:
        i = p.b.find('&lt;!-- text')
    else:
        i = p.b.find('&lt;!--     text')
    assert i &gt; -1,'fail2: %s' % (repr(p.b))
    c.deleteComments()
    assert p.b == s,'fail3: s\n%s\nresult\n%s' % (repr(s),repr(p.b))
    # Add a comment delim without a blank.
    c.addComments()
    p.b = p.b.replace('&lt;!-- ','&lt;!--')
    i = p.b.find('&lt;!--')
    w.setSelectionRange(i,i+4)
    c.deleteComments()
    assert p.b == s,'fail5: s\n%s\nresult\n%s' % (repr(s),repr(p.b))
finally:
    p.b = s
</t>
<t tx="ekr.20111112171235.3855">@language html
&lt;html&gt;
    text 
&lt;/html&gt;
</t>
<t tx="ekr.20111112171235.3858"># Can't be run externally.
w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'python')
assert p,'no test node'
s = p.b
indent = c.config.getBool('indent_added_comments',default=True)

try:
    i = p.b.find('pass')
    assert i &gt; -1,'fail1: %s' % (repr(p.b))
    c.selectPosition(p)
    w.setSelectionRange(i,i+4)
    c.addComments()
    if indent:
        i = p.b.find('# pass')
    else:
        i = p.b.find('#     pass')
    assert i &gt; -1,'fail2: %s' % (repr(p.b))
    c.deleteComments()
    assert p.b == s,'fail3: %s' % (repr(p.b))
    # Add a comment delim without a blank.
    c.addComments()
    p.b = p.b.replace('# pass','#pass')
    i = p.b.find('#')
    w.setSelectionRange(i,i+4)
    c.deleteComments()
    assert p.b == s,'fail5: s\n%s\nresult\n%s' % (repr(s),repr(p.b))
finally:
    p.b = s
</t>
<t tx="ekr.20111112171235.3859">@language python

def spam():
    pass

# after
</t>
<t tx="ekr.20111112211307.3910"># created by old and new add-comments.
</t>
<t tx="ekr.20111112211307.3911">@language python

def deleteCommentTest():

#     if 1:
#         a = 2
#         b = 3

    # if 1:
        # a = 2
        # b = 3

    pass
</t>
<t tx="ekr.20111112211307.3912">@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3

    if 1:
        a = 2
        b = 3

    pass
</t>
<t tx="ekr.20111112211307.3913">5.0
12.8
</t>
<t tx="ekr.20111113091935.4786">@nocolor-node

These all call g.findNodeAnywhere for an @&lt;file&gt; node.
We don't want to copy such nodes to dynamicUnitTest.leo
</t>
<t tx="ekr.20111115071700.3870">c.config.printSettings()

</t>
<t tx="ekr.20111115080347.3872"></t>
<t tx="ekr.20111120124051.3992">from leo.core.leoQt import QtCore,QtGui,QtWidgets
import leo.plugins.qt_events as qt_events
import sys
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
elif sys.platform.startswith('linux'):
    self.skipTest('linux test')
elif g.app.gui.guiName().startswith('qt'):
    def setup(p):
        delete_children(p)
        p2 = p.insertAsLastChild()
        c.selectPosition(p2)
        p2.h = 'first-child'
    
    def delete_children(p):
        while p.hasChildren():
            p.firstChild().doDelete()
    
    app = g.app.gui.qtApp
    assert issubclass(app.__class__,QtWidgets.QApplication)
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    assert g.isTextWrapper(wrapper),wrapper
    assert g.isTextWidget(w),w
    # w_name = w.__class__.__name__
    # bassert w_name in('QsciScintilla','LeoQTextBrowser'),w_name
    p1 = p.copy()
    filter_obj = qt_events.LeoQtEventFilter(c,w=w)
    g.app.unitTestDict[p.h] = filter_obj # preserve a pointer to the filter.
    try:
        ev = QtCore.QEvent
        table = (
            ev.KeyPress,
            # ev.KeyRelease, # Ignored except in QLineEdit's.
            # ev.ShortcutOverride, # Ignored everywhere.
        )
        for theType in table:
            # Create the event.
            setup(p1)
            e = QtGui.QKeyEvent(theType,ord('i'),QtCore.Qt.ControlModifier)
            # Pass it to eventFilter.
            filter_obj.eventFilter(w,e)
            # Check the results.
            c.redraw()
            n = p1.numberOfChildren()
            assert n==2,'%s children' % (n)
            delete_children(p1)
    finally:
        delete_children(p1)
        c.redraw()
else:
    self.skipTest('Requires Qt Gui')
</t>
<t tx="ekr.20111120124051.3994">'''Test that cycle-all-focus cycles through all tabs.'''

import sys
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
elif sys.platform.startswith('linux'):
    self.skipTest('Linux')
elif g.app.gui.guiName() == 'curses':
    self.skipTest('Curses gui')
else:
    log = c.frame.log
    c.bodyWantsFocusNow()
    w_name = g.app.gui.widget_name
    w = c.frame.body
    seen = []
    while w:
        event = g.bunch(widget=w)
        c.editCommands.cycleAllFocus(event=event)
        w = g.app.gui.get_focus()
        if w in seen: break
        seen.append(w)
    assert len(seen) &gt;2, "expected &gt;2, got %s" % len(seen)
</t>
<t tx="ekr.20111121081052.3908">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    log = c.frame.log
    d = log.contentsDict
    keys = list(d.keys())
    tabs = log.orderedTabNames()
    n = len(keys)
    n2 = log.numberOfVisibleTabs()
    n3 = len(tabs)
    assert n == n2,'n: %s n2: %s' % (n,n2)
    # The spell tab may not be in d.keys.
    assert n &lt;= n3,'n: %s len(log.orederedTabNames() %s): %s' % (n,n3,tabs)
</t>
<t tx="ekr.20111121140833.3916">w = c.frame.body.wrapper
s = w.getAllText()
i = s.find('(')
w.setInsertPoint(i)
c.findMatchingBracket(event=None)
i,j = w.getSelectionRange()
assert i &lt; j,'i: %s j: %s' % (i,j)
</t>
<t tx="ekr.20111121140833.3917">'''These were changed, then reverted, but a unit test is important.'''

if g.app.isExternalUnitTest:
    self.skipTest('Prints to console, which is annoying.')
else:
    log = c.frame.log
    log.put(p.h)
    log.putnl()
</t>
<t tx="ekr.20111121142012.4030">from leo.core.leoQt import QtGui,QtWidgets
log = c.frame.log
name = log.__class__.__name__

if g.app.isExternalUnitTest:
    assert name == 'NullLog',name
elif g.app.gui.guiName().startswith('qt'):
    assert name == 'LeoQtLog',name
    assert log.logCtrl.__class__.__name__ == 'QTextEditWrapper',log.logCtrl
    assert not issubclass(log.logCtrl.__class__,QtWidgets.QWidget.__class__)
        # leoQTextEditWidget us a poor name: it is not a Qt widget.
    assert log.logCtrl.widget.__class__.__name__ == 'LeoQTextBrowser'
    assert hasattr(log.logCtrl,'widget') and log.logCtrl.widget
    assert hasattr(log.logCtrl.widget,'leo_log_wrapper')
    wrapper = log.logCtrl.widget.leo_log_wrapper
    assert wrapper == log.logCtrl
else:
    self.skipTest('Requires Qt Gui')
</t>
<t tx="ekr.20111121152019.3929">'''updateEditors was crashing due to calling setSelectionRange(ins=i).
The proper keyword argument is insert=i.
'''

c.frame.body.updateEditors()
</t>
<t tx="ekr.20111121164644.3928">'''Test that cycle-all-focus cycles through all tabs.'''

if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    log = c.frame.log
    tabs = log.orderedTabNames()[1:]
    tabs.append('Log')
    # Set up the initial state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    for tab in tabs:
        log.cycleTabFocus(event=None)
        assert log.tabName == tab,'expected %s, got %s' % (tab,log.tabName)
</t>
<t tx="ekr.20111121224307.3934">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
elif g.app.gui.guiName().startswith('qt'):
    tabs = ('Log','Find')
    log = c.frame.log
    c.bodyWantsFocusNow()
    last_widget = c.frame.body
        
    for tab in tabs:
        # A small hack: fudge up the widget to pass to the command.
        event = g.bunch(widget=last_widget)
        c.editCommands.cycleAllFocus(event=event)
        assert log.tabName == tab,'expected %s, got %s' % (
            tab,log.tabName)
        last_widget = log.contentsDict.get(tab)
        event = g.bunch(widget=last_widget)
        # This throws exception: LeoQTextBrowser has no attribute logCtrl.
        c.k.handleDefaultChar(event, stroke='a')
else:
    self.skipTest('Requires Qt Gui')
</t>
<t tx="ekr.20111123214629.3941">from leo.core.leoQt import QtCore,QtGui,QtWidgets
import leo.plugins.qt_events as qt_events
import sys
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
elif sys.platform.startswith('linux'):
    self.skipTest('linux test')
elif g.app.gui.guiName().startswith('qt'):
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    assert g.isTextWrapper(wrapper),wrapper
    assert g.isTextWidget(w),w
    filter_obj = qt_events.LeoQtEventFilter(c,w=w)
    g.app.unitTestDict[p.h] = filter_obj
        # keep a pointer to the filter.
    for z in c.k.bindingsDict.keys():
        if z.s == 'Alt+Key-9':
            break
    else:
        # Create an Alt-9 key event.
        ev = QtCore.QEvent
        e = QtGui.QKeyEvent(ev.KeyPress,ord('9'),QtCore.Qt.AltModifier)
        filter_obj.eventFilter(w,e)
        # Assert that handleUnboundChar actually ignored it.
        assert g.app.unitTestDict.get('handleUnboundChar-ignore-alt-or-ctrl')
else:
     self.skipTest('Requires Qt Gui')
</t>
<t tx="ekr.20111124090010.3939">'''Test that the config parser visits @buttons and @commands nodes for
leoSettings.leo and unitTest.leo.

If strict is True, also test that the config parser vists the nodes in
myLeoSettings.leo. This may fail on machines without @buttons and @commands
nodes in myLeoSettings.leo.
'''

if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
elif g.app.gui.guiName() == 'curses':
    self.skipTest('Not valid for curses gui')
else:
    strict = True # Set to False if you are not EKR.
    table = ['leoSettings.leo','unitTest.leo']
    if strict:
        table.append('myLeoSettings.leo')
    keys = ('config.doButtons-file-names','config.doCommands-file-names')
    d = g.app.config.unitTestDict # Always created for this unit test.
    
    for key in keys:
        aList = d.get(key,[])
        for fn in table:
            assert fn in aList,'%s not in unitTestDict[%s]' % (fn,key)
</t>
<t tx="ekr.20111125182408.3947">def setup():
    while p.hasChildren():
        p.firstChild().doDelete()

setup()

try:
    files = (r'a\b.c',r'a\b.h',)
    c.importCommands.createImportParent(p,files)
    child = p.firstChild()
    assert child
    assert child.h == 'a/b',child.h
finally:
    setup()</t>
<t tx="ekr.20111125183140.3952">child = p.firstChild()
def setup():
    while p.hasChildren():
        p.firstChild().doDelete()

setup()
try:
    c.importCommands.createOutline(
        fileName=r'a\b\c.xyzzy',
        parent=p,
        atAuto=False,atShadow=False,
        s='test body',
        ext='xyzzy'
    )
    child = p.firstChild()
    assert child
    h = g.os_path_finalize_join(g.app.loadDir,'..','test','a','b','c.xyzzy')
    h = h.replace('\\','/')
    h = '@file ' + h
    # C: vs c: is not relevant here.
    assert child.h.lower() == h.lower(),child.h
finally:
    setup()</t>
<t tx="ekr.20111210104652.3958">def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

child = p.firstChild()
assert child
setup(child)
p2 = child.insertAfter()
p2.h = "test"
try:
    assert c.positionExists(p2),p2
    p2.moveToFirstChildOf(child)
    assert c.positionExists(p2),p2
    p2.moveToLastChildOf(child)
    assert c.positionExists(p2),p2
finally:
    if 1:
        setup(child)
    c.redraw(p)
</t>
<t tx="ekr.20111210104652.3959"></t>
<t tx="ekr.20111211094936.3970"></t>
<t tx="ekr.20111212142649.3971">import sys
# g.openWithFileName *always* opens the file.
if g.isPython3 and sys.platform.startswith('linux'):
    # There is a PyQt issue: https://bugreports.qt.io/browse/QTBUG-35600
    # The crash causes several other unit tests to fail.
    pass
else:
    c.selectPosition(p)
    c.copyOutline()
    try:
        p2 = c.pasteOutline()
        assert p2
        assert not p2.isCloned()
    finally:
        if p2: p2.doDelete()
        c.redraw(p)
</t>
<t tx="ekr.20111212142649.3972"># child text.
</t>
<t tx="ekr.20111213122041.3930">@language python
@tabwidth -4

# Begin

@others

# End
</t>
<t tx="ekr.20111214100515.3921"># Disabled: this now fails *regardless* of python.v2 switch

ic = c.importCommands

def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

fn = g.os_path_finalize_join(g.app.loadDir,'..','test','unittest','at-auto-section-ref-test.py')
# fn = r'c:\Users\edreamleo\at-auto-test.py'
assert g.os_path_exists(fn),fn

try:
    setup(p)
    child = p.insertAsNthChild(0)
    child.h = 'child'
    assert child

    ic.errors = 0
    ic.createOutline (fn,parent=child,s=None,ext=None)
    assert ic.errors == 0
finally:
    setup(p)
    c.redraw(p)
</t>
<t tx="ekr.20111214104615.3942">@language python
@tabwidth -4
@others
# end.
</t>
<t tx="ekr.20120201101804.3907">import leo.core.leoConfig as leoConfig
    
p = c.config.settingsRoot()
assert c
if p:
    # p will not exist when run externally.
    h = p.h
    p.h = '@@' + h
try:
    parser = leoConfig.SettingsTreeParser(c,localFlag=True)
    d1,d2 = parser.traverse()
    assert isinstance(d1,g.TypedDictOfLists),d1
    assert isinstance(d2,g.TypedDict),d2
finally:
    if p:
        p.h = h
        c.redraw()
</t>
<t tx="ekr.20120201125738.3958"># This tests is valid only if not g.new_config.

sd = g.app.config.localShortcutsDict
d = sd.get(c.hash(),{})
try:
    sd[c.hash()] = {}
    key,aList = c.config.getShortcut('new')
    # print(key,aList)
    assert aList,'key: %s' % (key)
finally:
    sd[c.hash()] = d
</t>
<t tx="ekr.20120212130242.3942"></t>
<t tx="ekr.20120212130242.3945"></t>
<t tx="ekr.20120212130242.3946"></t>
<t tx="ekr.20120212130242.3947"></t>
<t tx="ekr.20120212130242.3948"></t>
<t tx="ekr.20120212130242.3949"></t>
<t tx="ekr.20120212130242.4704"></t>
<t tx="ekr.20120212130242.4755"></t>
<t tx="ekr.20120228174052.3929"># node 1 text A.
</t>
<t tx="ekr.20120303054735.3931"># Test of bug 930726: expandNodeAndGoToFirstChild only expands or only goes to first child .

p.contract()
c.expandNodeAndGoToFirstChild()
assert c.p == p.firstChild()
</t>
<t tx="ekr.20120303054735.3932"></t>
<t tx="ekr.20120306173116.3933">@first # -*- coding: utf-8 -*-

s = '''\
&lt;:.&gt;
&lt;&gt;
&lt;_.&gt;
'''
ic = c.importCommands
try:
    test_node = p.copy()
    ic.xmlUnitTest(p,s=s,showTree=True)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20120306201833.3942"># Test of bug 799695: colorizer bug after move-lines-up into a docstring

# import os ; os.system('cls')

n = c.frame.body.colorizer.full_recolor_count

c.testManager.runEditCommandTest(p)

# Not an effective test, even though the bug fix was to call
# c.recolor_now(incremental=False)

# g.trace(n,c.frame.body.colorizer.full_recolor_count)

# assert c.frame.body.colorizer.full_recolor_count &gt; n
</t>
<t tx="ekr.20120306201833.3943">@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
</t>
<t tx="ekr.20120306201833.3944">@language python
def test():
    """ a
    b
    c
    """
    print 1
    
    print 2
</t>
<t tx="ekr.20120306201833.3945">@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
</t>
<t tx="ekr.20120307070541.3937">@first # -*- coding: utf-8 -*-

# Skip test when running test dynamically.
s = g.findTestScript(c,'@common leoRst test code',warn=False)
if s:
    exec(s)
    rst3Test(c,p)
</t>
<t tx="ekr.20120307070541.3941">@language rest
</t>
<t tx="ekr.20120307070541.3942">@language rest

Test of unicode characters: 

End of test.
</t>
<t tx="ekr.20120307070541.3944"></t>
<t tx="ekr.20120307070541.3945"></t>
<t tx="ekr.20120307070541.3946">.. rst3: filename: test.html


Test of unicode characters: 

End of test.

</t>
<t tx="ekr.20120307070541.3947">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document"&gt;


&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;Test of unicode characters: &lt;/p&gt;
&lt;p&gt;End of test.&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20120307070541.3948">.. rst3: filename: test.html


Test of unicode characters: 

End of test.

</t>
<t tx="ekr.20120307070541.3949">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;meta name="generator" content="Docutils VER: http://docutils.sourceforge.net/" /&gt;
&lt;title&gt;&lt;/title&gt;
&lt;style type="text/css"&gt;

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }

hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="document"&gt;


&lt;!-- rst3: filename: test.html --&gt;
&lt;p&gt;Test of unicode characters: &lt;/p&gt;
&lt;p&gt;End of test.&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20120307133953.3947">import sys
if sys.platform.startswith('win'):
    file_, http, unl1 = 'file://', 'http://', 'unl:' + '//'
    fn1 = 'LeoDocs.leo#'
    fn2 = 'doc/LeoDocs.leo#'
    unl2 = '@settings--&gt;Plugins--&gt;wikiview plugin'
    unl3 = '@settings--&gt;Plugins--&gt;wikiview%20plugin'
    table = (
        (http + 'writemonkey.com/index.php', ['browser']),
        (file_ + 'x.py',        ['os_startfile']),
        (file_ + fn1,           ['g.recursiveUNLSearch']),
        (file_ + fn2,           ['g.recursiveUNLSearch']),
        (unl1 + fn1 + unl2,     ['g.recursiveUNLSearch']),
        (unl1 + fn1 + unl3,     ['g.recursiveUNLSearch']),
        (unl1 + '#' + unl2,     ['g.recursiveUNLSearch']),
        (unl1 + '#' + unl3,     ['g.recursiveUNLSearch']),
        (unl1 + unl2,           ['g.recursiveUNLSearch']),
        (unl1 + unl3,           ['g.recursiveUNLSearch']),
    )
    d = g.app.unitTestDict
    for url,aList in table:
        d = g.app.unitTestDict = {}
        g.handleUrl(c=c,p=c.p,url=url)
        for kind in aList:
            assert d.get(kind), 'kind: %r\nurl: %r\n%s' % (
                kind,url,g.dictToString(d))
</t>
<t tx="ekr.20120309155126.3949"># Can't be run externally.
w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'rest and python')
assert p,'no test node'
s = p.b
indent = c.config.getBool('indent_added_comments',default=True)

try:
    i = p.b.find('pass')
    assert i &gt; -1,'fail1: %s' % (repr(p.b))
    c.selectPosition(p)
    w.setSelectionRange(i,i+4)
    c.addComments()
    if indent:
        i = p.b.find('# pass')
    else:
        i = p.b.find('#     pass')
    assert i &gt; -1,'fail2: %s' % (repr(p.b))
    c.deleteComments()
    assert p.b == s,'fail3: %s' % (repr(p.b))
    # Add a comment delim without a blank.
    c.addComments()
    p.b = p.b.replace('# pass','#pass')
    i = p.b.find('#')
    w.setSelectionRange(i,i+4)
    c.deleteComments()
    assert p.b == s,'fail5: s\n%s\nresult\n%s' % (repr(s),repr(p.b))
finally:
    p.b = s
</t>
<t tx="ekr.20120309155126.3950">@language rest

This is rest text.

@language python

def spam():
    pass

# after
</t>
<t tx="ekr.20120310121839.3949"># Not valid when run externally: the chapter node will not exist.
if not g.app.isExternalUnitTest:

    p1 = g.findNodeAnywhere(c,'@chapter aaa')
    assert p1
    p2 = g.findNodeAnywhere(c,'aaa node 1')
    assert p2
    try:
        # g.es_print('**1**', c.hoistStack)
        assert not c.hoistStack, ('fail1', c.hoistStack)
        c.selectPosition(p1)
        assert c.p == p1, ('fail2', c.p, p1)
        c.hoist()
            # New in Leo 5.3: should do nothing
        assert c.p == p1, ('fail3', c.p, p1)
        # assert c.p == p2, ('fail3', c.p, p2)
        c.dehoist()
            # New in Leo 5.3: should do nothing:
        assert c.p == p1, ('fail3', c.p, p1)
        # assert c.p == p2, 'fail4\n%s\n%s' % (c.p, p2)
        assert c.hoistStack == [], ('fail5', c.hoistStack)
    finally:
        c.hoistStack = []
        c.selectPosition(p)
        c.redraw()
else:
    self.skipTest('Can not be run locally')
</t>
<t tx="ekr.20120311124038.3951">p1 = p.copy()
try:
    assert not c.hoistStack
    c.selectPosition(p1)
    assert c.p == p1
    c.hoist()
    c.goToFirstNode()
    assert not c.hoistStack
        # The hoist stack must be cleared to show the first node.
    assert c.p == c.rootPosition()
    assert c.p.isVisible(c)
finally:
    c.selectPosition(p1)
    c.redraw()
</t>
<t tx="ekr.20120525072421.3889">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20120525072421.3890"># Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
</t>
<t tx="ekr.20120525072421.3891"># Should remove all trailing whitespace.

a = 2   
    
    b = 3
    c  = 4  
d = 5
e = 6  
x
</t>
<t tx="ekr.20120525072421.3892"># Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
</t>
<t tx="ekr.20121011094154.3906">@language python
</t>
<t tx="ekr.20121011094154.3911">s = '''

class Greeter {
    greeting: string;
    constructor (message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

var greeter = new Greeter("world");

var button = document.createElement('button')
button.innerText = "Say Hello"
button.onclick = function() {
    alert(greeter.greet())
}

document.body.appendChild(button)

'''

c.importCommands.typeScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20121011100210.4035">s = '''

module Sayings {
    export class Greeter {
        greeting: string;
        constructor (message: string) {
            this.greeting = message;
        }
        greet() {
            return "Hello, " + this.greeting;
        }
    }
}
var greeter = new Sayings.Greeter("world");

var button = document.createElement('button')
button.innerText = "Say Hello"
button.onclick = function() {
	alert(greeter.greet())
}

document.body.appendChild(button)


'''

c.importCommands.typeScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20121016134831.3906">import leo.core.leoBeautify as leoBeautify
cpp = leoBeautify.CPrettyPrinter(c)
# ts2p = c.convertCommands.TS_To_Python(c)
fn = 'typescript tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# bts2p.convertCodeList(aList)
# s = ''.join(aList)
</t>
<t tx="ekr.20121016134831.3907">@language javascript

public attemptIncrementalUpdateUnit(previousScript: Script,scriptId: string,newSourceText: ISourceText,editRange: ScriptEditRange): UpdateUnitResult
    self.logger.log("attemptIncrementalUpdateUnit(\"" + scriptId + "\")")
    if editRange === None:
        throw Error("editRange should be valid")
    var scope1 = self.getEnclosingScopeContextIfSingleScopeEdit(previousScript,scriptId,newSourceText,editRange)
    if scope1 === None:
        return None
    var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta
    # Heuristic: if the range to reparse is too big,bail out.
    # This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups
    if newScopeLength &gt;= newSourceText.getLength()/ 2:
        self.logger.log("  Bailing out because range of scope to reparse(" + newScopeLength + " characters)is greater than half the size of the source text")
        return None
    # Capture parsing errors so that they are part of "updateResult"
    var parseErrors: TypeScript.ErrorEntry:[] = []
    var errorCapture = function(minChar: number,charLen: number,message: string,unitIndex: number): void
        parseErrors.push(TypeScript.ErrorEntry:(unitIndex,minChar,minChar + charLen,message))
    var quickParseResult = TypeScript.quickParse(self.logger,scope1.scopeStartAST,newSourceText,scope1.scopeStartAST.minChar,scope1.scopeStartAST.minChar + newScopeLength,errorCapture)
    if quickParseResult.endLexState != TypeScript.LexState.Start:
        self.logger.log("  Bailing out because scope contains unterminated comment")
        return None
    var scriptFragment = quickParseResult.Script
    if scriptFragment.vars.members.length !== 0:
        self.logger.log("  Bailing out because new source text defines variables")
        return None
    #if(scriptFragment.scopes.members.length !== 1)
    #    logger.log("  Bailing out because new source text defines more than one scope(or none)");
    #    return null;
    #
    # This detects adding close curlies,since they have the side effect of having the parser
    # parse more members in the scope range.
    if scriptFragment.bod.members.length !== 1:
        self.logger.log("  Bailing out because new source text defines more than one scope(or none)")
        return None
    var oldScope = scope1.scopeStartAST
    var newScope = scriptFragment.bod.members[0]
    if oldScope.nodeType != newScope.nodeType:
        self.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope")
        return None
    if not (&lt;any&gt;oldScope).leftCurlyCount or not (&lt;any&gt;oldScope).rightCurlyCount:
        self.logger.log("  Bailing out because sopce doesn't have left/right curly count")
        return None
    if(&lt;any&gt;oldScope).leftCurlyCount !==(&lt;any&gt;newScope).leftCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)left curly braces")
        return None
    if(&lt;any&gt;oldScope).rightCurlyCount !==(&lt;any&gt;newScope).rightCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)right curly braces")
        return None
    if newScope.minChar !== 0:
        self.logger.log("  Bailing out because new function declaration does not start at position 0")
        return None
    if newScope.limChar !== newScopeLength:
        self.logger.log("  Bailing out because new function declaration does not end at the new end position")
        return None
    return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript,scriptFragment,oldScope,newScope,editRange,parseErrors)
</t>
<t tx="ekr.20130503061820.4186">@
language_delims_dict 
    # Keys are languages, values are 1,2 or 3-tuples of delims. 
language_extension_dict
    # Keys are languages, values are extensions.
extension_dict = {
    # Keys are extensions, values are languages.
@c

delims_d    = g.app.language_delims_dict
lang_d      = g.app.language_extension_dict
ext_d       = g.app.extension_dict

for lang in lang_d:
    ext = lang_d.get(lang)
    assert lang in delims_d,'fail 1: %s' % lang
    assert ext in ext_d,'fail 2: %s' % ext
for ext in ext_d:
    lang = ext_d.get(ext)
    assert lang in lang_d,'fail 3: %s' % lang
</t>
<t tx="ekr.20130524112342.4137">parent_v = p.parent().v or c.hiddenRootNode
while p.hasChildren():
    p.firstChild().doDelete()
if 0: # passes
    p.v.cloneAsNthChild(parent_v,p.childIndex())
if 1:
    v2 = p.v.insertAsFirstChild()
    v2.h = 'insertAsFirstChild'
    v2 = p.v.insertAsLastChild()
    v2.h = 'insertAsLastChild'
    v2 = p.v.insertAsNthChild(1)
    v2.h = 'insertAsNthChild(1)'
p.expand()
c.redraw()
</t>
<t tx="ekr.20130703132516.4188">p1 = p.copy()
while p.hasChildren():
    p.firstChild().doDelete()
root = p.insertAsLastChild()
root.h = 'root'
# Top level
a1 = root.insertAsLastChild()
a1.h = 'a'
a2 = a1.clone()
d1 = a1.insertAfter()
d1.h = 'd'
b1 = root.insertAsLastChild()
b1.h = 'b'
# Children of a.
b11 = b1.clone()
b11.moveToLastChildOf(a1)
b12 = b11.clone()
c2 = b11.insertAfter()
c2.h = 'c'
# Children of d
b11 = b1.clone()
b11.moveToLastChildOf(d1)
def parent(p):
    return p.stack[-1][0].h
n = root.level()
aList = []
nodes = 0
for p in root.subtree():
    nodes += 1
    if p.h == 'b':
        if 0:
            parent = p.stack[-1][0]
            print('found',p.level()-n,p.h,'childIndex',p.childIndex(),'parent:',parent.h)
        aList.append(p.copy())
n_aList = len(aList)
assert n_aList == 6,n_aList
try:
    c.deletePositionsInList(aList)
finally:
    if 1:
        while p1.hasChildren():
            p1.firstChild().doDelete()
c.redraw()
</t>
<t tx="ekr.20130910062920.4149">import codecs

# The hack of computing s below is not valid in Python 3.
if not g.isPython3:
    table = (
        ('utf-8',  codecs.BOM_UTF8),
        ('utf-16', codecs.BOM_UTF16_BE),
        ('utf-16', codecs.BOM_UTF16_LE),
        ('utf-32', codecs.BOM_UTF32_BE),
        ('utf-32', codecs.BOM_UTF32_LE),
    )
    for e,bom in table:
        s1 = 'this is a test'
        s = bom + 'this is a test'
        # print('%6s bom: %18r s: %s' % (e,bom,repr(s)))
        e2,s2 = g.stripBOM(s)
        assert e2 == e,'%s,%s' % (e,e2)
        assert s2 == s1,repr(s2)
</t>
<t tx="ekr.20130912092638.4150">@first # -*- coding: utf-16 -*-
@encoding utf-16

Test of utf-16.
</t>
<t tx="ekr.20130912092638.4151">import sys
if g.app.isExternalUnitTest:
    if sys.platform.startswith('linux'):
        self.skipTest('external linux test')
    else:
        path = g.os_path_finalize_join(g.app.loadDir,'..','test','unittest','utf-16-test.txt')
        assert g.os_path_exists(path)
        f = open(path,'r')
        s = f.read()
        f.close()
        s = g.toUnicode(s,encoding='utf-16')
        assert s.find('Test of utf-16.') &gt; -1,s
else:
    h = '@file unittest/utf-16-test.txt'
    p = g.findNodeAnywhere(c,h)
    s = 'Test of utf-16.'
    assert p,h
    # It's hard to test the utf-16 text directly.
    assert p.b
    assert p.b.find(s) &gt; -1
    assert len(p.b)==66,len(p.b)
</t>
<t tx="ekr.20130918043621.4172"></t>
<t tx="ekr.20130918043621.4190"></t>
<t tx="ekr.20130918043621.4195"># First, we must remove the trailing newline from the 'after' line.
h = 'after sel=3.6,3.6'
p2 = g.findNodeInTree(c,p,h)
assert p2,h
s = p2.b
if s.endswith('\n'):
    p2.b = p2.b[:-1]
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20130918043621.4196">line 1
line 2
line 3
</t>
<t tx="ekr.20130918043621.4197">line 1
line 2
line 3
</t>
<t tx="ekr.20130918043621.4198">line 1
line 2
line 3
</t>
<t tx="ekr.20130918043621.4199">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20130918043621.4200">line 1
line 2

line 4
</t>
<t tx="ekr.20130918043621.4201">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20130918043621.4202">line 1
line 2

line 4
</t>
<t tx="ekr.20130918043621.4203">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20130918043621.4204">line 1
li
line 3
</t>
<t tx="ekr.20130918043621.4205">line 1
line 2
line 3
</t>
<t tx="ekr.20130918043621.4206">line 1
li
line 3
</t>
<t tx="ekr.20130918050446.4202">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20130918050446.4203">line 1
line 2line 3
</t>
<t tx="ekr.20130918050446.4204">line 1
line 2
line 3
</t>
<t tx="ekr.20130918050446.4205">line 1
line 2line 3
</t>
<t tx="ekr.20130918050446.4210">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20130918050446.4211">line 1
line 2
line 4
</t>
<t tx="ekr.20130918050446.4212">line 1
line 2

line 4
</t>
<t tx="ekr.20130918050446.4213">line 1
line 2
line 4
</t>
<t tx="ekr.20130918051958.4176"># First, we must remove the trailing newline from the 'after' line.
h = 'after sel=3.6,3.6'
p2 = g.findNodeInTree(c,p,h)
assert p2,h
s = p2.b
if s.endswith('\n'):
    p2.b = p2.b[:-1]
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20130918051958.4177">line 1
line 2
line 3
</t>
<t tx="ekr.20130918051958.4178">line 1
line 2
line 3
</t>
<t tx="ekr.20130918051958.4179">line 1
line 2
line 3
</t>
<t tx="ekr.20130918052416.4180">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20130918052416.4181">line 1
# The next line contains two trailing blanks.
line 3line 4
</t>
<t tx="ekr.20130918052416.4182">line 1
# The next line contains two trailing blanks.
line 3  
line 4
</t>
<t tx="ekr.20130918052416.4183">line 1
# The next line contains two trailing blanks.
line 3line 4
</t>
<t tx="ekr.20130923090601.4178">u = c.undoer
assert u
c.insertHeadlineBefore()
assert u.undoMenuLabel == 'Undo Insert Node Before',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node Before',repr(u.undoMenuLabel)
</t>
<t tx="ekr.20131103084038.4274"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20131103084038.4275">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20131103084038.4276">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20131103084038.4277">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20131103084038.4282"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20131103084038.4283">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20131103084038.4284">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20131103084038.4285">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20131103084038.4290"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20131103084038.4291">@pagewidth 40
'''
docstring. more docstring.
'''
</t>
<t tx="ekr.20131103084038.4292">@pagewidth 40
'''
docstring.
more docstring.
'''
</t>
<t tx="ekr.20131103084038.4293">@pagewidth 40
'''
docstring. more docstring.
'''
</t>
<t tx="ekr.20131103084038.4298"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20131103084038.4299">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20131103084038.4300">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20131103084038.4301">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20131103084038.4306"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20131103084038.4307">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20131103084038.4308">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20131103084038.4309">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20131103084038.4314"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20131103084038.4315">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20131103084038.4316">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20131103084038.4317">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20131103084038.4322"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20131103084038.4323">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20131103084038.4324">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20131103084038.4325">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20131103084038.4330"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20131103084038.4331">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20131103084038.4332">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20131103084038.4333">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20131220083358.3982">u = c.undoer
p1 = g.findNodeInTree(c,p,'a')
p2 = g.findNodeInTree(c,p,'b')
assert p1 and p2
assert not p1.isCloned()
assert not p2.isCloned()
bunch = u.beforeChangeTree(p)
p1._relinkAsCloneOf(p2)
u.afterChangeTree(p,'relink-clone',bunch)
assert p.firstChild().isCloned()
assert p.firstChild().next().isCloned()
c.redraw()
u.undo()
c.redraw()
p1 = g.findNodeInTree(c,p,'a')
p2 = g.findNodeInTree(c,p,'b')
assert not p1.isCloned()
assert not p2.isCloned()
assert p1 and p2
u.clearUndoState()
</t>
<t tx="ekr.20131220083358.3983"></t>
<t tx="ekr.20131220083358.3984">b text.
</t>
<t tx="ekr.20131227150324.3983"># Verify a fix for bug https://bugs.launchpad.net/leo-editor/+bug/1264350
if g.app.isExternalUnitTest:
    # There is no @chapter node in the copied file.
    self.skipTest('Can not be run externally') 
else:
    aaa1 = g.findNodeAnywhere(c,'@chapter aaa')
    assert aaa1
    try:
        c.chapterController.selectChapterByName('aaa',collapse=True)
        aaa = c.p
        assert aaa.h == 'aaa node 1',repr(aaa)
        p2 = p.moveToVisBack(c)
        assert p2 is None,p2
    finally:
        c.chapterController.selectChapterByName('main',collapse=True)
</t>
<t tx="ekr.20140206132559.4560">@others
</t>
<t tx="ekr.20140206132559.4564">@others
bClass = aClass
</t>
<t tx="ekr.20140206132559.4567">tm = c.testManager
before   = g.findNodeInTree(c,p,'before')
expected = g.findNodeInTree(c,p,'expected')
assert before,expected
try:
    c.selectPosition(before)
    before.h = 'expected' # To make the compare work.
    c.importCommands.parse_body(before)
    # compare tree.
    assert tm.compareOutlines(before,expected,compareHeadlines=True,tag='',report=True)
    c.undoer.undo()
finally:
    before.h = 'before'
    c.redraw()
</t>
<t tx="ekr.20140217055617.4230"># This must be true even though @bool scriptingatscriptnodes is True in this file.
if hasattr(c,'theScriptingController'):
    # mod_scripting may be disabled when running tests externally.
    assert not c.theScriptingController.atScriptNodes
</t>
<t tx="ekr.20140218042220.4347">s = '''\

var c3 = (function () {
    "use strict";

    // Globals
    var c3 = { version: "0.0.1"   };

    c3.someFunction = function () {
        console.log("Just a demo...");
    };

    return c3;
}());

'''

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20140218045755.4348">@language python
@tabwidth -4

def not_a_sentinel(x):
    pass
@not_a_sentinel
def spam():
    pass

s1 = ''.join(g.splitLines(p.b) [2:])
s2 = p.nosentinels   
assert s1 == s2,'expected:\n%s\ngot:\n%s' % (s1,s2)
</t>
<t tx="ekr.20140218122321.4349">@language html
s = '''
&lt;!-- tags that start nodes: html,body,head,div,table,nodeA,nodeB --&gt;
&lt;html&gt;&lt;head&gt;headline&lt;/head&gt;&lt;body&gt;body&lt;/body&gt;&lt;/html&gt;
'''
@language python
table = (
    # The new xml scanner doesn't generate any new nodes,
    # because the scan state hasn't changed at the end of the line!
)
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    p2 = c.p.firstChild().firstChild()
    for h in table:
        assert p2 and p2.h == h, (p2 and p2.h, h)
        p2.moveToThreadNext()
    if 1:
        p.deleteAllChildren()
finally:
    c.redraw()

</t>
<t tx="ekr.20140218151418.4353">s = '''\
var express = require('express');

var app = express.createServer(express.logger());

app.get('/', function(request, response) {
response.send('Hello World!');
});

var port = process.env.PORT || 5000;
app.listen(port, function() {
console.log("Listening on " + port);
});
'''

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20140702101937.4245">table = (
    ('abc a bc x','bc',0,6),
    ('abc a bc x','bc',1,6),
    ('abc a x','bc',0,-1),
)
for s,word,i,expected in table:
    actual = g.find_word(s,word,i)
    assert actual == expected
</t>
<t tx="ekr.20140712142620.4458"></t>
<t tx="ekr.20140712142620.4503">aList = [p.copy() for p in c.all_positions()]
aList2 = sorted(reversed(aList),key=p.sort_key)
i = 0
for p in aList2:
    p2 = aList[i]
    i += 1
    assert p == p2,'\n%s:%s\n%s:%s' % (
        p.sort_key(p),p.h,p2.sort_key(p2),p2.h)
</t>
<t tx="ekr.20140712142620.4507">pd = c.persistenceController
gnxs = g.findNodeInTree(c,p,'@gnxs')
root = g.findNodeInTree(c,p,'root')
node1 = g.findNodeInTree(c,p,'node1')
assert gnxs and root and node1
root.deleteAllChildren()
new_node1 = root.insertAsLastChild()
new_node1.h = 'node1'
gnxs.b = 'gnx: %s\nunl: %s\n' % (node1.v.gnx,'node1')
try:
    pd.restore_gnxs(gnxs,root)
    # Important: p._relinkAsCloneOf leaves new_node1 unchanged,
    # but new_node1 should not be used.
finally:
    c.redraw()
</t>
<t tx="ekr.20140712142620.4508">gnx: ekr.20140923080452.6565
unl: node1
</t>
<t tx="ekr.20140712142620.4510"></t>
<t tx="ekr.20140712142620.4537">pd = c.persistenceController
root = c.rootPosition().insertAfter()
root.h = 'root'
child1 = root.insertAsLastChild()
child1.h = 'child1'
child2 = child1.insertAfter()
child2.h = 'child2'
child11 = child1.insertAsLastChild()
child11.h = 'child11'
try:
    for unl in ('root','root--&gt;child1','root--&gt;child2','root--&gt;child1--&gt;child11'):
        p = pd.find_absolute_unl_node(unl)
        parts = unl.split('--&gt;')
        assert p,unl
        assert p.h == parts[-1],p.h
finally:
    root.doDelete()
    c.selectPosition(p)
    c.redraw()
</t>
<t tx="ekr.20140712142620.4538">import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    h = '@persistence'
    p1 = pd.find_at_persistence_node()
    assert p1
    p2 = pd.has_at_persistence_node()
    assert p1 == p2,(p1,p2)
</t>
<t tx="ekr.20140712142620.4539">pd = c.persistenceController
parent = p.copy()
node1 = p.firstChild()
node2 = node1.next()
node3 = node2.next()
assert node1 and node2 and node3
child11 = node1.firstChild()
child12 = child11.next()
assert child11 and child12
child21 = node2.firstChild()
child22 = child21.next()
assert child21 and child22
node3_child1 = node3.firstChild()
assert node3_child1
node3_child1_child21 = node3_child1.firstChild()
assert node3_child1_child21
table = (
    ('node1',node1),
    ('',parent), # This special case is important.
    ('node1--&gt;child11',child11),
    ('node1--&gt;child12',child12),
    ('node2',node2),
    ('node2--&gt;child21',child21),
    ('node2--&gt;child22',child22),
    # Partial matches.
    ### ('node3--&gt;child1--&gt;child21',node3_child1_child21),
    ### ('child1--&gt;child21',node3_child1_child21),
    ### ('xxx--&gt;child21',node3_child1_child21),
        # This is ambiguous.
    # No matches.
    ('nodex',None),
    ('node1--&gt;childx',None),
    ('node3--&gt;childx',None),
)
for unl,expected in table:
    got = pd.find_position_for_relative_unl(parent,unl)
    assert got == expected,'unl: %s expected: %s got: %s' % (
        unl,expected and expected.h,got and got.h)
</t>
<t tx="ekr.20140712142620.4540"></t>
<t tx="ekr.20140712142620.4541"></t>
<t tx="ekr.20140712142620.4542"></t>
<t tx="ekr.20140712142620.4543"></t>
<t tx="ekr.20140712142620.4544"></t>
<t tx="ekr.20140712142620.4545"></t>
<t tx="ekr.20140712142620.4546">if g.app.isExternalUnitTest:
    # There will not be a proper cloned node in the copy of these tests.
    self.skipTest('Can not be run externally')
elif g.app.gui.guiName() == 'curses':
    self.skipTest('Not for curses gui')
else:
    pd = c.persistenceController
    root = g.findNodeInTree(c,p,'root')
    assert root
    root.h = '@auto root'
    try:
        clone = root.next()
        assert clone and clone.h == 'clone'
        inner_clone = root.firstChild()
        assert inner_clone
        assert clone.v == inner_clone.v
        rep = pd.find_representative_node(root,inner_clone)
        # Careful: cloning this test can cause problems.
        oops = '\n  rep: %s\nparent:%s\nclone: %s\nparent:%s\ninner: %s\nparent: %s' % (
            rep,rep.parent(),clone,clone.parent(),inner_clone,inner_clone.parent())
        if g.app.isExternalUnitTest:
            pass
        else:
            assert rep == clone,(repr(rep),repr(clone))
    finally:
        root.h = 'root' # root must not be an @auto node.
        c.redraw()
</t>
<t tx="ekr.20140712142620.4547"></t>
<t tx="ekr.20140712142620.4549"></t>
<t tx="ekr.20140712142620.4550"># Also a test of find_at_views_node, find_at_organizers_node and find_at_clones_node.
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    root = g.findNodeInTree(c,p,'root')
    assert root
    try:
        persistence = pd.find_at_persistence_node()
        assert persistence
        persistence.deleteAllChildren()
        root.h = '@auto root' # Make root look like an @auto node.
        assert pd.find_at_data_node(root)
        assert pd.find_at_gnxs_node(root)
    finally:
        root.h = 'root' # Make sure root is *not* an @auto node.
        # views.deleteAllChildren()
        c.selectPosition(p)
        c.redraw()
</t>
<t tx="ekr.20140712142620.4551"></t>
<t tx="ekr.20140712142620.4552">class aClass:
    @others
</t>
<t tx="ekr.20140712142620.4556"></t>
<t tx="ekr.20140712142620.4557">import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    # Test pd.has_at_auto_view_node, pd.has_at_clones_node and pd.has_at_organizers_node.
    pd = c.persistenceController
    persistence = g.findNodeAnywhere(c,'@persistence')
    assert persistence
    assert pd.has_at_persistence_node()
    persistence.deleteAllChildren()
    assert persistence
    root = g.findNodeInTree(c,p,'root')
    assert root
    # The representative of clone_test node must appear outside of root's tree.
    clone_test = g.findNodeInTree(c,p,'clone-test')
    if g.app.isExternalUnitTest:
        # There will not be a proper node in the copied tree.
        self.skipTest('Can not be run externally')
    else:
        assert clone_test
        assert clone_test.v == root.next().v,(clone_test.v,root.next().v)
        try:
            root.h = '@auto root' # Make root look like an @auto node.
            pd.update_before_write_foreign_file(root)
            data = g.findNodeInTree(c,persistence,'@data:@auto root')
            assert data
            data2 = pd.has_at_data_node(root)
            assert data2
            assert data == data2,(data,data2)
            gnxs = g.findNodeInTree(c,persistence,'@gnxs')
            assert gnxs
            gnxs2 = pd.has_at_gnxs_node(root)
            assert gnxs2
            assert gnxs == gnxs2,(gnxs,gnxs2)
        finally:
            root.h = 'root' # Make the root *not* an @auto node.
            c.redraw()
</t>
<t tx="ekr.20140712142620.4558">@others
</t>
<t tx="ekr.20140712142620.4559">class aClass:
    @others
</t>
<t tx="ekr.20140712142620.4561"></t>
<t tx="ekr.20140712142620.4562">def spam():
    pass
</t>
<t tx="ekr.20140712142620.4563">def clone_test():
    pass
</t>
<t tx="ekr.20140712142620.4574">pd = c.persistenceController
unl = pd.unl(p)
expected = p.h if g.app.isExternalUnitTest else '--&gt;'+p.h
assert unl.endswith(expected),repr(unl)
</t>
<t tx="ekr.20140712142620.4575">import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    root = g.findNodeInTree(c,p,'root')
    assert root
    persistence = pd.find_at_persistence_node()
    assert persistence
    persistence.deleteAllChildren()
    try:
        root.h = '@auto root' # Make root look like an @auto node.
        pd.update_before_write_foreign_file(root)
        data = g.findNodeAnywhere(c,'@data:@auto root')
        assert data
        gnxs = g.findNodeInTree(c,data,'@gnxs')
        assert gnxs
    finally:
        root.h = 'root' # Make root *not* an @auto node.
        # persistence.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20140712142620.4576"></t>
<t tx="ekr.20140712142620.4577">class aClass:
    @others
</t>
<t tx="ekr.20140712142620.4579"></t>
<t tx="ekr.20140712142620.4580"></t>
<t tx="ekr.20140712142620.4581">def spam():
    pass
</t>
<t tx="ekr.20140712142620.4582"></t>
<t tx="ekr.20140712142620.4583"># At present, neither the pack nor the unpack commands exist.
pd = c.persistenceController
persistence = pd.find_at_persistence_node()
assert persistence
persistence.deleteAllChildren()
view = g.findNodeInTree(c,p,'@view test')
assert view
assert c.positionExists(view)
try:
    c.selectPosition(view)
    v_b = view.b
    pd.pack()
    assert c.p.v == view.v
    pd.unpack()
    assert view.b == v_b,view.b
    assert view.lastChild().isCloned()
finally:
    # views.deleteAllChildren()
    c.undoer.clearUndoState()
    c.redraw()
</t>
<t tx="ekr.20140712142620.4585">view body
</t>
<t tx="ekr.20140712142620.4586">not a clone text
</t>
<t tx="ekr.20140712142620.4587">clone body
</t>
<t tx="ekr.20140715080507.4339"></t>
<t tx="ekr.20140715080507.4340"></t>
<t tx="ekr.20140715080507.4341"></t>
<t tx="ekr.20140716115306.4345">pd = c.persistenceController
at_persistence = pd.find_at_persistence_node()
assert at_persistence
at_persistence.deleteAllChildren()
root = at_persistence.insertAsLastChild()
root.h = 'test root'
root.b = root.gnx
at_data = pd.find_at_data_node(root)
assert at_data
try:
    at_uas = at_data.insertAsLastChild()
    at_uas.h = '@uas'
    at_ua = at_uas.insertAsLastChild()
    at_ua.h = '@ua:dummy-gnx'
    at_ua.b = 'unl:dummy-unl\nua:dummy-ua'
    at_recovery = pd.find_at_recovery_node(root)
    if at_recovery:
        at_recovery.deleteAllChildren()
    pd.recover_ua_for_gnx('dummy-gnx',root,'dummy-unl')
    assert at_recovery
    at_ua2 = g.findNodeInTree(c,at_recovery,'@ua:dummy-gnx')
    assert at_ua2
    assert at_ua2.h == at_ua.h
    assert at_ua2.b == at_ua.b,repr(at_ua2.b)
finally:
    pass # root.doDelete()

</t>
<t tx="ekr.20140723134017.4464"># This causes problems!
import glob
import importlib
path = g.os_path_finalize_join(g.app.loadDir,'..','plugins','importers')
assert g.os_path_exists(path), repr(path)
pattern = g.os_path_finalize_join(path,'*.py')
for fn in glob.glob(pattern):
    sfn = g.shortFileName(fn)
    m = importlib.import_module('leo.plugins.importers.%s' % sfn[:-3])
    assert m
</t>
<t tx="ekr.20140724164600.4590"># Print does not work with the curses gui: it is redirected.
g.pr('\nEnd of leoImport tests.')
</t>
<t tx="ekr.20140724220921.5199"></t>
<t tx="ekr.20140725132959.4593">s = '''\
.. toc

.. The section name contains trailing whitespace.

=======
Chapter 
=======

The top chapter.
'''
table = (
    "!Dummy chapter",
    "Chapter",
)
try:
    c.importCommands.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20140802074328.4471"></t>
<t tx="ekr.20140802074328.4472">vc = c.vimCommands
s = '''
abc
xyz
pdq
'''
table = (
    ('ab','y',False),
    ('a','c',True),
    ('x','\np',True),
    ('\nx','z',False),
)
for a,b,expected in table:
    i1,i2 = s.find(a),s.find(b)
    result = vc.on_same_line(s,i1,i2)
    assert result == expected,'%s expected: %s got: %s' % (
        s[i1:i2],expected,got)
</t>
<t tx="ekr.20140802074328.4473">vc = c.vimCommands
s = '''
abc
xyz
'''
table = (
    ('a','a'),
    ('a','b'),
    ('a','\nx')
)
for a,b,in table:
    i1,i2 = s.find(a),s.find(b)
    result = vc.to_bol(s,i2)
    assert result == i1,'%s expected: %s got: %s' % (
        s[i1:i2],expected,got)
</t>
<t tx="ekr.20140802074328.4474">vc = c.vimCommands
s = '''
abc
xyz
'''
table = (
    ('a','\nx'),
    ('b','\nx'),
    ('c','\nx'),
    ('\nx','\nx'),
)
for a,b,in table:
    i1,i2 = s.find(a),s.find(b)
    result = vc.to_eol(s,i1)
    assert result == i2,'%s expected: %s got: %s' % (
        s[i1:i2],expected,got)
</t>
<t tx="ekr.20140904060337.4476">if g.in_bridge or g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
elif g.app.gui.guiName().startswith('qt'):
    import leo.core.leoFrame as leoFrame
    import leo.plugins.qt_text as qt_text
    from leo.core.leoQt import Qsci,QtWidgets
    if Qsci:
        w = Qsci.QsciScintilla()
        q = qt_text.QScintillaWrapper(widget=w,c=c,name='test')
        q_list = [z for z in sorted(dir(q)) if not z.startswith('__')]
    # Check the text wrappers.
    W = leoFrame.WrapperAPI(c)
    tw = QtWidgets.QTextBrowser()
    t = qt_text.QTextEditWrapper(widget=tw,name='test2')
    W_list = [z for z in sorted(dir(W)) if not z.startswith('__')]
    t_list = [z for z in sorted(dir(t)) if not z.startswith('__')]
    ignore = [
        'set_focus', # synonym for setFocus
        'mutable_methods', # maybe for unit test, not actually used.
    ]
    for z in W_list:
        if z not in t_list and z not in ignore:
            assert False,'In WrapperAPI but not in QTextEditWrapper: %s' % z
    if Qsci:
        for z in W_list:
            if z not in q_list and z not in ignore:
                assert False,'In WrapperAPI but not in QScintillaWrapper: %s' % z
    # Check Null classes that are not subclasses of a base type:
    table = (
        ('NullIconBarClass',leoFrame.NullIconBarClass(c,None),
         # 'c.frame.iconBar',c.frame.iconBar,
         'IconBarAPI',leoFrame.IconBarAPI(c,None),
        ),
        ('NullStatusLineClass',leoFrame.NullStatusLineClass(c,None),
         # 'c.frame.statusLine',c.frame.statusLine,
         'StatusLineAPI',leoFrame.StatusLineAPI(c,None)
        )
    )
    for name1,L,name2,W in table:
        W_list = [z for z in sorted(dir(W)) if not z.startswith('__')]
        L_list = [z for z in sorted(dir(L)) if not z.startswith('__')]
        for z in W_list:
            assert z in L_list,'In %s but not in %s: %s' % (name2,name1,z)
else:
     self.skipTest('Requires Qt Gui')
</t>
<t tx="ekr.20140923080452.6565"></t>
<t tx="ekr.20141016101308.4747">assert c.hiddenRootNode.fileIndex.startswith('hidden-root-vnode-gnx'), c.hiddenRootNode.fileIndex
</t>
<t tx="ekr.20141020110954.4750"># Bug https://bugs.launchpad.net/leo-editor/+bug/1245535
h = p.h
try:
    p.h = '\nab\nxy\n'
    assert p.h == 'abxy',p.h
finally:
    p.h = h
</t>
<t tx="ekr.20141022175515.11">d = {} # Keys are gnx's, values are lists of vnodes with that gnx.
for p in c.all_positions():
    gnx = p.v.fileIndex
    assert gnx,p.v
    aSet = d.get(gnx,set())
    aSet.add(p.v)
    d[gnx] = aSet
for gnx in sorted(d.keys()):
    aList = sorted(d.get(gnx))
    assert len(aList) == 1,(gnx,aList)
</t>
<t tx="ekr.20141208130803.11">assert g.importModule('codewise',verbose=False)
    # Top-level .py file.
assert g.importModule('rope',verbose=False)
    # In a folder.
</t>
<t tx="ekr.20141223125432.11">if not g.isPython3 and g.app.gui.guiName().startswith('qt'):
    import leo.core.leoQt as leoQt
    QString = leoQt.QString
    s = g.toUnicode(QString('abc'))
    assert s == 'abc',repr(s)
else:
    self.skipTest('Requires Qt Gui')
</t>
<t tx="ekr.20150208213643.12">def spam():
    pass</t>
<t tx="ekr.20150208213643.13">def eggs():
    pass</t>
<t tx="ekr.20150208213643.15">def spam():
    pass</t>
<t tx="ekr.20150208213643.16">def eggs():
    pass</t>
<t tx="ekr.20150208213643.18"># node 1 text A.
</t>
<t tx="ekr.20150208213643.19"># node 2 text B.
</t>
<t tx="ekr.20150210195923.11"></t>
<t tx="ekr.20150210195923.12">line
</t>
<t tx="ekr.20150210195923.15">line
</t>
<t tx="ekr.20150216070628.100">node 1 line 1
node 1 line 2 changed
node 1 line 3 changed
</t>
<t tx="ekr.20150216070628.101">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.102"></t>
<t tx="ekr.20150216070628.103">@others
</t>
<t tx="ekr.20150216070628.104">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20150216070628.105">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.106">@others
</t>
<t tx="ekr.20150216070628.107">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20150216070628.108">node 2 line 1 changed
node 2 line 2 changed
</t>
<t tx="ekr.20150216070628.109"></t>
<t tx="ekr.20150216070628.11">import unittest
import leo.core.leoShadow as leoShadow
# Possible: replace this suite with individual @test nodes
# exec(g.findTestScript(c,'@common @shadow test code'))
x = c.shadowController
suite = unittest.makeSuite(unittest.TestCase)
root = g.findNodeInTree(c,p,'@shadow-tests')
assert root, 'Node not found: @shadow-tests'
delims = '//','',''
for p in root.children_iter():
    h = p.h.strip()
    if h.startswith('@shadow-test'):
        test = x.AtShadowTestCase(c,p,x,delims=delims,trace=False)
        suite.addTest(test)
</t>
<t tx="ekr.20150216070628.110">@others
</t>
<t tx="ekr.20150216070628.111">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20150216070628.112">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.113">@others
</t>
<t tx="ekr.20150216070628.114">node 1 line 1
node 1 line 2 changed
</t>
<t tx="ekr.20150216070628.115">node 2 line 1 changed
node 2 line 2 changed
</t>
<t tx="ekr.20150216070628.116"></t>
<t tx="ekr.20150216070628.117">@others
</t>
<t tx="ekr.20150216070628.118">node 1 line 1
node 1 line 2
node 1 line 3
</t>
<t tx="ekr.20150216070628.119">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.12">@

All the tags should be tested at least once (equal, replace, delete, insert).

The replace, delete, insert operations should happen at least once:
    1. At the beginning of a node.
    2. In the middle of a node.
    3. At the end of a node.

For the delete and replace operators we must also test the case that the
deletion or replacement spans more than one block.
</t>
<t tx="ekr.20150216070628.120">@others
</t>
<t tx="ekr.20150216070628.121">node 1 line 1
</t>
<t tx="ekr.20150216070628.122">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.123"></t>
<t tx="ekr.20150216070628.124">@others
</t>
<t tx="ekr.20150216070628.125">node 1 line 1
</t>
<t tx="ekr.20150216070628.126">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20150216070628.127">@others
</t>
<t tx="ekr.20150216070628.128">node 1 line 1
</t>
<t tx="ekr.20150216070628.129">node 2 line 3
</t>
<t tx="ekr.20150216070628.130"></t>
<t tx="ekr.20150216070628.131">@others
</t>
<t tx="ekr.20150216070628.132">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3
</t>
<t tx="ekr.20150216070628.133">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20150216070628.134">@others
</t>
<t tx="ekr.20150216070628.135">node 1 line 1
line 1 line 3
</t>
<t tx="ekr.20150216070628.136">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20150216070628.137"></t>
<t tx="ekr.20150216070628.138">@others
</t>
<t tx="ekr.20150216070628.139">node 1 line 1
</t>
<t tx="ekr.20150216070628.14">@others
</t>
<t tx="ekr.20150216070628.140">@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
node 2 line 2
</t>
<t tx="ekr.20150216070628.141">@others
</t>
<t tx="ekr.20150216070628.142">node 1 line 1
</t>
<t tx="ekr.20150216070628.143">node 2 line 2
</t>
<t tx="ekr.20150216070628.144"></t>
<t tx="ekr.20150216070628.145">@others
</t>
<t tx="ekr.20150216070628.146">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3
</t>
<t tx="ekr.20150216070628.147">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20150216070628.148">@others
</t>
<t tx="ekr.20150216070628.149">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3
</t>
<t tx="ekr.20150216070628.15">@
node 1 old line 1
node 1 old line 2
node 1 line 2
</t>
<t tx="ekr.20150216070628.150">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20150216070628.151"></t>
<t tx="ekr.20150216070628.152">@others
</t>
<t tx="ekr.20150216070628.153">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
</t>
<t tx="ekr.20150216070628.154">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.155">@others
</t>
<t tx="ekr.20150216070628.156">node 1 line 1
</t>
<t tx="ekr.20150216070628.157">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.158"># This fails because the @all read logic inserts a second verbatim, I think.
</t>
<t tx="ekr.20150216070628.159">@others
</t>
<t tx="ekr.20150216070628.16">@others
</t>
<t tx="ekr.20150216070628.160">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20150216070628.161">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.162">@others
</t>
<t tx="ekr.20150216070628.163">node 1 line 1
@verbatim
#@ should be handled by verbatim
node 1 line 2
</t>
<t tx="ekr.20150216070628.164">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.165"></t>
<t tx="ekr.20150216070628.166">line
</t>
<t tx="ekr.20150216070628.167">line
</t>
<t tx="ekr.20150216070628.168"></t>
<t tx="ekr.20150216070628.17">@
node 1 old line 1
node 1 old line 2
node 1 line 2
</t>
<t tx="ekr.20150216070628.18"></t>
<t tx="ekr.20150216070628.19">@others
</t>
<t tx="ekr.20150216070628.20">node 1 line 1
node 1 old line 1
node 1 old line 2
node 1 old line 3
node 1 old line 4
node 1 line 2
</t>
<t tx="ekr.20150216070628.21">@others
</t>
<t tx="ekr.20150216070628.22">node 1 line 1
node 1 new line 1
node 1 new line 2
node 1 line 2
</t>
<t tx="ekr.20150216070628.23"></t>
<t tx="ekr.20150216070628.24">line 1
line 2
line 3
</t>
<t tx="ekr.20150216070628.25">line 1
line 2 changed
line 3
</t>
<t tx="ekr.20150216070628.26"></t>
<t tx="ekr.20150216070628.27">line 1
line 2
line 3
</t>
<t tx="ekr.20150216070628.28">line 1 changed
line 2
line 3
</t>
<t tx="ekr.20150216070628.29"></t>
<t tx="ekr.20150216070628.30">line 1
line 2
line 3
</t>
<t tx="ekr.20150216070628.31">line 1
line 2
line 3 changed
</t>
<t tx="ekr.20150216070628.32"></t>
<t tx="ekr.20150216070628.33">line 1
line 2
line 3
</t>
<t tx="ekr.20150216070628.34">line 2
line 3
</t>
<t tx="ekr.20150216070628.35"></t>
<t tx="ekr.20150216070628.36">line 1
line 2
line 3
</t>
<t tx="ekr.20150216070628.37">line 1
line 3
</t>
<t tx="ekr.20150216070628.38"></t>
<t tx="ekr.20150216070628.39">line 1
line 2
line 3
</t>
<t tx="ekr.20150216070628.40">line 1
line 2
</t>
<t tx="ekr.20150216070628.41"></t>
<t tx="ekr.20150216070628.42">line 1
line 2
line 3
</t>
<t tx="ekr.20150216070628.43">inserted line
line 1
line 2
line 3
</t>
<t tx="ekr.20150216070628.44"></t>
<t tx="ekr.20150216070628.45">line 1
line 2
line 3
</t>
<t tx="ekr.20150216070628.46">line 1
inserted line
line 2
line 3
</t>
<t tx="ekr.20150216070628.47"></t>
<t tx="ekr.20150216070628.48">line 1
line 2
line 3
</t>
<t tx="ekr.20150216070628.49">line 1
line 2
inserted line
line 3
</t>
<t tx="ekr.20150216070628.50"></t>
<t tx="ekr.20150216070628.51">line 1
line 2
line 3
</t>
<t tx="ekr.20150216070628.52">line 1
line 2
line 3
inserted line
</t>
<t tx="ekr.20150216070628.53"></t>
<t tx="ekr.20150216070628.54">@others
</t>
<t tx="ekr.20150216070628.55">node 1 line 1
</t>
<t tx="ekr.20150216070628.56">node 2 line 1
</t>
<t tx="ekr.20150216070628.57">@others
</t>
<t tx="ekr.20150216070628.58">node 1 line 1
inserted node at end of node 1
</t>
<t tx="ekr.20150216070628.59">node 2 line 1
</t>
<t tx="ekr.20150216070628.60"></t>
<t tx="ekr.20150216070628.61">@others
</t>
<t tx="ekr.20150216070628.62">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20150216070628.63">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.64">@others
</t>
<t tx="ekr.20150216070628.65">node 1 line 1
</t>
<t tx="ekr.20150216070628.66">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.67"></t>
<t tx="ekr.20150216070628.68">@others
</t>
<t tx="ekr.20150216070628.69">node 1 line 1
</t>
<t tx="ekr.20150216070628.70">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.71">@others
</t>
<t tx="ekr.20150216070628.72">node 1 line 1
</t>
<t tx="ekr.20150216070628.73">node 2 line 2
</t>
<t tx="ekr.20150216070628.74"></t>
<t tx="ekr.20150216070628.75">@others
</t>
<t tx="ekr.20150216070628.76">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20150216070628.77">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.78">@others
</t>
<t tx="ekr.20150216070628.79">node 1 line 1
node 1 line 1 changed
</t>
<t tx="ekr.20150216070628.80">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.81"></t>
<t tx="ekr.20150216070628.82">@others
</t>
<t tx="ekr.20150216070628.83">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20150216070628.84">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.85">@others
</t>
<t tx="ekr.20150216070628.86">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20150216070628.87">node 2 line 1 changed
node 2 line 2
</t>
<t tx="ekr.20150216070628.88"></t>
<t tx="ekr.20150216070628.89">@others
</t>
<t tx="ekr.20150216070628.90">node 1 line 1
inserted node 1 at end of node 1
inserted node 2 at end of node 1
</t>
<t tx="ekr.20150216070628.91">node 2 line 1
</t>
<t tx="ekr.20150216070628.92">@others
</t>
<t tx="ekr.20150216070628.93">node 1 line 1
</t>
<t tx="ekr.20150216070628.94">node 2 line 1
</t>
<t tx="ekr.20150216070628.95"></t>
<t tx="ekr.20150216070628.96">@others
</t>
<t tx="ekr.20150216070628.97">node 1 line 1
node 1 line 2
node 1 line 3
</t>
<t tx="ekr.20150216070628.98">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20150216070628.99">@others
</t>
<t tx="ekr.20150216111306.25">import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    persistence = g.findNodeAnywhere(c,'@persistence')
    assert persistence
    assert pd.has_at_persistence_node()
    persistence.deleteAllChildren()
    assert persistence
</t>
<t tx="ekr.20150317093233.11">aList1 = list(c.all_positions())
aList2 = list(c.safe_all_positions())
n1,n2 = len(aList1),len(aList2)
assert n1 == n2,(n1,n2)
</t>
<t tx="ekr.20150328120706.1">table = (
    ('A25&amp;()','A'),         # Non-alpha characters.
    ('B\tc','B c'),         # Tabs.
    ('"AB"',"'AB'"),        # Double quotes.
    ('\\/:|&lt;&gt;*:.','_'),     # Special characters.
    ('_____________','_'),  # Combining underscores.
    ('A' * 200,'A' * 128),  # Maximum length.
    ('abc.','abc_'),        # Trailing dots.
)
for s,expected in table:
    got = g.sanitize_filename(s)
    assert got==expected,'s: %r expected: %r got: %r' % (s,expected,got)
</t>
<t tx="ekr.20150414144038.1"># main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
i,j = g.getWord(s,4)
word = s[i:j]
aList = ac.getDynamicList(w,word)
c.k.arg = aList[1]
event = g.bunch(char=None, stroke=None, widget=w)
ac.dynamicExpandHelper(event)
    # This *does* support undo.
s = w.getAllText()
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 0: ###
        c.undoer.undo()
</t>
<t tx="ekr.20150414144103.1"># main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
# i,j = g.getWord(s,4)
# word = s[i:j]
event = g.bunch(widget=w)
ac.dynamicCompletion(event)
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 1:
        c.undoer.undo(event=event)

</t>
<t tx="ekr.20150430053825.1">ac = c.abbrevCommands
assert ac
child = g.findNodeInTree(c,p,'child')
assert child
old_b = child.b
try:
    i,j,val = 0,0,child.b
    # ac.make_script_substitutions(i,j,val)
    # ac.find_place_holder(child,True)
    new_s,i,j = ac.next_place(child.b,offset=0)
    assert i == 34 and j == 40,(i,j)
    new_s2,i,j = ac.next_place(new_s,offset=40)
    assert i == 54 and j == 58,(i,j)
finally:
    child.b = old_b
</t>
<t tx="ekr.20150430061225.1">def spam ():
    """None - Return &lt;|return|&gt;
    """

    &lt;|code|&gt;
</t>
<t tx="ekr.20150521123343.1"></t>
<t tx="ekr.20150610064911.1"># This tests only recent bugs.
p1 = p.firstChild()
s = p1.b
p2 = p1.next()
try:
    c.selectPosition(p1)
    c.k.simulateCommand('beautify-tree')
    assert p1.b == p2.b
finally:
    p1.b = s
    c.setChanged(False)

</t>
<t tx="ekr.20150610064930.1">def spam():
    if - 1 &lt; 2:
        pass
</t>
<t tx="ekr.20150610065241.1">def spam():
    if -1 &lt; 2:
        pass
</t>
<t tx="ekr.20150610130646.1">table = (
    r'abcd/xy\pdqabc/aaa.py',
)
for s in table:
    g.splitLongFileName(s,limit=3)
    
</t>
<t tx="ekr.20150626093653.1"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = True
    h = '@auto-rst unittest/at-auto-rst-line-number-test.py'
    root = g.findNodeAnywhere(c, h)
    assert root
    assert root.isAtAutoRstNode(), root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        # g.cls()
        print('get_external_file_with_sentinels returns...')
        # print(''.join(['%3s %r' % (i, s) for i, s in enumerate(g.splitLines(s))]))
        g.printList(g.splitLines(s))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n, offset, p and p.h))
        else:
            if trace: print('not found: %s' % n)
            assert n == 9, n
            break
</t>
<t tx="ekr.20150626093745.1">@language rest
@tabwidth -4
</t>
<t tx="ekr.20150626100719.1">@others
Note: This node's body text is ignored when writing this file.

The @others directive is not required.
@language plain
@tabwidth -4
</t>
<t tx="ekr.20150626101627.1">@others
Note: This node's body text is ignored when writing this file.

The @others directive is not required.
@language plain
@tabwidth -4
</t>
<t tx="ekr.20150626101842.1">@others
Note: This node's body text is ignored when writing this file.

The @others directive is not required.
@language md
@tabwidth -4
</t>
<t tx="ekr.20150626101920.1">import sys
# Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
elif sys.platform.startswith('win'):
    trace = False
    h = '@auto unittest/at-auto-md-line-number-test.md'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        # g.cls()
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n, offset, p and p.h))
        else:
            if trace: print('not found: %s' % n)
            assert n == 7, n
            break
else:
    self.skipTest('Skip on Linux')
</t>
<t tx="ekr.20150919073819.1">class aClass:
    def __init__(self):
        pass
    def spam(self):
        pass
bClass = aClass
</t>
<t tx="ekr.20150919074122.1">tm = c.testManager
before   = g.findNodeInTree(c,p,'before')
expected = g.findNodeInTree(c,p,'expected')
assert before,expected
try:
    c.selectPosition(before)
    before.h = 'expected' # To make the compare work.
    c.importCommands.parse_body(before)
    # compare tree.
    assert tm.compareOutlines(before,expected,compareHeadlines=True,tag='',report=True)
    c.undoer.undo()
finally:
    before.h = 'before'
    c.redraw()
</t>
<t tx="ekr.20150919074132.1">@others
</t>
<t tx="ekr.20150919074154.1">@others
</t>
<t tx="ekr.20150919074211.1">class TypeJoinVisitor(TypeVisitor[Type]):
    """Implementation of the least upper bound algorithm.

    Attributes:
      s: The other (left) type operand.
    """
    @others
</t>
<t tx="ekr.20150919074211.10">def visit_erased_type(self, t: ErasedType) -&gt; Type:
    return self.s

</t>
<t tx="ekr.20150919074211.11">def visit_type_var(self, t: TypeVarType) -&gt; Type:
    if isinstance(self.s, TypeVarType) and (cast(TypeVarType, self.s)).id == t.id:
        return self.s
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20150919074211.12">def visit_instance(self, t: Instance) -&gt; Type:
    if isinstance(self.s, Instance):
        return join_instances(t, cast(Instance, self.s))
    elif isinstance(self.s, FunctionLike):
        return join_types(t, self.s.fallback)
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20150919074211.13">def visit_callable_type(self, t: CallableType) -&gt; Type:
    # TODO: Consider subtyping instead of just similarity.
    if isinstance(self.s, CallableType) and is_similar_callables(
            t, cast(CallableType, self.s)):
        return combine_similar_callables(t, cast(CallableType, self.s))
    elif isinstance(self.s, Overloaded):
        # Switch the order of arguments to that we'll get to visit_overloaded.
        return join_types(t, self.s)
    else:
        return join_types(t.fallback, self.s)

</t>
<t tx="ekr.20150919074211.14">def visit_overloaded(self, t: Overloaded) -&gt; Type:
    # This is more complex than most other cases. Here are some
    # examples that illustrate how this works.
    #
    # First let's define a concise notation:
    #  - Cn are callable types (for n in 1, 2, ...)
    #  - Ov(C1, C2, ...) is an overloaded type with items C1, C2, ...
    #  - Callable[[T, ...], S] is written as [T, ...] -&gt; S.
    #
    # We want some basic properties to hold (assume Cn are all
    # unrelated via Any-similarity):
    #
    #   join(Ov(C1, C2), C1) == C1
    #   join(Ov(C1, C2), Ov(C1, C2)) == Ov(C1, C2)
    #   join(Ov(C1, C2), Ov(C1, C3)) == C1
    #   join(Ov(C2, C2), C3) == join of fallback types
    #
    # The presence of Any types makes things more interesting. The join is the
    # most general type we can get with respect to Any:
    #
    #   join(Ov([int] -&gt; int, [str] -&gt; str), [Any] -&gt; str) == Any -&gt; str
    #
    # We could use a simplification step that removes redundancies, but that's not
    # implemented right now. Consider this example, where we get a redundancy:
    #
    #   join(Ov([int, Any] -&gt; Any, [str, Any] -&gt; Any), [Any, int] -&gt; Any) ==
    #       Ov([Any, int] -&gt; Any, [Any, int] -&gt; Any)
    #
    # TODO: Use callable subtyping instead of just similarity.
    result = []  # type: List[CallableType]
    s = self.s
    if isinstance(s, FunctionLike):
        # The interesting case where both types are function types.
        for t_item in t.items():
            for s_item in s.items():
                if is_similar_callables(t_item, s_item):
                    result.append(combine_similar_callables(t_item, s_item))
        if result:
            # TODO: Simplify redundancies from the result.
            if len(result) == 1:
                return result[0]
            else:
                return Overloaded(result)
        return join_types(t.fallback, s.fallback)
    return join_types(t.fallback, s)

</t>
<t tx="ekr.20150919074211.15">def visit_tuple_type(self, t: TupleType) -&gt; Type:
    if (isinstance(self.s, TupleType) and
            cast(TupleType, self.s).length() == t.length()):
        items = []  # type: List[Type]
        for i in range(t.length()):
            items.append(self.join(t.items[i],
                                   (cast(TupleType, self.s)).items[i]))
        # TODO: What if the fallback types are different?
        return TupleType(items, t.fallback)
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20150919074211.16">def join(self, s: Type, t: Type) -&gt; Type:
    return join_types(s, t)

</t>
<t tx="ekr.20150919074211.17">def default(self, typ: Type) -&gt; Type:
    if isinstance(typ, Instance):
        return object_from_instance(typ)
    elif isinstance(typ, UnboundType):
        return AnyType()
    elif isinstance(typ, Void) or isinstance(typ, ErrorType):
        return ErrorType()
    elif isinstance(typ, TupleType):
        return self.default(typ.fallback)
    elif isinstance(typ, FunctionLike):
        return self.default(typ.fallback)
    elif isinstance(typ, TypeVarType):
        return self.default(typ.upper_bound)
    else:
        return AnyType()
</t>
<t tx="ekr.20150919074211.2">
def __init__(self, s: Type) -&gt; None:
    self.s = s

</t>
<t tx="ekr.20150919074211.3">def visit_unbound_type(self, t: UnboundType) -&gt; Type:
    if isinstance(self.s, Void) or isinstance(self.s, ErrorType):
        return ErrorType()
    else:
        return AnyType()

</t>
<t tx="ekr.20150919074211.4">def visit_union_type(self, t: UnionType) -&gt; Type:
    if is_subtype(self.s, t):
        return t
    else:
        return UnionType(t.items + [self.s])

</t>
<t tx="ekr.20150919074211.5">def visit_error_type(self, t: ErrorType) -&gt; Type:
    return t

</t>
<t tx="ekr.20150919074211.6">def visit_type_list(self, t: TypeList) -&gt; Type:
    assert False, 'Not supported'

</t>
<t tx="ekr.20150919074211.7">def visit_any(self, t: AnyType) -&gt; Type:
    return t

</t>
<t tx="ekr.20150919074211.8">def visit_void(self, t: Void) -&gt; Type:
    if isinstance(self.s, Void):
        return t
    else:
        return ErrorType()

</t>
<t tx="ekr.20150919074211.9">def visit_none_type(self, t: NoneTyp) -&gt; Type:
    if not isinstance(self.s, Void):
        return self.s
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20150919074220.1">class TypeJoinVisitor(TypeVisitor[Type]):
    """Implementation of the least upper bound algorithm.

    Attributes:
      s: The other (left) type operand.
    """

    def __init__(self, s: Type) -&gt; None:
        self.s = s

    def visit_unbound_type(self, t: UnboundType) -&gt; Type:
        if isinstance(self.s, Void) or isinstance(self.s, ErrorType):
            return ErrorType()
        else:
            return AnyType()

    def visit_union_type(self, t: UnionType) -&gt; Type:
        if is_subtype(self.s, t):
            return t
        else:
            return UnionType(t.items + [self.s])

    def visit_error_type(self, t: ErrorType) -&gt; Type:
        return t

    def visit_type_list(self, t: TypeList) -&gt; Type:
        assert False, 'Not supported'

    def visit_any(self, t: AnyType) -&gt; Type:
        return t

    def visit_void(self, t: Void) -&gt; Type:
        if isinstance(self.s, Void):
            return t
        else:
            return ErrorType()

    def visit_none_type(self, t: NoneTyp) -&gt; Type:
        if not isinstance(self.s, Void):
            return self.s
        else:
            return self.default(self.s)

    def visit_erased_type(self, t: ErasedType) -&gt; Type:
        return self.s

    def visit_type_var(self, t: TypeVarType) -&gt; Type:
        if isinstance(self.s, TypeVarType) and (cast(TypeVarType, self.s)).id == t.id:
            return self.s
        else:
            return self.default(self.s)

    def visit_instance(self, t: Instance) -&gt; Type:
        if isinstance(self.s, Instance):
            return join_instances(t, cast(Instance, self.s))
        elif isinstance(self.s, FunctionLike):
            return join_types(t, self.s.fallback)
        else:
            return self.default(self.s)

    def visit_callable_type(self, t: CallableType) -&gt; Type:
        # TODO: Consider subtyping instead of just similarity.
        if isinstance(self.s, CallableType) and is_similar_callables(
                t, cast(CallableType, self.s)):
            return combine_similar_callables(t, cast(CallableType, self.s))
        elif isinstance(self.s, Overloaded):
            # Switch the order of arguments to that we'll get to visit_overloaded.
            return join_types(t, self.s)
        else:
            return join_types(t.fallback, self.s)

    def visit_overloaded(self, t: Overloaded) -&gt; Type:
        # This is more complex than most other cases. Here are some
        # examples that illustrate how this works.
        #
        # First let's define a concise notation:
        #  - Cn are callable types (for n in 1, 2, ...)
        #  - Ov(C1, C2, ...) is an overloaded type with items C1, C2, ...
        #  - Callable[[T, ...], S] is written as [T, ...] -&gt; S.
        #
        # We want some basic properties to hold (assume Cn are all
        # unrelated via Any-similarity):
        #
        #   join(Ov(C1, C2), C1) == C1
        #   join(Ov(C1, C2), Ov(C1, C2)) == Ov(C1, C2)
        #   join(Ov(C1, C2), Ov(C1, C3)) == C1
        #   join(Ov(C2, C2), C3) == join of fallback types
        #
        # The presence of Any types makes things more interesting. The join is the
        # most general type we can get with respect to Any:
        #
        #   join(Ov([int] -&gt; int, [str] -&gt; str), [Any] -&gt; str) == Any -&gt; str
        #
        # We could use a simplification step that removes redundancies, but that's not
        # implemented right now. Consider this example, where we get a redundancy:
        #
        #   join(Ov([int, Any] -&gt; Any, [str, Any] -&gt; Any), [Any, int] -&gt; Any) ==
        #       Ov([Any, int] -&gt; Any, [Any, int] -&gt; Any)
        #
        # TODO: Use callable subtyping instead of just similarity.
        result = []  # type: List[CallableType]
        s = self.s
        if isinstance(s, FunctionLike):
            # The interesting case where both types are function types.
            for t_item in t.items():
                for s_item in s.items():
                    if is_similar_callables(t_item, s_item):
                        result.append(combine_similar_callables(t_item, s_item))
            if result:
                # TODO: Simplify redundancies from the result.
                if len(result) == 1:
                    return result[0]
                else:
                    return Overloaded(result)
            return join_types(t.fallback, s.fallback)
        return join_types(t.fallback, s)

    def visit_tuple_type(self, t: TupleType) -&gt; Type:
        if (isinstance(self.s, TupleType) and
                cast(TupleType, self.s).length() == t.length()):
            items = []  # type: List[Type]
            for i in range(t.length()):
                items.append(self.join(t.items[i],
                                       (cast(TupleType, self.s)).items[i]))
            # TODO: What if the fallback types are different?
            return TupleType(items, t.fallback)
        else:
            return self.default(self.s)

    def join(self, s: Type, t: Type) -&gt; Type:
        return join_types(s, t)

    def default(self, typ: Type) -&gt; Type:
        if isinstance(typ, Instance):
            return object_from_instance(typ)
        elif isinstance(typ, UnboundType):
            return AnyType()
        elif isinstance(typ, Void) or isinstance(typ, ErrorType):
            return ErrorType()
        elif isinstance(typ, TupleType):
            return self.default(typ.fallback)
        elif isinstance(typ, FunctionLike):
            return self.default(typ.fallback)
        elif isinstance(typ, TypeVarType):
            return self.default(typ.upper_bound)
        else:
            return AnyType()
</t>
<t tx="ekr.20150919074321.1">class aClass:
    @others
</t>
<t tx="ekr.20150919074321.2">def __init__(self):
    pass
</t>
<t tx="ekr.20150919074321.3">def spam(self):
    pass
</t>
<t tx="ekr.20160123044102.1"># These must not return NotImplemented!
root = c.rootPosition()
assert p.__eq__(None) is False, p.__eq__(None)
assert p.__ne__(None) is True, p.__ne__(None)
assert p.__eq__(root) is False, p.__eq__(root)
assert p.__ne__(root) is True, p.__ne__(root)
</t>
<t tx="ekr.20160129082128.1" my_plugin="580300000076616c71002e">assert p.u == p.v.u, (p.u, p.v.u)
p.v.u = None
assert p.u == {}, p.u
assert p.v.u == {}, p.v.u
d = {'my_plugin': 'val'}
p.u = d
assert p.u == d, (p.u, d)
assert p.v.u == d, (p.v.u, d)
</t>
<t tx="ekr.20160314133351.1">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20160314133351.2">first line
before foo += bar2 after
last line
</t>
<t tx="ekr.20160314133351.3">first line
before bar2 += foo after
last line
</t>
<t tx="ekr.20160314133351.4">first line
before foo += bar2 after
last line
</t>
<t tx="ekr.20160318094003.1"></t>
<t tx="ekr.20160318094009.1">if not g.isPython3:
    self.skipTest('python 3 test')
else:
    import leo.core.leoAst as leoAst
    import leo.external.make_stub_files as msf
    import leo.external.py2cs as py2cs
    import ast, tokenize
    path = g.os_path_finalize_join(g.app.loadDir,
        '..', 'test', 'unittest', 'python3_test.py')
    assert g.os_path_exists(path), path
    fn = g.shortFileName(path)
    source = open(path, 'r').read()
    node = ast.parse(source, filename=fn, mode='exec')
    src = open(path, 'r').read()
    readlines = g.ReadLinesClass(src).next
    tokens = list(tokenize.generate_tokens(readlines))
    leoAst.AstFullTraverser().visit(node)
    s = leoAst.HTMLReportTraverser(debug=True).main(fn, node)
    assert s
    s = leoAst.AstFormatter().format(node)
    assert s
    s = py2cs.CoffeeScriptTraverser(controller=g.NullObject()).format(node, src, tokens)
    assert s
    controller = msf.StandAloneMakeStubFile()
    msf.StubTraverser(controller).visit(node)
</t>
<t tx="ekr.20160327132053.1"># Mimic the code in g.get_directives_dict
import re
pat = g.compute_directives_re()
pat = re.compile(pat, re.MULTILINE)
table = (
    '@wrap', # The failure case.
    '@wrap ',
    '@wrap\n',
    '@wrap\t',
)
for s in table:
    m = pat.search(s)
    assert m, repr(s)
</t>
<t tx="ekr.20160402043006.1"># node a
</t>
<t tx="ekr.20160402043006.2"># node b
</t>
<t tx="ekr.20160402043006.3"># node c
</t>
<t tx="ekr.20160403123754.1">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20160403123754.2">def child():
    pass
</t>
<t tx="ekr.20160403143048.1">@language c
@tabwidth -4
// before @others // line 1
@others
// last line: line 6
</t>
<t tx="ekr.20160403143048.2">def spam(): // line 2
    pass
</t>
<t tx="ekr.20160403143130.1">@language python
@tabwidth -4
# Before @others: line 1
@others
# Last line: line 6
</t>
<t tx="ekr.20160403143643.1"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    lines = g.splitLines(s)
    g.printList(lines)
    stripped_lines = [z for z in lines if not z.startswith('//@')]
    g.printList(stripped_lines)
    if trace:
        # g.cls()
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(lines)]))
    table = (
        # n is the 1-based offset
        (3, 4,  '// before @others // line 1'),
        (2, 8,  'def spam(): // line 2'),
        (3, 9,  '    pass'),
        (1, 11, 'def eggs(): // line 4'),
        (2, 12, '    pass'),
        (5, 14, '// last line: line 6'),
    )
    for i, data in enumerate(table):
        expected_offset, target_offset, expected_line = data
        p, offset, found = c.gotoCommands.find_file_line(i+1, p=target)
        assert expected_offset == offset, (
            'i: %s expected offset %s, got %s' % (i, expected_offset, offset))
        expected_line = expected_line.rstrip()
        got_line = stripped_lines[i].rstrip()
        assert expected_line == got_line, 'i: %s expected line:\n%s\ngot line:\n%s' % (
            i, expected_line, got_line)
        got_line2 = lines[target_offset].rstrip()
        assert expected_line == got_line2, 'i: %s expected line:\n%s\ngot line2:\n%s' % (
            i, expected_line, got_line)
    i = len(table)
    p, offset, found = c.gotoCommands.find_file_line(i+1, p=target)
    assert not found
</t>
<t tx="ekr.20160403143655.1"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    lines = g.splitLines(s)
    stripped_lines = [z for z in lines if not z.startswith('#@')]
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(lines)]))
        # print('')
        # print(''.join(['%3s %s' % (i, s) for i, s in enumerate(stripped_lines)]))
    table = (
        # n is the 1-based offset
        (3, 4,  '# Before @others: line 1'),
        (2, 8,  'def spam(): # line 2'),
        (3, 9,  '    pass'),
        (1, 11, 'def eggs(): # line 4'),
        (2, 12, '    pass'),
        (5, 14, '# Last line: line 6'),
    )
    for i, data in enumerate(table):
        expected_offset, target_offset, expected_line = data
        p, offset, found = c.gotoCommands.find_file_line(i+1, p=target)
        assert expected_offset == offset, (
            'i: %s expected offset %s, got %s' % (i, expected_offset, offset))
        expected_line = expected_line.rstrip()
        got_line = stripped_lines[i].rstrip()
        assert expected_line == got_line, 'i: %s expected line:\n%s\ngot line:\n%s' % (
            i, expected_line, got_line)
        got_line2 = lines[target_offset].rstrip()
        assert expected_line == got_line2, 'i: %s expected line:\n%s\ngot line2:\n%s' % (
            i, expected_line, got_line)
    i = len(table)
    p, offset, found = c.gotoCommands.find_file_line(i+1, p=target)
    assert not found
</t>
<t tx="ekr.20160403150121.1">def eggs(): // line 4
    pass
</t>
<t tx="ekr.20160403150216.1">def spam(): # line 2
    pass
</t>
<t tx="ekr.20160403150222.1">def eggs(): # line 4
    pass
</t>
<t tx="ekr.20160403152507.1">def eggs(): # line 4
    pass</t>
<t tx="ekr.20160410152100.1"></t>
<t tx="ekr.20160410152100.2">&lt;&lt; define s &gt;&gt;
if 0:
    # The preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
    # x = markdown.Markdown_Importer(ic)
else:
    ic = c.importCommands  
try:
    ic.markdownUnitTest(p,s=s,showTree=True) # Must be true.
    table = (
        (1, 'Top'),
        (2, 'Section 1'),
        (2, 'Section 2'),
        (3, 'Section 2.1'),
        (4, 'Section 2.1.1'),
        (3, 'Section 2.2'),
        (2, 'Section 3'),
    )
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@auto-m'), root.h
    p = root.firstChild()
    for n, h in table:
        n2 = p.level() - root.level()
        assert h == p.h, (h, p.h)
        assert n == n2, (n, n2, p.h)
        p.moveToThreadNext()
    assert p == after, p.h
finally:
    if 1:
        if root:
            root.doDelete()
        c.redraw()
</t>
<t tx="ekr.20160411033840.1">&lt;&lt; define s &gt;&gt;
if 0:
    # The preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    # imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
try:
    ic.markdownUnitTest(p,s=s,showTree=True) # Must be True.
    table = (
        (1, 'Top'),
        (2, 'Section 1'),
        (2, 'Section 2'),
        (3, 'Section 2.1'),
        (4, 'Section 2.1.1'),
        (3, 'Section 2.2'),
        (2, 'Section 3'),
    )
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@auto-m'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, p.h
finally:
    if 1:
        if root:
            root.doDelete()
        c.redraw()
</t>
<t tx="ekr.20160411034540.1">s = '''\
#Top
The top section

##Section 1
section 1, line 1
section 1, line 2

##Section 2
section 2, line 1

###Section 2.1
section 2.1, line 1

####Section 2.1.1
section 2.2.1 line 1
The next section is empty. It must not be deleted.

###Section 2.2

##Section 3
Section 3, line 1

'''
</t>
<t tx="ekr.20160523094102.1"># Great ast docs: http://greentreesnakes.readthedocs.io/en/latest/nodes.html

import leo.core.leoAst as leoAst
leoAst.unit_test(raise_on_fail=True)

import leo.external.make_stub_files as msf
msf.unit_test(raise_on_fail=True)

import leo.external.py2cs as py2cs
py2cs.unit_test(raise_on_fail=True)

</t>
<t tx="ekr.20161002020559.1"># This fixes a major bug in *all* generators returning positions.
trace = False
root = p.firstChild().firstChild()
table = (
    ('all_positions', c.all_positions),
    ('all_unique_positions', c.all_unique_positions),
    ('children', root.children),
    ('self_and_siblings', root.self_and_siblings),
    ('self_and_parents', root.firstChild().self_and_parents),
    ('self_and_subtree', root.self_and_subtree),
    ('following_siblings', root.following_siblings),
    ('parents', root.firstChild().firstChild().parents),
    ('unique_subtree', root.unique_subtree),
)
fail = []
for kind, generator in table:
    aList = list(generator())
    aList2 = list(set(aList))
    if len(aList) == len(aList2) and len(aList) &gt; 1:
        if trace: print('  OK: %s %s' % (kind, len(aList)))
    else:
        if trace: print('FAIL: %s %s %s' % (kind, len(aList), len(aList2)))
        fail.append(kind)
assert not fail, fail
</t>
<t tx="ekr.20161011052016.1">import imp
import leo.plugins.importers.javascript as js
imp.reload(js)
table = (
    # base  result          s
    (None, (0, 0, '/*'),    r'/* abc'),
    (None, (0, 0, ''),      r'a + b // /*'),
    (None, (0, 1, ''),      r'(function'),
    (None, (1, 1, ''),      r'(function(a) {'),
    (None, (0, 0, ''),      r'var x = /abc/'),
    (None, (0, 0, ''),      r'var x = /a"c/'),
    (None, (0, 0, ''),      r'var x = /a\//'),
    (None, (0, 0, ''),      r'var x = /a\//'),
    # (None, (0, 0, ''),      r"console.log(/'\d+'/)"),
    (None, (0, 1, ''),      r'var x = (0,'),
)
for base, result, s in table:
    importer = js.JS_Importer(c.importCommands)
    prev_state = js.JS_ScanState()
    new_state = importer.scan_line(s, prev_state)
    curlies, parens, context = result
    ok = (
        new_state.curlies == curlies and
        new_state.parens == parens and
        new_state.context == context)
    assert ok, '\nnew_state: %s\n        s: %s' % (new_state, s)
</t>
<t tx="ekr.20161011092326.7"># ~/at-auto-test.py

# This is valid Python, but it looks like a section reference.
a = b &lt;&lt; c &gt;&gt; d

</t>
<t tx="ekr.20161103015908.1"></t>
<t tx="ekr.20161103015940.1">s = '''\
#!/usr/bin/perl

# Function definition
sub Hello{
   print "Hello, World!\n";
}

sub Test{
   print "Test!\n";
}
"\N{LATIN SMALL LIGATURE FI}" =~ /fi/i;

$bar = "foo";
if ($bar =~ /foo/){
   print "Second time is matching\n";
}else{
   print "Second time is not matching\n";
}

# Function call
Hello();
'''
try:
    c.importCommands.perlUnitTest(p,s=s,showTree=True)
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161103021420.1">s = '''\
#!/usr/bin/perl

# This would print with a line break in the middle
print "Hello

sub World {
    print "This is not a funtion!"
}

world\n";
'''
try:
    c.importCommands.perlUnitTest(p,s=s,showTree=True)
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161103021621.1">s = '''\
#!/usr/bin/perl
          
sub Test{
   print "Test!\n";
}

=begin comment
sub World {
    print "This is not a funtion!"
}
=cut

# Function definition
sub Hello{
   print "Hello, World!\n";
}
'''
try:
    c.importCommands.perlUnitTest(p,s=s,showTree=True)
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161103075725.1"># These fail with the NEW (strict) import tests and the OLD scanners.</t>
<t tx="ekr.20161108034116.1"></t>
<t tx="ekr.20161108034138.1">@killcolor

s = r'''

# The JavaScript to CoffeeScript compiler.
# Common usage:
#
#
#     var src = "var square = function(n) { return n * n };"
#
#     js2coffee = require('js2coffee');
#     js2coffee.build(src);
#     //=&gt; "square = (n) -&gt; n * n"

# ## Requires
#
# Js2coffee relies on Narcissus's parser. (Narcissus is Mozilla's JavaScript
# engine written in JavaScript).

{parser} = @Narcissus or require('./narcissus_packed')

_ = @_ or require('underscore')

{Types, Typenames, Node} = @NodeExt or require('./node_ext')

{Code, p, strEscape, unreserve, unshift, isSingleLine, trim, blockTrim,
  ltrim, rtrim, strRepeat, paren, truthy} = @Js2coffeeHelpers or require('./helpers')

# ## Main entry point
# This is `require('js2coffee').build()`. It takes a JavaScript source
# string as an argument, and it returns the CoffeeScript version.
#
# 1. Ask Narcissus to break it down into Nodes (`parser.parse`). This
#    returns a `Node` object of type `script`.
#
# 2. This node is now passed onto `Builder#build()`.

buildCoffee = (str) -&gt;
  str  = str.replace /\r/g, ''
  str += "\n"

  builder    = new Builder
  scriptNode = parser.parse str

  output = trim builder.build(scriptNode)
  (rtrim line for line in output.split('\n')).join('\n')
# ## Builder class
# This is the main class that proccesses the AST and spits out streng.
# See the `buildCoffee()` function above for info on how this is used.

class Builder
  constructor: -&gt;
    @transformer = new Transformer
  # `build()`
  # The main entry point.

  # This finds the appropriate @builder function for `node` based on it's type,
  # the passes the node onto that function.
  #
  # For instance, for a `function` node, it calls `@builders.function(node)`.
  # It defaults to `@builders.other` if it can't find a function for it.

  build: (args...) -&gt;
    node = args[0]
    @transform node

    name = 'other'
    name = node.typeName()  if node != undefined and node.typeName

    fn  = (@[name] or @other)
    out = fn.apply(this, args)

    if node.parenthesized then paren(out) else out
  # `transform()`
  # Perform a transformation on the node, if a transformation function is
  # available.

  transform: (args...) -&gt;
    @transformer.transform.apply(@transformer, args)
  # `body()`
  # Works like `@build()`, and is used for code blocks. It cleans up the returned
  # code block by removing any extraneous spaces and such.

  body: (node, opts={}) -&gt;
    str = @build(node, opts)
    str = blockTrim(str)
    str = unshift(str)

    if str.length &gt; 0 then str else ""
  # ## The builders
  #
  # Each of these method are passed a Node, and is expected to return
  # a string representation of it CoffeeScript counterpart.
  #
  # These are invoked using the main entry point, `Builder#build()`.

  # `script`
  # This is the main entry point.

  'script': (n, opts={}) -&gt;
    c = new Code

    # *Functions must always be declared first in a block.*
    _.each n.functions,    (item) =&gt; c.add @build(item)
    _.each n.nonfunctions, (item) =&gt; c.add @build(item)

    c.toString()
  # `property_identifier`
  # A key in an object literal.

  'property_identifier': (n) -&gt;
    str = n.value.toString()

    # **Caveat:**
    # *In object literals like `{ '#foo click': b }`, ensure that the key is
    # quoted if need be.*

    if str.match(/^([_\$a-z][_\$a-z0-9]*)$/i) or str.match(/^[0-9]+$/i)
      str
    else
      strEscape str
  # `identifier`
  # Any object identifier like a variable name.

  'identifier': (n) -&gt;
    if n.value is 'undefined'
      '`undefined`'
    else if n.property_accessor
      n.value.toString()
    else
      unreserve n.value.toString()
  'number': (n) -&gt;
    "#{n.src()}"
  'id': (n) -&gt;
    if n.property_accessor
      n
    else
      unreserve n
  # `id_param`
  # Function parameters. Belongs to `list`.

  'id_param': (n) -&gt;
    if n.toString() in ['undefined']
      "#{n}_"
    else
      @id n
  # `return`
  # A return statement. Has `n.value` of type `id`.

  'return': (n) -&gt;
    if not n.value?
      "return\n"

    else
      "return #{@build(n.value)}\n"
  # `;` (aka, statement)
  # A single statement.

  ';': (n) -&gt;
    # **Caveat:**
    # Some statements can be blank as some people are silly enough to use `;;`
    # sometimes. They should be ignored.

    unless n.expression?
      ""

    else if n.expression.typeName() == 'object_init'
      src = @object_init(n.expression)
      if n.parenthesized
        src
      else
        "#{unshift(blockTrim(src))}\n"

    else
      @build(n.expression) + "\n"
  # `new` + `new_with_args`
  # For `new X` and `new X(y)` respctively.

  'new': (n) -&gt; "new #{@build n.left()}"
  'new_with_args': (n) -&gt; "new #{@build n.left()}(#{@build n.right()})"
  # ### Unary operators

  'unary_plus': (n) -&gt; "+#{@build n.left()}"
  'unary_minus': (n) -&gt; "-#{@build n.left()}"
  # ### Keywords

  'this': (n) -&gt; 'this'
  'null': (n) -&gt; 'null'
  'true': (n) -&gt; 'true'
  'false': (n) -&gt; 'false'
  'void': (n) -&gt; 'undefined'
  'debugger': (n) -&gt; "debugger\n"
  'break': (n) -&gt; "break\n"
  'continue': (n) -&gt; "continue\n"
  # ### Some simple operators

  '~': (n) -&gt; "~#{@build n.left()}"
  'typeof': (n) -&gt; "typeof #{@build n.left()}"
  'index': (n) -&gt;
    right = @build n.right()
    if _.any(n.children, (child) -&gt; child.typeName() == 'object_init' and child.children.length &gt; 1)
      right = "{#{right}}"
    "#{@build n.left()}[#{right}]"
  'throw': (n) -&gt; "throw #{@build n.exception}"
  '!': (n) -&gt;
    target = n.left()
    negations = 1
    ++negations while (target.isA '!') and target = target.left()
    if (negations &amp; 1) and target.isA '==', '!=', '===', '!==', 'in', 'instanceof' # invertible binary operators
      target.negated = not target.negated
      return @build target
    "#{if negations &amp; 1 then 'not ' else '!!'}#{@build target}"
  # ### Binary operators
  # All of these are rerouted to the `binary_operator` @builder.

  # TODO: make a function that generates these functions, invoked like so:
  #   in: binop 'in', 'of'
  #   '+': binop '+'
  #   and so on...

  in: (n) -&gt;    @binary_operator n, 'of'
  '+': (n) -&gt;   @binary_operator n, '+'
  '-': (n) -&gt;   @binary_operator n, '-'
  '*': (n) -&gt;   @binary_operator n, '*'
  '/': (n) -&gt;   @binary_operator n, '/'
  '%': (n) -&gt;   @binary_operator n, '%'
  '&gt;': (n) -&gt;   @binary_operator n, '&gt;'
  '&lt;': (n) -&gt;   @binary_operator n, '&lt;'
  '&amp;': (n) -&gt;   @binary_operator n, '&amp;'
  '|': (n) -&gt;   @binary_operator n, '|'
  '^': (n) -&gt;   @binary_operator n, '^'
  '&amp;&amp;': (n) -&gt;  @binary_operator n, 'and'
  '||': (n) -&gt;  @binary_operator n, 'or'
  '&lt;&lt;': (n) -&gt;  @binary_operator n, '&lt;&lt;'
  '&lt;=': (n) -&gt;  @binary_operator n, '&lt;='
  '&gt;&gt;': (n) -&gt;  @binary_operator n, '&gt;&gt;'
  '&gt;=': (n) -&gt;  @binary_operator n, '&gt;='
  '===': (n) -&gt; @binary_operator n, 'is'
  '!==': (n) -&gt; @binary_operator n, 'isnt'
  '&gt;&gt;&gt;': (n) -&gt;  @binary_operator n, '&gt;&gt;&gt;'
  instanceof: (n) -&gt; @binary_operator n, 'instanceof'
  '==': (n) -&gt;
    # TODO: throw warning
    @binary_operator n, 'is'
  '!=': (n) -&gt;
    # TODO: throw warning
    @binary_operator n, 'isnt'
  'binary_operator': do -&gt;
    INVERSIONS =
      is: 'isnt'
      in: 'not in'
      of: 'not of'
      instanceof: 'not instanceof'
    INVERSIONS[v] = k for own k, v of INVERSIONS
    (n, sign) -&gt;
      sign = INVERSIONS[sign] if n.negated
      "#{@build n.left()} #{sign} #{@build n.right()}"
  # ### Increments and decrements
  # For `a++` and `--b`.

  '--': (n) -&gt; @increment_decrement n, '--'
  '++': (n) -&gt; @increment_decrement n, '++'
  'increment_decrement': (n, sign) -&gt;
    if n.postfix
      "#{@build n.left()}#{sign}"
    else
      "#{sign}#{@build n.left()}"
  # `=` (aka, assignment)
  # For `a = b` (but not `var a = b`: that's `var`).

  '=': (n) -&gt;
    sign = if n.assignOp?
      Types[n.assignOp] + '='
    else
      '='

    "#{@build n.left()} #{sign} #{@build n.right()}"
  # `,` (aka, comma)
  # For `a = 1, b = 2'

  ',': (n) -&gt;
    list = _.map n.children, (item) =&gt; @build(item) + "\n"
    list.join('')
  # `regexp`
  # Regular expressions.

  'regexp': (n) -&gt;
    m     = n.value.toString().match(/^\/(.*)\/([a-z]?)/)
    value = m[1]
    flag  = m[2]

    # **Caveat:**
    # *If it begins with `=` or a space, the CoffeeScript parser will choke if
    # it's written as `/=/`. Hence, they are written as `new RegExp('=')`.*

    begins_with = value[0]

    if begins_with in [' ', '=']
      if flag.length &gt; 0
        "RegExp(#{strEscape value}, \"#{flag}\")"
      else
        "RegExp(#{strEscape value})"
    else
      "/#{value}/#{flag}"
  'string': (n) -&gt;
    strEscape n.value
  # `call`
  # A Function call.
  # `n.left` is an `id`, and `n.right` is a `list`.

  'call': (n) -&gt;
    if n.right().children.length == 0
      "#{@build n.left()}()"
    else
      "#{@build n.left()}(#{@build n.right()})"
  # `call_statement`
  # A `call` that's on it's own line.

  'call_statement': (n) -&gt;
    left = @build n.left()

    # **Caveat:**
    # *When calling in this way: `function () { ... }()`,
    # ensure that there are parenthesis around the anon function
    # (eg, `(-&gt; ...)()`).*

    left = paren(left)  if n.left().isA('function')

    if n.right().children.length == 0
      "#{left}()"
    else
      "#{left} #{@build n.right()}"
  # `list`
  # A parameter list.

  'list': (n) -&gt;
    list = _.map(n.children, (item) =&gt;
      if n.children.length &gt; 1
        item.is_list_element = true
      @build(item))

    list.join(", ")
  'delete': (n) -&gt;
    ids = _.map(n.children, (el) =&gt; @build(el))
    ids = ids.join(', ')
    "delete #{ids}\n"
  # `.` (scope resolution?)
  # For instances such as `object.value`.

  '.': (n) -&gt;
    # **Caveat:**
    # *If called as `this.xxx`, it should use the at sign (`n.xxx`).*

    # **Caveat:**
    # *If called as `x.prototype`, it should use double colons (`x::`).*

    left  = @build n.left()
    right_obj = n.right()
    right_obj.property_accessor = true
    right = @build right_obj

    if n.isThis and n.isPrototype
      "@::"
    else if n.isThis
      "@#{right}"
    else if n.isPrototype
      "#{left}::"
    else if n.left().isPrototype
      "#{left}#{right}"
    else
      "#{left}.#{right}"
  'try': (n) -&gt;
    c = new Code
    c.add 'try'
    c.scope @body(n.tryBlock)

    _.each n.catchClauses, (clause) =&gt;
      c.add @build(clause)

    if n.finallyBlock?
      c.add "finally"
      c.scope @body(n.finallyBlock)

    c
  'catch': (n) -&gt;
    body_ = @body(n.block)
    return '' if trim(body_).length == 0

    c = new Code

    if n.varName?
      c.add "catch #{n.varName}"
    else
      c.add 'catch'

    c.scope @body(n.block)
    c
  # `?` (ternary operator)
  # For `a ? b : c`. Note that these will always be parenthesized, as (I
  # believe) the order of operations in JS is different in CS.

  '?': (n) -&gt;
    "(if #{@build n.left()} then #{@build n.children[1]} else #{@build n.children[2]})"
  'for': (n) -&gt;
    c = new Code

    if n.setup?
      c.add "#{@build n.setup}\n"

    if n.condition?
      c.add "while #{@build n.condition}\n"
    else
      c.add "loop"

    c.scope @body(n.body)
    c.scope @body(n.update)  if n.update?
    c
  'for_in': (n) -&gt;
    c = new Code

    c.add "for #{@build n.iterator} of #{@build n.object}"
    c.scope @body(n.body)
    c
  'while': (n) -&gt;
    c = new Code

    keyword   = if n.positive then "while" else "until"
    body_     = @body(n.body)

    # *Use `loop` whin something will go on forever (like `while (true)`).*
    if truthy(n.condition)
      statement = "loop"
    else
      statement = "#{keyword} #{@build n.condition}"

    if isSingleLine(body_) and statement isnt "loop"
      c.add "#{trim body_}  #{statement}\n"
    else
      c.add statement
      c.scope body_
    c
  'do': (n) -&gt;
    c = new Code

    c.add "loop"
    c.scope @body(n.body)
    c.scope "break unless #{@build n.condition}"  if n.condition?

    c
  'if': (n) -&gt;
    c = new Code

    keyword = if n.positive then "if" else "unless"
    body_   = @body(n.thenPart)
    n.condition.parenthesized = false

    # *Account for `if (xyz) {}`, which should be `xyz`. (#78)*
    # *Note that `!xyz` still compiles to `xyz` because the `!` will not change anything.*
    if n.thenPart.isA('block') and n.thenPart.children.length == 0 and !n.elsePart?
      console.log n.thenPart
      c.add "#{@build n.condition}\n"

    else if isSingleLine(body_) and !n.elsePart?
      c.add "#{trim body_}  #{keyword} #{@build n.condition}\n"

    else
      c.add "#{keyword} #{@build n.condition}"
      c.scope @body(n.thenPart)

      if n.elsePart?
        if n.elsePart.typeName() == 'if'
          c.add "else #{@build(n.elsePart).toString()}"
        else
          c.add "else\n"
          c.scope @body(n.elsePart)

    c
  'switch': (n) -&gt;
    c = new Code

    c.add "switch #{@build n.discriminant}\n"

    fall_through = false
    _.each n.cases, (item) =&gt;
      if item.value == 'default'
        c.scope "else"
      else
        if fall_through == true
          c.add ", #{@build item.caseLabel}\n"
        else
          c.add "  when #{@build item.caseLabel}"
          
      if @body(item.statements).length == 0
        fall_through = true
      else
        fall_through = false
        c.add "\n"
        c.scope @body(item.statements), 2

      first = false

    c
  'existence_check': (n) -&gt;
    "#{@build n.left()}?"
  'array_init': (n) -&gt;
    if n.children.length == 0
      "[]"
    else
      "[ #{@list n} ]"
  # `property_init`
  # Belongs to `object_init`;
  # left is a `identifier`, right can be anything.

  'property_init': (n) -&gt;
    left = n.left()
    right = n.right()
    right.is_property_value = true
    "#{@property_identifier left}: #{@build right}"
  # `object_init`
  # An object initializer.
  # Has many `property_init`.

  'object_init': (n, options={}) -&gt;
    if n.children.length == 0
      "{}"

    else if n.children.length == 1 and not (n.is_property_value or n.is_list_element)
      @build n.children[0]

    else
      list = _.map n.children, (item) =&gt; @build item

      c = new Code
      c.scope list.join("\n")
      c = "{#{c}}"  if options.brackets?
      c
  # `function`
  # A function. Can be an anonymous function (`function () { .. }`), or a named
  # function (`function name() { .. }`).

  'function': (n) -&gt;
    c = new Code

    params = _.map n.params, (str) =&gt;
      if str.constructor == String
        @id_param str
      else
        @build str

    if n.name
      c.add "#{n.name} = "

    if n.params.length &gt; 0
      c.add "(#{params.join ', '}) -&gt;"
    else
      c.add "-&gt;"

    body = @body(n.body)
    if trim(body).length &gt; 0
      c.scope body
    else
      c.add "\n"

    c
  'var': (n) -&gt;
    list = _.map n.children, (item) =&gt;
      "#{unreserve item.value} = #{if item.initializer? then @build(item.initializer) else 'undefined'}"

    _.compact(list).join("\n") + "\n"
  # ### Unsupported things
  #
  # Due to CoffeeScript limitations, the following things are not supported:
  #
  #  * New getter/setter syntax (`x.prototype = { get name() { ... } };`)
  #  * Break labels (`my_label: ...`)
  #  * Constants

  'other': (n) -&gt;   @unsupported n, "#{n.typeName()} is not supported yet"
  'getter': (n) -&gt;  @unsupported n, "getter syntax is not supported; use __defineGetter__"
  'setter': (n) -&gt;  @unsupported n, "setter syntax is not supported; use __defineSetter__"
  'label': (n) -&gt;   @unsupported n, "labels are not supported by CoffeeScript"
  'const': (n) -&gt;   @unsupported n, "consts are not supported by CoffeeScript"
  'block': (args...) -&gt;
    @script.apply @, args
  # `unsupported()`
  # Throws an unsupported error.
  'unsupported': (node, message) -&gt;
    throw new UnsupportedError("Unsupported: #{message}", node)
# ## AST manipulation
# Manipulation of the abstract syntax tree happens here. All these are done on
# the `build()` step, done just before a node is passed onto `Builders`.

class Transformer
  transform: (args...) -&gt;
    node = args[0]
    return  if node.transformed?
    type = node.typeName()
    fn = @[type]

    if fn
      fn.apply(this, args)
      node.transformed = true
  'script': (n) -&gt;
    n.functions    = []
    n.nonfunctions = []

    _.each n.children, (item) =&gt;
      if item.isA('function')
        n.functions.push item
      else
        n.nonfunctions.push item

    last = null

    # *Statements don't need parens, unless they are consecutive object
    # literals.*
    _.each n.nonfunctions, (item) =&gt;
      if item.expression?
        expr = item.expression

        if last?.isA('object_init') and expr.isA('object_init')
          item.parenthesized = true
        else
          item.parenthesized = false

        last = expr
  '.': (n) -&gt;
    n.isThis      = n.left().isA('this')
    n.isPrototype = (n.right().isA('identifier') and n.right().value == 'prototype')
  ';': (n) -&gt;
    if n.expression?
      # *Statements don't need parens.*
      n.expression.parenthesized = false

      # *If the statement only has one function call (eg, `alert(2);`), the
      # parentheses should be omitted (eg, `alert 2`).*
      if n.expression.isA('call')
        n.expression.type = Typenames['call_statement']
        @call_statement n
  'function': (n) -&gt;
    # *Unwrap the `return`s.*
    n.body.walk last: true, (parent, node, list) -&gt;
      if node.isA('return') and node.value
        # Hax
        lastNode = if list
          parent[list]
        else
          parent.children[parent.children.length-1]

        if lastNode
          lastNode.type = Typenames[';']
          lastNode.expression = lastNode.value
  'switch': (n) -&gt;
    _.each n.cases, (item) =&gt;
      block = item.statements
      ch    = block.children

      # *CoffeeScript does not need `break` statements on `switch` blocks.*
      delete ch[ch.length-1] if block.last()?.isA('break')
  'call_statement': (n) -&gt;
    if n.children[1]
      _.each n.children[1].children, (child, i) -&gt;
        if child.isA('function') and i != n.children[1].children.length-1
          child.parenthesized = true
  'return': (n) -&gt;
    # *Doing "return {x:2, y:3}" should parenthesize the return value.*
    if n.value and n.value.isA('object_init') and n.value.children.length &gt; 1
      n.value.parenthesized = true
  'block': (n) -&gt;
    @script n
  'if': (n) -&gt;
    # *Account for `if(x) {} else { something }` which should be `something unless x`.*
    if n.thenPart.children.length == 0 and n.elsePart?.children.length &gt; 0
      n.positive = false
      n.thenPart = n.elsePart
      delete n.elsePart

    @inversible n
  'while': (n) -&gt;
    # *A while with a blank body (`while(x){}`) should be accounted for.*
    # *You can't have empty blocks, so put a `continue` in there. (#78)*
    if n.body.children.length is 0
      n.body.children.push n.clone(type: Typenames['continue'], value: 'continue', children: [])

    @inversible n
  'inversible': (n) -&gt;
    @transform n.condition
    positive = if n.positive? then n.positive else true

    # *Invert a '!='. (`if (x != y)` =&gt; `unless x is y`)*
    if n.condition.isA('!=')
      n.condition.type = Typenames['==']
      n.positive = not positive

    # *Invert a '!'. (`if (!x)` =&gt; `unless x`)*
    else if n.condition.isA('!')
      n.condition = n.condition.left()
      n.positive = not positive

    else
      n.positive = positive
  '==': (n) -&gt;
    if n.right().isA('null', 'void')
      n.type     = Typenames['!']
      n.children = [n.clone(type: Typenames['existence_check'], children: [n.left()])]
  '!=': (n) -&gt;
    if n.right().isA('null', 'void')
      n.type     = Typenames['existence_check']
      n.children = [n.left()]
class UnsupportedError
  constructor: (str, src) -&gt;
    @message = str
    @cursor  = src.start
    @line    = src.lineno
    @source  = src.tokenizer.source
  toString: -&gt; @message

# ## Exports

@Js2coffee = exports =
  version: '0.1.3'
  build: buildCoffee
  UnsupportedError: UnsupportedError

module.exports = exports  if module?
'''
@color

table = (
    "buildCoffee = (str) -&gt;",
    "class Builder",
    "constructor: -&gt;",
    "build: (args...) -&gt;",
    "transform: (args...) -&gt;",
    "body: (node, opts={}) -&gt;",
    "'script': (n, opts={}) -&gt;",
    "'property_identifier': (n) -&gt;",
    "'identifier': (n) -&gt;",
    "'number': (n) -&gt;",
    "'id': (n) -&gt;",
    "'id_param': (n) -&gt;",
    "'return': (n) -&gt;",
    "';': (n) -&gt;",
    "'new': (n) -&gt; \"new #{@build n.left()}\"",
    "'new_with_args': (n) -&gt; \"new #{@build n.left()}(#{@build n.right()})\"",
    "'unary_plus': (n) -&gt; \"+#{@build n.left()}\"",
    "'unary_minus': (n) -&gt; \"-#{@build n.left()}\"",
    "'this': (n) -&gt; 'this'",
    "'null': (n) -&gt; 'null'",
    "'true': (n) -&gt; 'true'",
    "'false': (n) -&gt; 'false'",
    "'void': (n) -&gt; 'undefined'",
    "'debugger': (n) -&gt; \"debugger\\n\"",
    "'break': (n) -&gt; \"break\\n\"",
    "'continue': (n) -&gt; \"continue\\n\"",
    "'~': (n) -&gt; \"~#{@build n.left()}\"",
    "'typeof': (n) -&gt; \"typeof #{@build n.left()}\"",
    "'index': (n) -&gt;",
    "'throw': (n) -&gt; \"throw #{@build n.exception}\"",
    "'!': (n) -&gt;",
    "in: (n) -&gt;    @binary_operator n, 'of'",
    "'+': (n) -&gt;   @binary_operator n, '+'",
    "'-': (n) -&gt;   @binary_operator n, '-'",
    "'*': (n) -&gt;   @binary_operator n, '*'",
    "'/': (n) -&gt;   @binary_operator n, '/'",
    "'%': (n) -&gt;   @binary_operator n, '%'",
    "'&gt;': (n) -&gt;   @binary_operator n, '&gt;'",
    "'&lt;': (n) -&gt;   @binary_operator n, '&lt;'",
    "'&amp;': (n) -&gt;   @binary_operator n, '&amp;'",
    "'|': (n) -&gt;   @binary_operator n, '|'",
    "'^': (n) -&gt;   @binary_operator n, '^'",
    "'&amp;&amp;': (n) -&gt;  @binary_operator n, 'and'",
    "'||': (n) -&gt;  @binary_operator n, 'or'",
    "'&lt;&lt;': (n) -&gt;  @binary_operator n, '&lt;&lt;'",
    "'&lt;=': (n) -&gt;  @binary_operator n, '&lt;='",
    "'&gt;&gt;': (n) -&gt;  @binary_operator n, '&gt;&gt;'",
    "'&gt;=': (n) -&gt;  @binary_operator n, '&gt;='",
    "'===': (n) -&gt; @binary_operator n, 'is'",
    "'!==': (n) -&gt; @binary_operator n, 'isnt'",
    "'&gt;&gt;&gt;': (n) -&gt;  @binary_operator n, '&gt;&gt;&gt;'",
    "instanceof: (n) -&gt; @binary_operator n, 'instanceof'",
    "'==': (n) -&gt;",
    "'!=': (n) -&gt;",
    "'binary_operator': do -&gt;",
    "'--': (n) -&gt; @increment_decrement n, '--'",
    "'++': (n) -&gt; @increment_decrement n, '++'",
    "'increment_decrement': (n, sign) -&gt;",
    "'=': (n) -&gt;",
    "',': (n) -&gt;",
    "'regexp': (n) -&gt;",
    "'string': (n) -&gt;",
    "'call': (n) -&gt;",
    "'call_statement': (n) -&gt;",
    "'list': (n) -&gt;",
    "'delete': (n) -&gt;",
    "'.': (n) -&gt;",
    "'try': (n) -&gt;",
    "'catch': (n) -&gt;",
    "'?': (n) -&gt;",
    "'for': (n) -&gt;",
    "'for_in': (n) -&gt;",
    "'while': (n) -&gt;",
    "'do': (n) -&gt;",
    "'if': (n) -&gt;",
    "'switch': (n) -&gt;",
    "'existence_check': (n) -&gt;",
    "'array_init': (n) -&gt;",
    "'property_init': (n) -&gt;",
    "'object_init': (n, options={}) -&gt;",
    "'function': (n) -&gt;",
    "'var': (n) -&gt;",
    "'other': (n) -&gt;   @unsupported n, \"#{n.typeName()} is not supported yet\"",
    "'getter': (n) -&gt;  @unsupported n, \"getter syntax is not supported; use __defineGetter__\"",
    "'setter': (n) -&gt;  @unsupported n, \"setter syntax is not supported; use __defineSetter__\"",
    "'label': (n) -&gt;   @unsupported n, \"labels are not supported by CoffeeScript\"",
    "'const': (n) -&gt;   @unsupported n, \"consts are not supported by CoffeeScript\"",
    "'block': (args...) -&gt;",
    "'unsupported': (node, message) -&gt;",
    "class Transformer",
    "transform: (args...) -&gt;",
    "'script': (n) -&gt;",
    "'.': (n) -&gt;",
    "';': (n) -&gt;",
    "'function': (n) -&gt;",
    "n.body.walk last: true, (parent, node, list) -&gt;",
    "'switch': (n) -&gt;",
    "'call_statement': (n) -&gt;",
    "'return': (n) -&gt;",
    "'block': (n) -&gt;",
    "'if': (n) -&gt;",
    "'while': (n) -&gt;",
    "'inversible': (n) -&gt;",
    "'==': (n) -&gt;",
    "'!=': (n) -&gt;",
    "class UnsupportedError",
    "constructor: (str, src) -&gt;",
    "toString: -&gt; @message",
)

try:
    c.importCommands.coffeeScriptUnitTest(p,s=s,showTree=True)
    if 1:
      p2 = c.p.firstChild().firstChild()
      for h in table:
          assert p2.h == h, (p2.h, h)
          p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161109065940.1"># g.cls()
import leo.plugins.importers.linescanner as linescanner
# import imp
# imp.reload(linescanner)
lines_table = [
    'abc',
    '    xyz',
    '    ',
    '  # comment',
]
for language in ('python', 'coffeescript'):
    importer = linescanner.Importer(
        c.importCommands,
        language = language,
    )
    # print('%s %r' % (language, importer.comment_delim))
    assert importer.single_comment == '#', importer.single_comment
    for line in lines_table:
        lines = [line]
        n = importer.get_leading_indent(lines, 0)
        # print('%s %r' % (n, line))
</t>
<t tx="ekr.20161109065949.1"># g.cls()
import leo.plugins.importers.linescanner as linescanner
# import imp
# imp.reload(linescanner)
table = [
    (False, 'abc'),
    (False, '    xyz'),
    (True, '    '),
    (True,'  # comment'),
]
importer = linescanner.Importer(c.importCommands, language = 'python')
for val, s in table:
    assert val == importer.is_ws_line(s), (val, repr(s))
</t>
<t tx="ekr.20161109084732.1">s = r'''

# Js2coffee relies on Narcissus's parser.

{parser} = @Narcissus or require('./narcissus_packed')

# Main entry point

buildCoffee = (str) -&gt;
  str  = str.replace /\r/g, ''
  str += "\n"

  builder    = new Builder
  scriptNode = parser.parse str
'''
table = (
    'buildCoffee = (str) -&gt;',
)
try:
    c.importCommands.coffeeScriptUnitTest(p,s=s,showTree=True)
    if 1:
      p2 = c.p.firstChild().firstChild()
      for h in table:
          assert p2.h == h, (p2.h, h)
          p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161112061406.1">class TypeJoinVisitor(TypeVisitor[Type]):
    """Implementation of the least upper bound algorithm.

    Attributes:
      s: The other (left) type operand.
    """

    def __init__(self, s: Type) -&gt; None:
        self.s = s

    def visit_unbound_type(self, t: UnboundType) -&gt; Type:
        if isinstance(self.s, Void) or isinstance(self.s, ErrorType):
            return ErrorType()
        else:
            return AnyType()

    def visit_union_type(self, t: UnionType) -&gt; Type:
        if is_subtype(self.s, t):
            return t
        else:
            return UnionType(t.items + [self.s])

    def visit_error_type(self, t: ErrorType) -&gt; Type:
        return t

    def visit_type_list(self, t: TypeList) -&gt; Type:
        assert False, 'Not supported'

    def visit_any(self, t: AnyType) -&gt; Type:
        return t

    def visit_void(self, t: Void) -&gt; Type:
        if isinstance(self.s, Void):
            return t
        else:
            return ErrorType()

    def visit_none_type(self, t: NoneTyp) -&gt; Type:
        if not isinstance(self.s, Void):
            return self.s
        else:
            return self.default(self.s)

    def visit_erased_type(self, t: ErasedType) -&gt; Type:
        return self.s

    def visit_type_var(self, t: TypeVarType) -&gt; Type:
        if isinstance(self.s, TypeVarType) and (cast(TypeVarType, self.s)).id == t.id:
            return self.s
        else:
            return self.default(self.s)

    def visit_instance(self, t: Instance) -&gt; Type:
        if isinstance(self.s, Instance):
            return join_instances(t, cast(Instance, self.s))
        elif isinstance(self.s, FunctionLike):
            return join_types(t, self.s.fallback)
        else:
            return self.default(self.s)

    def visit_callable_type(self, t: CallableType) -&gt; Type:
        # TODO: Consider subtyping instead of just similarity.
        if isinstance(self.s, CallableType) and is_similar_callables(
                t, cast(CallableType, self.s)):
            return combine_similar_callables(t, cast(CallableType, self.s))
        elif isinstance(self.s, Overloaded):
            # Switch the order of arguments to that we'll get to visit_overloaded.
            return join_types(t, self.s)
        else:
            return join_types(t.fallback, self.s)

    def visit_overloaded(self, t: Overloaded) -&gt; Type:
        # This is more complex than most other cases. Here are some
        # examples that illustrate how this works.
        #
        # First let's define a concise notation:
        #  - Cn are callable types (for n in 1, 2, ...)
        #  - Ov(C1, C2, ...) is an overloaded type with items C1, C2, ...
        #  - Callable[[T, ...], S] is written as [T, ...] -&gt; S.
        #
        # We want some basic properties to hold (assume Cn are all
        # unrelated via Any-similarity):
        #
        #   join(Ov(C1, C2), C1) == C1
        #   join(Ov(C1, C2), Ov(C1, C2)) == Ov(C1, C2)
        #   join(Ov(C1, C2), Ov(C1, C3)) == C1
        #   join(Ov(C2, C2), C3) == join of fallback types
        #
        # The presence of Any types makes things more interesting. The join is the
        # most general type we can get with respect to Any:
        #
        #   join(Ov([int] -&gt; int, [str] -&gt; str), [Any] -&gt; str) == Any -&gt; str
        #
        # We could use a simplification step that removes redundancies, but that's not
        # implemented right now. Consider this example, where we get a redundancy:
        #
        #   join(Ov([int, Any] -&gt; Any, [str, Any] -&gt; Any), [Any, int] -&gt; Any) ==
        #       Ov([Any, int] -&gt; Any, [Any, int] -&gt; Any)
        #
        # TODO: Use callable subtyping instead of just similarity.
        result = []  # type: List[CallableType]
        s = self.s
        if isinstance(s, FunctionLike):
            # The interesting case where both types are function types.
            for t_item in t.items():
                for s_item in s.items():
                    if is_similar_callables(t_item, s_item):
                        result.append(combine_similar_callables(t_item, s_item))
            if result:
                # TODO: Simplify redundancies from the result.
                if len(result) == 1:
                    return result[0]
                else:
                    return Overloaded(result)
            return join_types(t.fallback, s.fallback)
        return join_types(t.fallback, s)

    def visit_tuple_type(self, t: TupleType) -&gt; Type:
        if (isinstance(self.s, TupleType) and
                cast(TupleType, self.s).length() == t.length()):
            items = []  # type: List[Type]
            for i in range(t.length()):
                items.append(self.join(t.items[i],
                                       (cast(TupleType, self.s)).items[i]))
            # TODO: What if the fallback types are different?
            return TupleType(items, t.fallback)
        else:
            return self.default(self.s)

    def join(self, s: Type, t: Type) -&gt; Type:
        return join_types(s, t)

    def default(self, typ: Type) -&gt; Type:
        if isinstance(typ, Instance):
            return object_from_instance(typ)
        elif isinstance(typ, UnboundType):
            return AnyType()
        elif isinstance(typ, Void) or isinstance(typ, ErrorType):
            return ErrorType()
        elif isinstance(typ, TupleType):
            return self.default(typ.fallback)
        elif isinstance(typ, FunctionLike):
            return self.default(typ.fallback)
        elif isinstance(typ, TypeVarType):
            return self.default(typ.upper_bound)
        else:
            return AnyType()
</t>
<t tx="ekr.20161112061414.1">class aClass:
    @others
</t>
<t tx="ekr.20161112061414.2">def __init__(self):
    pass
</t>
<t tx="ekr.20161112061414.3">def spam(self):
    pass
</t>
<t tx="ekr.20161112061414.4">bClass = aClass
</t>
<t tx="ekr.20161115063144.10">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
class aClass:
    def outerDef(self):
        """docstring.
        line two."""

        def pr(*args,**keys):
            g.es_print(color='blue',*args,**keys)

        a = 3
'''
table = (
    (1, 'class aClass'),
    (2, 'outerDef'),
    # (3, 'pr'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.11">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\

class test:

    def importFilesCommand (self,files=None,treeType=None,
        perfectImport=True,testing=False,verbose=False):
            # Not a command.  It must *not* have an event arg.

        c = self.c
        if c == None: return
        p = c.currentPosition()

    # Used by paste logic.

    def convertMoreStringToOutlineAfter (self,s,firstVnode):
        s = string.replace(s,"\\r","")
        strings = string.split(s,"\\n")
        return self.convertMoreStringsToOutlineAfter(strings,firstVnode)
'''
table = (
    (1, 'class test'),
    (2, 'importFilesCommand'),
    (2, 'convertMoreStringToOutlineAfter'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        root.doDelete()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.12">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\

class test:
    def spam(b):
        pass

    # Used by paste logic.

    def foo(a):
        pass
'''
table = (
    (1, 'class test'),
    (2, 'spam'),
    (2, 'foo'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.13">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
"""A file consisting only of a docstring.
"""
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.14">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
import leo.core.leoGlobals as g

a = 3
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.15">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class cls:
     def fun(): # one extra space.
        pass
'''


c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.16">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\

class mammalProviderBase(object):
    """Root class for content providers used by DWEtree.py"""
    def __init__(self, params):
        """store reference to parameters"""
        self.params = params
    def provide(self, what):
        """default &lt;BASE&gt; value"""
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/'])
        return None

    def imagePath(self, sppdat):
        """return path to images and list of images for *species*"""
        path = 'MNMammals/imglib/Mammalia'
        for i in 'Order', 'Family', 'Genus', 'Species':
            path = os.path.join(path, sppdat['%sName' % (i,)])
        imglib = os.path.join('/var/www',path)
        imglib = os.path.join(imglib, '*.[Jj][Pp][Gg]')
        path = os.path.join('/',path)
        lst = [os.path.split(i)[1] for i in glob.glob(imglib)]
        lst.sort()
        return path, lst

class mainPages(mammalProviderBase):
    """provide content for pages in 'main' folder"""
    __parent = mammalProviderBase
    def provide(self, what):
        """add one layer to &lt;BASE&gt;"""
        ans = self.__parent.provide(self, what)
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/']+'main/')
        return ans
''' 
table = (
    (1, 'class mammalProviderBase'),
    (2, '__init__'),
    (2, 'provide'),
    (2, 'imagePath'),
    (1, 'class mainPages'),
    (2, 'provide'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.18"># ~/at-auto-test.py

# Careful: don't put a section reference in the string.
s = '''\
# This is valid Python, but it looks like a section reference.
a = b &lt; &lt; c &gt; &gt; d
'''.replace('&gt; &gt;', '&gt;&gt;').replace('&lt; &lt;', '&lt;&lt;')

c.importCommands.pythonUnitTest(p,s=s,showTree=False)

</t>
<t tx="ekr.20161115063144.19">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class ItasException(Exception):

    pass

def gpRun(gp, cmd, args, log = None):

    """Wrapper for making calls to the geoprocessor and reporting errors"""

    if log:

        log('gp: %s: %s\\n' % (cmd, str(args)))
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)


</t>
<t tx="ekr.20161115063144.20">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class emptyClass: pass

def followingDef():
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.21">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

class emptyClass: pass # comment

def followingDef(): # comment
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.22">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class aClass:
    def def1(self):
        pass

    if False or g.unitTesting:

        def pr(*args,**keys): # reportMismatch test
            g.es_print(color='blue',*args,**keys)

        pr('input...')
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.23">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class aClass:
    def def1(self):
        pass

    if False or g.unitTesting:

        def pr(*args,**keys): # reportMismatch test
            g.es_print(color='blue',*args,**keys)

        pr('input...')

    def def2(self):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.24">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
# This caused PyParse.py not to be imported properly.
s = r'''
import re
if 0: # Causes the 'overindent'
   if 0:   # for throwaway debugging output
      def dump(*stuff):
        sys.__stdout__.write(" ".join(map(str, stuff)) + "\n")
for ch in "({[":
   _tran[ord(ch)] = '('
class testClass1:
    pass
'''
table = (
    (1, 'Declarations'),
    (1, 'class testClass1'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.25">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class BaseScanner:

        """The base class for all import scanner classes."""

        def __init__ (self,importCommands,language):

            self.c = ic.c

        def createHeadline (self,parent,body,headline):
            # g.trace("parent,headline:",parent,headline)
            return p
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.26">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class BaseScanner:
    def containsUnderindentedComment(self):
        a = 2
    # A true underindented comment.
        b = 3
    # This underindented comment should be placed with next function.
    def empty(self):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.27">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class BaseScanner:
    def containsUnderindentedComment(self):
        a = 2
    #
        b = 3
        # This comment is part of the present function.

    def empty(self):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.28">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class aClass: # trailing comment


    def def1(self):             # trailing comment
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.29">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

xyz = 6 # trailing comment
pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.3">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class testClass1 # no colon
    pass

def spam():
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.30"># For comparison with unindent does not end function.

@tabwidth -4
    # Required when running unit tests externally.

s = '''\

def foo():
    pass

def bar():
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.31">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\

class emptyClass: 

    def spam():
        """docstring line 1
under-indented docstring line"""
        pass

def followingDef(): # comment
    pass
'''
table = (
    (1, 'class emptyClass'),
    (2, 'spam'),
    (1, 'followingDef'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.32">@tabwidth -4
    # Required when running unit tests externally.

s = '''\

def foo():

    error("""line1
line2.
""")

    a = 5

def bar():
    pass
'''

showTree = False
keepTree = False

c.importCommands.pythonUnitTest(p,s=s,showTree=showTree)

if showTree:
    try:
        child = p.firstChild()
        n = child.numberOfChildren()
        assert n == 2, 'expected 2 children, got %s' % n
    finally:
        if keepTree:
            # h = child.h
            # print('h',h)
            child.setHeadString('@'+h)
        else:
            while p.hasChildren():
                p.firstChild().doDelete()
        c.redraw(p)
</t>
<t tx="ekr.20161115063144.33">@killcolor

s = '''\

"""Generic output formatting.
"""

import sys


AS_IS = None


class NullFormatter:
    """A formatter which does nothing.

    If the writer parameter is omitted, a NullWriter instance is created.
    No methods of the writer are called by NullFormatter instances.

    Implementations should inherit from this class if implementing a writer
    interface but don't need to inherit any implementation.

    """

    def __init__(self, writer=None):
        if writer is None:
            writer = NullWriter()
        self.writer = writer
    def end_paragraph(self, blankline): pass
    def add_line_break(self): pass
    def add_hor_rule(self, *args, **kw): pass
    def add_label_data(self, format, counter, blankline=None): pass
    def add_flowing_data(self, data): pass
    def add_literal_data(self, data): pass
    def flush_softspace(self): pass
    def push_alignment(self, align): pass
    def pop_alignment(self): pass
    def push_font(self, x): pass
    def pop_font(self): pass
    def push_margin(self, margin): pass
    def pop_margin(self): pass
    def set_spacing(self, spacing): pass
    def push_style(self, *styles): pass
    def pop_style(self, n=1): pass
    def assert_line_data(self, flag=1): pass


class AbstractFormatter:
    """The standard formatter.

    This implementation has demonstrated wide applicability to many writers,
    and may be used directly in most circumstances.  It has been used to
    implement a full-featured World Wide Web browser.

    """

    #  Space handling policy:  blank spaces at the boundary between elements
    #  are handled by the outermost context.  "Literal" data is not checked
    #  to determine context, so spaces in literal data are handled directly
    #  in all circumstances.

    def __init__(self, writer):
        self.writer = writer            # Output device
        self.align = None               # Current alignment
        self.align_stack = []           # Alignment stack
        self.font_stack = []            # Font state
        self.margin_stack = []          # Margin state
        self.spacing = None             # Vertical spacing state
        self.style_stack = []           # Other state, e.g. color
        self.nospace = 1                # Should leading space be suppressed
        self.softspace = 0              # Should a space be inserted
        self.para_end = 1               # Just ended a paragraph
        self.parskip = 0                # Skipped space between paragraphs?
        self.hard_break = 1             # Have a hard break
        self.have_label = 0

    def end_paragraph(self, blankline):
        if not self.hard_break:
            self.writer.send_line_break()
            self.have_label = 0
        if self.parskip &lt; blankline and not self.have_label:
            self.writer.send_paragraph(blankline - self.parskip)
            self.parskip = blankline
            self.have_label = 0
        self.hard_break = self.nospace = self.para_end = 1
        self.softspace = 0

    def add_line_break(self):
        if not (self.hard_break or self.para_end):
            self.writer.send_line_break()
            self.have_label = self.parskip = 0
        self.hard_break = self.nospace = 1
        self.softspace = 0

    def add_hor_rule(self, *args, **kw):
        if not self.hard_break:
            self.writer.send_line_break()
        self.writer.send_hor_rule(*args, **kw)
        self.hard_break = self.nospace = 1
        self.have_label = self.para_end = self.softspace = self.parskip = 0

    def add_label_data(self, format, counter, blankline = None):
        if self.have_label or not self.hard_break:
            self.writer.send_line_break()
        if not self.para_end:
            self.writer.send_paragraph((blankline and 1) or 0)
        if isinstance(format, str):
            self.writer.send_label_data(self.format_counter(format, counter))
        else:
            self.writer.send_label_data(format)
        self.nospace = self.have_label = self.hard_break = self.para_end = 1
        self.softspace = self.parskip = 0

    def format_counter(self, format, counter):
        label = ''
        for c in format:
            if c == '1':
                label = label + ('%d' % counter)
            elif c in 'aA':
                if counter &gt; 0:
                    label = label + self.format_letter(c, counter)
            elif c in 'iI':
                if counter &gt; 0:
                    label = label + self.format_roman(c, counter)
            else:
                label = label + c
        return label

    def format_letter(self, case, counter):
        label = ''
        while counter &gt; 0:
            counter, x = divmod(counter-1, 26)
            # This makes a strong assumption that lowercase letters
            # and uppercase letters form two contiguous blocks, with
            # letters in order!
            s = chr(ord(case) + x)
            label = s + label
        return label

    def format_roman(self, case, counter):
        ones = ['i', 'x', 'c', 'm']
        fives = ['v', 'l', 'd']
        label, index = '', 0
        # This will die of IndexError when counter is too big
        while counter &gt; 0:
            counter, x = divmod(counter, 10)
            if x == 9:
                label = ones[index] + ones[index+1] + label
            elif x == 4:
                label = ones[index] + fives[index] + label
            else:
                if x &gt;= 5:
                    s = fives[index]
                    x = x-5
                else:
                    s = ''
                s = s + ones[index]*x
                label = s + label
            index = index + 1
        if case == 'I':
            return label.upper()
        return label

    def add_flowing_data(self, data):
        if not data: return
        # The following looks a bit convoluted but is a great improvement over
        # data = regsub.gsub('[' + string.whitespace + ']+', ' ', data)
        prespace = data[:1].isspace()
        postspace = data[-1:].isspace()
        data = " ".join(data.split())
        if self.nospace and not data:
            return
        elif prespace or self.softspace:
            if not data:
                if not self.nospace:
                    self.softspace = 1
                    self.parskip = 0
                return
            if not self.nospace:
                data = ' ' + data
        self.hard_break = self.nospace = self.para_end = \
                          self.parskip = self.have_label = 0
        self.softspace = postspace
        self.writer.send_flowing_data(data)

    def add_literal_data(self, data):
        if not data: return
        if self.softspace:
            self.writer.send_flowing_data(" ")
        self.hard_break = data[-1:] == '\n'
        self.nospace = self.para_end = self.softspace = \
                       self.parskip = self.have_label = 0
        self.writer.send_literal_data(data)

    def flush_softspace(self):
        if self.softspace:
            self.hard_break = self.para_end = self.parskip = \
                              self.have_label = self.softspace = 0
            self.nospace = 1
            self.writer.send_flowing_data(' ')

    def push_alignment(self, align):
        if align and align != self.align:
            self.writer.new_alignment(align)
            self.align = align
            self.align_stack.append(align)
        else:
            self.align_stack.append(self.align)

    def pop_alignment(self):
        if self.align_stack:
            del self.align_stack[-1]
        if self.align_stack:
            self.align = align = self.align_stack[-1]
            self.writer.new_alignment(align)
        else:
            self.align = None
            self.writer.new_alignment(None)

    def push_font(self, (size, i, b, tt)):
        if self.softspace:
            self.hard_break = self.para_end = self.softspace = 0
            self.nospace = 1
            self.writer.send_flowing_data(' ')
        if self.font_stack:
            csize, ci, cb, ctt = self.font_stack[-1]
            if size is AS_IS: size = csize
            if i is AS_IS: i = ci
            if b is AS_IS: b = cb
            if tt is AS_IS: tt = ctt
        font = (size, i, b, tt)
        self.font_stack.append(font)
        self.writer.new_font(font)

    def pop_font(self):
        if self.font_stack:
            del self.font_stack[-1]
        if self.font_stack:
            font = self.font_stack[-1]
        else:
            font = None
        self.writer.new_font(font)

    def push_margin(self, margin):
        self.margin_stack.append(margin)
        fstack = filter(None, self.margin_stack)
        if not margin and fstack:
            margin = fstack[-1]
        self.writer.new_margin(margin, len(fstack))

    def pop_margin(self):
        if self.margin_stack:
            del self.margin_stack[-1]
        fstack = filter(None, self.margin_stack)
        if fstack:
            margin = fstack[-1]
        else:
            margin = None
        self.writer.new_margin(margin, len(fstack))

    def set_spacing(self, spacing):
        self.spacing = spacing
        self.writer.new_spacing(spacing)

    def push_style(self, *styles):
        if self.softspace:
            self.hard_break = self.para_end = self.softspace = 0
            self.nospace = 1
            self.writer.send_flowing_data(' ')
        for style in styles:
            self.style_stack.append(style)
        self.writer.new_styles(tuple(self.style_stack))

    def pop_style(self, n=1):
        del self.style_stack[-n:]
        self.writer.new_styles(tuple(self.style_stack))

    def assert_line_data(self, flag=1):
        self.nospace = self.hard_break = not flag
        self.para_end = self.parskip = self.have_label = 0


class NullWriter:
    """Minimal writer interface to use in testing &amp; inheritance.

    A writer which only provides the interface definition; no actions are
    taken on any methods.  This should be the base class for all writers
    which do not need to inherit any implementation methods.

    """
    def __init__(self): pass
    def flush(self): pass
    def new_alignment(self, align): pass
    def new_font(self, font): pass
    def new_margin(self, margin, level): pass
    def new_spacing(self, spacing): pass
    def new_styles(self, styles): pass
    def send_paragraph(self, blankline): pass
    def send_line_break(self): pass
    def send_hor_rule(self, *args, **kw): pass
    def send_label_data(self, data): pass
    def send_flowing_data(self, data): pass
    def send_literal_data(self, data): pass


class AbstractWriter(NullWriter):
    """A writer which can be used in debugging formatters, but not much else.

    Each method simply announces itself by printing its name and
    arguments on standard output.

    """

    def new_alignment(self, align):
        print "new_alignment(%s)" % `align`

    def new_font(self, font):
        print "new_font(%s)" % `font`

    def new_margin(self, margin, level):
        print "new_margin(%s, %d)" % (`margin`, level)

    def new_spacing(self, spacing):
        print "new_spacing(%s)" % `spacing`

    def new_styles(self, styles):
        print "new_styles(%s)" % `styles`

    def send_paragraph(self, blankline):
        print "send_paragraph(%s)" % `blankline`

    def send_line_break(self):
        print "send_line_break()"

    def send_hor_rule(self, *args, **kw):
        print "send_hor_rule()"

    def send_label_data(self, data):
        print "send_label_data(%s)" % `data`

    def send_flowing_data(self, data):
        print "send_flowing_data(%s)" % `data`

    def send_literal_data(self, data):
        print "send_literal_data(%s)" % `data`


class DumbWriter(NullWriter):
    """Simple writer class which writes output on the file object passed in
    as the file parameter or, if file is omitted, on standard output.  The
    output is simply word-wrapped to the number of columns specified by
    the maxcol parameter.  This class is suitable for reflowing a sequence
    of paragraphs.

    """

    def __init__(self, file=None, maxcol=72):
        self.file = file or sys.stdout
        self.maxcol = maxcol
        NullWriter.__init__(self)
        self.reset()

    def reset(self):
        self.col = 0
        self.atbreak = 0

    def send_paragraph(self, blankline):
        self.file.write('\n'*blankline)
        self.col = 0
        self.atbreak = 0

    def send_line_break(self):
        self.file.write('\n')
        self.col = 0
        self.atbreak = 0

    def send_hor_rule(self, *args, **kw):
        self.file.write('\n')
        self.file.write('-'*self.maxcol)
        self.file.write('\n')
        self.col = 0
        self.atbreak = 0

    def send_literal_data(self, data):
        self.file.write(data)
        i = data.rfind('\n')
        if i &gt;= 0:
            self.col = 0
            data = data[i+1:]
        data = data.expandtabs()
        self.col = self.col + len(data)
        self.atbreak = 0

    def send_flowing_data(self, data):
        if not data: return
        atbreak = self.atbreak or data[0].isspace()
        col = self.col
        maxcol = self.maxcol
        write = self.file.write
        for word in data.split():
            if atbreak:
                if col + len(word) &gt;= maxcol:
                    write('\n')
                    col = 0
                else:
                    write(' ')
                    col = col + 1
            write(word)
            col = col + len(word)
            atbreak = 1
        self.col = col
        self.atbreak = data[-1].isspace()


def test(file = None):
    w = DumbWriter()
    f = AbstractFormatter(w)
    if file is not None:
        fp = open(file)
    elif sys.argv[1:]:
        fp = open(sys.argv[1])
    else:
        fp = sys.stdin
    while 1:
        line = fp.readline()
        if not line:
            break
        if line == '\n':
            f.end_paragraph(1)
        else:
            f.add_flowing_data(line)
    f.end_paragraph(0)


if __name__ == '__main__':
    test()
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.34"># Was unittest/at_auto-unit-test.py
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
class class1:
    def class1_method1():
        pass
    def class1_method2():
        pass
    # After @others in child1.
class class2:
    def class2_method1():
        pass
    def class2_method2():
        pass
# last line
'''
table = (
    (1, 'class class1'),
    (2, 'class1_method1'),
    (2, 'class1_method2'),
    (1, 'class class2'),
    (2, 'class2_method1'),
    (2, 'class2_method2'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()

</t>
<t tx="ekr.20161115063144.4">@tabwidth -4
    # Required when running unit tests externally.

# Leo bug 603720
# Within the docstring we must change '\' to '\\'
s = '''\
def foo():
    s = \\
"""#!/bin/bash
cd /tmp
ls"""
    file('/tmp/script', 'w').write(s)

class bar:
    pass

foo()
'''

tree = c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.5">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class testClass2:
    pass
'''

tree = c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.6">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class testClass1:
    """A docstring"""
    def __init__ (self):
        pass
    def f1(self):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20161115063144.7">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
NS = { 'i': 'http://www.inkscape.org/namespaces/inkscape',
      's': 'http://www.w3.org/2000/svg',
      'xlink' : 'http://www.w3.org/1999/xlink'}

tabLevels = 4  # number of defined tablevels, FIXME, could derive from template?
'''
table = (
    (1, 'Declarations'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.8">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
import leo.core.leoGlobals as g

a = 3
'''
table = (
    (1, 'Declarations'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.9">@tabwidth -4
    # Required when running unit tests externally.

s = '''\
class Index:
    """docstring"""
    @cherrypy.nocolor
    @cherrypy.expose
    def index(self):
        return "Hello world!"
        
    @cmd('abc')
    def abc(self):
        return "abc"
'''

try:
    c.importCommands.pythonUnitTest(p,s=s,showTree=True) # Must be true.
    index = g.findNodeInTree(c, p, 'index')
    assert index
    lines = g.splitLines(index.b)
    assert lines[0] == '@cherrypy.nocolor\n', repr(lines[0])
    assert lines[1] == '@cherrypy.expose\n', repr(lines[1])
    abc = g.findNodeInTree(c,p, 'abc')
    lines = g.splitLines(abc.b)
    assert lines[0] == "@cmd('abc')\n", repr(lines[0])
    if 1:
        p.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115092708.1"># g.cls()
import leo.plugins.importers.python as python
# import imp
# imp.reload(python)
# A list of dictionaries.
if 0:
    tests = [
        # g.Bunch(line='s = "\\""', ctx=('', '')),
        g.Bunch(line='\\\n'),
    ]
else:
    tests = [
        g.Bunch(line='\n'),
        g.Bunch(line='\\\n'),
        g.Bunch(line='s = "\\""', ctx=('', '')), # empty string.
        g.Bunch(line="s = '\\''", ctx=('', '')), # empty string.
        g.Bunch(line='# comment'),
        g.Bunch(line='  # comment'),
        g.Bunch(line='    # comment'),
        g.Bunch(line='a = "string"'),
        g.Bunch(line='a = "Continued string', ctx=('', '"')),
        g.Bunch(line='end of continued string"', ctx=('"', '')),
        g.Bunch(line='a = """Continued docstring', ctx=('', '"""')),
        g.Bunch(line='a = """#', ctx=('', '"""')),
        g.Bunch(line='end of continued string"""', ctx=('"""', '')),
        g.Bunch(line="a = '''Continued docstring", ctx=('', "'''")),
        g.Bunch(line="end of continued string'''", ctx=("'''", '')),
        g.Bunch(line='a = {[(')
    ]
if hasattr(python, 'Py_Importer'):
    importer = python.Py_Importer(c.importCommands)
    importer.test_scan_state(tests, State=python.Python_ScanState)
else:
    self.skipTest('Skipping test for new python importer')
</t>
<t tx="ekr.20161117000902.1">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = """\
# -*- coding: utf-8 -*-
import leo.core.leoGlobals as g
class LeoImportCommands(object):
    '''A class implementing all of Leo's import/export code.'''
    def createOutline(self, fileName, parent, s=None, ext=None):
        '''Create an outline by importing a file or string.'''

    def dispatch(self, ext, p):
        '''Return the correct scanner function for p, an @auto node.'''
        # Match the @auto type first, then the file extension.
        return self.scanner_for_at_auto(p) or self.scanner_for_ext(ext)
    def scanner_for_at_auto(self, p):
        '''A factory returning a scanner function for p, an @auto node.'''
        d = self.atAutoDict
        for key in d.keys():
            aClass = d.get(key)
            if aClass and g.match_word(p.h, 0, key):
                if trace: g.trace('found', aClass.__name__)

                def scanner_for_at_auto_cb(parent, s, prepass=False):
                    try:
                        scanner = aClass(importCommands=self)
                        return scanner.run(s, parent, prepass=prepass)
                    except Exception:
                        g.es_print('Exception running', aClass.__name__)
                        g.es_exception()
                        return None

                if trace: g.trace('found', p.h)
                return scanner_for_at_auto_cb
        if trace: g.trace('not found', p.h, sorted(d.keys()))
        return None
    def scanner_for_ext(self, ext):
        '''A factory returning a scanner function for the given file extension.'''
        aClass = self.classDispatchDict.get(ext)
        if aClass:

            def scanner_for_ext_cb(parent, s, prepass=False):
                try:
                    scanner = aClass(importCommands=self)
                    return scanner.run(s, parent, prepass=prepass)
                except Exception:
                    g.es_print('Exception running', aClass.__name__)
                    g.es_exception()
                    return None

            return scanner_for_ext_cb
        else:
            return None
    def get_import_filename(self, fileName, parent):
        '''Return the absolute path of the file and set .default_directory.'''

    def init_import(self, ext, fileName, s):
        '''Init ivars &amp; vars for imports.'''
"""
table = (
    (1, 'Declarations'),
    (1, "class LeoImportCommands"),
    (2, "createOutline"),
    (2, "dispatch"),
    (2, "scanner_for_at_auto"),
    (2, "scanner_for_ext"),
    (2, "get_import_filename"),
    (2, "init_import"),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161117011147.1">import leo.plugins.importers.linescanner as linescanner
table = [
    ('', 'abc\n'),
    ('    ', '    xyz\n'),
    ('    ', '    \n'),
    ('  ','  # comment\n'),
    ('', '\n'),
]
importer = linescanner.Importer(c.importCommands, language='python')
for val, s in table:
    assert val == importer.get_str_lws(s), (val, repr(s))
</t>
<t tx="ekr.20161118144658.1">@tabwidth -2 # Required

s = r'''
class Builder
  constructor: -&gt;
    @transformer = new Transformer
  # `build()`

  build: (args...) -&gt;
    node = args[0]
    @transform node

    name = 'other'
    name = node.typeName()  if node != undefined and node.typeName

    fn  = (@[name] or @other)
    out = fn.apply(this, args)

    if node.parenthesized then paren(out) else out
  # `transform()`

  transform: (args...) -&gt;
    @transformer.transform.apply(@transformer, args)

  # `body()`

  body: (node, opts={}) -&gt;
    str = @build(node, opts)
    str = blockTrim(str)
    str = unshift(str)
    if str.length &gt; 0 then str else ""
'''
table = (
  'class Builder',
  'constructor: -&gt;',
  'build: (args...) -&gt;',
  'transform: (args...) -&gt;',
  'body: (node, opts={}) -&gt;',
)
try:
    c.importCommands.coffeeScriptUnitTest(p,s=s,showTree=True)
    if 1:
      p2 = c.p.firstChild().firstChild()
      for h in table:
          assert p2.h == h, (p2.h, h)
          p2.moveToThreadNext()
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161119031833.1"># ('len',   'tr///', '/',       context,  0,       0,       0),
# ('len',   's///',  '/',       context,  0,       0,       0),
# ('len',   'm//',   '/',       context,  0,       0,       0),
# ('len',   '/',     '/',       '',       0,       0,       0),

s = '''\
#!/usr/bin/perl

sub test1 {
    s = /{/g;
}

sub test2 {
    s = m//{/;
}

sub test3 {
    s = s///{/;
}

sub test4 {
    s = tr///{/;
}
'''
try:
    c.importCommands.perlUnitTest(p,s=s,showTree=True)
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161119032623.1">if 0:
    # The preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.perl
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.perl)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
#!/usr/bin/perl

sub test1 {
    s = /}/g;
}

sub test2 {
    s = m//}/;
}

sub test3 {
    s = s///}/;
}

sub test4 {
    s = tr///}/;
}
'''
table = (
    'sub test1',
    'sub test2',
    'sub test3',
    'sub test4'
)
try:
    ic.perlUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161123115047.1"></t>
<t tx="ekr.20161123120652.1">s = r'''
var name = 'Bob';

hello() {
  print('Hello, World!');
}

// Define a function.
printNumber(num aNumber) {
  print('The number is $aNumber.'); // Print to console.
}

// This is where the app starts executing.
void main() {
  var number = 42; // Declare and initialize a variable.
  printNumber(number); // Call a function.
}
'''
table = (
    'hello',
    'printNumber',
    'void main',
)
try:
    c.importCommands.dartUnitTest(p,s=s,showTree=True)
    root = c.p.firstChild()
    p2 = root.firstChild()
    for h in table:
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
    assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161123202857.1"></t>
<t tx="ekr.20161123202924.1">s = '''\
* Section 1
Sec 1.
* Section 2
Sec 2.
** Section 2-1
Sec 2.1
*** Section 2-1-1
Sec 2.1.1
* Section 3
** Section 3.1
Sec 3.1
'''
table = (
    'Section 1',
    'Section 2', 'Section 2-1', 'Section 2-1-1',
    'Section 3', 'Section 3.1',
)
try:
    c.importCommands.orgUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.firstChild()
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()

</t>
<t tx="ekr.20161124040933.1"></t>
<t tx="ekr.20161124040933.2">@tabwidth 4 # Required
s = '''\
Section 1
: Sec 1.
Section 2
: Sec 2.
\tSection 2-1
: Sec 2-1
\t\tSection 2-1-1
: Sect 2-1-1
Section 3
: Sec 3
\tSection 3.1
: Sec 3.1
'''
table = (
    'Section 1',
    'Section 2', 'Section 2-1', 'Section 2-1-1',
    'Section 3', 'Section 3.1',
)
try:
    c.importCommands.otlUnitTest(p,s=s,showTree=True)
    if 0:
        root = c.p.firstChild()
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161125134815.1">if 0:
    # The preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    # imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.
#Header

After header text

##Subheader

Not an underline

----------------

After subheader text

#Last header: no text
'''
table = (
    '!Declarations',
    'Header',
        'Subheader',
        'Last header: no text',
)
try:
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@auto-m'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161125230415.1">s = '''\
Top
====

The top section

Section 1
---------

section 1, line 1
-- Not an underline
secttion 1, line 2

Section 2
---------

section 2, line 1

###Section 2.1

section 2.1, line 1

####Section 2.1.1

section 2.2.1 line 1

###Section 2.2
section 2.2, line 1.

Section 3
---------

section 3, line 1

'''
</t>
<t tx="ekr.20161126111517.1">if 0:
    # The preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    # imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.
#Header

After header text

##Subheader

Not an underline

----------------

This *should* be a section
==========================

After subheader text

#Last header: no text
'''
table = (
    '!Declarations',
    'Header',
        'Subheader',
            'This *should* be a section',
        'Last header: no text',
)
try:
    g.app.suppressImportChecks = True
        # Required, because the implicit underlining *must*
        # cause the perfect-import test to fail!
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@auto-m'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    g.app.suppressImportChecks = False
        # Not needed: done in Importer.check
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161127181028.1">@first # -*- coding: utf-8 -*-
    # Required (Python 2 only) because test contains ```.
if 0:
    # The preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    # imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.
#Header

```python
loads.init = {
    Chloride: 11.5,
    TotalP: 0.002,
}
```
#Last header
'''
table = (
    '!Declarations',
    'Header',
    'Last header',
)
try:
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161129104243.1">if 0:
    # The preamble...
    # g.cls()
    if c.isChanged(): c.save()
    import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst as leo_rst
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

# Notes:
# All heading must be followed by an empty line.
### g.app.suppressImportChecks = True
s = '''\
  #########
Chapter 1
  #########

It was a dark and stormy night.
section 1
+++++++++

Sec 1.
section 2
+++++++++

Sec 2.
'''
table = (
    '!Dummy chapter',
    'section 1',
    'section 2',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161129222003.1">s = '''\
&lt;?php
class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
'''

c.importCommands.phpUnitTest(p,s=s,showTree=True)
</t>
<t tx="ekr.20161130041921.1">#section 1
Sec 1.

#section 2
Sec 2.
@language python
@tabwidth -4
@ignore
</t>
<t tx="ekr.20161130042452.50">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161130042452.51">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161130050706.29">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161130050706.30">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161130051657.1">s = '''\
Leading text in root node of subtree

Etc. etc.

### A level one node ######################################################

This would be the text in this level one node.

And this.

### Another level one node ################################################

Another one

#### A level 2 node #######################################################

See what we did there - one more '#' - this is a subnode.
'''
ic = c.importCommands
ic.ctextUnitTest(p,fileName='@auto-ctext test.txt',s=s,showTree=True)</t>
<t tx="ekr.20161130052935.1">Leading text in root node of subtree

Etc. etc.
</t>
<t tx="ekr.20161130053149.1">Leading text in root node of subtree

Etc. etc.

### A level one node ######################################################

This would be the text in this level one node.

And this.

### Another level one node ################################################

Another one

#### A level 2 node #######################################################

See what we did there - one more '#' - this is a subnode.

</t>
<t tx="ekr.20161202053644.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161202053644.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161202083956.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161202083956.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161202093319.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093319.2">
The top section

</t>
<t tx="ekr.20161202093319.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093319.4">
section 2, line 1

</t>
<t tx="ekr.20161202093319.5">
section 2.1, line 1

</t>
<t tx="ekr.20161202093319.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093319.7">section 2.2, line 1.

</t>
<t tx="ekr.20161202093319.8">
section 3, line 1

</t>
<t tx="ekr.20161202093322.10">
The top section

</t>
<t tx="ekr.20161202093322.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093322.12">
section 2, line 1

</t>
<t tx="ekr.20161202093322.13">
section 2.1, line 1

</t>
<t tx="ekr.20161202093322.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093322.15">section 2.2, line 1.

</t>
<t tx="ekr.20161202093322.16">
section 3, line 1

</t>
<t tx="ekr.20161202093322.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093409.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093409.2">
The top section

</t>
<t tx="ekr.20161202093409.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093409.4">
section 2, line 1

</t>
<t tx="ekr.20161202093409.5">
section 2.1, line 1

</t>
<t tx="ekr.20161202093409.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093409.7">section 2.2, line 1.

</t>
<t tx="ekr.20161202093409.8">
section 3, line 1

</t>
<t tx="ekr.20161202093410.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093410.2">
The top section

</t>
<t tx="ekr.20161202093410.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093410.4">
section 2, line 1

</t>
<t tx="ekr.20161202093410.5">
section 2.1, line 1

</t>
<t tx="ekr.20161202093410.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093410.7">section 2.2, line 1.

</t>
<t tx="ekr.20161202093410.8">
section 3, line 1

</t>
<t tx="ekr.20161202093505.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161202093505.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161202093509.22">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093509.23">
The top section

</t>
<t tx="ekr.20161202093509.24">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093509.25">
section 2, line 1

</t>
<t tx="ekr.20161202093509.26">
section 2.1, line 1

</t>
<t tx="ekr.20161202093509.27">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093509.28">section 2.2, line 1.

</t>
<t tx="ekr.20161202093509.29">
section 3, line 1

</t>
<t tx="ekr.20161202093709.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093709.2">#Top
The top section

</t>
<t tx="ekr.20161202093709.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161202093709.4">section 2, line 1

</t>
<t tx="ekr.20161202093709.5">section 2.1, line 1

</t>
<t tx="ekr.20161202093709.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161202093709.7">
</t>
<t tx="ekr.20161202093709.8">Section 3, line 1

</t>
<t tx="ekr.20161204034138.15">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204034138.16">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204034142.19">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204034142.20">The top section

</t>
<t tx="ekr.20161204034142.21">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204034142.22">section 2, line 1

</t>
<t tx="ekr.20161204034142.23">section 2.1, line 1

</t>
<t tx="ekr.20161204034142.24">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204034142.25">
</t>
<t tx="ekr.20161204034142.26">Section 3, line 1

</t>
<t tx="ekr.20161204034142.27">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204034142.28">
The top section

</t>
<t tx="ekr.20161204034142.29">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204034142.30">
section 2, line 1

</t>
<t tx="ekr.20161204034142.31">
section 2.1, line 1

</t>
<t tx="ekr.20161204034142.32">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204034142.33">section 2.2, line 1.

</t>
<t tx="ekr.20161204034142.34">
section 3, line 1

</t>
<t tx="ekr.20161204034207.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204034207.10">
The top section

</t>
<t tx="ekr.20161204034207.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204034207.12">
section 2, line 1

</t>
<t tx="ekr.20161204034207.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204034207.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204034207.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204034207.16">
section 3, line 1

</t>
<t tx="ekr.20161204034207.2">The top section

</t>
<t tx="ekr.20161204034207.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204034207.4">section 2, line 1

</t>
<t tx="ekr.20161204034207.5">section 2.1, line 1

</t>
<t tx="ekr.20161204034207.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204034207.7">
</t>
<t tx="ekr.20161204034207.8">Section 3, line 1

</t>
<t tx="ekr.20161204034207.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204035447.20">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204035447.21">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204035451.19">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204035451.20">The top section

</t>
<t tx="ekr.20161204035451.21">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204035451.22">section 2, line 1

</t>
<t tx="ekr.20161204035451.23">section 2.1, line 1

</t>
<t tx="ekr.20161204035451.24">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204035451.25">
</t>
<t tx="ekr.20161204035451.26">Section 3, line 1

</t>
<t tx="ekr.20161204035451.27">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204035451.28">
The top section

</t>
<t tx="ekr.20161204035451.29">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204035451.30">
section 2, line 1

</t>
<t tx="ekr.20161204035451.31">
section 2.1, line 1

</t>
<t tx="ekr.20161204035451.32">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204035451.33">section 2.2, line 1.

</t>
<t tx="ekr.20161204035451.34">
section 3, line 1

</t>
<t tx="ekr.20161204040924.1"># Alt-G works.  The tests themselves are erroneous.
</t>
<t tx="ekr.20161204041306.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041306.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041310.53">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041310.54">The top section

</t>
<t tx="ekr.20161204041310.55">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041310.56">section 2, line 1

</t>
<t tx="ekr.20161204041310.57">section 2.1, line 1

</t>
<t tx="ekr.20161204041310.58">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041310.59">
</t>
<t tx="ekr.20161204041310.60">Section 3, line 1

</t>
<t tx="ekr.20161204041310.61">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041310.62">
The top section

</t>
<t tx="ekr.20161204041310.63">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041310.64">
section 2, line 1

</t>
<t tx="ekr.20161204041310.65">
section 2.1, line 1

</t>
<t tx="ekr.20161204041310.66">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041310.67">section 2.2, line 1.

</t>
<t tx="ekr.20161204041310.68">
section 3, line 1

</t>
<t tx="ekr.20161204041354.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041354.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041358.103">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041358.104">The top section

</t>
<t tx="ekr.20161204041358.105">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041358.106">section 2, line 1

</t>
<t tx="ekr.20161204041358.107">section 2.1, line 1

</t>
<t tx="ekr.20161204041358.108">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041358.109">
</t>
<t tx="ekr.20161204041358.110">Section 3, line 1

</t>
<t tx="ekr.20161204041359.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041359.2">
The top section

</t>
<t tx="ekr.20161204041359.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041359.4">
section 2, line 1

</t>
<t tx="ekr.20161204041359.5">
section 2.1, line 1

</t>
<t tx="ekr.20161204041359.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041359.7">section 2.2, line 1.

</t>
<t tx="ekr.20161204041359.8">
section 3, line 1

</t>
<t tx="ekr.20161204041418.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041418.10">
The top section

</t>
<t tx="ekr.20161204041418.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041418.12">
section 2, line 1

</t>
<t tx="ekr.20161204041418.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204041418.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041418.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204041418.16">
section 3, line 1

</t>
<t tx="ekr.20161204041418.2">The top section

</t>
<t tx="ekr.20161204041418.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041418.4">section 2, line 1

</t>
<t tx="ekr.20161204041418.5">section 2.1, line 1

</t>
<t tx="ekr.20161204041418.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041418.7">
</t>
<t tx="ekr.20161204041418.8">Section 3, line 1

</t>
<t tx="ekr.20161204041418.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041426.33">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041426.34">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041557.1"></t>
<t tx="ekr.20161204041641.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041641.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041645.103">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041645.104">The top section

</t>
<t tx="ekr.20161204041645.105">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041645.106">section 2, line 1

</t>
<t tx="ekr.20161204041645.107">section 2.1, line 1

</t>
<t tx="ekr.20161204041645.108">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041645.109">
</t>
<t tx="ekr.20161204041645.110">Section 3, line 1

</t>
<t tx="ekr.20161204041646.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041646.2">
The top section

</t>
<t tx="ekr.20161204041646.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041646.4">
section 2, line 1

</t>
<t tx="ekr.20161204041646.5">
section 2.1, line 1

</t>
<t tx="ekr.20161204041646.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041646.7">section 2.2, line 1.

</t>
<t tx="ekr.20161204041646.8">
section 3, line 1

</t>
<t tx="ekr.20161204041720.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041720.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041724.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041724.10">
The top section

</t>
<t tx="ekr.20161204041724.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041724.12">
section 2, line 1

</t>
<t tx="ekr.20161204041724.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204041724.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041724.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204041724.16">
section 3, line 1

</t>
<t tx="ekr.20161204041724.2">The top section

</t>
<t tx="ekr.20161204041724.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041724.4">section 2, line 1

</t>
<t tx="ekr.20161204041724.5">section 2.1, line 1

</t>
<t tx="ekr.20161204041724.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041724.7">
</t>
<t tx="ekr.20161204041724.8">Section 3, line 1

</t>
<t tx="ekr.20161204041724.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041755.29">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041755.30">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041800.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041800.10">
The top section

</t>
<t tx="ekr.20161204041800.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041800.12">
section 2, line 1

</t>
<t tx="ekr.20161204041800.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204041800.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041800.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204041800.16">
section 3, line 1

</t>
<t tx="ekr.20161204041800.2">The top section

</t>
<t tx="ekr.20161204041800.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041800.4">section 2, line 1

</t>
<t tx="ekr.20161204041800.5">section 2.1, line 1

</t>
<t tx="ekr.20161204041800.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041800.7">
</t>
<t tx="ekr.20161204041800.8">Section 3, line 1

</t>
<t tx="ekr.20161204041800.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041842.20">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041842.21">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041902.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041902.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204041920.33">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204041920.34">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042116.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204042116.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042155.7">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204042155.8">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042301.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204042301.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042305.100">section 2.1, line 1

</t>
<t tx="ekr.20161204042305.101">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204042305.102">
</t>
<t tx="ekr.20161204042305.103">Section 3, line 1

</t>
<t tx="ekr.20161204042305.104">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042305.105">
The top section

</t>
<t tx="ekr.20161204042305.106">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204042305.107">
section 2, line 1

</t>
<t tx="ekr.20161204042305.108">
section 2.1, line 1

</t>
<t tx="ekr.20161204042305.109">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204042305.110">section 2.2, line 1.

</t>
<t tx="ekr.20161204042305.111">
section 3, line 1

</t>
<t tx="ekr.20161204042305.96">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042305.97">The top section

</t>
<t tx="ekr.20161204042305.98">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204042305.99">section 2, line 1

</t>
<t tx="ekr.20161204042714.33">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204042714.34">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042719.10">
</t>
<t tx="ekr.20161204042719.11">Section 3, line 1

</t>
<t tx="ekr.20161204042719.12">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042719.13">
The top section

</t>
<t tx="ekr.20161204042719.14">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204042719.15">
section 2, line 1

</t>
<t tx="ekr.20161204042719.16">
section 2.1, line 1

</t>
<t tx="ekr.20161204042719.17">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204042719.18">section 2.2, line 1.

</t>
<t tx="ekr.20161204042719.19">
section 3, line 1

</t>
<t tx="ekr.20161204042719.4">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042719.5">The top section

</t>
<t tx="ekr.20161204042719.6">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204042719.7">section 2, line 1

</t>
<t tx="ekr.20161204042719.8">section 2.1, line 1

</t>
<t tx="ekr.20161204042719.9">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204042739.15">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204042739.16">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204042822.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042822.10">
The top section

</t>
<t tx="ekr.20161204042822.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204042822.12">
section 2, line 1

</t>
<t tx="ekr.20161204042822.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204042822.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204042822.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204042822.16">
section 3, line 1

</t>
<t tx="ekr.20161204042822.2">The top section

</t>
<t tx="ekr.20161204042822.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204042822.4">section 2, line 1

</t>
<t tx="ekr.20161204042822.5">section 2.1, line 1

</t>
<t tx="ekr.20161204042822.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204042822.7">
</t>
<t tx="ekr.20161204042822.8">Section 3, line 1

</t>
<t tx="ekr.20161204042822.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042916.1">print('start python tests')
</t>
<t tx="ekr.20161204042938.1">print('end python tests')
</t>
<t tx="ekr.20161204043013.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204043013.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204043017.19">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043017.20">The top section

</t>
<t tx="ekr.20161204043017.21">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204043017.22">section 2, line 1

</t>
<t tx="ekr.20161204043017.23">section 2.1, line 1

</t>
<t tx="ekr.20161204043017.24">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204043017.25">
</t>
<t tx="ekr.20161204043017.26">Section 3, line 1

</t>
<t tx="ekr.20161204043017.27">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043017.28">
The top section

</t>
<t tx="ekr.20161204043017.29">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204043017.30">
section 2, line 1

</t>
<t tx="ekr.20161204043017.31">
section 2.1, line 1

</t>
<t tx="ekr.20161204043017.32">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204043017.33">section 2.2, line 1.

</t>
<t tx="ekr.20161204043017.34">
section 3, line 1

</t>
<t tx="ekr.20161204043028.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204043028.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204043032.100">section 2.1, line 1

</t>
<t tx="ekr.20161204043032.101">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204043032.102">
</t>
<t tx="ekr.20161204043032.103">Section 3, line 1

</t>
<t tx="ekr.20161204043032.104">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043032.105">
The top section

</t>
<t tx="ekr.20161204043032.106">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204043032.107">
section 2, line 1

</t>
<t tx="ekr.20161204043032.108">
section 2.1, line 1

</t>
<t tx="ekr.20161204043032.109">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204043032.110">section 2.2, line 1.

</t>
<t tx="ekr.20161204043032.111">
section 3, line 1

</t>
<t tx="ekr.20161204043032.96">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043032.97">The top section

</t>
<t tx="ekr.20161204043032.98">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204043032.99">section 2, line 1

</t>
<t tx="ekr.20161204043342.40">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204043342.41">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204043346.10">
</t>
<t tx="ekr.20161204043346.11">Section 3, line 1

</t>
<t tx="ekr.20161204043346.12">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043346.13">
The top section

</t>
<t tx="ekr.20161204043346.14">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204043346.15">
section 2, line 1

</t>
<t tx="ekr.20161204043346.16">
section 2.1, line 1

</t>
<t tx="ekr.20161204043346.17">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204043346.18">section 2.2, line 1.

</t>
<t tx="ekr.20161204043346.19">
section 3, line 1

</t>
<t tx="ekr.20161204043346.4">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043346.5">The top section

</t>
<t tx="ekr.20161204043346.6">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204043346.7">section 2, line 1

</t>
<t tx="ekr.20161204043346.8">section 2.1, line 1

</t>
<t tx="ekr.20161204043346.9">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204045827.15">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204045827.16">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204045955.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204045955.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204154852.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204154852.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161204155218.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161204155218.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161206135449.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161206135449.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161206165824.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161206165824.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161216141227.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161216141227.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161216141315.1">if 0:
    # The preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.markdown)
    # imp.reload(leo.plugins.writers.markdown)
    imp.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.

#@@ Header

After header text

##@@Subheader

Not an underline

----------------

This *should* be a section
==========================

After subheader text

#Last header: no text
'''
table = (
    '!Declarations',
    '@verbatim', # This is an artifact of the unit test.
    '@@ Header',
        '@@Subheader',
            'This *should* be a section',
        'Last header: no text',
)
try:
    g.app.suppressImportChecks = True
        # Required, because the implicit underlining *must*
        # cause the perfect-import test to fail!
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@auto-m'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    g.app.suppressImportChecks = False
        # Not needed: done in Importer.check
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161218103650.1">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
import sys

if sys.version_info[0] &gt;= 3:
    exec_ = eval('exec')
else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")

def make_parser():

    parser = argparse.ArgumentParser(
        description="""Raster calcs. with GDAL.
        The first --grid defines the projection, extent, cell size, and origin
        for all calculations, all other grids are transformed and resampled
        as needed to match.""",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
)
'''
table = (
    (1, 'Declarations'),
    (1, 'make_parser'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161218104646.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161218104646.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161220185154.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161220185154.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221062411.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221062411.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221063734.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221063734.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221065216.7">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221065216.8">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221080848.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221080848.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221091453.20">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221091453.21">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221091950.20">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221091950.21">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161221092230.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161221092230.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161222064421.1"># From xo.py.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = r'''#!/usr/bin/env python3

import os
import re

def merge_value(v1, v2):
    return v

class MainDisplay(object):

    def save_file(self):
        """Write the file out to disk."""
        with open(self.save_name, "w") as f:
            for newline in newlines:
                f.write(newline)

# This line should be included at the end of the class node.
ensure_endswith_newline = lambda x: x if x.endswith('\n') else x + '\n'

def retab(s, tabsize):
    return ''.join(pieces)

if __name__=="__main__":
    main()
'''
table = (
    (1, 'Declarations'),
    (1, 'merge_value'),
    (1, 'class MainDisplay'),
    (2, 'save_file'),
    (1, 'retab'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161222122038.3">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161222122038.4">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161222123534.3">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161222123534.4">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161222123751.3">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161222123751.4">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161223153848.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161223153848.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20161224101046.1">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''
"""
A PyQt "task launcher" for quick access to python scripts.

Buttons to click to make working in Windows less unproductive.

e.g. a button to move the current window to top or bottom half
of screen, because Windows-Up / Windows-Down doesn't do that.
Or quote the text on the clipboard properly, because Outlook
can't do that.

terrynbrown@gmail.com, 2016-12-23
"""

import sys
import time
from PyQt4 import QtGui, QtCore, Qt
from PyQt4.QtCore import Qt as QtConst

COMMANDS = []

class Draggable(QtGui.QWidget):
    def __init__(self, *args, **kwargs):
        """__init__
        """

        QtGui.QWidget.__init__(self, *args, **kwargs)
        # self.setMouseTracking(True)
        self.offset = None
        layout = QtGui.QHBoxLayout()
        self.setLayout(layout)
        layout.addItem(QtGui.QSpacerItem(15, 5))
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)

    def mousePressEvent(self, event):
        self.offset = event.pos()

    def mouseMoveEvent(self, event):
        x=event.globalX()
        y=event.globalY()
        x_w = self.offset.x()
        y_w = self.offset.y()
        self.parent().move(x-x_w, y-y_w)

def command(name):
    def makebutton(function):
        COMMANDS.append((name, function))
        return function
    return makebutton

@command("Exit")
def exit_():
    exit()

def main():

    app = Qt.QApplication(sys.argv)

    main = QtGui.QMainWindow(None,
       # QtConst.CustomizeWindowHint  |
       QtConst.FramelessWindowHint #  |
       # QtConst.WindowCloseButtonHint
    )

    main.resize(800,16)
    main.move(40,40)
    mainwidj = Draggable()

    for name, function in COMMANDS:
        button = QtGui.QPushButton(name)
        button.clicked.connect(function)
        mainwidj.layout().addWidget(button)

    main.setCentralWidget(mainwidj)
    main.show()
    app.exec_()

if __name__ == '__main__':
    main()
'''
table = (
    (1, "Declarations"),
    (1, "class Draggable"),
    (2, "__init__"),
    (2, "mousePressEvent"),
    (2, "mouseMoveEvent"),
    (1, "command"),
    (1, "exit_"),
    (1, "main"),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    c.importCommands.pythonUnitTest(p,s=s,showTree=True) # Must be true.
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    target = g.findNodeInTree(c, root, 'exit_')
    assert target
    lines = g.splitLines(target.b)
    assert lines[0] == '@command("Exit")\n', repr(lines[0])
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161224111342.1">import glob
import os
if 0: # Preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    # import leo.plugins.importers.basescanner as basescanner
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    # imp.reload(leo.plugins.importers.basescanner)
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

try:
    base_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'core')
    assert g.os_path_exists(base_dir), base_dir
    files = glob.glob('%s%s%s' % (base_dir, os.sep, '*.py'))
    files = [z for z in files if g.shortFileName(z).startswith('leo')]
    # leoTangle contains section refs in @c sections.
    files = [z for z in files
        if not g.shortFileName(z).endswith('leoTangle.py')]
    if 0: # Do only files in the table.
        table = (
            'leoColorizer.py',
            'leoFileCommands.py',
            'leoNodes.py',
        )
        result = []
        for fn in files:
            for z in table:
                if g.shortFileName(fn).endswith(z):
                    result.append(fn)
        files = result
    test_node = p.copy()
    fails = []
    test_node.deleteAllChildren()
    for fn in files:
        sfn = g.shortFileName(fn)
        s = g.readFileIntoUnicodeString(fn)
        s2 = ic.removeSentinelLines(s, '#', None, None)
        try:
            print(sfn)
            ic.pythonUnitTest(p,s=s2,showTree=True)
            test_node.lastChild().h = '@@file %s' % sfn
        except AssertionError:
            print('FAIL: %6s %6s %s' % (len(s), len(s2), sfn))
            fails.append(sfn)
            # break
    if fails:
        print('%s failures' % (len(fails)))
        g.printList(sorted(fails))
    elif 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161224145026.1">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
    
s = '''
def isValidPython(self):
    if sys.platform == 'cli':
        return True
    minimum_python_version = '2.6'
    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0, 1, 2)])
        ok = g.CheckVersion(version, minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                class EmergencyDialog(object):
                    def run(self):
                        """Run the modal emergency dialog."""
                        self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
                        self.top.lift()
                        self.top.grab_set() # Make the dialog a modal dialog.
                        self.root.wait_window(self.top)
                d = EmergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
def loadLocalFile(self, fn, gui, old_c):
    trace = (False or g.trace_startup) and not g.unitTesting
'''
table = (
    (1, 'isValidPython'),
    # (2, 'class EmergencyDialog'),
    # (3, 'run'),
    (1, 'loadLocalFile'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161228070933.1">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands 
s = """
if isPython3:
    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        return s

    def ue(s, encoding):
        return s if g.isUnicode(s) else str(s, encoding)
else:
    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        return builtins.unicode(s) # Suppress pyflakes complaint.

    def ue(s, encoding):
        return builtins.unicode(s, encoding)
"""
table = (
    (1, 'Declarations'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161228071435.1">if isPython3: # g.not defined yet.
    &lt;&lt; u:1 &gt;&gt;
    &lt;&lt; ue:1 &gt;&gt;
else:
    &lt;&lt; u:2 &gt;&gt;
    &lt;&lt; ue: 2&gt;&gt;
</t>
<t tx="ekr.20161228071822.1">def u(s):
    '''Return s, converted to unicode from Qt widgets.'''
    return s</t>
<t tx="ekr.20161228071836.1">def ue(s, encoding):
    return s if g.isUnicode(s) else str(s, encoding)</t>
<t tx="ekr.20161228071849.1">def u(s):
    '''Return s, converted to unicode from Qt widgets.'''
    return builtins.unicode(s) # Suppress pyflakes complaint.</t>
<t tx="ekr.20161228071905.1">def ue(s, encoding):
    return builtins.unicode(s, encoding)</t>
<t tx="ekr.20161228071915.1">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20161228072352.1">if isPython3: # g.not defined yet.
    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        return s
    def ue(s, encoding):
        return s if g.isUnicode(s) else str(s, encoding)
else:
    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        return builtins.unicode(s) # Suppress pyflakes complaint.
    def ue(s, encoding):
        return builtins.unicode(s, encoding)
</t>
<t tx="ekr.20161231115630.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20161231115630.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170101085120.25">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170101085120.26">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170101131839.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170101131839.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170101134221.7">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170101134221.8">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170101134417.1"></t>
<t tx="ekr.20170105122516.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170105122516.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170112111339.7">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170112111339.8">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170112111900.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170112111900.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170113162613.7">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170113162613.8">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170114055256.3">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170114055256.4">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170114080041.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170114080041.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170114200550.3">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170114200550.4">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170115052901.10">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170115052901.11">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170122032242.1">s = """
@base_task(
    targets=['img/who_map.png', 'img/who_map.pdf'],
    file_dep=[data_path('phyto')],
    task_dep=['load_data'],
)
def make_map():
    '''make_map - plot the Thompson / Bartsh / WHO map'''
"""
table = (
    (1, 'make_map'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    c.importCommands .pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20170122033034.1">if 0: # Preamble...
    # g.cls()
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands 
s = '''
"""
sheet_stats.py - report column stats for spreadsheets

requires openpyxl and numpy

Terry N. Brown, terrynbrown@gmail.com, Fri Dec 16 13:20:47 2016
2016-12-26 Henry Helgen added average, variance, standard deviation,
                        coefficient of variation to output
2016-12-23 Henry Helgen updated to Python 3.5 syntax including print() and
                        writer = csv.writer(open(opt.output, 'w', newline=''))
"""

import csv
import argparse
import glob
import multiprocessing
import os
import sys
from collections import namedtuple
from math import sqrt, isnan
NAN = float('NAN')

from openpyxl import load_workbook

PYTHON_2 = sys.version_info[0] &lt; 3
if not PYTHON_2:
    unicode = str

class AttrDict(dict):
    """allow d.attr instead of d['attr']
    http://stackoverflow.com/a/14620633
    """
    def __init__(self, *args, **kwargs):
        super(AttrDict, self).__init__(*args, **kwargs)
        self.__dict__ = self

FIELDS = [  # fields in outout table
    'file', 'field', 'n', 'blank', 'bad', 'min', 'max', 'mean', 'std',
    'sum', 'sumsq', 'variance', 'coefvar'
]
def make_parser():
    """build an argparse.ArgumentParser, don't call this directly,
       call get_options() instead.
    """
    parser = argparse.ArgumentParser(
        description="""Report column stats for spreadsheets""",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument('files', type=str, nargs='+',
        help="Files to process, '*' patterns expanded."
    )

    required_named = parser.add_argument_group('required named arguments')

    required_named.add_argument("--output",
        help="Path to .csv file for output, will be overwritten",
        metavar='FILE'
    )

    return parser

def get_options(args=None):
    """
    get_options - use argparse to parse args, and return a
    argparse.Namespace, possibly with some changes / expansions /
    validatations.

    Client code should call this method with args as per sys.argv[1:],
    rather than calling make_parser() directly.

    :param [str] args: arguments to parse
    :return: options with modifications / validations
    :rtype: argparse.Namespace
    """
    opt = make_parser().parse_args(args)

    # modifications / validations go here

    if not opt.output:
        print("No --output supplied")
        exit(10)

    return opt

def get_aggregate(psumsqn, psumn, pcountn):
    """
    get_aggregate - compute mean, variance, standard deviation,
    coefficient of variation This function is used instead of
    numpy.mean, numpy.var, numpy.std since the sum, sumsq, and count are
    available when the function is called. It avoids an extra pass
    through the list.

    # note pcountn means the full list n,  not a sample n - 1

    :param sum of squares, sum, count
    :return: a tuple of floats mean, variance, standard deviation, coefficient of variation
    """

    Agg = namedtuple("Agg", "mean variance std coefvar")

    # validate inputs check for count == 0
    if pcountn == 0:
        result = Agg(NAN, NAN, NAN, NAN)
    else:

        mean = psumn / pcountn # mean

        # compute variance from sum squared without knowing mean while summing
        variance = (psumsqn - (psumn * psumn) / pcountn ) / pcountn

        #compute standard deviation
        if variance &lt; 0:
            std = NAN
        else:
            std = sqrt(variance)

        # compute coefficient of variation
        if mean == 0:
            coefvar = NAN
        else:
            coefvar = std / mean

        result = Agg(mean, variance, std, coefvar)

    return result


def proc_file(filepath):
    """
    proc_file - process one .xlsx file

    :param str filepath: path to file
    :return: list of lists, rows of info. as expected in main()
    """

    print(filepath)

    # get the first sheet
    book = load_workbook(filename=filepath, read_only=True)
    sheets = book.get_sheet_names()
    sheet = book[sheets[0]]
    row_source = sheet.rows
    row0 = next(row_source)
    # get field names from the first row
    fields = [i.value for i in row0]

    data = {
        'filepath': filepath,
        'fields': {field:AttrDict({f:0 for f in FIELDS}) for field in fields}
    }

    for field in fields:
        # init. mins/maxs with invalid value for later calc.
        data['fields'][field].update(dict(
            min=NAN,
            max=NAN,
            field=field,
            file=filepath,
        ))

    rows = 0
    for row in row_source:

        if rows % 1000 == 0:  # feedback every 1000 rows
            print(rows)
            # Much cleaner to exit by creating a file called "STOP" in the
            # local directory than to try and use Ctrl-C, when using
            # multiprocessing.  Save time by checking only every 1000 rows.
            if os.path.exists("STOP"):
                return

        rows += 1

        for cell_n, cell in enumerate(row):
            d = data['fields'][fields[cell_n]]
            if cell.value is None or unicode(cell.value).strip() == '':
                d.blank += 1
            else:
                try:
                    x = float(cell.value)
                    d.sum += x
                    d.sumsq += x*x
                    d.n += 1
                    # min is x if no value seen yet, else min(prev-min, x)
                    if isnan(d.min):
                        d.min = x
                    else:
                        d.min = min(d.min, x)
                    # as for min
                    if isnan(d.max):
                        d.max = x
                    else:
                        d.max = max(d.max, x)
                except ValueError:
                    d.bad += 1

    assert sum(d.n+d.blank+d.bad for d in data['fields'].values()) == rows * len(fields)

    # compute the derived values
    for field in data['fields']:
        d = data['fields'][field]
        d.update(get_aggregate(d.sumsq, d.sum, d.n)._asdict().items())

    return data
def get_answers(opt=None, **kwargs):
    """get_answers - process files

    :param argparse.Namespace opt: options
    :return: list of answers from proc_file
    """

    if opt is None:  # API call rather than command line
        opt = type("opt", (), kwargs)

    # pass filenames through glob() to expand "2017_*.xlsx" etc.
    files = []
    for filepath in opt.files:
        files.extend(glob.glob(filepath))

    # create a pool of processors
    pool = multiprocessing.Pool(multiprocessing.cpu_count()-1)

    # process file list with processor pool
    return pool.map(proc_file, files)
def get_table_rows(answers):
    """get_table_rows - generator - convert get_answers() output to table format

    :param list answers: output from get_answers()
    :return: list of rows suitable for csv.writer
    """
    yield FIELDS
    for answer in answers:
        for field in answer['fields']:
            row = [answer['fields'][field][k] for k in FIELDS]
            if PYTHON_2:
                yield [unicode(col).encode('utf-8') for col in row]
            else:
                yield row

def main():
    """main() - when invoked directly"""
    opt = get_options()

    # csv.writer does its own EOL handling,
    # see https://docs.python.org/3/library/csv.html#csv.reader
    if PYTHON_2:
        output = open(opt.output, 'wb')
    else:
        output = open(opt.output, 'w', newline='')

    with output as out:
        writer = csv.writer(out)
        for row in get_table_rows(get_answers(opt)):
            writer.writerow(row)

if __name__ == '__main__':
    main()
'''
table = (
    (1, "Declarations"),
    (1, "class AttrDict"),
    (2, "__init__"),
    (1, "make_parser"),
    (1, "get_options"),
    (1, "get_aggregate"),
    (1, "proc_file"),
    (1, "get_answers"),
    (1, "get_table_rows"),
    (1, "main"),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20170122164330.1"># Do not try to reload g.
table = (
    (True, '@language python\n'),
    (True, '@tabwidth -4 #test\n'),
    (True, '@others\n'),
    (True, '    @others\n'),
    (True, '@encoding\n'),
    (False, '@encoding.setter\n'),
    (False, '@encoding("abc")\n'),
    (False, 'encoding = "abc"\n'),
)
for expected, s in table:
    result = g.isDirective(s)
    assert expected == bool(result), (expected, bool(result), repr(s))
</t>
<t tx="ekr.20170123035753.1">at = c.atFileCommands
table = (
    (at.othersDirective, '@others'),
    (at.othersDirective, '@others\n'),
    (at.othersDirective, '    @others'),
    (at.miscDirective,   '@tabwidth -4'),
    (at.miscDirective,   '@tabwidth -4\n'),
    (at.miscDirective,   '@encoding'),
    (at.noDirective,     '@encoding.setter'),
    (at.noDirective,     '@encoding("abc")'),
    (at.noDirective,     'encoding = "abc"'),
    (at.noDirective,     '@directive'), # A crucial new test.
)
for expected, s in table:
    result = at.directiveKind4(s, 0)
    assert expected == result, (expected, result, repr(s))
</t>
<t tx="ekr.20170128023431.1">@language html
</t>
<t tx="ekr.20170201143435.1">@language python
import leo.core.leoColorizer as leoColorizer
import leo.core.leoFrame as leoFrame
# import imp
# imp.reload(leoColorizer)
wrapper = c.frame.body.wrapper
widget = c.frame.body.widget
assert wrapper, p.h
assert widget, p.h
if g.app.gui.guiName() == 'curses':
    x = leoFrame.NullColorizer(c)
else:
    x = leoColorizer.JEditColorizer(c, widget, wrapper)
tables = p.firstChild()
tables_s = tables.b
child = p.firstChild().next()
assert child.h == 'test-child'
grand = child.firstChild()
&lt;&lt; scanLanguageDirectives test tables &gt;&gt;
try:
    for i, data in enumerate(language_table):
        language, child_s, grand_s = data
        child.b = child_s
        grand.b = grand_s
        got = x.scanLanguageDirectives(grand)
        assert got == language, '%s expected %r, got %r child.b %r' % (
            i, language, got, child.b)
finally:
    tables.b = tables_s
    
</t>
<t tx="ekr.20170201143435.2">language_table = [
    ('python', '@language rest\n@language python\n', ''),
    ('rest', '@language rest', ''),
    ('python', '@language rest\n@language python\n', ''),
]
</t>
<t tx="ekr.20170201143435.3">@language rest
@language python
</t>
<t tx="ekr.20170201143435.4"></t>
<t tx="ekr.20170201175441.1">@language python
import leo.core.leoColorizer as leoColorizer
# import imp
# imp.reload(leoColorizer)
wrapper = c.frame.body.wrapper
widget = c.frame.body.widget
x = leoColorizer.JEditColorizer(c, widget, wrapper)
tables = p.firstChild()
tables_s = tables.b
child = p.firstChild().next()
assert child.h == 'test-child'
grand = child.firstChild()
&lt;&lt; useSyntaxColoring test tables &gt;&gt;
try:
    for i, data in enumerate(language_table):
        expected, child_s, grand_s = data
        child.b = child_s
        grand.b = grand_s
        got = x.useSyntaxColoring(grand)
        assert got == expected, '%s expected %r, got %r child.b %r' % (
            i, expected, got, child.b)
finally:
    tables.b = tables_s
    
</t>
<t tx="ekr.20170201175441.2">language_table = [
    (True, '', ''),
    # Ambiguous parent.
    (True, '@color \n@nocolor\n', ''),
    (True, '@nocolor \n@color\n', ''),
    # Unambiguous parent.
    (True, '@nocolor-node', ''), # Does not apply to descendants.
    (False, '@nocolor', ''),
    (False, '@killcolor', ''),
    #
    # Note: the following tests don't matter because
    # jedit.recolor ignores the self.enabled flag.
    # As a result, *all* color directives, including @nocolor-node,
    # Apply from the directive to the next color directive.
    #
    # Unambiguous child.
    (False, '', '@killcolor\n'),
    (True, '', '@color\n'),
    # @nocolor-node rules node.
    (False, '', '@nocolor-node\n'),
    (False, '', '@color\n@nocolor-node\n'),
    # Ambiguous node: defer to ancestors.
    (True, '', '@color\n@nocolor'),
    (True, '', '@nocolor\n@color'),
]
</t>
<t tx="ekr.20170201175441.3"></t>
<t tx="ekr.20170201175441.4">@nocolor
@color
</t>
<t tx="ekr.20170302110925.1"># This was part of the ill-fated leoViews project.
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    h = '@persistence'
    p1 = pd.find_at_persistence_node()
    assert p1
    p2 = pd.has_at_persistence_node()
    assert p1 == p2,(p1,p2)
    print(p1.h)
    pd.prepass(p2)
</t>
<t tx="ekr.20170302201859.3">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170302201859.4">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170306041801.1">s = """\
import sys

class Foo():
    pass
    
a = 2

def main(self):
    pass

if __name__ == '__main__':
    main()
"""
table = (
    (1, 'Declarations'),
    (1, 'class Foo'),
    (1, 'main'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    c.importCommands .pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
        assert root.b.find("if __name__ == '__main__':") &gt; -1
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20170401122024.7">@language cweb
@ % This file is part of CWEB.
% This program by Silvio Levy and Donald E. Knuth
% is based on a program by Knuth.
% It is distributed WITHOUT ANY WARRANTY, express or implied.
% Version 3.61 --- July 2000
% (essentially the same as version 3.6, which added
%  recently introduced features of standard C++ to version 3.4)

% Copyright (C) 1987,1990,1993,2000 Silvio Levy and Donald E. Knuth

% Permission is granted to make and distribute verbatim copies of this
% document provided that the copyright notice and this permission notice
% are preserved on all copies.

% Permission is granted to copy and distribute modified versions of this
% document under the conditions for verbatim copying, provided that the
% entire resulting derived work is given a different name and distributed
% under the terms of a permission notice identical to this one.

% Here is TeX material that gets inserted after \input cwebmac
\def\hang{\hangindent 3em\indent\ignorespaces}
\def\pb{$\.|\ldots\.|$} % C brackets (|...|)
\def\v{\char'174} % vertical (|) in typewriter font
\def\dleft{[\![} \def\dright{]\!]} % double brackets
\mathchardef\RA="3221 % right arrow
\mathchardef\BA="3224 % double arrow
\def\({} % ) kludge for alphabetizing certain section names
\def\TeXxstring{\\{\TEX/\_string}}
\def\skipxTeX{\\{skip\_\TEX/}}
\def\copyxTeX{\\{copy\_\TEX/}}

\def\title{CWEAVE (Version 3.61)}
\def\topofcontents{\null\vfill
  \centerline{\titlefont The {\ttitlefont CWEAVE} processor}
  \vskip 15pt
  \centerline{(Version 3.61)}
  \vfill}
\def\botofcontents{\vfill
\noindent
Copyright \copyright\ 1987, 1990, 1993, 2000 Silvio Levy and Donald E. Knuth
\bigskip\noindent
Permission is granted to make and distribute verbatim copies of this
document provided that the copyright notice and this permission notice
are preserved on all copies.

\smallskip\noindent
Permission is granted to copy and distribute modified versions of this
document under the conditions for verbatim copying, provided that the
entire resulting derived work is given a different name and distributed
under the terms of a permission notice identical to this one.
}
\pageno=\contentspagenumber \advance\pageno by 1
\let\maybe=\iftrue
@s not_eq normal @q unreserve a C++ keyword @&gt;@** Introduction. This is the \.{CWEAVE} program by Silvio Levy and Donald E. Knuth, based on \.{WEAVE} by Knuth. We are thankful to Steve Avery, Nelson Beebe, Hans-Hermann Bode (to whom the original \CPLUSPLUS/ adaptation is due), Klaus Guntermann, Norman Ramsey, Tomas Rokicki, Joachim Schnitter, Joachim Schrod, Lee Wittenberg, Saroj Mahapatra, Cesar Augusto Rorato Crusius, and others who have contributed improvements.  The ``banner line'' defined here should be changed whenever \.{CWEAVE} is modified.

@d banner "This is CWEAVE (Version 3.61)\n"

@c @&lt;Include files@&gt;@/
@h
@&lt;Common code for \.{CWEAVE} and \.{CTANGLE}@&gt;@/
@&lt;Typedef declarations@&gt;@/
@&lt;Global variables@&gt;@/
@&lt;Predeclaration of procedures@&gt;
@ We predeclare several standard system functions here instead of including their system header files, because the names of the header files are not as standard as the names of the functions. (For example, some \CEE/ environments have \.{&lt;string.h&gt;} where others have \.{&lt;strings.h&gt;}.)

@&lt;Predeclaration of procedures@&gt;=
extern int strlen(); /* length of string */
extern int strcmp(); /* compare strings lexicographically */
extern char* strcpy(); /* copy one string to another */
extern int strncmp(); /* compare up to $n$ string characters */
extern char* strncpy(); /* copy up to $n$ string characters */
@ \.{CWEAVE} has a fairly straightforward outline.  It operates in three phases: First it inputs the source file and stores cross-reference data, then it inputs the source once again and produces the \TEX/ output file, finally it sorts and outputs the index.  Please read the documentation for \.{common}, the set of routines common to \.{CTANGLE} and \.{CWEAVE}, before proceeding further.

@c
int main (ac, av)
int ac; /* argument count */
char **av; /* argument values */
{
  argc=ac; argv=av;
  program=cweave;
  make_xrefs=force_lines=1; /* controlled by command-line options */
  common_init();
  @&lt;Set initial values@&gt;;
  if (show_banner) printf(banner); /* print a ``banner line'' */
  @&lt;Store all the reserved words@&gt;;
  phase_one(); /* read all the user's text and store the cross-references */
  phase_two(); /* read all the text again and translate it to \TEX/ form */
  phase_three(); /* output the cross-reference index */
  return wrap_up(); /* and exit gracefully */
}@ We have to get \CEE/'s reserved words into the hash table, and the simplest way to do this is to insert them every time \.{CWEAVE} is run.  Fortunately there are relatively few reserved words. (Some of these are not strictly ``reserved,'' but are defined in header files of the ISO Standard \CEE/ Library.) @^reserved words@&gt;

@&lt;Store all the reserved words@&gt;=
id_lookup("and",NULL,alfop);
id_lookup("and_eq",NULL,alfop);
id_lookup("asm",NULL,sizeof_like);
id_lookup("auto",NULL,int_like);
id_lookup("bitand",NULL,alfop);
id_lookup("bitor",NULL,alfop);
id_lookup("bool",NULL,raw_int);
id_lookup("break",NULL,case_like);
id_lookup("case",NULL,case_like);
id_lookup("catch",NULL,catch_like);
id_lookup("char",NULL,raw_int);
id_lookup("class",NULL,struct_like);
id_lookup("clock_t",NULL,raw_int);
id_lookup("compl",NULL,alfop);
id_lookup("const",NULL,const_like);
id_lookup("const_cast",NULL,raw_int);
id_lookup("continue",NULL,case_like);
id_lookup("default",NULL,case_like);
id_lookup("define",NULL,define_like);
id_lookup("defined",NULL,sizeof_like);
id_lookup("delete",NULL,delete_like);
id_lookup("div_t",NULL,raw_int);
id_lookup("do",NULL,do_like);
id_lookup("double",NULL,raw_int);
id_lookup("dynamic_cast",NULL,raw_int);
id_lookup("elif",NULL,if_like);
id_lookup("else",NULL,else_like);
id_lookup("endif",NULL,if_like);
id_lookup("enum",NULL,struct_like);
id_lookup("error",NULL,if_like);
id_lookup("explicit",NULL,int_like);
id_lookup("export",NULL,int_like);
id_lookup("extern",NULL,int_like);
id_lookup("FILE",NULL,raw_int);
id_lookup("float",NULL,raw_int);
id_lookup("for",NULL,for_like);
id_lookup("fpos_t",NULL,raw_int);
id_lookup("friend",NULL,int_like);
id_lookup("goto",NULL,case_like);
id_lookup("if",NULL,if_like);
id_lookup("ifdef",NULL,if_like);
id_lookup("ifndef",NULL,if_like);
id_lookup("include",NULL,if_like);
id_lookup("inline",NULL,int_like);
id_lookup("int",NULL,raw_int);
id_lookup("jmp_buf",NULL,raw_int);
id_lookup("ldiv_t",NULL,raw_int);
id_lookup("line",NULL,if_like);
id_lookup("long",NULL,raw_int);
id_lookup("mutable",NULL,int_like);
id_lookup("namespace",NULL,struct_like);
id_lookup("new",NULL,new_like);
id_lookup("not",NULL,alfop);
id_lookup("not_eq",NULL,alfop);
id_lookup("NULL",NULL,custom);
id_lookup("offsetof",NULL,raw_int);
id_lookup("operator",NULL,operator_like);
id_lookup("or",NULL,alfop);
id_lookup("or_eq",NULL,alfop);
id_lookup("pragma",NULL,if_like);
id_lookup("private",NULL,public_like);
id_lookup("protected",NULL,public_like);
id_lookup("ptrdiff_t",NULL,raw_int);
id_lookup("public",NULL,public_like);
id_lookup("register",NULL,int_like);
id_lookup("reinterpret_cast",NULL,raw_int);
id_lookup("return",NULL,case_like);
id_lookup("short",NULL,raw_int);
id_lookup("sig_atomic_t",NULL,raw_int);
id_lookup("signed",NULL,raw_int);
id_lookup("size_t",NULL,raw_int);
id_lookup("sizeof",NULL,sizeof_like);
id_lookup("static",NULL,int_like);
id_lookup("static_cast",NULL,raw_int);
id_lookup("struct",NULL,struct_like);
id_lookup("switch",NULL,for_like);
id_lookup("template",NULL,template_like);
id_lookup("this",NULL,custom);
id_lookup("throw",NULL,case_like);
id_lookup("time_t",NULL,raw_int);
id_lookup("try",NULL,else_like);
id_lookup("typedef",NULL,typedef_like);
id_lookup("typeid",NULL,raw_int);
id_lookup("typename",NULL,struct_like);
id_lookup("undef",NULL,if_like);
id_lookup("union",NULL,struct_like);
id_lookup("unsigned",NULL,raw_int);
id_lookup("using",NULL,int_like);
id_lookup("va_dcl",NULL,decl); /* Berkeley's variable-arg-list convention */
id_lookup("va_list",NULL,raw_int); /* ditto */
id_lookup("virtual",NULL,int_like);
id_lookup("void",NULL,raw_int);
id_lookup("volatile",NULL,const_like);
id_lookup("wchar_t",NULL,raw_int);
id_lookup("while",NULL,for_like);
id_lookup("xor",NULL,alfop);
id_lookup("xor_eq",NULL,alfop);
res_wd_end=name_ptr;
id_lookup("TeX",NULL,custom);
id_lookup("make_pair",NULL,func_template);
@ The following parameters were sufficient in the original \.{WEAVE} to handle \TEX/, so they should be sufficient for most applications of \.{CWEAVE}. If you change |max_bytes|, |max_names|, |hash_size|, or |buf_size| you have to change them also in the file |"common.w"|.

@d max_bytes 90000 /* the number of bytes in identifiers,
  index entries, and section names */
@d max_names 4000 /* number of identifiers, strings, section names;
  must be less than 10240; used in |"common.w"| */
@d max_sections 2000 /* greater than the total number of sections */
@d hash_size 353 /* should be prime */
@d buf_size 100 /* maximum length of input line, plus one */
@d longest_name 10000 /* section names and strings shouldn't be longer than this */
@d long_buf_size (buf_size+longest_name)
@d line_length 80 /* lines of \TEX/ output have at most this many characters;
  should be less than 256 */
@d max_refs 20000 /* number of cross-references; must be less than 65536 */
@d max_toks 20000 /* number of symbols in \CEE/ texts being parsed;
  must be less than 65536 */
@d max_texts 4000 /* number of phrases in \CEE/ texts being parsed;
  must be less than 10240 */
@d max_scraps 2000 /* number of tokens in \CEE/ texts being parsed */
@d stack_size 400 /* number of simultaneous output levels */

@ The next few sections contain stuff from the file |"common.w"| that must
be included in both |"ctangle.w"| and |"cweave.w"|. It appears in
file |"common.h"|, which needs to be updated when |"common.w"| changes.

@i common.h@* Data structures exclusive to {\tt CWEAVE}. As explained in \.{common.w}, the field of a |name_info| structure that contains the |rlink| of a section name is used for a completely different purpose in the case of identifiers.  It is then called the |ilk| of the identifier, and it is used to distinguish between various types of identifiers, as follows:  \yskip\hang |normal| and |func_template| identifiers are part of the \CEE/ program that will  appear in italic type (or in typewriter type if all uppercase).  \yskip\hang |custom| identifiers are part of the \CEE/ program that will be typeset in special ways.  \yskip\hang |roman| identifiers are index entries that appear after \.{@@\^} in the \.{CWEB} file.  \yskip\hang |wildcard| identifiers are index entries that appear after \.{@@:} in the \.{CWEB} file.  \yskip\hang |typewriter| identifiers are index entries that appear after \.{@@.} in the \.{CWEB} file.  \yskip\hang |alfop|, \dots, |template_like| identifiers are \CEE/ or \CPLUSPLUS/ reserved words whose |ilk| explains how they are to be treated when \CEE/ code is being formatted.

@d ilk dummy.Ilk
@d normal 0 /* ordinary identifiers have |normal| ilk */
@d roman 1 /* normal index entries have |roman| ilk */
@d wildcard 2 /* user-formatted index entries have |wildcard| ilk */
@d typewriter 3 /* `typewriter type' entries have |typewriter| ilk */
@d abnormal(a) (a-&gt;ilk&gt;typewriter) /* tells if a name is special */
@d func_template 4 /* identifiers that can be followed by optional template */
@d custom 5 /* identifiers with user-given control sequence */
@d alfop 22 /* alphabetic operators like \&amp;{and} or \&amp;{not\_eq} */
@d else_like 26 /* \&amp;{else} */
@d public_like 40 /* \&amp;{public}, \&amp;{private}, \&amp;{protected} */
@d operator_like 41 /* \&amp;{operator} */
@d new_like 42 /* \&amp;{new} */
@d catch_like 43 /* \&amp;{catch} */
@d for_like 45 /* \&amp;{for}, \&amp;{switch}, \&amp;{while} */
@d do_like 46 /* \&amp;{do} */
@d if_like 47 /* \&amp;{if}, \&amp;{ifdef}, \&amp;{endif}, \&amp;{pragma}, \dots */
@d delete_like 48 /* \&amp;{delete} */
@d raw_ubin 49 /* `\.\&amp;' or `\.*' when looking for \&amp;{const} following */
@d const_like 50 /* \&amp;{const}, \&amp;{volatile} */
@d raw_int 51 /* \&amp;{int}, \&amp;{char}, \dots; also structure and class names  */
@d int_like 52 /* same, when not followed by left parenthesis or \DC\ */
@d case_like 53 /* \&amp;{case}, \&amp;{return}, \&amp;{goto}, \&amp;{break}, \&amp;{continue} */
@d sizeof_like 54 /* \&amp;{sizeof} */
@d struct_like 55 /* \&amp;{struct}, \&amp;{union}, \&amp;{enum}, \&amp;{class} */
@d typedef_like 56 /* \&amp;{typedef} */
@d define_like 57 /* \&amp;{define} */
@d template_like 58 /* \&amp;{template} */
@ We keep track of the current section number in |section_count|, which is the total number of sections that have started.  Sections which have been altered by a change file entry have their |changed_section| flag turned on during the first phase.

@&lt;Global variables@&gt;=
boolean change_exists; /* has any section changed? */

@ The other large memory area in \.{CWEAVE} keeps the cross-reference data. All uses of the name |p| are recorded in a linked list beginning at |p-&gt;xref|, which points into the |xmem| array. The elements of |xmem| are structures consisting of an integer, |num|, and a pointer |xlink| to another element of |xmem|.  If |x=p-&gt;xref| is a pointer into |xmem|, the value of |x-&gt;num| is either a section number where |p| is used, or |cite_flag| plus a section number where |p| is mentioned, or |def_flag| plus a section number where |p| is defined; and |x-&gt;xlink| points to the next such cross-reference for |p|, if any. This list of cross-references is in decreasing order by section number. The next unused slot in |xmem| is |xref_ptr|. The linked list ends at |&amp;xmem[0]|.  The global variable |xref_switch| is set either to |def_flag| or to zero, depending on whether the next cross-reference to an identifier is to be underlined or not in the index. This switch is set to |def_flag| when \.{@@!} or \.{@

@d} is scanned, and it is cleared to zero when
the next identifier or index entry cross-reference has been made.
Similarly, the global variable |section_xref_switch| is either
|def_flag| or |cite_flag| or zero, depending
on whether a section name is being defined, cited or used in \CEE/ text.

@&lt;Typedef declarations@&gt;=
typedef struct xref_info {
  sixteen_bits num; /* section number plus zero or |def_flag| */
  struct xref_info *xlink; /* pointer to the previous cross-reference */
} xref_info;
typedef xref_info *xref_pointer;

@ @&lt;Global...@&gt;=
xref_info xmem[max_refs]; /* contains cross-reference information */
xref_pointer xmem_end = xmem+max_refs-1;
xref_pointer xref_ptr; /* the largest occupied position in |xmem| */
sixteen_bits xref_switch,section_xref_switch; /* either zero or |def_flag| */

@ A section that is used for multi-file output (with the \.{@@(} feature) has a special first cross-reference whose |num| field is |file_flag|.

@d file_flag (3*cite_flag)
@d def_flag (2*cite_flag)
@d cite_flag 10240 /* must be strictly larger than |max_sections| */
@d xref equiv_or_xref

@&lt;Set initial values@&gt;=
xref_ptr=xmem; name_dir-&gt;xref=(char*)xmem; xref_switch=0; section_xref_switch=0;
xmem-&gt;num=0; /* sentinel value */@ A new cross-reference for an identifier is formed by calling |new_xref|, which discards duplicate entries and ignores non-underlined references to one-letter identifiers or \CEE/'s reserved words.  If the user has sent the |no_xref| flag (the \.{-x} option of the command line), it is unnecessary to keep track of cross-references for identifiers. If one were careful, one could probably make more changes around section 100 to avoid a lot of identifier looking up.

@d append_xref(c) if (xref_ptr==xmem_end) overflow("cross-reference");
  else (++xref_ptr)-&gt;num=c;
@d no_xref (flags['x']==0)
@d make_xrefs flags['x'] /* should cross references be output? */
@d is_tiny(p) ((p+1)-&gt;byte_start==(p)-&gt;byte_start+1)
@d unindexed(a) (a&lt;res_wd_end &amp;&amp; a-&gt;ilk&gt;=custom)
      /* tells if uses of a name are to be indexed */

@c
void
new_xref(p)
name_pointer p;
{
  xref_pointer q; /* pointer to previous cross-reference */
  sixteen_bits m, n; /* new and previous cross-reference value */
  if (no_xref) return;
  if ((unindexed(p) || is_tiny(p)) &amp;&amp; xref_switch==0) return;
  m=section_count+xref_switch; xref_switch=0; q=(xref_pointer)p-&gt;xref;
  if (q != xmem) {
    n=q-&gt;num;
    if (n==m || n==m+def_flag) return;
    else if (m==n+def_flag) {
        q-&gt;num=m; return;
    }
  }
  append_xref(m); xref_ptr-&gt;xlink=q; p-&gt;xref=(char*)xref_ptr;
}@ The cross-reference lists for section names are slightly different. Suppose that a section name is defined in sections $m_1$, \dots, $m_k$, cited in sections $n_1$, \dots, $n_l$, and used in sections $p_1$, \dots, $p_j$.  Then its list will contain $m_1+|def_flag|$, \dots, $m_k+|def_flag|$, $n_1+|cite_flag|$, \dots, $n_l+|cite_flag|$, $p_1$, \dots, $p_j$, in this order.  Although this method of storage takes quadratic time with respect to the length of the list, under foreseeable uses of \.{CWEAVE} this inefficiency is insignificant.

@c
void
new_section_xref(p)
name_pointer p;
{
  xref_pointer q,r; /* pointers to previous cross-references */
  q=(xref_pointer)p-&gt;xref; r=xmem;
  if (q&gt;xmem)
        while (q-&gt;num&gt;section_xref_switch) {r=q; q=q-&gt;xlink;}
  if (r-&gt;num==section_count+section_xref_switch)
        return; /* don't duplicate entries */
  append_xref(section_count+section_xref_switch);
  xref_ptr-&gt;xlink=q; section_xref_switch=0;
  if (r==xmem) p-&gt;xref=(char*)xref_ptr;
  else r-&gt;xlink=xref_ptr;
}@ The cross-reference list for a section name may also begin with |file_flag|. Here's how that flag gets put~in.

@c
void
set_file_flag(p)
name_pointer p;
{
  xref_pointer q;
  q=(xref_pointer)p-&gt;xref;
  if (q-&gt;num==file_flag) return;
  append_xref(file_flag);
  xref_ptr-&gt;xlink = q;
  p-&gt;xref = (char *)xref_ptr;
}@ A third large area of memory is used for sixteen-bit `tokens', which appear in short lists similar to the strings of characters in |byte_mem|. Token lists are used to contain the result of \CEE/ code translated into \TEX/ form; further details about them will be explained later. A |text_pointer| variable is an index into |tok_start|.

@&lt;Typedef declarations@&gt;=
typedef sixteen_bits token;
typedef token *token_pointer;
typedef token_pointer *text_pointer;

@ The first position of |tok_mem| that is unoccupied by replacement text is called |tok_ptr|, and the first unused location of |tok_start| is called |text_ptr|. Thus, we usually have |*text_ptr==tok_ptr|.

@&lt;Global variables@&gt;=
token tok_mem[max_toks]; /* tokens */
token_pointer tok_mem_end = tok_mem+max_toks-1; /* end of |tok_mem| */
token_pointer tok_start[max_texts]; /* directory into |tok_mem| */
token_pointer tok_ptr; /* first unused position in |tok_mem| */
text_pointer text_ptr; /* first unused position in |tok_start| */
text_pointer tok_start_end = tok_start+max_texts-1; /* end of |tok_start| */
token_pointer max_tok_ptr; /* largest value of |tok_ptr| */
text_pointer max_text_ptr; /* largest value of |text_ptr| */

@ @&lt;Set init...@&gt;=
tok_ptr=tok_mem+1; text_ptr=tok_start+1; tok_start[0]=tok_mem+1;
tok_start[1]=tok_mem+1;
max_tok_ptr=tok_mem+1; max_text_ptr=tok_start+1;@ Here are the three procedures needed to complete |id_lookup|:

@c
int names_match(p,first,l,t)
name_pointer p; /* points to the proposed match */
char *first; /* position of first character of string */
int l; /* length of identifier */
eight_bits t; /* desired ilk */
{
  if (length(p)!=l) return 0;
  if (p-&gt;ilk!=t &amp;&amp; !(t==normal &amp;&amp; abnormal(p))) return 0;
  return !strncmp(first,p-&gt;byte_start,l);
}

void
init_p(p,t)
name_pointer p;
eight_bits t;
{
  p-&gt;ilk=t; p-&gt;xref=(char*)xmem;
}

void
init_node(p)
name_pointer p;
{
  p-&gt;xref=(char*)xmem;
}@* Lexical scanning. Let us now consider the subroutines that read the \.{CWEB} source file and break it into meaningful units. There are four such procedures: One simply skips to the next `\.{@@\ }' or `\.{@

@*}' that begins a
section; another passes over the \TEX/ text at the beginning of a
section; the third passes over the \TEX/ text in a \CEE/ comment;
and the last, which is the most interesting, gets the next token of
a \CEE/ text.  They all use the pointers |limit| and |loc| into
the line of input currently being studied.@ Control codes in \.{CWEB}, which begin with `\.{@@}', are converted into a numeric code designed to simplify \.{CWEAVE}'s logic; for example, larger numbers are given to the control codes that denote more significant milestones, and the code of |new_section| should be the largest of all. Some of these numeric control codes take the place of |char| control codes that will not otherwise appear in the output of the scanning routines. @^ASCII code dependencies@&gt;

@d ignore 00 /* control code of no interest to \.{CWEAVE} */
@d verbatim 02 /* takes the place of extended ASCII \.{\char2} */
@d begin_short_comment 03 /* \CPLUSPLUS/ short comment */
@d begin_comment '\t' /* tab marks will not appear */
@d underline '\n' /* this code will be intercepted without confusion */
@d noop 0177 /* takes the place of ASCII delete */
@d xref_roman 0203 /* control code for `\.{@@\^}' */
@d xref_wildcard 0204 /* control code for `\.{@@:}' */
@d xref_typewriter 0205 /* control code for `\.{@@.}' */
@d TeX_string 0206 /* control code for `\.{@@t}' */
@f TeX_string TeX
@d ord 0207 /* control code for `\.{@@'}' */
@d join 0210 /* control code for `\.{@@\&amp;}' */
@d thin_space 0211 /* control code for `\.{@@,}' */
@d math_break 0212 /* control code for `\.{@@\v}' */
@d line_break 0213 /* control code for `\.{@@/}' */
@d big_line_break 0214 /* control code for `\.{@@\#}' */
@d no_line_break 0215 /* control code for `\.{@@+}' */
@d pseudo_semi 0216 /* control code for `\.{@@;}' */
@d macro_arg_open 0220 /* control code for `\.{@@[}' */
@d macro_arg_close 0221 /* control code for `\.{@@]}' */
@d trace 0222 /* control code for `\.{@@0}', `\.{@@1}' and `\.{@@2}' */
@d translit_code 0223 /* control code for `\.{@@l}' */
@d output_defs_code 0224 /* control code for `\.{@@h}' */
@d format_code 0225 /* control code for `\.{@@f}' and `\.{@@s}' */
@d definition 0226 /* control code for `\.{@@d}' */
@d begin_C 0227 /* control code for `\.{@@c}' */
@d section_name 0230 /* control code for `\.{@@&lt;}' */
@d new_section 0231 /* control code for `\.{@@\ }' and `\.{@@*}' */

@ Control codes are converted to \.{CWEAVE}'s internal representation by means of the table |ccode|.

@&lt;Global variables@&gt;=
eight_bits ccode[256]; /* meaning of a char following \.{@@} */

@ @&lt;Set ini...@&gt;=
{int c; for (c=0; c&lt;256; c++) ccode[c]=0;}
ccode[' ']=ccode['\t']=ccode['\n']=ccode['\v']=ccode['\r']=ccode['\f']
   =ccode['*']=new_section;
ccode['@@']='@@'; /* `quoted' at sign */
ccode['=']=verbatim;
ccode['d']=ccode['D']=definition;
ccode['f']=ccode['F']=ccode['s']=ccode['S']=format_code;
ccode['c']=ccode['C']=ccode['p']=ccode['P']=begin_C;
ccode['t']=ccode['T']=TeX_string;
ccode['l']=ccode['L']=translit_code;
ccode['q']=ccode['Q']=noop;
ccode['h']=ccode['H']=output_defs_code;
ccode['&amp;']=join; ccode['&lt;']=ccode['(']=section_name;
ccode['!']=underline; ccode['^']=xref_roman;
ccode[':']=xref_wildcard; ccode['.']=xref_typewriter; ccode[',']=thin_space;
ccode['|']=math_break; ccode['/']=line_break; ccode['#']=big_line_break;
ccode['+']=no_line_break; ccode[';']=pseudo_semi;
ccode['[']=macro_arg_open; ccode[']']=macro_arg_close;
ccode['\'']=ord;
@&lt;Special control codes for debugging@&gt;@;

@ Users can write \.{@@2}, \.{@@1}, and \.{@@0} to turn tracing fully on, partly on, and off, respectively.

@&lt;Special control codes for debugging@&gt;=
ccode['0']=ccode['1']=ccode['2']=trace;
@ The |skip_limbo| routine is used on the first pass to skip through portions of the input that are not in any sections, i.e., that precede the first section. After this procedure has been called, the value of |input_has_ended| will tell whether or not a section has actually been found.  There's a complication that we will postpone until later: If the \.{@@s} operation appears in limbo, we want to use it to adjust the default interpretation of identifiers.

@&lt;Predeclaration of procedures@&gt;=
void skip_limbo();

@ @c
void
skip_limbo() {
  while(1) {
    if (loc&gt;limit &amp;&amp; get_line()==0) return;
    *(limit+1)='@@';
    while (*loc!='@@') loc++; /* look for '@@', then skip two chars */
    if (loc++ &lt;=limit) { int c=ccode[(eight_bits)*loc++];
      if (c==new_section) return;
      if (c==noop) skip_restricted();
      else if (c==format_code) @&lt;Process simple format in limbo@&gt;;
    }
  }
}
@ During the definition and \CEE/ parts of a section, cross-references are made for all identifiers except reserved words. However, the right identifier in a format definition is not referenced, and the left identifier is referenced only if it has been explicitly underlined (preceded by \.{@@!}). The \TEX/ code in comments is, of course, ignored, except for \CEE/ portions enclosed in \pb; the text of a section name is skipped entirely, even if it contains \pb\ constructions.  The variables |lhs| and |rhs| point to the respective identifiers involved in a format definition.

@&lt;Global variables@&gt;=
name_pointer lhs, rhs; /* pointers to |byte_start| for format identifiers */
name_pointer res_wd_end; /* pointer to the first nonreserved identifier */

@ A much simpler processing of format definitions occurs when the definition is found in limbo.

@&lt;Process simple format in limbo@&gt;=
{
  if (get_next()!=identifier)
    err_print("! Missing left identifier of @@s");
@.Missing left identifier...@&gt;
  else {
    lhs=id_lookup(id_first,id_loc,normal);
    if (get_next()!=identifier)
      err_print("! Missing right identifier of @@s");
@.Missing right identifier...@&gt;
    else {
      rhs=id_lookup(id_first,id_loc,normal);
      lhs-&gt;ilk=rhs-&gt;ilk;
    }
  }
}
@ The |skip_TeX| routine is used on the first pass to skip through the \TEX/ code at the beginning of a section. It returns the next control code or `\.{\v}' found in the input. A |new_section| is assumed to exist at the very end of the file.

@f skip_TeX TeX

@c
unsigned
skip_TeX() /* skip past pure \TEX/ code */
{
  while (1) {
    if (loc&gt;limit &amp;&amp; get_line()==0) return(new_section);
    *(limit+1)='@@';
    while (*loc!='@@' &amp;&amp; *loc!='|') loc++;
    if (*loc++ =='|') return('|');
    if (loc&lt;=limit) return(ccode[(eight_bits)*(loc++)]);
  }
}@*1 Inputting the next token. As stated above, \.{CWEAVE}'s most interesting lexical scanning routine is the |get_next| function that inputs the next token of \CEE/ input. However, |get_next| is not especially complicated.  The result of |get_next| is either a |char| code for some special character, or it is a special code representing a pair of characters (e.g., `\.{!=}'), or it is the numeric value computed by the |ccode| table, or it is one of the following special codes:  \yskip\hang |identifier|: In this case the global variables |id_first| and |id_loc| will have been set to the beginning and ending-plus-one locations in the buffer, as required by the |id_lookup| routine.  \yskip\hang |string|: The string will have been copied into the array |section_text|; |id_first| and |id_loc| are set as above (now they are pointers into |section_text|).  \yskip\hang |constant|: The constant is copied into |section_text|, with slight modifications; |id_first| and |id_loc| are set.  \yskip\noindent Furthermore, some of the control codes cause |get_next| to take additional actions:  \yskip\hang |xref_roman|, |xref_wildcard|, |xref_typewriter|, |TeX_string|, |verbatim|: The values of |id_first| and |id_loc| will have been set to the beginning and ending-plus-one locations in the buffer.  \yskip\hang |section_name|: In this case the global variable |cur_section| will point to the |byte_start| entry for the section name that has just been scanned. The value of |cur_section_char| will be |'('| if the section name was preceded by \.{@@(} instead of \.{@

@&lt;}.

\yskip\noindent If |get_next| sees `\.{@@!}'
it sets |xref_switch| to |def_flag| and goes on to the next token.

@d constant 0200 /* \CEE/ constant */
@d string 0201 /* \CEE/ string */
@d identifier 0202 /* \CEE/ identifier or reserved word */

@&lt;Global variables@&gt;=
name_pointer cur_section; /* name of section just scanned */
char cur_section_char; /* the character just before that name */@ @&lt;Include...@&gt;=
#include &lt;ctype.h&gt; /* definition of |isalpha|, |isdigit| and so on */
#include &lt;stdlib.h&gt; /* definition of |exit| */
@ As one might expect, |get_next| consists mostly of a big switch that branches to the various special cases that can arise. \CEE/ allows underscores to appear in identifiers, and some \CEE/ compilers even allow the dollar sign.

@d isxalpha(c) ((c)=='_' || (c)=='$')
   /* non-alpha characters allowed in identifier */
@d ishigh(c) ((eight_bits)(c)&gt;0177)
@^high-bit character handling@&gt;

@&lt;Predeclaration of procedures@&gt;=
eight_bits get_next();
@ @c
eight_bits
get_next() /* produces the next input token */
{@+eight_bits c; /* the current character */
  while (1) {
    @&lt;Check if we're at the end of a preprocessor command@&gt;;
    if (loc&gt;limit &amp;&amp; get_line()==0) return(new_section);
    c=*(loc++);
    if (xisdigit(c) || c=='\\' || c=='.') @&lt;Get a constant@&gt;@;
    else if (c=='\'' || c=='"' || (c=='L'&amp;&amp;(*loc=='\'' || *loc=='"'))@|
           || (c=='&lt;' &amp;&amp; sharp_include_line==1))
        @&lt;Get a string@&gt;@;
    else if (xisalpha(c) || isxalpha(c) || ishigh(c))
      @&lt;Get an identifier@&gt;@;
    else if (c=='@@') @&lt;Get control code and possible section name@&gt;@;
    else if (xisspace(c)) continue; /* ignore spaces and tabs */
    if (c=='#' &amp;&amp; loc==buffer+1) @&lt;Raise preprocessor flag@&gt;;
    mistake: @&lt;Compress two-symbol operator@&gt;@;
    return(c);
  }
}
@ Because preprocessor commands do not fit in with the rest of the syntax of \CEE/, we have to deal with them separately.  One solution is to enclose such commands between special markers.  Thus, when a \.\# is seen as the first character of a line, |get_next| returns a special code |left_preproc| and raises a flag |preprocessing|.  We can use the same internal code number for |left_preproc| as we do for |ord|, since |get_next| changes |ord| into a string.

@d left_preproc ord /* begins a preprocessor command */
@d right_preproc 0217 /* ends a preprocessor command */

@&lt;Global variables@&gt;=
boolean preprocessing=0; /* are we scanning a preprocessor command? */

@ @&lt;Raise prep...@&gt;= {
  preprocessing=1;
  @&lt;Check if next token is |include|@&gt;;
  return (left_preproc);
}
@ An additional complication is the freakish use of \.&lt; and \.&gt; to delimit a file name in lines that start with \.{\#include}.  We must treat this file name as a string.

@&lt;Global variables@&gt;=
boolean sharp_include_line=0; /* are we scanning a |#include| line? */

@ @&lt;Check if next token is |include|@&gt;=
while (loc&lt;=buffer_end-7 &amp;&amp; xisspace(*loc)) loc++;
if (loc&lt;=buffer_end-6 &amp;&amp; strncmp(loc,"include",7)==0) sharp_include_line=1;
@ When we get to the end of a preprocessor line, we lower the flag and send a code |right_preproc|, unless the last character was a \.\\.

@&lt;Check if we're at the end of a preprocessor command@&gt;=
  while (loc==limit-1 &amp;&amp; preprocessing &amp;&amp; *loc=='\\')
    if (get_line()==0) return(new_section); /* still in preprocessor mode */
  if (loc&gt;=limit &amp;&amp; preprocessing) {
    preprocessing=sharp_include_line=0;
    return(right_preproc);
  }
@ The following code assigns values to the combinations
\.{++}, \.{--}, \.{-&gt;}, \.{&gt;=}, \.{&lt;=}, \.{==}, \.{&lt;&lt;},
\.{&gt;&gt;}, \.{!=}, \.{\v\v}, and \.{\&amp;\&amp;}, and to the \CPLUSPLUS/ combinations \.{...}, \.{::}, \.{.*} and \.{-&gt;*}. The compound assignment operators (e.g., \.{+=}) are treated as separate tokens.

@d compress(c) if (loc++&lt;=limit) return(c)

@&lt;Compress two-symbol operator@&gt;=
switch(c) {
  case '/': if (*loc=='*') {compress(begin_comment);}
    else if (*loc=='/') compress(begin_short_comment); break;
  case '+': if (*loc=='+') compress(plus_plus); break;
  case '-': if (*loc=='-') {compress(minus_minus);}
    else if (*loc=='&gt;') if (*(loc+1)=='*') {loc++; compress(minus_gt_ast);}
                        else compress(minus_gt); break;
  case '.': if (*loc=='*') {compress(period_ast);}
            else if (*loc=='.' &amp;&amp; *(loc+1)=='.') {
              loc++; compress(dot_dot_dot);
            }
            break;
  case ':': if (*loc==':') compress(colon_colon); break;
  case '=': if (*loc=='=') compress(eq_eq); break;
  case '&gt;': if (*loc=='=') {compress(gt_eq);}
    else if (*loc=='&gt;') compress(gt_gt); break;
  case '&lt;': if (*loc=='=') {compress(lt_eq);}
    else if (*loc=='&lt;') compress(lt_lt); break;
  case '&amp;': if (*loc=='&amp;') compress(and_and); break;
  case '|': if (*loc=='|') compress(or_or); break;
  case '!': if (*loc=='=') compress(not_eq); break;
}
@ @&lt;Get an identifier@&gt;= {
  id_first=--loc;
  while (isalpha(*++loc) || isdigit(*loc) || isxalpha(*loc) || ishigh(*loc));
  id_loc=loc; return(identifier);
}
@ Different conventions are followed by \TEX/ and \CEE/ to express octal and hexadecimal numbers; it is reasonable to stick to each convention within its realm.  Thus the \CEE/ part of a \.{CWEB} file has octals introduced by \.0 and hexadecimals by \.{0x}, but \.{CWEAVE} will print with \TeX/ macros that the user can redefine to fit the context. In order to simplify such macros, we replace some of the characters.  Notice that in this section and the next, |id_first| and |id_loc| are pointers into the array |section_text|, not into |buffer|.

@&lt;Get a constant@&gt;= {
  id_first=id_loc=section_text+1;
  if (*(loc-1)=='\\') {*id_loc++='~';
  while (xisdigit(*loc)) *id_loc++=*loc++;} /* octal constant */
  else if (*(loc-1)=='0') {
    if (*loc=='x' || *loc=='X') {*id_loc++='^'; loc++;
      while (xisxdigit(*loc)) *id_loc++=*loc++;} /* hex constant */
    else if (xisdigit(*loc)) {*id_loc++='~';
      while (xisdigit(*loc)) *id_loc++=*loc++;} /* octal constant */
    else goto dec; /* decimal constant */
  }
  else { /* decimal constant */
    if (*(loc-1)=='.' &amp;&amp; !xisdigit(*loc)) goto mistake; /* not a constant */
    dec: *id_loc++=*(loc-1);
    while (xisdigit(*loc) || *loc=='.') *id_loc++=*loc++;
    if (*loc=='e' || *loc=='E') { /* float constant */
      *id_loc++='_'; loc++;
      if (*loc=='+' || *loc=='-') *id_loc++=*loc++;
      while (xisdigit(*loc)) *id_loc++=*loc++;
    }
  }
  while (*loc=='u' || *loc=='U' || *loc=='l' || *loc=='L'
         || *loc=='f' || *loc=='F') {
    *id_loc++='$'; *id_loc++=toupper(*loc); loc++;
  }
  return(constant);
}
@ \CEE/ strings and character constants, delimited by double and single quotes, respectively, can contain newlines or instances of their own delimiters if they are protected by a backslash.  We follow this convention, but do not allow the string to be longer than |longest_name|.

@&lt;Get a string@&gt;= {
  char delim = c; /* what started the string */
  id_first = section_text+1;
  id_loc = section_text;
  if (delim=='\'' &amp;&amp; *(loc-2)=='@@') {*++id_loc='@@'; *++id_loc='@@';}
  *++id_loc=delim;
  if (delim=='L') { /* wide character constant */
    delim=*loc++; *++id_loc=delim;
  }
  if (delim=='&lt;') delim='&gt;'; /* for file names in |#include| lines */
  while (1) {
    if (loc&gt;=limit) {
      if(*(limit-1)!='\\') {
        err_print("! String didn't end"); loc=limit; break;
@.String didn't end@&gt;
      }
      if(get_line()==0) {
        err_print("! Input ended in middle of string"); loc=buffer; break;
@.Input ended in middle of string@&gt;
      }
    }
    if ((c=*loc++)==delim) {
      if (++id_loc&lt;=section_text_end) *id_loc=c;
      break;
    }
    if (c=='\\') if (loc&gt;=limit) continue;
      else if (++id_loc&lt;=section_text_end) {
        *id_loc = '\\'; c=*loc++;
      }
    if (++id_loc&lt;=section_text_end) *id_loc=c;
  }
  if (id_loc&gt;=section_text_end) {
    printf("\n! String too long: ");
@.String too long@&gt;
    term_write(section_text+1,25);
    printf("..."); mark_error;
  }
  id_loc++;
  return(string);
}
@ After an \.{@@} sign has been scanned, the next character tells us whether there is more work to do.

@&lt;Get control code and possible section name@&gt;= {
  c=*loc++;
  switch(ccode[(eight_bits)c]) {
    case translit_code: err_print("! Use @@l in limbo only"); continue;
@.Use @@l in limbo...@&gt;
    case underline: xref_switch=def_flag; continue;
    case trace: tracing=c-'0'; continue;
    case xref_roman: case xref_wildcard: case xref_typewriter:
    case noop: case TeX_string: c=ccode[c]; skip_restricted(); return(c);
    case section_name:
      @&lt;Scan the section name and make |cur_section| point to it@&gt;;
    case verbatim: @&lt;Scan a verbatim string@&gt;;
    case ord: @&lt;Get a string@&gt;;
    default: return(ccode[(eight_bits)c]);
  }
}
@ The occurrence of a section name sets |xref_switch| to zero, because the section name might (for example) follow \&amp;{int}.

@&lt;Scan the section name and make |cur_section| point to it@&gt;= {
  char *k; /* pointer into |section_text| */
  cur_section_char=*(loc-1);
  @&lt;Put section name into |section_text|@&gt;;
  if (k-section_text&gt;3 &amp;&amp; strncmp(k-2,"...",3)==0)
        cur_section=section_lookup(section_text+1,k-3,1); /* 1 indicates a prefix */
  else cur_section=section_lookup(section_text+1,k,0);
  xref_switch=0; return(section_name);
}
@ At the present point in the program we have |*(loc-1)==verbatim|; we set |id_first| to the beginning of the string itself, and |id_loc| to its ending-plus-one location in the buffer.  We also set |loc| to the position just after the ending delimiter.

@&lt;Scan a verbatim string@&gt;= {
  id_first=loc++; *(limit+1)='@@'; *(limit+2)='&gt;';
  while (*loc!='@@' || *(loc+1)!='&gt;') loc++;
  if (loc&gt;=limit) err_print("! Verbatim string didn't end");
@.Verbatim string didn't end@&gt;
  id_loc=loc; loc+=2;
  return (verbatim);
}
@ Section names are placed into the |section_text| array with consecutive spaces, tabs, and carriage-returns replaced by single spaces. There will be no spaces at the beginning or the end. (We set |section_text[0]=' '| to facilitate this, since the |section_lookup| routine uses |section_text[1]| as the first character of the name.)

@&lt;Set initial values@&gt;=section_text[0]=' ';

@ @&lt;Put section name...@&gt;=
k=section_text;
while (1) {
  if (loc&gt;limit &amp;&amp; get_line()==0) {
    err_print("! Input ended in section name");
@.Input ended in section name@&gt;
    loc=buffer+1; break;
  }
  c=*loc;
  @&lt;If end of name or erroneous control code, |break|@&gt;;
  loc++; if (k&lt;section_text_end) k++;
  if (xisspace(c)) {
    c=' '; if (*(k-1)==' ') k--;
  }
*k=c;
}
if (k&gt;=section_text_end) {
  printf("\n! Section name too long: ");
@.Section name too long@&gt;
  term_write(section_text+1,25);
  printf("..."); mark_harmless;
}
if (*k==' ' &amp;&amp; k&gt;section_text) k--;
@ @&lt;If end of name...@&gt;=
if (c=='@@') {
  c=*(loc+1);
  if (c=='&gt;') {
    loc+=2; break;
  }
  if (ccode[(eight_bits)c]==new_section) {
    err_print("! Section name didn't end"); break;
@.Section name didn't end@&gt;
  }
  if (c!='@@') {
    err_print("! Control codes are forbidden in section name"); break;
@.Control codes are forbidden...@&gt;
  }
  *(++k)='@@'; loc++; /* now |c==*loc| again */
}
@ This function skips over a restricted context at relatively high speed.

@&lt;Predeclaration of procedures@&gt;=
void skip_restricted();

@ @c
void
skip_restricted()
{
  id_first=loc; *(limit+1)='@@';
false_alarm:
  while (*loc!='@@') loc++;
  id_loc=loc;
  if (loc++&gt;limit) {
    err_print("! Control text didn't end"); loc=limit;
@.Control text didn't end@&gt;
  }
  else {
    if (*loc=='@@'&amp;&amp;loc&lt;=limit) {loc++; goto false_alarm;}
    if (*loc++!='&gt;')
      err_print("! Control codes are forbidden in control text");
@.Control codes are forbidden...@&gt;
  }
}
@** Phase one processing. We now have accumulated enough subroutines to make it possible to carry out \.{CWEAVE}'s first pass over the source file. If everything works right, both phase one and phase two of \.{CWEAVE} will assign the same numbers to sections, and these numbers will agree with what \.{CTANGLE} does.  The global variable |next_control| often contains the most recent output of |get_next|; in interesting cases, this will be the control code that ended a section or part of a section.

@&lt;Global variables@&gt;=
eight_bits next_control; /* control code waiting to be acting upon */@ The overall processing strategy in phase one has the following straightforward outline.

@&lt;Predeclaration of procedures@&gt;=
void phase_one();

@ @c
void
phase_one() {
  phase=1; reset_input(); section_count=0;
  skip_limbo(); change_exists=0;
  while (!input_has_ended)
    @&lt;Store cross-reference data for the current section@&gt;;
  changed_section[section_count]=change_exists;
    /* the index changes if anything does */
  phase=2; /* prepare for second phase */
  @&lt;Print error messages about unused or undefined section names@&gt;;
}
@ @&lt;Store cross-reference data...@&gt;=
{
  if (++section_count==max_sections) overflow("section number");
  changed_section[section_count]=changing;
     /* it will become 1 if any line changes */
  if (*(loc-1)=='*' &amp;&amp; show_progress) {
    printf("*%d",section_count);
    update_terminal; /* print a progress report */
  }
  @&lt;Store cross-references in the \TEX/ part of a section@&gt;;
  @&lt;Store cross-references in the definition part of a section@&gt;;
  @&lt;Store cross-references in the \CEE/ part of a section@&gt;;
  if (changed_section[section_count]) change_exists=1;
}
@ In the \TEX/ part of a section, cross-reference entries are made only for the identifiers in \CEE/ texts enclosed in \pb, or for control texts enclosed in \.{@@\^}$\,\ldots\,$\.{@@&gt;} or \.{@@.}$\,\ldots\,$\.{@@&gt;} or \.{@@:}$\,\ldots\,$\.{@@&gt;}.

@&lt;Store cross-references in the \TEX/ part of a section@&gt;=
while (1) {
  switch (next_control=skip_TeX()) {
    case translit_code: err_print("! Use @@l in limbo only"); continue;
@.Use @@l in limbo...@&gt;
    case underline: xref_switch=def_flag; continue;
    case trace: tracing=*(loc-1)-'0'; continue;
    case '|': C_xref(section_name); break;
    case xref_roman: case xref_wildcard: case xref_typewriter:
    case noop: case section_name:
      loc-=2; next_control=get_next(); /* scan to \.{@@&gt;} */
      if (next_control&gt;=xref_roman &amp;&amp; next_control&lt;=xref_typewriter) {
        @&lt;Replace |"@@@@"| by |"@@"| @&gt;@;
        new_xref(id_lookup(id_first, id_loc,next_control-identifier));
      }
      break;
  }
  if (next_control&gt;=format_code) break;
}
@ @&lt;Replace |"@@@@"| by |"@@"| @&gt;=
{
  char *src=id_first,*dst=id_first;
  while(src&lt;id_loc){
    if(*src=='@@') src++;
    *dst++=*src++;
  }
  id_loc=dst;
  while (dst&lt;src) *dst++=' '; /* clean up in case of error message display */
}
@ When we get to the following code we have |next_control&gt;=format_code|.

@&lt;Store cross-references in the definition part of a section@&gt;=
while (next_control&lt;=definition) { /* |format_code| or |definition| */
  if (next_control==definition) {
    xref_switch=def_flag; /* implied \.{@@!} */
    next_control=get_next();
  } else @&lt;Process a format definition@&gt;;
  outer_xref();
}
@ Error messages for improper format definitions will be issued in phase two. Our job in phase one is to define the |ilk| of a properly formatted identifier, and to remove cross-references to identifiers that we now discover should be unindexed.

@&lt;Process a format definition@&gt;= {
  next_control=get_next();
  if (next_control==identifier) {
    lhs=id_lookup(id_first, id_loc,normal); lhs-&gt;ilk=normal;
    if (xref_switch) new_xref(lhs);
    next_control=get_next();
    if (next_control==identifier) {
      rhs=id_lookup(id_first, id_loc,normal);
      lhs-&gt;ilk=rhs-&gt;ilk;
      if (unindexed(lhs)) { /* retain only underlined entries */
        xref_pointer q,r=NULL;
        for (q=(xref_pointer)lhs-&gt;xref;q&gt;xmem;q=q-&gt;xlink)
          if (q-&gt;num&lt;def_flag)
            if (r) r-&gt;xlink=q-&gt;xlink;
            else lhs-&gt;xref=(char*)q-&gt;xlink;
          else r=q;
      }
      next_control=get_next();
    }
  }
}
@ Finally, when the \TEX/ and definition parts have been treated, we have |next_control&gt;=begin_C|.

@&lt;Store cross-references in the \CEE/ part of a section@&gt;=
if (next_control&lt;=section_name) {  /* |begin_C| or |section_name| */
  if (next_control==begin_C) section_xref_switch=0;
  else {
    section_xref_switch=def_flag;
    if(cur_section_char=='(' &amp;&amp; cur_section!=name_dir)
      set_file_flag(cur_section);
  }
  do {
    if (next_control==section_name &amp;&amp; cur_section!=name_dir)
      new_section_xref(cur_section);
    next_control=get_next(); outer_xref();
  } while ( next_control&lt;=section_name);
}
@ @&lt;Print error messages about un...@&gt;=section_check(root)
@ The |C_xref| subroutine stores references to identifiers in \CEE/ text material beginning with the current value of |next_control| and continuing until |next_control| is `\.\{' or `\.{\v}', or until the next ``milestone'' is passed (i.e., |next_control&gt;=format_code|). If |next_control&gt;=format_code| when |C_xref| is called, nothing will happen; but if |next_control=='|'| upon entry, the procedure assumes that this is the `\.{\v}' preceding \CEE/ text that is to be processed.  The parameter |spec_ctrl| is used to change this behavior. In most cases |C_xref| is called with |spec_ctrl==ignore|, which triggers the default processing described above. If |spec_ctrl==section_name|, section names will be gobbled. This is used when \CEE/ text in the \TEX/ part or inside comments is parsed: It allows for section names to appear in \pb, but these strings will not be entered into the cross reference lists since they are not definitions of section names.  The program uses the fact that our internal code numbers satisfy the relations |xref_roman==identifier+roman| and |xref_wildcard==identifier +wildcard| and |xref_typewriter==identifier+typewriter|, as well as |normal==0|.

@&lt;Predeclaration of procedures@&gt;=
void C_xref();

@ @c
void
C_xref( spec_ctrl ) /* makes cross-references for \CEE/ identifiers */
  eight_bits spec_ctrl;
{
  name_pointer p; /* a referenced name */
  while (next_control&lt;format_code || next_control==spec_ctrl) {
    if (next_control&gt;=identifier &amp;&amp; next_control&lt;=xref_typewriter) {
      if (next_control&gt;identifier) @&lt;Replace |"@@@@"| by |"@@"| @&gt;@;
      p=id_lookup(id_first, id_loc,next_control-identifier); new_xref(p);
    }
    if (next_control==section_name) {
      section_xref_switch=cite_flag;
      new_section_xref(cur_section);
    }
    next_control=get_next();
    if (next_control=='|' || next_control==begin_comment ||
        next_control==begin_short_comment) return;
  }
}
@ The |outer_xref| subroutine is like |C_xref| except that it begins with |next_control!='|'| and ends with |next_control&gt;=format_code|. Thus, it handles \CEE/ text with embedded comments.

@&lt;Predeclaration of procedures@&gt;=
void outer_xref();

@ @c
void
outer_xref() /* extension of |C_xref| */
{
  int bal; /* brace level in comment */
  while (next_control&lt;format_code)
    if (next_control!=begin_comment &amp;&amp; next_control!=begin_short_comment)
      C_xref(ignore);
    else {
      boolean is_long_comment=(next_control==begin_comment);
      bal=copy_comment(is_long_comment,1); next_control='|';
      while (bal&gt;0) {
        C_xref(section_name); /* do not reference section names in comments */
        if (next_control=='|') bal=copy_comment(is_long_comment,bal);
        else bal=0; /* an error message will occur in phase two */
      }
    }
}
@ After phase one has looked at everything, we want to check that each section name was both defined and used.  The variable |cur_xref| will point to cross-references for the current section name of interest.

@&lt;Global variables@&gt;=
xref_pointer cur_xref; /* temporary cross-reference pointer */
boolean an_output; /* did |file_flag| precede |cur_xref|? */

@ The following recursive procedure walks through the tree of section names and prints out anomalies. @^recursion@&gt;

@&lt;Predeclaration of procedures@&gt;=
void section_check();

@ @c
void
section_check(p)
name_pointer p; /* print anomalies in subtree |p| */
{
  if (p) {
    section_check(p-&gt;llink);
    cur_xref=(xref_pointer)p-&gt;xref;
    if (cur_xref-&gt;num==file_flag) {an_output=1; cur_xref=cur_xref-&gt;xlink;}
    else an_output=0;
    if (cur_xref-&gt;num &lt;def_flag) {
      printf("\n! Never defined: &lt;"); print_section_name(p); putchar('&gt;'); mark_harmless;
@.Never defined: &lt;section name&gt;@&gt;
    }
    while (cur_xref-&gt;num &gt;=cite_flag) cur_xref=cur_xref-&gt;xlink;
    if (cur_xref==xmem &amp;&amp; !an_output) {
      printf("\n! Never used: &lt;"); print_section_name(p); putchar('&gt;'); mark_harmless;
@.Never used: &lt;section name&gt;@&gt;
    }
    section_check(p-&gt;rlink);
  }
}
@* Low-level output routines. The \TEX/ output is supposed to appear in lines at most |line_length| characters long, so we place it into an output buffer. During the output process, |out_line| will hold the current line number of the line about to be output.

@&lt;Global variables@&gt;=
char out_buf[line_length+1]; /* assembled characters */
char *out_ptr; /* just after last character in |out_buf| */
char *out_buf_end = out_buf+line_length; /* end of |out_buf| */
int out_line; /* number of next line to be output */@ The |flush_buffer| routine empties the buffer up to a given breakpoint, and moves any remaining characters to the beginning of the next line. If the |per_cent| parameter is 1 a |'%'| is appended to the line that is being output; in this case the breakpoint |b| should be strictly less than |out_buf_end|. If the |per_cent| parameter is |0|, trailing blanks are suppressed. The characters emptied from the buffer form a new line of output; if the |carryover| parameter is true, a |"%"| in that line will be carried over to the next line (so that \TEX/ will ignore the completion of commented-out text).

@d c_line_write(c) fflush(active_file),fwrite(out_buf+1,sizeof(char),c,active_file)
@d tex_putc(c) putc(c,active_file)
@d tex_new_line putc('\n',active_file)
@d tex_printf(c) fprintf(active_file,c)

@c
void
flush_buffer(b,per_cent,carryover)
char *b;  /* outputs from |out_buf+1| to |b|,where |b&lt;=out_ptr| */
boolean per_cent,carryover;
{
  char *j; j=b; /* pointer into |out_buf| */
  if (! per_cent) /* remove trailing blanks */
    while (j&gt;out_buf &amp;&amp; *j==' ') j--;
  c_line_write(j-out_buf);
  if (per_cent) tex_putc('%');
  tex_new_line; out_line++;
  if (carryover)
    while (j&gt;out_buf)
      if (*j--=='%' &amp;&amp; (j==out_buf || *j!='\\')) {
        *b--='%'; break;
      }
  if (b&lt;out_ptr) strncpy(out_buf+1,b+1,out_ptr-b);
  out_ptr-=b-out_buf;
}@ When we are copying \TEX/ source material, we retain line breaks that occur in the input, except that an empty line is not output when the \TEX/ source line was nonempty. For example, a line of the \TEX/ file that contains only an index cross-reference entry will not be copied. The |finish_line| routine is called just before |get_line| inputs a new line, and just after a line break token has been emitted during the output of translated \CEE/ text.

@c
void
finish_line() /* do this at the end of a line */
{
  char *k; /* pointer into |buffer| */
  if (out_ptr&gt;out_buf) flush_buffer(out_ptr,0,0);
  else {
    for (k=buffer; k&lt;=limit; k++)
      if (!(xisspace(*k))) return;
    flush_buffer(out_buf,0,0);
  }
}@ In particular, the |finish_line| procedure is called near the very beginning of phase two. We initialize the output variables in a slightly tricky way so that the first line of the output file will be `\.{\\input cwebmac}'.

@&lt;Set initial values@&gt;=
out_ptr=out_buf+1; out_line=1; active_file=tex_file;
*out_ptr='c'; tex_printf("\\input cwebma");
@ When we wish to append one character |c| to the output buffer, we write `|out(c)|'; this will cause the buffer to be emptied if it was already full.  If we want to append more than one character at once, we say |out_str(s)|, where |s| is a string containing the characters.  A line break will occur at a space or after a single-nonletter \TEX/ control sequence.

@d out(c) {if (out_ptr&gt;=out_buf_end) break_out(); *(++out_ptr)=c;}

@c
void
out_str(s) /* output characters from |s| to end of string */
char *s;
{
  while (*s) out(*s++);
}@ The |break_out| routine is called just before the output buffer is about to overflow. To make this routine a little faster, we initialize position 0 of the output buffer to `\.\\'; this character isn't really output.

@&lt;Set initial values@&gt;=
out_buf[0]='\\';

@ A long line is broken at a blank space or just before a backslash that isn't preceded by another backslash. In the latter case, a |'%'| is output at the break.

@&lt;Predeclaration of procedures@&gt;=
void break_out();

@ @c
void
break_out() /* finds a way to break the output line */
{
  char *k=out_ptr; /* pointer into |out_buf| */
  while (1) {
    if (k==out_buf) @&lt;Print warning message, break the line, |return|@&gt;;
    if (*k==' ') {
      flush_buffer(k,0,1); return;
    }
    if (*(k--)=='\\' &amp;&amp; *k!='\\') { /* we've decreased |k| */
      flush_buffer(k,1,1); return;
    }
  }
}
@ We get to this section only in the unusual case that the entire output line consists of a string of backslashes followed by a string of nonblank non-backslashes. In such cases it is almost always safe to break the line by putting a |'%'| just before the last character.

@&lt;Print warning message, break the line, |return|@&gt;=
{
  printf("\n! Line had to be broken (output l. %d):\n",out_line);
@.Line had to be broken@&gt;
  term_write(out_buf+1, out_ptr-out_buf-1);
  new_line; mark_harmless;
  flush_buffer(out_ptr-1,1,1); return;
}
@ Here is a macro that outputs a section number in decimal notation. The number to be converted by |out_section| is known to be less than |def_flag|, so it cannot have more than five decimal digits.  If the section is changed, we output `\.{\\*}' just after the number.

@c
void
out_section(n)
sixteen_bits n;
{
  char s[6];
  sprintf(s,"%d",n); out_str(s);
  if(changed_section[n]) out_str ("\\*");
@.\\*@&gt;
}@ The |out_name| procedure is used to output an identifier or index entry, enclosing it in braces.

@c
void
out_name(p,quote_xalpha)
name_pointer p;
boolean quote_xalpha;
{
  char *k, *k_end=(p+1)-&gt;byte_start; /* pointers into |byte_mem| */
  out('{');
  for (k=p-&gt;byte_start; k&lt;k_end; k++) {
    if (isxalpha(*k) &amp;&amp; quote_xalpha) out('\\');
@.\\\$@&gt;
@.\\\_@&gt;
    out(*k);
  }
  out('}');
}@* Routines that copy \TEX/ material. During phase two, we use subroutines |copy_limbo|, |copy_TeX|, and |copy_comment| in place of the analogous |skip_limbo|, |skip_TeX|, and |skip_comment| that were used in phase one. (Well, |copy_comment| was actually written in such a way that it functions as |skip_comment| in phase one.)  The |copy_limbo| routine, for example, takes \TEX/ material that is not part of any section and transcribes it almost verbatim to the output file. The use of `\.{@@}' signs is severely restricted in such material: `\.{@@@@}' pairs are replaced by singletons; `\.{@@l}' and `\.{@@q}' and `\.{@@s}' are interpreted.

@c
void
copy_limbo()
{
  char c;
  while (1) {
    if (loc&gt;limit &amp;&amp; (finish_line(), get_line()==0)) return;
    *(limit+1)='@@';
    while (*loc!='@@') out(*(loc++));
    if (loc++&lt;=limit) {
      c=*loc++;
      if (ccode[(eight_bits)c]==new_section) break;
      switch (ccode[(eight_bits)c]) {
        case translit_code: out_str("\\ATL"); break;
@.\\ATL@&gt;
        case '@@': out('@@'); break;
        case noop: skip_restricted(); break;
        case format_code: if (get_next()==identifier) get_next();
          if (loc&gt;=limit) get_line(); /* avoid blank lines in output */
          break; /* the operands of \.{@@s} are ignored on this pass */
        default: err_print("! Double @@ should be used in limbo");
@.Double @@ should be used...@&gt;
        out('@@');
      }
    }
  }
}@ The |copy_TeX| routine processes the \TEX/ code at the beginning of a
section; for example, the words you are now reading were copied in this
way. It returns the next control code or `\.{\v}' found in the input.
We don't copy spaces or tab marks into the beginning of a line. This
makes the test for empty lines in |finish_line| work.

@ @f copy_TeX TeX
@c
eight_bits
copy_TeX()
{
  char c; /* current character being copied */
  while (1) {
    if (loc&gt;limit &amp;&amp; (finish_line(), get_line()==0)) return(new_section);
    *(limit+1)='@@';
    while ((c=*(loc++))!='|' &amp;&amp; c!='@@') {
      out(c);
      if (out_ptr==out_buf+1 &amp;&amp; (xisspace(c))) out_ptr--;
    }
    if (c=='|') return('|');
    if (loc&lt;=limit) return(ccode[(eight_bits)*(loc++)]);
  }
}@ The |copy_comment| function issues a warning if more braces are opened than closed, and in the case of a more serious error it supplies enough braces to keep \TEX/ from complaining about unbalanced braces. Instead of copying the \TEX/ material into the output buffer, this function copies it into the token memory (in phase two only). The abbreviation |app_tok(t)| is used to append token |t| to the current token list, and it also makes sure that it is possible to append at least one further token without overflow.

@d app_tok(c) {if (tok_ptr+2&gt;tok_mem_end) overflow("token"); *(tok_ptr++)=c;}

@&lt;Predeclaration of procedures@&gt;=
int copy_comment();

@ @c
int copy_comment(is_long_comment,bal) /* copies \TEX/ code in comments */
boolean is_long_comment; /* is this a traditional \CEE/ comment? */
int bal; /* brace balance */
{
  char c; /* current character being copied */
  while (1) {
    if (loc&gt;limit) {
      if (is_long_comment) {
        if (get_line()==0) {
          err_print("! Input ended in mid-comment");
@.Input ended in mid-comment@&gt;
          loc=buffer+1; goto done;
        }
      }
      else {
        if (bal&gt;1) err_print("! Missing } in comment");
@.Missing \} in comment@&gt;
        goto done;
      }
    }
    c=*(loc++);
    if (c=='|') return(bal);
    if (is_long_comment) @&lt;Check for end of comment@&gt;;
    if (phase==2) {
      if (ishigh(c)) app_tok(quoted_char);
      app_tok(c);
    }
    @&lt;Copy special things when |c=='@@', '\\'|@&gt;;
    if (c=='{') bal++;
    else if (c=='}') {
      if(bal&gt;1) bal--;
      else {err_print("! Extra } in comment");
@.Extra \} in comment@&gt;
        if (phase==2) tok_ptr--;
      }
    }
  }
done:@&lt;Clear |bal| and |return|@&gt;;
}
@ @&lt;Check for end of comment@&gt;=
if (c=='*' &amp;&amp; *loc=='/') {
  loc++;
  if (bal&gt;1) err_print("! Missing } in comment");
@.Missing \} in comment@&gt;
  goto done;
}
@ @&lt;Copy special things when |c=='@@'...@&gt;=
if (c=='@@') {
  if (*(loc++)!='@@') {
    err_print("! Illegal use of @@ in comment");
@.Illegal use of @@...@&gt;
    loc-=2; if (phase==2) *(tok_ptr-1)=' '; goto done;
  }
}
else if (c=='\\' &amp;&amp; *loc!='@@')
  if (phase==2) app_tok(*(loc++)) else loc++;
@ We output enough right braces to keep \TEX/ happy.

@&lt;Clear |bal| and |return|@&gt;=
if (phase==2) while (bal-- &gt;0) app_tok('}');
return(0);
@** Parsing.
The most intricate part of \.{CWEAVE} is its mechanism for converting
\CEE/-like code into \TEX/ code, and we might as well plunge into this
aspect of the program now. A ``bottom up'' approach is used to parse the
\CEE/-like material, since \.{CWEAVE} must deal with fragmentary
constructions whose overall ``part of speech'' is not known.

At the lowest level, the input is represented as a sequence of entities
that we shall call {\it scraps}, where each scrap of information consists
of two parts, its {\it category} and its {\it translation}. The category
is essentially a syntactic class, and the translation is a token list that
represents \TEX/ code. Rules of syntax and semantics tell us how to
combine adjacent scraps into larger ones, and if we are lucky an entire
\CEE/ text that starts out as hundreds of small scraps will join
together into one gigantic scrap whose translation is the desired \TEX/
code. If we are unlucky, we will be left with several scraps that don't
combine; their translations will simply be output, one by one.

The combination rules are given as context-sensitive productions that are
applied from left to right. Suppose that we are currently working on the
sequence of scraps $s_1\,s_2\ldots s_n$. We try first to find the longest
production that applies to an initial substring $s_1\,s_2\ldots\,$; but if
no such productions exist, we try to find the longest production
applicable to the next substring $s_2\,s_3\ldots\,$; and if that fails, we
try to match $s_3\,s_4\ldots\,$, etc.

A production applies if the category codes have a given pattern. For
example, one of the productions (see rule~3) is
$$\hbox{|exp| }\left\{\matrix{\hbox{|binop|}\cr\hbox{|ubinop|}}\right\}
\hbox{ |exp| }\RA\hbox{ |exp|}$$
and it means that three consecutive scraps whose respective categories are
|exp|, |binop| (or |ubinop|),
and |exp| are converted to one scrap whose category
is |exp|.  The translations of the original
scraps are simply concatenated.  The case of
$$\hbox{|exp| |comma| |exp| $\RA$ |exp|} \hskip4emE_1C\,\\{opt}9\,E_2$$
(rule 4) is only slightly more complicated:
Here the resulting |exp| translation
consists not only of the three original translations, but also of the
tokens |opt| and 9 between the translations of the
|comma| and the following |exp|.
In the \TEX/ file, this will specify an optional line break after the
comma, with penalty 90.

At each opportunity the longest possible production is applied.  For
example, if the current sequence of scraps is |int_like| |cast|
|lbrace|, rule 31 is applied; but if the sequence is |int_like| |cast|
followed by anything other than |lbrace|, rule 32 takes effect.

Translation rules such as `$E_1C\,\\{opt}9\,E_2$' above use subscripts
to distinguish between translations of scraps whose categories have the
same initial letter; these subscripts are assigned from left to right.@ Here is a list of the category codes that scraps can have. (A few others, like |int_like|, have already been defined; the |cat_name| array contains a complete list.)

@d exp 1 /* denotes an expression, including perhaps a single identifier */
@d unop 2 /* denotes a unary operator */
@d binop 3 /* denotes a binary operator */
@d ubinop 4
  /* denotes an operator that can be unary or binary, depending on context */
@d cast 5 /* denotes a cast */
@d question 6 /* denotes a question mark and possibly the expressions flanking it */
@d lbrace 7 /* denotes a left brace */
@d rbrace 8 /* denotes a right brace */
@d decl_head 9 /* denotes an incomplete declaration */
@d comma 10 /* denotes a comma */
@d lpar 11 /* denotes a left parenthesis or left bracket */
@d rpar 12 /* denotes a right parenthesis or right bracket */
@d prelangle 13 /* denotes `$&lt;$' before we know what it is */
@d prerangle 14 /* denotes `$&gt;$' before we know what it is */
@d langle 15 /* denotes `$&lt;$' when it's used as angle bracket in a template */
@d colcol 18 /* denotes `::' */
@d base 19 /* denotes a colon that introduces a base specifier */
@d decl 20 /* denotes a complete declaration */
@d struct_head 21 /* denotes the beginning of a structure specifier */
@d stmt 23 /* denotes a complete statement */
@d function 24 /* denotes a complete function */
@d fn_decl 25 /* denotes a function declarator */
@d semi 27 /* denotes a semicolon */
@d colon 28 /* denotes a colon */
@d tag 29 /* denotes a statement label */
@d if_head 30 /* denotes the beginning of a compound conditional */
@d else_head 31 /* denotes a prefix for a compound statement */
@d if_clause 32 /* pending \.{if} together with a condition */
@d lproc 35 /* begins a preprocessor command */
@d rproc 36 /* ends a preprocessor command */
@d insert 37 /* a scrap that gets combined with its neighbor */
@d section_scrap 38 /* section name */
@d dead 39 /* scrap that won't combine */
@d ftemplate 59 /* \\{make\_pair} */
@d new_exp 60 /* \&amp;{new} and a following type identifier */
@d begin_arg 61 /* \.{@@[} */
@d end_arg 62 /* \.{@@]} */

@&lt;Global variables@&gt;=
char cat_name[256][12];
eight_bits cat_index;

@ @&lt;Set in...@&gt;=
    for (cat_index=0;cat_index&lt;255;cat_index++)
      strcpy(cat_name[cat_index],"UNKNOWN");
@.UNKNOWN@&gt;
    strcpy(cat_name[exp],"exp");
    strcpy(cat_name[unop],"unop");
    strcpy(cat_name[binop],"binop");
    strcpy(cat_name[ubinop],"ubinop");
    strcpy(cat_name[cast],"cast");
    strcpy(cat_name[question],"?");
    strcpy(cat_name[lbrace],"{"@q}@&gt;);
    strcpy(cat_name[rbrace],@q{@&gt;"}");
    strcpy(cat_name[decl_head],"decl_head");
    strcpy(cat_name[comma],",");
    strcpy(cat_name[lpar],"(");
    strcpy(cat_name[rpar],")");
    strcpy(cat_name[prelangle],"&lt;");
    strcpy(cat_name[prerangle],"&gt;");
    strcpy(cat_name[langle],"\\&lt;");
    strcpy(cat_name[colcol],"::");
    strcpy(cat_name[base],"\\:");
    strcpy(cat_name[decl],"decl");
    strcpy(cat_name[struct_head],"struct_head");
    strcpy(cat_name[alfop],"alfop");
    strcpy(cat_name[stmt],"stmt");
    strcpy(cat_name[function],"function");
    strcpy(cat_name[fn_decl],"fn_decl");
    strcpy(cat_name[else_like],"else_like");
    strcpy(cat_name[semi],";");
    strcpy(cat_name[colon],":");
    strcpy(cat_name[tag],"tag");
    strcpy(cat_name[if_head],"if_head");
    strcpy(cat_name[else_head],"else_head");
    strcpy(cat_name[if_clause],"if()");
    strcpy(cat_name[lproc],"#{"@q}@&gt;);
    strcpy(cat_name[rproc],@q{@&gt;"#}");
    strcpy(cat_name[insert],"insert");
    strcpy(cat_name[section_scrap],"section");
    strcpy(cat_name[dead],"@@d");
    strcpy(cat_name[public_like],"public");
    strcpy(cat_name[operator_like],"operator");
    strcpy(cat_name[new_like],"new");
    strcpy(cat_name[catch_like],"catch");
    strcpy(cat_name[for_like],"for");
    strcpy(cat_name[do_like],"do");
    strcpy(cat_name[if_like],"if");
    strcpy(cat_name[delete_like],"delete");
    strcpy(cat_name[raw_ubin],"ubinop?");
    strcpy(cat_name[const_like],"const");
    strcpy(cat_name[raw_int],"raw");
    strcpy(cat_name[int_like],"int");
    strcpy(cat_name[case_like],"case");
    strcpy(cat_name[sizeof_like],"sizeof");
    strcpy(cat_name[struct_like],"struct");
    strcpy(cat_name[typedef_like],"typedef");
    strcpy(cat_name[define_like],"define");
    strcpy(cat_name[template_like],"template");
    strcpy(cat_name[ftemplate],"ftemplate");
    strcpy(cat_name[new_exp],"new_exp");
    strcpy(cat_name[begin_arg],"@@["@q]@&gt;);
    strcpy(cat_name[end_arg],@q[@&gt;"@@]");
    strcpy(cat_name[0],"zero");
@ This code allows \.{CWEAVE} to display its parsing steps.

@c
void
print_cat(c) /* symbolic printout of a category */
eight_bits c;
{
  printf(cat_name[c]);
}@ The token lists for translated \TEX/ output contain some special control symbols as well as ordinary characters. These control symbols are interpreted by \.{CWEAVE} before they are written to the output file.  \yskip\hang |break_space| denotes an optional line break or an en space;  \yskip\hang |force| denotes a line break;  \yskip\hang |big_force| denotes a line break with additional vertical space;  \yskip\hang |preproc_line| denotes that the line will be printed flush left;  \yskip\hang |opt| denotes an optional line break (with the continuation line indented two ems with respect to the normal starting position)---this code is followed by an integer |n|, and the break will occur with penalty $10n$;  \yskip\hang |backup| denotes a backspace of one em;  \yskip\hang |cancel| obliterates any |break_space|, |opt|, |force|, or |big_force| tokens that immediately precede or follow it and also cancels any |backup| tokens that follow it;  \yskip\hang |indent| causes future lines to be indented one more em;  \yskip\hang |outdent| causes future lines to be indented one less em.  \yskip\noindent All of these tokens are removed from the \TEX/ output that comes from \CEE/ text between \pb\ signs; |break_space| and |force| and |big_force| become single spaces in this mode. The translation of other \CEE/ texts results in \TEX/ control sequences \.{\\1}, \.{\\2}, \.{\\3}, \.{\\4}, \.{\\5}, \.{\\6}, \.{\\7}, \.{\\8} corresponding respectively to |indent|, |outdent|, |opt|, |backup|, |break_space|, |force|, |big_force| and |preproc_line|. However, a sequence of consecutive `\.\ ', |break_space|, |force|, and/or |big_force| tokens is first replaced by a single token (the maximum of the given ones).  The token |math_rel| will be translated into \.{\\MRL\{}, and it will get a matching \.\} later. Other control sequences in the \TEX/ output will be `\.{\\\\\{}$\,\ldots\,$\.\}' surrounding identifiers, `\.{\\\&amp;\{}$\,\ldots\,$\.\}' surrounding reserved words, `\.{\\.\{}$\,\ldots\,$\.\}' surrounding strings, `\.{\\C\{}$\,\ldots\,$\.\}$\,$|force|' surrounding comments, and `\.{\\X$n$:}$\,\ldots\,$\.{\\X}' surrounding section names, where |n| is the section number.

@d math_rel 0206
@d big_cancel 0210 /* like |cancel|, also overrides spaces */
@d cancel 0211 /* overrides |backup|, |break_space|, |force|, |big_force| */
@d indent 0212 /* one more tab (\.{\\1}) */
@d outdent 0213 /* one less tab (\.{\\2}) */
@d opt 0214 /* optional break in mid-statement (\.{\\3}) */
@d backup 0215 /* stick out one unit to the left (\.{\\4}) */
@d break_space 0216 /* optional break between statements (\.{\\5}) */
@d force 0217 /* forced break between statements (\.{\\6}) */
@d big_force 0220 /* forced break with additional space (\.{\\7}) */
@d preproc_line 0221 /* begin line without indentation (\.{\\8}) */
@^high-bit character handling@&gt;

@d quoted_char 0222
        /* introduces a character token in the range |0200|--|0377| */
@d end_translation 0223 /* special sentinel token at end of list */
@d inserted 0224 /* sentinel to mark translations of inserts */
@d qualifier 0225 /* introduces an explicit namespace qualifier */
@ The raw input is converted into scraps according to the following table, which gives category codes followed by the translations. \def\stars {\.{**}}% The symbol `\stars' stands for `\.{\\\&amp;\{{\rm identifier}\}}', i.e., the identifier itself treated as a reserved word. The right-hand column is the so-called |mathness|, which is explained further below.  An identifier |c| of length 1 is translated as \.{\\\v c} instead of as \.{\\\\\{c\}}. An identifier \.{CAPS} in all caps is translated as \.{\\.\{CAPS\}} instead of as \.{\\\\\{CAPS\}}. An identifier that has become a reserved word via |typedef| is translated with \.{\\\&amp;} replacing \.{\\\\} and |raw_int| replacing |exp|.  A string of length greater than 20 is broken into pieces of size at most~20 with discretionary breaks in between.  \yskip\halign{\quad#\hfil&amp;\quad#\hfil&amp;\quad\hfil#\hfil\cr \.{!=}&amp;|binop|: \.{\\I}&amp;yes\cr \.{&lt;=}&amp;|binop|: \.{\\Z}&amp;yes\cr \.{&gt;=}&amp;|binop|: \.{\\G}&amp;yes\cr \.{==}&amp;|binop|: \.{\\E}&amp;yes\cr \.{\&amp;\&amp;}&amp;|binop|: \.{\\W}&amp;yes\cr \.{\v\v}&amp;|binop|: \.{\\V}&amp;yes\cr \.{++}&amp;|unop|: \.{\\PP}&amp;yes\cr \.{--}&amp;|unop|: \.{\\MM}&amp;yes\cr \.{-&gt;}&amp;|binop|: \.{\\MG}&amp;yes\cr \.{&gt;&gt;}&amp;|binop|: \.{\\GG}&amp;yes\cr \.{&lt;&lt;}&amp;|binop|: \.{\\LL}&amp;yes\cr \.{::}&amp;|colcol|: \.{\\DC}&amp;maybe\cr \.{.*}&amp;|binop|: \.{\\PA}&amp;yes\cr \.{-&gt;*}&amp;|binop|: \.{\\MGA}&amp;yes\cr \.{...}&amp;|raw_int|: \.{\\,\\ldots\\,}&amp;yes\cr \."string\."&amp;|exp|: \.{\\.\{}string with special characters quoted\.\}&amp;maybe\cr \.{@@=}string\.{@@&gt;}&amp;|exp|: \.{\\vb\{}string with special characters   quoted\.\}&amp;maybe\cr \.{@@'7'}&amp;|exp|: \.{\\.\{@@'7'\}}&amp;maybe\cr \.{077} or \.{\\77}&amp;|exp|: \.{\\T\{\\\~77\}}&amp;maybe\cr \.{0x7f}&amp;|exp|: \.{\\T\{\\\^7f\}}&amp;maybe\cr \.{77}&amp;|exp|: \.{\\T\{77\}}&amp;maybe\cr \.{77L}&amp;|exp|: \.{\\T\{77\\\$L\}}&amp;maybe\cr \.{0.1E5}&amp;|exp|: \.{\\T\{0.1\\\_5\}}&amp;maybe\cr \.+&amp;|ubinop|: \.+&amp;yes\cr \.-&amp;|ubinop|: \.-&amp;yes\cr \.*&amp;|raw_ubin|: \.*&amp;yes\cr \./&amp;|binop|: \./&amp;yes\cr \.&lt;&amp;|prelangle|: \.{\\langle}&amp;yes\cr \.=&amp;|binop|: \.{\\K}&amp;yes\cr \.&gt;&amp;|prerangle|: \.{\\rangle}&amp;yes\cr \..&amp;|binop|: \..&amp;yes\cr \.{\v}&amp;|binop|: \.{\\OR}&amp;yes\cr \.\^&amp;|binop|: \.{\\XOR}&amp;yes\cr \.\%&amp;|binop|: \.{\\MOD}&amp;yes\cr \.?&amp;|question|: \.{\\?}&amp;yes\cr \.!&amp;|unop|: \.{\\R}&amp;yes\cr \.\~&amp;|unop|: \.{\\CM}&amp;yes\cr \.\&amp;&amp;|raw_ubin|: \.{\\AND}&amp;yes\cr \.(&amp;|lpar|: \.(&amp;maybe\cr \.[&amp;|lpar|: \.[&amp;maybe\cr \.)&amp;|rpar|: \.)&amp;maybe\cr \.]&amp;|rpar|: \.]&amp;maybe\cr \.\{&amp;|lbrace|: \.\{&amp;yes\cr \.\}&amp;|lbrace|: \.\}&amp;yes\cr \.,&amp;|comma|: \.,&amp;yes\cr \.;&amp;|semi|: \.;&amp;maybe\cr \.:&amp;|colon|: \.:&amp;no\cr \.\# (within line)&amp;|ubinop|: \.{\\\#}&amp;yes\cr \.\# (at beginning)&amp;|lproc|:  |force| |preproc_line| \.{\\\#}&amp;no\cr end of \.\# line&amp;|rproc|:  |force|&amp;no\cr identifier&amp;|exp|: \.{\\\\\{}identifier with underlines and              dollar signs quoted\.\}&amp;maybe\cr \.{and}&amp;|alfop|: \stars&amp;yes\cr \.{and\_eq}&amp;|alfop|: \stars&amp;yes\cr \.{asm}&amp;|sizeof_like|: \stars&amp;maybe\cr \.{auto}&amp;|int_like|: \stars&amp;maybe\cr \.{bitand}&amp;|alfop|: \stars&amp;yes\cr \.{bitor}&amp;|alfop|: \stars&amp;yes\cr \.{bool}&amp;|raw_int|: \stars&amp;maybe\cr \.{break}&amp;|case_like|: \stars&amp;maybe\cr \.{case}&amp;|case_like|: \stars&amp;maybe\cr \.{catch}&amp;|catch_like|: \stars&amp;maybe\cr \.{char}&amp;|raw_int|: \stars&amp;maybe\cr \.{class}&amp;|struct_like|: \stars&amp;maybe\cr \.{clock\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{compl}&amp;|alfop|: \stars&amp;yes\cr \.{const}&amp;|const_like|: \stars&amp;maybe\cr \.{const\_cast}&amp;|raw_int|: \stars&amp;maybe\cr \.{continue}&amp;|case_like|: \stars&amp;maybe\cr \.{default}&amp;|case_like|: \stars&amp;maybe\cr \.{define}&amp;|define_like|: \stars&amp;maybe\cr \.{defined}&amp;|sizeof_like|: \stars&amp;maybe\cr \.{delete}&amp;|delete_like|: \stars&amp;maybe\cr \.{div\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{do}&amp;|do_like|: \stars&amp;maybe\cr \.{double}&amp;|raw_int|: \stars&amp;maybe\cr \.{dynamic\_cast}&amp;|raw_int|: \stars&amp;maybe\cr \.{elif}&amp;|if_like|: \stars&amp;maybe\cr \.{else}&amp;|else_like|: \stars&amp;maybe\cr \.{endif}&amp;|if_like|: \stars&amp;maybe\cr \.{enum}&amp;|struct_like|: \stars&amp;maybe\cr \.{error}&amp;|if_like|: \stars&amp;maybe\cr \.{explicit}&amp;|int_like|: \stars&amp;maybe\cr \.{export}&amp;|int_like|: \stars&amp;maybe\cr \.{extern}&amp;|int_like|: \stars&amp;maybe\cr \.{FILE}&amp;|raw_int|: \stars&amp;maybe\cr \.{float}&amp;|raw_int|: \stars&amp;maybe\cr \.{for}&amp;|for_like|: \stars&amp;maybe\cr \.{fpos\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{friend}&amp;|int_like|: \stars&amp;maybe\cr \.{goto}&amp;|case_like|: \stars&amp;maybe\cr \.{if}&amp;|if_like|: \stars&amp;maybe\cr \.{ifdef}&amp;|if_like|: \stars&amp;maybe\cr \.{ifndef}&amp;|if_like|: \stars&amp;maybe\cr \.{include}&amp;|if_like|: \stars&amp;maybe\cr \.{inline}&amp;|int_like|: \stars&amp;maybe\cr \.{int}&amp;|raw_int|: \stars&amp;maybe\cr \.{jmp\_buf}&amp;|raw_int|: \stars&amp;maybe\cr \.{ldiv\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{line}&amp;|if_like|: \stars&amp;maybe\cr \.{long}&amp;|raw_int|: \stars&amp;maybe\cr \.{make\_pair}&amp;|ftemplate|: \.{\\\\\{make\\\_pair\}}&amp;maybe\cr \.{mutable}&amp;|int_like|: \stars&amp;maybe\cr \.{namespace}&amp;|struct_like|: \stars&amp;maybe\cr \.{new}&amp;|new_like|: \stars&amp;maybe\cr \.{not}&amp;|alfop|: \stars&amp;yes\cr \.{not\_eq}&amp;|alfop|: \stars&amp;yes\cr \.{NULL}&amp;|exp|: \.{\\NULL}&amp;yes\cr \.{offsetof}&amp;|raw_int|: \stars&amp;maybe\cr \.{operator}&amp;|operator_like|: \stars&amp;maybe\cr \.{or}&amp;|alfop|: \stars&amp;yes\cr \.{or\_eq}&amp;|alfop|: \stars&amp;yes\cr \.{pragma}&amp;|if_like|: \stars&amp;maybe\cr \.{private}&amp;|public_like|: \stars&amp;maybe\cr \.{protected}&amp;|public_like|: \stars&amp;maybe\cr \.{ptrdiff\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{public}&amp;|public_like|: \stars&amp;maybe\cr \.{register}&amp;|int_like|: \stars&amp;maybe\cr \.{reinterpret\_cast}&amp;|raw_int|: \stars&amp;maybe\cr \.{return}&amp;|case_like|: \stars&amp;maybe\cr \.{short}&amp;|raw_int|: \stars&amp;maybe\cr \.{sig\_atomic\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{signed}&amp;|raw_int|: \stars&amp;maybe\cr \.{size\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{sizeof}&amp;|sizeof_like|: \stars&amp;maybe\cr \.{static}&amp;|int_like|: \stars&amp;maybe\cr \.{static\_cast}&amp;|raw_int|: \stars&amp;maybe\cr \.{struct}&amp;|struct_like|: \stars&amp;maybe\cr \.{switch}&amp;|for_like|: \stars&amp;maybe\cr \.{template}&amp;|template_like|: \stars&amp;maybe\cr \.{TeX}&amp;|exp|: \.{\\TeX}&amp;yes\cr \.{this}&amp;|exp|: \.{\\this}&amp;yes\cr \.{throw}&amp;|case_like|: \stars&amp;maybe\cr \.{time\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{try}&amp;|else_like|: \stars&amp;maybe\cr \.{typedef}&amp;|typedef_like|: \stars&amp;maybe\cr \.{typeid}&amp;|raw_int|: \stars&amp;maybe\cr \.{typename}&amp;|struct_like|: \stars&amp;maybe\cr \.{undef}&amp;|if_like|: \stars&amp;maybe\cr \.{union}&amp;|struct_like|: \stars&amp;maybe\cr \.{unsigned}&amp;|raw_int|: \stars&amp;maybe\cr \.{using}&amp;|int_like|: \stars&amp;maybe\cr \.{va\_dcl}&amp;|decl|: \stars&amp;maybe\cr \.{va\_list}&amp;|raw_int|: \stars&amp;maybe\cr \.{virtual}&amp;|int_like|: \stars&amp;maybe\cr \.{void}&amp;|raw_int|: \stars&amp;maybe\cr \.{volatile}&amp;|const_like|: \stars&amp;maybe\cr \.{wchar\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{while}&amp;|for_like|: \stars&amp;maybe\cr \.{xor}&amp;|alfop|: \stars&amp;yes\cr \.{xor\_eq}&amp;|alfop|: \stars&amp;yes\cr \.{@@,}&amp;|insert|: \.{\\,}&amp;maybe\cr \.{@@\v}&amp;|insert|:  |opt| \.0&amp;maybe\cr \.{@@/}&amp;|insert|:  |force|&amp;no\cr \.{@@\#}&amp;|insert|:  |big_force|&amp;no\cr \.{@@+}&amp;|insert|:  |big_cancel| \.{\{\}} |break_space|   \.{\{\}} |big_cancel|&amp;no\cr \.{@@;}&amp;|semi|: &amp;maybe\cr \.{@@[@q]@&gt;}&amp;|begin_arg|: &amp;maybe\cr \.{@q[@&gt;@@]}&amp;|end_arg|: &amp;maybe\cr \.{@@\&amp;}&amp;|insert|: \.{\\J}&amp;maybe\cr \.{@@h}&amp;|insert|: |force| \.{\\ATH} |force|&amp;no\cr \.{@

@&lt;}\thinspace section name\thinspace\.{@@&gt;}&amp;|section_scrap|:
 \.{\\X}$n$\.:translated section name\.{\\X}&amp;maybe\cr
\.{@@(@q)@&gt;}\thinspace section name\thinspace\.{@@&gt;}&amp;|section_scrap|:
 \.{\\X}$n$\.{:\\.\{}section name with special characters
      quoted\.{\ \}\\X}&amp;maybe\cr
\.{/*}comment\.{*/}&amp;|insert|: |cancel|
      \.{\\C\{}translated comment\.\} |force|&amp;no\cr
\.{//}comment&amp;|insert|: |cancel|
      \.{\\SHC\{}translated comment\.\} |force|&amp;no\cr
}

\smallskip
The construction \.{@@t}\thinspace stuff\/\thinspace\.{@@&gt;} contributes
\.{\\hbox\{}\thinspace  stuff\/\thinspace\.\} to the following scrap.

@i prod.w
@* Implementing the productions. More specifically, a scrap is a structure consisting of a category |cat| and a |text_pointer| |trans|, which points to the translation in |tok_start|.  When \CEE/ text is to be processed with the grammar above, we form an array |scrap_info| containing the initial scraps. Our production rules have the nice property that the right-hand side is never longer than the left-hand side. Therefore it is convenient to use sequential allocation for the current sequence of scraps. Five pointers are used to manage the parsing:  \yskip\hang |pp| is a pointer into |scrap_info|.  We will try to match the category codes |pp-&gt;cat,@,@,(pp+1)-&gt;cat|$,\,\,\ldots\,$ to the left-hand sides of productions.  \yskip\hang |scrap_base|, |lo_ptr|, |hi_ptr|, and |scrap_ptr| are such that the current sequence of scraps appears in positions |scrap_base| through |lo_ptr| and |hi_ptr| through |scrap_ptr|, inclusive, in the |cat| and |trans| arrays. Scraps located between |scrap_base| and |lo_ptr| have been examined, while those in positions |&gt;=hi_ptr| have not yet been looked at by the parsing process.  \yskip\noindent Initially |scrap_ptr| is set to the position of the final scrap to be parsed, and it doesn't change its value. The parsing process makes sure that |lo_ptr&gt;=pp+3|, since productions have as many as four terms, by moving scraps from |hi_ptr| to |lo_ptr|. If there are fewer than |pp+3| scraps left, the positions up to |pp+3| are filled with blanks that will not match in any productions. Parsing stops when |pp==lo_ptr+1| and |hi_ptr==scrap_ptr+1|.  Since the |scrap| structure will later be used for other purposes, we declare its second element as a union.

@&lt;Typedef declarations@&gt;=
typedef struct {
  eight_bits cat;
  eight_bits mathness;
  union {
    text_pointer Trans;
    @&lt;Rest of |trans_plus| union@&gt;@;
  } trans_plus;
} scrap;
typedef scrap *scrap_pointer;@ @d trans trans_plus.Trans /* translation texts of scraps */

@&lt;Global variables@&gt;=
scrap scrap_info[max_scraps]; /* memory array for scraps */
scrap_pointer scrap_info_end=scrap_info+max_scraps -1; /* end of |scrap_info| */
scrap_pointer pp; /* current position for reducing productions */
scrap_pointer scrap_base; /* beginning of the current scrap sequence */
scrap_pointer scrap_ptr; /* ending of the current scrap sequence */
scrap_pointer lo_ptr; /* last scrap that has been examined */
scrap_pointer hi_ptr; /* first scrap that has not been examined */
scrap_pointer max_scr_ptr; /* largest value assumed by |scrap_ptr| */

@ @&lt;Set init...@&gt;=
scrap_base=scrap_info+1;
max_scr_ptr=scrap_ptr=scrap_info;
@ Token lists in |@!tok_mem| are composed of the following kinds of items for \TEX/ output.  \yskip\item{$\bullet$}Character codes and special codes like |force| and |math_rel| represent themselves;  \item{$\bullet$}|id_flag+p| represents \.{\\\\\{{\rm identifier $p$}\}};  \item{$\bullet$}|res_flag+p| represents \.{\\\&amp;\{{\rm identifier $p$}\}};  \item{$\bullet$}|section_flag+p| represents section name |p|;  \item{$\bullet$}|tok_flag+p| represents token list number |p|;  \item{$\bullet$}|inner_tok_flag+p| represents token list number |p|, to be translated without line-break controls.

@d id_flag 10240 /* signifies an identifier */
@d res_flag 2*id_flag /* signifies a reserved word */
@d section_flag 3*id_flag /* signifies a section name */
@d tok_flag 4*id_flag /* signifies a token list */
@d inner_tok_flag 5*id_flag /* signifies a token list in `\pb' */

@c
void
print_text(p) /* prints a token list for debugging; not used in |main| */
text_pointer p;
{
  token_pointer j; /* index into |tok_mem| */
  sixteen_bits r; /* remainder of token after the flag has been stripped off */
  if (p&gt;=text_ptr) printf("BAD");
  else for (j=*p; j&lt;*(p+1); j++) {
    r=*j%id_flag;
    switch (*j/id_flag) {
      case 1: printf("\\\\{"@q}@&gt;); print_id((name_dir+r)); printf(@q{@&gt;"}");
        break; /* |id_flag| */
      case 2: printf("\\&amp;{"@q}@&gt;); print_id((name_dir+r)); printf(@q{@&gt;"}");
        break; /* |res_flag| */
      case 3: printf("&lt;"); print_section_name((name_dir+r)); printf("&gt;");
        break; /* |section_flag| */
      case 4: printf("[[%d]]",r); break; /* |tok_flag| */
      case 5: printf("|[[%d]]|",r); break; /* |inner_tok_flag| */
      default: @&lt;Print token |r| in symbolic form@&gt;;
    }
  }
  fflush(stdout);
}@ @&lt;Print token |r|...@&gt;=
switch (r) {
  case math_rel: printf("\\mathrel{"@q}@&gt;); break;
  case big_cancel: printf("[ccancel]"); break;
  case cancel: printf("[cancel]"); break;
  case indent: printf("[indent]"); break;
  case outdent: printf("[outdent]"); break;
  case backup: printf("[backup]"); break;
  case opt: printf("[opt]"); break;
  case break_space: printf("[break]"); break;
  case force: printf("[force]"); break;
  case big_force: printf("[fforce]"); break;
  case preproc_line: printf("[preproc]"); break;
  case quoted_char: j++; printf("[%o]",(unsigned)*j); break;
  case end_translation: printf("[quit]"); break;
  case inserted: printf("[inserted]"); break;
  default: putxchar(r);
}
@ The production rules listed above are embedded directly into \.{CWEAVE}, since it is easier to do this than to write an interpretive system that would handle production systems in general. Several macros are defined here so that the program for each production is fairly short.  All of our productions conform to the general notion that some |k| consecutive scraps starting at some position |j| are to be replaced by a single scrap of some category |c| whose translation is composed from the translations of the disappearing scraps. After this production has been applied, the production pointer |pp| should change by an amount |d|. Such a production can be represented by the quadruple |(j,k,c,d)|. For example, the production `|exp@,comma@,exp| $\RA$ |exp|' would be represented by `|(pp,3,exp,-2)|'; in this case the pointer |pp| should decrease by 2 after the production has been applied, because some productions with |exp| in their second or third positions might now match, but no productions have |exp| in the fourth position of their left-hand sides. Note that the value of |d| is determined by the whole collection of productions, not by an individual one. The determination of |d| has been done by hand in each case, based on the full set of productions but not on the grammar of \CEE/ or on the rules for constructing the initial scraps.  We also attach a serial number to each production, so that additional information is available when debugging. For example, the program below contains the statement `|reduce(pp,3,exp,-2,4)|' when it implements the production just mentioned.  Before calling |reduce|, the program should have appended the tokens of the new translation to the |tok_mem| array. We commonly want to append copies of several existing translations, and macros are defined to simplify these common cases. For example, \\{app2}|(pp)| will append the translations of two consecutive scraps, |pp-&gt;trans| and |(pp+1)-&gt;trans|, to the current token list. If the entire new translation is formed in this way, we write `|squash(j,k,c,d,n)|' instead of `|reduce(j,k,c,d,n)|'. For example, `|squash(pp,3,exp,-2,3)|' is an abbreviation for `\\{app3}|(pp); reduce(pp,3,exp,-2,3)|'.  A couple more words of explanation: Both |big_app| and |app| append a token (while |big_app1| to |big_app4| append the specified number of scrap translations) to the current token list. The difference between |big_app| and |app| is simply that |big_app| checks whether there can be a conflict between math and non-math tokens, and intercalates a `\.{\$}' token if necessary.  When in doubt what to use, use |big_app|.  The |mathness| is an attribute of scraps that says whether they are to be printed in a math mode context or not.  It is separate from the ``part of speech'' (the |cat|) because to make each |cat| have a fixed |mathness| (as in the original \.{WEAVE}) would multiply the number of necessary production rules.  The low two bits (i.e. |mathness % 4|) control the left boundary. (We need two bits because we allow cases |yes_math|, |no_math| and |maybe_math|, which can go either way.) The next two bits (i.e. |mathness / 4|) control the right boundary. If we combine two scraps and the right boundary of the first has a different mathness from the left boundary of the second, we insert a \.{\$} in between.  Similarly, if at printing time some irreducible scrap has a |yes_math| boundary the scrap gets preceded or followed by a \.{\$}. The left boundary is |maybe_math| if and only if the right boundary is.  The code below is an exact translation of the production rules into \CEE/, using such macros, and the reader should have no difficulty understanding the format by comparing the code with the symbolic productions as they were listed earlier.

@d no_math 2 /* should be in horizontal mode */
@d yes_math 1 /* should be in math mode */
@d maybe_math 0 /* works in either horizontal or math mode */
@d big_app2(a) big_app1(a);big_app1(a+1)
@d big_app3(a) big_app2(a);big_app1(a+2)
@d big_app4(a) big_app3(a);big_app1(a+3)
@d app(a) *(tok_ptr++)=a
@d app1(a) *(tok_ptr++)=tok_flag+(int)((a)-&gt;trans-tok_start)

@&lt;Global variables@&gt;=
int cur_mathness, init_mathness;
@ @c
void
app_str(s)
char *s;
{
  while (*s) app_tok(*(s++));
}

void
big_app(a)
token a;
{
        if (a==' ' || (a&gt;=big_cancel &amp;&amp; a&lt;=big_force)) /* non-math token */ {
                if (cur_mathness==maybe_math) init_mathness=no_math;
                else if (cur_mathness==yes_math) app_str("{}$");
                cur_mathness=no_math;
        }
        else {
                if (cur_mathness==maybe_math) init_mathness=yes_math;
                else if (cur_mathness==no_math) app_str("${}");
                cur_mathness=yes_math;
        }
        app(a);
}

void
big_app1(a)
scrap_pointer a;
{
  switch (a-&gt;mathness % 4) { /* left boundary */
  case (no_math):
    if (cur_mathness==maybe_math) init_mathness=no_math;
    else if (cur_mathness==yes_math) app_str("{}$");
    cur_mathness=a-&gt;mathness / 4; /* right boundary */
    break;
  case (yes_math):
    if (cur_mathness==maybe_math) init_mathness=yes_math;
    else if (cur_mathness==no_math) app_str("${}");
    cur_mathness=a-&gt;mathness / 4; /* right boundary */
    break;
  case (maybe_math): /* no changes */ break;
  }
  app(tok_flag+(int)((a)-&gt;trans-tok_start));
}
@ In \CEE/, new specifier names can be defined via |typedef|, and we want to make the parser recognize future occurrences of the identifier thus defined as specifiers.  This is done by the procedure |make_reserved|, which changes the |ilk| of the relevant identifier.  We first need a procedure to recursively seek the first identifier in a token list, because the identifier might be enclosed in parentheses, as when one defines a function returning a pointer.  If the first identifier found is a keyword like `\&amp;{case}', we return the special value |case_found|; this prevents underlining of identifiers in case labels.  If the first identifier is the keyword `\&amp;{operator}', we give up; users who want to index definitions of overloaded \CPLUSPLUS/ operators should say, for example, `\.{@@!@@\^\\\&amp;\{operator\} \$+\{=\}\$@@&gt;}' (or, more properly alphebetized, `\.{@@!@@:operator+=\}\{\\\&amp;\{operator\} \$+\{=\}\$@@&gt;}').

@d no_ident_found (token_pointer)0 /* distinct from any identifier token */
@d case_found (token_pointer)1 /* likewise */
@d operator_found (token_pointer)2 /* likewise */

@c
token_pointer
find_first_ident(p)
text_pointer p;
{
  token_pointer q; /* token to be returned */
  token_pointer j; /* token being looked at */
  sixteen_bits r; /* remainder of token after the flag has been stripped off */
  if (p&gt;=text_ptr) confusion("find_first_ident");
  for (j=*p; j&lt;*(p+1); j++) {
    r=*j%id_flag;
    switch (*j/id_flag) {
      case 2: /* |res_flag| */
        if (name_dir[r].ilk==case_like) return case_found;
        if (name_dir[r].ilk==operator_like) return operator_found;
        if (name_dir[r].ilk!=raw_int) break;
      case 1: return j;
      case 4: case 5: /* |tok_flag| or |inner_tok_flag| */
        if ((q=find_first_ident(tok_start+r))!=no_ident_found)
          return q;
      default: ; /* char, |section_flag|, fall thru: move on to next token */
        if (*j==inserted) return no_ident_found; /* ignore inserts */
        else if (*j==qualifier) j++; /* bypass namespace qualifier */
    }
  }
  return no_ident_found;
}@ The scraps currently being parsed must be inspected for any occurrence of the identifier that we're making reserved; hence the |for| loop below.

@c
void
make_reserved(p) /* make the first identifier in |p-&gt;trans| like |int| */
scrap_pointer p;
{
  sixteen_bits tok_value; /* the name of this identifier, plus its flag*/
  token_pointer tok_loc; /* pointer to |tok_value| */
  if ((tok_loc=find_first_ident(p-&gt;trans))&lt;=operator_found)
    return; /* this should not happen */
  tok_value=*tok_loc;
  for (;p&lt;=scrap_ptr; p==lo_ptr? p=hi_ptr: p++) {
    if (p-&gt;cat==exp) {
      if (**(p-&gt;trans)==tok_value) {
        p-&gt;cat=raw_int;
        **(p-&gt;trans)=tok_value%id_flag+res_flag;
      }
    }
  }
  (name_dir+(sixteen_bits)(tok_value%id_flag))-&gt;ilk=raw_int;
  *tok_loc=tok_value%id_flag+res_flag;
}@ In the following situations we want to mark the occurrence of an identifier as a definition: when |make_reserved| is just about to be used; after a specifier, as in |char **argv|; before a colon, as in \\{found}:; and in the declaration of a function, as in \\{main}()$\{\ldots;\}$.  This is accomplished by the invocation of |make_underlined| at appropriate times.  Notice that, in the declaration of a function, we find out that the identifier is being defined only after it has been swallowed up by an |exp|.

@c
void
make_underlined(p)
/* underline the entry for the first identifier in |p-&gt;trans| */
scrap_pointer p;
{
  token_pointer tok_loc; /* where the first identifier appears */
  if ((tok_loc=find_first_ident(p-&gt;trans))&lt;=operator_found)
    return; /* this happens, for example, in |case found:| */
  xref_switch=def_flag;
  underline_xref(*tok_loc%id_flag+name_dir);
}@ We cannot use |new_xref| to underline a cross-reference at this point because this would just make a new cross-reference at the end of the list. We actually have to search through the list for the existing cross-reference.

@&lt;Predeclaration of procedures@&gt;=
void  underline_xref();

@ @c
void
underline_xref(p)
name_pointer p;
{
  xref_pointer q=(xref_pointer)p-&gt;xref; /* pointer to cross-reference being examined */
  xref_pointer r; /* temporary pointer for permuting cross-references */
  sixteen_bits m; /* cross-reference value to be installed */
  sixteen_bits n; /* cross-reference value being examined */
  if (no_xref) return;
  m=section_count+xref_switch;
  while (q != xmem) {
    n=q-&gt;num;
    if (n==m) return;
    else if (m==n+def_flag) {
        q-&gt;num=m; return;
    }
    else if (n&gt;=def_flag &amp;&amp; n&lt;m) break;
    q=q-&gt;xlink;
  }
  @&lt;Insert new cross-reference at |q|, not at beginning of list@&gt;;
}
@ We get to this section only when the identifier is one letter long, so it didn't get a non-underlined entry during phase one.  But it may have got some explicitly underlined entries in later sections, so in order to preserve the numerical order of the entries in the index, we have to insert the new cross-reference not at the beginning of the list (namely, at |p-&gt;xref|), but rather right before |q|.

@&lt;Insert new cross-reference at |q|, not at beginning of list@&gt;=
  append_xref(0); /* this number doesn't matter */
  xref_ptr-&gt;xlink=(xref_pointer)p-&gt;xref; r=xref_ptr;
  p-&gt;xref=(char*)xref_ptr;
  while (r-&gt;xlink!=q) {r-&gt;num=r-&gt;xlink-&gt;num; r=r-&gt;xlink;}
  r-&gt;num=m; /* everything from |q| on is left undisturbed */
@ Now here's the |reduce| procedure used in our code for productions.  The `|freeze_text|' macro is used to give official status to a token list. Before saying |freeze_text|, items are appended to the current token list, and we know that the eventual number of this token list will be the current value of |text_ptr|. But no list of that number really exists as yet, because no ending point for the current list has been stored in the |tok_start| array. After saying |freeze_text|, the old current token list becomes legitimate, and its number is the current value of |text_ptr-1| since |text_ptr| has been increased. The new current token list is empty and ready to be appended to. Note that |freeze_text| does not check to see that |text_ptr| hasn't gotten too large, since it is assumed that this test was done beforehand.

@d freeze_text *(++text_ptr)=tok_ptr

@c
void
reduce(j,k,c,d,n)
scrap_pointer j;
eight_bits c;
short k, d, n;
{
  scrap_pointer i, i1; /* pointers into scrap memory */
  j-&gt;cat=c; j-&gt;trans=text_ptr;
  j-&gt;mathness=4*cur_mathness+init_mathness;
  freeze_text;
  if (k&gt;1) {
    for (i=j+k, i1=j+1; i&lt;=lo_ptr; i++, i1++) {
      i1-&gt;cat=i-&gt;cat; i1-&gt;trans=i-&gt;trans;
      i1-&gt;mathness=i-&gt;mathness;
    }
    lo_ptr=lo_ptr-k+1;
  }
  pp=(pp+d&lt;scrap_base? scrap_base: pp+d);
  @&lt;Print a snapshot of the scrap list if debugging @&gt;;
  pp--; /* we next say |pp++| */
}@ Here's the |squash| procedure, which takes advantage of the simplification that occurs when |k==1|.

@c
void
squash(j,k,c,d,n)
scrap_pointer j;
eight_bits c;
short k, d, n;
{
  scrap_pointer i; /* pointers into scrap memory */
  if (k==1) {
    j-&gt;cat=c; pp=(pp+d&lt;scrap_base? scrap_base: pp+d);
    @&lt;Print a snapshot...@&gt;;
    pp--; /* we next say |pp++| */
    return;
  }
  for (i=j; i&lt;j+k; i++) big_app1(i);
  reduce(j,k,c,d,n);
}@ If \.{CWEAVE} is being run in debugging mode, the production numbers and current stack categories will be printed out when |tracing| is set to 2; a sequence of two or more irreducible scraps will be printed out when |tracing| is set to 1.

@&lt;Global variables@&gt;=
int tracing; /* can be used to show parsing details */

@ @&lt;Print a snapsh...@&gt;=
{ scrap_pointer k; /* pointer into |scrap_info| */
  if (tracing==2) {
    printf("\n%d:",n);
    for (k=scrap_base; k&lt;=lo_ptr; k++) {
      if (k==pp) putxchar('*'); else putxchar(' ');
      if (k-&gt;mathness %4 ==  yes_math) putchar('+');
      else if (k-&gt;mathness %4 ==  no_math) putchar('-');
      print_cat(k-&gt;cat);
      if (k-&gt;mathness /4 ==  yes_math) putchar('+');
      else if (k-&gt;mathness /4 ==  no_math) putchar('-');
    }
    if (hi_ptr&lt;=scrap_ptr) printf("..."); /* indicate that more is coming */
  }
}
@ The |translate| function assumes that scraps have been stored in positions |scrap_base| through |scrap_ptr| of |cat| and |trans|. It applies productions as much as possible. The result is a token list containing the translation of the given sequence of scraps.  After calling |translate|, we will have |text_ptr+3&lt;=max_texts| and |tok_ptr+6&lt;=max_toks|, so it will be possible to create up to three token lists with up to six tokens without checking for overflow. Before calling |translate|, we should have |text_ptr&lt;max_texts| and |scrap_ptr&lt;max_scraps|, since |translate| might add a new text and a new scrap before it checks for overflow.

@c
text_pointer
translate() /* converts a sequence of scraps */
{
  scrap_pointer i, /* index into |cat| */
  j; /* runs through final scraps */
  pp=scrap_base; lo_ptr=pp-1; hi_ptr=pp;
  @&lt;If tracing, print an indication of where we are@&gt;;
  @&lt;Reduce the scraps...@&gt;;
  @&lt;Combine the irreducible scraps that remain@&gt;;
}@ @&lt;If tracing,...@&gt;=
if (tracing==2) {
  printf("\nTracing after l. %d:\n",cur_line); mark_harmless;
@.Tracing after...@&gt;
  if (loc&gt;buffer+50) {
    printf("...");
    term_write(loc-51,51);
  }
  else term_write(buffer,loc-buffer);
}
@ And here now is the code that applies productions as long as possible. Before applying the production mechanism, we must make sure it has good input (at least four scraps, the length of the lhs of the longest rules), and that there is enough room in the memory arrays to hold the appended tokens and texts.  Here we use a very conservative test; it's more important to make sure the program will still work if we change the production rules (within reason) than to squeeze the last bit of space from the memory arrays.

@d safe_tok_incr 20
@d safe_text_incr 10
@d safe_scrap_incr 10

@&lt;Reduce the scraps using the productions until no more rules apply@&gt;=
while (1) {
  @&lt;Make sure the entries |pp| through |pp+3| of |cat| are defined@&gt;;
  if (tok_ptr+safe_tok_incr&gt;tok_mem_end) {
    if (tok_ptr&gt;max_tok_ptr) max_tok_ptr=tok_ptr;
    overflow("token");
  }
  if (text_ptr+safe_text_incr&gt;tok_start_end) {
    if (text_ptr&gt;max_text_ptr) max_text_ptr=text_ptr;
    overflow("text");
  }
  if (pp&gt;lo_ptr) break;
  init_mathness=cur_mathness=maybe_math;
  @&lt;Match a production...@&gt;;
}
@ If we get to the end of the scrap list, category codes equal to zero are stored, since zero does not match anything in a production.

@&lt;Make sure the entries |pp| through |pp+3| of |cat| are defined@&gt;=
if (lo_ptr&lt;pp+3) {
  while (hi_ptr&lt;=scrap_ptr &amp;&amp; lo_ptr!=pp+3) {
    (++lo_ptr)-&gt;cat=hi_ptr-&gt;cat; lo_ptr-&gt;mathness=(hi_ptr)-&gt;mathness;
    lo_ptr-&gt;trans=(hi_ptr++)-&gt;trans;
  }
  for (i=lo_ptr+1;i&lt;=pp+3;i++) i-&gt;cat=0;
}
@ Let us consider the big switch for productions now, before looking at its context. We want to design the program so that this switch works, so we might as well not keep ourselves in suspense about exactly what code needs to be provided with a proper environment.

@d cat1 (pp+1)-&gt;cat
@d cat2 (pp+2)-&gt;cat
@d cat3 (pp+3)-&gt;cat
@d lhs_not_simple (pp-&gt;cat!=public_like
        &amp;&amp; pp-&gt;cat!=semi
        &amp;&amp; pp-&gt;cat!=prelangle
        &amp;&amp; pp-&gt;cat!=prerangle
        &amp;&amp; pp-&gt;cat!=template_like
        &amp;&amp; pp-&gt;cat!=new_like
        &amp;&amp; pp-&gt;cat!=new_exp
        &amp;&amp; pp-&gt;cat!=ftemplate
        &amp;&amp; pp-&gt;cat!=raw_ubin
        &amp;&amp; pp-&gt;cat!=const_like
        &amp;&amp; pp-&gt;cat!=raw_int
        &amp;&amp; pp-&gt;cat!=operator_like)
 /* not a production with left side length 1 */

@&lt;Match a production at |pp|, or increase |pp| if there is no match@&gt;= {
  if (cat1==end_arg &amp;&amp; lhs_not_simple)
    if (pp-&gt;cat==begin_arg) squash(pp,2,exp,-2,124);
    else squash(pp,2,end_arg,-1,125);
  else if (cat1==insert) squash(pp,2,pp-&gt;cat,-2,0);
  else if (cat2==insert) squash(pp+1,2,(pp+1)-&gt;cat,-1,0);
  else if (cat3==insert) squash(pp+2,2,(pp+2)-&gt;cat,0,0);
  else
  switch (pp-&gt;cat) {
    case exp: @&lt;Cases for |exp|@&gt;; @+break;
    case lpar: @&lt;Cases for |lpar|@&gt;; @+break;
    case unop: @&lt;Cases for |unop|@&gt;; @+break;
    case ubinop: @&lt;Cases for |ubinop|@&gt;; @+break;
    case binop: @&lt;Cases for |binop|@&gt;; @+break;
    case cast: @&lt;Cases for |cast|@&gt;; @+break;
    case sizeof_like: @&lt;Cases for |sizeof_like|@&gt;; @+break;
    case int_like: @&lt;Cases for |int_like|@&gt;; @+break;
    case public_like: @&lt;Cases for |public_like|@&gt;; @+break;
    case colcol: @&lt;Cases for |colcol|@&gt;; @+break;
    case decl_head: @&lt;Cases for |decl_head|@&gt;; @+break;
    case decl: @&lt;Cases for |decl|@&gt;; @+break;
    case base: @&lt;Cases for |base|@&gt;; @+break;
    case struct_like: @&lt;Cases for |struct_like|@&gt;; @+break;
    case struct_head: @&lt;Cases for |struct_head|@&gt;; @+break;
    case fn_decl: @&lt;Cases for |fn_decl|@&gt;; @+break;
    case function: @&lt;Cases for |function|@&gt;; @+break;
    case lbrace: @&lt;Cases for |lbrace|@&gt;; @+break;
    case if_like: @&lt;Cases for |if_like|@&gt;; @+break;
    case else_like: @&lt;Cases for |else_like|@&gt;; @+break;
    case else_head: @&lt;Cases for |else_head|@&gt;; @+break;
    case if_clause: @&lt;Cases for |if_clause|@&gt;; @+break;
    case if_head: @&lt;Cases for |if_head|@&gt;; @+break;
    case do_like: @&lt;Cases for |do_like|@&gt;; @+break;
    case case_like: @&lt;Cases for |case_like|@&gt;; @+break;
    case catch_like: @&lt;Cases for |catch_like|@&gt;; @+break;
    case tag: @&lt;Cases for |tag|@&gt;; @+break;
    case stmt: @&lt;Cases for |stmt|@&gt;; @+break;
    case semi: @&lt;Cases for |semi|@&gt;; @+break;
    case lproc: @&lt;Cases for |lproc|@&gt;; @+break;
    case section_scrap: @&lt;Cases for |section_scrap|@&gt;; @+break;
    case insert: @&lt;Cases for |insert|@&gt;; @+break;
    case prelangle: @&lt;Cases for |prelangle|@&gt;; @+break;
    case prerangle: @&lt;Cases for |prerangle|@&gt;; @+break;
    case langle: @&lt;Cases for |langle|@&gt;; @+break;
    case template_like: @&lt;Cases for |template_like|@&gt;; @+break;
    case new_like: @&lt;Cases for |new_like|@&gt;; @+break;
    case new_exp: @&lt;Cases for |new_exp|@&gt;; @+break;
    case ftemplate: @&lt;Cases for |ftemplate|@&gt;; @+break;
    case for_like: @&lt;Cases for |for_like|@&gt;; @+break;
    case raw_ubin: @&lt;Cases for |raw_ubin|@&gt;; @+break;
    case const_like: @&lt;Cases for |const_like|@&gt;; @+break;
    case raw_int: @&lt;Cases for |raw_int|@&gt;; @+break;
    case operator_like: @&lt;Cases for |operator_like|@&gt;; @+break;
    case typedef_like: @&lt;Cases for |typedef_like|@&gt;; @+break;
    case delete_like: @&lt;Cases for |delete_like|@&gt;; @+break;
    case question: @&lt;Cases for |question|@&gt;; @+break;
  }
  pp++; /* if no match was found, we move to the right */
}
@ Now comes the code that tries to match each production starting with a particular type of scrap. Whenever a match is discovered, the |squash| or |reduce| macro will cause the appropriate action to be performed, followed by |goto found|.

@&lt;Cases for |exp|@&gt;=
if (cat1==lbrace || cat1==int_like || cat1==decl) {
  make_underlined(pp); big_app1(pp); big_app(indent); app(indent);
  reduce(pp,1,fn_decl,0,1);
}
else if (cat1==unop) squash(pp,2,exp,-2,2);
else if ((cat1==binop || cat1==ubinop) &amp;&amp; cat2==exp)
        squash(pp,3,exp,-2,3);
else if (cat1==comma &amp;&amp; cat2==exp) {
  big_app2(pp);
  app(opt); app('9'); big_app1(pp+2); reduce(pp,3,exp,-2,4);
}
else if (cat1==lpar &amp;&amp; cat2==rpar &amp;&amp; cat3==colon) squash(pp+3,1,base,0,5);
else if (cat1==cast &amp;&amp; cat2==colon) squash(pp+2,1,base,0,5);
else if (cat1==semi) squash(pp,2,stmt,-1,6);
else if (cat1==colon) {
  make_underlined (pp);  squash(pp,2,tag,-1,7);
}
else if (cat1==rbrace) squash(pp,1,stmt,-1,8);
else if (cat1==lpar &amp;&amp; cat2==rpar &amp;&amp; (cat3==const_like || cat3==case_like)) {
  big_app1(pp+2); big_app(' '); big_app1(pp+3); reduce(pp+2,2,rpar,0,9);
}
else if (cat1==cast &amp;&amp; (cat2==const_like || cat2==case_like)) {
  big_app1(pp+1); big_app(' '); big_app1(pp+2); reduce(pp+1,2,cast,0,9);
}
else if (cat1==exp || cat1==cast) squash(pp,2,exp,-2,10);
@ @&lt;Cases for |lpar|@&gt;=
if ((cat1==exp||cat1==ubinop) &amp;&amp; cat2==rpar) squash(pp,3,exp,-2,11);
else if (cat1==rpar) {
  big_app1(pp); app('\\'); app(','); big_app1(pp+1);
@.\\,@&gt;
  reduce(pp,2,exp,-2,12);
}
else if ((cat1==decl_head || cat1==int_like || cat1==cast) &amp;&amp; cat2==rpar)
 squash(pp,3,cast,-2,13);
else if ((cat1==decl_head || cat1==int_like || cat1==exp) &amp;&amp; cat2==comma) {
  big_app3(pp); app(opt); app('9'); reduce(pp,3,lpar,-1,14);
}
else if (cat1==stmt || cat1==decl) {
  big_app2(pp); big_app(' '); reduce(pp,2,lpar,-1,15);
}
@ @&lt;Cases for |unop|@&gt;=
if (cat1==exp || cat1==int_like) squash(pp,2,exp,-2,16);
@ @&lt;Cases for |ubinop|@&gt;=
if (cat1==cast &amp;&amp; cat2==rpar) {
  big_app('{'); big_app1(pp); big_app('}'); big_app1(pp+1);
  reduce(pp,2,cast,-2,17);
}
else if (cat1==exp || cat1==int_like) {
  big_app('{'); big_app1(pp); big_app('}'); big_app1(pp+1);
  reduce(pp,2,cat1,-2,18);
}
else if (cat1==binop) {
  big_app(math_rel); big_app1(pp); big_app('{'); big_app1(pp+1); big_app('}');
  big_app('}'); reduce(pp,2,binop,-1,19);
}
@ @&lt;Cases for |binop|@&gt;=
if (cat1==binop) {
  big_app(math_rel); big_app('{'); big_app1(pp); big_app('}');
  big_app('{'); big_app1(pp+1); big_app('}');
  big_app('}'); reduce(pp,2,binop,-1,20);
}
@ @&lt;Cases for |cast|@&gt;=
if (cat1==lpar) squash(pp,2,lpar,-1,21);
else if (cat1==exp) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,exp,-2,21);
}
else if (cat1==semi) squash(pp,1,exp,-2,22);
@ @&lt;Cases for |sizeof_like|@&gt;=
if (cat1==cast) squash(pp,2,exp,-2,23);
else if (cat1==exp) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,exp,-2,24);
}
@ @&lt;Cases for |int_like|@&gt;=
if (cat1==int_like|| cat1==struct_like) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,cat1,-2,25);
}
else if (cat1==exp &amp;&amp; (cat2==raw_int||cat2==struct_like))
  squash(pp,2,int_like,-2,26);
else if (cat1==exp || cat1==ubinop || cat1==colon) {
  big_app1(pp); big_app(' '); reduce(pp,1,decl_head,-1,27);
}
else if (cat1==semi || cat1==binop) squash(pp,1,decl_head,0,28);
@ @&lt;Cases for |public_like|@&gt;=
if (cat1==colon) squash(pp,2,tag,-1,29);
else squash(pp,1,int_like,-2,30);
@ @&lt;Cases for |colcol|@&gt;=
if (cat1==exp||cat1==int_like) {
  app(qualifier); squash(pp,2,cat1,-2,31);
}@+else if (cat1==colcol) squash(pp,2,colcol,-1,32);
@ @&lt;Cases for |decl_head|@&gt;=
if (cat1==comma) {
  big_app2(pp); big_app(' '); reduce(pp,2,decl_head,-1,33);
}
else if (cat1==ubinop) {
  big_app1(pp); big_app('{'); big_app1(pp+1); big_app('}');
  reduce(pp,2,decl_head,-1,34);
}
else if (cat1==exp &amp;&amp; cat2!=lpar &amp;&amp; cat2!=exp &amp;&amp; cat2!=cast) {
  make_underlined(pp+1); squash(pp,2,decl_head,-1,35);
}
else if ((cat1==binop||cat1==colon) &amp;&amp; cat2==exp &amp;&amp; (cat3==comma ||
    cat3==semi || cat3==rpar))
  squash(pp,3,decl_head,-1,36);
else if (cat1==cast) squash(pp,2,decl_head,-1,37);
else if (cat1==lbrace || cat1==int_like || cat1==decl) {
  big_app1(pp); big_app(indent); app(indent); reduce(pp,1,fn_decl,0,38);
}
else if (cat1==semi) squash(pp,2,decl,-1,39);
@ @&lt;Cases for |decl|@&gt;=
if (cat1==decl) {
  big_app1(pp); big_app(force); big_app1(pp+1);
  reduce(pp,2,decl,-1,40);
}
else if (cat1==stmt || cat1==function) {
  big_app1(pp); big_app(big_force);
  big_app1(pp+1); reduce(pp,2,cat1,-1,41);
}
@ @&lt;Cases for |base|@&gt;=
if (cat1==int_like || cat1==exp) {
  if (cat2==comma) {
    big_app1(pp); big_app(' '); big_app2(pp+1);
    app(opt); app('9'); reduce(pp,3,base,0,42);
  }
  else if (cat2==lbrace) {
    big_app1(pp); big_app(' '); big_app1(pp+1); big_app(' '); big_app1(pp+2);
    reduce(pp,3,lbrace,-2,43);
  }
}
@ @&lt;Cases for |struct_like|@&gt;=
if (cat1==lbrace) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,struct_head,0,44);
}
else if (cat1==exp||cat1==int_like) {
  if (cat2==lbrace || cat2==semi) {
    make_underlined(pp+1); make_reserved(pp+1);
    big_app1(pp); big_app(' '); big_app1(pp+1);
    if (cat2==semi) reduce(pp,2,decl_head,0,45);
    else {
      big_app(' '); big_app1(pp+2);reduce(pp,3,struct_head,0,46);
    }
  }
  else if (cat2==colon) squash(pp+2,1,base,2,47);
  else if (cat2!=base) {
    big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,int_like,-2,48);
  }
}
@ @&lt;Cases for |struct_head|@&gt;=
if ((cat1==decl || cat1==stmt || cat1==function) &amp;&amp; cat2==rbrace) {
  big_app1(pp); big_app(indent); big_app(force); big_app1(pp+1);
  big_app(outdent); big_app(force);  big_app1(pp+2);
  reduce(pp,3,int_like,-2,49);
}
else if (cat1==rbrace) {
  big_app1(pp); app_str("\\,"); big_app1(pp+1);
@.\\,@&gt;
  reduce(pp,2,int_like,-2,50);
}
@ @&lt;Cases for |fn_decl|@&gt;=
if (cat1==decl) {
  big_app1(pp); big_app(force); big_app1(pp+1); reduce(pp,2,fn_decl,0,51);
}
else if (cat1==stmt) {
  big_app1(pp); app(outdent); app(outdent); big_app(force);
  big_app1(pp+1); reduce(pp,2,function,-1,52);
}
@ @&lt;Cases for |function|@&gt;=
if (cat1==function || cat1==decl || cat1==stmt) {
  big_app1(pp); big_app(big_force); big_app1(pp+1); reduce(pp,2,cat1,-1,53);
}
@ @&lt;Cases for |lbrace|@&gt;=
if (cat1==rbrace) {
  big_app1(pp); app('\\'); app(','); big_app1(pp+1);
@.\\,@&gt;
  reduce(pp,2,stmt,-1,54);
}
else if ((cat1==stmt||cat1==decl||cat1==function) &amp;&amp; cat2==rbrace) {
  big_app(force); big_app1(pp);  big_app(indent); big_app(force);
  big_app1(pp+1); big_app(force); big_app(backup);  big_app1(pp+2);
  big_app(outdent); big_app(force); reduce(pp,3,stmt,-1,55);
}
else if (cat1==exp) {
  if (cat2==rbrace) squash(pp,3,exp,-2,56);
  else if (cat2==comma &amp;&amp; cat3==rbrace) squash(pp,4,exp,-2,56);
}
@ @&lt;Cases for |if_like|@&gt;=
if (cat1==exp) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,if_clause,0,57);
}
@ @&lt;Cases for |else_like|@&gt;=
if (cat1==colon) squash(pp+1,1,base,1,58);
else if (cat1==lbrace) squash(pp,1,else_head,0,59);
else if (cat1==stmt) {
  big_app(force); big_app1(pp); big_app(indent); big_app(break_space);
  big_app1(pp+1); big_app(outdent); big_app(force);
  reduce(pp,2,stmt,-1,60);
}
@ @&lt;Cases for |else_head|@&gt;=
if (cat1==stmt || cat1==exp) {
  big_app(force); big_app1(pp); big_app(break_space); app(noop);
  big_app(cancel); big_app1(pp+1); big_app(force);
  reduce(pp,2,stmt,-1,61);
}
@ @&lt;Cases for |if_clause|@&gt;=
if (cat1==lbrace) squash(pp,1,if_head,0,62);
else if (cat1==stmt) {
  if (cat2==else_like) {
    big_app(force); big_app1(pp); big_app(indent); big_app(break_space);
    big_app1(pp+1); big_app(outdent); big_app(force); big_app1(pp+2);
    if (cat3==if_like) {
      big_app(' '); big_app1(pp+3); reduce(pp,4,if_like,0,63);
    }@+else reduce(pp,3,else_like,0,64);
  }
  else squash(pp,1,else_like,0,65);
}
@ @&lt;Cases for |if_head|@&gt;=
if (cat1==stmt || cat1==exp) {
  if (cat2==else_like) {
    big_app(force); big_app1(pp); big_app(break_space); app(noop);
    big_app(cancel); big_app1(pp+1); big_app(force); big_app1(pp+2);
    if (cat3==if_like) {
      big_app(' '); big_app1(pp+3); reduce(pp,4,if_like,0,66);
    }@+else reduce(pp,3,else_like,0,67);
  }
  else squash(pp,1,else_head,0,68);
}
@ @&lt;Cases for |do_like|@&gt;=
if (cat1==stmt &amp;&amp; cat2==else_like &amp;&amp; cat3==semi) {
  big_app1(pp); big_app(break_space); app(noop); big_app(cancel);
  big_app1(pp+1); big_app(cancel); app(noop); big_app(break_space);
  big_app2(pp+2); reduce(pp,4,stmt,-1,69);
}
@ @&lt;Cases for |case_like|@&gt;=
if (cat1==semi) squash(pp,2,stmt,-1,70);
else if (cat1==colon) squash(pp,2,tag,-1,71);
else if (cat1==exp) {
  big_app1(pp); big_app(' ');  big_app1(pp+1);  reduce(pp,2,exp,-2,72);
}
@ @&lt;Cases for |catch_like|@&gt;=
if (cat1==cast || cat1==exp) {
  big_app2(pp); big_app(indent); big_app(indent); reduce(pp,2,fn_decl,0,73);
}
@ @&lt;Cases for |tag|@&gt;=
if (cat1==tag) {
  big_app1(pp); big_app(break_space); big_app1(pp+1); reduce(pp,2,tag,-1,74);
}
else if (cat1==stmt||cat1==decl||cat1==function) {
  big_app(force); big_app(backup); big_app1(pp); big_app(break_space);
  big_app1(pp+1); reduce(pp,2,cat1,-1,75);
}
@ The user can decide at run-time whether short statements should be grouped together on the same line.

@d force_lines flags['f'] /* should each statement be on its own line? */
@&lt;Cases for |stmt|@&gt;=
if (cat1==stmt||cat1==decl||cat1==function) {
  big_app1(pp);
  if (cat1==function) big_app(big_force);
  else if (cat1==decl) big_app(big_force);
  else if (force_lines) big_app(force);
  else big_app(break_space);
  big_app1(pp+1); reduce(pp,2,cat1,-1,76);
}
@ @&lt;Cases for |semi|@&gt;=
big_app(' '); big_app1(pp); reduce(pp,1,stmt,-1,77);
@ @&lt;Cases for |lproc|@&gt;=
if (cat1==define_like) make_underlined(pp+2);
if (cat1==else_like || cat1==if_like ||cat1==define_like)
  squash(pp,2,lproc,0,78);
else if (cat1==rproc) {
  app(inserted); big_app2(pp); reduce(pp,2,insert,-1,79);
} else if (cat1==exp || cat1==function) {
  if (cat2==rproc) {
    app(inserted); big_app1(pp); big_app(' '); big_app2(pp+1);
    reduce(pp,3,insert,-1,80);
  }
  else if (cat2==exp &amp;&amp; cat3==rproc &amp;&amp; cat1==exp) {
    app(inserted); big_app1(pp); big_app(' '); big_app1(pp+1); app_str(" \\5");
@.\\5@&gt;
    big_app2(pp+2); reduce(pp,4,insert,-1,80);
  }
}
@ @&lt;Cases for |section_scrap|@&gt;=
if (cat1==semi) {
  big_app2(pp); big_app(force); reduce(pp,2,stmt,-2,81);
}
else squash(pp,1,exp,-2,82);
@ @&lt;Cases for |insert|@&gt;=
if (cat1)
  squash(pp,2,cat1,0,83);
@ @&lt;Cases for |prelangle|@&gt;=
init_mathness=cur_mathness=yes_math;
app('&lt;'); reduce(pp,1,binop,-2,84);
@ @&lt;Cases for |prerangle|@&gt;=
init_mathness=cur_mathness=yes_math;
app('&gt;'); reduce(pp,1,binop,-2,85);
@ @&lt;Cases for |langle|@&gt;=
if (cat1==prerangle) {
  big_app1(pp); app('\\'); app(','); big_app1(pp+1);
@.\\,@&gt;
  reduce(pp,2,cast,-1,86);
}
else if (cat1==decl_head || cat1==int_like || cat1==exp) {
  if (cat2==prerangle) squash(pp,3,cast,-1,87);
  else if (cat2==comma) {
    big_app3(pp); app(opt); app('9'); reduce(pp,3,langle,0,88);
  }
}
@ @&lt;Cases for |template_like|@&gt;=
if (cat1==exp &amp;&amp; cat2==prelangle) squash(pp+2,1,langle,2,89);
else if (cat1==exp || cat1==raw_int) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,cat1,-2,90);
}@+ else squash(pp,1,raw_int,0,91);
@ @&lt;Cases for |new_like|@&gt;=
if (cat1==lpar &amp;&amp; cat2==exp &amp;&amp; cat3==rpar) squash(pp,4,new_like,0,92);
else if (cat1==cast) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,exp,-2,93);
}
else if (cat1!=lpar) squash(pp,1,new_exp,0,94);
@ @&lt;Cases for |new_exp|@&gt;=
if (cat1==int_like || cat1==const_like) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,new_exp,0,95);
}
else if (cat1==struct_like &amp;&amp; (cat2==exp || cat2==int_like)) {
  big_app1(pp); big_app(' '); big_app1(pp+1); big_app(' ');
  big_app1(pp+2); reduce(pp,3,new_exp,0,96);
}
else if (cat1==raw_ubin) {
  big_app1(pp); big_app('{'); big_app1(pp+1); big_app('}');
  reduce(pp,2,new_exp,0,97);
}
else if (cat1==lpar) squash(pp,1,exp,-2,98);
else if (cat1==exp) {
  big_app1(pp); big_app(' '); reduce(pp,1,exp,-2,98);
}
else if (cat1!=raw_int &amp;&amp; cat1!=struct_like &amp;&amp; cat1!=colcol)
  squash(pp,1,exp,-2,99);
@ @&lt;Cases for |ftemplate|@&gt;=
if (cat1==prelangle) squash(pp+1,1,langle,1,100);
else squash(pp,1,exp,-2,101);
@ @&lt;Cases for |for_like|@&gt;=
if (cat1==exp) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,else_like,-2,102);
}
@ @&lt;Cases for |raw_ubin|@&gt;=
if (cat1==const_like) {
  big_app2(pp); app_str("\\ "); reduce(pp,2,raw_ubin,0,103);
@.\\\ @&gt;
} else squash(pp,1,ubinop,-2,104);
@ @&lt;Cases for |const_like|@&gt;=
squash(pp,1,int_like,-2,105);
@ @&lt;Cases for |raw_int|@&gt;=
if (cat1==prelangle) squash(pp+1,1,langle,1,106);
else if (cat1==colcol) squash(pp,2,colcol,-1,107);
else if (cat1==cast) squash(pp,2,raw_int,0,108);
else if (cat1==lpar) squash(pp,1,exp,-2,109);
else if (cat1!=langle) squash(pp,1,int_like,-3,110);
@ @&lt;Cases for |operator_like|@&gt;=
if (cat1==binop || cat1==unop || cat1==ubinop) {
  if (cat2==binop) break;
  big_app1(pp); big_app('{'); big_app1(pp+1); big_app('}');
  reduce(pp,2,exp,-2,111);
}
else if (cat1==new_like || cat1==delete_like) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,exp,-2,112);
}
else if (cat1==comma) squash(pp,2,exp,-2,113);
else if (cat1!=raw_ubin) squash(pp,1,new_exp,0,114);
@ @&lt;Cases for |typedef_like|@&gt;=
if ((cat1==int_like || cat1==cast) &amp;&amp; (cat2==comma || cat2==semi))
  squash(pp+1,1,exp,-1,115);
else if (cat1==int_like) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,typedef_like,0,116);
}
else if (cat1==exp &amp;&amp; cat2!=lpar &amp;&amp; cat2!=exp &amp;&amp; cat2!=cast) {
  make_underlined(pp+1); make_reserved(pp+1);
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,typedef_like,0,117);
}
else if (cat1==comma) {
  big_app2(pp); big_app(' '); reduce(pp,2,typedef_like,0,118);
}
else if (cat1==semi) squash(pp,2,decl,-1,119);
else if (cat1==ubinop &amp;&amp; (cat2==ubinop || cat2==cast)) {
  big_app('{'); big_app1(pp+1); big_app('}'); big_app1(pp+2);
  reduce(pp+1,2,cat2,0,120);
}
@ @&lt;Cases for |delete_like|@&gt;=
if (cat1==lpar &amp;&amp; cat2==rpar) {
  big_app2(pp); app('\\'); app(','); big_app1(pp+2);
@.\\,@&gt;
  reduce(pp,3,delete_like,0,121);
}
else if (cat1==exp) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,exp,-2,122);
}
@ @&lt;Cases for |question|@&gt;=
if (cat1==exp &amp;&amp; (cat2==colon || cat2==base)) {
  (pp+2)-&gt;mathness=5*yes_math; /* this colon should be in math mode */
  squash(pp,3,binop,-2,123);
}
@ If the initial sequence of scraps does not reduce to a single scrap, we concatenate the translations of all remaining scraps, separated by blank spaces, with dollar signs surrounding the translations of scraps where appropriate.

@&lt;Combine the irreducible scraps that remain@&gt;= {
  @&lt;If semi-tracing, show the irreducible scraps@&gt;;
  for (j=scrap_base; j&lt;=lo_ptr; j++) {
    if (j!=scrap_base) app(' ');
    if (j-&gt;mathness % 4 == yes_math) app('$');
    app1(j);
    if (j-&gt;mathness / 4 == yes_math) app('$');
    if (tok_ptr+6&gt;tok_mem_end) overflow("token");
  }
  freeze_text; return(text_ptr-1);
}
@ @&lt;If semi-tracing, show the irreducible scraps@&gt;=
if (lo_ptr&gt;scrap_base &amp;&amp; tracing==1) {
  printf("\nIrreducible scrap sequence in section %d:",section_count);
@.Irreducible scrap sequence...@&gt;
  mark_harmless;
  for (j=scrap_base; j&lt;=lo_ptr; j++) {
    printf(" "); print_cat(j-&gt;cat);
  }
}
@* Initializing the scraps. If we are going to use the powerful production mechanism just developed, we must get the scraps set up in the first place, given a \CEE/ text. A table of the initial scraps corresponding to \CEE/ tokens appeared above in the section on parsing; our goal now is to implement that table. We shall do this by implementing a subroutine called |C_parse| that is analogous to the |C_xref| routine used during phase one.  Like |C_xref|, the |C_parse| procedure starts with the current value of |next_control| and it uses the operation |next_control=get_next()| repeatedly to read \CEE/ text until encountering the next `\.{\v}' or `\.{/*}', or until |next_control&gt;=format_code|. The scraps corresponding to what it reads are appended into the |cat| and |trans| arrays, and |scrap_ptr| is advanced.

@c
void
C_parse(spec_ctrl) /* creates scraps from \CEE/ tokens */
  eight_bits spec_ctrl;
{
  int count; /* characters remaining before string break */
  while (next_control&lt;format_code || next_control==spec_ctrl) {
    @&lt;Append the scrap appropriate to |next_control|@&gt;;
    next_control=get_next();
    if (next_control=='|' || next_control==begin_comment ||
        next_control==begin_short_comment) return;
  }
}@ The following macro is used to append a scrap whose tokens have just been appended:

@d app_scrap(c,b) {
  (++scrap_ptr)-&gt;cat=(c); scrap_ptr-&gt;trans=text_ptr;
  scrap_ptr-&gt;mathness=5*(b); /* no no, yes yes, or maybe maybe */
  freeze_text;
}
@ @&lt;Append the scr...@&gt;=
@&lt;Make sure that there is room for the new scraps, tokens, and texts@&gt;;
switch (next_control) {
  case section_name:
    app(section_flag+(int)(cur_section-name_dir));
    app_scrap(section_scrap,maybe_math);
    app_scrap(exp,yes_math);@+break;
  case string: case constant: case verbatim: @&lt;Append a string or constant@&gt;;
   @+break;
  case identifier: app_cur_id(1);@+break;
  case TeX_string: @&lt;Append a \TEX/ string, without forming a scrap@&gt;;@+break;
  case '/': case '.':
    app(next_control); app_scrap(binop,yes_math);@+break;
  case '&lt;': app_str("\\langle");@+app_scrap(prelangle,yes_math);@+break;
@.\\langle@&gt;
  case '&gt;': app_str("\\rangle");@+app_scrap(prerangle,yes_math);@+break;
@.\\rangle@&gt;
  case '=': app_str("\\K"); app_scrap(binop,yes_math);@+break;
@.\\K@&gt;
  case '|': app_str("\\OR"); app_scrap(binop,yes_math);@+break;
@.\\OR@&gt;
  case '^': app_str("\\XOR"); app_scrap(binop,yes_math);@+break;
@.\\XOR@&gt;
  case '%': app_str("\\MOD"); app_scrap(binop,yes_math);@+break;
@.\\MOD@&gt;
  case '!': app_str("\\R"); app_scrap(unop,yes_math);@+break;
@.\\R@&gt;
  case '~': app_str("\\CM"); app_scrap(unop,yes_math);@+break;
@.\\CM@&gt;
  case '+': case '-': app(next_control); app_scrap(ubinop,yes_math);@+break;
  case '*': app(next_control); app_scrap(raw_ubin,yes_math);@+break;
  case '&amp;': app_str("\\AND"); app_scrap(raw_ubin,yes_math);@+break;
@.\\AND@&gt;
  case '?': app_str("\\?"); app_scrap(question,yes_math);@+break;
@.\\?@&gt;
  case '#': app_str("\\#"); app_scrap(ubinop,yes_math);@+break;
@.\\\#@&gt;
  case ignore: case xref_roman: case xref_wildcard:
  case xref_typewriter: case noop:@+break;
  case '(': case '[': app(next_control); app_scrap(lpar,maybe_math);@+break;
  case ')': case ']': app(next_control); app_scrap(rpar,maybe_math);@+break;
  case '{': app_str("\\{"@q}@&gt;); app_scrap(lbrace,yes_math);@+break;
@.\\\{@&gt;@q}@&gt;
  case '}': app_str(@q{@&gt;"\\}"); app_scrap(rbrace,yes_math);@+break;
@q{@&gt;@.\\\}@&gt;
  case ',': app(','); app_scrap(comma,yes_math);@+break;
  case ';': app(';'); app_scrap(semi,maybe_math);@+break;
  case ':': app(':'); app_scrap(colon,no_math);@+break;@/
  @t\4@&gt;  @&lt;Cases involving nonstandard characters@&gt;@;
  case thin_space: app_str("\\,"); app_scrap(insert,maybe_math);@+break;
@.\\,@&gt;
  case math_break: app(opt); app_str("0");
    app_scrap(insert,maybe_math);@+break;
  case line_break: app(force); app_scrap(insert,no_math);@+break;
  case left_preproc: app(force); app(preproc_line);
    app_str("\\#"); app_scrap(lproc,no_math);@+break;
@.\\\#@&gt;
  case right_preproc: app(force); app_scrap(rproc,no_math);@+break;
  case big_line_break: app(big_force); app_scrap(insert,no_math);@+break;
  case no_line_break: app(big_cancel); app(noop); app(break_space);
    app(noop); app(big_cancel);
    app_scrap(insert,no_math);@+break;
  case pseudo_semi: app_scrap(semi,maybe_math);@+break;
  case macro_arg_open: app_scrap(begin_arg,maybe_math);@+break;
  case macro_arg_close: app_scrap(end_arg,maybe_math);@+break;
  case join: app_str("\\J"); app_scrap(insert,no_math);@+break;
@.\\J@&gt;
  case output_defs_code: app(force); app_str("\\ATH"); app(force);
    app_scrap(insert,no_math);@+break;
@.\\ATH@&gt;
  default: app(inserted); app(next_control);
    app_scrap(insert,maybe_math);@+break;
}
@ @&lt;Make sure that there is room for the new...@&gt;=
if (scrap_ptr+safe_scrap_incr&gt;scrap_info_end ||
  tok_ptr+safe_tok_incr&gt;tok_mem_end @| ||
  text_ptr+safe_text_incr&gt;tok_start_end) {
  if (scrap_ptr&gt;max_scr_ptr) max_scr_ptr=scrap_ptr;
  if (tok_ptr&gt;max_tok_ptr) max_tok_ptr=tok_ptr;
  if (text_ptr&gt;max_text_ptr) max_text_ptr=text_ptr;
  overflow("scrap/token/text");
}
@ Some nonstandard characters may have entered \.{CWEAVE} by means of standard ones. They are converted to \TEX/ control sequences so that it is possible to keep \.{CWEAVE} from outputting unusual |char| codes.

@&lt;Cases involving nonstandard characters@&gt;=
case not_eq: app_str("\\I");@+app_scrap(binop,yes_math);@+break;
@.\\I@&gt;
case lt_eq: app_str("\\Z");@+app_scrap(binop,yes_math);@+break;
@.\\Z@&gt;
case gt_eq: app_str("\\G");@+app_scrap(binop,yes_math);@+break;
@.\\G@&gt;
case eq_eq: app_str("\\E");@+app_scrap(binop,yes_math);@+break;
@.\\E@&gt;
case and_and: app_str("\\W");@+app_scrap(binop,yes_math);@+break;
@.\\W@&gt;
case or_or: app_str("\\V");@+app_scrap(binop,yes_math);@+break;
@.\\V@&gt;
case plus_plus: app_str("\\PP");@+app_scrap(unop,yes_math);@+break;
@.\\PP@&gt;
case minus_minus: app_str("\\MM");@+app_scrap(unop,yes_math);@+break;
@.\\MM@&gt;
case minus_gt: app_str("\\MG");@+app_scrap(binop,yes_math);@+break;
@.\\MG@&gt;
case gt_gt: app_str("\\GG");@+app_scrap(binop,yes_math);@+break;
@.\\GG@&gt;
case lt_lt: app_str("\\LL");@+app_scrap(binop,yes_math);@+break;
@.\\LL@&gt;
case dot_dot_dot: app_str("\\,\\ldots\\,");@+app_scrap(raw_int,yes_math);
  @+break;
@.\\,@&gt;
@.\\ldots@&gt;
case colon_colon: app_str("\\DC");@+app_scrap(colcol,maybe_math);@+break;
@.\\DC@&gt;
case period_ast: app_str("\\PA");@+app_scrap(binop,yes_math);@+break;
@.\\PA@&gt;
case minus_gt_ast: app_str("\\MGA");@+app_scrap(binop,yes_math);@+break;
@.\\MGA@&gt;
@ The following code must use |app_tok| instead of |app| in order to protect against overflow. Note that |tok_ptr+1&lt;=max_toks| after |app_tok| has been used, so another |app| is legitimate before testing again.  Many of the special characters in a string must be prefixed by `\.\\' so that \TEX/ will print them properly. @^special string characters@&gt;

@&lt;Append a string or constant@&gt;=
count= -1;
if (next_control==constant) app_str("\\T{"@q}@&gt;);
@.\\T@&gt;
else if (next_control==string) {
  count=20; app_str("\\.{"@q}@&gt;);
}
@.\\.@&gt;
else app_str("\\vb{"@q}@&gt;);
@.\\vb@&gt;
while (id_first&lt;id_loc) {
  if (count==0) { /* insert a discretionary break in a long string */
     app_str(@q(@&gt;@q{@&gt;"}\\)\\.{"@q}@&gt;); count=20;
@q(@&gt;@.\\)@&gt;
  }
@^high-bit character handling@&gt;
  if((eight_bits)(*id_first)&gt;0177) {
    app_tok(quoted_char);
    app_tok((eight_bits)(*id_first++));
  }
  else {
    switch (*id_first) {
      case  ' ':case '\\':case '#':case '%':case '$':case '^':
      case '{': case '}': case '~': case '&amp;': case '_': app('\\'); break;
@.\\\ @&gt;
@.\\\\@&gt;
@.\\\#@&gt;
@.\\\%@&gt;
@.\\\$@&gt;
@.\\\^@&gt;
@.\\\{@&gt;@q}@&gt;
@q{@&gt;@.\\\}@&gt;
@.\\\~@&gt;
@.\\\&amp;@&gt;
@.\\\_@&gt;
      case '@@': if (*(id_first+1)=='@@') id_first++;
        else err_print("! Double @@ should be used in strings");
@.Double @@ should be used...@&gt;
    }
    app_tok(*id_first++);
  }
  count--;
}
app(@q{@&gt;'}');
app_scrap(exp,maybe_math);
@ We do not make the \TEX/ string into a scrap, because there is no telling what the user will be putting into it; instead we leave it open, to be picked up by the next scrap. If it comes at the end of a section, it will be made into a scrap when |finish_C| is called.  There's a known bug here, in cases where an adjacent scrap is |prelangle| or |prerangle|. Then the \TEX/ string can disappear when the \.{\\langle} or \.{\\rangle} becomes \.{&lt;} or \.{&gt;}. For example, if the user writes \.{\v x&lt;@@ty@@&gt;\v}, the \TEX/ string \.{\\hbox\{y\}} eventually becomes part of an |insert| scrap, which is combined with a |prelangle| scrap and eventually lost. The best way to work around this bug is probably to enclose the \.{@@t...@@&gt;} in \.{@@[...@@]} so that the \TEX/ string is treated as an expression. @^bug, known@&gt;

@&lt;Append a \TEX/ string, without forming a scrap@&gt;=
app_str("\\hbox{"@q}@&gt;);
@^high-bit character handling@&gt;
while (id_first&lt;id_loc)
  if((eight_bits)(*id_first)&gt;0177) {
    app_tok(quoted_char);
    app_tok((eight_bits)(*id_first++));
  }
  else {
    if (*id_first=='@@') id_first++;
    app_tok(*id_first++);
  }
app(@q{@&gt;'}');
@ The function |app_cur_id| appends the current identifier to the token list; it also builds a new scrap if |scrapping==1|.

@&lt;Predeclaration of procedures@&gt;=
void app_cur_id();

@ @c
void
app_cur_id(scrapping)
boolean scrapping; /* are we making this into a scrap? */
{
  name_pointer p=id_lookup(id_first,id_loc,normal);
  if (p-&gt;ilk&lt;=custom) { /* not a reserved word */
    app(id_flag+(int)(p-name_dir));
    if (scrapping) app_scrap(p-&gt;ilk==func_template? ftemplate: exp,
                             p-&gt;ilk==custom? yes_math: maybe_math);
@.\\NULL@&gt;
  } else {
    app(res_flag+(int)(p-name_dir));
    if (scrapping) {
      if (p-&gt;ilk==alfop) app_scrap(ubinop,yes_math)@;
      else app_scrap(p-&gt;ilk,maybe_math);
    }
  }
}
@ When the `\.{\v}' that introduces \CEE/ text is sensed, a call on |C_translate| will return a pointer to the \TEX/ translation of that text. If scraps exist in |scrap_info|, they are unaffected by this translation process.

@c
text_pointer
C_translate()
{
  text_pointer p; /* points to the translation */
  scrap_pointer save_base; /* holds original value of |scrap_base| */
  save_base=scrap_base; scrap_base=scrap_ptr+1;
  C_parse(section_name); /* get the scraps together */
  if (next_control!='|') err_print("! Missing '|' after C text");
@.Missing '|'...@&gt;
  app_tok(cancel); app_scrap(insert,maybe_math);
        /* place a |cancel| token as a final ``comment'' */
  p=translate(); /* make the translation */
  if (scrap_ptr&gt;max_scr_ptr) max_scr_ptr=scrap_ptr;
  scrap_ptr=scrap_base-1; scrap_base=save_base; /* scrap the scraps */
  return(p);
}@ The |outer_parse| routine is to |C_parse| as |outer_xref| is to |C_xref|: It constructs a sequence of scraps for \CEE/ text until |next_control&gt;=format_code|. Thus, it takes care of embedded comments.  The token list created from within `\pb' brackets is output as an argument to \.{\\PB}, if the user has invoked \.{CWEAVE} with the \.{+e} flag. Although \.{cwebmac} ignores \.{\\PB}, other macro packages might use it to localize the special meaning of the macros that mark up program text.

@d make_pb flags['e']

@c
void
outer_parse() /* makes scraps from \CEE/ tokens and comments */
{
  int bal; /* brace level in comment */
  text_pointer p, q; /* partial comments */
  while (next_control&lt;format_code)
    if (next_control!=begin_comment &amp;&amp; next_control!=begin_short_comment)
      C_parse(ignore);
    else {
      boolean is_long_comment=(next_control==begin_comment);
      @&lt;Make sure that there is room for the new...@&gt;;
      app(cancel); app(inserted);
      if (is_long_comment) app_str("\\C{"@q}@&gt;);
@.\\C@&gt;
      else app_str("\\SHC{"@q}@&gt;);
@.\\SHC@&gt;
      bal=copy_comment(is_long_comment,1); next_control=ignore;
      while (bal&gt;0) {
        p=text_ptr; freeze_text; q=C_translate();
         /* at this point we have |tok_ptr+6&lt;=max_toks| */
        app(tok_flag+(int)(p-tok_start));
        if (make_pb) app_str("\\PB{");
@.\\PB@&gt;
        app(inner_tok_flag+(int)(q-tok_start));
        if (make_pb)  app_tok('}');
        if (next_control=='|') {
          bal=copy_comment(is_long_comment,bal);
          next_control=ignore;
        }
        else bal=0; /* an error has been reported */
      }
      app(force); app_scrap(insert,no_math);
        /* the full comment becomes a scrap */
    }
}@* Output of tokens.
So far our programs have only built up multi-layered token lists in
\.{CWEAVE}'s internal memory; we have to figure out how to get them into
the desired final form. The job of converting token lists to characters in
the \TEX/ output file is not difficult, although it is an implicitly
recursive process. Four main considerations had to be kept in mind when
this part of \.{CWEAVE} was designed.  (a) There are two modes of output:
|outer| mode, which translates tokens like |force| into line-breaking
control sequences, and |inner| mode, which ignores them except that blank
spaces take the place of line breaks. (b) The |cancel| instruction applies
to adjacent token or tokens that are output, and this cuts across levels
of recursion since `|cancel|' occurs at the beginning or end of a token
list on one level. (c) The \TEX/ output file will be semi-readable if line
breaks are inserted after the result of tokens like |break_space| and
|force|.  (d) The final line break should be suppressed, and there should
be no |force| token output immediately after `\.{\\Y\\B}'.@ The output process uses a stack to keep track of what is going on at different ``levels'' as the token lists are being written out. Entries on this stack have three parts:  \yskip\hang |end_field| is the |tok_mem| location where the token list of a particular level will end;  \yskip\hang |tok_field| is the |tok_mem| location from which the next token on a particular level will be read;  \yskip\hang |mode_field| is the current mode, either |inner| or |outer|.  \yskip\noindent The current values of these quantities are referred to quite frequently, so they are stored in a separate place instead of in the |stack| array. We call the current values |cur_end|, |cur_tok|, and |cur_mode|.  The global variable |stack_ptr| tells how many levels of output are currently in progress. The end of output occurs when an |end_translation| token is found, so the stack is never empty except when we first begin the output process.

@d inner 0 /* value of |mode| for \CEE/ texts within \TEX/ texts */
@d outer 1 /* value of |mode| for \CEE/ texts in sections */

@&lt;Typedef declarations@&gt;= typedef int mode;
typedef struct {
  token_pointer end_field; /* ending location of token list */
  token_pointer tok_field; /* present location within token list */
  boolean mode_field; /* interpretation of control tokens */
} output_state;
typedef output_state *stack_pointer;

@ @d cur_end cur_state.end_field /* current ending location in |tok_mem| */
@d cur_tok cur_state.tok_field /* location of next output token in |tok_mem| */
@d cur_mode cur_state.mode_field /* current mode of interpretation */
@d init_stack stack_ptr=stack;cur_mode=outer /* initialize the stack */

@&lt;Global variables@&gt;=
output_state cur_state; /* |cur_end|, |cur_tok|, |cur_mode| */
output_state stack[stack_size]; /* info for non-current levels */
stack_pointer stack_ptr; /* first unused location in the output state stack */
stack_pointer stack_end=stack+stack_size-1; /* end of |stack| */
stack_pointer max_stack_ptr; /* largest value assumed by |stack_ptr| */

@ @&lt;Set init...@&gt;=
max_stack_ptr=stack;
@ To insert token-list |p| into the output, the |push_level| subroutine is called; it saves the old level of output and gets a new one going. The value of |cur_mode| is not changed.

@c
void
push_level(p) /* suspends the current level */
text_pointer p;
{
  if (stack_ptr==stack_end) overflow("stack");
  if (stack_ptr&gt;stack) { /* save current state */
    stack_ptr-&gt;end_field=cur_end;
    stack_ptr-&gt;tok_field=cur_tok;
    stack_ptr-&gt;mode_field=cur_mode;
  }
  stack_ptr++;
  if (stack_ptr&gt;max_stack_ptr) max_stack_ptr=stack_ptr;
  cur_tok=*p; cur_end=*(p+1);
}@ Conversely, the |pop_level| routine restores the conditions that were in force when the current level was begun. This subroutine will never be called when |stack_ptr==1|.

@c
void
pop_level()
{
  cur_end=(--stack_ptr)-&gt;end_field;
  cur_tok=stack_ptr-&gt;tok_field; cur_mode=stack_ptr-&gt;mode_field;
}@ The |get_output| function returns the next byte of output that is not a reference to a token list. It returns the values |identifier| or |res_word| or |section_code| if the next token is to be an identifier (typeset in italics), a reserved word (typeset in boldface), or a section name (typeset by a complex routine that might generate additional levels of output). In these cases |cur_name| points to the identifier or section name in question.

@&lt;Global variables@&gt;=
name_pointer cur_name;

@ @d res_word 0201 /* returned by |get_output| for reserved words */
@d section_code 0200 /* returned by |get_output| for section names */

@c
eight_bits
get_output() /* returns the next token of output */
{
  sixteen_bits a; /* current item read from |tok_mem| */
  restart: while (cur_tok==cur_end) pop_level();
  a=*(cur_tok++);
  if (a&gt;=0400) {
    cur_name=a % id_flag + name_dir;
    switch (a / id_flag) {
      case 2: return(res_word); /* |a==res_flag+cur_name| */
      case 3: return(section_code); /* |a==section_flag+cur_name| */
      case 4: push_level(a % id_flag + tok_start); goto restart;
        /* |a==tok_flag+cur_name| */
      case 5: push_level(a % id_flag + tok_start); cur_mode=inner; goto restart;
        /* |a==inner_tok_flag+cur_name| */
      default: return(identifier); /* |a==id_flag+cur_name| */
    }
  }
  return(a);
}@ The real work associated with token output is done by |make_output|. This procedure appends an |end_translation| token to the current token list, and then it repeatedly calls |get_output| and feeds characters to the output buffer until reaching the |end_translation| sentinel. It is possible for |make_output| to be called recursively, since a section name may include embedded \CEE/ text; however, the depth of recursion never exceeds one level, since section names cannot be inside of section names.  A procedure called |output_C| does the scanning, translation, and output of \CEE/ text within `\pb' brackets, and this procedure uses |make_output| to output the current token list. Thus, the recursive call of |make_output| actually occurs when |make_output| calls |output_C| while outputting the name of a section. @^recursion@&gt;

@c
void
output_C() /* outputs the current token list */
{
  token_pointer save_tok_ptr;
  text_pointer save_text_ptr;
  sixteen_bits save_next_control; /* values to be restored */
  text_pointer p; /* translation of the \CEE/ text */
  save_tok_ptr=tok_ptr; save_text_ptr=text_ptr;
  save_next_control=next_control; next_control=ignore; p=C_translate();
  app(inner_tok_flag+(int)(p-tok_start));
  if (make_pb) {
    out_str("\\PB{"); make_output(); out('}');
@.\\PB@&gt;
  }@+else make_output(); /* output the list */
  if (text_ptr&gt;max_text_ptr) max_text_ptr=text_ptr;
  if (tok_ptr&gt;max_tok_ptr) max_tok_ptr=tok_ptr;
  text_ptr=save_text_ptr; tok_ptr=save_tok_ptr; /* forget the tokens */
  next_control=save_next_control; /* restore |next_control| to original state */
}@ Here is \.{CWEAVE}'s major output handler.

@&lt;Predeclaration of procedures@&gt;=
void make_output();

@ @c
void
make_output() /* outputs the equivalents of tokens */
{
  eight_bits a, /* current output byte */
  b; /* next output byte */
  int c; /* count of |indent| and |outdent| tokens */
  char scratch[longest_name]; /* scratch area for section names */
  char *k, *k_limit; /* indices into |scratch| */
  char *j; /* index into |buffer| */
  char *p; /* index into |byte_mem| */
  char delim; /* first and last character of string being copied */
  char *save_loc, *save_limit; /* |loc| and |limit| to be restored */
  name_pointer cur_section_name; /* name of section being output */
  boolean save_mode; /* value of |cur_mode| before a sequence of breaks */
  app(end_translation); /* append a sentinel */
  freeze_text; push_level(text_ptr-1);
  while (1) {
    a=get_output();
    reswitch: switch(a) {
      case end_translation: return;
      case identifier: case res_word: @&lt;Output an identifier@&gt;; break;
      case section_code: @&lt;Output a section name@&gt;; break;
      case math_rel: out_str("\\MRL{"@q}@&gt;);
@.\\MRL@&gt;
      case noop: case inserted: break;
      case cancel: case big_cancel: c=0; b=a;
        while (1) {
          a=get_output();
          if (a==inserted) continue;
          if ((a&lt;indent &amp;&amp; !(b==big_cancel&amp;&amp;a==' ')) || a&gt;big_force) break;
          if (a==indent) c++; else if (a==outdent) c--;
          else if (a==opt) a=get_output();
        }
        @&lt;Output saved |indent| or |outdent| tokens@&gt;;
        goto reswitch;
      case indent: case outdent: case opt: case backup: case break_space:
      case force: case big_force: case preproc_line:
	  	@&lt;Output a control,look ahead in case of line breaks, possibly |goto reswitch|@&gt;; break;
      case quoted_char: out(*(cur_tok++));
      case qualifier: break;
      default: out(a); /* otherwise |a| is an ordinary character */
    }
  }
}
@ @&lt;Output saved...@&gt;=
  for (;c&gt;0;c--) out_str("\\1");
@.\\1@&gt;
  for (;c&lt;0;c++) out_str("\\2");
@.\\2@&gt;
@ The current mode does not affect the behavior of \.{CWEAVE}'s output routine except when we are outputting control tokens.

@&lt;Output a control...@&gt;=
if (a&lt;break_space || a==preproc_line) {
  if (cur_mode==outer) {
    out('\\'); out(a-cancel+'0');
@.\\1@&gt;
@.\\2@&gt;
@.\\3@&gt;
@.\\4@&gt;
@.\\8@&gt;
    if (a==opt) {
      b=get_output(); /* |opt| is followed by a digit */
      if (b!='0' || force_lines==0) out(b)@;
      else out_str("{-1}"); /* |force_lines| encourages more \.{@@\v} breaks */
    }
  } else if (a==opt) b=get_output(); /* ignore digit following |opt| */
  }
else @&lt;Look ahead for strongest line break, |goto reswitch|@&gt;
@ If several of the tokens |break_space|, |force|, |big_force| occur in a row, possibly mixed with blank spaces (which are ignored), the largest one is used. A line break also occurs in the output file, except at the very end of the translation. The very first line break is suppressed (i.e., a line break that follows `\.{\\Y\\B}').

@&lt;Look ahead for strongest line break, |goto reswitch|@&gt;= {
  b=a; save_mode=cur_mode; c=0;
  while (1) {
    a=get_output();
    if (a==inserted) continue;
    if (a==cancel || a==big_cancel) {
      @&lt;Output saved |indent| or |outdent| tokens@&gt;;
      goto reswitch; /* |cancel| overrides everything */
    }
    if ((a!=' ' &amp;&amp; a&lt;indent) || a==backup || a&gt;big_force) {
      if (save_mode==outer) {
        if (out_ptr&gt;out_buf+3 &amp;&amp; strncmp(out_ptr-3,"\\Y\\B",4)==0)
          goto reswitch;
        @&lt;Output saved |indent| or |outdent| tokens@&gt;;
        out('\\'); out(b-cancel+'0');
@.\\5@&gt;
@.\\6@&gt;
@.\\7@&gt;
        if (a!=end_translation) finish_line();
      }
      else if (a!=end_translation &amp;&amp; cur_mode==inner) out(' ');
      goto reswitch;
    }
    if (a==indent) c++;
    else if (a==outdent) c--;
    else if (a==opt) a=get_output();
    else if (a&gt;b) b=a; /* if |a==' '| we have |a&lt;b| */
  }
}
@ An identifier of length one does not have to be enclosed in braces, and it looks slightly better if set in a math-italic font instead of a (slightly narrower) text-italic font. Thus we output `\.{\\\v}\.{a}' but `\.{\\\\\{aa\}}'.

@&lt;Output an identifier@&gt;=
out('\\');
if (a==identifier) {
  if (cur_name-&gt;ilk==custom &amp;&amp; !doing_format) {
 custom_out:
    for (p=cur_name-&gt;byte_start;p&lt;(cur_name+1)-&gt;byte_start;p++)
      out(*p=='_'? 'x': *p=='$'? 'X': *p);
    break;
  } else if (is_tiny(cur_name)) out('|')@;
@.\\|@&gt;
  else { delim='.';
    for (p=cur_name-&gt;byte_start;p&lt;(cur_name+1)-&gt;byte_start;p++)
      if (xislower(*p)) { /* not entirely uppercase */
         delim='\\'; break;
      }
  out(delim);
  }
@.\\\\@&gt;
@.\\.@&gt;
}@+else if (cur_name-&gt;ilk==alfop) {
  out('X');
  goto custom_out;
}@+else out('&amp;'); /* |a==res_word| */
@.\\\&amp;@&gt;
if (is_tiny(cur_name)) {
  if (isxalpha((cur_name-&gt;byte_start)[0]))
    out('\\');
  out((cur_name-&gt;byte_start)[0]);
}
else out_name(cur_name,1);
@ The remaining part of |make_output| is somewhat more complicated. When we output a section name, we may need to enter the parsing and translation routines, since the name may contain \CEE/ code embedded in \pb\ constructions. This \CEE/ code is placed at the end of the active input buffer and the translation process uses the end of the active |tok_mem| area.

@&lt;Output a section name@&gt;= {
  out_str("\\X");
@.\\X@&gt;
  cur_xref=(xref_pointer)cur_name-&gt;xref;
  if (cur_xref-&gt;num==file_flag) {an_output=1; cur_xref=cur_xref-&gt;xlink;}
  else an_output=0;
  if (cur_xref-&gt;num&gt;=def_flag) {
    out_section(cur_xref-&gt;num-def_flag);
    if (phase==3) {
      cur_xref=cur_xref-&gt;xlink;
      while (cur_xref-&gt;num&gt;=def_flag) {
        out_str(", ");
        out_section(cur_xref-&gt;num-def_flag);
      cur_xref=cur_xref-&gt;xlink;
      }
    }
  }
  else out('0'); /* output the section number, or zero if it was undefined */
  out(':');
  if (an_output) out_str("\\.{"@q}@&gt;);
@.\\.@&gt;
  @&lt;Output the text of the section name@&gt;;
  if (an_output) out_str(@q{@&gt;" }");
  out_str("\\X");
}
@ @&lt;Output the text...@&gt;=
sprint_section_name(scratch,cur_name);
k=scratch;
k_limit=scratch+strlen(scratch);
cur_section_name=cur_name;
while (k&lt;k_limit) {
  b=*(k++);
  if (b=='@@') @&lt;Skip next character, give error if not `\.{@@}'@&gt;;
  if (an_output)
    switch (b) {
 case  ' ':case '\\':case '#':case '%':case '$':case '^':
 case '{': case '}': case '~': case '&amp;': case '_':
    out('\\'); /* falls through */
@.\\\ @&gt;
@.\\\\@&gt;
@.\\\#@&gt;
@.\\\%@&gt;
@.\\\$@&gt;
@.\\\^@&gt;
@.\\\{@&gt;@q}@&gt;
@q{@&gt;@.\\\}@&gt;
@.\\\~@&gt;
@.\\\&amp;@&gt;
@.\\\_@&gt;
 default: out(b);
    }
  else if (b!='|') out(b)
  else {
    @&lt;Copy the \CEE/ text into the |buffer| array@&gt;;
    save_loc=loc; save_limit=limit; loc=limit+2; limit=j+1;
    *limit='|'; output_C();
    loc=save_loc; limit=save_limit;
  }
}
@ @&lt;Skip next char...@&gt;=
if (*k++!='@@') {
  printf("\n! Illegal control code in section name: &lt;");
@.Illegal control code...@&gt;
  print_section_name(cur_section_name); printf("&gt; "); mark_error;
}
@ The \CEE/ text enclosed in \pb\ should not contain `\.{\v}' characters, except within strings. We put a `\.{\v}' at the front of the buffer, so that an error message that displays the whole buffer will look a little bit sensible. The variable |delim| is zero outside of strings, otherwise it equals the delimiter that began the string being copied.

@&lt;Copy the \CEE/ text into the |buffer| array@&gt;=
j=limit+1; *j='|'; delim=0;
while (1) {
  if (k&gt;=k_limit) {
    printf("\n! C text in section name didn't end: &lt;");
@.C text...didn't end@&gt;
    print_section_name(cur_section_name); printf("&gt; "); mark_error; break;
  }
  b=*(k++);
  if (b=='@@' || (b=='\\' &amp;&amp; delim!=0))
     @&lt;Copy a quoted character into the buffer@&gt;
  else {
    if (b=='\'' || b=='"')
      if (delim==0) delim=b;
      else if (delim==b) delim=0;
    if (b!='|' || delim!=0) {
      if (j&gt;buffer+long_buf_size-3) overflow("buffer");
      *(++j)=b;
    }
    else break;
  }
}
@ @&lt;Copy a quoted char...@&gt;= {
  if (j&gt;buffer+long_buf_size-4) overflow("buffer");
  *(++j)=b; *(++j)=*(k++);
}
@** Phase two processing. We have assembled enough pieces of the puzzle in order to be ready to specify the processing in \.{CWEAVE}'s main pass over the source file. Phase two is analogous to phase one, except that more work is involved because we must actually output the \TEX/ material instead of merely looking at the \.{CWEB} specifications.
@&lt;Predeclaration of procedures@&gt;=
void phase_two();

@ @c
void
phase_two() {
reset_input(); if (show_progress) printf("\nWriting the output file...");
@.Writing the output file...@&gt;
section_count=0; format_visible=1; copy_limbo();
finish_line(); flush_buffer(out_buf,0,0); /* insert a blank line, it looks nice */
while (!input_has_ended) @&lt;Translate the current section@&gt;;
}
@ The output file will contain the control sequence \.{\\Y} between non-null sections of a section, e.g., between the \TEX/ and definition parts if both are nonempty. This puts a little white space between the parts when they are printed. However, we don't want \.{\\Y} to occur between two definitions within a single section. The variables |out_line| or |out_ptr| will change if a section is non-null, so the following macros `|save_position|' and `|emit_space_if_needed|' are able to handle the situation:

@d save_position save_line=out_line; save_place=out_ptr
@d emit_space_if_needed if (save_line!=out_line || save_place!=out_ptr)
  out_str("\\Y");
  space_checked=1
@.\\Y@&gt;

@&lt;Global variables@&gt;=
int save_line; /* former value of |out_line| */
char *save_place; /* former value of |out_ptr| */
int sec_depth; /* the integer, if any, following \.{@@*} */
boolean space_checked; /* have we done |emit_space_if_needed|? */
boolean format_visible; /* should the next format declaration be output? */
boolean doing_format=0; /* are we outputting a format declaration? */
boolean group_found=0; /* has a starred section occurred? */

@ @&lt;Translate the current section@&gt;= {
  section_count++;
  @&lt;Output the code for the beginning of a new section@&gt;;
  save_position;
  @&lt;Translate the \TEX/ part of the current section@&gt;;
  @&lt;Translate the definition part of the current section@&gt;;
  @&lt;Translate the \CEE/ part of the current section@&gt;;
  @&lt;Show cross-references to this section@&gt;;
  @&lt;Output the code for the end of a section@&gt;;
}
@ Sections beginning with the \.{CWEB} control sequence `\.{@@\ }' start in the output with the \TEX/ control sequence `\.{\\M}', followed by the section number. Similarly, `\.{@

@*}' sections lead to the control sequence `\.{\\N}'. In this case there's an additional parameter, representing one plus the specified depth, immediately after the \.{\\N}. If the section has changed, we put \.{\\*} just after the section number.

@&lt;Output the code for the beginning of a new section@&gt;=
if (*(loc-1)!='*') out_str("\\M");
@.\\M@&gt;
else {
  while (*loc == ' ') loc++;
  if (*loc=='*') { /* ``top'' level */
    sec_depth = -1;
    loc++;
  }
  else {
    for (sec_depth=0; xisdigit(*loc);loc++)
      sec_depth = sec_depth*10 + (*loc) -'0';
  }
  while (*loc == ' ') loc++; /* remove spaces before group title */
  group_found=1;
  out_str("\\N");
@.\\N@&gt;
  {@+ char s[32];@+sprintf(s,"{%d}",sec_depth+1);@+out_str(s);@+}
  if (show_progress)
  printf("*%d",section_count); update_terminal; /* print a progress report */
}
out_str("{");out_section(section_count); out_str("}");
@ In the \TEX/ part of a section, we simply copy the source text, except that index entries are not copied and \CEE/ text within \pb\ is translated.

@&lt;Translate the \TEX/ part of the current section@&gt;= do {
  next_control=copy_TeX();
  switch (next_control) {
    case '|': init_stack; output_C(); break;
    case '@@': out('@@'); break;
    case TeX_string: case noop:
    case xref_roman: case xref_wildcard: case xref_typewriter:
    case section_name: loc-=2; next_control=get_next(); /* skip to \.{@@&gt;} */
      if (next_control==TeX_string)
        err_print("! TeX string should be in C text only"); break;
@.TeX string should be...@&gt;
    case thin_space: case math_break: case ord:
    case line_break: case big_line_break: case no_line_break: case join:
    case pseudo_semi: case macro_arg_open: case macro_arg_close:
    case output_defs_code:
        err_print("! You can't do that in TeX text"); break;
@.You can't do that...@&gt;
  }
} while (next_control&lt;format_code);
@ When we get to the following code we have |next_control&gt;=format_code|, and the token memory is in its initial empty state.

@&lt;Translate the definition part of the current section@&gt;=
space_checked=0;
while (next_control&lt;=definition) { /* |format_code| or |definition| */
  init_stack;
  if (next_control==definition) @&lt;Start a macro definition@&gt;@;
  else @&lt;Start a format definition@&gt;;
  outer_parse(); finish_C(format_visible); format_visible=1;
  doing_format=0;
}
@ Keeping in line with the conventions of the \CEE/ preprocessor (and otherwise contrary to the rules of \.{CWEB}) we distinguish here between the case that `\.(' immediately follows an identifier and the case that the two are separated by a space.  In the latter case, and if the identifier is not followed by `\.(' at all, the replacement text starts immediately after the identifier.  In the former case, it starts after we scan the matching `\.)'.

@&lt;Start a macro definition@&gt;= {
  if (save_line!=out_line || save_place!=out_ptr || space_checked) app(backup);
  if(!space_checked){emit_space_if_needed;save_position;}
  app_str("\\D"); /* this will produce `\&amp;{define }' */
@.\\D@&gt;
  if ((next_control=get_next())!=identifier)
    err_print("! Improper macro definition");
@.Improper macro definition@&gt;
  else {
    app('$'); app_cur_id(0);
    if (*loc=='(')
  reswitch: switch (next_control=get_next()) {
      case '(': case ',': app(next_control); goto reswitch;
      case identifier: app_cur_id(0); goto reswitch;
      case ')': app(next_control); next_control=get_next(); break;
      default: err_print("! Improper macro definition"); break;
    }
    else next_control=get_next();
    app_str("$ "); app(break_space);
    app_scrap(dead,no_math); /* scrap won't take part in the parsing */
  }
}
@ @&lt;Start a format...@&gt;= {
  doing_format=1;
  if(*(loc-1)=='s' || *(loc-1)=='S') format_visible=0;
  if(!space_checked){emit_space_if_needed;save_position;}
  app_str("\\F"); /* this will produce `\&amp;{format }' */
@.\\F@&gt;
  next_control=get_next();
  if (next_control==identifier) {
    app(id_flag+(int)(id_lookup(id_first, id_loc,normal)-name_dir));
    app(' ');
    app(break_space); /* this is syntactically separate from what follows */
    next_control=get_next();
    if (next_control==identifier) {
      app(id_flag+(int)(id_lookup(id_first, id_loc,normal)-name_dir));
      app_scrap(exp,maybe_math); app_scrap(semi,maybe_math);
      next_control=get_next();
    }
  }
  if (scrap_ptr!=scrap_info+2) err_print("! Improper format definition");
@.Improper format definition@&gt;
}
@ Finally, when the \TEX/ and definition parts have been treated, we have |next_control&gt;=begin_C|. We will make the global variable |this_section| point to the current section name, if it has a name.

@&lt;Global variables@&gt;=
name_pointer this_section; /* the current section name, or zero */

@ @&lt;Translate the \CEE/...@&gt;=
this_section=name_dir;
if (next_control&lt;=section_name) {
  emit_space_if_needed; init_stack;
  if (next_control==begin_C) next_control=get_next();
  else {
    this_section=cur_section;
    @&lt;Check that '=' or '==' follows this section name, and emit the scraps to start the section definition@&gt;;
  }
  while  (next_control&lt;=section_name) {
    outer_parse();
    @&lt;Emit the scrap for a section name if present@&gt;;
  }
  finish_C(1);
}
@ The title of the section and an $\E$ or $\mathrel+\E$ are made into a scrap that should not take part in the parsing.

@&lt;Check that '='...@&gt;=
do next_control=get_next();
  while (next_control=='+'); /* allow optional `\.{+=}' */
if (next_control!='=' &amp;&amp; next_control!=eq_eq)
  err_print("! You need an = sign after the section name");
@.You need an = sign...@&gt;
  else next_control=get_next();
if (out_ptr&gt;out_buf+1 &amp;&amp; *out_ptr=='Y' &amp;&amp; *(out_ptr-1)=='\\') app(backup);
    /* the section name will be flush left */
@.\\Y@&gt;
app(section_flag+(int)(this_section-name_dir));
cur_xref=(xref_pointer)this_section-&gt;xref;
if(cur_xref-&gt;num==file_flag) cur_xref=cur_xref-&gt;xlink;
app_str("${}");
if (cur_xref-&gt;num!=section_count+def_flag) {
  app_str("\\mathrel+"); /*section name is multiply defined*/
  this_section=name_dir; /*so we won't give cross-reference info here*/
}
app_str("\\E"); /* output an equivalence sign */
@.\\E@&gt;
app_str("{}$");
app(force); app_scrap(dead,no_math);
        /* this forces a line break unless `\.{@@+}' follows */
@ @&lt;Emit the scrap...@&gt;=
if (next_control&lt;section_name) {
  err_print("! You can't do that in C text");
@.You can't do that...@&gt;
  next_control=get_next();
}
else if (next_control==section_name) {
  app(section_flag+(int)(cur_section-name_dir));
  app_scrap(section_scrap,maybe_math);
  next_control=get_next();
}
@ Cross references relating to a named section are given after the section ends.

@&lt;Show cross-references to this section@&gt;=
if (this_section&gt;name_dir) {
  cur_xref=(xref_pointer)this_section-&gt;xref;
  if (cur_xref-&gt;num==file_flag){an_output=1;cur_xref=cur_xref-&gt;xlink;}
  else an_output=0;
  if (cur_xref-&gt;num&gt;def_flag)
    cur_xref=cur_xref-&gt;xlink; /* bypass current section number */
  footnote(def_flag); footnote(cite_flag); footnote(0);
}
@ @&lt;Output the code for the end of a section@&gt;=
out_str("\\fi"); finish_line();
@.\\fi@&gt;
flush_buffer(out_buf,0,0); /* insert a blank line, it looks nice */
@ The |footnote| procedure gives cross-reference information about multiply defined section names (if the |flag| parameter is |def_flag|), or about references to a section name (if |flag==cite_flag|), or to its uses (if |flag==0|). It assumes that |cur_xref| points to the first cross-reference entry of interest, and it leaves |cur_xref| pointing to the first element not printed.  Typical outputs: `\.{\\A101.}'; `\.{\\Us 370\\ET1009.}'; `\.{\\As 8, 27\\*\\ETs64.}'.  Note that the output of \.{CWEAVE} is not English-specific; users may supply new definitions for the macros \.{\\A}, \.{\\As}, etc.

@&lt;Predeclaration of procedures@&gt;=
void footnote();

@ @c
void
footnote(flag) /* outputs section cross-references */
sixteen_bits flag;
{
  xref_pointer q; /* cross-reference pointer variable */
  if (cur_xref-&gt;num&lt;=flag) return;
  finish_line(); out('\\');
@.\\A@&gt;
@.\\Q@&gt;
@.\\U@&gt;
  out(flag==0? 'U': flag==cite_flag? 'Q': 'A');
  @&lt;Output all the section numbers on the reference list |cur_xref|@&gt;;
  out('.');
}
@ The following code distinguishes three cases, according as the number of cross-references is one, two, or more than two. Variable |q| points to the first cross-reference, and the last link is a zero.

@&lt;Output all the section numbers on the reference list |cur_xref|@&gt;=
q=cur_xref; if (q-&gt;xlink-&gt;num&gt;flag) out('s'); /* plural */
while (1) {
  out_section(cur_xref-&gt;num-flag);
  cur_xref=cur_xref-&gt;xlink; /* point to the next cross-reference to output */
  if (cur_xref-&gt;num&lt;=flag) break;
  if (cur_xref-&gt;xlink-&gt;num&gt;flag) out_str(", "); /* not the last */
  else {out_str("\\ET"); /* the last */
@.\\ET@&gt;
  if (cur_xref != q-&gt;xlink) out('s'); /* the last of more than two */
  }
}
@ The |finish_C| procedure outputs the translation of the current scraps, preceded by the control sequence `\.{\\B}' and followed by the control sequence `\.{\\par}'. It also restores the token and scrap memories to their initial empty state.  A |force| token is appended to the current scraps before translation takes place, so that the translation will normally end with \.{\\6} or \.{\\7} (the \TEX/ macros for |force| and |big_force|). This \.{\\6} or \.{\\7} is replaced by the concluding \.{\\par} or by \.{\\Y\\par}.

@&lt;Predeclaration of procedures@&gt;=
void finish_C();

@ @c
void
finish_C(visible) /* finishes a definition or a \CEE/ part */
  boolean visible; /* nonzero if we should produce \TEX/ output */
{
  text_pointer p; /* translation of the scraps */
  if (visible) {
    out_str("\\B"); app_tok(force); app_scrap(insert,no_math);
    p=translate();
@.\\B@&gt;
    app(tok_flag+(int)(p-tok_start)); make_output(); /* output the list */
    if (out_ptr&gt;out_buf+1)
      if (*(out_ptr-1)=='\\')
@.\\6@&gt;
@.\\7@&gt;
@.\\Y@&gt;
        if (*out_ptr=='6') out_ptr-=2;
        else if (*out_ptr=='7') *out_ptr='Y';
    out_str("\\par"); finish_line();
  }
  if (text_ptr&gt;max_text_ptr) max_text_ptr=text_ptr;
  if (tok_ptr&gt;max_tok_ptr) max_tok_ptr=tok_ptr;
  if (scrap_ptr&gt;max_scr_ptr) max_scr_ptr=scrap_ptr;
  tok_ptr=tok_mem+1; text_ptr=tok_start+1; scrap_ptr=scrap_info;
    /* forget the tokens and the scraps */
}
@** Phase three processing. We are nearly finished! \.{CWEAVE}'s only remaining task is to write out the index, after sorting the identifiers and index entries.  If the user has set the |no_xref| flag (the \.{-x} option on the command line), just finish off the page, omitting the index, section name list, and table of contents.

@&lt;Predeclaration of procedures@&gt;=
void phase_three();@ @c
void
phase_three() {
if (no_xref) {
  finish_line();
  out_str("\\end");
@.\\end@&gt;
  finish_line();
}
else {
  phase=3; if (show_progress) printf("\nWriting the index...");
@.Writing the index...@&gt;
  finish_line();
  if ((idx_file=fopen(idx_file_name,"w"))==NULL)
    fatal("! Cannot open index file ",idx_file_name);
@.Cannot open index file@&gt;
  if (change_exists) {
    @&lt;Tell about changed sections@&gt;; finish_line(); finish_line();
  }
  out_str("\\inx"); finish_line();
@.\\inx@&gt;
  active_file=idx_file; /* change active file to the index file */
  @&lt;Do the first pass of sorting@&gt;;
  @&lt;Sort and output the index@&gt;;
  finish_line(); fclose(active_file); /* finished with |idx_file| */
  active_file=tex_file; /* switch back to |tex_file| for a tic */
  out_str("\\fin"); finish_line();
@.\\fin@&gt;
  if ((scn_file=fopen(scn_file_name,"w"))==NULL)
    fatal("! Cannot open section file ",scn_file_name);
@.Cannot open section file@&gt;
  active_file=scn_file; /* change active file to section listing file */
  @&lt;Output all the section names@&gt;;
  finish_line(); fclose(active_file); /* finished with |scn_file| */
  active_file=tex_file;
  if (group_found) out_str("\\con");@+else out_str("\\end");
@.\\con@&gt;
@.\\end@&gt;
  finish_line();
  fclose(active_file);
}
if (show_happiness) printf("\nDone.");
check_complete(); /* was all of the change file used? */
}
@ Just before the index comes a list of all the changed sections, including the index section itself.

@&lt;Global variables@&gt;=
sixteen_bits k_section; /* runs through the sections */

@ @&lt;Tell about changed sections@&gt;= {
  /* remember that the index is already marked as changed */
  k_section=0;
  while (!changed_section[++k_section]);
  out_str("\\ch ");
@.\\ch@&gt;
  out_section(k_section);
  while (k_section&lt;section_count) {
    while (!changed_section[++k_section]);
    out_str(", "); out_section(k_section);
  }
  out('.');
}
@ A left-to-right radix sorting method is used, since this makes it easy to adjust the collating sequence and since the running time will be at worst proportional to the total length of all entries in the index. We put the identifiers into 102 different lists based on their first characters. (Uppercase letters are put into the same list as the corresponding lowercase letters, since we want to have `$t&lt;\\{TeX}&lt;\&amp;{to}$'.) The list for character |c| begins at location |bucket[c]| and continues through the |blink| array.

@&lt;Global variables@&gt;=
name_pointer bucket[256];
name_pointer next_name; /* successor of |cur_name| when sorting */
name_pointer blink[max_names]; /* links in the buckets */

@ To begin the sorting, we go through all the hash lists and put each entry having a nonempty cross-reference list into the proper bucket.

@&lt;Do the first pass of sorting@&gt;= {
int c;
for (c=0; c&lt;=255; c++) bucket[c]=NULL;
for (h=hash; h&lt;=hash_end; h++) {
  next_name=*h;
  while (next_name) {
    cur_name=next_name; next_name=cur_name-&gt;link;
    if (cur_name-&gt;xref!=(char*)xmem) {
      c=(eight_bits)((cur_name-&gt;byte_start)[0]);
      if (xisupper(c)) c=tolower(c);
      blink[cur_name-name_dir]=bucket[c]; bucket[c]=cur_name;
    }
  }
}
}
@ During the sorting phase we shall use the |cat| and |trans| arrays from
\.{CWEAVE}'s parsing algorithm and rename them |depth| and |head|. They now
represent a stack of identifier lists for all the index entries that have
not yet been output. The variable |sort_ptr| tells how many such lists are
present; the lists are output in reverse order (first |sort_ptr|, then
|sort_ptr-1|, etc.). The |j|th list starts at |head[j]|, and if the first
|k| characters of all entries on this list are known to be equal we have
|depth[j]==k|.

@ @&lt;Rest of |trans_plus| union@&gt;=
name_pointer Head;

@ @d depth cat /* reclaims memory that is no longer needed for parsing */
@d head trans_plus.Head /* ditto */
@f sort_pointer int
@d sort_pointer scrap_pointer /* ditto */
@d sort_ptr scrap_ptr /* ditto */
@d max_sorts max_scraps /* ditto */

@&lt;Global variables@&gt;=
eight_bits cur_depth; /* depth of current buckets */
char *cur_byte; /* index into |byte_mem| */
sixteen_bits cur_val; /* current cross-reference number */
sort_pointer max_sort_ptr; /* largest value of |sort_ptr| */

@ @&lt;Set init...@&gt;=
max_sort_ptr=scrap_info;

@ The desired alphabetic order is specified by the |collate| array; namely, $|collate|[0]&lt;|collate|[1]&lt;\cdots&lt;|collate|[100]$.

@&lt;Global variables@&gt;=
eight_bits collate[102+128]; /* collation order */
@^high-bit character handling@&gt;

@ We use the order $\hbox{null}&lt;\.\ &lt;\hbox{other characters}&lt;{}$\.\_${}&lt; \.A=\.a&lt;\cdots&lt;\.Z=\.z&lt;\.0&lt;\cdots&lt;\.9.$ Warning: The collation mapping needs to be changed if ASCII code is not being used. @^ASCII code dependencies@&gt; @^high-bit character handling@&gt;  We initialize |collate| by copying a few characters at a time, because some \CEE/ compilers choke on long strings.

@&lt;Set initial values@&gt;=
collate[0]=0;
strcpy(collate+1," \1\2\3\4\5\6\7\10\11\12\13\14\15\16\17");
/* 16 characters + 1 = 17 */
strcpy(collate+17,"\20\21\22\23\24\25\26\27\30\31\32\33\34\35\36\37");
/* 16 characters + 17 = 33 */
strcpy(collate+33,"!\42#$%&amp;'()*+,-./:;&lt;=&gt;?@@[\\]^`{|}~_");
/* 32 characters + 33 = 65 */
strcpy(collate+65,"abcdefghijklmnopqrstuvwxyz0123456789");
/* (26 + 10) characters + 65 = 101 */
strcpy(collate+101,"\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217");
/* 16 characters + 101 = 117 */
strcpy(collate+117,"\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237");
/* 16 characters + 117 = 133 */
strcpy(collate+133,"\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257");
/* 16 characters + 133 = 149 */
strcpy(collate+149,"\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277");
/* 16 characters + 149 = 165 */
strcpy(collate+165,"\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317");
/* 16 characters + 165 = 181 */
strcpy(collate+181,"\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337");
/* 16 characters + 181 = 197 */
strcpy(collate+197,"\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357");
/* 16 characters + 197 = 213 */
strcpy(collate+213,"\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377");
/* 16 characters + 213 = 229 */

@ @&lt;Sort and output...@&gt;=
sort_ptr=scrap_info; unbucket(1);
while (sort_ptr&gt;scrap_info) {
  cur_depth=sort_ptr-&gt;depth;
  if (blink[sort_ptr-&gt;head-name_dir]==0 || cur_depth==infinity)
    @&lt;Output index entries for the list at |sort_ptr|@&gt;@;
  else @&lt;Split the list at |sort_ptr| into further lists@&gt;;
}
@ @&lt;Split the list...@&gt;= {
  eight_bits c;
  next_name=sort_ptr-&gt;head;
  do {
    cur_name=next_name; next_name=blink[cur_name-name_dir];
    cur_byte=cur_name-&gt;byte_start+cur_depth;
    if (cur_byte==(cur_name+1)-&gt;byte_start) c=0; /* hit end of the name */
    else {
      c=(eight_bits) *cur_byte;
      if (xisupper(c)) c=tolower(c);
    }
  blink[cur_name-name_dir]=bucket[c]; bucket[c]=cur_name;
  } while (next_name);
  --sort_ptr; unbucket(cur_depth+1);
}
@ @&lt;Output index...@&gt;= {
  cur_name=sort_ptr-&gt;head;
  do {
    out_str("\\I");
@.\\I@&gt;
    @&lt;Output the name at |cur_name|@&gt;;
    @&lt;Output the cross-references at |cur_name|@&gt;;
    cur_name=blink[cur_name-name_dir];
  } while (cur_name);
  --sort_ptr;
}
@ @&lt;Output the name...@&gt;=
switch (cur_name-&gt;ilk) {
  case normal: case func_template: if (is_tiny(cur_name)) out_str("\\|");
    else {char *j;
      for (j=cur_name-&gt;byte_start;j&lt;(cur_name+1)-&gt;byte_start;j++)
        if (xislower(*j)) goto lowcase;
      out_str("\\."); break;
lowcase: out_str("\\\\");
    }
  break;
@.\\|@&gt;
@.\\.@&gt;
@.\\\\@&gt;
  case wildcard: out_str("\\9");@+ goto not_an_identifier;
@.\\9@&gt;
  case typewriter: out_str("\\.");
@.\\.@&gt;
  case roman: not_an_identifier: out_name(cur_name,0); goto name_done;
  case custom: {char *j; out_str("$\\");
    for (j=cur_name-&gt;byte_start;j&lt;(cur_name+1)-&gt;byte_start;j++)
      out(*j=='_'? 'x': *j=='$'? 'X': *j);
    out('$');
    goto name_done;
    }
  default: out_str("\\&amp;");
@.\\\&amp;@&gt;
}
out_name(cur_name,1);
name_done:@;
@ Section numbers that are to be underlined are enclosed in `\.{\\[}$\,\ldots\,$\.]'.

@&lt;Output the cross-references at |cur_name|@&gt;=
@&lt;Invert the cross-reference list at |cur_name|, making |cur_xref| the head@&gt;;
do {
  out_str(", "); cur_val=cur_xref-&gt;num;
  if (cur_val&lt;def_flag) out_section(cur_val);
  else {out_str("\\["); out_section(cur_val-def_flag); out(']');}
@.\\[@&gt;
  cur_xref=cur_xref-&gt;xlink;
} while (cur_xref!=xmem);
out('.'); finish_line();
@ List inversion is best thought of as popping elements off one stack and pushing them onto another. In this case |cur_xref| will be the head of the stack that we push things onto.

@&lt;Global variables@&gt;=
xref_pointer next_xref, this_xref;
  /* pointer variables for rearranging a list */

@ @&lt;Invert the cross-reference list at |cur_name|, making |cur_xref| the head@&gt;=
this_xref=(xref_pointer)cur_name-&gt;xref; cur_xref=xmem;
do {
  next_xref=this_xref-&gt;xlink; this_xref-&gt;xlink=cur_xref;
  cur_xref=this_xref; this_xref=next_xref;
} while (this_xref!=xmem);
@ @&lt;Output all the section names@&gt;=section_print(root)
@ Procedure |unbucket| goes through the buckets and adds nonempty lists to the stack, using the collating sequence specified in the |collate| array. The parameter to |unbucket| tells the current depth in the buckets. Any two sequences that agree in their first 255 character positions are regarded as identical.

@d infinity 255 /* $\infty$ (approximately) */

@&lt;Predeclaration of procedures@&gt;=
void  unbucket();

@ @c
void
unbucket(d) /* empties buckets having depth |d| */
eight_bits d;
{
  int c;  /* index into |bucket|; cannot be a simple |char| because of sign
    comparison below*/
  for (c=100+128; c&gt;= 0; c--) if (bucket[collate[c]]) {
@^high-bit character handling@&gt;
    if (sort_ptr&gt;=scrap_info_end) overflow("sorting");
    sort_ptr++;
    if (sort_ptr&gt;max_sort_ptr) max_sort_ptr=sort_ptr;
    if (c==0) sort_ptr-&gt;depth=infinity;
    else sort_ptr-&gt;depth=d;
    sort_ptr-&gt;head=bucket[collate[c]]; bucket[collate[c]]=NULL;
  }
}
@ The following recursive procedure walks through the tree of section names and prints them. @^recursion@&gt;

@&lt;Predeclaration of procedures@&gt;=
void section_print();

@ @c
void
section_print(p) /* print all section names in subtree |p| */
name_pointer p;
{
  if (p) {
    section_print(p-&gt;llink); out_str("\\I");
@.\\I@&gt;
    tok_ptr=tok_mem+1; text_ptr=tok_start+1; scrap_ptr=scrap_info; init_stack;
    app(p-name_dir+section_flag); make_output();
    footnote(cite_flag);
    footnote(0); /* |cur_xref| was set by |make_output| */
    finish_line();@/
    section_print(p-&gt;rlink);
  }
}
@ Because on some systems the difference between two pointers is a |long| rather than an |int|, we use \.{\%ld} to print these quantities.

@c
void
print_stats() {
  printf("\nMemory usage statistics:\n");
@.Memory usage statistics:@&gt;
  printf("%ld names (out of %ld)\n",
            (long)(name_ptr-name_dir),(long)max_names);
  printf("%ld cross-references (out of %ld)\n",
            (long)(xref_ptr-xmem),(long)max_refs);
  printf("%ld bytes (out of %ld)\n",
            (long)(byte_ptr-byte_mem),(long)max_bytes);
  printf("Parsing:\n");
  printf("%ld scraps (out of %ld)\n",
            (long)(max_scr_ptr-scrap_info),(long)max_scraps);
  printf("%ld texts (out of %ld)\n",
            (long)(max_text_ptr-tok_start),(long)max_texts);
  printf("%ld tokens (out of %ld)\n",
            (long)(max_tok_ptr-tok_mem),(long)max_toks);
  printf("%ld levels (out of %ld)\n",
            (long)(max_stack_ptr-stack),(long)stack_size);
  printf("Sorting:\n");
  printf("%ld levels (out of %ld)\n",
            (long)(max_sort_ptr-scrap_info),(long)max_scraps);
}@** Index.
If you have read and understood the code for Phase III above, you know what
is in this index and how it got here. All sections in which an identifier is
used are listed with that identifier, except that reserved words are
indexed only when they appear in format definitions, and the appearances
of identifiers in section names are not indexed. Underlined entries
correspond to where the identifier was declared. Error messages, control
sequences put into the output, and a few
other things like ``recursion'' are indexed here too.
</t>
<t tx="ekr.20170401122030.1">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170401122030.2">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170401123840.1"># To do: use tables as in the clean-c test.
</t>
<t tx="ekr.20170401123840.10"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20170401123840.11"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
</t>
<t tx="ekr.20170401123840.12"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
</t>
<t tx="ekr.20170401123840.13"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@nosent unittest/at-nosent-line-number-test.py'
    root = g.findNodeAnywhere(c, h)
    assert root
    assert root.isAtNoSentFileNode(), root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20170401123840.14"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    gnx = target.v.fileIndex
    assert gnx
    found = c.gotoCommands.find_gnx(root, gnx, h)
    assert found, 'not found'
</t>
<t tx="ekr.20170401123840.15">c.gotoCommands.success(lines=['a', 'b'], n=3, n2=3, p=p)
c.gotoCommands.fail(lines=['a', 'b'], n=3, root=p)

</t>
<t tx="ekr.20170401123840.2">child = g.findNodeInChildren(c, p, 'syntax-error')
assert child, 'no child'
try:
    c.goToScriptLineNumber(1, child)
finally:
    p.contract()
    c.selectPosition(p)
    c.redraw()
</t>
<t tx="ekr.20170401123840.3">@language python
def spam:
    pass
</t>
<t tx="ekr.20170401123840.4">import sys
# Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
elif sys.platform.startswith('win'):
    trace = False
    h = '@auto unittest/at-auto-md-line-number-test.md'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
else:
    self.skipTest('Skip on Linux')
</t>
<t tx="ekr.20170401123840.5"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-org unittest/at-auto-org-line-number-test.py'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 4, n
            break
</t>
<t tx="ekr.20170401123840.6"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-otl unittest/at-auto-otl-line-number-test.py'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % n)
            assert n == 4, n
            break
</t>
<t tx="ekr.20170401123840.7">import sys
# Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
elif sys.platform.startswith('win'):
    trace = False
    root = p.parent().parent()
    # h = '@auto unittest/at-auto-line-number-test.py'
    h = '@auto unittest/at-auto-unit-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(25):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 12, n
            if trace: print('not found: %s' % (n+1))
            break
else:
    self.skipTest('Skip on Linux')
</t>
<t tx="ekr.20170401123840.8"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-rst unittest/at-auto-rst-line-number-test.txt'
        # This must not be a python file
    root = g.findNodeAnywhere(c, h)
    assert root
    assert root.isAtAutoRstNode(), root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print('get_external_file_with_sentinels returns...')
        # print(''.join(['%3s %r' % (i, s) for i, s in enumerate(g.splitLines(s))]))
        g.printList(g.splitLines(s))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 9, n
            break
</t>
<t tx="ekr.20170401123840.9"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    lines = g.splitLines(s)
    stripped_lines = [z for z in lines if not z.startswith('//@')]
    if trace:
        # g.printList(stripped_lines)
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(lines)]))
    table = (
        # n is the 1-based offset of the *stripped* lines.
        # Directives do not appear in @clean files.
        # (1,     '@language c'),
        # (2,     '@tabwidth -4'),
        (3,     '// before @others // line 1'),
        # (4,     '@others'),
        # spam node.
        (1,     'def spam(): // line 2'),
        (2,     '    pass'),
        # eggs node.
        (1,    'def eggs(): // line 4'),
        (2,    '    pass'),
        # resume top node.
        (5,    '// last line: line 6'),
    )
    for n, data in enumerate(table):
        offset, line = data
        p, offset2, found = c.gotoCommands.find_file_line(n+1, p=target)
        assert offset == offset2, 'expected offset %s, got %s %r' % (
            offset, offset2, p and p.h)
    p, offset, found = c.gotoCommands.find_file_line(15, p=target)
    assert not found
</t>
<t tx="ekr.20170407065952.1">import imp
import leo.plugins.importers.javascript as js
imp.reload(js)
importer = js.JS_Importer(c.importCommands)
pattern = importer.op_pattern
table = (
    '++', '--', '&amp;&amp;', '||', '~', '&gt;&gt;', '&lt;&lt;', 
    # '&gt;&gt;=',  '&lt;&lt;=',
    # '&gt;&gt;&gt;', '&gt;&gt;&gt;=',
    # '&lt;&lt;&lt;', '&lt;&lt;&lt;=',
    '&lt;', '&lt;=', '&gt;', '&gt;=',
    '+', '+=', '-', '-=',
    '/', '/=', '*', '*=', 
    '%', '%=', '&amp;', '&amp;=',
    '|', '|=',
)
for s in table:
    m = pattern.match(s)
    assert m, s
    assert m.group(0) == s, (s, m.group(0))
</t>
<t tx="ekr.20170408233251.1">import re
import leo.core.leoAtFile as atFile
if 0: # prefix
    import imp
    imp.reload(atFile)
at = atFile.AtFile(c)
s = '''\
if (
    %s and 
    %s &gt; 3
):
    pass
''' % (g.angleBrackets('a'), g.angleBrackets('b'))
# Careful: avoid @verbatim and other substitutions.
expected = '''\
AT+leo-ver=5-thin
AT+node:GNX: * @test at.putRefLine 1
if (
    AT+&lt; &lt;a&gt; &gt;
    AT+node:GNX: ** &lt; &lt; a &gt; &gt;
    a
    AT-&lt; &lt;a&gt; &gt;
    ATafterref
 and 
    AT+&lt; &lt;b&gt; &gt;
    AT+node:GNX: ** &lt; &lt; b &gt; &gt;
    b
    AT-&lt; &lt;b&gt; &gt;
    ATafterref
 &gt; 3
):
    pass
AT-leo
'''.replace('AT','#@').replace('&gt; &gt;', '&gt;&gt;').replace('&lt; &lt;', '&lt;&lt;')

result = at.writeFromString(c.p, s)
result = re.sub(r'#@\+node:(.+):', '#@+node:GNX:', result)
    # Don't test actual gnx's, so we can copy/paste this test.
if 0: # Show unexpected mismatches.
    result = g.splitLines(result)
    expected = g.splitLines(expected)
    assert len(expected) == len(result)
    for i, s in enumerate(result):
        if expected[i] != result[i]:
            print(i)
            print('expected: %r' % expected[i])
            print('result:   %r' % result[i])
            break
assert result == expected
</t>
<t tx="ekr.20170408234524.1">a
</t>
<t tx="ekr.20170408234531.1">b
</t>
<t tx="ekr.20170409003052.1">import re
import leo.core.leoAtFile as atFile
if 0: # prefix
    import imp
    imp.reload(atFile)
at = atFile.AtFile(c)
s = '''\
if (%s and %s &gt; 3):
    pass
''' % (g.angleBrackets('a'), g.angleBrackets('b'))
# Careful: avoid @verbatim and other substitutions.
expected = '''\
AT+leo-ver=5-thin
AT+node:GNX: * @test at.putRefLine 2
if (
AT+&lt; &lt;a&gt; &gt;
AT+node:GNX: ** &lt; &lt; a &gt; &gt;
a
AT-&lt; &lt;a&gt; &gt;
ATafterref
 and 
AT+&lt; &lt;b&gt; &gt;
AT+node:GNX: ** &lt; &lt; b &gt; &gt;
b
AT-&lt; &lt;b&gt; &gt;
ATafterref
 &gt; 3):
    pass
AT-leo
'''.replace('AT','#@').replace('&gt; &gt;', '&gt;&gt;').replace('&lt; &lt;', '&lt;&lt;')
    # Recreate expected string.
result = at.writeFromString(c.p, s)
result = re.sub(r'#@\+node:(.+):', '#@+node:GNX:', result)
    # Don't test actual gnx's, so we can copy/paste this test.
if 0: # Show unexpected mismatches.
    result = g.splitLines(result)
    expected = g.splitLines(expected)
    # assert len(expected) == len(result)
    for i, s in enumerate(result):
        if expected[i] != result[i]:
            print(i)
            print('expected: %r' % expected[i])
            print('result:   %r' % result[i])
            break
assert result == expected
</t>
<t tx="ekr.20170409003052.2">a
</t>
<t tx="ekr.20170409003052.3">b
</t>
<t tx="ekr.20170409174529.27">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170409174529.28">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170409174632.19">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170409174632.20">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170410084645.1">#@+leo-ver=5
#@+node:#@file
# before

#@@raw

@c

&lt;&lt; ref &gt;&gt;

#@@end_raw

#after
#@-leo
</t>
<t tx="ekr.20170410190519.53">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170410190519.54">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170415061122.50">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170415061122.51">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170416060817.1">s = '''\
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE note SYSTEM "Note.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/head&gt;
&lt;body class='bodystring'&gt;
&lt;div id='bodydisplay'&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
'''
ic = c.importCommands
table = (
    (1, "&lt;html&gt;"),
    (2, "&lt;head&gt;"),
    (2, "&lt;body class='bodystring'&gt;"),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.xmlUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()

</t>
<t tx="ekr.20170416085619.1">@language html
s = '''
&lt;html&gt;
&lt;head&gt;headline&lt;/head&gt;
&lt;body&gt;body&lt;/body&gt;
&lt;/html&gt;
'''
@language python
table = (
    '&lt;html&gt;',
)
try:
    c.importCommands.htmlUnitTest(p,s=s,showTree=True)
    p2 = c.p.firstChild().firstChild()
    for h in table:
        assert p2 and p2.h == h, (p2 and p2.h, h)
        p2.moveToThreadNext()
    if 1:
        p.deleteAllChildren()
finally:
    c.redraw()

</t>
<t tx="ekr.20170426033159.40">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170426033159.41">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170502211859.15">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170502211859.16">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170503133125.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170503133125.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170503133258.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170503133258.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170503133608.21">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170503133608.22">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170504062625.1"># flattened, ignore-case, head, body

# found 7 nodes</t>
<t tx="ekr.20170504102140.1"># flattened, word, ignore-case, head, body

# found 149 nodes</t>
<t tx="ekr.20170504102649.1"></t>
<t tx="ekr.20170504102726.1"></t>
<t tx="ekr.20170504122245.1"></t>
<t tx="ekr.20170504122721.1">def at_auto_child():
    pass
</t>
<t tx="ekr.20170504122721.10">def class2_method1():
    pass
</t>
<t tx="ekr.20170504122721.11">def class2_method2():
    pass
</t>
<t tx="ekr.20170504122721.12">This would be the text in this level one node.

And this.
</t>
<t tx="ekr.20170504122721.13">Another one
</t>
<t tx="ekr.20170504122721.14">See what we did there - one more '#' - this is a subnode.
</t>
<t tx="ekr.20170504122721.15">Sec 1.
</t>
<t tx="ekr.20170504122721.16">Sec 2.
</t>
<t tx="ekr.20170504122721.17">Sec 1.
</t>
<t tx="ekr.20170504122721.18">Sec 2.
</t>
<t tx="ekr.20170504122721.2">Sec 1.

</t>
<t tx="ekr.20170504122721.3">Sec 2.
</t>
<t tx="ekr.20170504122721.4">def spam():
    pass
</t>
<t tx="ekr.20170504122721.5">def eggs():
    pass


</t>
<t tx="ekr.20170504122721.6">class class1:
    @others
</t>
<t tx="ekr.20170504122721.7">def class1_method1():
    pass
</t>
<t tx="ekr.20170504122721.8">def class1_method2():
    pass
# After @others in child1.
</t>
<t tx="ekr.20170504122721.9">class class2:
    @others
# last line
</t>
<t tx="ekr.20170504124245.1"></t>
<t tx="ekr.20170504124249.1"></t>
<t tx="ekr.20170504124417.1"></t>
<t tx="ekr.20170504124617.1"></t>
<t tx="ekr.20170504124637.1"></t>
<t tx="ekr.20170504124652.1"></t>
<t tx="ekr.20170504124842.1"></t>
<t tx="ekr.20170520193219.85">&lt;?php
@others
@language php
@tabwidth -4
</t>
<t tx="ekr.20170520193219.86">class foo {
    public $bar = &lt;&lt;&lt;EOT
a test.
bar
EOT;
}
?&gt;
</t>
<t tx="ekr.20170520193221.1"></t>
<t tx="ekr.20170520193221.2"></t>
<t tx="ekr.20170520193221.3"></t>
<t tx="ekr.20170520193223.10"></t>
<t tx="ekr.20170520193223.16"></t>
<t tx="ekr.20170520193223.7"></t>
<t tx="ekr.20170520193223.8"></t>
<t tx="ekr.20170520193223.9"></t>
<t tx="ekr.20170520204621.1"></t>
<t tx="sps.20100531034136.20110">p2 = p.firstChild().firstChild().firstChild()
aList = g.get_directives_dict_list(p2)
path = c.scanAtPathDirectives(aList)
endpath = g.os_path_normpath('again/again')
assert path and path.endswith(endpath),'expected ending %s got %s' % (
    endpath,path)
</t>
<t tx="sps.20100531034136.20111"></t>
<t tx="sps.20100531034136.20112"></t>
<t tx="sps.20100531034136.20113"></t>
<t tx="sps.20100609234650.16094">end = g.skip_blank_lines("",0)
assert end == 0, "expected 0, got %d" % end
end = g.skip_blank_lines(" ",0)
assert end == 0, "expected 0, got %d" % end
end = g.skip_blank_lines("\n",0)
assert end == 1, "expected 1, got %d" % end
end = g.skip_blank_lines(" \n",0)
assert end == 2, "expected 1, got %d" % end
end = g.skip_blank_lines("\n\na\n",0)
assert end == 2, "expected 2, got %d" % end
end = g.skip_blank_lines("\n\n a\n",0)
assert end == 2, "expected 2, got %d" % end
</t>
<t tx="ville.20090312195309.2">#if this starts failing due to much refacting in unitTest.leo,
# adjust accordingly

# These seem to fail if various nodes are cloned.
import random,fnmatch

all_h = [z.copy().h for z in c.find_h('.')]

assert len(all_h) &gt; 1000,'fail 1'

sample = random.sample(all_h, 20)    

# Test that all nodes are found at least once.
for h in sample:
    pat = fnmatch.translate(h)
    pl = c.find_h(pat)
    assert len(pl) &gt; 0 and len(pl) &lt; len(all_h),'fail 2'

tests = c.find_h('@test(.*)')

bm = tests.filter_b('(.*)all_positions')
forloops = 0
for node in bm:   
    # many of these are for loops
    for m in node.matchiter:
        if 'for' in m.group(1):
            forloops += 1

assert forloops &gt; 10,'fail for'

# all of these should also be found by find_b
all_bm = c.find_b('(.*)all_positions')
assert len(all_bm) &gt;= len(bm),'fail len'

assert set(el.h for el in bm).issubset(set(el.h for el in all_bm)),'fail set'

itertest = c.find_h('@test p.iters and v.iters')
assert len(itertest) &gt;= 1,'fail 3'
tn = itertest[0]
assert tn.h == '@test p.iters and v.iters','fail h'
assert len(itertest.filter_b('notfound, really')) == 0,'fail 4'
assert len(itertest.filter_b('leoNodes')) == 1,'fail 5'
chi = itertest.children().filter_h('child?')
assert chi[0].h == 'child1','fail 6'
assert chi[1].h == 'child2','fail 7'
# twice, in clones
chi_b = chi.children().filter_h('a').children().filter_h('b')

if 0:
    assert len(chi_b) == 2,'fail len 2: %s: %s' % (chi_b,len(chi_b))
    assert chi_b[0].h == chi_b[1].h == 'b'
    chi_e = chi.children().filter_h('d').children().filter_h('e')
    assert len(chi_e) == 1,'fail 8'
    assert chi_e[0].h == 'e','fail 9'

</t>
<t tx="ville.20090602190735.4770">_foo = 0

@g.command('my-test-command')
def mytestcommand(event):
    global _foo
    _foo = 1

try:
    c.k.simulateCommand('my-test-command')
    assert _foo == 1
    
    # bonus test: c.app.commanders()
    assert c in g.app.commanders()

except AttributeError:
    # Raised only for unit testing.
    pass
</t>
</tnodes>
</leo_file>
