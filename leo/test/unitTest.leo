<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070417092935"><vh>Startup</vh>
<v t="ekr.20140716121225.4354"><vh>@@button print-gnx</vh></v>
<v t="ekr.20161123080832.1"><vh>@button make-table</vh></v>
<v t="ekr.20111112092813.4154"><vh>@command cls</vh></v>
<v t="ekr.20101220161557.6011"><vh>@file unitTestStartup.txt</vh></v>
<v t="ekr.20150216110251.11"><vh>@persistence</vh></v>
<v t="ekr.20041121151002"><vh>@settings</vh>
<v t="ekr.20190113122443.1"><vh>@bool add-context-to-headlines = False</vh></v>
<v t="ekr.20080324133327.2"><vh>@bool allow-middle-button-paste = True</vh></v>
<v t="ekr.20161011095551.1"><vh>@bool allow-section-references-in-at-auto = True</vh></v>
<v t="ekr.20140902101931.4478"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20161129030232.1"><vh>@bool run-pyflakes-on-write = False</vh></v>
<v t="ekr.20140217055617.4231"><vh>@bool scriptingatscriptnodes = True</vh></v>
<v t="ekr.20180214042153.1"><vh>@bool select-next-after-delete = False</vh></v>
<v t="ekr.20051013162226"><vh>@bool test-setting = True</vh></v>
<v t="ekr.20150602215639.1"><vh>@bool tidy-autobeautify = False</vh></v>
<v t="ekr.20070503064257"><vh>@bool use-chapters = True</vh></v>
<v t="ekr.20150321155210.11"><vh>@bool verbose-check-outline = False</vh></v>
<v t="ekr.20181031152556.1"><vh>@bool write-script-file = True</vh></v>
<v t="ekr.20070528100318"><vh>@bool write-strips-blank-lines = False</vh></v>
<v t="ekr.20170415084531.1"><vh>@data import-html-tags</vh></v>
<v t="ekr.20111026111009.3972"><vh>@data import-xml-tags</vh></v>
<v t="ekr.20111123042627.6654"><vh>@enabled-plugins</vh></v>
<v t="ekr.20050328101834"><vh>@page http plugin</vh>
<v t="ekr.20050328101834.1"><vh>@bool http-active = False</vh></v>
<v t="ekr.20050328101834.2"><vh>@int port = 8080</vh></v>
<v t="ekr.20050328101834.3"><vh>@string rst-http-attributename = ''</vh></v>
</v>
<v t="ekr.20111112093605.4679"><vh>@shortcuts</vh></v>
<v t="ekr.20110521073115.3494"><vh>colorizer colors</vh>
<v t="ekr.20110521073115.3495"><vh>@@color keyword3-color = orange</vh></v>
<v t="ekr.20110521073115.3496"><vh>@@color keyword4-color = pink</vh></v>
</v>
<v t="ekr.20111124094121.3941"><vh>Empty @buttons and @commands nodes</vh>
<v t="ekr.20111124094121.3942"><vh>@buttons</vh></v>
<v t="ekr.20111124094121.3943"><vh>@commands</vh></v>
</v>
<v t="ekr.20171126153138.1"><vh>Required for reformat-paragraph tests</vh>
<v t="ekr.20171126152936.1"><vh>@int page-width = 80</vh></v>
<v t="ekr.20171126153044.1"><vh>@int tab-width = -4</vh></v>
</v>
<v t="ekr.20131111155830.4249"><vh>Vim settings</vh>
<v t="ekr.20131111155830.4250"><vh>@@@data vim-control-character-commands</vh></v>
<v t="ekr.20131111155830.4251"><vh>@data vim-command-tails</vh></v>
<v t="ekr.20131111155830.4252"><vh>@data vim-commands</vh></v>
<v t="ekr.20131111155830.4253"><vh>@data vim-motions</vh></v>
<v t="ekr.20131111155830.4254"><vh>@data vim-motion-tails</vh></v>
</v>
</v>
<v t="ekr.20100123172713.5114"><vh>Scripts</vh>
<v t="ekr.20100102164959.5088"><vh>Count pages</vh></v>
<v t="ekr.20100123172713.5116"><vh>Clean all tnodeLists</vh></v>
<v t="ekr.20070217065840"><vh>Scripts that make unit tests</vh>
<v t="ekr.20070217065840.1"><vh>@@command make-test @key = Alt-5</vh></v>
<v t="ekr.20070217065840.2"><vh>@@command do-before @key = Alt-6</vh>
<v t="ekr.20070217065840.3"><vh>getSel</vh></v>
<v t="ekr.20070217065840.4"><vh>findNodes</vh></v>
<v t="ekr.20070217065840.5"><vh>putSelectionInHeadline</vh></v>
</v>
<v t="ekr.20070217065840.6"><vh>@@command do-after @key = Alt-7</vh>
<v t="ekr.20070217072822"><vh>getSel</vh></v>
<v t="ekr.20070217065840.8"><vh>findNodes</vh></v>
<v t="ekr.20070217065840.9"><vh>putSelectionInHeadline</vh></v>
</v>
</v>
<v t="ekr.20070113145100"><vh>Create chinese folder</vh></v>
<v t="ekr.20071113140035"><vh>Find unique @ test nodes</vh></v>
<v t="ekr.20091206090247.5060"><vh>Clear all uA's, tnodeLists, etc.</vh>
<v t="ekr.20091206090247.5061"><vh>Clean unused tnodeLists</vh></v>
<v t="ekr.20091206090247.5062"><vh>Clear all timestamps</vh></v>
<v t="ekr.20091206090247.5063"><vh>Clear all uAs (unknown attributes)</vh></v>
</v>
</v>
</v>
<v t="ekr.20191215093835.9"><vh>data</vh>
<v t="ekr.20191215093835.15"><vh>a</vh>
<v t="ekr.20191215093835.16"><vh>b</vh></v>
</v>
<v t="ekr.20191215093835.12"><vh>c</vh></v>
<v t="ekr.20191215093835.13"><vh>d</vh></v>
<v t="ekr.20191215093835.14"><vh>e</vh>
<v t="ekr.20191215093835.15"></v>
</v>
</v>
<v t="ekr.20051012104957"><vh>@ignore Docs</vh>
<v t="bwmulder.20050108100437.1"><vh>How to run unit tests</vh></v>
<v t="ekr.20050618061835"><vh>How to use the @test directive, by Roger Erens</vh>
<v t="ekr.20050618061835.1"><vh>Intro</vh>
<v t="ekr.20050618061835.2"><vh>@url http://www.onlamp.com/pub/a/python/2005/02/03/tdd_pyunit2.html</vh></v>
</v>
<v t="ekr.20050618061835.3"><vh>Preparations: adding a button</vh>
<v t="ekr.20050618061835.4"><vh>@@button Do @test</vh></v>
</v>
<v t="ekr.20050618061835.5"><vh>Alpha</vh>
<v t="ekr.20050618061835.6"><vh>@test my first Leo test</vh></v>
<v t="ekr.20050618061835.7"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.8"><vh>Bravo</vh>
<v t="ekr.20050618061835.9"><vh>@@test my second Leo test</vh></v>
<v t="ekr.20050618061835.10"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.11"><vh>It takes two to tango</vh>
<v t="ekr.20050618061835.6"></v>
<v t="ekr.20050618061835.9"></v>
<v t="ekr.20050618061835.12"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.13"><vh>Life gets more interesting</vh>
<v t="ekr.20050618061835.14"><vh>@@test koekiemonster.wants()</vh>
<v t="ekr.20050618061835.15"><vh>input data</vh></v>
<v t="ekr.20050618061835.16"><vh>expected result</vh></v>
</v>
<v t="ekr.20050618061835.17"><vh>output on the console</vh></v>
<v t="ekr.20050618061835.18"><vh>output on the console using print statements</vh></v>
</v>
<v t="ekr.20050618061835.19"><vh>How about @suite?</vh></v>
<v t="ekr.20050618061835.20"><vh>Final remarks</vh></v>
</v>
<v t="ekr.20111211094936.3970"><vh>@ignore To do</vh>
<v t="ekr.20111115080347.3872"><vh>To do: tests of the high-level interface</vh>
<v t="ekr.20100131171342.5478"><vh>@@@test that log and body implements high-level interface</vh></v>
</v>
<v t="ekr.20100131171342.5473"><vh>Tk gui tests</vh>
<v t="ekr.20100131171342.5474"><vh>@test leoBody is subset of leoTkBody</vh></v>
<v t="ekr.20100131171342.5475"><vh>@test leoFrame is subset of leoTkFrame</vh></v>
<v t="ekr.20100131171342.5476"><vh>@test leoGui is subset of leoTkGui</vh></v>
<v t="ekr.20100131171342.5477"><vh>@test leoTree is subset of leoTkTree</vh></v>
</v>
<v t="ekr.20111125183140.3952"><vh>@test ic.createOutline changes back-slashes to slashes</vh></v>
<v t="ekr.20111125182408.3947"><vh>@test ic.createImportParent changes back-slashes to slashes</vh></v>
</v>
</v>
<v t="ekr.20190113120618.1"><vh>Files</vh>
<v t="ekr.20190113120734.1"><vh>@asis unittest/at-asis-test.py</vh>
<v t="ekr.20190113120734.2"><vh>spam</vh></v>
<v t="ekr.20190113120734.3"><vh>eggs</vh></v>
</v>
<v t="ekr.20190113123439.5"><vh>@auto unittest/at-auto-line-number-test.py</vh></v>
<v t="ekr.20190113123439.7"><vh>@auto unittest/at-auto-md-line-number-test.md</vh></v>
<v t="ekr.20190113123439.11"><vh>@auto unittest/at-auto-section-ref-test.py</vh></v>
<v t="ekr.20190113121550.1"><vh>@auto unittest/at-auto-test.py</vh></v>
<v t="ekr.20190113123439.16"><vh>@auto unittest/at-auto-unit-test.py</vh></v>
<v t="ekr.20190113123635.2"><vh>@auto-org unittest/at-auto-org-line-number-test.org</vh></v>
<v t="ekr.20190113123635.5"><vh>@auto-otl unittest/at-auto-otl-line-number-test.otl</vh></v>
<v t="ekr.20190113123822.1"><vh>@clean unittest/at-clean-line-number-test.c</vh>
<v t="ekr.20190113123822.2"><vh>spam</vh></v>
<v t="ekr.20190113123822.3"><vh>eggs</vh></v>
</v>
<v t="ekr.20190113123853.1"><vh>@clean unittest/at-clean-line-number-test.py</vh>
<v t="ekr.20190113123853.2"><vh>spam</vh></v>
<v t="ekr.20190113123853.3"><vh>eggs</vh></v>
</v>
<v t="ekr.20191207060251.1"><vh>@clean unittest/at-clean-write-test.py</vh>
<v t="ekr.20191207060251.2"><vh>spam</vh></v>
<v t="ekr.20191207060251.3"><vh>eggs</vh></v>
</v>
<v t="ekr.20160403123754.1"><vh>@file unittest/at-file-line-number-test.c</vh></v>
<v t="ekr.20080904102243.2"><vh>@file unittest/at-file-line-number-test.py</vh></v>
<v t="ekr.20111021115306.3697"><vh>@file unittest/tex-error.tex</vh></v>
<v t="ekr.20130912092638.4150"><vh>@file unittest/utf-16-test.txt</vh></v>
<v t="ekr.20190113124135.1"><vh>@nosent unittest/at-nosent-line-number-test.py</vh>
<v t="ekr.20190113124135.2"><vh>spam</vh></v>
<v t="ekr.20190113124135.3"><vh>eggs</vh></v>
</v>
<v t="ekr.20100731163237.5782"><vh>@thin unittest/at-thin-html-test.html</vh></v>
<v t="ekr.20090704085350.5022"><vh>@thin unittest/at-thin-test.py</vh></v>
</v>
<v t="ekr.20101220161557.6016"><vh>Active Unit Tests</vh>
<v t="edward.20160314170027.56" descendentVnodeUnknownAttributes="7d7100285808000000302e342e31322e3471017d71025809000000756e69745f7465737471035804000000616263647104735809000000302e342e31382e333571057d710658090000006d795f706c7567696e7107580300000076616c710873752e"><vh>@file activeUnitTests.txt</vh></v>
</v>
<v t="ekr.20190923014948.1"><vh>Failures when run from bridge w/ readSettings=False</vh>
<v t="ekr.20150430053825.1"><vh>@test abbrevCommands.next_place</vh>
<v t="ekr.20150430061225.1"><vh>child</vh></v>
</v>
<v t="ekr.20051107115231.18"><vh>@test paste and undo in headline - at end</vh></v>
<v t="ekr.20051107115231.20"><vh>@test paste and undo in headline - with selection</vh></v>
<v t="ekr.20051107115231.16"><vh>@test paste at end of headline</vh></v>
<v t="ekr.20060325071703.1"><vh>@test ifplatform</vh></v>
<v t="ekr.20111124090010.3939"><vh>@test g.app.config @buttons and @commands logic</vh></v>
<v t="ekr.20100212104817.5351"><vh>@test help-for-command</vh></v>
<v t="ekr.20100204165850.5373"><vh>@test most toggle commands</vh></v>
<v t="ekr.20051107115231.17"><vh>@test typing and undo in headline - at end</vh></v>
</v>
<v t="ekr.20191219054650.1"><vh>Remaining -Wd warnings</vh></v>
<v t="ekr.20191219172058.1"><vh>importlib test</vh></v>
<v t="ekr.20191219183054.1"><vh>Found:imp</vh>
<v t="ekr.20191121163350.1"><vh>@@test nodes: tog vs asttokens (fails)</vh></v>
<v t="ekr.20191125235556.1"><vh>@@test TOG: Leo's core files (long)</vh></v>
<v t="ekr.20170408233251.1"><vh>@test at.putRefLine 1</vh>
<v t="ekr.20170408234524.1"><vh>&lt;&lt; a &gt;&gt;</vh></v>
<v t="ekr.20170408234531.1"><vh>&lt;&lt; b &gt;&gt;</vh></v>
</v>
<v t="ekr.20170409003052.1"><vh>@test at.putRefLine 2</vh>
<v t="ekr.20170409003052.2"><vh>&lt;&lt; a &gt;&gt;</vh></v>
<v t="ekr.20170409003052.3"><vh>&lt;&lt; b &gt;&gt;</vh></v>
</v>
<v t="ekr.20090529141856.4718"><vh>@test c class 1</vh></v>
<v t="ekr.20090529141856.4719"><vh>@test c class--underindented line</vh></v>
<v t="ekr.20090529141856.4721"><vh>@test c comment follows arg list</vh></v>
<v t="ekr.20090529141856.4722"><vh>@test c comment follows block delim</vh></v>
<v t="ekr.20090529141856.4726"><vh>@test c extern</vh></v>
<v t="ekr.20090529141856.4723"><vh>@test c intermixed blanks and tabs</vh></v>
<v t="ekr.20090529141856.4724"><vh>@test c old-style decl 1</vh></v>
<v t="ekr.20090529141856.4725"><vh>@test c old-style decl 2</vh></v>
<v t="ekr.20090529141856.4733"><vh>@test elisp</vh></v>
<v t="ekr.20090529141856.4770"><vh>@test from AdminPermission.java</vh></v>
<v t="ekr.20090529141856.4773"><vh>@test from BundleException.java</vh></v>
<v t="ekr.20161115092708.1"><vh>@test i.scan_state (for python)</vh></v>
<v t="ekr.20161109065940.1"><vh>@test Importer.get_leading_indent</vh></v>
<v t="ekr.20161109065949.1"><vh>@test Importer.is_ws_line</vh></v>
<v t="ekr.20181020063007.2"><vh>@test importers.coffee.scan_line</vh>
<v t="ekr.20181020063007.3"><vh>&lt;&lt; define table &gt;&gt;</vh></v>
</v>
<v t="ekr.20181020063656.1"><vh>@test importers.dart.clean_headline</vh></v>
<v t="ekr.20170407065952.1"><vh>@test importers.javascript.op_pattern</vh></v>
<v t="ekr.20161011052016.1"><vh>@test importers.javascript.scan_line</vh></v>
<v t="ekr.20181020064529.1"><vh>@test importers.markdown.is_hash</vh></v>
<v t="ekr.20181020071052.1"><vh>@test importers.markdown.is_underline</vh></v>
<v t="ekr.20181020072106.1"><vh>@test importers.pascal methods</vh></v>
<v t="ekr.20181020063007.4"><vh>@test importers.python.test_scan_state</vh>
<v t="ekr.20181020063007.5"><vh>&lt;&lt; define python tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20181020074227.2"><vh>@test importers.xml.is_ws_line</vh></v>
<v t="ekr.20181020074227.3"><vh>@test importesrs.xml.scan line</vh></v>
<v t="ekr.20090529141856.4767"><vh>@test java interface test1</vh></v>
<v t="ekr.20090529141856.4768"><vh>@test java interface test2</vh></v>
<v t="ekr.20161129104243.1"><vh>@test leo_rst</vh></v>
<v t="ekr.20161224145026.1"><vh>@test leoApp fail</vh></v>
<v t="ekr.20161127181028.1"><vh>@test markdown github syntax</vh></v>
<v t="ekr.20161216141315.1"><vh>@test markdown importer-@@-section-name</vh></v>
<v t="ekr.20161125134815.1"><vh>@test markdown importer-basic</vh></v>
<v t="ekr.20161126111517.1"><vh>@test markdown importer-implicit section</vh></v>
<v t="ekr.20160410152100.2"><vh>@test md-import-test</vh>
<v t="ekr.20160411034540.1"><vh>&lt;&lt; define s &gt;&gt; (md-import-test)</vh></v>
<v t="ekr.20161202093709.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161202093709.2"><vh>!Declarations</vh>
<v t="ekr.20161202093709.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093709.4"><vh>Section 2</vh>
<v t="ekr.20161202093709.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093709.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093709.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093709.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034142.19"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204034142.20"><vh>Top</vh>
<v t="ekr.20161204034142.21"><vh>Section 1</vh></v>
<v t="ekr.20161204034142.22"><vh>Section 2</vh>
<v t="ekr.20161204034142.23"><vh>Section 2.1</vh>
<v t="ekr.20161204034142.24"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034142.25"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034142.26"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034207.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204034207.2"><vh>Top</vh>
<v t="ekr.20161204034207.3"><vh>Section 1</vh></v>
<v t="ekr.20161204034207.4"><vh>Section 2</vh>
<v t="ekr.20161204034207.5"><vh>Section 2.1</vh>
<v t="ekr.20161204034207.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034207.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034207.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204035451.19"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204035451.20"><vh>Top</vh>
<v t="ekr.20161204035451.21"><vh>Section 1</vh></v>
<v t="ekr.20161204035451.22"><vh>Section 2</vh>
<v t="ekr.20161204035451.23"><vh>Section 2.1</vh>
<v t="ekr.20161204035451.24"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204035451.25"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204035451.26"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041310.53"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041310.54"><vh>Top</vh>
<v t="ekr.20161204041310.55"><vh>Section 1</vh></v>
<v t="ekr.20161204041310.56"><vh>Section 2</vh>
<v t="ekr.20161204041310.57"><vh>Section 2.1</vh>
<v t="ekr.20161204041310.58"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041310.59"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041310.60"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041358.103"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041358.104"><vh>Top</vh>
<v t="ekr.20161204041358.105"><vh>Section 1</vh></v>
<v t="ekr.20161204041358.106"><vh>Section 2</vh>
<v t="ekr.20161204041358.107"><vh>Section 2.1</vh>
<v t="ekr.20161204041358.108"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041358.109"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041358.110"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041418.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041418.2"><vh>Top</vh>
<v t="ekr.20161204041418.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041418.4"><vh>Section 2</vh>
<v t="ekr.20161204041418.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041418.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041418.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041418.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041645.103"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041645.104"><vh>Top</vh>
<v t="ekr.20161204041645.105"><vh>Section 1</vh></v>
<v t="ekr.20161204041645.106"><vh>Section 2</vh>
<v t="ekr.20161204041645.107"><vh>Section 2.1</vh>
<v t="ekr.20161204041645.108"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041645.109"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041645.110"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041724.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041724.2"><vh>Top</vh>
<v t="ekr.20161204041724.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041724.4"><vh>Section 2</vh>
<v t="ekr.20161204041724.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041724.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041724.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041724.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041800.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204041800.2"><vh>Top</vh>
<v t="ekr.20161204041800.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041800.4"><vh>Section 2</vh>
<v t="ekr.20161204041800.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041800.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041800.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041800.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042305.96"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204042305.97"><vh>Top</vh>
<v t="ekr.20161204042305.98"><vh>Section 1</vh></v>
<v t="ekr.20161204042305.99"><vh>Section 2</vh>
<v t="ekr.20161204042305.100"><vh>Section 2.1</vh>
<v t="ekr.20161204042305.101"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042305.102"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042305.103"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042719.4"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204042719.5"><vh>Top</vh>
<v t="ekr.20161204042719.6"><vh>Section 1</vh></v>
<v t="ekr.20161204042719.7"><vh>Section 2</vh>
<v t="ekr.20161204042719.8"><vh>Section 2.1</vh>
<v t="ekr.20161204042719.9"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042719.10"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042719.11"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042822.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204042822.2"><vh>Top</vh>
<v t="ekr.20161204042822.3"><vh>Section 1</vh></v>
<v t="ekr.20161204042822.4"><vh>Section 2</vh>
<v t="ekr.20161204042822.5"><vh>Section 2.1</vh>
<v t="ekr.20161204042822.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042822.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042822.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043017.19"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204043017.20"><vh>Top</vh>
<v t="ekr.20161204043017.21"><vh>Section 1</vh></v>
<v t="ekr.20161204043017.22"><vh>Section 2</vh>
<v t="ekr.20161204043017.23"><vh>Section 2.1</vh>
<v t="ekr.20161204043017.24"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043017.25"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043017.26"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043032.96"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204043032.97"><vh>Top</vh>
<v t="ekr.20161204043032.98"><vh>Section 1</vh></v>
<v t="ekr.20161204043032.99"><vh>Section 2</vh>
<v t="ekr.20161204043032.100"><vh>Section 2.1</vh>
<v t="ekr.20161204043032.101"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043032.102"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043032.103"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043346.4"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test</vh>
<v t="ekr.20161204043346.5"><vh>Top</vh>
<v t="ekr.20161204043346.6"><vh>Section 1</vh></v>
<v t="ekr.20161204043346.7"><vh>Section 2</vh>
<v t="ekr.20161204043346.8"><vh>Section 2.1</vh>
<v t="ekr.20161204043346.9"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043346.10"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043346.11"><vh>Section 3</vh></v>
</v>
</v>
</v>
<v t="ekr.20160411033840.1"><vh>@test md-import-test-rst-style</vh>
<v t="ekr.20161125230415.1"><vh>&lt;&lt; define s &gt;&gt; (md-import-test-rst-style)</vh></v>
<v t="ekr.20161202093319.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093319.2"><vh>Top</vh>
<v t="ekr.20161202093319.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093319.4"><vh>Section 2</vh>
<v t="ekr.20161202093319.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093319.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093319.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093319.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093322.9"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093322.10"><vh>Top</vh>
<v t="ekr.20161202093322.11"><vh>Section 1</vh></v>
<v t="ekr.20161202093322.12"><vh>Section 2</vh>
<v t="ekr.20161202093322.13"><vh>Section 2.1</vh>
<v t="ekr.20161202093322.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093322.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093322.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093409.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093409.2"><vh>Top</vh>
<v t="ekr.20161202093409.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093409.4"><vh>Section 2</vh>
<v t="ekr.20161202093409.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093409.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093409.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093409.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093410.1"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093410.2"><vh>Top</vh>
<v t="ekr.20161202093410.3"><vh>Section 1</vh></v>
<v t="ekr.20161202093410.4"><vh>Section 2</vh>
<v t="ekr.20161202093410.5"><vh>Section 2.1</vh>
<v t="ekr.20161202093410.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093410.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093410.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161202093509.22"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161202093509.23"><vh>Top</vh>
<v t="ekr.20161202093509.24"><vh>Section 1</vh></v>
<v t="ekr.20161202093509.25"><vh>Section 2</vh>
<v t="ekr.20161202093509.26"><vh>Section 2.1</vh>
<v t="ekr.20161202093509.27"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161202093509.28"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161202093509.29"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034142.27"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204034142.28"><vh>Top</vh>
<v t="ekr.20161204034142.29"><vh>Section 1</vh></v>
<v t="ekr.20161204034142.30"><vh>Section 2</vh>
<v t="ekr.20161204034142.31"><vh>Section 2.1</vh>
<v t="ekr.20161204034142.32"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034142.33"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034142.34"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204034207.9"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204034207.10"><vh>Top</vh>
<v t="ekr.20161204034207.11"><vh>Section 1</vh></v>
<v t="ekr.20161204034207.12"><vh>Section 2</vh>
<v t="ekr.20161204034207.13"><vh>Section 2.1</vh>
<v t="ekr.20161204034207.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204034207.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204034207.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204035451.27"><vh>@@auto-markdown c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204035451.28"><vh>Top</vh>
<v t="ekr.20161204035451.29"><vh>Section 1</vh></v>
<v t="ekr.20161204035451.30"><vh>Section 2</vh>
<v t="ekr.20161204035451.31"><vh>Section 2.1</vh>
<v t="ekr.20161204035451.32"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204035451.33"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204035451.34"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041310.61"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041310.62"><vh>Top</vh>
<v t="ekr.20161204041310.63"><vh>Section 1</vh></v>
<v t="ekr.20161204041310.64"><vh>Section 2</vh>
<v t="ekr.20161204041310.65"><vh>Section 2.1</vh>
<v t="ekr.20161204041310.66"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041310.67"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041310.68"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041359.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041359.2"><vh>Top</vh>
<v t="ekr.20161204041359.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041359.4"><vh>Section 2</vh>
<v t="ekr.20161204041359.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041359.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041359.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041359.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041418.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041418.10"><vh>Top</vh>
<v t="ekr.20161204041418.11"><vh>Section 1</vh></v>
<v t="ekr.20161204041418.12"><vh>Section 2</vh>
<v t="ekr.20161204041418.13"><vh>Section 2.1</vh>
<v t="ekr.20161204041418.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041418.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041418.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041646.1"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041646.2"><vh>Top</vh>
<v t="ekr.20161204041646.3"><vh>Section 1</vh></v>
<v t="ekr.20161204041646.4"><vh>Section 2</vh>
<v t="ekr.20161204041646.5"><vh>Section 2.1</vh>
<v t="ekr.20161204041646.6"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041646.7"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041646.8"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041724.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041724.10"><vh>Top</vh>
<v t="ekr.20161204041724.11"><vh>Section 1</vh></v>
<v t="ekr.20161204041724.12"><vh>Section 2</vh>
<v t="ekr.20161204041724.13"><vh>Section 2.1</vh>
<v t="ekr.20161204041724.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041724.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041724.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204041800.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204041800.10"><vh>Top</vh>
<v t="ekr.20161204041800.11"><vh>Section 1</vh></v>
<v t="ekr.20161204041800.12"><vh>Section 2</vh>
<v t="ekr.20161204041800.13"><vh>Section 2.1</vh>
<v t="ekr.20161204041800.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204041800.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204041800.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042305.104"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204042305.105"><vh>Top</vh>
<v t="ekr.20161204042305.106"><vh>Section 1</vh></v>
<v t="ekr.20161204042305.107"><vh>Section 2</vh>
<v t="ekr.20161204042305.108"><vh>Section 2.1</vh>
<v t="ekr.20161204042305.109"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042305.110"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042305.111"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042719.12"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204042719.13"><vh>Top</vh>
<v t="ekr.20161204042719.14"><vh>Section 1</vh></v>
<v t="ekr.20161204042719.15"><vh>Section 2</vh>
<v t="ekr.20161204042719.16"><vh>Section 2.1</vh>
<v t="ekr.20161204042719.17"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042719.18"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042719.19"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204042822.9"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204042822.10"><vh>Top</vh>
<v t="ekr.20161204042822.11"><vh>Section 1</vh></v>
<v t="ekr.20161204042822.12"><vh>Section 2</vh>
<v t="ekr.20161204042822.13"><vh>Section 2.1</vh>
<v t="ekr.20161204042822.14"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204042822.15"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204042822.16"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043017.27"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204043017.28"><vh>Top</vh>
<v t="ekr.20161204043017.29"><vh>Section 1</vh></v>
<v t="ekr.20161204043017.30"><vh>Section 2</vh>
<v t="ekr.20161204043017.31"><vh>Section 2.1</vh>
<v t="ekr.20161204043017.32"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043017.33"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043017.34"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043032.104"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204043032.105"><vh>Top</vh>
<v t="ekr.20161204043032.106"><vh>Section 1</vh></v>
<v t="ekr.20161204043032.107"><vh>Section 2</vh>
<v t="ekr.20161204043032.108"><vh>Section 2.1</vh>
<v t="ekr.20161204043032.109"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043032.110"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043032.111"><vh>Section 3</vh></v>
</v>
</v>
<v t="ekr.20161204043346.12"><vh>@@auto-md c:/leo.repo/leo-editor/leo/test/md-import-test-rst-style</vh>
<v t="ekr.20161204043346.13"><vh>Top</vh>
<v t="ekr.20161204043346.14"><vh>Section 1</vh></v>
<v t="ekr.20161204043346.15"><vh>Section 2</vh>
<v t="ekr.20161204043346.16"><vh>Section 2.1</vh>
<v t="ekr.20161204043346.17"><vh>Section 2.1.1</vh></v>
</v>
<v t="ekr.20161204043346.18"><vh>Section 2.2</vh></v>
</v>
<v t="ekr.20161204043346.19"><vh>Section 3</vh></v>
</v>
</v>
</v>
<v t="ekr.20181020062632.1"><vh>@test org-placeholder</vh></v>
<v t="ekr.20181020062526.1"><vh>@test org_pattern</vh></v>
<v t="ekr.20181020062334.1"><vh>@test otl (vim-outline) mode</vh></v>
<v t="ekr.20090529141856.4735"><vh>@test pascal-to-delphi interface</vh></v>
<v t="ekr.20161119032623.1"><vh>@test perl regex-2</vh></v>
<v t="ekr.20161115063144.34"><vh>@test python basic nesting test</vh></v>
<v t="ekr.20161218103650.1"><vh>@test python bug #346</vh></v>
<v t="ekr.20161228070933.1"><vh>@test python bug #354</vh></v>
<v t="ekr.20170122033034.1"><vh>@test python bug #357</vh></v>
<v t="ekr.20161115063144.7"><vh>@test python comment after dict assign</vh></v>
<v t="ekr.20161115063144.8"><vh>@test python decls test 1</vh></v>
<v t="ekr.20161224101046.1"><vh>@test python decorator 2</vh></v>
<v t="ekr.20161115063144.10"><vh>@test python def inside def</vh></v>
<v t="ekr.20161115063144.11"><vh>@test python def test 1</vh></v>
<v t="ekr.20161115063144.12"><vh>@test python def test 2</vh></v>
<v t="ekr.20161115063144.16"><vh>@test python indent decls</vh></v>
<v t="ekr.20161117000902.1"><vh>@test python leoImport.py (small)</vh></v>
<v t="ekr.20161115063144.24"><vh>@test python overindented def 3</vh></v>
<v t="ekr.20161222064421.1"><vh>@test python top-level later decl</vh>
<v t="ekr.20191219051321.68"><vh>@@file @test python top-level later decl</vh>
<v t="ekr.20191219051321.69"><vh>Declarations</vh></v>
<v t="ekr.20191219051321.70"><vh>merge_value</vh></v>
<v t="ekr.20191219051321.71"><vh>class MainDisplay(object)</vh>
<v t="ekr.20191219051321.72"><vh>save_file</vh></v>
</v>
<v t="ekr.20191219051321.73"><vh>retab</vh></v>
</v>
</v>
<v t="ekr.20161115063144.31"><vh>@test python underindent method</vh></v>
<v t="ekr.20090529141856.4785"><vh>@test rST import test</vh></v>
<v t="ekr.20090529141856.4788"><vh>@test rST import test: long overlines</vh></v>
<v t="ekr.20090529141856.4787"><vh>@test rST import test: long underlines</vh></v>
<v t="ekr.20090529141856.4786"><vh>@test rST import test: no double-underlines</vh></v>
<v t="ekr.20181009102459.1"><vh>@test setup importer tests</vh></v>
<v t="ekr.20191118154059.1"><vh>@test TokenOrder classes</vh>
<v t="ekr.20191206053245.1"><vh>test: test end-of-file handling</vh></v>
<v t="ekr.20191120074811.1"><vh>ignore: Contexts...</vh>
<v t="ekr.20191119133927.1"><vh>test: ClassDef</vh></v>
<v t="ekr.20191122203522.1"><vh>test: ClassDef, FunctionDef</vh></v>
<v t="ekr.20191119142414.1"><vh>test: FunctionDef &amp; NamedConstant</vh></v>
</v>
<v t="ekr.20191120075520.1"><vh>ignore: Expressions &amp; operators...</vh>
<v t="ekr.20191118155612.1"><vh>test: attribute</vh></v>
<v t="ekr.20191119211714.1"><vh>test: CompareOp</vh></v>
<v t="ekr.20191201072043.1"><vh>test: dict containing ternary</vh></v>
<v t="ekr.20191203125635.1"><vh>test: DictComp</vh></v>
<v t="ekr.20191119213940.1"><vh>test: ListComp and comprehension</vh></v>
<v t="ekr.20191122153258.1"><vh>test: NamedConstant</vh></v>
<v t="ekr.20191118160305.1"><vh>test: Operator: semicolon</vh></v>
<v t="ekr.20191118155612.2"><vh>test: Operator: semicolon between statements</vh></v>
<v t="ekr.20191119210429.1"><vh>test: UnaryOp</vh></v>
</v>
<v t="ekr.20191125151346.1"><vh>ignore: Files...</vh>
<v t="ekr.20191204154152.1"><vh>file: core..leoApp.py</vh></v>
<v t="ekr.20191205071617.1"><vh>file: core..leoAst.py</vh></v>
<v t="ekr.20191205090519.1"><vh>file: core..leoDebugger.py</vh></v>
<v t="ekr.20191119203945.1"><vh>file: core..leoFind.py</vh></v>
<v t="ekr.20191123203957.1"><vh>file: core..leoGlobals.py</vh></v>
<v t="ekr.20191203155845.1"><vh>file: core..leoTips.py</vh></v>
<v t="ekr.20191118155609.1"><vh>file: core..runLeo.py</vh></v>
</v>
<v t="ekr.20191122210522.1"><vh>ignore: If...</vh>
<v t="ekr.20191203160056.1"><vh>test: from leoTips.py</vh></v>
<v t="ekr.20191119213126.1"><vh>test: if + tuple</vh></v>
<v t="ekr.20191123210801.1"><vh>test: if + unary op</vh></v>
<v t="ekr.20191120171921.1"><vh>test: if, elif</vh></v>
<v t="ekr.20191122213610.1"><vh>test: if, elif + 2</vh></v>
<v t="ekr.20191120064442.1"><vh>test: if, elif, else</vh></v>
<v t="ekr.20191120132531.1"><vh>test: if, else</vh></v>
<v t="ekr.20191122210035.1"><vh>test: if, else, if</vh></v>
<v t="ekr.20191120164539.1"><vh>test: Nested If's</vh></v>
<v t="ekr.20191125161333.1"><vh>test: ternary + if</vh></v>
</v>
<v t="ekr.20191124040736.1"><vh>ignore: Statements...</vh>
<v t="ekr.20191204025303.1"><vh>test: Call</vh></v>
<v t="ekr.20191203120043.1"><vh>test: Global</vh></v>
<v t="ekr.20191120163559.1"><vh>test: Try</vh></v>
<v t="ekr.20191205090659.1"><vh>test: TryExceptElse</vh></v>
<v t="ekr.20191203125053.1"><vh>test: With</vh></v>
<v t="ekr.20191205071827.1"><vh>test: YieldFrom</vh></v>
</v>
<v t="ekr.20191205090312.1"><vh>ignore: Strings...</vh>
<v t="ekr.20191127134236.1"><vh>ignore: plain strings</vh>
<v t="ekr.20191203185327.1"><vh>test: \x and \o escapes</vh></v>
<v t="ekr.20191203121918.1"><vh>test: backslashes in docstring</vh></v>
<v t="ekr.20191201065409.1"><vh>test: bs/nl</vh></v>
<v t="ekr.20191204154344.1"><vh>test: bytes bs-x</vh></v>
<v t="ekr.20191126143046.1"><vh>test: empty string</vh></v>
<v t="ekr.20191127172440.1"><vh>test: escaped string delims</vh></v>
<v t="ekr.20191201062631.1"><vh>test: escaped strings</vh></v>
<v t="ekr.20191205014742.1"><vh>test: f-string join</vh></v>
<v t="ekr.20191202195507.1"><vh>test: raw docstring</vh></v>
<v t="ekr.20191201064058.1"><vh>test: raw escaped strings</vh></v>
<v t="ekr.20191203111346.1"><vh>test: single quote</vh></v>
<v t="ekr.20191125235415.1"><vh>test: string concatentation</vh></v>
<v t="ekr.20191118155611.1"><vh>test: string with % op</vh></v>
</v>
<v t="ekr.20191126084046.1"><vh>ignore: f-strings</vh>
<v t="ekr.20191204164129.1"><vh>test: complex Call</vh></v>
<v t="ekr.20191125165640.1"><vh>test: f-string + Ternary</vh></v>
<v t="ekr.20191201124815.1"><vh>test: f-string case 1: single f-string</vh></v>
<v t="ekr.20191129033147.1"><vh>test: f-string case 2: f-string + plain</vh></v>
<v t="ekr.20191201131734.1"><vh>test: f-string case 3: plain + f-string</vh></v>
<v t="ekr.20191201134842.1"><vh>test: f-string case 4: f-string + fstring</vh></v>
<v t="ekr.20191201135548.1"><vh>test: f-string case 5: many</vh></v>
<v t="ekr.20191201064443.1"><vh>test: f-string containing ternary op</vh></v>
<v t="ekr.20191201083823.1"><vh>test: f-string leoFind.py line 856</vh></v>
<v t="ekr.20191127134726.1"><vh>test: f-string leoFind.py: line 861</vh></v>
<v t="ekr.20191126002258.1"><vh>test: f-string summary</vh>
<v t="ekr.20191129035530.1"><vh>more</vh></v>
</v>
<v t="ekr.20191129033245.1"><vh>test: f-string summary: joins + 1 f-expr</vh></v>
<v t="ekr.20191129033359.1"><vh>test: f-string summary: joins + 2 f-exprs</vh></v>
<v t="ekr.20191201201448.1"><vh>test: f-string: complex, with commas</vh></v>
<v t="ekr.20191128141922.1"><vh>test: print one f-string</vh></v>
<v t="ekr.20191204150947.1"><vh>test: regex string</vh></v>
<v t="ekr.20191129042702.1"><vh>test: simple f-string tests</vh></v>
</v>
</v>
</v>
<v t="ekr.20191121063148.1"><vh>@test tokens: tog vs asttokens</vh></v>
<v t="ekr.20191219054650.1"></v>
</v>
</vnodes>
<tnodes>
<t tx="bwmulder.20050108100437.1">@killcolor

Running unit tests from test.leo is easy, provided you have enabled the
Scripting plugin. When this plugin is enabled Leo will create a blue 'script
button' in the icon bar called 'unit test'. 

- To run all unit tests, select the node in test.leo called 'Unit tests...',
then do &lt;alt-4&gt; 

- To run a single test, select an @test node and do &lt;alt-4&gt;.

- To run a suite of tests, select an @suite node and do &lt;alt-4&gt;.

- To run any other collection of tests, create an outline containing those @test
or @suite nodes, select the root of that tree and do &lt;alt-4&gt; .

Several nodes in the tree @thin ../src/leoTest.py (in test.leo) contain support
code for @test, @suite, etc. so if you want all the gory details you can read
the code. It's not complicated: Leo creates UnitTest classes automatically whose
run method is the body of the @suite or @test node.
</t>
<t tx="ekr.20041121151002"># Many of these are required for unit tests.
# Do not change them without running all unit tests.</t>
<t tx="ekr.20050328101834"></t>
<t tx="ekr.20050328101834.1"></t>
<t tx="ekr.20050328101834.2"></t>
<t tx="ekr.20050328101834.3"></t>
<t tx="ekr.20050618061835">@killcolor

Here is a tutorial written by Roger Erens.

Version Date        LeoID       Remarks
------- ----        -----       -------
0.1     20050519    rogererens  Initial version</t>
<t tx="ekr.20050618061835.1">So you think "Well, since I've written this piece of funky Python software, and everybody keeps saying how useful unit testing is, I really ought to start using unit tests." And since Leo's creator has said countless times in the Leo forums how easy unit testing in Leo is, a few uncomplicated examples might help convince you that he's not spamming.

Beware: this How-To should be the last time that you write tests AFTER having written your funky software! Test Driven Development dictates that tests have to be prepared BEFORE you get down to writing your actual code. See a nice tutorial on O'Reilly's website (url given in the descendant node).</t>
<t tx="ekr.20050618061835.10">Start of Do @test
F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Documents and Settings\re1705\My Documents\PythonStuff\leo\src\leoTes
t.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.010s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.11">A real fun feature of Leo is that Leo saves you from having to select each and single @test node and press the 'Do @test' button to obtain testing results. Just collecting the @test nodes under an organizing node, selecting that organizing node, and pressing the 'Do @test' button will suffice.
Of course, this was one of the key ideas of unit testing, but it's nice to see it being implemented by Leo so smoothly!

So, press the button while having this node selected, and see if your console's output matches the third child node more or less. </t>
<t tx="ekr.20050618061835.12">Start of Do @test
.F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 2 tests in 0.040s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.13">Okay: so you've seen now some simple stand-alone tests to get your toes wet.
Now, we get to the 'grande finale' and see real-life usage of the @test nodes.

The @test child node below illustrates the following points:

1.  The node imports the module to test (and keeps it up to date by reloading it).
2.  It also obtains data to use as input and referral. This is what you might call
    the setUp methods in traditional unit tests. If more tests need the same data,
    you can put the nodes in a central place where all the @test nodes can find
    them. Likewise, common code for several unit tests might be collected in a
    central place.
3.  Comparable with the traditional unit tests' tearDown method, some statements
    can follow the test itself, if neccessary. You might also consider using a
    try/finally construct.
4.  I have used g.es() statements instead of print statements, since the latter
    clutter the console. Try replacing the g.es() statements by corresponding
    print statements to see what I mean. With more than one @test node being tested,
    this will give quite a dreadful look.</t>
<t tx="ekr.20050618061835.14">@color

try:
    # SETUP
    import koekiemonster # this module defines a function want() which we want to test
    reload(koekiemonster) # changes in koekiemonster need to propagate to the test

    # obtaining the input parameter for the function
    inputNode = p.firstChild()
    inputData = inputNode.b
    
    # obtaining the expected result from the function with above input parameter
    expectedResultNode = inputNode.next()
    expected = expectedResultNode.b
    
    # execute the function with above input parameter
    result = koekiemonster.wants(inputData)
    
    # TEST
    assert(result == expected)
    
    # TEARDOWN
    g.es("Now it's time to clean up")

except AssertionError:
    # TEARDOWN
    g.es("Oh oh! %s failed:" % p.h.strip())
    g.es("koekiemonster.wants(%s)==%s" % (inputData, result))
    g.es("Expected: %s" % expected)
    raise # pass the exception on to the unit test machinery</t>
<t tx="ekr.20050618061835.15">vegetables</t>
<t tx="ekr.20050618061835.16">Yuck!</t>
<t tx="ekr.20050618061835.17">Start of Do @test
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.070s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.18">Start of Do @test
Oh oh: @test koekiemonster.wants() failed:
koekiemonster.wants(vegetables)=Yack!
Expected: Yuck!
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.051s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.19">With the aforementioned possibilities of running all @test nodes in a subtree
with a single click on a button, the sharing of input/expected data, and the
sharing of setUp/tearDown code, there hardly seems a need for the @suite nodes.

On Leo's website
(http://webpages.charter.net/edreamleo/scripting.html#unit-testing-with-test-and-suite)
I could still find some extra info on @suite nodes, not found in LeoDocs.leo:

&lt;quote&gt;

Using @suite nodes

Such nodes create a suite of tests. Leo executes the script in these nodes similar to @test nodes, but Leo assumes that the script in an @suite node will do the following:

    * Create a suite of unit tests
    * Put the suite in g.app.scriptDict["suite"]

The difference between @test and @suite is:

    * Leo creates a unit test from script in an @test node by creating an instance of generalTestCase, a subclass of unittest.TestCase.
    * The script in an @suite node creates the test suite.

An @suite nodes allows us to create "legacy" unit tests simply. For example,
rather than rewriting all the reformatParagraph unit tests to use @test nodes, I
simply wrote an @suite node with the following body.

    suite = c.testManager.makeReformatParagraphSuite()
    g.app.scriptDict['suite'] = suite

&lt;/quote&gt;

Well, that's almost, but not quite completely, totally incomprehensible to me.
Fortunately, since Leo's creator removed most of this quote from LeoDocs.leo and
test.leo, this information appears to be outdated
.</t>
<t tx="ekr.20050618061835.2"></t>
<t tx="ekr.20050618061835.20">Don't forget to read the node
Users Guide--&gt;Chapter 7: Scripting Leo with Python--&gt;Unit testing with @test, @suite
in LeoDocs.leo, especially the final notes. Also investigate a little further in test.leo to see some heavy weight lifting.

This concludes my How-To on using @test. It was not written by an expert on (unit) testing;
it is more or less the result of keeping notes on my way to find out how I could get started
with unit tests in Leo. Maybe it's useful for other newbies as well.

Please post any remarks on one of the Leo Fora, and if deemed helpful, I'll be glad to incorporate them into a next version.

Happy testing!</t>
<t tx="ekr.20050618061835.3">Comment by EKR: There is no need to do this if you use test.leo for your unit tests:  just use the unit test button.

From the console, start up a Leo instance. On MS Windows: go to the folder in which you installed Leo 4.3, open up the 'src' folder and double click the 'leo.py' file. Opening a command window, and typing "python leo.py" may be another way.

Use the File--&gt;Open... menu item to open the outline containing your code.

Choose a good-looking position to insert a new node called 'Test zone'. Copy the child node of the node you're reading right now, and paste it as a child node of 'Test zone'. The code it contains is essentially the same as found in the node
Unit tests...--&gt;Do @test
in the file 'test.leo' in the 'test' folder. I just added my 0.2 cents by adding some starting and finishing remarks. Remove them if they clutter your console too much.

Also, make sure that you have an entry 'Scripting' in the 'Plugins' menu (enable the plugin if neccessary). Now is a good time to save your leo file.

With the 'Scripting' plugin (also known as the 'mod_scripting' plugin) enabled, the net effect will be that the next time you open your outline, a blue button with the caption 'Do @test' shows up in the tool bar of Leo, if your screen is wide enough.
To get the button right away in the tool bar, I have to assume that you started Leo with the scripting plugin enabled. In this case, a yellow button with the caption 'script Button' can be pressed while having the node '@button Do @test' selected. Note: the resulting button will not be blue, but pink. Removing a button from the tool bar can be done by right-clicking it.

We'll see the use of this added button soon, but before that, read up on the 'assert' function in the Python manuals, since it is used a lot in testing. It won't be long before you're back here!</t>
<t tx="ekr.20050618061835.4">@color

g.pr("\nStart of Do @test")
c.testManager.doTests(all=False)
g.pr("End of Do @test")</t>
<t tx="ekr.20050618061835.5">The first child node of the node you're reading right now, contains the simplest succeeding test possible.
Select it, and press the button 'Do @test'.
You can find the verbatim result as it got sent to my console in the second child node.

A few things are worth noting here:

1.  The node containing the test must have its headline start with '@test'.
2.  Whenever the 'assert' statement finds out that the expression given to it
    is 'True', a test passes successfully. There are more ways to pass a test, but
    for now, let us stick to the use of assert functions.
3.  A passed test is denoted with a single dot in the output. See the line between
    'Start of Do @test' and the line filled with dashes. This is compatible with the
    way traditional unit testing shows its progress.
4.  Below the dashed line in the output, a summary is printed. This one surely gives
    us a reason to lean back for a moment, and congratualate ourselves with another
    piece of robust, funky code!</t>
<t tx="ekr.20050618061835.6">@color
assert(True)</t>
<t tx="ekr.20050618061835.7">Start of Do @test
.
----------------------------------------------------------------------
Ran 1 test in 0.010s

OK
End of Do @test</t>
<t tx="ekr.20050618061835.8">Now that you've seen a passing test, it should be obvious to imagine how a failing test would look like. See the first child node, and then run it by pressing the 'Do @test' button as before.

Instead of a dot denoting success, we get an 'F' denoting a failure on the line following 'Start of Do @test'. When running a lot of tests, the next part, following the lines filled with '='s, helps to identify which test failed.
It also includes a trace back, but for AssertionErrors, it does not seem to offer much added value to me right now. On second thought: when you have multiple asserts in a test, the trace back can tell you which assert function failed. Still, I would choose for only one assert function per test and get rid of this trace back altogether. This would keep the console much cleaner, IMHO.</t>
<t tx="ekr.20050618061835.9">@color
assert('Spam' == 'Ham')</t>
<t tx="ekr.20051012104957">@nosearch</t>
<t tx="ekr.20051013162226"></t>
<t tx="ekr.20051107115231.16">import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
g.app.gui.set_focus(c,w)
w2 = g.app.gui.get_focus(c)
try:
    assert w
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w,'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste,'Expected: %s, got %s' % (
        h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20051107115231.17">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
if g.app.gui.guiName() == 'curses':
    # This could be adapted, but not now.
    self.skipTest('Not for curses gui')
k = c.k
if k.defaultUnboundKeyAction != 'insert':
    self.skipTest('defaultUnboundKeyAction != insert')
if not k.getStrokeForCommandName('undo'):
    self.skipTest('no settings')

frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make the node visible.
w = c.edit_widget(p)
try:
    assert w, 'oops1'
    wName = g.app.gui.widget_name(w)
    assert wName.startswith('head'),'w.name:%s' % wName
    w.setSelectionRange('end','end')
    g.app.gui.event_generate(c,'X','Shift+X',w)
    g.app.gui.event_generate(c,'Y','Shift+Y',w)
    g.app.gui.event_generate(c,'Z','Shift+Z',w)
    g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + 'XYZ',(
        'oops2: expected: %s, got: %s' % (
            h + 'XYZ',p.h))
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.undoMenuLabel == 'Undo Typing','oops3: %s' % (
            c.undoer.undoMenuLabel)
    k.manufactureKeyPressForCommandName(w,'undo')
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.redoMenuLabel == 'Redo Typing','oops4'
    assert p.h == h,'oops5 got: %s, expected: %s' % (
        p.h,h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20051107115231.18">import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
frame = c.frame
tree = frame.tree
canvas = tree.canvas
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w,'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste,'oops2 got: %s' % p.h
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'oops3 got: %s' % p.h
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20051107115231.20">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.keyHandler
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w, 'Null w'
        paste = 'ABC'
        g.app.gui.replaceClipboardWith(paste)
        w.setSelectionRange('1.1','1.2')
        if g.app.gui.guiName() == 'curses':
            c.frame.pasteText(event=g.Bunch(widget=w))
        else:
            stroke = k.getStrokeForCommandName('paste-text')
            if stroke is None:
                self.skipTest('no binding for paste-text') # #1345
            k.manufactureKeyPressForCommandName(w,'paste-text')
            g.app.gui.event_generate(c,'\n','Return',w)
        assert p.h == h[0] + paste + h[2:]
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, 'head mismatch'
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20060325071703.1">import sys

win32  = c.config.getBool('test_win32_setting')
darwin = c.config.getBool('test_darwin_setting')

if win32 is None and darwin is None:
    self.skipTest('settings not loaded') # #1345

if sys.platform == 'win32':
    assert(win32)
    assert(not darwin)

elif sys.platform== 'darwin':
    assert(not win32)
    assert(darwin)

</t>
<t tx="ekr.20070113145100"># Not part of cvs distributions, but needed for two unit tests.

dir = g.os_path_join(g.app.loadDir,'..','test','unittest',g.u('chinese\u8116folder'),encoding='utf-8')
s   = g.os_path_join(dir,g.u('chinese\u8116test.leo'),encoding='utf-8')
    
if not g.os_path_exists(dir):
    import os
    os.mkdir(dir)
    g.pr('created chinese folder')
    
if not g.os_path_exists(s):
    f = file(s,'w')
    f.close()
    g.pr('created chinese file')
    
</t>
<t tx="ekr.20070217065840">@nocolor-node

@
To make unit tests, do the following:
    
- Use the make-test script (Alt-5) to create a suboutline for a unit test.
- Put text in the before node, selected desired text, then do the do-before script (Alt-6).
- Execute the command, then do the do-after script (Alt-7).
</t>
<t tx="ekr.20070217065840.1">try:
    p1 = p.insertAfter()
    c.setHeadString(p1,'@test ')
    body = 'c.testManager.runEditCommandTest(c,p)'
    c.setBodyString(p1,body)
    for s in ('work','before','after'):
        p2 = p1.insertAsLastChild()
        c.setHeadString(p2,s)
    p1.expand()
finally:
    c.redraw()
    c.editPosition(p1)</t>
<t tx="ekr.20070217065840.2">@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. The work node should have body text. If all is as expected,
copy the body text the work node to the before node, and represent the selection
range of the work in the headline of the before node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top and work.b:

    c.setBodyString(before,work.b)
    c.setBodyString(after,'')
    putSelectionInHeadline(c,before,'before',sel)
    c.redraw()
else:
    g.es_print('do-before: not in a proper @test tree')</t>
<t tx="ekr.20070217065840.3">def getSel(c):
    
    w = c.frame.body.bodyCtrl
    i,j= w.getSelectionRange()
    if i == j:
        i = j = w.getInsertPoint()
        sel = (i,i)
    return i,j</t>
<t tx="ekr.20070217065840.4">def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.h.startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild() 
    before = work and work.next()     
    after  = before and before.next()
    if (
        work   and work.h.startswith('work') and
        before and before.h.startswith('before') and
        after  and after.h.startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None</t>
<t tx="ekr.20070217065840.5">def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.h,repr(sel))

    w = c.frame.body.bodyCtrl
    i,j = sel
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    s = '%s sel=%s,%s' % (prefix,i,j)
    c.setHeadString(p,s)
</t>
<t tx="ekr.20070217065840.6">@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. If all is as expected, copy the work node to the after node,
and represent the selection range of the work node in the headline of the after node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top:
    c.setBodyString(after,work.b)
    putSelectionInHeadline(c,after,'after',sel)
    c.redraw()
else:
    g.es_print('do-after: not in @test tree')</t>
<t tx="ekr.20070217065840.8">def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.h.startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild()
    before = work and work.next()
    after  = before and before.next()
    if (
        work   and work.h.startswith('work') and
        before and before.h.startswith('before') and
        after  and after.h.startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None</t>
<t tx="ekr.20070217065840.9">def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.h,repr(sel))
    
    w = c.frame.body.bodyCtrl
    i,j = sel
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    s = '%s sel=%s,%s' % (prefix,i,j)
    c.setHeadString(p,s)
</t>
<t tx="ekr.20070217072822">def getSel(c):
    
    w = c.frame.body.bodyCtrl
    i,j= w.getSelectionRange()
    if i == j:
        i = j = w.getInsertPoint()
        sel = (i,i)
    return i,j</t>
<t tx="ekr.20070417092935"># TARGETWORD

w = c.frame.body.wrapper

for (which,result) in (('cap','Targetword'),('low','targetword'),('up','TARGETWORD')):
    w.setInsertPoint(5)
    c.editCommands.capitalizeHelper(event=None,which=which,undoType=None)
    s = w.getAllText()
    word = s[2:12]
    assert word == result, 'Expected %s, got: %s' % (result,repr(word))
    i = w.getInsertPoint()
    assert i == 5, 'Expected 5, got: %d' % i
</t>
<t tx="ekr.20070503064257"></t>
<t tx="ekr.20070528100318"># Required to make a typing test work.
</t>
<t tx="ekr.20071113140035">fn = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','core','leoPy.leo'))
assert g.os_path_exists(fn),fn
c1 = c
c2 = g.openWithFileName(fn,old_c=None,enableLog=False)
assert c2
c.frame.bringToFront()
g.app.setLog(c.frame.log)

d1 = {} ; d2 = {}
for c,d in ( (c1,d1),(c2,d2)):
    for p in c.all_unique_positions():
        if p.h.startswith('@test'):
            d[p.h]=p.h

if 0: # not important
    g.pr()
    g.pr('----- Only in unitTest.leo')
    for h in sorted(d1.keys()):
        if not d2.get(h):
            print(h)

print('\n----- Only in leoPy.leo')
for h in sorted(d2.keys()):
    if not d1.get(h):
        print(h)</t>
<t tx="ekr.20080324133327.2">True: allow linux-like pastes using a mouse's middle button.

Important: this may cause crashes on some platforms.
</t>
<t tx="ekr.20090529141856.4718">if False: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.c)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
class cTestClass1 {

    int foo (int a) {
        a = 2 ;
    }

    char bar (float c) {
        ;
    }
}
'''
table = (
    'class cTestClass1',
    'int foo',
    'char bar',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4719">if g.in_bridge:
    self.skipTest('In bridge')

if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.c)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
class cTestClass1 {

    int foo (int a) {
// an underindented line.
        a = 2 ;
    }

    // This should go with the next function.

    char bar (float c) {
        ;
    }
}
'''
table = (
    'class cTestClass1',
    'int foo',
    'char bar',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4721">if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.c)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) //  &lt;---------------------problem
{
    return true;
}
'''
table = (
    'void aaa::bbb::doit',
    'bool aaa::bbb::dothat',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children 
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4722">if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.c)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) 
{
    return true;
} //  &lt;---------------------problem
'''
table = (
    'void aaa::bbb::doit',
    'bool aaa::bbb::dothat',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4723">if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.c)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
s = '''
void
aaa::bbb::doit
    (
    awk* b  // leading blank
    )
{
	assert(false); // leading tab
}

'''
table = (
    'void aaa::bbb::doit',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4724">if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.c)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
static void
ReleaseCharSet(cset)
    CharSet *cset;
{
    ckfree((char *)cset-&gt;chars);
    if (cset-&gt;ranges) {
    ckfree((char *)cset-&gt;ranges);
    }
}
'''
table = (
    'static void ReleaseCharSet',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4725">if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.c)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
Tcl_Obj *
Tcl_NewLongObj(longValue)
    register long longValue;	/* Long integer used to initialize the
         * new object. */
{
    return Tcl_DbNewLongObj(longValue, "unknown", 0);
}
'''
table = (
    'Tcl_Obj * Tcl_NewLongObj',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4726">if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.c)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
extern "C"
{
#include "stuff.h"
void    init(void);
#include "that.h"
}
'''
table = (
    'extern "C"',
)
try:
    ic.cUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4733">if 0:
    # The preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.elisp
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.elisp)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
;;; comment
;;; continue
;;;

(defun abc (a b)
   (+ 1 2 3))

; comm
(defun cde (a b)
   (+ 1 2 3))
'''

table = (
    'defun abc',
    'defun cde',
)
try:
    ic.elispUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()

</t>
<t tx="ekr.20090529141856.4735">if 0:
    # The preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.pascal
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.pascal)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''
unit Unit1;

interface

uses
Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
Forms,
Dialogs;

type
TForm1 = class(TForm)
procedure FormCreate(Sender: TObject);
private
{ Private declarations }
public
{ Public declarations }
end;

var
Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.FormCreate(Sender: TObject);
var
x,y: double;
begin
x:= 4;
Y := x/2;
end;

end. // interface
'''
table = (
    'interface',
    'procedure FormCreate',
    'procedure TForm1.FormCreate',
)
try:
    ic.pascalUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20090529141856.4767">if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.java)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
interface Bicycle {
    void changeCadence(int newValue);
    void changeGear(int newValue);
}
'''
table = (
    'interface Bicycle',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4768">if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.java)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
interface Bicycle {
void changeCadence(int newValue);
void changeGear(int newValue);
}
'''
table = (
    'interface Bicycle',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4770">if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.java)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
/**
 * Indicates the caller's authority to perform lifecycle operations on
 */

public final class AdminPermission extends BasicPermission
{
    /**
     * Creates a new &lt;tt&gt;AdminPermission&lt;/tt&gt; object.
     */
    public AdminPermission()
    {
        super("AdminPermission");
    }
}
'''
table = (
    'public final class AdminPermission extends BasicPermission',
    'public AdminPermission',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4773">@language python
@tabwidth 8
    # Must be in this node when run externally.
    
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.java
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.java)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
/*
 * $Header: /cvs/leo/test/unitTest.leo,v 1.247 2008/02/14 14:59:04 edream Exp $
 * 
 * Copyright (c) OSGi Alliance (2000, 2005). All Rights Reserved.
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this 
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html.
 */

package org.osgi.framework;

/**
 * A Framework exception used to indicate that a bundle lifecycle problem
 * occurred.
 * 
 * &lt;p&gt;
 * &lt;code&gt;BundleException&lt;/code&gt; object is created by the Framework to denote
 * an exception condition in the lifecycle of a bundle.
 * &lt;code&gt;BundleException&lt;/code&gt;s should not be created by bundle developers.
 * 
 * &lt;p&gt;
 * This exception is updated to conform to the general purpose exception
 * chaining mechanism.
 * 
 * @version $Revision: 1.247 $
 */

public class BundleException extends Exception {
	static final long	serialVersionUID	= 3571095144220455665L;
	/**
	 * Nested exception.
	 */
	private Throwable	cause;

	/**
	 * Creates a &lt;code&gt;BundleException&lt;/code&gt; that wraps another exception.
	 * 
	 * @param msg The associated message.
	 * @param cause The cause of this exception.
	 */
	public BundleException(String msg, Throwable cause) {
		super(msg);
		this.cause = cause;
	}
}

'''
table = (
    'public class BundleException extends Exception',
    'public BundleException',
)
try:
    ic.javaUnitTest(p,s=s,showTree=True)
    if 1: # Check structure
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for i, h in enumerate(table):
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1: # Delete children
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4785">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.leo_rst)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

====
top
====

The top section

section 1
---------

section 1, line 1
--
section 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''
table = (
    '!Dummy chapter',
    'top',
    'section 1',
    'section 2',
    'section 2.1',
    'section 2.1.1',
    'section 3',
    'placeholder',
    'section 3.1.1',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4786">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.leo_rst)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

top
====

The top section

section 1
---------

section 1, line 1
--
section 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''
table = (
    '!Dummy chapter',
    'top',
    'section 1',
    'section 2',
    'section 2.1',
    'section 2.1.1',
    'section 3',
    'placeholder',
    'section 3.1.1',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4787">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.leo_rst)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
s = '''\
.. toc

top
-------------

The top section
'''
table = (
    '!Dummy chapter',
    'top',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20090529141856.4788">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.leo_rst)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

======
top
======

The top section
'''
table = (
    "!Dummy chapter",
    "top",
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20091206090247.5060"># Use these with caution.</t>
<t tx="ekr.20091206090247.5061">count = 0
for p in c.all_unique_positions():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        ### c.setChanged(True)
        c.setChanged()

s = "%d nodes" % count
print(s) ; g.es(s)</t>
<t tx="ekr.20091206090247.5062"># About the only time you should run this script is when:
# - changing the format of timestamps in nodeIndices.setTimestamp or
# - when making a retroactive change to leoID.txt.

if 0: # This is usually a very bad idea.

    for p in c.all_positions():
        p.v.fileIndex = None

    g.es("all timestamps cleared")</t>
<t tx="ekr.20091206090247.5063">doDelete = False
put = g.es_print
for p in c.all_positions():
    if p.v.u:
        put("found v.u:",p.h,
            g.listToString(p.v.u.keys()))
        if doDelete:
            p.v.u = None
put('done') 
c.redraw()</t>
<t tx="ekr.20100102164959.5088">nodes = 0 ; lines = 0
for p in c.all_unique_positions():
    nodes += 1
    lines += len(g.splitLines(p.b))

pages = ((nodes * 10) + lines) / 50
s = "%d nodes,  %d lines, %d pages" % (nodes,lines,pages)
print(s); g.es(s)</t>
<t tx="ekr.20100123172713.5114"></t>
<t tx="ekr.20100123172713.5116">count = 0
for p in c.all_unique_positions():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList"): # and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        ### c.setChanged(True)
        c.setChanged()

s = "%d nodes" % count
print s ; g.es(s)</t>
<t tx="ekr.20100131171342.5473"></t>
<t tx="ekr.20100131171342.5474">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)
    assert(tkGui)

    import leo.core.leoFrame as leoFrame
    import inspect,sys

    baseClass = leoFrame.leoBody
    subClasses  = (tkGui.leoTkinterBody,leoFrame.nullBody)
    baseObject = c.frame.body

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        try:
            assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)
        except AssertionError:
            exctype, value = sys.exc_info()[:2]
            print(value)
            raise

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                #raise
                exctype, value = sys.exc_info()[:2]
                print(value)
</t>
<t tx="ekr.20100131171342.5475">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoFrame
    subClasses  = (tkGui.leoTkinterFrame,leoFrame.NullFrame)
    baseObject = c.frame

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
</t>
<t tx="ekr.20100131171342.5476">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoGui as leoGui
    import inspect

    baseClass = leoGui.leoGui
    subClasses  = (tkGui.tkinterGui,) # nullGui can inherit almost all leoGui dummy methods.
    baseObject = g.app.gui

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                raise
</t>
<t tx="ekr.20100131171342.5477">if g.app.gui.guiName() == 'tkinter':

    pc = g.app.pluginsController
    tkGui = pc.loadOnePlugin('leo.plugins.tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoTree
    subClasses  = (tkGui.leoTkinterTree,leoFrame.nullTree)
    baseObject = c.frame.tree

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
</t>
<t tx="ekr.20100131171342.5478">logCtrl = c.frame.log.logCtrl

table = (
    ('mustBeDefinedInSubclasses',logCtrl.mustBeDefinedInSubclasses),
    ('mustBeDefinedInBaseClass',logCtrl.mustBeDefinedOnlyInBaseClass),
    ('mustBeDefined',logCtrl.mustBeDefined),
)

# Check existence.
for tag,aList in table:
    for z in aList:
        assert hasattr(c.frame.log,z),'%s %s %s' % (tag,c.frame.log,z)
        assert hasattr(c.frame.body,z),'%s %s %s' % (tag,c.frame.body,z)

# Check signatures.
import inspect
for tag,aList in table:
    for z in aList:
        func = getattr(c.frame.body.bodyCtrl,z)
        func2 = getattr(c.frame.log.logCtrl,z)
        assert func,z
        assert func2,z
        d1 = inspect.getargspec(func)
        d2 = inspect.getargspec(func2)
        assert d1==d2,'\n%s\n\nd1 %s\n\nd2 %s' % (z,d1,d2)
</t>
<t tx="ekr.20100204165850.5373">if g.app.inBridge:
    self.skipTest('in bridge')
k = c.k
colorizer = c.frame.body.getColorizer()
ed = c.editCommands
# These don't set ivars
    # 'toggle-active-pane'),
    # 'toggle-angle-brackets',
    # 'toggle-input-state'),
    # 'toggle-mini-buffer'),
    # 'toggle-split-direction'),
table = [
    (k,'abbrevOn','toggle-abbrev-mode'),
    (ed,'extendMode','toggle-extend-mode'),
]
# Not valid for external tests.
table2 = [
    (k,'enable_autocompleter','toggle-autocompleter'),
    (k,'enable_calltips','toggle-calltips'),
    (c,'sparse_find','toggle-find-collapses-nodes'),
    (colorizer,'showInvisibles','toggle-invisibles'),
    (c,'sparse_move','toggle-sparse-move'),
]
if not g.app.isExternalUnitTest:
    table.extend(table2)
for obj,ivar,command in table:
    val1 = getattr(obj,ivar)
    try:
        k.simulateCommand(command)
        val2 = getattr(obj,ivar)
        assert val2 == (not val1),'failed 1 %s' % command
        k.simulateCommand(command)
        val3 = getattr(obj,ivar)
        assert val3 == val1,'failed 2 %s' % command
    finally:
        setattr(obj,ivar,val1)
</t>
<t tx="ekr.20100212104817.5351">result = c.helpCommands.getBindingsForCommand('help')
if not result:
    self.skipTest('no settings')
assert result.strip().lower()=='f1', repr(result)
</t>
<t tx="ekr.20101220161557.6016"># Nov. 2016: 878 tests.
# Nov. 2017: 916 tests, 25 skipped.

# Some tests are disabled when g.app.isExternalUnitTest is True.
# Using self.skipTest(reason) is now preferred.
</t>
<t tx="ekr.20110521073115.3494"></t>
<t tx="ekr.20110521073115.3495">builtins, including cython builtins
</t>
<t tx="ekr.20110521073115.3496">cython keywords
</t>
<t tx="ekr.20111026111009.3972"># lowercase xml tags, one per line.

html
body
head
div
table
nodeA
nodeB
</t>
<t tx="ekr.20111112092813.4154">g.cls()</t>
<t tx="ekr.20111112093605.4679"># leoSettings.leo no longer sets any bindings for run-xxx-unit-test.
# These are now EKR's preferred settings everywhere:
# there should be little need to run unit tests externally.

run-selected-unit-tests-locally     = Alt-4
run-marked-unit-tests-locally       = Alt-5
run-all-unit-tests-locally          = Alt-6

# Important: Alt-9 is used by a unit test
</t>
<t tx="ekr.20111115080347.3872"></t>
<t tx="ekr.20111123042627.6654"># Leo loads plugins in the order they appear here.

# **Important**: to change these defaults, put
# an @enabled-plugins node in myLeoSettings.leo.

# Highly-recommended plugins:
plugins_menu.py
free_layout.py # needs to be early
viewrendered.py

# Recommended plugins:
### contextmenu.py
# leo_to_html.py
mod_scripting.py
# nav_qt.py
# quicksearch.py
# stickynotes.py
# todo.py
</t>
<t tx="ekr.20111124090010.3939">if g.app.gui.guiName() == 'browser':
    self.skipTest('browser gui')
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
if getattr(g.app, 'isBrowserTest', None):
    # Set only in test_browser_gui.py.
    self.skipTest('Browser Gui test')
d = g.app.config.unitTestDict # Always created for this unit test.
keys = ('config.doButtons-file-names','config.doCommands-file-names')
for key in keys:
    aList = d.get(key,[])
    if 'leoSettings' not in aList:
        self.skipTest('no settings') # #1345
    for base in ('leoSettings', 'unitTest'):
        for ext in ('.leo', '.db'):
            if base+ext in aList:
                break
        else:
            print('key', key, 'ext', ext, 'base', base)
            g.printObj(aList)
            assert False,'%s not in unitTestDict[%s]' % (base,key)
</t>
<t tx="ekr.20111124094121.3941"># These exist for a unit test.</t>
<t tx="ekr.20111124094121.3942"></t>
<t tx="ekr.20111124094121.3943"></t>
<t tx="ekr.20111125182408.3947">def setup():
    while p.hasChildren():
        p.firstChild().doDelete()

setup()

try:
    files = (r'a\b.c',r'a\b.h',)
    c.importCommands.createImportParent(p,files)
    child = p.firstChild()
    assert child
    assert child.h == 'a/b',child.h
finally:
    setup()</t>
<t tx="ekr.20111125183140.3952">child = p.firstChild()
def setup():
    while p.hasChildren():
        p.firstChild().doDelete()

setup()
try:
    c.importCommands.createOutline(
        fileName=r'a\b\c.xyzzy',
        parent=p,
        atAuto=False,atShadow=False,
        s='test body',
        ext='xyzzy'
    )
    child = p.firstChild()
    assert child
    h = g.os_path_finalize_join(g.app.loadDir,'..','test','a','b','c.xyzzy')
    h = h.replace('\\','/')
    h = '@file ' + h
    # C: vs c: is not relevant here.
    assert child.h.lower() == h.lower(),child.h
finally:
    setup()</t>
<t tx="ekr.20111211094936.3970"></t>
<t tx="ekr.20131111155830.4249"></t>
<t tx="ekr.20131111155830.4250"># Not yet...

    &lt;BS&gt;        delete the character in front of the cursor
N   &lt;Del&gt;       delete N characters under and after the cursor
    &lt;Del&gt;       delete the character under the cursor
    &lt;Del&gt;       while entering a count: delete last character
    &lt;Down&gt;      recall newer command-line that starts with current command
    &lt;Esc&gt;       abandon command-line (if 'wildchar' is &lt;Esc&gt;, type it twice)
    &lt;Left&gt;      (motion) cursor left
    &lt;Right&gt;     (motion) cursor right
    &lt;S-Down&gt;    recall newer command-line from history
    &lt;S-Left&gt;    (motion) cursor one word left
    &lt;S-Right&gt;   (motion) cursor one word right
    &lt;S-Up&gt;      recall older command-line from history
    &lt;Up&gt;        recall older command-line that starts with current command

N   CTRL-^                  Edit alternate file N (equivalent to ":e #N").
N   CTRL-A                  add N to the number at or after the cursor
N   CTRL-B                  window N pages Backwards (upwards)
    CTRL-B                  (motion?) cursor to beginning of command-line
    CTRL-BREAK              MS-DOS: during searches: interrupt the search
    CTRL-C                  during searches: interrupt the search
N   CTRL-D                  window N lines Downwards (default: 1/2 window)
N   CTRL-E                  window N lines downwards (default: 1)
    CTRL-E                  (motion?) cursor to end of command-line
N   CTRL-F                  (motion) window N pages Forwards (downwards)
    CTRL-G                  show current file name (with path) and cursor position
N   CTRL-I                  (motion) go to Nth newer position in jump list
    CTRL-K {char1} {char2}  enter digraph
    CTRL-L                  Clear and redraw the screen.
N   CTRL-O                  (motion) go to Nth older position in jump list
N   CTRL-R                  redo last N undone changes
    CTRL-R &lt;0-9a-z"%:-&gt;     insert contents of register &lt;0-9a-z"%:-&gt;
N   CTRL-T                  (motion) Jump back from Nth older tag in tag list
N   CTRL-U                  window N lines Upwards (default: 1/2 window)
    CTRL-U                  remove all characters
    CTRL-V                  highlight blockwise or stop highlighting
    CTRL-V                  start highlighting blockwise   }  highlighted text
    CTRL-V {char}           insert {char} literally
    CTRL-V {number}         enter decimal value of character (up to three digits)
    CTRL-W                  delete the word in front of the cursor
    CTRL-W +                Increase current window height
    CTRL-W -                Decrease current window height
    CTRL-W =                Make all windows equal height
    CTRL-W CTRL-W           Move cursor to window below (wrap)
    CTRL-W CTRL-^           Split window and edit alternate file
    CTRL-W R                Rotate windows upwards
    CTRL-W W                Move cursor to window above (wrap)
    CTRL-W ]                Split window and jump to tag under cursor
    CTRL-W _                Set current window height (default: very high)
    CTRL-W b                Move cursor to bottom window
    CTRL-W c  or :cl[ose]   Make buffer hidden and close window
    CTRL-W f                Split window and edit file name under the cursor
    CTRL-W j                Move cursor to window below
    CTRL-W k                Move cursor to window above
    CTRL-W n  or :new       Create new empty window
    CTRL-W o  or :on[ly]    Make current window only one on the screen
    CTRL-W p                Move cursor to previous active window
    CTRL-W q  or :q[uit]    Quit editing and close window
    CTRL-W r                Rotate windows downwards
    CTRL-W s                Split window into two parts
    CTRL-W t                Move cursor to top window
    CTRL-W x                Exchange current window with next one
N   CTRL-X                  subtract N from the number at or after the cursor
N   CTRL-Y                  window N lines upwards (default: 1)
    CTRL-Z                  Same as ":stop!"
    CTRL-]                  Jump to the tag under cursor, unless changes have been made</t>
<t tx="ekr.20131111155830.4251">char F
char T
char f
char r
char t
letter m
letter q
motion &lt;
motion &gt;
motion c
motion d
motion gU
motion gq
motion gu
motion g~
motion y
pattern /
pattern ?
register @
</t>
<t tx="ekr.20131111155830.4252"># http://tnerual.eriogerg.free.fr/vimqrc.html
vim_0 0
vim_tilda ~
vim_plus +
vim_underscore _
vim_minus -
vim_comma ,
vim_dot .
vim_semicolon ;
vim_lparen (
vim_rparen )
vim_lcurly {
vim_rcurly }
vim_vertical |
vim_backtick `
vim_dollar $
vim_caret ^
vim_percent %
vim_langle &lt;
vim_langle &lt;&lt;
vim_rangle &gt;
vim_rangle &gt;&gt;
vim_pound #
vim_star *
vim_slash /\\n
vim_slash /
vim_question ?\\n
vim_question ?
vim_at @
vim_at @@
vim_dquote "
vim_lsquare [#
vim_lsquare [(
vim_lsquare [*
vim_lsquare [[
vim_lsquare []
vim_lsquare [p
vim_lsquare [{
vim_rsquare ]#
vim_rsquare ])
vim_rsquare ]*
vim_rsquare ][
vim_rsquare ]]
vim_rsquare ]p
vim_rsquare ]}
vim_A A
vim_B B
vim_C C
vim_D D
vim_E E
vim_F F
vim_G G
vim_H H
vim_I I
vim_J J
vim_K K
vim_M M
vim_L L
vim_N N
vim_O O
vim_P P
vim_R R
vim_S S
vim_T T
vim_U U
vim_V V
vim_W W
vim_X X
vim_Y Y
vim_Z ZQ
vim_Z ZZ
vim_a a
vim_b b
vim_c c
vim_d dd
vim_d d
vim_g g~
vim_g g^
vim_g g#
vim_g g$
vim_g g*
vim_g g0
vim_g gD
vim_g gE
vim_g gI
vim_g gU
vim_g ga
vim_g gd
vim_g ge
vim_g gf
vim_g gg
vim_g gj
vim_g gk
vim_g gq
vim_g gs
vim_g gu
vim_g gv
vim_h h
vim_i i
vim_j j
vim_k k
vim_l l
vim_n n
vim_m m
vim_o o
vim_p p
vim_q q
vim_r r
vim_s s
vim_t t
vim_u u
vim_v v
vim_w w
vim_x x
vim_y y
vim_y yy
vim_z z-
vim_z z.
vim_z z&lt;CR&gt;
vim_z zb
vim_z zh
vim_z zl
vim_z zt
vim_z zz
</t>
<t tx="ekr.20131111155830.4253"># CR
# Ctrl-End
# Ctrl-Home
# Ctrl-Left
# Ctrl-M
# Ctrl-N
# Ctrl-P
# Ctrl-Right
# End
# Home
# Shift-Left
# Shift-Right

( 	
)
{
}
[[
[]
][
]]
$
^	
+
,
-
;
_
0
B
E
F
G
T
W
b
e
f
g$
g^
g0
gE
# gEnd
# gHome	
ge
gg
h
j
k
t
w
</t>
<t tx="ekr.20131111155830.4254">char F
char T
char f
char t
</t>
<t tx="ekr.20140217055617.4231"># For a unit test.</t>
<t tx="ekr.20140716121225.4354">print(p.v.gnx)</t>
<t tx="ekr.20140902101931.4478"></t>
<t tx="ekr.20150216110251.11"># Do not delete this node.
# It is used by unit tests.</t>
<t tx="ekr.20150321155210.11"></t>
<t tx="ekr.20150430053825.1">ac = c.abbrevCommands
assert ac
if c.abbrev_place_start is None or c.abbrev_place_end is None:
    self.skipTest('no abbreviation settings') # #1345.
child = g.findNodeInTree(c,p,'child')
assert child
old_b = child.b
try:
    i,j,val = 0,0,child.b
    # ac.make_script_substitutions(i,j,val)
    # ac.find_place_holder(child,True)
    new_s,i,j = ac.next_place(child.b,offset=0)
    assert i == 34 and j == 40,(i,j)
    new_s2,i,j = ac.next_place(new_s,offset=40)
    assert i == 54 and j == 58,(i,j)
finally:
    child.b = old_b
</t>
<t tx="ekr.20150430061225.1">def spam ():
    """None - Return &lt;|return|&gt;
    """

    &lt;|code|&gt;
</t>
<t tx="ekr.20150602215639.1">True: Automatically beautify all @&lt;file&gt; nodes when saving an outline.

# This *must* be False in unitTest.leo!</t>
<t tx="ekr.20160410152100.2">&lt;&lt; define s &gt;&gt;
if 0:
    # The preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    import leo.plugins.writers.markdown
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.markdown)
    importlib.reload(leo.plugins.writers.markdown)
    importlib.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
    # x = markdown.Markdown_Importer(ic)
else:
    ic = c.importCommands  
try:
    ic.markdownUnitTest(p,s=s,showTree=True) # Must be true.
    table = (
        (1, 'Top'),
        (2, 'Section 1'),
        (2, 'Section 2'),
        (3, 'Section 2.1'),
        (4, 'Section 2.1.1'),
        (3, 'Section 2.2'),
        (2, 'Section 3'),
    )
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@auto-m'), root.h
    p = root.firstChild()
    for n, h in table:
        n2 = p.level() - root.level()
        assert h == p.h, (h, p.h)
        assert n == n2, (n, n2, p.h)
        p.moveToThreadNext()
    assert p == after, p.h
finally:
    if 1:
        if root:
            root.doDelete()
        c.redraw()
</t>
<t tx="ekr.20160411033840.1">&lt;&lt; define s &gt;&gt;
if 0:
    # The preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.markdown)
    # importlib.reload(leo.plugins.writers.markdown)
    importlib.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
try:
    ic.markdownUnitTest(p,s=s,showTree=True) # Must be True.
    table = (
        (1, 'Top'),
        (2, 'Section 1'),
        (2, 'Section 2'),
        (3, 'Section 2.1'),
        (4, 'Section 2.1.1'),
        (3, 'Section 2.2'),
        (2, 'Section 3'),
    )
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@auto-m'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, p.h
finally:
    if 1:
        if root:
            root.doDelete()
        c.redraw()
</t>
<t tx="ekr.20160411034540.1">s = '''\
#Top
The top section

##Section 1
section 1, line 1
section 1, line 2

##Section 2
section 2, line 1

###Section 2.1
section 2.1, line 1

####Section 2.1.1
section 2.2.1 line 1
The next section is empty. It must not be deleted.

###Section 2.2

##Section 3
Section 3, line 1

'''
</t>
<t tx="ekr.20161011052016.1">import importlib
import leo.plugins.importers.javascript as js
importlib.reload(js)
table = (
    # base  result          s
    (None, (0, 0, '/*'),    r'/* abc'),
    (None, (0, 0, ''),      r'a + b // /*'),
    (None, (0, 1, ''),      r'(function'),
    (None, (1, 1, ''),      r'(function(a) {'),
    (None, (0, 0, ''),      r'var x = /abc/'),
    (None, (0, 0, ''),      r'var x = /a"c/'),
    (None, (0, 0, ''),      r'var x = /a\//'),
    (None, (0, 0, ''),      r'var x = /a\//'),
    # (None, (0, 0, ''),      r"console.log(/'\d+'/)"),
    (None, (0, 1, ''),      r'var x = (0,'),
)
for base, result, s in table:
    importer = js.JS_Importer(c.importCommands)
    prev_state = js.JS_ScanState()
    new_state = importer.scan_line(s, prev_state)
    curlies, parens, context = result
    ok = (
        new_state.curlies == curlies and
        new_state.parens == parens and
        new_state.context == context)
    assert ok, '\nnew_state: %s\n        s: %s' % (new_state, s)
</t>
<t tx="ekr.20161011095551.1">True: (Experimental): The @auto write code expands section references.
False: (Legacy):      The @auto write code ignores section references.
</t>
<t tx="ekr.20161109065940.1">import leo.plugins.importers.linescanner as linescanner
# import importlib
# importlib.reload(linescanner)
lines_table = [
    'abc',
    '    xyz',
    '    ',
    '  # comment',
]
for language in ('python', 'coffeescript'):
    importer = linescanner.Importer(
        c.importCommands,
        language = language,
    )
    # print('%s %r' % (language, importer.comment_delim))
    assert importer.single_comment == '#', importer.single_comment
    for line in lines_table:
        lines = [line]
        n = importer.get_leading_indent(lines, 0)
        # print('%s %r' % (n, line))
</t>
<t tx="ekr.20161109065949.1">import leo.plugins.importers.linescanner as linescanner
# import importlib
# importlib.reload(linescanner)
table = [
    (False, 'abc'),
    (False, '    xyz'),
    (True, '    '),
    (True,'  # comment'),
]
importer = linescanner.Importer(c.importCommands, language = 'python')
for val, s in table:
    assert val == importer.is_ws_line(s), (val, repr(s))
</t>
<t tx="ekr.20161115063144.10">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
class aClass:
    def outerDef(self):
        """docstring.
        line two."""

        def pr(*args,**keys):
            g.es_print(color='blue',*args,**keys)

        a = 3
'''
table = (
    (1, 'class aClass'),
    (2, 'outerDef'),
    # (3, 'pr'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.11">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\

class test:

    def importFilesCommand (self,files=None,treeType=None,
        perfectImport=True,testing=False,verbose=False):
            # Not a command.  It must *not* have an event arg.

        c = self.c
        if c == None: return
        p = c.currentPosition()

    # Used by paste logic.

    def convertMoreStringToOutlineAfter (self,s,firstVnode):
        s = string.replace(s,"\\r","")
        strings = string.split(s,"\\n")
        return self.convertMoreStringsToOutlineAfter(strings,firstVnode)
'''
table = (
    (1, 'class test'),
    (2, 'importFilesCommand'),
    (2, 'convertMoreStringToOutlineAfter'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        root.doDelete()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.12">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\

class test:
    def spam(b):
        pass

    # Used by paste logic.

    def foo(a):
        pass
'''
table = (
    (1, 'class test'),
    (2, 'spam'),
    (2, 'foo'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.16">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\

class mammalProviderBase(object):
    """Root class for content providers used by DWEtree.py"""
    def __init__(self, params):
        """store reference to parameters"""
        self.params = params
    def provide(self, what):
        """default &lt;BASE&gt; value"""
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/'])
        return None

    def imagePath(self, sppdat):
        """return path to images and list of images for *species*"""
        path = 'MNMammals/imglib/Mammalia'
        for i in 'Order', 'Family', 'Genus', 'Species':
            path = os.path.join(path, sppdat['%sName' % (i,)])
        imglib = os.path.join('/var/www',path)
        imglib = os.path.join(imglib, '*.[Jj][Pp][Gg]')
        path = os.path.join('/',path)
        lst = [os.path.split(i)[1] for i in glob.glob(imglib)]
        lst.sort()
        return path, lst

class mainPages(mammalProviderBase):
    """provide content for pages in 'main' folder"""
    __parent = mammalProviderBase
    def provide(self, what):
        """add one layer to &lt;BASE&gt;"""
        ans = self.__parent.provide(self, what)
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/']+'main/')
        return ans
''' 
table = (
    (1, 'class mammalProviderBase(object)'),
    (2, '__init__'),
    (2, 'provide'),
    (2, 'imagePath'),
    (1, 'class mainPages(mammalProviderBase)'),
    (2, 'provide'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.24">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
# This caused PyParse.py not to be imported properly.
s = r'''
import re
if 0: # Causes the 'overindent'
   if 0:   # for throwaway debugging output
      def dump(*stuff):
        sys.__stdout__.write(" ".join(map(str, stuff)) + "\n")
for ch in "({[":
   _tran[ord(ch)] = '('
class testClass1:
    pass
'''
table = (
    (1, 'Declarations'),
    (1, 'class testClass1'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.31">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\

class emptyClass: 

    def spam():
        """docstring line 1
under-indented docstring line"""
        pass

def followingDef(): # comment
    pass
'''
table = (
    (1, 'class emptyClass'),
    (2, 'spam'),
    (1, 'followingDef'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.34"># Was unittest/at_auto-unit-test.py
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
class class1:
    def class1_method1():
        pass
    def class1_method2():
        pass
    # After @others in child1.
class class2:
    def class2_method1():
        pass
    def class2_method2():
        pass
# last line
'''
table = (
    (1, 'class class1'),
    (2, 'class1_method1'),
    (2, 'class1_method2'),
    (1, 'class class2'),
    (2, 'class2_method1'),
    (2, 'class2_method2'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()

</t>
<t tx="ekr.20161115063144.7">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
NS = { 'i': 'http://www.inkscape.org/namespaces/inkscape',
      's': 'http://www.w3.org/2000/svg',
      'xlink' : 'http://www.w3.org/1999/xlink'}

tabLevels = 4  # number of defined tablevels, FIXME, could derive from template?
'''
table = (
    (1, 'Declarations'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115063144.8">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = '''\
import leo.core.leoGlobals as g

a = 3
'''
table = (
    (1, 'Declarations'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161115092708.1">import leo.plugins.importers.python as python
# import importlib
# importlib.reload(python)
# A list of dictionaries.
if 0:
    tests = [
        # g.Bunch(line='s = "\\""', ctx=('', '')),
        g.Bunch(line='\\\n'),
    ]
else:
    tests = [
        g.Bunch(line='\n'),
        g.Bunch(line='\\\n'),
        g.Bunch(line='s = "\\""', ctx=('', '')), # empty string.
        g.Bunch(line="s = '\\''", ctx=('', '')), # empty string.
        g.Bunch(line='# comment'),
        g.Bunch(line='  # comment'),
        g.Bunch(line='    # comment'),
        g.Bunch(line='a = "string"'),
        g.Bunch(line='a = "Continued string', ctx=('', '"')),
        g.Bunch(line='end of continued string"', ctx=('"', '')),
        g.Bunch(line='a = """Continued docstring', ctx=('', '"""')),
        g.Bunch(line='a = """#', ctx=('', '"""')),
        g.Bunch(line='end of continued string"""', ctx=('"""', '')),
        g.Bunch(line="a = '''Continued docstring", ctx=('', "'''")),
        g.Bunch(line="end of continued string'''", ctx=("'''", '')),
        g.Bunch(line='a = {[(')
    ]
if hasattr(python, 'Py_Importer'):
    importer = python.Py_Importer(c.importCommands)
    importer.test_scan_state(tests, State=python.Python_ScanState)
else:
    self.skipTest('Skipping test for new python importer')
</t>
<t tx="ekr.20161117000902.1">if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = """\
# -*- coding: utf-8 -*-
import leo.core.leoGlobals as g
class LeoImportCommands(object):
    '''A class implementing all of Leo's import/export code.'''
    def createOutline(self, fileName, parent, s=None, ext=None):
        '''Create an outline by importing a file or string.'''

    def dispatch(self, ext, p):
        '''Return the correct scanner function for p, an @auto node.'''
        # Match the @auto type first, then the file extension.
        return self.scanner_for_at_auto(p) or self.scanner_for_ext(ext)
    def scanner_for_at_auto(self, p):
        '''A factory returning a scanner function for p, an @auto node.'''
        d = self.atAutoDict
        for key in d.keys():
            aClass = d.get(key)
            if aClass and g.match_word(p.h, 0, key):
                if trace: g.trace('found', aClass.__name__)

                def scanner_for_at_auto_cb(parent, s, prepass=False):
                    try:
                        scanner = aClass(importCommands=self)
                        return scanner.run(s, parent, prepass=prepass)
                    except Exception:
                        g.es_print('Exception running', aClass.__name__)
                        g.es_exception()
                        return None

                if trace: g.trace('found', p.h)
                return scanner_for_at_auto_cb
        if trace: g.trace('not found', p.h, sorted(d.keys()))
        return None
    def scanner_for_ext(self, ext):
        '''A factory returning a scanner function for the given file extension.'''
        aClass = self.classDispatchDict.get(ext)
        if aClass:

            def scanner_for_ext_cb(parent, s, prepass=False):
                try:
                    scanner = aClass(importCommands=self)
                    return scanner.run(s, parent, prepass=prepass)
                except Exception:
                    g.es_print('Exception running', aClass.__name__)
                    g.es_exception()
                    return None

            return scanner_for_ext_cb
        else:
            return None
    def get_import_filename(self, fileName, parent):
        '''Return the absolute path of the file and set .default_directory.'''

    def init_import(self, ext, fileName, s):
        '''Init ivars &amp; vars for imports.'''
"""
table = (
    (1, 'Declarations'),
    (1, "class LeoImportCommands(object)"),
    (2, "createOutline"),
    (2, "dispatch"),
    (2, "scanner_for_at_auto"),
    (2, "scanner_for_ext"),
    (2, "get_import_filename"),
    (2, "init_import"),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161119032623.1">if 0:
    # The preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.perl
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.perl)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
#!/usr/bin/perl

sub test1 {
    s = /}/g;
}

sub test2 {
    s = m//}/;
}

sub test3 {
    s = s///}/;
}

sub test4 {
    s = tr///}/;
}
'''
table = (
    'sub test1',
    'sub test2',
    'sub test3',
    'sub test4'
)
try:
    ic.perlUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161123080832.1">'''
Create a table of expected headlines in a unit test.

Usage: select the desired subnode of an @test node.
'''
g.cls()
# Proper escapes are tricky.
if p.parent() and p.parent().h.startswith('@test'):
    table = [
        '(%s, "%s"),' % (
            p.level()-c.p.level(),
            p.h.replace('\\', '\\\\').replace('"', '\\"'),
        )
            for p in p.subtree()
    ]
    print("table = (\n    %s\n)" % '\n    '.join(table))
else:
    print('select a child of an @test node node')</t>
<t tx="ekr.20161125134815.1">if 0:
    # The preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.markdown)
    # importlib.reload(leo.plugins.writers.markdown)
    importlib.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.
#Header

After header text

##Subheader

Not an underline

----------------

After subheader text

#Last header: no text
'''
table = (
    '!Declarations',
    'Header',
        'Subheader',
        'Last header: no text',
)
try:
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@auto-m'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161125230415.1">s = '''\
Top
====

The top section

Section 1
---------

section 1, line 1
-- Not an underline
secttion 1, line 2

Section 2
---------

section 2, line 1

###Section 2.1

section 2.1, line 1

####Section 2.1.1

section 2.2.1 line 1

###Section 2.2
section 2.2, line 1.

Section 3
---------

section 3, line 1

'''
</t>
<t tx="ekr.20161126111517.1">if 0:
    # The preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.markdown)
    # importlib.reload(leo.plugins.writers.markdown)
    importlib.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.
#Header

After header text

##Subheader

Not an underline

----------------

This *should* be a section
==========================

After subheader text

#Last header: no text
'''
table = (
    '!Declarations',
    'Header',
        'Subheader',
            'This *should* be a section',
        'Last header: no text',
)
try:
    g.app.suppressImportChecks = True
        # Required, because the implicit underlining *must*
        # cause the perfect-import test to fail!
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@auto-m'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    g.app.suppressImportChecks = False
        # Not needed: done in Importer.check
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161127181028.1">@first # -*- coding: utf-8 -*-
    # Required (Python 2 only) because test contains ```.
if 0:
    # The preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.markdown)
    # importlib.reload(leo.plugins.writers.markdown)
    importlib.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.
#Header

```python
loads.init = {
    Chloride: 11.5,
    TotalP: 0.002,
}
```
#Last header
'''
table = (
    '!Declarations',
    'Header',
    'Last header',
)
try:
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161129030232.1"></t>
<t tx="ekr.20161129104243.1">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

if 0:
    # The preamble...
    if c.isChanged(): c.save()
    import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst as leo_rst
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.leo_rst)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

# Notes:
# All heading must be followed by an empty line.
s = '''\
  #########
Chapter 1
  #########

It was a dark and stormy night.
section 1
+++++++++

Sec 1.
section 2
+++++++++

Sec 2.
'''
table = (
    '!Dummy chapter',
    'section 1',
    'section 2',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161202093319.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093319.2">
The top section

</t>
<t tx="ekr.20161202093319.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093319.4">
section 2, line 1

</t>
<t tx="ekr.20161202093319.5">
section 2.1, line 1

</t>
<t tx="ekr.20161202093319.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093319.7">section 2.2, line 1.

</t>
<t tx="ekr.20161202093319.8">
section 3, line 1

</t>
<t tx="ekr.20161202093322.10">
The top section

</t>
<t tx="ekr.20161202093322.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093322.12">
section 2, line 1

</t>
<t tx="ekr.20161202093322.13">
section 2.1, line 1

</t>
<t tx="ekr.20161202093322.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093322.15">section 2.2, line 1.

</t>
<t tx="ekr.20161202093322.16">
section 3, line 1

</t>
<t tx="ekr.20161202093322.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093409.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093409.2">
The top section

</t>
<t tx="ekr.20161202093409.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093409.4">
section 2, line 1

</t>
<t tx="ekr.20161202093409.5">
section 2.1, line 1

</t>
<t tx="ekr.20161202093409.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093409.7">section 2.2, line 1.

</t>
<t tx="ekr.20161202093409.8">
section 3, line 1

</t>
<t tx="ekr.20161202093410.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093410.2">
The top section

</t>
<t tx="ekr.20161202093410.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093410.4">
section 2, line 1

</t>
<t tx="ekr.20161202093410.5">
section 2.1, line 1

</t>
<t tx="ekr.20161202093410.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093410.7">section 2.2, line 1.

</t>
<t tx="ekr.20161202093410.8">
section 3, line 1

</t>
<t tx="ekr.20161202093509.22">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093509.23">
The top section

</t>
<t tx="ekr.20161202093509.24">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161202093509.25">
section 2, line 1

</t>
<t tx="ekr.20161202093509.26">
section 2.1, line 1

</t>
<t tx="ekr.20161202093509.27">
section 2.2.1 line 1

</t>
<t tx="ekr.20161202093509.28">section 2.2, line 1.

</t>
<t tx="ekr.20161202093509.29">
section 3, line 1

</t>
<t tx="ekr.20161202093709.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161202093709.2">#Top
The top section

</t>
<t tx="ekr.20161202093709.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161202093709.4">section 2, line 1

</t>
<t tx="ekr.20161202093709.5">section 2.1, line 1

</t>
<t tx="ekr.20161202093709.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161202093709.7">
</t>
<t tx="ekr.20161202093709.8">Section 3, line 1

</t>
<t tx="ekr.20161204034142.19">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204034142.20">The top section

</t>
<t tx="ekr.20161204034142.21">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204034142.22">section 2, line 1

</t>
<t tx="ekr.20161204034142.23">section 2.1, line 1

</t>
<t tx="ekr.20161204034142.24">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204034142.25">
</t>
<t tx="ekr.20161204034142.26">Section 3, line 1

</t>
<t tx="ekr.20161204034142.27">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204034142.28">
The top section

</t>
<t tx="ekr.20161204034142.29">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204034142.30">
section 2, line 1

</t>
<t tx="ekr.20161204034142.31">
section 2.1, line 1

</t>
<t tx="ekr.20161204034142.32">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204034142.33">section 2.2, line 1.

</t>
<t tx="ekr.20161204034142.34">
section 3, line 1

</t>
<t tx="ekr.20161204034207.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204034207.10">
The top section

</t>
<t tx="ekr.20161204034207.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204034207.12">
section 2, line 1

</t>
<t tx="ekr.20161204034207.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204034207.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204034207.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204034207.16">
section 3, line 1

</t>
<t tx="ekr.20161204034207.2">The top section

</t>
<t tx="ekr.20161204034207.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204034207.4">section 2, line 1

</t>
<t tx="ekr.20161204034207.5">section 2.1, line 1

</t>
<t tx="ekr.20161204034207.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204034207.7">
</t>
<t tx="ekr.20161204034207.8">Section 3, line 1

</t>
<t tx="ekr.20161204034207.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204035451.19">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204035451.20">The top section

</t>
<t tx="ekr.20161204035451.21">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204035451.22">section 2, line 1

</t>
<t tx="ekr.20161204035451.23">section 2.1, line 1

</t>
<t tx="ekr.20161204035451.24">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204035451.25">
</t>
<t tx="ekr.20161204035451.26">Section 3, line 1

</t>
<t tx="ekr.20161204035451.27">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204035451.28">
The top section

</t>
<t tx="ekr.20161204035451.29">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204035451.30">
section 2, line 1

</t>
<t tx="ekr.20161204035451.31">
section 2.1, line 1

</t>
<t tx="ekr.20161204035451.32">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204035451.33">section 2.2, line 1.

</t>
<t tx="ekr.20161204035451.34">
section 3, line 1

</t>
<t tx="ekr.20161204041310.53">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041310.54">The top section

</t>
<t tx="ekr.20161204041310.55">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041310.56">section 2, line 1

</t>
<t tx="ekr.20161204041310.57">section 2.1, line 1

</t>
<t tx="ekr.20161204041310.58">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041310.59">
</t>
<t tx="ekr.20161204041310.60">Section 3, line 1

</t>
<t tx="ekr.20161204041310.61">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041310.62">
The top section

</t>
<t tx="ekr.20161204041310.63">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041310.64">
section 2, line 1

</t>
<t tx="ekr.20161204041310.65">
section 2.1, line 1

</t>
<t tx="ekr.20161204041310.66">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041310.67">section 2.2, line 1.

</t>
<t tx="ekr.20161204041310.68">
section 3, line 1

</t>
<t tx="ekr.20161204041358.103">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041358.104">The top section

</t>
<t tx="ekr.20161204041358.105">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041358.106">section 2, line 1

</t>
<t tx="ekr.20161204041358.107">section 2.1, line 1

</t>
<t tx="ekr.20161204041358.108">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041358.109">
</t>
<t tx="ekr.20161204041358.110">Section 3, line 1

</t>
<t tx="ekr.20161204041359.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041359.2">
The top section

</t>
<t tx="ekr.20161204041359.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041359.4">
section 2, line 1

</t>
<t tx="ekr.20161204041359.5">
section 2.1, line 1

</t>
<t tx="ekr.20161204041359.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041359.7">section 2.2, line 1.

</t>
<t tx="ekr.20161204041359.8">
section 3, line 1

</t>
<t tx="ekr.20161204041418.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041418.10">
The top section

</t>
<t tx="ekr.20161204041418.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041418.12">
section 2, line 1

</t>
<t tx="ekr.20161204041418.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204041418.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041418.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204041418.16">
section 3, line 1

</t>
<t tx="ekr.20161204041418.2">The top section

</t>
<t tx="ekr.20161204041418.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041418.4">section 2, line 1

</t>
<t tx="ekr.20161204041418.5">section 2.1, line 1

</t>
<t tx="ekr.20161204041418.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041418.7">
</t>
<t tx="ekr.20161204041418.8">Section 3, line 1

</t>
<t tx="ekr.20161204041418.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041645.103">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041645.104">The top section

</t>
<t tx="ekr.20161204041645.105">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041645.106">section 2, line 1

</t>
<t tx="ekr.20161204041645.107">section 2.1, line 1

</t>
<t tx="ekr.20161204041645.108">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041645.109">
</t>
<t tx="ekr.20161204041645.110">Section 3, line 1

</t>
<t tx="ekr.20161204041646.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041646.2">
The top section

</t>
<t tx="ekr.20161204041646.3">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041646.4">
section 2, line 1

</t>
<t tx="ekr.20161204041646.5">
section 2.1, line 1

</t>
<t tx="ekr.20161204041646.6">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041646.7">section 2.2, line 1.

</t>
<t tx="ekr.20161204041646.8">
section 3, line 1

</t>
<t tx="ekr.20161204041724.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041724.10">
The top section

</t>
<t tx="ekr.20161204041724.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041724.12">
section 2, line 1

</t>
<t tx="ekr.20161204041724.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204041724.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041724.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204041724.16">
section 3, line 1

</t>
<t tx="ekr.20161204041724.2">The top section

</t>
<t tx="ekr.20161204041724.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041724.4">section 2, line 1

</t>
<t tx="ekr.20161204041724.5">section 2.1, line 1

</t>
<t tx="ekr.20161204041724.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041724.7">
</t>
<t tx="ekr.20161204041724.8">Section 3, line 1

</t>
<t tx="ekr.20161204041724.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041800.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204041800.10">
The top section

</t>
<t tx="ekr.20161204041800.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204041800.12">
section 2, line 1

</t>
<t tx="ekr.20161204041800.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204041800.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204041800.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204041800.16">
section 3, line 1

</t>
<t tx="ekr.20161204041800.2">The top section

</t>
<t tx="ekr.20161204041800.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204041800.4">section 2, line 1

</t>
<t tx="ekr.20161204041800.5">section 2.1, line 1

</t>
<t tx="ekr.20161204041800.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204041800.7">
</t>
<t tx="ekr.20161204041800.8">Section 3, line 1

</t>
<t tx="ekr.20161204041800.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042305.100">section 2.1, line 1

</t>
<t tx="ekr.20161204042305.101">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204042305.102">
</t>
<t tx="ekr.20161204042305.103">Section 3, line 1

</t>
<t tx="ekr.20161204042305.104">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042305.105">
The top section

</t>
<t tx="ekr.20161204042305.106">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204042305.107">
section 2, line 1

</t>
<t tx="ekr.20161204042305.108">
section 2.1, line 1

</t>
<t tx="ekr.20161204042305.109">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204042305.110">section 2.2, line 1.

</t>
<t tx="ekr.20161204042305.111">
section 3, line 1

</t>
<t tx="ekr.20161204042305.96">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042305.97">The top section

</t>
<t tx="ekr.20161204042305.98">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204042305.99">section 2, line 1

</t>
<t tx="ekr.20161204042719.10">
</t>
<t tx="ekr.20161204042719.11">Section 3, line 1

</t>
<t tx="ekr.20161204042719.12">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042719.13">
The top section

</t>
<t tx="ekr.20161204042719.14">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204042719.15">
section 2, line 1

</t>
<t tx="ekr.20161204042719.16">
section 2.1, line 1

</t>
<t tx="ekr.20161204042719.17">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204042719.18">section 2.2, line 1.

</t>
<t tx="ekr.20161204042719.19">
section 3, line 1

</t>
<t tx="ekr.20161204042719.4">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042719.5">The top section

</t>
<t tx="ekr.20161204042719.6">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204042719.7">section 2, line 1

</t>
<t tx="ekr.20161204042719.8">section 2.1, line 1

</t>
<t tx="ekr.20161204042719.9">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204042822.1">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204042822.10">
The top section

</t>
<t tx="ekr.20161204042822.11">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204042822.12">
section 2, line 1

</t>
<t tx="ekr.20161204042822.13">
section 2.1, line 1

</t>
<t tx="ekr.20161204042822.14">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204042822.15">section 2.2, line 1.

</t>
<t tx="ekr.20161204042822.16">
section 3, line 1

</t>
<t tx="ekr.20161204042822.2">The top section

</t>
<t tx="ekr.20161204042822.3">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204042822.4">section 2, line 1

</t>
<t tx="ekr.20161204042822.5">section 2.1, line 1

</t>
<t tx="ekr.20161204042822.6">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204042822.7">
</t>
<t tx="ekr.20161204042822.8">Section 3, line 1

</t>
<t tx="ekr.20161204042822.9">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043017.19">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043017.20">The top section

</t>
<t tx="ekr.20161204043017.21">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204043017.22">section 2, line 1

</t>
<t tx="ekr.20161204043017.23">section 2.1, line 1

</t>
<t tx="ekr.20161204043017.24">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204043017.25">
</t>
<t tx="ekr.20161204043017.26">Section 3, line 1

</t>
<t tx="ekr.20161204043017.27">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043017.28">
The top section

</t>
<t tx="ekr.20161204043017.29">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204043017.30">
section 2, line 1

</t>
<t tx="ekr.20161204043017.31">
section 2.1, line 1

</t>
<t tx="ekr.20161204043017.32">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204043017.33">section 2.2, line 1.

</t>
<t tx="ekr.20161204043017.34">
section 3, line 1

</t>
<t tx="ekr.20161204043032.100">section 2.1, line 1

</t>
<t tx="ekr.20161204043032.101">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161204043032.102">
</t>
<t tx="ekr.20161204043032.103">Section 3, line 1

</t>
<t tx="ekr.20161204043032.104">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043032.105">
The top section

</t>
<t tx="ekr.20161204043032.106">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204043032.107">
section 2, line 1

</t>
<t tx="ekr.20161204043032.108">
section 2.1, line 1

</t>
<t tx="ekr.20161204043032.109">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204043032.110">section 2.2, line 1.

</t>
<t tx="ekr.20161204043032.111">
section 3, line 1

</t>
<t tx="ekr.20161204043032.96">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043032.97">The top section

</t>
<t tx="ekr.20161204043032.98">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204043032.99">section 2, line 1

</t>
<t tx="ekr.20161204043346.10">
</t>
<t tx="ekr.20161204043346.11">Section 3, line 1

</t>
<t tx="ekr.20161204043346.12">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043346.13">
The top section

</t>
<t tx="ekr.20161204043346.14">
section 1, line 1
-- Not an underline
secttion 1, line 2

</t>
<t tx="ekr.20161204043346.15">
section 2, line 1

</t>
<t tx="ekr.20161204043346.16">
section 2.1, line 1

</t>
<t tx="ekr.20161204043346.17">
section 2.2.1 line 1

</t>
<t tx="ekr.20161204043346.18">section 2.2, line 1.

</t>
<t tx="ekr.20161204043346.19">
section 3, line 1

</t>
<t tx="ekr.20161204043346.4">@others

Warning: this node is ignored when writing this file.

@language md
@tabwidth -4
</t>
<t tx="ekr.20161204043346.5">The top section

</t>
<t tx="ekr.20161204043346.6">section 1, line 1
section 1, line 2

</t>
<t tx="ekr.20161204043346.7">section 2, line 1

</t>
<t tx="ekr.20161204043346.8">section 2.1, line 1

</t>
<t tx="ekr.20161204043346.9">section 2.2.1 line 1
The next section is empty. It must not be deleted.

</t>
<t tx="ekr.20161216141315.1">if 0:
    # The preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.markdown
    # import leo.plugins.writers.markdown
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.markdown)
    # importlib.reload(leo.plugins.writers.markdown)
    importlib.reload(leoImport)
    markdown = leo.plugins.importers.markdown
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
# insert test for markdown here.
s = '''\
Decl line.

#@@ Header

After header text

##@@Subheader

Not an underline

----------------

This *should* be a section
==========================

After subheader text

#Last header: no text
'''
table = (
    '!Declarations',
    '@verbatim', # This is an artifact of the unit test.
    '@@ Header',
        '@@Subheader',
            'This *should* be a section',
        'Last header: no text',
)
try:
    g.app.suppressImportChecks = True
        # Required, because the implicit underlining *must*
        # cause the perfect-import test to fail!
    ic.markdownUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@auto-m'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    g.app.suppressImportChecks = False
        # Not needed: done in Importer.check
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20161218103650.1">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  
s = '''\
import sys

if sys.version_info[0] &gt;= 3:
    exec_ = eval('exec')
else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")

def make_parser():

    parser = argparse.ArgumentParser(
        description="""Raster calcs. with GDAL.
        The first --grid defines the projection, extent, cell size, and origin
        for all calculations, all other grids are transformed and resampled
        as needed to match.""",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
)
'''
table = (
    (1, 'Declarations'),
    (1, 'make_parser'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161222064421.1"># From xo.py.
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands  

s = r'''#!/usr/bin/env python3

import os
import re

def merge_value(v1, v2):
    return v

class MainDisplay(object):

    def save_file(self):
        """Write the file out to disk."""
        with open(self.save_name, "w") as f:
            for newline in newlines:
                f.write(newline)

# This line should be included at the end of the class node.
ensure_endswith_newline = lambda x: x if x.endswith('\n') else x + '\n'

def retab(s, tabsize):
    return ''.join(pieces)

if __name__=="__main__":
    main()
'''
table = (
    (1, 'Declarations'),
    (1, 'merge_value'),
    (1, 'class MainDisplay(object)'),
    (2, 'save_file'),
    (1, 'retab'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 0:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161224101046.1">@tabwidth -4
    # Required when running unit tests externally.
if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''
"""
A PyQt "task launcher" for quick access to python scripts.

Buttons to click to make working in Windows less unproductive.

e.g. a button to move the current window to top or bottom half
of screen, because Windows-Up / Windows-Down doesn't do that.
Or quote the text on the clipboard properly, because Outlook
can't do that.

terrynbrown@gmail.com, 2016-12-23
"""

import sys
import time
from PyQt4 import QtGui, QtCore, Qt
from PyQt4.QtCore import Qt as QtConst

COMMANDS = []

class Draggable(QtGui.QWidget):
    def __init__(self, *args, **kwargs):
        """__init__
        """

        QtGui.QWidget.__init__(self, *args, **kwargs)
        # self.setMouseTracking(True)
        self.offset = None
        layout = QtGui.QHBoxLayout()
        self.setLayout(layout)
        layout.addItem(QtGui.QSpacerItem(15, 5))
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 0)

    def mousePressEvent(self, event):
        self.offset = event.pos()

    def mouseMoveEvent(self, event):
        x=event.globalX()
        y=event.globalY()
        x_w = self.offset.x()
        y_w = self.offset.y()
        self.parent().move(x-x_w, y-y_w)

def command(name):
    def makebutton(function):
        COMMANDS.append((name, function))
        return function
    return makebutton

@command("Exit")
def exit_():
    exit()

def main():

    app = Qt.QApplication(sys.argv)

    main = QtGui.QMainWindow(None,
       # QtConst.CustomizeWindowHint  |
       QtConst.FramelessWindowHint #  |
       # QtConst.WindowCloseButtonHint
    )

    main.resize(800,16)
    main.move(40,40)
    mainwidj = Draggable()

    for name, function in COMMANDS:
        button = QtGui.QPushButton(name)
        button.clicked.connect(function)
        mainwidj.layout().addWidget(button)

    main.setCentralWidget(mainwidj)
    main.show()
    app.exec_()

if __name__ == '__main__':
    main()
'''
table = (
    (1, "Declarations"),
    (1, "class Draggable(QtGui.QWidget)"),
    (2, "__init__"),
    (2, "mousePressEvent"),
    (2, "mouseMoveEvent"),
    (1, "command"),
    (1, '@command("Exit") exit_'),
    (1, "main"),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    c.importCommands.pythonUnitTest(p,s=s,showTree=True) # Must be true.
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    target = g.findNodeInTree(c, root, '@command("Exit") exit_')
    assert target
    lines = g.splitLines(target.b)
    assert lines[0] == '@command("Exit")\n', repr(lines[0])
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161224145026.1">if 0: # Preamble...
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
    
s = '''
def isValidPython(self):
    if sys.platform == 'cli':
        return True
    minimum_python_version = '2.6'
    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0, 1, 2)])
        ok = g.CheckVersion(version, minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                class EmergencyDialog(object):
                    def run(self):
                        """Run the modal emergency dialog."""
                        self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
                        self.top.lift()
                        self.top.grab_set() # Make the dialog a modal dialog.
                        self.root.wait_window(self.top)
                d = EmergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
def loadLocalFile(self, fn, gui, old_c):
    trace = (False or g.trace_startup) and not g.unitTesting
'''
table = (
    (1, 'isValidPython'),
    # (2, 'class EmergencyDialog'),
    # (3, 'run'),
    (1, 'loadLocalFile'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20161228070933.1">if 0: # Preamble...
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands 
s = """
if isPython3:
    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        return s

    def ue(s, encoding):
        return s if g.isUnicode(s) else str(s, encoding)
else:
    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        return builtins.unicode(s) # Suppress pyflakes complaint.

    def ue(s, encoding):
        return builtins.unicode(s, encoding)
"""
table = (
    (1, 'Declarations'),
    # (1, 'u'),
    # (1, 'ue'),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20170122033034.1">if 0: # Preamble...
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.python)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands 
s = '''
"""
sheet_stats.py - report column stats for spreadsheets

requires openpyxl and numpy

Terry N. Brown, terrynbrown@gmail.com, Fri Dec 16 13:20:47 2016
2016-12-26 Henry Helgen added average, variance, standard deviation,
                        coefficient of variation to output
2016-12-23 Henry Helgen updated to Python 3.5 syntax including print() and
                        writer = csv.writer(open(opt.output, 'w', newline=''))
"""

import csv
import argparse
import glob
import multiprocessing
import os
import sys
from collections import namedtuple
from math import sqrt, isnan
NAN = float('NAN')

from openpyxl import load_workbook

PYTHON_2 = sys.version_info[0] &lt; 3
if not PYTHON_2:
    unicode = str

class AttrDict(dict):
    """allow d.attr instead of d['attr']
    http://stackoverflow.com/a/14620633
    """
    def __init__(self, *args, **kwargs):
        super(AttrDict, self).__init__(*args, **kwargs)
        self.__dict__ = self

FIELDS = [  # fields in outout table
    'file', 'field', 'n', 'blank', 'bad', 'min', 'max', 'mean', 'std',
    'sum', 'sumsq', 'variance', 'coefvar'
]
def make_parser():
    """build an argparse.ArgumentParser, don't call this directly,
       call get_options() instead.
    """
    parser = argparse.ArgumentParser(
        description="""Report column stats for spreadsheets""",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument('files', type=str, nargs='+',
        help="Files to process, '*' patterns expanded."
    )

    required_named = parser.add_argument_group('required named arguments')

    required_named.add_argument("--output",
        help="Path to .csv file for output, will be overwritten",
        metavar='FILE'
    )

    return parser

def get_options(args=None):
    """
    get_options - use argparse to parse args, and return a
    argparse.Namespace, possibly with some changes / expansions /
    validatations.

    Client code should call this method with args as per sys.argv[1:],
    rather than calling make_parser() directly.

    :param [str] args: arguments to parse
    :return: options with modifications / validations
    :rtype: argparse.Namespace
    """
    opt = make_parser().parse_args(args)

    # modifications / validations go here

    if not opt.output:
        print("No --output supplied")
        exit(10)

    return opt

def get_aggregate(psumsqn, psumn, pcountn):
    """
    get_aggregate - compute mean, variance, standard deviation,
    coefficient of variation This function is used instead of
    numpy.mean, numpy.var, numpy.std since the sum, sumsq, and count are
    available when the function is called. It avoids an extra pass
    through the list.

    # note pcountn means the full list n,  not a sample n - 1

    :param sum of squares, sum, count
    :return: a tuple of floats mean, variance, standard deviation, coefficient of variation
    """

    Agg = namedtuple("Agg", "mean variance std coefvar")

    # validate inputs check for count == 0
    if pcountn == 0:
        result = Agg(NAN, NAN, NAN, NAN)
    else:

        mean = psumn / pcountn # mean

        # compute variance from sum squared without knowing mean while summing
        variance = (psumsqn - (psumn * psumn) / pcountn ) / pcountn

        #compute standard deviation
        if variance &lt; 0:
            std = NAN
        else:
            std = sqrt(variance)

        # compute coefficient of variation
        if mean == 0:
            coefvar = NAN
        else:
            coefvar = std / mean

        result = Agg(mean, variance, std, coefvar)

    return result


def proc_file(filepath):
    """
    proc_file - process one .xlsx file

    :param str filepath: path to file
    :return: list of lists, rows of info. as expected in main()
    """

    print(filepath)

    # get the first sheet
    book = load_workbook(filename=filepath, read_only=True)
    sheets = book.get_sheet_names()
    sheet = book[sheets[0]]
    row_source = sheet.rows
    row0 = next(row_source)
    # get field names from the first row
    fields = [i.value for i in row0]

    data = {
        'filepath': filepath,
        'fields': {field:AttrDict({f:0 for f in FIELDS}) for field in fields}
    }

    for field in fields:
        # init. mins/maxs with invalid value for later calc.
        data['fields'][field].update(dict(
            min=NAN,
            max=NAN,
            field=field,
            file=filepath,
        ))

    rows = 0
    for row in row_source:

        if rows % 1000 == 0:  # feedback every 1000 rows
            print(rows)
            # Much cleaner to exit by creating a file called "STOP" in the
            # local directory than to try and use Ctrl-C, when using
            # multiprocessing.  Save time by checking only every 1000 rows.
            if os.path.exists("STOP"):
                return

        rows += 1

        for cell_n, cell in enumerate(row):
            d = data['fields'][fields[cell_n]]
            if cell.value is None or unicode(cell.value).strip() == '':
                d.blank += 1
            else:
                try:
                    x = float(cell.value)
                    d.sum += x
                    d.sumsq += x*x
                    d.n += 1
                    # min is x if no value seen yet, else min(prev-min, x)
                    if isnan(d.min):
                        d.min = x
                    else:
                        d.min = min(d.min, x)
                    # as for min
                    if isnan(d.max):
                        d.max = x
                    else:
                        d.max = max(d.max, x)
                except ValueError:
                    d.bad += 1

    assert sum(d.n+d.blank+d.bad for d in data['fields'].values()) == rows * len(fields)

    # compute the derived values
    for field in data['fields']:
        d = data['fields'][field]
        d.update(get_aggregate(d.sumsq, d.sum, d.n)._asdict().items())

    return data
def get_answers(opt=None, **kwargs):
    """get_answers - process files

    :param argparse.Namespace opt: options
    :return: list of answers from proc_file
    """

    if opt is None:  # API call rather than command line
        opt = type("opt", (), kwargs)

    # pass filenames through glob() to expand "2017_*.xlsx" etc.
    files = []
    for filepath in opt.files:
        files.extend(glob.glob(filepath))

    # create a pool of processors
    pool = multiprocessing.Pool(multiprocessing.cpu_count()-1)

    # process file list with processor pool
    return pool.map(proc_file, files)
def get_table_rows(answers):
    """get_table_rows - generator - convert get_answers() output to table format

    :param list answers: output from get_answers()
    :return: list of rows suitable for csv.writer
    """
    yield FIELDS
    for answer in answers:
        for field in answer['fields']:
            row = [answer['fields'][field][k] for k in FIELDS]
            if PYTHON_2:
                yield [unicode(col).encode('utf-8') for col in row]
            else:
                yield row

def main():
    """main() - when invoked directly"""
    opt = get_options()

    # csv.writer does its own EOL handling,
    # see https://docs.python.org/3/library/csv.html#csv.reader
    if PYTHON_2:
        output = open(opt.output, 'wb')
    else:
        output = open(opt.output, 'w', newline='')

    with output as out:
        writer = csv.writer(out)
        for row in get_table_rows(get_answers(opt)):
            writer.writerow(row)

if __name__ == '__main__':
    main()
'''
table = (
    (1, "Declarations"),
    (1, "class AttrDict(dict)"),
    (2, "__init__"),
    (1, "make_parser"),
    (1, "get_options"),
    (1, "get_aggregate"),
    (1, "proc_file"),
    (1, "get_answers"),
    (1, "get_table_rows"),
    (1, "main"),
)
try:
    test_node = p.copy()
    test_node.deleteAllChildren()
    ic.pythonUnitTest(p,s=s,showTree=True)
    after = p.nodeAfterTree()
    root = p.lastChild()
    assert root.h.startswith('@@'), root.h
    p = root.firstChild()
    if 1:
        for n, h in table:
            n2 = p.level() - root.level()
            assert h == p.h, (h, p.h)
            assert n == n2, (n, n2, p.h)
            p.moveToThreadNext()
        assert p == after, ('tree comp failed', p.h)
    if 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20170407065952.1">import importlib
import leo.plugins.importers.javascript as js
importlib.reload(js)
importer = js.JS_Importer(c.importCommands)
pattern = importer.op_pattern
table = (
    '++', '--', '&amp;&amp;', '||', '~', '&gt;&gt;', '&lt;&lt;', 
    # '&gt;&gt;=',  '&lt;&lt;=',
    # '&gt;&gt;&gt;', '&gt;&gt;&gt;=',
    # '&lt;&lt;&lt;', '&lt;&lt;&lt;=',
    '&lt;', '&lt;=', '&gt;', '&gt;=',
    '+', '+=', '-', '-=',
    '/', '/=', '*', '*=', 
    '%', '%=', '&amp;', '&amp;=',
    '|', '|=',
)
for s in table:
    m = pattern.match(s)
    assert m, s
    assert m.group(0) == s, (s, m.group(0))
</t>
<t tx="ekr.20170408233251.1">import re
import leo.core.leoAtFile as atFile
if 0: # prefix
    import importlib
    importlib.reload(atFile)
at = atFile.AtFile(c)
s = '''\
if (
    %s and 
    %s &gt; 3
):
    pass
''' % (g.angleBrackets('a'), g.angleBrackets('b'))
# Careful: avoid @verbatim and other substitutions.
expected = '''\
AT+leo-ver=5-thin
AT+node:GNX: * @test at.putRefLine 1
if (
    AT+&lt; &lt;a&gt; &gt;
    AT+node:GNX: ** &lt; &lt; a &gt; &gt;
    a
    AT-&lt; &lt;a&gt; &gt;
    ATafterref
 and 
    AT+&lt; &lt;b&gt; &gt;
    AT+node:GNX: ** &lt; &lt; b &gt; &gt;
    b
    AT-&lt; &lt;b&gt; &gt;
    ATafterref
 &gt; 3
):
    pass
AT-leo
'''.replace('AT','#@').replace('&gt; &gt;', '&gt;&gt;').replace('&lt; &lt;', '&lt;&lt;')

result = at.stringToString(c.p, s)
result = re.sub(r'#@\+node:(.+):', '#@+node:GNX:', result)
    # Don't test actual gnx's, so we can copy/paste this test.
if 0: # Show unexpected mismatches.
    result = g.splitLines(result)
    expected = g.splitLines(expected)
    assert len(expected) == len(result)
    for i, s in enumerate(result):
        if expected[i] != result[i]:
            print(i)
            print('expected: %r' % expected[i])
            print('result:   %r' % result[i])
            break
assert result == expected
</t>
<t tx="ekr.20170408234524.1">a
</t>
<t tx="ekr.20170408234531.1">b
</t>
<t tx="ekr.20170409003052.1">import re
import leo.core.leoAtFile as atFile
if 0: # prefix
    import importlib
    importlib.reload(atFile)
at = atFile.AtFile(c)
s = '''\
if (%s and %s &gt; 3):
    pass
''' % (g.angleBrackets('a'), g.angleBrackets('b'))
# Careful: avoid @verbatim and other substitutions.
expected = '''\
AT+leo-ver=5-thin
AT+node:GNX: * @test at.putRefLine 2
if (
AT+&lt; &lt;a&gt; &gt;
AT+node:GNX: ** &lt; &lt; a &gt; &gt;
a
AT-&lt; &lt;a&gt; &gt;
ATafterref
 and 
AT+&lt; &lt;b&gt; &gt;
AT+node:GNX: ** &lt; &lt; b &gt; &gt;
b
AT-&lt; &lt;b&gt; &gt;
ATafterref
 &gt; 3):
    pass
AT-leo
'''.replace('AT','#@').replace('&gt; &gt;', '&gt;&gt;').replace('&lt; &lt;', '&lt;&lt;')
    # Recreate expected string.
result = at.stringToString(c.p, s)
result = re.sub(r'#@\+node:(.+):', '#@+node:GNX:', result)
    # Don't test actual gnx's, so we can copy/paste this test.
if 0: # Show unexpected mismatches.
    result = g.splitLines(result)
    expected = g.splitLines(expected)
    # assert len(expected) == len(result)
    for i, s in enumerate(result):
        if expected[i] != result[i]:
            print(i)
            print('expected: %r' % expected[i])
            print('result:   %r' % result[i])
            break
assert result == expected
</t>
<t tx="ekr.20170409003052.2">a
</t>
<t tx="ekr.20170409003052.3">b
</t>
<t tx="ekr.20170415084531.1"># lowercase xml tags, one per line.

html
body
head
div
table
nodeA
nodeB
</t>
<t tx="ekr.20171126152936.1"># Required for unit tests: See #577.</t>
<t tx="ekr.20171126153044.1"># Required for unit tests: See #577.</t>
<t tx="ekr.20171126153138.1">See #577: https://github.com/leo-editor/leo-editor/issues/577
</t>
<t tx="ekr.20180214042153.1">False is the legacy value.</t>
<t tx="ekr.20181009102459.1"># A big hack for the travis-ci tests.
# Init the importer class.
if g.in_bridge:
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.c
    import importlib
    importlib.reload(leo.plugins.importers.linescanner)
    importlib.reload(leo.plugins.importers.c)
    importlib.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
</t>
<t tx="ekr.20181020062334.1">import leo.plugins.importers.otl as otl
if 0: # Preamble
    if c.isChanged(): c.save()
    import importlib
    importlib.reload(otl)
x = otl.Otl_Importer(c.importCommands, atAuto=False)    
pattern = x.otl_pattern
table = (
    'body line',
    '\tline 1',
    '  \tlevel 2',
)
for line in table:
    m = pattern.match(line)
    # print('%20r ==&gt; (%r)(%r)' % (
        # line, m and m.group(1), m and m.group(2)))
    assert m
</t>
<t tx="ekr.20181020062526.1">import leo.plugins.importers.org as org
if 0: # Preamble
    if c.isChanged(): c.save()
    import importlib
    importlib.reload(org)
x = org.Org_Importer(c.importCommands, atAuto=False)    
pattern = x.org_pattern
table = (
    # 'body * line',
    '* line 1',
    '** level 2',
)
for line in table:
    m = pattern.match(line)
    # print('%20s ==&gt; (%r)(%r)' % (line, m and m.group(1), m and m.group(2)))
    assert m, repr(line)
</t>
<t tx="ekr.20181020062632.1">if 0:
    # The preamble...
    import leo.plugins.importers.linescanner as linescanner
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.org as org
    # Reload all.
    import importlib
    importlib.reload(linescanner)
    importlib.reload(org)
    importlib.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands 
# insert test for org here.
s = '''\
* Section 1
Sec 1.
* Section 2
Sec 2.
** Section 2-1
Sec 2.1
*** Section 2-1-1
Sec 2.1.1
* Section 3
****** Section 3-1-1-1-1-1
: Sec 3-1-1-1-1-1
** Section 3.1
Sec 3.1
'''
table = (
    'Section 1',
    'Section 2', 'Section 2-1', 'Section 2-1-1',
    'Section 3',
    'placeholder', 'placeholder', 'placeholder', 'placeholder',
    'Section 3-1-1-1-1-1',
    'Section 3.1',
)
try:
    g.app.suppressImportChecks = True
    ic.orgUnitTest(p,s=s,showTree=True)
    root = c.p.firstChild()
    p2 = root.firstChild()
    for h in table:
        assert p2.h == h, (p2.h, h)
        p2.moveToThreadNext()
    assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()

</t>
<t tx="ekr.20181020063007.2">import importlib
import leo.plugins.importers.coffeescript as cs
importlib.reload(cs)
&lt;&lt; define table &gt;&gt;
x = cs.CS_Importer(c.importCommands, atAuto=True)
assert x.single_comment == '#', x.single_comment
for new_state, line in table:
    print('%5s %r' % (new_state, line))
if 0:
    for line in lines_table:
        lines = [line]
        n = importer.get_leading_indent(lines, 0)
        # print('%s %r' % (n, line))
</t>
<t tx="ekr.20181020063007.3">table = [
    # State after line, line

]
</t>
<t tx="ekr.20181020063007.4">import leo.plugins.importers.linescanner as linescanner
import leo.plugins.importers.python as py
if 0: # Preamble.
    if c.isChanged(): c.save()
    import importlib
    importlib.reload(linescanner)
    importlib.reload(py)
State = py.Python_ScanState
&lt;&lt; define python tests &gt;&gt;
if 1:
    importer = py.Py_Importer(c.importCommands, atAuto=True)
    importer.test_scan_state(tests, State)
</t>
<t tx="ekr.20181020063007.5"># A list of dictionaries.
if 0:
    tests = [
        g.Bunch(line='s = "\\""', ctx=('', '')),
    ]
else:
    tests = [
        g.Bunch(line='\n'),
        g.Bunch(line='\\\n'),
        g.Bunch(line='s = "\\""', ctx=('', '')),
        g.Bunch(line="s = '\\''", ctx=('', '')),
        g.Bunch(line='# comment'),
        g.Bunch(line='  # comment'),
        g.Bunch(line='    # comment'),
        g.Bunch(line='a = "string"'),
        g.Bunch(line='a = "Continued string', ctx=('', '"')),
        g.Bunch(line='end of continued string"', ctx=('"', '')),
        g.Bunch(line='a = """Continued docstring', ctx=('', '"""')),
        g.Bunch(line='a = """#', ctx=('', '"""')),
        g.Bunch(line='end of continued string"""', ctx=('"""', '')),
        g.Bunch(line="a = '''Continued docstring", ctx=('', "'''")),
        g.Bunch(line="end of continued string'''", ctx=("'''", '')),
        g.Bunch(line='a = {[(')
    ]
</t>
<t tx="ekr.20181020063656.1">import leo.plugins.importers.dart as dart
if 0: # Preamble.
    if c.isChanged(): c.save()
    import importlib
    importlib.reload(dart)
x = dart.Dart_Importer(c.importCommands, atAuto=False)    
table = (
    ('func(abc) {', 'func'),
    ('void foo() {', 'void foo'),
)
for s, expected in table:
    # print('%20s ==&gt; %s' % (s, x.clean_headline(s)))
    got = x.clean_headline(s)
    assert got == expected
</t>
<t tx="ekr.20181020064529.1">import leo.plugins.importers.markdown as markdown
if 0: # Preamble.
    import leo
    import leo.core.leoImport as leoImport
    import importlib
    importlib.reload(markdown)
    importlib.reload(leoImport)
    ic = leo.core.leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
x = markdown.Markdown_Importer(ic, atAuto=False)   
# insert test for markdown here.
assert x.md_pattern_table
table = (
    (1, 'name',     '# name\n'),
    (2, 'a test',   '## a test\n'),
    (3, 'a test',   '### a test\n'),
)
for data in table:
    level, name, line = data
    level2, name2 = x.is_hash(line)
    assert level == level2
    assert name == name2
level3, name = x.is_hash('Not a hash')
assert level3 == None
assert name == None
</t>
<t tx="ekr.20181020071052.1">import leo.plugins.importers.markdown as markdown
if 0: # Preamble.
    import leo
    import leo.core.leoImport as leoImport
    import importlib
    importlib.reload(markdown)
    importlib.reload(leoImport)
    ic = leo.core.leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
x = markdown.Markdown_Importer(ic, atAuto=False)
for line in ('----\n', '-----\n', '====\n', '====\n'):
    got = x.is_underline(line)
    assert got, repr(line)
for line in ('-\n', '--\n', '---\n', '==\n', '===\n', '===\n','==-==\n', 'abc\n'):
    got = x.is_underline(line)
    assert not got, repr(line)
</t>
<t tx="ekr.20181020072106.1">import leo.plugins.importers.pascal as pascal
if 0: # Preamble.
    import importlib
    importlib.reload(pascal)
x = pascal.Pascal_Importer(c.importCommands, atAuto=False)    
table = (
    ('procedure TForm1.FormCreate(Sender: TObject);\n', 'procedure TForm1.FormCreate'),
)
state = g.Bunch(context='')
for line, cleaned in table:
    assert x.starts_block(0, [line], state, state)
    assert x.clean_headline(line) == cleaned

</t>
<t tx="ekr.20181020074227.2">import leo.plugins.importers.xml as xml
import leo.plugins.importers.linescanner as linescanner
if 0: # Prefix
    import importlib
    importlib.reload(linescanner)
    importlib.reload(xml)
x = xml.Xml_Importer(importCommands = c.importCommands, atAuto = False)
table = (
   (1, ' \n'),
   (1, '\n'),
   (1, ' '),
   (1, '&lt;!-- comment --&gt;'),
   (0, '  &lt;!-- comment --&gt; Help'),
   (0, 'x &lt;!-- comment --&gt;'),
   (0, 'Help'),
)
for expected, line in table:
    got = x.is_ws_line(line)
    assert expected == got, (expected, int(got), repr(line))
</t>
<t tx="ekr.20181020074227.3">import leo.plugins.importers.xml as xml
if 0: # Preamble
    import importlib
    import leo.plugins.importers.linescanner as linescanner
    importlib.reload(linescanner)
    importlib.reload(xml)
x = xml.Xml_Importer(importCommands = c.importCommands, atAuto = False)
table = (
    (0, '&lt;tag&gt;'),
    (0, '&lt;tag&gt;&lt;/tag'),
    (1, '&lt;html'),
    (1, '&lt;html attrib="&lt;"&gt;'),
    (0, '&lt;html attrib="&lt;" /&gt;'),
    (0, '&lt;html&gt;x&lt;/html&gt;'),
    (0, '&lt;/br&gt;'), # Tag underflow
    (0, '&lt;br /&gt;'),
    (0, '&lt;br/&gt;'),
)
for level, line in table:
    prev_state = x.state_class()
    assert prev_state.tag_level == 0
    new_state = x.scan_line(line, prev_state)
    assert new_state.tag_level == level, (new_state, repr(line))
</t>
<t tx="ekr.20181031152556.1"></t>
<t tx="ekr.20190113120618.1"># At least one unit test uses each of these files.</t>
<t tx="ekr.20190113120734.1">@language python
@others
</t>
<t tx="ekr.20190113120734.2">def spam():
    pass</t>
<t tx="ekr.20190113120734.3">def eggs():
    pass</t>
<t tx="ekr.20190113122443.1"># Must be False for @auto unit tests.</t>
<t tx="ekr.20190113123822.1">@language c
@tabwidth -4
// before @others // line 1
@others
// last line: line 6
</t>
<t tx="ekr.20190113123822.2">def spam(): // line 2
    pass
</t>
<t tx="ekr.20190113123822.3">def eggs(): // line 4
    pass
</t>
<t tx="ekr.20190113123853.1">@language python
@tabwidth -4
# Before @others: line 1
@others
# Last line: line 6
</t>
<t tx="ekr.20190113123853.2">def spam(): # line 2
    pass
</t>
<t tx="ekr.20190113123853.3">def eggs(): # line 4
    pass
</t>
<t tx="ekr.20190113124135.1">@language python
@tabwidth -4
# before @others: line 1
@others
# last line: line 6</t>
<t tx="ekr.20190113124135.2">def spam(): # line 2
    pass
</t>
<t tx="ekr.20190113124135.3">def eggs(): # line 4
    pass</t>
<t tx="ekr.20190923014948.1"></t>
<t tx="ekr.20191118154059.1">"""
The master unit test for leoAst.TokenOrderGenerator and related classes.
"""
import time
import leo.core.leoAst as leoAst
if 0: # Not for production.
    import importlib
    importlib.reload(leoAst)
if 0: # Not for production.
    g.cls()
#
# Flags for TR.run_tests.
flags = [
    # New flags.
    'all',
    # 'coverage',
    'show-test-kind', # all vs selected.
    # 'dump-sources-first',
    # 'dump-raw-tree-first',
    # 'dump-tokens-first',
    # 'set-trace-mode',  # Sets TOG.trace_mode.
    # 'show-exception-after-fail',

    # 'dump-tokens-after-fail',
    # 'dump-tree-after-fail',
    # 'dump-all-after-fail',
    # 'dump-contents',
    # 'dump-raw-tree',
    # 'dump-tokens',
    # 'dump-tree',
    # 'summarize',
    # 'trace-times',    # Only for'file:' tests.
    # 'trace-tokenizer-tokens',
    # 'use-asttokens',
]
# Reload (if enabled), then make tests, run tests, and summarize.
leoAst.TestRunner().run_tests(flags, root=c.p)

</t>
<t tx="ekr.20191118155609.1"></t>
<t tx="ekr.20191118155611.1">print('test %s=%s'%(a, 2))
print('done')
</t>
<t tx="ekr.20191118155612.1">open(os.devnull, "w")
</t>
<t tx="ekr.20191118155612.2">a = 1 ; b = 2
print('a') ; print('b')
</t>
<t tx="ekr.20191118160305.1">print('c');
print('d')
</t>
<t tx="ekr.20191119133927.1">class TestClass1:
    pass
    
def decorator():
    pass
    
@decorator
class TestClass2:
    pass
    
@decorator
class TestClass(base1, base2):
    pass
</t>
<t tx="ekr.20191119142414.1">def run(fileName=None, pymacs=None, *args, **keywords):
    pass
</t>
<t tx="ekr.20191119203945.1"># line 856 
</t>
<t tx="ekr.20191119210429.1">print(-(2))
</t>
<t tx="ekr.20191119211714.1">if a and not b and c:
    pass
</t>
<t tx="ekr.20191119213126.1">for i, j in b:
    pass
</t>
<t tx="ekr.20191119213940.1">any([p2.isDirty() for p2 in p.subtree()])
</t>
<t tx="ekr.20191120064442.1">if (a):
    print('a1')
    print('a2')
elif b:
    print('b1')
    print('b2')
else:
    print('c1')
    print('c2')
</t>
<t tx="ekr.20191120074811.1"></t>
<t tx="ekr.20191120075520.1"></t>
<t tx="ekr.20191120132531.1">if 1:
    print('a')
else:
    print('b')
</t>
<t tx="ekr.20191120163559.1">try:
    print('a1')
    print('a2')
except ImportError:
    print('b1')
    print('b2')
except SyntaxError:
    print('c1')
    print('c2')
finally:
    print('d1')
    print('d2')
</t>
<t tx="ekr.20191120164539.1">if a:
    if b:
        print('b')
else:
    if d:
        print('d')
</t>
<t tx="ekr.20191120171921.1">if 1:
    print('a')
elif 2:
    print('b')
elif 3:
    print('c')
    print('d')
print('-')
if 1:
    print('e')
elif 2:
    print('f')
    print('g')


</t>
<t tx="ekr.20191121063148.1">import leo.core.leoAst as leoAst
if 0: ###
    import importlib
    importlib.reload(leoAst)
try:
    import asttokens
except Exception:
    self.skipTest('requires asttokens')
import glob
import os
import time
import token as tm
# Calculate files
core_directory = g.os_path_finalize_join(g.app.loadDir, '..', 'core')
assert os.path.exists(core_directory), core_directory
file_names = glob.glob(core_directory + os.path.sep + 'leo*.py')
for file_name in file_names[:1]:
    path = g.os_path_finalize_join(core_directory, file_name)
    assert os.path.exists(path), path
    with open(path, 'r') as f:
        contents = f.read()
    # Setup asttokens data.
    t1 = time.process_time()
    atok = asttokens.ASTTokens(contents, parse=True, filename=file_name)
    ast_tree = atok.tree
    ast_tokens = atok._tokens
    # Setup TOG data.
    t2 = time.process_time()
    x = leoAst.TokenOrderGenerator() # Use the base class.
    tog_tokens = x.make_tokens(contents)
    tog_tree = leoAst.parse_ast(contents)
    # Compare tokens
    t3 = time.process_time()
    def ast_key(t):
        kind = tm.tok_name[t.type].lower()
        return f"{kind}:{t.string}"

    def token_filter(t):
        return t.kind not in ('encoding', 'ws')
    
    ast_list = [ast_key(z) for z in ast_tokens]
    tog_compare_list = list(filter(token_filter, tog_tokens))
    tog_list = [f"{z.kind}:{z.value}" for z in tog_compare_list]
    # Compare.
    i = leoAst.compare_lists(ast_list, tog_list)
    t4 = time.process_time()
    ok = i is None
    if not ok:
        print('Token mismatch at', i)
        print('ast', repr(ast_list[i]))
        print('tog', repr(tog_compare_list[i]))
    # Print tokens.
    if 0:
        import token as tm
        print('asttokens.tokens...')
        for z in ast_tokens[:10]:
            kind = tm.tok_name[z.type].lower()
            print(f"{z.index:4} {kind:&gt;12} {z.string!r}")
        print('tog.tokens...')
        for z in tog_tokens[:10]:
            print(f"{z.index:4} {z.kind:&gt;12} {z.value!r}")
    # Print summary.
    if not ok:
        print(
            f"{g.shortFileName(file_name)}:\n"
            f"ast_tokens: {len(ast_tokens):&gt;5} "
            f"{t2-t1:4.2f} sec.\n"
            f"tog.tokens: {len(tog_tokens):&gt;5} "
            f"{t3-t2:4.2f} sec.\n"
            f"compare tokens: {t4-t3:4.2f}")
    assert ok
            
</t>
<t tx="ekr.20191121163350.1">import leo.core.leoAst as leoAst
if 0:
    import importlib
    importlib.reload(leoAst)
import ast
try:
    import asttokens
except Exception:
    self.skipTest('requires asttokens')
import glob
import os
import time
if 0:
    file_names = ['contents']
    contents = '''
g.es_print(f"removing callback: {callback}")
'''
else:
    core_directory = g.os_path_finalize_join(g.app.loadDir, '..', 'core')
    assert os.path.exists(core_directory), core_directory
    file_names = glob.glob(core_directory + os.path.sep + 'leo*.py')

for file_name in file_names[:1]:
    if file_name == 'contents':
        pass
    else:
        path = g.os_path_finalize_join(core_directory, file_name)
        assert os.path.exists(path), path
        with open(path, 'r') as f:
            contents = f.read()
    # Setup asttokens data.
    t1 = time.process_time()
    atok = asttokens.ASTTokens(contents, parse=True, filename=file_name)
    ast_tree = atok.tree
    ast_nodes = list(asttokens.util.walk(ast_tree))
    # Compute tog nodes.
    t2 = time.process_time()
    x = leoAst.TokenOrderNodeGenerator()
    tog_tree = leoAst.parse_ast(contents)
    tog_nodes = list(x.generate_nodes(tog_tree))
    # Filter the nodes.
    t3 = time.process_time()
    ast_nodes2 = [z.__class__.__name__ for z in ast_nodes
        if not isinstance(z, (ast.alias, int, bool, str))]
    tog_nodes2 = [z.__class__.__name__ for z in tog_nodes]
    t4 = time.process_time()
    print('Comparing trees in', g.shortFileName(file_name), '...')
    print('len(ast):', len(ast_nodes2), 'len(tog)', len(tog_nodes2))
    ### g.printObj([z.__class__.__name__ for z in tog_nodes[:10]])
    i = leoAst.compare_lists(ast_nodes2, tog_nodes2)
    ok = i is None
    if ok:
        print('Tree match!', file_name)
    else:
        print('Tree mismatch at', i)
        # limit = min(len(ast_nodes2), len(tog_nodes2))
        for j in range(i-5, i+5):
            if j &gt;= 0:
                print('ast', j, ast_nodes2[j-1:j][0])
                print('tog', j, tog_nodes2[j-1:j][0])
                print('')
        print('Tree mismatch at', i)
    # Print tokens.
    if 1:
        print('')
        print(
            f"file: {g.shortFileName(file_name)}:\n"
            f"ast_nodes: {len(ast_nodes):&gt;5} "
            f"{t2-t1:5.2f} sec.\n"
            f"tog.nodes: {len(tog_nodes):&gt;5} "
            f"{t3-t2:5.2f} sec.\n"
            f"compare nodes: {t4-t3:4.2f}")
    assert ok
</t>
<t tx="ekr.20191122153258.1">run(a=None, b=str)
</t>
<t tx="ekr.20191122203522.1">"""ds 1"""
class TestClass:
    """ds 2"""
    def long_name(a, b=2):
        """ds 3"""
        print('done')
</t>
<t tx="ekr.20191122210035.1">if 1:
    print('a')
else:
    if 2:
        print('b')
</t>
<t tx="ekr.20191122210522.1"></t>
<t tx="ekr.20191122213610.1">if 1:
    pass
elif 2:
    pass
    pass
</t>
<t tx="ekr.20191123203957.1"># line 1604.
</t>
<t tx="ekr.20191123210801.1">if -(2):
    pass
</t>
<t tx="ekr.20191124040736.1"></t>
<t tx="ekr.20191125151346.1"></t>
<t tx="ekr.20191125161333.1">if 1:
    a = 'class' if cond else 'def'
    # find_pattern = prefix + ' ' + word
    print('1')
else:
    print('2')
</t>
<t tx="ekr.20191125165640.1">func(f"{b if not cond1 else ''}")
</t>
<t tx="ekr.20191125235415.1">print('a' 'b')
print('c')
</t>
<t tx="ekr.20191125235556.1">"""
A unit test that tests TOG on all of Leo's sources.
"""
import time
import leo.core.leoAst as leoAst
if 0: # Not for production.
    import importlib
    importlib.reload(leoAst)
if 0: # Not for production.
    g.cls()
#
# Flags for TR.run_tests.
flags = [
    # New flags.
    'all-leo-files',
    'coverage',
    'show-test-kind', # all vs selected.
    # 'dump-sources-first',
    # 'dump-raw-tree-first',
    # 'dump-tokens-first',
    # 'set-trace-mode',  # Sets TOG.trace_mode.
    # 'show-exception-after-fail',

    # 'dump-tokens-after-fail',
    # 'dump-tree-after-fail',
    # 'dump-all-after-fail',
    # 'dump-contents',
    # 'dump-raw-tree',
    # 'dump-tokens',
    # 'dump-tree',
    'summarize',
    # 'trace-times',    # Only for'file:' tests.
    # 'trace-tokenizer-tokens',
    # 'use-asttokens',
]
# Reload (if enabled), then make tests, run tests, and summarize.
leoAst.TestRunner().run_tests(flags, root=c.p)

</t>
<t tx="ekr.20191126002258.1">print(f'x3{e3+1}y3' f'x4{e4+2}y4')
print('done')
</t>
<t tx="ekr.20191126084046.1"></t>
<t tx="ekr.20191126143046.1">self.s = ''
self.i = 0
</t>
<t tx="ekr.20191127134236.1"></t>
<t tx="ekr.20191127134726.1"># leoFind.py: line 861
one(f"{'B'}" ": ")
</t>
<t tx="ekr.20191127172440.1">print("a\"b")
</t>
<t tx="ekr.20191128141922.1">print(f"test {a}={2}")
print('done')
</t>
<t tx="ekr.20191129033147.1">print(f'{7.1}' 'p7.2')
print('end')
</t>
<t tx="ekr.20191129033245.1">print(f'x1{e1}y1', 'p1')
print(f'x2{e2}y2', f'f2')
print(f'x3{e3}y3', f'x4{e4}y4')
print('end')
</t>
<t tx="ekr.20191129033359.1">print(f'x1{e1}y1{e2}z1', 'p1')
print(f'x2{e3}y2{e3}z2', f'f2')
print(f'x3{e4}y3{e5}z3', f'x4{e6}y4{e7}z4')
print('end')
</t>
<t tx="ekr.20191129035530.1"># Single f-strings.
# 'p1' ;
# f'f1' ;
# f'x1{e1}y1' ;
# f'x2{e2+1}y2{e2+2}z2' ;

# Concatentated strings...
# 'p2', 'p3' ;
# f'f2' 'f3' ;

# f'x5{e5+1}y5{e5+1}z5' f'x6{e6+1}y6{e6+1}z6' ;
</t>
<t tx="ekr.20191129042702.1">'p1' ;
f'f1' ;
'done' ;
</t>
<t tx="ekr.20191201062631.1">f1(a='\b', b='\n', t='\t')
f2(f='\f', r='\r', v='\v')
f3(bs='\\')
</t>
<t tx="ekr.20191201064058.1">r1(a=r'\b', b=r'\n', t=r'\t')
r2(f=r'\f', r=r'\r', v=r'\v')
r3(bs=r'\\')
</t>
<t tx="ekr.20191201064443.1"># leoFind.py line 856

a = f"{'a' if x else 'b'}"
f()

# Pass
# print(f"{'a' if x else 'b'}")
</t>
<t tx="ekr.20191201065409.1">print('hello\
world')
</t>
<t tx="ekr.20191201072043.1">d = {
    'a' if x else 'b': True,
    }
f()
</t>
<t tx="ekr.20191201083823.1">func(
    "Isearch"
    f"{' Backward' if True else ''}"
)
print('done')
</t>
<t tx="ekr.20191201124815.1">print(f'{7.1}')
print('end')
</t>
<t tx="ekr.20191201131734.1">print('p1' f'{f2}')
'end'
</t>
<t tx="ekr.20191201134842.1">print(f'{f1}' f'{f2}')
'end'
</t>
<t tx="ekr.20191201135548.1">print('s1', f'{f2}' f'f3' f'{f4}' 's5')
'end'
</t>
<t tx="ekr.20191201201448.1">print(f"{list(z for z in ('a', 'b', 'c') if z != 'b')}")
</t>
<t tx="ekr.20191202195507.1"># Line 1619 leoFind.py
print(r"""DS""")
</t>
<t tx="ekr.20191203111346.1"># leoGlobals.py line 806.
print('"')
</t>
<t tx="ekr.20191203120043.1"># Line 1604, leoGlobals.py
def spam():
    global gg
    print('')
</t>
<t tx="ekr.20191203121918.1"># leoGlobals.py.

class SherlockTracer:
    """before\\after"""
</t>
<t tx="ekr.20191203125053.1"># leoGlobals.py, line 1785.

with open(fn) as f:
    pass

</t>
<t tx="ekr.20191203125635.1"># leoGlobals.py, line 3028.

d2 = {val: key for key, val in d.iteritems()}
</t>
<t tx="ekr.20191203155845.1"># line 93.
</t>
<t tx="ekr.20191203160056.1"># Line 93, leoTips.py
unseen = [i for i in range(5) if i not in seen]
for issue in data:
    for a in aList:
        print('a')
    else:
        print('b')
if b:
    print('c')
</t>
<t tx="ekr.20191203185327.1"># Line 4609, leoGlobals.py
print("\x7e" "\0777") # tilde.
print('done')
</t>
<t tx="ekr.20191204025303.1">f1(a,b=2)
f2(1 + 2)
f3(arg, *args, **kwargs)
f4(a='a', *args, **kwargs)
func(a, b, one='one', two='two', *args, **kwargs)
</t>
<t tx="ekr.20191204150947.1"># Line 7709, leoGlobals.py

fr"""{kinds}://[^\s'"]+[\w=/]"""
</t>
<t tx="ekr.20191204154152.1"></t>
<t tx="ekr.20191204154344.1"># Line 201, leoApp.py

print(b'\xfe')
print('done')
</t>
<t tx="ekr.20191204164129.1"># Line 1177, leoApp.py

print(
    message = f"line 1: {old_id!r}\n" "line 2\n"
)
print('done')
</t>
<t tx="ekr.20191205014742.1"># The first newline causes the fail.
print(f"a {old_id!r}\n" "b\n")
print('done')
</t>
<t tx="ekr.20191205071617.1"># line 1046, leoAst.py.

</t>
<t tx="ekr.20191205071827.1"># Line 1046, leoAst.py

self.node = tree
yield from self.gen_token('newline', '\n')
print('done')
</t>
<t tx="ekr.20191205090312.1"></t>
<t tx="ekr.20191205090519.1"></t>
<t tx="ekr.20191205090659.1"># Line 240: leoDebugger.py

try:
    print('a')
except ValueError:
    print('b')
else:
    print('c')
</t>
<t tx="ekr.20191206053245.1"># Only a comment.
</t>
<t tx="ekr.20191207060251.1">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20191207060251.2">def spam():
    pass
</t>
<t tx="ekr.20191207060251.3">def eggs():
    pass
</t>
<t tx="ekr.20191215093835.12"></t>
<t tx="ekr.20191215093835.13"></t>
<t tx="ekr.20191215093835.14"></t>
<t tx="ekr.20191215093835.15"></t>
<t tx="ekr.20191215093835.16"></t>
<t tx="ekr.20191215093835.9"></t>
<t tx="ekr.20191219051321.68">#!/usr/bin/env python3

@others
if __name__=="__main__":
    main()
@language python
@tabwidth -4
</t>
<t tx="ekr.20191219051321.69">import os
import re

</t>
<t tx="ekr.20191219051321.70">def merge_value(v1, v2):
    return v

</t>
<t tx="ekr.20191219051321.71">class MainDisplay(object):

    @others
ensure_endswith_newline = lambda x: x if x.endswith('\n') else x + '\n'

</t>
<t tx="ekr.20191219051321.72">def save_file(self):
    """Write the file out to disk."""
    with open(self.save_name, "w") as f:
        for newline in newlines:
            f.write(newline)

# This line should be included at the end of the class node.
</t>
<t tx="ekr.20191219051321.73">def retab(s, tabsize):
    return ''.join(pieces)

</t>
<t tx="ekr.20191219054650.1">
c:\leo.repo\leo-editor\leo\core\leoGlobals.py:43: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses
  import imp

C:\Anaconda3\lib\site-packages\nbconvert\exporters\exporter_locator.py:28:
    DeprecationWarning: `nbconvert.exporters.exporter_locator`
    is deprecated in favor of `nbconvert.exporters.base` since nbconvert 5.0.
  DeprecationWarning)

&lt;string&gt;:22: DeprecationWarning: inspect.getargspec() is deprecated,
use inspect.signature() or inspect.getfullargspec()
</t>
<t tx="ekr.20191219172058.1">import leo.core.leoTest as leoTest
try:
    import importlib
    importlib.reload(leoTest)
    print(leoTest)
except Exception:
    g.es_print_exception()

</t>
<t tx="ekr.20191219183054.1">@nosearch

# flattened, word, ignore-case, head, body

# found 66 nodes</t>
</tnodes>
</leo_file>
