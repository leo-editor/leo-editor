<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.45" body_secondary_ratio="0.74">
	<global_window_position top="127" left="550" height="861" width="1185"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070416075121"><vh>Startup</vh>
<v t="ekr.20070224123943"><vh>@settings</vh>
<v t="ekr.20091230064146.1911"><vh>@data import_xml_tags</vh></v>
<v t="ekr.20071025193940"><vh>@enabled-plugins</vh></v>
<v t="ekr.20110510110227.2439"><vh>Autocompleter settings</vh>
<v t="ekr.20110512085154.2447"><vh>@bool auto_tab_complete = True</vh></v>
<v t="ekr.20110511061102.5232"><vh>@bool enable_autocompleter_initially = False</vh></v>
<v t="ekr.20110512225930.2456"><vh>@bool enable_calltips_initially = False</vh></v>
<v t="ekr.20110510110227.2440"><vh>@bool use_qcompleter = False</vh></v>
</v>
<v t="ekr.20100118190256.2014"><vh>Chapters</vh>
<v t="ekr.20070604100125"><vh>@bool use_chapter_tabs = True</vh></v>
<v t="ekr.20070503085527"><vh>@bool use_chapters = True</vh></v>
</v>
<v t="ekr.20110521072459.2463"><vh>colorizer colors</vh>
<v t="ekr.20110521072459.2464"><vh>@@color keyword3_color = orange</vh></v>
<v t="ekr.20110521072459.2465"><vh>@@color keyword4_color = pink</vh></v>
</v>
<v t="ekr.20120928143821.3161"><vh>Log pane colors</vh>
<v t="ekr.20120928143821.3162"><vh>@@color log_error_color = orange</vh></v>
<v t="ekr.20120928143821.3168"><vh>@@color log_warning_color = purple</vh></v>
<v t="ekr.20120928143821.3163"><vh>@@color log_text_foreground_color = pink</vh></v>
<v t="ekr.20120928143821.3164"><vh>@@color log_text_background_color = None</vh></v>
</v>
<v t="ekr.20100118190256.2015"><vh>Files &amp; directories</vh>
<v t="ekr.20101009105505.2295"><vh>@bool put_expansion_bits_in_leo_files = False</vh></v>
<v t="ekr.20080822153619.1"><vh>@string shadow_subdir = .leo/shadow</vh></v>
<v t="ekr.20080922164255.1"><vh>@string test = c:\leo.repo\trunk\leo\test</vh></v>
</v>
<v t="ekr.20080729153237.1"><vh>Gc settings</vh>
<v t="ekr.20080729153237.2"><vh>@bool trace_gc = False</vh></v>
<v t="ekr.20080729153237.3"><vh>@bool trace_gc_calls = False</vh></v>
<v t="ekr.20080729153237.4"><vh>@bool trace_gc_verbose = False</vh></v>
</v>
<v t="ekr.20080529111617.1"><vh>Plugins</vh>
<v t="ekr.20070723091227"><vh>http plugin</vh>
<v t="ekr.20070723091227.1"><vh>@bool http_active = True</vh></v>
<v t="ekr.20070723091227.2"><vh>@int</vh>
<v t="ekr.20090316115500.1"><vh>port = 8080</vh></v>
</v>
<v t="ekr.20070723091227.3"><vh>@string rst_http_attributename = 'rst_http_attribute'</vh></v>
</v>
<v t="ekr.20080529111617.2"><vh>cleo</vh>
<v t="ekr.20080529111617.3"><vh>@color cleo_color_prog_green =</vh></v>
<v t="ekr.20080529111617.4"><vh>@color cleo_color_prog_red =</vh></v>
<v t="ekr.20080529111617.5"><vh>@data cleo_color_file_node_list</vh></v>
<v t="ekr.20080529111617.6"><vh>@int cleo_prog_width = 18</vh></v>
<v t="ekr.20080529111617.7"><vh>@float cleo_time_init = 1.0</vh></v>
<v t="ekr.20080529111617.8"><vh>@int cleo_prog_scale = 1</vh></v>
<v t="ekr.20080529111617.9"><vh>@float cleo_prog_extra = 4</vh></v>
<v t="ekr.20080529111617.10"><vh>@string cleo_time_name = 'days'</vh></v>
</v>
<v t="ekr.20100910124218.2257"><vh>screenshot settings</vh>
<v t="ekr.20100910124218.2258"><vh>@bool edit-screenshots = True</vh></v>
<v t="ekr.20100910124218.2259"><vh>@string screenshot-bin = "c:\Program Files (x86)\Inkscape\inkscape.exe"</vh></v>
</v>
<v t="ekr.20110321213552.2500"><vh>viewrendered settings</vh>
<v t="ekr.20110321213552.2497"><vh>@bool view-rendered-auto-create = False</vh></v>
<v t="ekr.20110526180653.2467"><vh>@bool view-rendered-auto-hide = True</vh></v>
<v t="ekr.20110321213552.2499"><vh>@bool scrolledmessage_use_viewrendered = True</vh></v>
</v>
</v>
<v t="ekr.20100118190256.2012"><vh>Syntax coloring</vh>
<v t="ekr.20100118141712.2011"><vh>@@int qt_tab_width = 80</vh></v>
<v t="ekr.20100118122048.2003"><vh>@@font python keyword1 fonts</vh></v>
<v t="ekr.20100118133026.2008"><vh>@@font python keyword3 fonts</vh></v>
<v t="ekr.20100119095312.2041"><vh>@@font rest keyword2 fonts</vh></v>
<v t="ekr.20100119100926.2046"><vh>@@font rest keyword4 fonts</vh></v>
<v t="ekr.20100330084954.2125"><vh>@color pseudoplain_operator_color = blue</vh></v>
</v>
<v t="ekr.20100118190256.2016"><vh>Vim</vh>
<v t="ekr.20090815161520.1815"><vh>@string vim_trigger_event = select2</vh></v>
<v t="ekr.20080604104453.5"><vh>@strings [command,insert, overwrite] top_level_unbound_key_action = insert</vh></v>
</v>
<v t="ekr.20100118190256.2013"><vh>Windows</vh>
<v t="ekr.20100507151756.2123"><vh>@string qt-toolbar-location=top</vh></v>
<v t="ekr.20090629105832.1790"><vh>@@bool big_outline_pane = True</vh></v>
<v t="ekr.20080412082246.1"><vh>@bool fixedWindow = False</vh></v>
</v>
</v>
<v t="ekr.20041001211817"><vh>Buttons</vh>
<v t="ekr.20070531102813"><vh>@ignore Disabled buttons</vh>
<v t="ekr.20071002150320"><vh>@button create-canvas</vh></v>
<v t="ekr.20100812102648.2193"><vh>@button format-code</vh>
<v t="ekr.20100812102648.2195"><vh>&lt;&lt; options &gt;&gt;</vh></v>
<v t="ekr.20100812114823.2176"><vh>The code-to-rst command</vh>
<v t="ekr.20100812114823.2177"><vh>code_to_rst_command &amp; helpers</vh>
<v t="ekr.20100812114823.2178"><vh>write_code_body &amp; helpers</vh>
<v t="ekr.20100812114823.2179"><vh>split_parts</vh></v>
<v t="ekr.20100812114823.2180"><vh>write_code_block</vh></v>
</v>
<v t="ekr.20100812114823.2181"><vh>write_code_headline &amp; helper</vh>
<v t="ekr.20100812114823.2182"><vh>write_code_headline_helper</vh></v>
</v>
<v t="ekr.20100812114823.2183"><vh>write_code_node</vh></v>
<v t="ekr.20100812114823.2184"><vh>write_code_tree</vh></v>
</v>
<v t="ekr.20100812114823.2185"><vh>Changed methods</vh>
<v t="ekr.20100812114823.2186"><vh>getOption &amp; setOption</vh></v>
<v t="ekr.20100812114823.2187"><vh>initOptionsFromSettings</vh></v>
<v t="ekr.20100812114823.2188"><vh>writeSpecialTree</vh></v>
</v>
</v>
</v>
<v t="ekr.20090701125834.1765"><vh>@button insert-inst-icon</vh></v>
<v t="ekr.20061030041200"><vh>@button iron-py</vh></v>
<v t="ekr.20110414063538.2372"><vh>@button json r/w</vh>
<v t="ekr.20110414063538.2385"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20110414063538.2383"><vh>TestClass</vh>
<v t="ekr.20110414073628.2389"><vh> utils</vh></v>
<v t="ekr.20110414063538.2384"><vh>main</vh></v>
<v t="ekr.20110414094917.2406"><vh>Reading...</vh>
<v t="ekr.20110414094917.2420"><vh>Not used</vh>
<v t="ekr.20110414094917.2415"><vh>readSaxFile</vh></v>
<v t="ekr.20110414094917.2418"><vh>setPositionsFromVnodes &amp; helper</vh>
<v t="ekr.20110414094917.2419"><vh>archivedPositionToPosition</vh></v>
</v>
<v t="ekr.20110414094917.2416"><vh>resolve_tnode_lists</vh></v>
<v t="ekr.20110414094917.2417"><vh>resolve_archived_position</vh></v>
</v>
<v t="ekr.20110414185051.2435"><vh>create_v_dict</vh></v>
<v t="ekr.20110414094917.2422"><vh>read_json_data &amp; helper</vh>
<v t="ekr.20110414094917.2432"><vh>create_t_dict</vh></v>
</v>
<v t="ekr.20110414094917.2408"><vh>create_json_children</vh></v>
<v t="ekr.20110414094917.2409"><vh>create_json_vnode &amp; helpers</vh>
<v t="ekr.20110414094917.2410"><vh>handle_json_tnode_attributes</vh></v>
<v t="ekr.20110414094917.2411"><vh>handle_json_vnode_attributes</vh></v>
</v>
<v t="ekr.20110414094917.2413"><vh>get_json_ua</vh></v>
</v>
<v t="ekr.20110414094917.2391"><vh>Writing...</vh>
<v t="ekr.20110414063538.2373"><vh>putFile</vh></v>
<v t="ekr.20110414063538.2374"><vh>putTnode</vh></v>
<v t="ekr.20110414063538.2375"><vh>putTnodes</vh>
<v t="ekr.20110414063538.2376"><vh>&lt;&lt; write only those tnodes that were referenced &gt;&gt;</vh></v>
</v>
<v t="ekr.20110414063538.2377"><vh>putVnode</vh>
<v t="ekr.20110414063538.2378"><vh>&lt;&lt; Set gnx = vnode index &gt;&gt;</vh></v>
<v t="ekr.20110414063538.2379"><vh>&lt;&lt; Append attribute bits to attrs &gt;&gt;</vh></v>
<v t="ekr.20110414063538.2380"><vh>&lt;&lt; Append unKnownAttributes to attrs&gt;&gt; fc.put</vh></v>
<v t="ekr.20110414063538.2381"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
</v>
<v t="ekr.20110414063538.2382"><vh>putVnodes</vh></v>
</v>
</v>
</v>
<v t="ekr.20080806145258.14"><vh>@button Leo2DHTML</vh>
<v t="ekr.20080806145258.15"><vh>&lt;&lt; about LeoToHTML &gt;&gt;</vh></v>
<v t="ekr.20080806145258.16"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.17"><vh>escape</vh></v>
<v t="ekr.20080806145258.18"><vh>writeAll</vh></v>
<v t="ekr.20080806145258.19"><vh>writeBody</vh></v>
<v t="ekr.20080806145258.20"><vh>writeHead</vh></v>
<v t="ekr.20080806145258.21"><vh>writeContents</vh></v>
<v t="ekr.20080806145258.22"><vh>writePreamble</vh></v>
<v t="ekr.20080806145258.23"><vh>writePostamble</vh></v>
</v>
<v t="ekr.20101103135707.2439"><vh>@button move head to prev</vh></v>
<v t="ekr.20101103170034.2445"><vh>@button move tail to next</vh></v>
<v t="ekr.20080105115712"><vh>@button pylint</vh>
<v t="ekr.20080115085447"><vh>harmless warnings, errors</vh></v>
<v t="ekr.20080105130903"><vh>warnings</vh></v>
<v t="ekr.20080105120559"><vh>&lt;&lt; define data &gt;&gt;</vh></v>
</v>
<v t="ekr.20090715064044.1782"><vh>@button render-as-sphinx</vh></v>
<v t="ekr.20080807114145.2"><vh>@button run-windows-script</vh>
<v t="ekr.20080807115344.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080807115344.2"><vh>class MySite</vh></v>
<v t="ekr.20080807115344.3"><vh>class Application</vh></v>
<v t="ekr.20080807115344.4"><vh>RunCode</vh></v>
</v>
<v t="ekr.20070115092430"><vh>@button winpdb</vh></v>
<v t="ekr.20080815073750.1"><vh>@button write-nosent-files</vh></v>
<v t="ekr.20070929122956.1"><vh>buttons for networkx</vh>
<v t="ekr.20070929070426"><vh>@button print link</vh></v>
<v t="ekr.20070927175908"><vh>@button leo2graph</vh></v>
<v t="ekr.20070929062147.1"><vh>@button at-graph2graph</vh></v>
<v t="ekr.20070929062147.2"><vh>@button at-networkx2graph</vh>
<v t="ekr.20070929081505"><vh>error</vh></v>
<v t="ekr.20070929074830"><vh>parse</vh></v>
<v t="ekr.20070929072506.2"><vh>parseNodes</vh></v>
<v t="ekr.20070929074830.1"><vh>parseEdges</vh></v>
</v>
<v t="ekr.20070929082546"><vh>@button at-networkx2at-graph</vh>
<v t="ekr.20070929120541"><vh>createEdges</vh></v>
<v t="ekr.20070929120541.1"><vh>createNodes</vh></v>
<v t="ekr.20070929115302"><vh>createTree</vh></v>
<v t="ekr.20070929114410.2"><vh>error</vh></v>
<v t="ekr.20070929114410.3"><vh>parse</vh></v>
<v t="ekr.20070929114410.5"><vh>parseEdges</vh></v>
<v t="ekr.20070929114410.4"><vh>parseNodes</vh></v>
</v>
</v>
<v t="ekr.20110320205650.2495"><vh>Movie buttons</vh>
<v t="ekr.20101014040509.2318"><vh>@@button play/pause (OLD)</vh></v>
<v t="ekr.20101014040509.2321"><vh>@button crash test</vh></v>
<v t="ekr.20101014040509.2316"><vh>@button load video</vh>
<v t="ekr.20101014040509.2317"><vh>run</vh></v>
</v>
<v t="ekr.20110321012354.2495"><vh>@button pause-play</vh></v>
<v t="ekr.20101014040509.2320"><vh>@button show-stack</vh></v>
<v t="ekr.20101014040509.2319"><vh>@button vid-stop</vh></v>
</v>
<v t="ekr.20060904110922"><vh>OPML buttons</vh>
<v t="ekr.20060904111037.1"><vh>@button opml-write</vh></v>
<v t="ekr.20060904111037"><vh>@button opml-read</vh></v>
</v>
<v t="ekr.20090620063706.1826"><vh>Prototype of rendering commands</vh>
<v t="ekr.20090619103402.1818"><vh>@button render-as-html</vh></v>
<v t="ekr.20090619103402.1821"><vh>@button render-as-text</vh></v>
</v>
<v t="ekr.20091013153026.2721"><vh>Prototype of using patternmatch library</vh>
<v t="ekr.20091011110344.1853"><vh>@button find script a</vh></v>
<v t="ekr.20091010091628.1836"><vh>@button create find button</vh>
<v t="ekr.20091010104145.1840"><vh>class patController</vh>
<v t="ekr.20091010104145.1842"><vh>ctor</vh></v>
<v t="ekr.20091010104145.1843"><vh>setup</vh></v>
<v t="ekr.20091010104145.1844"><vh>driver</vh></v>
<v t="ekr.20091010104145.1845"><vh>find</vh></v>
<v t="ekr.20091010104145.1846"><vh>findr</vh></v>
</v>
</v>
<v t="ekr.20091010091628.1837"><vh>find pat a</vh></v>
</v>
<v t="ekr.20100109084336.1996"><vh>Prototypes of gui-dependent cursor move helpers</vh>
<v t="ekr.20100109081612.1984"><vh>@button up</vh></v>
<v t="ekr.20100109081746.1990"><vh>@button up-extend</vh></v>
<v t="ekr.20100109081746.1993"><vh>@button up-page-extend</vh></v>
<v t="ekr.20100109081746.1988"><vh>@button down</vh></v>
<v t="ekr.20100109081746.1992"><vh>@button down-extend</vh></v>
</v>
<v t="ekr.20110526180653.2468"><vh>viewrendered buttons</vh>
<v t="ekr.20110321012354.2496"><vh>@button toggle-renderer</vh></v>
<v t="ekr.20110321073942.2490"><vh>@button lock-unlock-renderer</vh></v>
<v t="ekr.20110321213439.2495"><vh>@button update-renderer</vh></v>
</v>
<v t="ekr.20120923105702.3128"><vh>@button tutorial</vh></v>
<v t="ekr.20120925084214.3144"><vh>@button show-vpos</vh></v>
</v>
</v>
<v t="ekr.20070410063214"><vh>Commands</vh>
<v t="ekr.20111020134534.2594"><vh>@ignore disabled commands</vh>
<v t="ekr.20071128122043"><vh>@command create-shell-tab</vh></v>
<v t="ekr.20060924180049"><vh>@command clones-tab</vh>
<v t="ekr.20060924180049.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060924180049.2"><vh>init</vh></v>
<v t="ekr.20060924180049.3"><vh>getAllClones</vh></v>
<v t="ekr.20060924180049.4"><vh>displayClones</vh>
<v t="ekr.20060924180049.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060924180049.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20080823154546.1"><vh>@command parse-python</vh></v>
<v t="edward.20081127113749.2"><vh>@command complete-previous</vh>
<v t="edward.20081127113749.3"><vh>WordCompleter</vh>
<v t="edward.20081127113749.4"><vh>complete_word</vh>
<v t="edward.20081127113749.5"><vh>&lt;&lt;backward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"><vh>&lt;&lt;counter check&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.7"><vh>&lt;&lt;forward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"></v>
</v>
<v t="edward.20081127113749.8"><vh>&lt;&lt;clean up and exit&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.9"><vh>acceptable_word</vh></v>
<v t="edward.20081127113749.10"><vh>undo_replacement</vh></v>
<v t="edward.20081127113749.11"><vh>redo_replacement</vh></v>
<v t="edward.20081127113749.12"><vh>exit</vh></v>
<v t="edward.20081127113749.13"><vh>run</vh></v>
<v t="edward.20081127113749.14"><vh>adjust</vh></v>
</v>
<v t="edward.20081127113749.15"><vh>getCurrentWord</vh></v>
</v>
<v t="edward.20081127113749.16"><vh>@command complete-next</vh>
<v t="edward.20081127113749.3"></v>
<v t="edward.20081127113749.15"></v>
</v>
</v>
</v>
<v t="ekr.20071026102420.3"><vh>Scripts</vh>
<v t="ekr.20100127111425.2062"><vh>search script (do not delete)</vh>
<v t="ekr.20100731123441.2155"><vh>searchDir</vh></v>
</v>
<v t="ekr.20090309064612.2"><vh> Example scripts</vh>
<v t="ekr.20080701130406.1"><vh>Run pylint on plugins</vh></v>
<v t="ekr.20080617170334.1"><vh>Determining key values</vh></v>
<v t="ekr.20080920101658.1"><vh>getInput</vh></v>
<v t="ekr.20080917063615.1"><vh>getSettingSource</vh></v>
<v t="ekr.20081205104320.1"><vh>run bash script</vh></v>
</v>
<v t="ekr.20071129103842"><vh>create-at-auto-nodes</vh></v>
<v t="ekr.20090428081009.1"><vh>patching auto-completion table</vh></v>
<v t="ekr.20090205070715.1"><vh>print colorer stats</vh></v>
<v t="ekr.20121011100948.4582"><vh>Recursive import script (with cleanups)</vh>
<v t="ekr.20121011100948.4601"><vh>class ImportController</vh>
<v t="ekr.20121011100948.4583"><vh>Pass 1: import_dir</vh></v>
<v t="ekr.20121011100948.4584"><vh>Pass 2: clean_all &amp; helpers</vh>
<v t="ekr.20121011100948.4585"><vh>clean</vh></v>
<v t="ekr.20121011100948.4586"><vh>clean_blank_lines</vh></v>
<v t="ekr.20121011100948.4587"><vh>merge_comment_nodes</vh></v>
<v t="ekr.20121011100948.4588"><vh>merge_extra_nodes</vh></v>
<v t="ekr.20121011100948.4589"><vh>move_decorator_lines</vh></v>
<v t="ekr.20121011100948.4590"><vh>move_doc_string</vh></v>
<v t="ekr.20121011100948.4591"><vh>move_shebang_line</vh></v>
<v t="ekr.20121011100948.4592"><vh>rename_decls</vh></v>
</v>
<v t="ekr.20121011100948.4593"><vh>Pass 3: post_process &amp; helpers</vh>
<v t="ekr.20121011100948.4594"><vh>clear_dirty_bits</vh></v>
<v t="ekr.20121011100948.4595"><vh>dump_headlines</vh></v>
<v t="ekr.20121011100948.4596"><vh>fix_back_slashes</vh></v>
<v t="ekr.20121011100948.4597"><vh>minimize_headlines</vh></v>
<v t="ekr.20121011100948.4598"><vh>remove_empty_nodes</vh></v>
<v t="ekr.20121011100948.4599"><vh>munge_at_file (not used)</vh></v>
</v>
<v t="ekr.20121011100948.4600"><vh>run</vh></v>
</v>
</v>
<v t="ekr.20070517070854"><vh>run script in nullGui</vh></v>
<v t="ekr.20070517071510"><vh>run script with leoBridge</vh></v>
<v t="ekr.20080206055658"><vh>Script to print font settings</vh></v>
</v>
</v>
<v t="ekr.20071025193940"></v>
<v t="ekr.20120923110028.3130"><vh>Notes</vh>
<v t="ekr.20090309064612.3"><vh>New features</vh>
<v t="ekr.20090309064612.4"><vh>Decorator tests</vh>
<v t="ekr.20080628094340.1"><vh>Decorator test</vh></v>
<v t="edward.20081221145716.1"><vh>decorator test 2</vh></v>
</v>
<v t="ekr.20090201162523.1"><vh>Macro test</vh>
<v t="ekr.20090201192257.1"><vh>@@test macro ab</vh></v>
</v>
<v t="ekr.20090128131130.1"><vh>posList tests</vh></v>
<v t="ekr.20090128112453.1"><vh>Property tests</vh></v>
<v t="ekr.20090507082111.1904"><vh>test creation of gnx's</vh></v>
<v t="ekr.20090601093755.1802"><vh>Test of @g.command decorator</vh></v>
<v t="ekr.20080922164656.1"><vh>Tests of path expressions</vh>
<v t="ekr.20080921144924.1"><vh>Tests of g.os_path_finalize</vh></v>
<v t="ekr.20080922142953.1"><vh>test os_pathExpression</vh></v>
<v t="ekr.20080922164255.1"></v>
<v t="ekr.20080922164255.2"><vh>@@shadow {{c.config.getString('test')}}/eval-shadow-test.txt</vh></v>
<v t="ekr.20080923073240.2"><vh>@path {{c.config.getString('test')}}</vh>
<v t="ekr.20080923073240.1"><vh>@@thin eval-thin-test.txt</vh></v>
</v>
</v>
<v t="ekr.20080531080812.1"><vh>tracer tests</vh></v>
<v t="ekr.20100616085524.2191"><vh>config iter</vh></v>
<v t="ekr.20100615095815.2189"><vh>activate/deactivate events</vh></v>
</v>
<v t="ekr.20070517160058.1"><vh>Prototypes</vh>
<v t="ekr.20101110190130.2451"><vh>example leoremote client</vh></v>
<v t="ekr.20100108090658.1958"><vh>generate key events</vh>
<v t="ekr.20100108090658.1959"><vh>Reference</vh></v>
<v t="ekr.20100108111728.2077"><vh>Binding dicts</vh></v>
<v t="ekr.20100108102030.1962"><vh>&lt;&lt; imports&gt;&gt;</vh></v>
<v t="ekr.20100108102030.1963"><vh>&lt;&lt; constants &gt;&gt;</vh></v>
<v t="ekr.20100108111728.2076"><vh>adjustBindings</vh></v>
<v t="ekr.20100108102217.1966"><vh>overrideCommand</vh></v>
<v t="ekr.20100108102217.1967"><vh>setKeyAndMods</vh></v>
<v t="ekr.20100108102217.1968"><vh>testKeys</vh></v>
</v>
<v t="ekr.20090507082535.1906"><vh>Get my email</vh></v>
<v t="ekr.20080531131542.1"><vh>mxTextTools proto</vh>
<v t="ekr.20080531141227.1"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
<v t="ekr.20080531131542.2"><vh>&lt;&lt; define scan4 tables &gt;&gt;</vh></v>
<v t="ekr.20080531131542.4"><vh>printItem</vh></v>
</v>
<v t="ekr.20080806145258.12"><vh>Prototype of Leo in Ajax</vh>
<v t="ekr.20080806145258.13"><vh>To do</vh></v>
<v t="ekr.20080806145258.24"><vh>@@file server.py</vh></v>
<v t="ekr.20080806145258.25"><vh>@@file hello.html</vh></v>
<v t="ekr.20080806145258.26"><vh>@@file cgi-bin/edward.py</vh>
<v t="ekr.20080806145702.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080806145258.27"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.28"><vh>escape</vh></v>
<v t="ekr.20080806145258.29"><vh>print_all</vh></v>
<v t="ekr.20080806145258.30"><vh>print_body</vh></v>
<v t="ekr.20080806145258.31"><vh>print_head</vh></v>
<v t="ekr.20080806145258.32"><vh>print_leo_dot_js</vh></v>
<v t="ekr.20080806145258.33"><vh>print_tree</vh></v>
</v>
<v t="ekr.20080806145258.1"><vh>@@thin cgi-bin/leo.js</vh></v>
<v t="ekr.20080806145258.34"><vh>@@thin jqueryTest.html</vh></v>
</v>
<v t="ekr.20070929062147"><vh>Prototype of networkx graph tools</vh>
<v t="ekr.20070929122956"><vh>Data trees</vh>
<v t="ekr.20070929114617"><vh>@graph-target</vh></v>
<v t="ekr.20070929072043"><vh>@networkx</vh>
<v t="ekr.20070929072506.1"><vh>@nodes</vh></v>
<v t="ekr.20070929072506"><vh>@edges</vh></v>
</v>
<v t="ekr.20070929070257"><vh>@graph</vh>
<v t="ekr.20070929070257.1"><vh>@node child1</vh>
<v t="ekr.20070929070632"><vh>@link ('ekr', '20070929070257', 2): @node child2</vh></v>
</v>
<v t="ekr.20070929070257.2"><vh>@node child2</vh>
<v t="ekr.20070929070632.1"><vh>@link ('ekr', '20070929070257', 1): @node child1</vh></v>
</v>
</v>
<v t="ekr.20070928095102"><vh>root-node</vh>
<v t="ekr.20070928095102.1"><vh>child1</vh></v>
<v t="ekr.20070928095102.2"><vh>child2</vh></v>
</v>
</v>
</v>
<v t="ekr.20070630142904"><vh>Prototype of pyrex</vh>
<v t="ekr.20070630142904.2"><vh>gcc build docs</vh></v>
<v t="ekr.20070630142904.3"><vh>pyrexc command-line options</vh></v>
<v t="ekr.20070630142904.4"><vh>@@file myModule.pyx</vh></v>
<v t="ekr.20070630142904.5"><vh>Make myModule.c</vh></v>
</v>
<v t="ekr.20090728090618.2837"><vh>pydiction-1.0</vh>
<v t="ekr.20090728090618.2846"><vh>pydiction.vim</vh></v>
<v t="ekr.20090728090618.2847"><vh>README.txt</vh></v>
<v t="ekr.20090728090618.2838"><vh>pydiction.py</vh>
<v t="ekr.20090728090618.2849"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20090728090618.2839"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="ekr.20090728090618.2848"><vh>&lt;&lt; process command line &gt;&gt;</vh></v>
<v t="ekr.20090728090618.2840"><vh>get_submodules</vh></v>
<v t="ekr.20090728090618.2841"><vh>write_dictionary</vh></v>
<v t="ekr.20090728090618.2842"><vh>my_import</vh></v>
<v t="ekr.20090728090618.2843"><vh>remove_duplicates</vh></v>
<v t="ekr.20090728090618.2844"><vh>get_yesno</vh></v>
<v t="ekr.20090728090618.2845"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20090630141519.1793"><vh>rClick proto script</vh></v>
<v t="ekr.20080503202744.3"><vh>Rope</vh></v>
<v t="ekr.20080811113441.2"><vh>Running body text as a windows script</vh>
<v t="ekr.20080807115344.1"><vh>Windows script</vh></v>
</v>
<v t="ekr.20071026102420.2"><vh>Screen capture with Wink</vh>
<v t="ekr.20070528111805"><vh>FrontWindowCapture.pyw</vh></v>
<v t="ekr.20070609085533"><vh>@@url c:\prog\wink\ChangeViewMenu.htm</vh></v>
</v>
<v t="ekr.20100516140428.2135"><vh>sha1 hashes</vh></v>
<v t="ekr.20091230081322.1919"><vh>unicode categories</vh></v>
<v t="ekr.20100521101729.2148"><vh>proto of template</vh></v>
</v>
<v t="ekr.20071105085941"><vh>Tests</vh>
<v t="ekr.20100203174233.2032"><vh>@@test paste-script</vh></v>
<v t="ekr.20100122125233.2053"><vh>@test zcpspm</vh></v>
<v t="ekr.20091230121016.1931"><vh>at-auto stuff</vh>
<v t="ekr.20090706044257.1784"><vh>@@auto ../../install</vh></v>
<v t="ekr.20091217210235.1866"><vh>@@auto-rst at-auto-rst-test.txt</vh>
<v t="ekr.20100110172917.1916"><vh>section 1</vh></v>
<v t="ekr.20100110172917.1917"><vh>section 2</vh></v>
</v>
<v t="ekr.20091229092257.1930"><vh>@@auto-rst ../doc/html/intro.html.txt</vh>
<v t="ekr.20100110172917.1918"><vh>@rst-no-head intro.html declarations</vh></v>
<v t="ekr.20100110172917.1919"><vh>Chapter 2: The Leo Tutorial</vh>
<v t="ekr.20100110172917.1920"><vh>Leo's main window</vh></v>
<v t="ekr.20100110172917.1921"><vh>Outline commands</vh></v>
<v t="ekr.20100110172917.1922"><vh>External files and @file nodes</vh></v>
<v t="ekr.20100110172917.1923"><vh>Creating external files from outlines</vh>
<v t="ekr.20100110172917.1924"><vh>Section references</vh></v>
<v t="ekr.20100110172917.1925"><vh>The @others directive</vh></v>
<v t="ekr.20100110172917.1926"><vh>The @all directive</vh></v>
<v t="ekr.20100110172917.1927"><vh>Choosing between @others and sections</vh></v>
<v t="ekr.20100110172917.1928"><vh>Organizing programs as outlines</vh></v>
</v>
<v t="ekr.20100110172917.1929"><vh>Clones &amp; views</vh></v>
<v t="ekr.20100110172917.1930"><vh>More about directives</vh></v>
<v t="ekr.20100110172917.1931"><vh>Scripting, extending and customizing Leo</vh></v>
<v t="ekr.20100110172917.1932"><vh>Summary</vh></v>
<v t="ekr.20100110172917.1933"><vh>Further study</vh></v>
</v>
</v>
<v t="ekr.20091229101227.1902"><vh>@@auto-rst quickstart.txt</vh>
<v t="ekr.20100110172917.1934"><vh>A ReStructuredText Primer</vh>
<v t="ekr.20100110172917.1935"><vh>Structure</vh></v>
<v t="ekr.20100110172917.1936"><vh>Text styles</vh></v>
<v t="ekr.20100110172917.1937"><vh>Lists</vh></v>
<v t="ekr.20100110172917.1938"><vh>Preformatting (code samples)</vh></v>
<v t="ekr.20100110172917.1939"><vh>Sections</vh>
<v t="ekr.20100110172917.1940"><vh>Document Title / Subtitle</vh></v>
</v>
<v t="ekr.20100110172917.1941"><vh>Images</vh></v>
<v t="ekr.20100110172917.1942"><vh>What Next?</vh></v>
</v>
</v>
<v t="ekr.20091230064146.1912"><vh>@@auto xml-tags-test.xml</vh>
<v t="ekr.20100110172917.1943"><vh>xml</vh></v>
<v t="ekr.20100110172917.1944"><vh>test.a</vh></v>
<v t="ekr.20100110172917.1945"><vh>test-b</vh></v>
</v>
<v t="ekr.20091230090645.1925"><vh>@@auto layout.html</vh>
<v t="ekr.20100110172917.1946"><vh>layout declarations</vh></v>
<v t="ekr.20100110172917.1947"><vh>html</vh>
<v t="ekr.20100110172917.1948"><vh>py:match</vh>
<v t="ekr.20100110172917.1949"><vh>head</vh>
<v t="ekr.20100110172917.1950"><vh>py:if</vh></v>
</v>
</v>
<v t="ekr.20100110172917.1951"><vh>py:match</vh>
<v t="ekr.20100110172917.1952"><vh>body</vh></v>
</v>
<v t="ekr.20100110172917.1953"><vh>py:match</vh></v>
<v t="ekr.20100110172917.1954"><vh>py:match</vh></v>
</v>
</v>
<v t="ekr.20091230160238.1922"><vh>@@auto-rst cheatsheet.txt</vh>
<v t="ekr.20100110172917.1955"><vh>The reStructuredText_ Cheat Sheet: Syntax Reminders</vh>
<v t="ekr.20100110172917.1956"><vh>Section Structure</vh></v>
<v t="ekr.20100110172917.1957"><vh>Body Elements</vh></v>
<v t="ekr.20100110172917.1958"><vh>Inline Markup</vh></v>
<v t="ekr.20100110172917.1959"><vh>Directive Quick Reference</vh></v>
<v t="ekr.20100110172917.1960"><vh>Interpreted Text Role Quick Reference</vh></v>
</v>
</v>
<v t="ekr.20100110151049.2004"><vh>@@auto-rst unicode-headline-test.txt</vh>
<v t="ekr.20100110172917.1961"><vh>section 1: Ę</vh></v>
</v>
</v>
<v t="ekr.20100205114630.2091"><vh>File tests</vh>
<v t="ekr.20100203233053.2033"><vh>@@thin at-path-in-body-test.py</vh></v>
<v t="ekr.20100204062222.2035"><vh>@@@auto C:\leo.repo\trunk\leo\extensions\Pmw\Pmw_1_3\lib</vh></v>
<v t="ekr.20100204082851.2038"><vh>@@auto test-PmwComboBox.py</vh>
<v t="ekr.20100204085631.2041"><vh>test-PmwComboBox declarations</vh></v>
<v t="ekr.20100204085631.2042"><vh>class ComboBox</vh>
<v t="ekr.20100204085631.2043"><vh>__init__</vh></v>
<v t="ekr.20100204085631.2044"><vh>destroy</vh></v>
<v t="ekr.20100204085631.2045"><vh>get</vh></v>
<v t="ekr.20100204085631.2046"><vh>invoke</vh></v>
<v t="ekr.20100204085631.2047"><vh>selectitem</vh></v>
<v t="ekr.20100204085631.2048"><vh>size</vh></v>
<v t="ekr.20100204085631.2049"><vh>bbox</vh></v>
<v t="ekr.20100204085631.2050"><vh>clear</vh></v>
<v t="ekr.20100204085631.2051"><vh>_addHistory</vh></v>
<v t="ekr.20100204085631.2052"><vh>_next</vh></v>
<v t="ekr.20100204085631.2053"><vh>_previous</vh></v>
<v t="ekr.20100204085631.2054"><vh>_selectCmd</vh></v>
<v t="ekr.20100204085631.2055"><vh>_drawArrow</vh></v>
<v t="ekr.20100204085631.2056"><vh>_postList</vh></v>
<v t="ekr.20100204085631.2057"><vh>_dropdownBtnRelease</vh></v>
<v t="ekr.20100204085631.2058"><vh>_unpostOnNextRelease</vh></v>
<v t="ekr.20100204085631.2059"><vh>_resizeArrow</vh></v>
<v t="ekr.20100204085631.2060"><vh>_unpostList</vh></v>
<v t="ekr.20100204085631.2061"><vh>_selectUnpost</vh></v>
</v>
</v>
<v t="ekr.20100204085410.2060"><vh>@@auto test-blank-lines.py</vh>
<v t="ekr.20100205114630.2089"><vh>test-blank-lines declarations</vh></v>
<v t="ekr.20100205114630.2090"><vh>class ComboBox</vh></v>
</v>
<v t="ekr.20100329100226.2108"><vh>@@auto-rst at-auto-test.txt</vh>
<v t="ekr.20100329100841.2109"><vh>Level 1</vh>
<v t="ekr.20100329100841.2110"><vh>Level 2</vh></v>
</v>
</v>
</v>
<v t="ekr.20080930114036.1"><vh>Icon stuff</vh>
<v t="ekr.20100824124015.2195"><vh>print icons</vh></v>
<v t="ekr.20080930080501.1"><vh>Add icon row</vh></v>
<v t="ekr.20080930083052.1"><vh>hide icon rows</vh></v>
<v t="ekr.20080930083052.2"><vh>show icon rows</vh></v>
<v t="ekr.20080930085514.1"><vh>clear icon bar</vh></v>
</v>
<v t="ekr.20100103112623.1951"><vh>Insert form-feed</vh></v>
<v t="ekr.20100119095726.2043"><vh>rest colorizing</vh></v>
<v t="ekr.20100130095415.2023"><vh>Simulate startup code for non-ascii directories</vh></v>
<v t="ekr.20080924081821.1"><vh>test of autoCompleter.getExternalCompletions (do not deletes)</vh></v>
<v t="ekr.20081003094737.1"><vh>Unicode tests</vh>
<v t="ekr.20080701101740.1"><vh>locale tests</vh></v>
<v t="ekr.20080821111715.1"><vh>Standard print test (only works for Latin-1 and ascii)</vh></v>
<v t="ekr.20090525090210.1940"><vh>Unicode characters: La Peña</vh></v>
<v t="ekr.20090617083033.1814"><vh>Test of copy/paste of unicode</vh>
<v t="ekr.20090617083033.1813"><vh>Unicode characters: La Peña תּ</vh></v>
</v>
<v t="ekr.20090618102458.1816"><vh>Converting QString to unicode</vh></v>
<v t="ekr.20100127122240.2063"><vh>Terry's unicode problem</vh></v>
<v t="ekr.20100202115249.2023"><vh>@@thin qttexttest.py</vh></v>
</v>
<v t="ekr.20090514103332.1929"><vh>Unit tests</vh>
<v t="ekr.20090218112656.1"><vh>@test self.assertEqual</vh></v>
<v t="ekr.20090514101216.1927"><vh>@test self.assertNotEqual</vh></v>
</v>
<v t="ekr.20100127111116.2059"><vh>wrapping</vh></v>
<v t="ekr.20100205074729.2085"><vh>Clone battle test</vh>
<v t="ekr.20100205074729.2086"><vh>node a</vh></v>
<v t="ekr.20100205074729.2087"><vh>@@thin clone-battle-test.txt</vh>
<v t="ekr.20100205074729.2086"></v>
</v>
</v>
<v t="ekr.20100330082345.2120"><vh>pseudoplain</vh></v>
<v t="ekr.20100911195503.2426"><vh>tests of os.path.relpath</vh></v>
<v t="ekr.20100526075442.2155"><vh>@@auto-rst c:\prog\graphs.rst</vh>
<v t="ekr.20100526092131.2157"><vh>DOT</vh>
<v t="ekr.20100526092131.2158"><vh>Examples from User guide</vh></v>
<v t="ekr.20100526092131.2159"><vh>Small graph</vh></v>
<v t="ekr.20100526092131.2160"><vh>Fancy graph</vh></v>
<v t="ekr.20100526092131.2161"><vh>Graph with polygonal shapes</vh></v>
<v t="ekr.20100526092131.2162"><vh>Records with nested fields</vh></v>
<v t="ekr.20100526092131.2163"><vh>HTML-like labels</vh></v>
<v t="ekr.20100526092131.2164"><vh>Graph with constrained ranks</vh></v>
</v>
<v t="ekr.20100526092131.2165"><vh>Server status</vh>
<v t="ekr.20100526092131.2166"><vh>dhcpd.conf</vh></v>
</v>
<v t="ekr.20100526092131.2167"><vh>networkx</vh>
<v t="ekr.20100526092131.2168"><vh>Tutorial</vh></v>
<v t="ekr.20100526092131.2169"><vh>Examples</vh>
<v t="ekr.20100526092131.2170"><vh>File hierarchy to graph</vh></v>
</v>
</v>
<v t="ekr.20100526092131.2171"><vh>pygraphviz</vh></v>
<v t="ekr.20100526092131.2172"><vh>Diagraming apt components</vh></v>
</v>
</v>
<v t="ekr.20101004104134.2347"><vh>Recent</vh>
<v t="ekr.20100821214143.2190"><vh>@@html Leo's home page</vh></v>
<v t="ekr.20120505111317.2735"><vh>Convert Leo outline to/from json</vh>
<v t="ekr.20120505111317.2736"><vh>to_json</vh></v>
<v t="ekr.20120505111317.2737"><vh>vnode_dict</vh></v>
</v>
<v t="ekr.20110127090822.2451"><vh>dump k.bindingsDict</vh></v>
<v t="ekr.20100907114225.2209"><vh>example leoremote client</vh></v>
<v t="ekr.20110416065515.2437"><vh>jinja2</vh></v>
<v t="ekr.20110525093203.2470"><vh>json stuff</vh>
<v t="ekr.20110414094917.2423"><vh>@json-outline</vh></v>
<v t="ekr.20110414094917.2424"><vh>@input-tree</vh>
<v t="ekr.20110414094917.2425"><vh>child1</vh>
<v t="ekr.20110414094917.2427"><vh>grandchild11</vh></v>
<v t="ekr.20110414094917.2428"><vh>grandchild12</vh></v>
</v>
<v t="ekr.20110414094917.2426"><vh>child2</vh>
<v t="ekr.20110414094917.2429"><vh>grandchild21</vh></v>
</v>
</v>
</v>
<v t="ekr.20100729114420.2152"><vh>plain fonts</vh></v>
<v t="ekr.20110325142419.2337"><vh>QCompleter example</vh>
<v t="ekr.20110325142419.2338"><vh>class DictionaryCompleter(QCompleter)</vh></v>
<v t="ekr.20110325142419.2339"><vh>class CompletionTextEdit(QTextEdit)</vh>
<v t="ekr.20110325142419.2340"><vh>ctor</vh></v>
<v t="ekr.20110325142419.2341"><vh>setCompleter</vh></v>
<v t="ekr.20110325142419.2342"><vh>insertCompletion</vh></v>
<v t="ekr.20110325142419.2343"><vh>textUnderCursor</vh></v>
<v t="ekr.20110325144059.2351"><vh>focusInEvent</vh></v>
<v t="ekr.20110325144059.2352"><vh>keyPressEvent</vh></v>
</v>
<v t="ekr.20110325144059.2350"><vh>main</vh></v>
</v>
<v t="ekr.20110511140347.2445"><vh>QTimer</vh></v>
<v t="ekr.20120426175039.2682"><vh>Socket test</vh>
<v t="ekr.20120426175039.2683"><vh>class Server</vh>
<v t="ekr.20120426175039.2684"><vh>__init__</vh></v>
<v t="ekr.20120426175039.2685"><vh>handle_accept</vh></v>
</v>
<v t="ekr.20120426175039.2686"><vh>class RequestHandler</vh></v>
</v>
<v t="ekr.20120311074029.2727"><vh>URL's</vh>
<v t="ekr.20120312075951.2740"><vh>@url file://{{c.openDirectory}}/../doc/LeoDocs.leo</vh></v>
<v t="ekr.20120311074029.2728"><vh>@url file://C:/prog/test.sh</vh></v>
<v t="ekr.20120311074029.2729"><vh>@url file://C:/prog</vh></v>
<v t="ekr.20120311074029.2730"><vh>@url http://writemonkey.com/index.php</vh></v>
<v t="ekr.20120311074029.2731"><vh>@url file://C:\leo.repo\trunk\leo\doc\LeoDocs.leo#Leo 4.10 Release notes</vh></v>
<v t="ekr.20120311074029.2732"><vh>@url file://../doc/LeoDocs.leo#Leo 4.10 Release notes</vh></v>
<v t="ekr.20120311074029.2733"><vh>@url #--&gt;Before 4.10 b1</vh></v>
<v t="ekr.20120311074029.2734"><vh>@url file://~/ekr.leo</vh></v>
<v t="ekr.20120311074029.2735"><vh>@url file://~/ekr.html</vh></v>
<v t="ekr.20120311074029.2736"><vh>@url file://c:/users/edreamleo/ekr.html</vh></v>
<v t="ekr.20120320072350.2731"><vh>@url ../doc/LeoDocs.leo#Leo 4.10 Release notes</vh></v>
</v>
<v t="ekr.20110320203616.2489"><vh>viewrendered examples</vh>
<v t="ekr.20110320203616.2491"><vh>rst test</vh></v>
<v t="ekr.20110320203616.2492"><vh>docstring test</vh></v>
<v t="ekr.20101014040509.2311"><vh>@movie Horse movie</vh></v>
<v t="ekr.20101014040509.2312"><vh>@movie Gayane Ballet</vh></v>
<v t="ekr.20110320203616.2493"><vh>@html Leo's home page</vh></v>
<v t="ekr.20110320203616.2497"><vh>@networkx my network</vh></v>
<v t="ekr.20110321010339.2496"><vh>@svg bubbles.svg</vh></v>
<v t="ekr.20110322101711.2507"><vh>@svg bubbles sources</vh></v>
<v t="ekr.20101014040509.2310"><vh>@image splash screen</vh></v>
<v t="ekr.20101014040509.2313"><vh>@url weather</vh></v>
<v t="ekr.20101014040509.2314"><vh>@url mail</vh></v>
<v t="ekr.20110321213439.2493"><vh>@graphics-script</vh></v>
</v>
<v t="ekr.20120925105035.3146"><vh>vpos probe</vh></v>
<v t="ekr.20120928085003.3150"><vh>Test g.error, g.warning, g.note</vh></v>
<v t="ekr.20120925073640.3143"><vh>&lt;&lt; docstring &gt;&gt; (scrolling test)</vh></v>
<v t="ekr.20121005071615.3175"><vh>test g.importFromPath</vh></v>
</v>
</v>
<v t="ekr.20120923110028.3131"><vh>Screencasts</vh>
<v t="ekr.20120914093811.2824"><vh>@command start next screencast @key=alt-9</vh></v>
<v t="ekr.20120914183137.2850"><vh>@screencast the parts of the screen</vh>
<v t="ekr.20120918123030.2960"><vh>Intro</vh></v>
<v t="ekr.20120915122112.2868"><vh>panes</vh>
<v t="ekr.20120914183137.2851"><vh>This is the tree pane</vh></v>
<v t="ekr.20120914183137.2853"><vh>This is the log pane</vh></v>
<v t="ekr.20120914183137.2855"><vh>This is the body pane</vh></v>
<v t="ekr.20120914183137.2856"><vh>The minibuffer</vh></v>
<v t="ekr.20120914183137.2857"><vh>The icon area</vh></v>
</v>
<v t="ekr.20120915122112.2873"><vh>icon box</vh></v>
<v t="ekr.20120915114713.2866"><vh>node icon</vh></v>
<v t="ekr.20120915112650.2864"><vh>dirty icon</vh></v>
<v t="ekr.20120915122112.2871"><vh>text icon</vh></v>
<v t="ekr.20120915122112.2869"><vh>marked icon</vh></v>
<v t="ekr.20120915122112.2870"><vh>clone icon</vh></v>
<v t="ekr.20120915122112.2872"><vh>full icon</vh></v>
<v t="ekr.20120915122112.2874"><vh>save command clears dirty bits</vh></v>
<v t="ekr.20120916063628.2922"><vh>quit</vh></v>
</v>
<v t="ekr.20120914093811.2825"><vh>@screencast common keys</vh>
<v t="ekr.20120914093811.2826"><vh>ctrl-i</vh></v>
<v t="ekr.20120915073533.2862"><vh>typing...</vh>
<v t="ekr.20120914174750.2853"><vh>Black border</vh></v>
<v t="ekr.20120914104624.2829"><vh>ctrl-h</vh></v>
<v t="ekr.20120914182320.2853"><vh>typing</vh></v>
<v t="ekr.20120914104624.2832"><vh>return</vh></v>
<v t="ekr.20120914104624.2833"><vh>tying in body</vh></v>
</v>
<v t="ekr.20120914104624.2834"><vh>another inserted node</vh></v>
<v t="ekr.20120914104624.2835"><vh>Ctrl-R</vh></v>
<v t="ekr.20120914104624.2836"><vh>Up</vh></v>
<v t="ekr.20120914104624.2837"><vh>Left</vh></v>
<v t="ekr.20120914104624.2838"><vh>Right</vh></v>
<v t="ekr.20120914174750.2850"><vh>That's all</vh></v>
<v t="ekr.20120914174750.2851"><vh>clean up and quit</vh></v>
</v>
<v t="ekr.20120915162554.2882"><vh>@screencast minibuffer</vh>
<v t="ekr.20120915162554.2883"><vh>mb intro</vh></v>
<v t="ekr.20120915164308.2886"><vh>mb typing</vh></v>
<v t="ekr.20120915170516.2888"><vh>mb tab </vh></v>
<v t="ekr.20120915173000.2894"><vh>mb no tab</vh></v>
<v t="ekr.20120917133405.2948"><vh>mb backspace</vh></v>
<v t="ekr.20120917133405.2950"><vh>mb backspace</vh></v>
<v t="ekr.20120917133405.2952"><vh>mb backspace</vh></v>
<v t="ekr.20120917133405.2953"><vh>mb e tab</vh></v>
<v t="ekr.20120917133405.2955"><vh>mb 6 backspaces</vh></v>
<v t="ekr.20120916185527.2922"><vh>mb o tab</vh></v>
<v t="ekr.20120915173000.2895"><vh>mb Return</vh></v>
<v t="ekr.20120915174321.2898"><vh>mb inserted node</vh></v>
<v t="ekr.20120915175727.2905"><vh>mb last slide</vh></v>
<v t="ekr.20120916065229.2914"><vh>mb quit</vh></v>
</v>
<v t="ekr.20120915181136.2907"><vh>@screencast Ctrl-F</vh>
<v t="ekr.20120916063628.2912"><vh>find intro</vh></v>
<v t="ekr.20120916065229.2916"><vh>Ctrl-F</vh></v>
<v t="ekr.20120916140331.2916"><vh>Return</vh></v>
<v t="ekr.20120916184840.2920"><vh>The search succeeds</vh></v>
<v t="ekr.20120916063628.2913"><vh>cleanup and quit</vh></v>
<v t="ekr.20120916184021.2918"><vh>spam</vh></v>
</v>
<v t="ekr.20120918103721.2944"><vh>@ignore-tree Text nodes</vh>
<v t="ekr.20120918144251.2965"><vh>@text Intro</vh></v>
<v t="ekr.20120918144251.2964"><vh>@text</vh></v>
<v t="ekr.20120918143835.2964"><vh>@text</vh></v>
<v t="ekr.20120918113531.2956"><vh>@text Intro</vh></v>
<v t="ekr.20120918113531.2957"><vh>@text Motivation</vh></v>
<v t="ekr.20120918111016.2955"><vh>@text How it works</vh></v>
<v t="ekr.20120918121401.2957"><vh>@text Showing nodes</vh></v>
</v>
<v t="ekr.20120921072549.3028"><vh>@screencast menus</vh>
<v t="ekr.20120922191243.3126"><vh>@ignore-node comments</vh></v>
<v t="ekr.20120922123519.3032"><vh>file</vh>
<v t="ekr.20120922123519.3037"><vh>openwith</vh></v>
<v t="ekr.20120922123519.3033"><vh>recentfiles</vh></v>
<v t="ekr.20120922123519.3034"><vh>read/write</vh></v>
<v t="ekr.20120922123519.3035"><vh>export</vh></v>
</v>
<v t="ekr.20120922123519.3038"><vh>edit</vh>
<v t="ekr.20120922123519.3039"><vh>edit-body</vh></v>
<v t="ekr.20120922123519.3040"><vh>edit-headline</vh></v>
<v t="ekr.20120922123519.3041"><vh>find</vh></v>
</v>
<v t="ekr.20120922124750.3050"><vh>outline</vh>
<v t="ekr.20120922124750.3051"><vh>check</vh></v>
<v t="ekr.20120922124750.3052"><vh>expand/contract</vh></v>
<v t="ekr.20120922124750.3053"><vh>move</vh></v>
<v t="ekr.20120922124750.3054"><vh>mark</vh></v>
<v t="ekr.20120922124750.3055"><vh>goto</vh></v>
</v>
<v t="ekr.20120922124750.3058"><vh>plugins</vh>
<v t="ekr.20120922124750.3059"><vh>core</vh></v>
</v>
<v t="ekr.20120922124750.3057"><vh>cmds</vh>
<v t="ekr.20120922124750.3063"><vh>abbrev</vh></v>
<v t="ekr.20120922124750.3064"><vh>bodyeditors</vh></v>
<v t="ekr.20120922124750.3065"><vh>buffers</vh></v>
<v t="ekr.20120922124750.3066"><vh>chapters</vh></v>
<v t="ekr.20120922124750.3067"><vh>cursorselection</vh>
<v t="ekr.20120922124750.3068"><vh>cursorback</vh></v>
<v t="ekr.20120922124750.3069"><vh>cursorbackextendselection</vh></v>
<v t="ekr.20120922124750.3070"><vh>cursorbackextendto</vh></v>
<v t="ekr.20120922124750.3071"><vh>cursorforward</vh></v>
<v t="ekr.20120922124750.3072"><vh>cursorforwardextendselection</vh></v>
</v>
<v t="ekr.20120922124750.3073"><vh>debugging</vh></v>
<v t="ekr.20120922124750.3074"><vh>filesanddirectories</vh></v>
<v t="ekr.20120922124750.3075"><vh>focus</vh></v>
<v t="ekr.20120922124750.3076"><vh>icons</vh></v>
<v t="ekr.20120922124750.3077"><vh>macros</vh></v>
<v t="ekr.20120922124750.3078"><vh>minibuffer</vh></v>
<v t="ekr.20120922124750.3079"><vh>pickers</vh></v>
<v t="ekr.20120922124750.3080"><vh>rectangles</vh></v>
<v t="ekr.20120922124750.3081"><vh>registers</vh></v>
<v t="ekr.20120922124750.3082"><vh>rstcommands</vh></v>
<v t="ekr.20120922124750.3084"><vh>runscripttests</vh></v>
<v t="ekr.20120922124750.3085"><vh>scrolling</vh></v>
<v t="ekr.20120922124750.3086"><vh>shell</vh></v>
<v t="ekr.20120922124750.3087"><vh>spellcheck</vh></v>
<v t="ekr.20120922124750.3088"><vh>textcommands</vh></v>
<v t="ekr.20120922124750.3089"><vh>togglesettings</vh></v>
<v t="ekr.20120922124750.3090"><vh>yankandkill</vh></v>
</v>
<v t="ekr.20120922124750.3060"><vh>window</vh></v>
<v t="ekr.20120922124750.3061"><vh>help</vh>
<v t="ekr.20120922124750.3062"><vh>helpcommands</vh></v>
</v>
</v>
<v t="ekr.20120917200834.2928"><vh>@screencast How to make screencasts</vh>
<v t="ekr.20120918170946.2994"><vh>Intro</vh>
<v t="ekr.20120918164428.2968"><vh>Nodes</vh></v>
<v t="ekr.20120918170133.2973"><vh>Scripts</vh></v>
<v t="ekr.20120918170946.2976"><vh>Most nodes are hiddeen</vh></v>
<v t="ekr.20120918170133.2974"><vh>Show nodes</vh></v>
</v>
<v t="ekr.20120918174346.3024"><vh>The program counter</vh>
<v t="ekr.20120918170133.2975"><vh>m.p</vh></v>
<v t="ekr.20120918170946.2979"><vh>m.p 2</vh></v>
</v>
<v t="ekr.20120918174346.3026"><vh>Organizing nodes</vh>
<v t="ekr.20120918174346.3018"><vh>organizing screencasts</vh></v>
<v t="ekr.20120918174346.3019"><vh>empty nodes</vh></v>
<v t="ekr.20120918174346.3020"><vh>ignored nodes</vh></v>
<v t="ekr.20120918174346.3021"><vh>example @ignore-node</vh>
<v t="ekr.20120918174346.3022"><vh>@ignore-node whatever</vh></v>
</v>
<v t="ekr.20120918174346.3027"><vh>ignored trees</vh></v>
</v>
<v t="ekr.20120918174346.3025"><vh>m methods</vh>
<v t="ekr.20120918170946.2989"><vh>m.redraw</vh></v>
<v t="ekr.20120918170946.2990"><vh>m.redraw 2</vh></v>
<v t="ekr.20120918170946.2991"><vh>m.redraw 3</vh></v>
<v t="ekr.20120918174346.3028"><vh>captions</vh>
<v t="ekr.20120918170946.2981"><vh>m.log</vh></v>
<v t="ekr.20120918170946.2982"><vh>m.caption</vh></v>
<v t="ekr.20120918170946.2986"><vh>m.body</vh></v>
<v t="ekr.20120918170946.2987"><vh>m.body 2</vh></v>
<v t="ekr.20120918170946.2983"><vh>m.tree</vh></v>
<v t="ekr.20120918170946.2984"><vh>m.tree 2</vh></v>
</v>
<v t="ekr.20120918174346.3029"><vh>images</vh>
<v t="ekr.20120918170946.2992"><vh>m.image</vh></v>
<v t="ekr.20120918170946.2993"><vh>m.image 2</vh></v>
</v>
<v t="ekr.20120918170946.2997"><vh>key handling</vh>
<v t="ekr.20120918170946.2998"><vh>m.head_keys</vh></v>
<v t="ekr.20120918170946.2999"><vh>m.head_keys 2</vh></v>
<v t="ekr.20120918170946.3000"><vh>restore previous headline</vh></v>
<v t="ekr.20120918174346.3014"><vh>m.body_keys</vh></v>
<v t="ekr.20120918174346.3015"><vh>m.body_keys_ 2</vh>
<v t="ekr.20120918174346.3016"><vh>@ignore-node child</vh></v>
</v>
</v>
</v>
<v t="ekr.20120918174346.3023"><vh>more normal examples</vh></v>
<v t="ekr.20120918115916.2954"><vh>m.quit</vh></v>
<v t="ekr.20120918103721.2948"><vh>quit</vh></v>
</v>
</v>
<v t="ekr.20120913105857.2914"><vh>@screencast Tutorial</vh>
<v t="ekr.20120923110028.3133"><vh>@ignore-tree completed @text nodes</vh>
<v t="ekr.20120913105857.2915"><vh>@text Welcome to Leo!</vh></v>
</v>
<v t="ekr.20120923063534.3130"><vh>Intro</vh></v>
<v t="ekr.20120923115619.3155"><vh>@ignore-tree not yet</vh>
<v t="ekr.20120913105857.2918"><vh>External files</vh>
<v t="ekr.20120913105857.2919"><vh>Thin nodes (explanation &amp; exercise)</vh>
<v t="ekr.20120913105857.2920"><vh>@path ~</vh>
<v t="ekr.20120913105857.2921"><vh>@@thin myfile_thin.py</vh>
<v t="ekr.20120913105857.2922"><vh>imports &amp; setup routines</vh>
<v t="ekr.20120913105857.2923"><vh>imports</vh></v>
<v t="ekr.20120913105857.2924"><vh>init1, init2</vh></v>
</v>
<v t="ekr.20120913105857.2925"><vh>class Foo</vh>
<v t="ekr.20120913105857.2926"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20120913105857.2927"><vh>spam</vh></v>
<v t="ekr.20120913105857.2928"><vh>eggs</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20120913105857.2929"><vh>Auto nodes</vh>
<v t="ekr.20120913105857.2930"><vh>@path ~</vh>
<v t="ekr.20120913105857.2931"><vh>@@auto myfile_auto.py</vh>
<v t="ekr.20120913105857.2932"><vh>imports &amp; setup routines</vh>
<v t="ekr.20120913105857.2933"><vh>imports</vh></v>
<v t="ekr.20120913105857.2934"><vh>init1, init2</vh></v>
</v>
<v t="ekr.20120913105857.2935"><vh>class Foo</vh>
<v t="ekr.20120913105857.2936"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20120913105857.2937"><vh>spam</vh></v>
<v t="ekr.20120913105857.2938"><vh>eggs</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20120913105857.2939"><vh>Shadow nodes</vh>
<v t="ekr.20120913105857.2940"><vh>@path ~</vh>
<v t="ekr.20120913105857.2941"><vh>@@shadow myfile_shadow.py</vh>
<v t="ekr.20120913105857.2942"><vh>imports &amp; setup routines</vh>
<v t="ekr.20120913105857.2943"><vh>imports</vh></v>
<v t="ekr.20120913105857.2944"><vh>init1, init2</vh></v>
</v>
<v t="ekr.20120913105857.2945"><vh>class Foo</vh>
<v t="ekr.20120913105857.2946"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20120913105857.2947"><vh>spam</vh></v>
<v t="ekr.20120913105857.2948"><vh>eggs</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20120913105857.2949"><vh>reStructuredText (@auto-rst)</vh>
<v t="ekr.20120913105857.2950"><vh>@path ~</vh>
<v t="ekr.20120913105857.2951"><vh>@@auto-rst myfile_rst.txt</vh>
<v t="ekr.20120913105857.2952"><vh>Main heading</vh>
<v t="ekr.20120913105857.2953"><vh>subheading 1</vh></v>
<v t="ekr.20120913105857.2954"><vh>subheading 2</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20120913105857.2955"><vh>Configuration (enabling plugins etc.)</vh>
<v t="ekr.20120913105857.2956"><vh>Find out your ~/.leo directory (script)</vh></v>
<v t="ekr.20120913105857.2957"><vh>@@settings</vh>
<v t="ekr.20120913105857.2958"><vh>@enabled-plugins</vh></v>
<v t="ekr.20120913105857.2959"><vh>@@string initial_split_orientation = horizontal</vh></v>
<v t="ekr.20120913105857.2960"><vh>suggested style sheets</vh>
<v t="ekr.20120913105857.2961"><vh>default look (Linux)</vh>
<v t="ekr.20120913105857.2962"><vh>@@data qt-gui-plugin-style-sheet</vh></v>
</v>
<v t="ekr.20120913105857.2963"><vh>A mac look</vh>
<v t="ekr.20120913105857.2964"><vh>@@data qt-gui-plugin-style-sheet</vh></v>
</v>
</v>
<v t="ekr.20120913105857.2965"><vh>@int qt_max_colorized_chars = 200000</vh></v>
<v t="ekr.20120913105857.2966"><vh>@data contextmenu_commands</vh></v>
<v t="ekr.20120913105857.2967"><vh>@bool use_body_focus_border = False</vh></v>
</v>
</v>
<v t="ekr.20120913105857.2968"><vh>Search and replace</vh></v>
<v t="ekr.20120913105857.2969"><vh>Minibuffer</vh></v>
<v t="ekr.20120913105857.2970"><vh>Scripting Leo</vh>
<v t="ekr.20120913105857.2971"><vh>Executing scripts with ctrl+b</vh>
<v t="ekr.20120913105857.2972"><vh>Press ctrl+b here</vh></v>
</v>
<v t="ekr.20120913105857.2973"><vh>Creating script buttons</vh>
<v t="ekr.20120913105857.2974"><vh>@button example-btn</vh></v>
</v>
</v>
</v>
<v t="ekr.20120923110028.3132"><vh>Last slide</vh></v>
<v t="ekr.20120923110028.3136"><vh>Example Tree</vh>
<v t="ekr.20120923110028.3137"><vh>Example outline</vh>
<v t="ekr.20120923110028.3138"><vh>Node b</vh></v>
</v>
</v>
</v>
<v t="ekr.20121008164702.3281"><vh>Prototype of ipynb import</vh>
<v t="ekr.20121008164702.3282"><vh>@button cvt ipynb @key=Alt-7</vh>
<v t="ekr.20121008164702.3283"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
<v t="ekr.20121008164702.3284"><vh>class IpynbReader</vh>
<v t="ekr.20121008164702.3285"><vh>ctor</vh></v>
<v t="ekr.20121008164702.3286"><vh>do_cell</vh></v>
<v t="ekr.20121008164702.3287"><vh>do_worksheet</vh></v>
<v t="ekr.20121008164702.3288"><vh>get_node</vh></v>
<v t="ekr.20121008164702.3289"><vh>parse</vh></v>
</v>
</v>
<v t="ekr.20121008164702.3290"><vh>ipynb tree</vh>
<v t="ekr.20121008164702.3291"><vh>worksheet 1</vh>
<v t="ekr.20121008164702.3292"><vh>Part 2: Dataset Basics and Concepts</vh>
<v t="ekr.20121008164702.3293"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3294"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3295"><vh>code</vh></v>
<v t="ekr.20121008164702.3296"><vh>code</vh></v>
<v t="ekr.20121008164702.3297"><vh>code</vh></v>
<v t="ekr.20121008164702.3298"><vh>code</vh></v>
<v t="ekr.20121008164702.3299"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3300"><vh>code</vh></v>
<v t="ekr.20121008164702.3301"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3302"><vh>code</vh></v>
<v t="ekr.20121008164702.3303"><vh>code</vh></v>
<v t="ekr.20121008164702.3304"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3305"><vh>Attributes</vh>
<v t="ekr.20121008164702.3306"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3307"><vh>For Samples</vh>
<v t="ekr.20121008164702.3308"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3309"><vh>code</vh></v>
<v t="ekr.20121008164702.3310"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3311"><vh>code</vh></v>
<v t="ekr.20121008164702.3312"><vh>code</vh></v>
<v t="ekr.20121008164702.3313"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3314"><vh>code</vh></v>
<v t="ekr.20121008164702.3315"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3316"><vh>code</vh></v>
<v t="ekr.20121008164702.3317"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3318"><vh>code</vh></v>
<v t="ekr.20121008164702.3319"><vh>code</vh></v>
<v t="ekr.20121008164702.3320"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3321"><vh>code</vh></v>
<v t="ekr.20121008164702.3322"><vh>code</vh></v>
</v>
<v t="ekr.20121008164702.3323"><vh>For Features</vh>
<v t="ekr.20121008164702.3324"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3325"><vh>code</vh></v>
<v t="ekr.20121008164702.3326"><vh>code</vh></v>
</v>
<v t="ekr.20121008164702.3327"><vh>For The Dataset</vh>
<v t="ekr.20121008164702.3328"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3329"><vh>code</vh></v>
</v>
</v>
<v t="ekr.20121008164702.3330"><vh>Slicing, resampling, feature selection</vh>
<v t="ekr.20121008164702.3331"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3332"><vh>code</vh></v>
<v t="ekr.20121008164702.3333"><vh>code</vh></v>
<v t="ekr.20121008164702.3334"><vh>code</vh></v>
<v t="ekr.20121008164702.3335"><vh>code</vh></v>
<v t="ekr.20121008164702.3336"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3337"><vh>code</vh></v>
<v t="ekr.20121008164702.3338"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3339"><vh>code</vh></v>
<v t="ekr.20121008164702.3340"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3341"><vh>code</vh></v>
<v t="ekr.20121008164702.3342"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3343"><vh>code</vh></v>
<v t="ekr.20121008164702.3344"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3345"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3346"><vh>code</vh></v>
<v t="ekr.20121008164702.3347"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3348"><vh>code</vh></v>
<v t="ekr.20121008164702.3349"><vh>code</vh></v>
<v t="ekr.20121008164702.3350"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3351"><vh>code</vh></v>
<v t="ekr.20121008164702.3352"><vh>code</vh></v>
<v t="ekr.20121008164702.3353"><vh>markdown</vh></v>
</v>
<v t="ekr.20121008164702.3354"><vh>Loading fMRI data</vh>
<v t="ekr.20121008164702.3355"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3356"><vh>code</vh></v>
<v t="ekr.20121008164702.3357"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3358"><vh>code</vh></v>
<v t="ekr.20121008164702.3359"><vh>code</vh></v>
<v t="ekr.20121008164702.3360"><vh>code</vh></v>
<v t="ekr.20121008164702.3361"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3362"><vh>code</vh></v>
<v t="ekr.20121008164702.3363"><vh>code</vh></v>
<v t="ekr.20121008164702.3364"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3365"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3366"><vh>code</vh></v>
<v t="ekr.20121008164702.3367"><vh>code</vh></v>
<v t="ekr.20121008164702.3368"><vh>code</vh></v>
<v t="ekr.20121008164702.3369"><vh>code</vh></v>
<v t="ekr.20121008164702.3370"><vh>code</vh></v>
<v t="ekr.20121008164702.3371"><vh>code</vh></v>
<v t="ekr.20121008164702.3372"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3373"><vh>code</vh></v>
<v t="ekr.20121008164702.3374"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3375"><vh>code</vh></v>
<v t="ekr.20121008164702.3376"><vh>markdown</vh></v>
</v>
<v t="ekr.20121008164702.3377"><vh>Storage</vh>
<v t="ekr.20121008164702.3378"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3379"><vh>code</vh></v>
<v t="ekr.20121008164702.3380"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3381"><vh>code</vh></v>
<v t="ekr.20121008164702.3382"><vh>markdown</vh></v>
<v t="ekr.20121008164702.3383"><vh>code</vh></v>
<v t="ekr.20121008164702.3384"><vh>code</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20121011100948.4582"></v>
<v t="ekr.20121011195530.3405"><vh>pyv8</vh></v>
</vnodes>
<tnodes>
<t tx="edward.20081127113749.10">def undo_replacement(self):
    u = self.c.undoer; c=self.c; p=u.p
    bunch = u.getBead(u.bead)
    c.setBodyString(p, bunch.oldBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.11">def redo_replacement(self):
    c = self.c; u=c.undoer; bunch=u.getBead(u.bead+1)
    c.setBodyString(bunch.p, bunch.newBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.12">def exit(self):
    #g.app.config.set(c,word_completer_key,'WordCompleter',None)
    #g.app.config.set(c,'next_word_completer','WordCompleter',None)
    self.pos = -1</t>
<t tx="edward.20081127113749.13">def run(self):
    self.adjust(self.p, c.frame.body.getInsertPoint())
    self.complete_word()
</t>
<t tx="edward.20081127113749.14">def adjust(self, p, pos):
    if p != self.p or pos != self.pos:
        self.p = p.copy()
        self.pos = pos
        bs = p.bodyString()
        word = getCurrentWord(bs, pos)
        self.word = word
        self.before = bs[:pos-len(word)]
        self.after = bs[pos:]
        self.search_pos = p.copy()
        if self.back:
            self.chunk = self.before
        else:
            self.chunk = self.after
        self.tried = {word:1}</t>
<t tx="edward.20081127113749.15">def getCurrentWord(s, pos):
    i = pos-1
    while i&gt;=0 and wordsep.find(s[i]) &lt; 0:
         i -= 1
    return s[i+1:pos]</t>
<t tx="edward.20081127113749.16">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'next_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p, c, back=False)
    g.app.config.set(c, word_completer_key, 'WordCompleter', completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()

</t>
<t tx="edward.20081127113749.2">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'back_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p,c,back=True)
    g.app.config.set(c,word_completer_key,'WordCompleter',completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()
</t>
<t tx="edward.20081127113749.3">class WordCompleter:
    def __init__(self, p, c, back=True):
        self.p = p.copy()
        self.c = c
        self.back = back
        self.pos = -1
    @others
</t>
<t tx="edward.20081127113749.4">def complete_word(self):
    txt = self.chunk
    word = self.word
    try:
        if self.back:
            &lt;&lt;backward search&gt;&gt;
        else:
            &lt;&lt;forward search&gt;&gt;
        &lt;&lt;clean up and exit&gt;&gt;
    except:
        self.exit()
        g.es_exception()</t>
<t tx="edward.20081127113749.5">p = self.search_pos
start = -1
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.rfind(word, 0, start)
    if i == -1:
        p.moveToThreadBack()
        if p:self.chunk = txt = p.bodyString()
        start = -1
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[:i+len(word)-1]
            return
        start = i+len(word)-1</t>
<t tx="edward.20081127113749.6">counter+=1
if counter &gt; 10000:
    g.es_trace("counter max")
    break</t>
<t tx="edward.20081127113749.7">p = self.search_pos
start = 0
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.find(word, start)
    if i == -1:
        p.moveToThreadNext()
        if p:self.chunk = txt = p.bodyString()
        start = 0
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[i+1:]
            return
        start = i+1</t>
<t tx="edward.20081127113749.8">if len(self.tried) &gt; 1:
    # there was some tries so we need to restore
    self.c.setBodyString(self.p, self.before+self.word+self.after)
    self.c.frame.body.setInsertPoint(self.pos)
return self.exit()</t>
<t tx="edward.20081127113749.9">@ if found word for the first time then try it
@c
def acceptable_word(self, i, txt, word):
    if i == 0 or wordsep.find(txt[i-1]) != -1:
        j = i+len(word)
        while j &lt; len(txt) and wordsep.find(txt[j]) &lt; 0:
            j += 1
        nword = txt[i:j]
        if nword not in self.tried:
            self.tried[nword] = 1
            u = self.c.undoer
            bunch = u.createCommonBunch(p)
            bunch.oldBody = p.bodyString()
            bunch.insertPos = self.pos
            # Set the type &amp; helpers.
            bunch.kind = 'node'
            bunch.undoType = 'complete word'
            bunch.undoHelper = self.undo_replacement
            bunch.redoHelper = self.redo_replacement
            bunch.newBody = newBody = self.before+nword+self.after

            self.c.setBodyString(self.p, newBody)
            self.c.frame.body.setInsertPoint(self.pos)

            bunch.dirtyVnodeList = [p.v]
            bunch.newChanged = u.c.isChanged()
            bunch.newDirty = p.isDirty()
            bunch.newMarked = p.isMarked()

            u.pushBead(bunch)

            return True
    return False
</t>
<t tx="edward.20081221145716.1">def debug(f,*args,**keys):
    if 1:
        def debugCallback(*args,**keys):
            print f.__name__,args,keys
            f(*args,**keys)
            print 'after',f.__name__
        return debugCallback
    else:
        print 'in debug'
        return f
@debug
def spam(a=5):
    g.trace(a,g.callers(4))

spam(3)
spam(a=4)
</t>
<t tx="ekr.20041001211817">import os

g.pr(os.path.exists(os.path.normpath("C:\\Progra~1\\Eclipse")))</t>
<t tx="ekr.20060904110922"></t>
<t tx="ekr.20060904111037">if hasattr(c,'opmlCommands'):
    c.opmlCommands.readOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060904111037.1">if hasattr(c,'opmlCommands'):
    c.opmlCommands.writeOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060924180049">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060924180049.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060924180049.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060924180049.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060924180049.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060924180049.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060924180049.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20061030041200">import os, sys

if 1: # Executes Iron Python in the console. (But not from the tutorials directory).
    path = r'c:\prog\IronPython-1.0.1\ipy.exe'
    args = ['-i']
        
    if 1: # Use present environment.
        os.spawnv(os.P_NOWAIT, path, args)
    else: # Use a pristine environment.
        os.spawnve(os.P_NOWAIT, path, args, os.environ)</t>
<t tx="ekr.20070115092430"># Invoke winpdb for general scripts **not** containing the predefined g, p or d constants.

# This is essentially the same as using the debug command.

import os,subprocess,sys

# Important: scriptFile2 must be different from scriptFile.
filename = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile2'))
f = open(filename,'w') 
f.write(p.bodyString()) 
f.close() 
python = sys.executable
pythonDir = g.os_path_dirname(python) 
#winpdb = g.os_path_join(pythonDir,'Scripts','_winpdb.py') # For older versions of winpdb.
winpdb = g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py') # For version 1.1.2 and newer.
os.chdir(g.app.loadDir)
cmdline = '%s %s -t %s' % (python,winpdb,filename) 
subprocess.Popen(cmdline)
</t>
<t tx="ekr.20070224123943"></t>
<t tx="ekr.20070410063214"></t>
<t tx="ekr.20070416075121" str_leo_pos="7"></t>
<t tx="ekr.20070503085527"></t>
<t tx="ekr.20070517070854">import leoGui
oldGui = g.app.gui
g.app.gui = leoGui.nullGui(guiName='testGui')
try:
    fileName = g.os_path_abspath(g.os_path_join(
        g.app.loadDir,'..','doc','LeoDocs.leo'))
    ok,frame = g.openWithFileName(fileName,old_c=c)
    if ok:
        c2 = frame.c
        for p in c2.allNodes_iter():
            g.pr('.'*p.level(),p.headString())
        g.app.closeLeoWindow(frame)
finally:
    g.app.gui = oldGui</t>
<t tx="ekr.20070517071510">import leoBridge

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','doc','LeoDocs.leo'))

if 0: # This can not be run locally: leoBridge.controller starts a Tk event loop.

    controller = leoBridge.controller(gui='nullGui')
    g = controller.globals()
    c = controller.openLeoFile(path)
    n = 0
    for p in c.allNodes_iter():
        n += 1
    g.pr('%d nodes in %s' % (n,path))
    # g.app.closeLeoWindow(c.frame)</t>
<t tx="ekr.20070517160058.1">@language python
</t>
<t tx="ekr.20070528111805"># FrontWindowCapture.pyw
# Version 0.1
# Date    20070526
# Author  Roger Erens (roger AT erens-krekels.net)
"""
        Purpose:
        Capture the image of the front-most window into a fixed-name
        (_front_window), max-size (default MAX_WIDTH is 640 pixels), and
        fixed-format (PNG) file that can easily be used when creating
        documentation for an application on a wiki or in some HTML-docs.
        This script does _not_ copy the captured image to the clipboard (handy
        when creating MS Word or OpenOffice documents) since MS Windows already
        has ALT-PRTSCR to do so.

        Dependencies:
        Fairly recent versions of Python, wxPython, and PIL should be installed

        Start:
        Double click FrontWindowCapture.pyw; an icon appears in the Task Bar (lower right of
        the screen).

        Use:
        Bring a window to the front and then left-click on the
        icon in the Task Bar. A file named '_front_window.png' will be saved
        in the current directory.
        A pictures wider than MAXWIDTH is scaled down in order to make it easily
        used in wikis or HTML-documentation.
        Usually, human intelligence is needed to rename that file; this is also
        why this script does not copy the image to the clipboard.

        End:
        Close the application by right-clicking the icon in the Task Bar.

        Note:
        Make sure that your system is fast enough to find the frontmost
        window. That is, when a virusscanner is running or virtual memory is
        low, this script will choke. You can see what happens by enabling the
        print statements and running this script from a console (change the
        extension from .pyw to .py).
"""
import wx
import sys
import win32ui
import win32gui
import win32con
import time
from PIL import Image, ImageGrab

Image.init()

MAX_WIDTH = 640
BLINK_STATE = 0

class TaskBarApp(wx.Frame):
    def __init__(self, parent, id, title):
        wx.Frame.__init__(self, parent, -1, title, size = (1, 1),
            style=wx.FRAME_NO_TASKBAR| wx.NO_FULL_REPAINT_ON_RESIZE)
        self.tbicon = wx.TaskBarIcon()
        icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
        self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
        self.tbicon.Bind(wx.EVT_TASKBAR_LEFT_UP, self.OnTaskBarLeftClick)
        self.tbicon.Bind(wx.EVT_TASKBAR_RIGHT_UP, self.OnTaskBarRightClick)
        self.Show(True)

    def OnTaskBarLeftClick(self, evt):

        self.FlashIcon(evt)

        def _MyCallback(hwnd, extra ):
            extra.append(hwnd)

        windows = []
        win32gui.EnumWindows(_MyCallback, windows)

        winList = []
        for i in windows:
            if win32gui.IsWindowVisible(i):
                winList.append(i)
                #g.pr(i)

        win32gui.SetForegroundWindow(winList[1])    # found by trial and error
                                                    # that I need the second
                                                    # window from the list
        time.sleep(0.1)  # give the previous command some time to finish

        fgwindow = win32ui.GetForegroundWindow()
        #g.pr("(C)lick!")

        bbox = fgwindow.GetWindowRect()
        img = ImageGrab.grab( bbox)
        width = bbox[2] - bbox[0]
        if width &gt; MAX_WIDTH:
            coeff = MAX_WIDTH * 1. / width
            height = bbox[3] - bbox[1]
            newHeight = int( coeff * height)
            #g.pr(width, height, "scaled down to", MAX_WIDTH, newHeight)
            img = img.resize((MAX_WIDTH,newHeight), Image.ANTIALIAS)
        img = img.convert("P", dither=Image.NONE,
                              palette=Image.ADAPTIVE, colors=256)
        img.save("_front_window.png", "PNG", optimize=1)
        #img.show() # show the image in an image viewer

        self.FlashIcon(evt)

    def OnTaskBarRightClick(self, evt):
        #g.pr("Auta..." # that's about it...)
        self.tbicon.Destroy()
        self.Close(True)
        wx.GetApp().ProcessIdle()

    def FlashIcon(self, evt):
        global BLINK_STATE
        if BLINK_STATE == 0:
            icon = wx.Icon('LeoApp16lick.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Window is being captured...')
            BLINK_STATE = 1
            return
        else:
            icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
            BLINK_STATE = 0
            return

class MyApp(wx.App):
    def OnInit(self):
        frame = TaskBarApp(None, -1, ' ')
        frame.Center(wx.BOTH)
        frame.Show(False)
        return True

def main():
    app = MyApp(0)
    app.MainLoop()

if __name__ == '__main__':
    main()

""" CREDITS

    Thanks to
    Roger Upole:
    http://groups.google.com/group/comp.lang.python/
    browse_thread/thread/ff39ec79f7c3248a/
    e600c892772bf52a?lnk=gst&amp;q=screen+capture&amp;rnum=6#e600c892772bf52a
    for his time.sleep() Aha (This took me a year and a half to note!)

    Christian Wyglendowski, Werner Bruhin, and Xavier Morel for the
    http://wiki.wxpython.org/index.cgi/FlashingTaskbarIcon
    discussion

    'Rob aspn at msolutionsinc.com '
    http://mail.python.org/pipermail/python-win32/2003-June/001129.html
    for his suggestion to find out the foremost window

    and of course the usual suspects that created/maintain
    wxPython,
    PIL,
    pywin32,
    LEO,
    gvim,
    and Python itself.
"""</t>
<t tx="ekr.20070531102813"></t>
<t tx="ekr.20070604100125"></t>
<t tx="ekr.20070609085533"></t>
<t tx="ekr.20070630142904"></t>
<t tx="ekr.20070630142904.2">@nocolor

To build your module using GCC is a three step process on Unix:

1. Use Pyrex to translate mymodule.pyx to mymodule.c::

    python pyrexc mymodule.pyx

mymodule.pyx is the name of the Pyrex module you are writing.

2. Compile mymodule.c to mymodule.o::

    gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c

-c  Produces a .o file instead of an executable. 
-fPIC Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ is the location of the Python 2.2 include file.
 The location of your Python include file may differ from /usr/include/python2.2/. 

3 Link the mymodule.o into a mymodule.so::
    
    gcc -shared mymodule.o -lxosd -o mymodule.so

-shared produces a shared-object file, instead of an executable. 
-lxosd links against a C-library, with the name of the library given as the argument. 
</t>
<t tx="ekr.20070630142904.3">@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  ----- ----              --------    -----------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     &lt;directory&gt; Search for include files in named 
                                      directory (may be repeated)
  -o    --output-file     &lt;filename&gt;  Specify name of generated C file (only
                                      one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
</t>
<t tx="ekr.20070630142904.4">def spam(int i, char *s):
    if 1:
        g.pr(i,s)</t>
<t tx="ekr.20070630142904.5"># Use pyrexc to create myModule.c from myModule.pyx.

import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.6.4\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

# Use pyrex/Demos/setup.py to create module on Linux.</t>
<t tx="ekr.20070723091227">
        
        
        </t>
<t tx="ekr.20070723091227.1"></t>
<t tx="ekr.20070723091227.2"></t>
<t tx="ekr.20070723091227.3"></t>
<t tx="ekr.20070927175908">'''Convert a normal Leo tree to a networkx graph'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (id(p.v.t),p.headString())

def addTree(p):
    x.add_node(node_id(p))
    for child in p.children_iter():
        addTree(child)
        x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070928095102">@ This is a plain Leo tree.

You can convert it to a networkx graph using the leo2graph button.
</t>
<t tx="ekr.20070928095102.1"></t>
<t tx="ekr.20070928095102.2"></t>
<t tx="ekr.20070929062147">@nocolor

The following scripts convert between Leo trees and NetworkX graphs.

- leo2graph:            convert a normal Leo tree to a NetworkX graph.
- at-graph2graph:       convert an @graph tree to a Networkx graph.
- at-networkx2graph:    convert an @networkx tree to a Networkx graph
- at-networkx2at-graph: create an @graph tree from an @networkx tree.

Not ready yet:

- tree2pict: convert a Leo @graph tree to a picture of the corresponding graph.

@color</t>
<t tx="ekr.20070929062147.1">'''Convert an @graph tree to a networkx graph.'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (str(p.v.t.fileIndex),p.headString())

def addTree(p):
    tag = '@link'
    h = p.headString()
    if h.startswith('@graph'):
        for child in p.children_iter():
            addTree(child)
    elif h.startswith('@node'):
        x.add_node(node_id(p))
        for child in p.children_iter():
            h = child.headString()
            if h.startswith(tag):
                link = h[len(tag):].strip()
                if link: x.add_edge(node_id(p),link)
            elif child.headString().startswith('@node'):
                addTree(child)
                x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')</t>
<t tx="ekr.20070929062147.2">'''Convert an @networkx node to a networkx graph.'''
import networkx as nx
import sys

@others

x = nx.Graph()

edges,nodes = parse(p)

for z in nodes:
    x.add_node(z)

for z in edges:
    a,b = z
    x.add_edge(a,b)

g.pr('\nnodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('\nedges...\n', g.listToString(x.edges(),sort=True))
g.pr('\nyaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070929070257">@ This is an @graph tree.

You can convert it to a networkx graph using the at-graph2graph button.</t>
<t tx="ekr.20070929070257.1"></t>
<t tx="ekr.20070929070257.2"></t>
<t tx="ekr.20070929070426">g.es('@link %s: %s' % (str(p.v.t.fileIndex),p.headString()))</t>
<t tx="ekr.20070929070632"></t>
<t tx="ekr.20070929070632.1"></t>
<t tx="ekr.20070929072043">@ This node defines a networkx graph using nodes and edges.

You can create an @graph tree from this node using the graph2at-graph button.
</t>
<t tx="ekr.20070929072506"># Each edge is represented as two lines.

# child1 --&gt; child2
('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2

# child2 --&gt; child1
('ekr', '20070929070257', 2): @node child2
('ekr', '20070929070257', 1): @node child1

</t>
<t tx="ekr.20070929072506.1"># Each node is on a separate line.

('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2
</t>
<t tx="ekr.20070929072506.2">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929074830">def parse (p):

    tag = '@networkx'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
        if not p.headString().startswith(tag):
            error('No %s node in the outline' % tag)
            return [],[]

    nodes = []
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,p,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return [],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return edges,nodes
</t>
<t tx="ekr.20070929074830.1">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929081505">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929082546">'''Convert an @networkx node to an @graph tree.
Create the tree as the child of the @graph-target node,
or the current position if no such node.'''

import networkx as nx
import sys

@others

g.pr('=' * 10)

p,edges,nodes = parse(p)

createTree(p,edges,nodes)
</t>
<t tx="ekr.20070929114410.2">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929114410.3">def parse (p):

    tag = '@graph-target'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
    if not (p and p.headString().startswith(tag)):
        p = c.currentPosition() # Use the presently selected node.

    nodes = [] ; tag = '@networkx'
    data = g.findNodeAnywhere(c,tag)
    if not data:
        error('No %s tree' % tag)
        return None,[],[]
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,data,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return None,[],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return p,edges,nodes
</t>
<t tx="ekr.20070929114410.4">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929114410.5">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929114617">@ This will be the root node for the @graph tree produced by the at-networkx2at-graph button.</t>
<t tx="ekr.20070929115302">def createTree (parent,edges,nodes):

    if 0:
        g.trace('nodes...\n', g.listToString(nodes,sort=True))
        g.trace('edges...\n', g.listToString(edges,sort=True))

    c.beginUpdate()
    try:
        p = parent.insertAsLastChild()
        p.setHeadString('@graph')
        d = createNodes(p,nodes)
        createEdges(d,edges)
        c.selectPosition(p)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070929120541">def createEdges (d,edges):

    for edge in edges:
        a,b = edge
        g.trace('\n%s --&gt; %s' % (a,b))
        p = d.get(a)
        if p:
            p2 = p.insertAsLastChild()
            p2.setHeadString('@link %s' % (b))
        else:
            error('@node not found: %s' % (a))
</t>
<t tx="ekr.20070929120541.1">def createNodes (parent,nodes):

    d = {}

    for node in nodes:
        # g.trace(node)
        p = parent.insertAsLastChild()
        p.setHeadString('@node %s' % (node))
        d[node] = p.copy()

    return d
</t>
<t tx="ekr.20070929122956"></t>
<t tx="ekr.20070929122956.1"></t>
<t tx="ekr.20071002150320">log = c.frame.log
tag = 'my-canvas'

w = log.canvasDict.get(tag)
if not w:
    w = log.createCanvas(tag)
    w.configure(bg='yellow')

log.selectTab(tag)
</t>
<t tx="ekr.20071025193940"># Standard plugins
free_layout.py
mod_scripting.py
nav_qt.py
plugins_menu.py
quicksearch.py
viewrendered.py

# testing
# active_path.py
screencast.py
vim.py

### UNL.py # moved to core.
### scrolledmessage.py is broken at present.

# Other useful plugins...

# attrib_edit.py
# codewisecompleter.py
# contextmenu.py
# ctagscompleter.py
# graphed.py
# ipython.py
# leoOPML.py
# leo_to_html.py
# leoremote.py
# mod_autosave.py
# nodenavigator.py
# open_with.py
# pydeeshell.py
# rst3.py
# screenshots.py
# stickynotes.py # requires Python 3.0
# stickynotes_plus.py
# templates.py
# vim.py
# xemacs.py

# test of @bool warn_when_plugins_fail_to_load
# xyzzy.py 
</t>
<t tx="ekr.20071026102420.2"></t>
<t tx="ekr.20071026102420.3"></t>
<t tx="ekr.20071105085941"></t>
<t tx="ekr.20071128122043">log = c.frame.log ; tag = 'Shell'
frame1 = log.frameDict.get(tag)
shellKind = 'text' # in ('plain','text','canvas')

if frame1:
    log.selectTab(tag)
elif shellKind == 'plain':
    log.selectTab (tag,createText=False)
    frame = log.frameDict.get(tag)
elif shellKind == 'text':
    log.selectTab (tag,createText=True)
    frame = log.textDict.get(tag)
elif shellKind == 'canvas':
    log.createCanvas(tag)
    log.selectTab(tag)
    frame = log.canvasDict.get(tag)
else:
    frame = None
    g.es('bad shellKind',shellKind)

if frame and not frame1:
    frame.configure(bg='white')
    g.pr('logFrame',log.frameDict.get(tag))
</t>
<t tx="ekr.20071129103842"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True
baseDir = r'c:\leo.repo\pythoscope\lib2to3\pgen2'
dirs = (r'',)
g.pr('-----')

for theDir in dirs:
    pattern = g.os_path_join(baseDir,theDir,'*.py')
    files = glob.glob(pattern)
    g.pr(pattern)
    # g.pr(g.listToString(files))
    for name in files:
        h = '@auto %s' % (name[len(baseDir) + 1:].strip())
        g.pr('creating',h)
        if reallyCreate:
            child = p.insertAsLastChild()
            child.initHeadString(h)</t>
<t tx="ekr.20080105115712"># This hangs Leo while pylint is running.
import pylint.lint as lint
import sys

rcFile = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','pylint-leo-rc.txt'))
rcArg = '--rcfile=%s' % rcFile
&lt;&lt; define data &gt;&gt;

# We expect only one W104 error, in leoGlobals.py
g.pr('\n','=' * 40)
for name,s in data:
    name2 = g.os_path_abspath(g.os_path_join(g.app.loadDir,name))
    args = [name2,rcArg]
    if s.strip():
        args.append('--disable-msg=%s' % s)
    g.pr(name,s)
    lint.Run(args)
g.pr('\n' + 'End of pylint run')</t>
<t tx="ekr.20080105120559">data = (
    ('leoAtFile.py',''), 
    ('leoChapters.py',''),
    ('leoCommands.py',''), 
    ('leoEditCommands.py','E1101'),
    ('leoFileCommands.py',''), 
    ('leoFind.py',''),
    ('leoFrame.py',''),
    ('leoGlobals.py','E0602,E1101'),
    ('leoGui.py',''),
    ('leoImport.py',''),
    ('leoMenu.py',''),
    ('leoNodes.py',''),
    ('leoPlugins.py',''),
    ('leoTangle.py',''),
    ('leoUndo.py','W0102'),
    ('leoTkinterDialog.py',''),
    ('leoTkinterFind.py',''),
    ('leoTkinterGui.py',''),
    ('leoTkinterFrame.py','W0221'),
    ('leoTkinterKeys.py',''), 
    ('leoTkinterMenu.py',''), 
    ('leoTkinterTree.py',''),
)
</t>
<t tx="ekr.20080105130903">@nocolor
@
C0111 Missing docstring
C0301 Line too long
C0311 Bad indentation
C0321 More than one statement on a single line
C0322 Operator not preceded by a space
C0323 Operator not followed by a space
C0324 Comma not followed by a space

R0201 Method could be a function.
R0903 Too few public methods (0/1)

W0102 Dangerous default value [] as argument
W0104 Statement seems to have no effect
W0106 Unnecessary semicolon
W0107 Unnecessary pass statement
W0122 Use of the exec statement
W0141 Used builtin function 'map'
W0142 Used * or * magic*
W0201 Attribute defined outside __init__
W0212 Access to a protected member of a client class
W0231 __init__ method from base class is not called
W0232 Class has no __init__ method
W0401 Wildcard import (pychecker)
W0402 Uses of a deprecated module (like string)
W0404 Reimport &lt;module&gt;: let pychecker do this.
W0406 Module import itself
W0602 Using global for x but no assigment is done (leoEditCommands defines classList after all classes).
W0603 Using the global statement
W0612 Unused variable
W0613 Unused argument (sometimes used for debugging)
W0621 Redefining &lt;name&gt; from outer scope: especially __pychecker__
W0622 Redefining built-in
W0631 Using possibly undefined loop variable
W0702 No exception type specified
W0703 Catch "Exception"
W0704 Except doesn't do anything (Except: pass)
W1111 Assigning to a function call that only returns None</t>
<t tx="ekr.20080115085447">@nocolor
@

************* Module leoGlobals
W0104:3871: Statement seems to have no effect
</t>
<t tx="ekr.20080206055658">g.pr('settings...')
for z in ('body','button','headline','log','menu','outline'):
    for z2 in ('family','size','slant','weight',):
        setting = '%s_text_font_%s' % (z,z2)
        g.pr(setting,c.config.get(setting,z2))

g.pr('default sizes...')
for z in ('Body','Log','Menu','Tree'):
    setting = 'default%sFontSize' % z
    g.pr(setting,getattr(c.config,setting))

g.pr('actual fonts...')
for z in ('body','button','headline','log','menu','outline'):
    kind = ('family','size','slant','weight')
    arg0,arg1,arg2,arg3 = args = ['%s_text_font_%s' % (z,z2) for z2 in kind]
    setting = '%s_text_font' % (z)
    g.pr('%20s' % (setting),c.config.getFontFromParams(arg0,arg1,arg2,arg3,defaultSize=12))
</t>
<t tx="ekr.20080412082246.1"></t>
<t tx="ekr.20080503202744.3">import rope.base.project
import rope.contrib.codeassist as codeassist
import leo.core.leoGlobals as g
import leo.core.leoCommands as leoCommands
c2 = leoCommands.Commands(frame=c.frame,fileName='xyz-file')

class leoFSCommands (object):
    def create_file(self,path):         g.trace(path)
    def create_folder(self,path):       g.trace(path)
    def move (self,path,new_location):  g.trace(path,new_location)
    def remove (self,path):             g.trace(path)
    def write (self,path,data):         g.trace(path,data)

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','..'))
    # Make the trunk folder a project
project = rope.base.project.Project(path,fscommands=leoFSCommands)
s = p.bodyString() # Could simulate a write to allow @others.

g.pr('*' * 40)
for pattern in (
    # 'g.', # works.
    # 'g.trace(', # weird.
    # 'rope.base.', # works.
    'g.list', # works: gives g.listToString
    'c2.de', # works.
):
    i = s.find(pattern)
    if i &gt; -1:
        proposals = codeassist.code_assist(project,s,i+len(pattern))
        g.pr('-' * 20)
        g.pr('pattern:',pattern)
        g.pr(g.listToString(proposals))</t>
<t tx="ekr.20080529111617.1"></t>
<t tx="ekr.20080529111617.10">The name of time unit (e.g. days, weeks, hours)</t>
<t tx="ekr.20080529111617.2"></t>
<t tx="ekr.20080529111617.3">The colour used instead of green in progress bars</t>
<t tx="ekr.20080529111617.4">The colour used instead of red in progress bars</t>
<t tx="ekr.20080529111617.5"># list of @file node types to color.
# Uncomment these to enable coloring for these kinds of nodes.
# @asis
# @file
# @auto
# @thin
@auto</t>
<t tx="ekr.20080529111617.6">The base width of progress bars, in pixels.</t>
<t tx="ekr.20080529111617.7">The default number of time units.</t>
<t tx="ekr.20080529111617.8">0: no progress bars
1: unscaled progress bars
2: scaled progress bars</t>
<t tx="ekr.20080529111617.9">pixels per time unit to add to width of scaled progress bars</t>
<t tx="ekr.20080531080812.1">def eggs():
    g.trace()

def spam():
    g.trace()
    eggs()

t = g.startTracer()
spam()
t.stop()
</t>
<t tx="ekr.20080531131542.1">import mx.TextTools as tt

&lt;&lt; define scan4 tables &gt;&gt;
&lt;&lt; define s &gt;&gt;

@others

g.pr('*' * 60)
ok,taglist,nextindex = tt.tag(s,lineTable)
# g.pr(g.listToString(taglist))
for z in taglist:
    printItem(z,level=0)
g.pr('ok:',ok)
</t>
<t tx="ekr.20080531131542.2">from mx.TextTools import * # Required for tags.

ws_charset   = CharSet(' \t')
name_charset = CharSet(alpha)

gnxTable = (
    (None,Is,':',MatchFail),
    (None,AllNotIn,':',MatchFail),
    (None,Is,':',MatchFail,MatchOk),
)

sentinelNameTable = (
    (None,Is,'@',+1,+3),
    (None,Is,'+',+1,+2),
    (None,Is,'-',+1),
    (None,AllInCharSet,name_charset,MatchFail,MatchOk),
)

sentinelTable = (
    # Start of another line.
    # Skip ws.
    (None,AllInCharSet,ws_charset,+1),
    # Require sentinel comment.
    (None,Word,'#@',MatchFail),
    ('kind',Table,sentinelNameTable,MatchFail),
    ('gnx',Table,gnxTable,+1),
    # Everything else is the sentinel value
    ('extra',AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

normalLineTable = (
    (None,AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

lineTable = (
    ('sent',Table,sentinelTable,+1,+2),
    ('line',Table,normalLineTable,+1,+1),
    ('eof',EOF,Here,-2),
)</t>
<t tx="ekr.20080531131542.4">def printItem(aList,level):

    obj,lt_index,rt_index,subtag = aList
    g.pr('  '*level,obj,repr(s[lt_index:rt_index]))
    if subtag:
        for z in subtag:
            printItem(z,level+1)
</t>
<t tx="ekr.20080531141227.1">path = r'c:\leo.repo\trunk\leo\core\runLeo.py'
f = file(path)
s = f.read()
f.close()</t>
<t tx="ekr.20080604104453.5">@nocolor

This setting determines the initial binding for otherwise-unbound keystrokes
when no mode is in effect.  Note: the keyboard-quit command exits all modes.

The valid values are::

command:  Leo ignores the key (like Vim).
insert:  Leo inserts the key at the cursor (like Emacs)
overwrite: Leo replaces the character at the cursor.</t>
<t tx="ekr.20080617170334.1">@first # -*- coding: utf-8 -*-

import Tkinter as Tk

top = Tk.Toplevel()
w = Tk.Text(top)
w.pack()

def key(event):
    if event.char: g.pr('state',event.state,'char', repr(event.char), repr(event.keysym))

def after():
    g.trace()
    w.event_generate('&lt;Key&gt;',keysym='a')
    w.event_generate('A')
    w.event_generate(g.toEncodedString('Á',encoding='utf8'))
    # w.event_generate('&lt;Key-Control_L&gt;')
    # w.event_generate('c')
    # w.event_generate('Shift-Control-a')

w.bind('&lt;Key&gt;',key)
w.focus_set()
w.update()
# top.after_idle(after)
top.mainloop()
</t>
<t tx="ekr.20080628094340.1">if 0:
    # Called when func is **defined**
    def leo_command(func):
        g.trace(func.__name__)
        return func
else:
    class leo_command:
        def __init__(self,func,c=c):
            self.c = c
            self.func = func
            self.name = func.__name__
            g.pr("registering",self.name)

        def __call__(__self,*__args,**__kw):
            g.pr("before", __self.name)
            try:
                return __self.func(*__args,**__kw)
            finally:
                g.pr("after ", __self.name)
                g.pr('c',c)
                c.outerUpdate()


@leo_command
def hello():
    g.pr("Hello, world!")

hello()
</t>
<t tx="ekr.20080701101740.1">import locale
aList = dir(locale)
# g.pr(g.listToString(aList))

g.pr(g.getpreferredencoding())
# import os
# g.pr(dir(os))
</t>
<t tx="ekr.20080701130406.1">import glob

aList = glob.glob(r'c:\leo.repo\trunk\leo\plugins\*.py')
for z in aList:
    name = g.shortFileName(z)
    if not name.startswith('_'):
        g.pr('echo .')
        g.pr('echo',name)
        g.pr('call pylint.bat core\%s' % name)</t>
<t tx="ekr.20080729153237.1"></t>
<t tx="ekr.20080729153237.2"># True: calls to the garbage collector.</t>
<t tx="ekr.20080729153237.3"># True (recommended): print a message when Leo calls gc.collect explicitly.</t>
<t tx="ekr.20080729153237.4"># True: verbose trace the garbage collector.</t>
<t tx="ekr.20080806145258.1"></t>
<t tx="ekr.20080806145258.12">@nocolor

Notes:
    
- button Leo2dHTML creates leo\test\x.htm, where x is the name of the .leo file
  containing the script. The file contains javascript that allows a browser to
  expand and contract headlines.  Leo2DHTML is *unrelated* to the other files.
    
- leo\test\server.py is a minimal Python server.  Invoke from a console with::
    
    python server.py

To use this server, type this url in a web browser: http://localhost:8080/
The server will print the contents of the directory from which it was invoked.
Choose hello.html to see the 'Hello World' test page.

- leo\test\hello.html is a test page.  It uses leo\test\cgi-bin\edward.py

- leo\test\cgi-bin\edward.py is the script called from hello.leo when the user
  hits the 'Submit Query button.
  This is recompiled (as needed) for every query, which makes testing it easier.
  
  **Important** edward.py returns its result by printing (in a special format):
  Thus, everything you print will be part of the returned form(!). You **can**
  print debug info: just make sure you don't mess up the special conventions:
  the best place to print debugging info is in print_all.

@color</t>
<t tx="ekr.20080806145258.13">@

edward.py:
    
How can we get the content of an input form?</t>
<t tx="ekr.20080806145258.14">@first # -*- coding: utf-8 -*-
@language python
@tabwidth -4

&lt;&lt; about LeoToHTML &gt;&gt;
import leo.core.leoGlobals as g
&lt;&lt; define dhtml stuff &gt;&gt;
@others

fileName = c.frame.shortFileName() # Get current outline file name
if fileName.endswith('.leo'): fileName = fileName[:-4] # Remove .leo suffix
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test',fileName)) + '.htm'

# Write the file.
f=open(path, 'w')
writeAll(f)
f.close() 
g.es('wrote: %s' % (path),color="turquoise4") 
</t>
<t tx="ekr.20080806145258.15">@

LeoToHTML by Dan Rahmel, modified by EKR.

This @button script creates an .htm file containing the contents of the selected tree.
The file is called x.htm, where x is the name of the .leo file containing the script.
This file is written to the leo/test folder.

The script inserts javascript into the page so that nodes can be expanded and contracted.

The script presently works well.  This script may become the basis for a facebook app.

The generated html passes html-tidy: http://www.w3.org/People/Raggett/tidy/
</t>
<t tx="ekr.20080806145258.16">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

javascript  = """
&lt;script src="cgi-bin/leo.js" type="text/javascript"&gt;&lt;/script&gt;
"""

style = '''
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
'''
</t>
<t tx="ekr.20080806145258.17">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.18">def writeAll(f):

    f.write('&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;')
    f.write('&lt;html&gt;')
    writeHead(f)
    writeBody(f)
    f.write("&lt;/html&gt;")
</t>
<t tx="ekr.20080806145258.19">def writeBody(f):

    f.write('&lt;body class="st" onload="format()"&gt;')
    writeContents(f)
    f.write("&lt;/body&gt;")
</t>
<t tx="ekr.20080806145258.20">def writeHead(f):

    f.write('&lt;head&gt;')
    f.write(style)
    f.write(javascript)
    f.write('&lt;title&gt;%s&lt;/title&gt;' % c.shortFileName())
    f.write('&lt;/head&gt;')
</t>
<t tx="ekr.20080806145258.21">def writeContents(f):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    current = c.currentPosition()
    prev_level = current.level()
    open_divs = 0
    for p in current.self_and_subtree_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            f.write(end_div)
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        f.write(division % (n,escape(h),n))
        open_divs += 1
        if body:
            f.write(div % escape(body))
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        f.write(end_div)
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.22"># def writePreamble(f):

    # '''Write HTML header information.'''

    # header_start = '''\


# &lt;body class="st" onload="format()"&gt;
# '''

    # for s in (header_start,style,javascript,header_end):
        # # f.write(g.adjustTripleString(s,c.tab_width))
        # f.write(s)
</t>
<t tx="ekr.20080806145258.23"># def writePostamble (f):

    # pass

</t>
<t tx="ekr.20080806145258.24"># A minimal python server for testing.
# To access this server, type this url in a web browser: http://localhost:8080/
# The server will print the contents of the directory from which it was invoked.
# Choose hello.html to see the 'Hello World' test page.

import CGIHTTPServer
import SocketServer

port = 8080

Handler = CGIHTTPServer.CGIHTTPRequestHandler
s = SocketServer.TCPServer(("", port), Handler)

s.server_name = '127.0.0.1' # represents local host.
s.server_port = port

# import os ; print 'cwd', os.getcwd()

print "server.py: serving at port", port
s.serve_forever()
</t>
<t tx="ekr.20080806145258.25">@language html

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;

&lt;!-- Used by edward.old.py
&lt;script language="JavaScript" type="text/javascript"&gt;
   var openImg = new Image();
   openImg.src = "open.gif";
   var closedImg = new Image();
   closedImg.src = "closed.gif";

   function showNode(node) {
      var objBranch = 
         document.getElementById(node).style;
      if(objBranch.display=="block")
         objBranch.display="none";
      else
         objBranch.display="block";
   }

   function swapFolder(img) {
      objImg = document.getElementById(img);
      if(objImg.src.indexOf('closed.gif')&gt;-1)
         objImg.src = openImg.src;
      else
         objImg.src = closedImg.src;
   }
&lt;/script&gt;
--&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;form action="cgi-bin/edward.py" method="GET"&gt;
&lt;input type="submit" name="George"&gt;
&lt;/form&gt;

&lt;p&gt;This is the hello world test page.
The server in server.py should be running when using this page.

&lt;p&gt;The button (form) above should cause the server to send a "GET" request
to the edward.py script, which will respond with a new page.

&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20080806145258.26">@first #! c:\python25\python.exe
@first # -*- coding: utf-8 -*-

'''This is the cgi script called from hello.html when the user hits the button.'''

### Print statements are used to return results (return the form).
### You *can* use print statement for tracing, but only in print_all.
# To do: use cgi.FieldStorage.

@language python
@tabwidth -4
&lt;&lt; imports &gt;&gt;
&lt;&lt; define dhtml stuff &gt;&gt;
@others

if 1: # Open the bridge.
    path = os.path.abspath(os.path.join(leoParentDir,'leo','test','test.leo')) # c does not exist!
    b = leoBridge.controller(gui='nullGui',loadPlugins=False,readSettings=False,verbose=False)
    g = b.globals()
    c = b.openLeoFile(path)
    p = c.rootPosition()
else:
    c = None

# import pdb ; pdb.Pdb() # Doesn't work.
print_all(c)</t>
<t tx="ekr.20080806145258.27">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

style = """
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
"""</t>
<t tx="ekr.20080806145258.28">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.29">def print_all(c):

    # This line is required (with extra newline), but does not show on the page.
    print "Content-type:text/html\n"

    print '&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;'
    print '&lt;html&gt;'
    if c:
        # Print the page.
        print_head(c)
        print_body(c)
    else:
        # Print the debugging info.
        print '__file__',__file__
        print 'os.getcwd()',os.getcwd()

    print '&lt;/html&gt;'
</t>
<t tx="ekr.20080806145258.30">def print_body(c):

    print '&lt;body class="st" onload="format()"&gt;'

    if 0:
        # Debugging info.
        form = cgi.FieldStorage()
        print repr(form)
        # if form.has_key('name'):
            # print 'name',form['name'].value
        # else:
            # print 'no name'
    print_tree(c)
    print '&lt;/body&gt;'
</t>
<t tx="ekr.20080806145258.31">def print_head(c):

    print '&lt;head&gt;'

    if 1: # Copy the entire leo.js file into the page.
        print '&lt;script type="text/javascript"&gt;'
        print_leo_dot_js(c)
        print '&lt;/script&gt;'

    else: # Possible bug in the python server??
        # The Python says leo.js is not executable(!)
        print '&lt;script src="leo.js" type="text/javascript"&gt;&lt;/script&gt;'

    print '&lt;title&gt;%s&lt;/title&gt;' % (c.shortFileName())
    print '&lt;/head&gt;'
</t>
<t tx="ekr.20080806145258.32">def print_leo_dot_js(c):

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','cgi-bin','leo.js'))

    try:
        f = file(path)
    except IOError:
        print 'can not open',path
        return

    for line in f.readlines():
        print line,

    f.close()
</t>
<t tx="ekr.20080806145258.33">def print_tree(c):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    prev_level = 0
    open_divs = 0
    for p in c.allNodes_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            print end_div
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        print division % (n,escape(h),n)
        open_divs += 1
        if body: print div % escape(body)
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        print end_div
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.34"></t>
<t tx="ekr.20080806145702.1">import os
import sys

# Add the *parent* of the leo directory to sys.path.
leoParentDir = os.path.abspath(os.path.join(os.path.dirname(__file__),'..','..','..'))

if leoParentDir not in sys.path:
    sys.path.append(leoParentDir)

import leo.core.leoBridge as leoBridge

import cgi
import cgitb ; cgitb.enable()
</t>
<t tx="ekr.20080807114145.2">@
A script button to run any body text as a Windows Script.
See: http://en.wikipedia.org/wiki/Windows_Script_Host

You need the win32 extensions and you must enable the script engine.
Adapted from Active State examples:ch21_active_scripting:ActiveApp.py
http://python.net/crew/mhammond/win32/
@c

&lt;&lt; imports &gt;&gt;

@others

RunCode("python",p.bodyString())
</t>
<t tx="ekr.20080807115344.1">Application.Echo("Hello from Python")
</t>
<t tx="ekr.20080807115344.2">class MySite(axsite.AXSite):
    # Our error handler will simply print to the console.
    def OnScriptError(self, activeScriptError):
        exc = activeScriptError.GetExceptionInfo()
        print "Exception:", exc[1]
        try:
            sourceText = activeScriptError.GetSourceLineText()
        except pythoncom.com_error:
            sourceText = None
        if sourceText is not None: 
            context, lineNo, charNo = activeScriptError.GetSourcePosition()
            print sourceText
            indent = " " * (charNo-1)
            print indent + "^"
        return winerror.S_OK
</t>
<t tx="ekr.20080807115344.3"># A named object for our namespace
# A normal Python COM object (minus registration info)
class Application:
    _public_methods_ = [ 'Echo' ]
    def Echo(self, *args):
        print string.join(map(str, args))

</t>
<t tx="ekr.20080807115344.4"># Create the site and the engine and runs the code.
def RunCode(engineName, code):

    app = win32com.server.util.wrap( Application() )

    # Create a dictionary holding our object model.
    model = {'Application' : app,}

    # Create the scripting site.
    site = MySite(model)
    # Create the engine and add the code.
    engine = site.AddEngine(engineName)
    engine.AddCode(code)

    # Run the code.
    engine.Start()
</t>
<t tx="ekr.20080807115344.5">import string
import sys
from win32com.axscript import axscript
from win32com.axscript.server import axsite
import pythoncom
import win32com.server.util</t>
<t tx="ekr.20080811113441.2"></t>
<t tx="ekr.20080815073750.1">n = 0
for p in c.allNodes_iter():
    if p.isAtNoSentFileNode():
        c.atFileCommands.write(p,nosentinels=True)
        n += 1
g.es('done: %s files written' %(n))</t>
<t tx="ekr.20080821111715.1">@first # -*- coding: utf-8 -*-

# Important: see http://webpages.charter.net/edreamleo/FAQ.html#unicode-issues

import sys

print '=' * 40

e = sys.getdefaultencoding()
assert e.lower() == 'utf-8'
print 'encoding',e

table = (
    'La Peña',
    unicode('La Peña','utf-8'),
    u'La Peña',
    u'La Pe\xf1a',
    # u'AA \u0102 BB',
)

for s in table:
    print type(s)
    g.es_print('g.es_print',s)
    if type(s) != type(u'a'):
        s = unicode(s,e)
    print      'print     ',s
    print      'repr(s)   ',repr(s)
</t>
<t tx="ekr.20080822153619.1"></t>
<t tx="ekr.20080823154546.1">p2 = p.insertAfter()
p2.setHeadString('inserted node')
s = p.bodyString()

# Remove Leo directives.
directives = ['@'+z for z in g.globalDirectiveList]
def isDirective(s):
    for z in directives:
        if s.startswith(z):
            return True
    else: return False
aList = [z for z in g.splitLines(s) if not isDirective(z)]
s = ''.join(aList)
if not s.endswith('\n'): s = s + '\n'

c.importCommands.scanPythonText(s,p2.copy(),atAuto=True)
c.redraw_now()
g.pr('done')</t>
<t tx="ekr.20080917063615.1">aList = (
'aspellbindir',
'wholeword',
'Whole-Word',
'vimcmd',
'huh',
)

for name in aList:
    kind, val = c.config.getSettingSource(name)
    print '%-20s %-20s %s' % (name,repr(val),kind)
</t>
<t tx="ekr.20080920101658.1">def getInput (event=None):

    '''Evaluate a Python Expression entered in the minibuffer.'''

    stateName = 'get-input'
    k = c.k ; state = k.getState(stateName)

    if state == 0:
        k.setLabelBlue('Input: ',protect=True)
        k.getArg(event,stateName,1,getInput)
    else:
        k.clearState()
        g.es_print('input:',k.arg)

getInput()
</t>
<t tx="ekr.20080921144924.1">print(g.os_path_finalize(r'~/.leo/notebook.leo'))
print(g.os_path_finalize(g.os_path_join(g.app.loadDir,r'~/.leo/notebook.leo')))
print(g.os_path_finalize_join(g.app.loadDir,r'~/.leo/notebook.leo'))</t>
<t tx="ekr.20080922142953.1"># @string default_leo_file = ~/.leo/workbook.leo
path = "{{c.config.getString('default_leo_file')}}"
# print g.os_path_expandExpression(path,c=c)
print g.os_path_finalize(path,c=c)</t>
<t tx="ekr.20080922164255.1"></t>
<t tx="ekr.20080922164255.2"></t>
<t tx="ekr.20080922164656.1"></t>
<t tx="ekr.20080923073240.1">{{c.config.getString('test')}}/eval-test.txt
=
c:\leo.repo\trunk\leo\test\eval-test.txt</t>
<t tx="ekr.20080923073240.2"></t>
<t tx="ekr.20080924081821.1"># c.k.ab

# Test this code using the execute-script command.

s = p.bodyString()
lines = g.splitLines(s)
s = lines[0]

theObject,aList = c.k.autoCompleter.getExternalCompletions(s)

print '='*20
print 'theObject',theObject and theObject.__class__
print 'len(completions)',len(aList)
print g.listToString(aList, tag='completion list', sort=True, indent='')
</t>
<t tx="ekr.20080930080501.1">c.frame.iconBar.addRow()
c.frame.addIconButton(text="New")</t>
<t tx="ekr.20080930083052.1">c.frame.hideIconBar()</t>
<t tx="ekr.20080930083052.2">c.frame.showIconBar()</t>
<t tx="ekr.20080930085514.1">c.frame.clearIconBar()</t>
<t tx="ekr.20080930114036.1"></t>
<t tx="ekr.20081003094737.1"></t>
<t tx="ekr.20081205104320.1"># import os
tag = '#!/bin/bash\n'
s = g.getScript(c,p,
    useSelectedText=False,
    forcePythonSentinels=False,
    useSentinels=True)
if not s.startswith(tag):
    s = tag + s
print s
os.system(s)
</t>
<t tx="ekr.20090128112453.1"># print p.b
# p.b = p.b + '\n# new'
# p.h = p.h + 'z'

print c.p

if 0:
    print p.v.u
    print p.v.u.get('key')
    p.v.u['key'] = 'abc'
    print p.v.u.get('key')
    p.v.u = {'key':'xyz'}
    # p.v.u = 'abc'
    print p.v.u

if 0:
    print p.v.t.u
    print p.v.t.u.get('t-key')
    p.v.t.u['t-key'] = 'pdq'
    print p.v.t.u.get('t-key')
    # p.v.t.u = {'key':'pdq'}
    # # p.v.t.u = 'pdq'
    # print p.v.t.u</t>
<t tx="ekr.20090128131130.1">aList = g.posList(c) # Start with all positions
print len(aList)
aList2 = aList.select('plugin',regex=False,removeClones=True)
print aList2.dump(sort=True)
aList3 = aList2.select('http')
print aList3.dump()

# To see the docstring, enable auto-completion and type g.posList?
# g.posList</t>
<t tx="ekr.20090201162523.1"># define a macro: ctrl-f ab ctrl-r AB
pass</t>
<t tx="ekr.20090201192257.1">b = p.b
try:
    w = c.frame.body.bodyCtrl
    w.setInsertPoint(0)
    m = c.macroCommands
    fn = g.os_path_finalize_join(g.app.loadDir,'..','..','ekr-macros.txt')
    f = open(fn)
    m.loadMacros(f)
    macro = m.namedMacros.get('ab')
    assert macro
    m.executeMacro(macro)
finally:
    assert p.b =='ab' + b,p.b
    p.b = b
</t>
<t tx="ekr.20090205070715.1">#colorer = c.frame.body.colorizer.highlighter.colorer
g.es ('total characters: %s, keywords: %s, leo_keywords: %s' % (
    colorer.totalChars,
    colorer.totalKeywordsCalls,
    colorer.totalLeoKeywordsCalls))</t>
<t tx="ekr.20090218112656.1"># 'self' is now defined in @test and @suite nodes.
self.assertEqual(1,1)</t>
<t tx="ekr.20090309064612.2"></t>
<t tx="ekr.20090309064612.3"></t>
<t tx="ekr.20090309064612.4"></t>
<t tx="ekr.20090316115500.1"></t>
<t tx="ekr.20090428081009.1">import PyQt4.QtCore as QtCore
import PyQt4.QtGui as QtGui
from PyQt4 import uic

table = (
    (['QtGui'],'object',QtGui),
    (['QtCore'],'object',QtCore),
)

c.k.autoCompleter.defineObjectDict(table)
print c.k.autoCompleter.objectDict.keys()

# print c.k.autoCompleter.objectDict.get('QtCore')</t>
<t tx="ekr.20090507082111.1904">print "---- inserting ----"
p2 = p.insertAsLastChild().copy()
p3 = p.insertAsLastChild().copy()

print [p2.gnx, p3.gnx]

children = p.children_iter()
print [p.gnx for p in children]

c.redraw()</t>
<t tx="ekr.20090507082535.1906">import email,getpass,imaplib,os

username = 'edreamleo@gmail.com'
passfile = os.path.expanduser('~/gmailpass.txt')
M = imaplib.IMAP4_SSL('imap.gmail.com',993)
try:
    f = open(passfile)
    password = f.read()
    M.login(username,password)
except IOError:
    g.es_print('file not found: %s' % (passfile),color='red')
    # M.login(username, getpass.getpass())

M.select()
typ, data = M.search(None, 'ALL')
for num in data[0].split():
    typ, data = M.fetch(num,'(RFC822)')
    s = data[0][1]
    m = email.message_from_string(s)
    # for z in m.keys(): print z
    payload = m.get_payload()
    p2 = p.insertAsLastChild()
    date,from_s,subject = m['date'],m['from'],m['subject']
    p2.setHeadString(subject)
    body = '@nocolor\n\nDate: %s\nFrom: %s\nSubject: %s\n\n%s' % (
        date,from_s,subject,payload)
    p2.setBodyString(body)
print 'done'
M.close()
M.logout()
c.redraw()</t>
<t tx="ekr.20090514101216.1927"># 'self' is now defined in @test and @suite nodes.
self.assertNotEqual(1,2)</t>
<t tx="ekr.20090514103332.1929">@language python</t>
<t tx="ekr.20090525090210.1940">La Peña</t>
<t tx="ekr.20090601093755.1802">bookmarks = []

@g.command('bookmark')
def bookmark(event):
    c = event.get('c')
    p = c.currentPosition()
    bookmarks.append(p.gnx)
    g.es('bookmarked') </t>
<t tx="ekr.20090617083033.1813">La Peña תּ
</t>
<t tx="ekr.20090617083033.1814"></t>
<t tx="ekr.20090618102458.1816">@first # -*- coding: utf-8 -*-

import PyQt4.QtCore as QtCore

s0 = unicode('La Peña','utf-8')
print s0
e = s0.encode('utf-8',"strict")
print e,repr(e)
s2 = QtCore.QString(s0)
print s2,repr(s2)
s3 = unicode(s2,'utf-8')
print s3
# s4 = QtCore.QString(e)
# print s4</t>
<t tx="ekr.20090619103402.1818"># Warning: this *replaces* the text.

bodyCtrl = c.frame.body.bodyCtrl
w = bodyCtrl.widget # A QTextEdit
s = bodyCtrl.getAllText()
w.setHtml(s)

try:
    # Lock out onTextChanged
    w.changingText = True
    w.setHtml(s)
finally:
    w.changingText = False</t>
<t tx="ekr.20090619103402.1821">bodyCtrl = c.frame.body.bodyCtrl
w = bodyCtrl.widget # A QTextEdit
s = bodyCtrl.getAllText()
w.setPlainText(s)</t>
<t tx="ekr.20090620063706.1826"></t>
<t tx="ekr.20090629105832.1790"></t>
<t tx="ekr.20090630141519.1793">#Example popup handler
from PyQt4 import QtCore

def test_acts(c,p,menu):

   # 'menu' is QMenu instance that was jsut created
   a1 = menu.addAction("Display " + p.h)
   a2 = menu.addAction("Es " + p.h)

   def a1_func():
       g.es("a1 from " + p.h)

   def a2_func():
       g.es("a2 from " + p.h)

   a1.connect(a1, QtCore.SIGNAL("triggered()"), a1_func)
   a2.connect(a2, QtCore.SIGNAL("triggered()"), a2_func)

def test_acts_handler2(c, p, menu):
   a = menu.addAction("Hello from handler 2")
   def f():
       g.es("Hello: " + p.h)

   a.connect(a, QtCore.SIGNAL("triggered()"), f)

def register():
   # the idea is just to append to the normal list g.tree_popup_handlers
   g.tree_popup_handlers.append(test_acts)
   g.tree_popup_handlers.append(test_acts_handler2)

register()</t>
<t tx="ekr.20090701125834.1765">fn = g.os_path_finalize_join(g.app.loadDir,'..','Icons','leo_inst.ico')
assert g.os_path_exists(fn)
c.editCommands.insertIconFromFile(path=fn)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20090706044257.1784">@language unknown_language
#!/bin/sh
#@+leo-ver=4-thin
#@+node:EKR.20040519082027.33:@file-thin ../../install
#@@first

# This script installs Leo on *nix.
# Initial version by by Frank Merenda (fmerenda@yahoo.com)

# Variables...
LEO_PREFIX=${LEO_PREFIX:-/usr/local}
LEO_RUN_SCRIPT_OUTPUT="${LEO_PREFIX}/bin/leo"

# Bug fix: 2008/4/8: replace /lib/leo by /lib.
LEO_LIB_DIR="${LEO_PREFIX}/lib"

echo ""
echo "Prefix directory set to \"$LEO_PREFIX\""

# Make the directory structure
if [ ! -d $LEO_LIB_DIR ] ; then
    echo ""
    echo Making directory structure $LEO_LIB_DIR

    RESULTS=`mkdir -p -m755 $LEO_LIB_DIR 2&gt;&amp;1`
    if [ $? -ne 0 ]; then
        echo Failure making directory $LEO_LIB_DIR!
        exit 1;
    fi
fi

if [ ! -d $LEO_PREFIX/bin ] ; then
    echo ""
    echo Making directory structure $LEO_PREFIX/bin
    RESULTS=`mkdir -p -m755 $LEO_PREFIX/bin 2&gt;&amp;1`
    if [ $? -ne 0 ]; then
        echo Failure making directory $LEO_PREFIX/bin!
        exit 1;
    fi
fi

# Copy the files
cp -rp leo $LEO_LIB_DIR
chown -R root:root $LEO_LIB_DIR

echo "PYTHONPATH=${LEO_PREFIX}/lib python ${LEO_PREFIX}/lib/leo/core/runLeo.py \"\$@\"" &gt; $LEO_RUN_SCRIPT_OUTPUT

RESULTS=`chmod 755 $LEO_RUN_SCRIPT_OUTPUT`   

echo ""
echo "Leo installed successfully"
echo "Make sure ${LEO_PREFIX}/bin is in your path then"
echo "type 'leo filename.leo' to use it."   
echo ""

exit 0;
#@-node:EKR.20040519082027.33:@file-thin ../../install
#@-leo
</t>
<t tx="ekr.20090715064044.1782">@language python

b = p.b
p2 = g.findNodeAnywhere(c,'@sphinx')
if p2:
    c.selectPosition(p2)
else:
    c.insertHeadline(op_name='Create @sphinx node')
    p2 = c.p
    p2.h = '@sphinx'
    c.redraw()

w = c.frame.body.bodyCtrl.widget
w.setHtml(b)
</t>
<t tx="ekr.20090728090618.2837"></t>
<t tx="ekr.20090728090618.2838">@first #!/usr/bin/env python

# Last modified: July 15th, 2009

@language python
@tabwidth -4

&lt;&lt; docstring &gt;&gt;
&lt;&lt; declarations &gt;&gt;

# Path/filename of the vim dictionary file to write to:
PYDICTION_DICT = r'complete-dict'
# Path/filename of the vim dictionary backup file:
PYDICTION_DICT_BACKUP = r'complete-dict.last'

@others

if __name__ == '__main__':
    &lt;&lt; process command line &gt;&gt;
</t>
<t tx="ekr.20090728090618.2839">__author__ = "Ryan Kulla (rkulla AT gmail DOT com)"
__version__ = "1.0"
__copyright__ = "Copyright (c) 2003-2009 Ryan Kulla"

import os
import sys
import types
import shutil
</t>
<t tx="ekr.20090728090618.2840">def get_submodules(module_name, submodules):
    """Build a list of all the submodules of modules."""

    # Try to import a given module, so we can dir() it:
    try:
        imported_module = my_import(module_name)
    except ImportError, err:
        return submodules

    mod_attrs = dir(imported_module)

    for mod_attr in mod_attrs:
        if type(getattr(imported_module, mod_attr)) is types.ModuleType:
            submodules.append(module_name + '.' + mod_attr)

    return submodules


</t>
<t tx="ekr.20090728090618.2841">def write_dictionary(module_name):
    """Write to module attributes to the vim dictionary file."""

    try:
        imported_module = my_import(module_name)
    except ImportError, err:
        return

    mod_attrs = dir(imported_module)

    # Generate fully-qualified module names: 
    write_to.write('\n--- %(x)s module with "%(x)s." prefix ---\n' % 
                   {'x': module_name})
    for mod_attr in mod_attrs:
        if callable(getattr(imported_module, mod_attr)):
            # If an attribute is callable, show an opening parentheses:
            prefix_on = '%s.%s('
        else:
            prefix_on = '%s.%s'
        write_to.write(prefix_on % (module_name, mod_attr) + '\n')

    # Generate non-fully-qualified module names: 
    write_to.write('\n--- %(x)s module without "%(x)s." prefix ---\n' % 
                   {'x': module_name})
    for mod_attr in mod_attrs:
        if callable(getattr(imported_module, mod_attr)):
            prefix_off = '%s('
        else:
            prefix_off = '%s'
        write_to.write(prefix_off % mod_attr + '\n')
</t>
<t tx="ekr.20090728090618.2842">def my_import(name):
    """Make __import__ import "package.module" formatted names."""
    mod = __import__(name)
    components = name.split('.')
    for comp in components[1:]:
        mod = getattr(mod, comp)
    return mod


</t>
<t tx="ekr.20090728090618.2843">def remove_duplicates(seq, keep=()):
    """

    Remove duplicates from a sequence while perserving order.

    The optional tuple argument "keep" can be given to specificy 
    each string you don't want to be removed as a duplicate.
    """
    seq2 = []
    seen = set();
    for i in seq:
        if i in (keep):
            seq2.append(i)
            continue
        elif i not in seen:
            seq2.append(i)
        seen.add(i)
    return seq2


</t>
<t tx="ekr.20090728090618.2844">def get_yesno(msg="[Y/n]?"):
    """

    Returns True if user inputs 'n', 'Y', "yes", "Yes"...
    Returns False if user inputs 'n', 'N', "no", "No"...
    If they enter an invalid option it tells them so and asks again.
    Hitting Enter is equivalent to answering Yes.
    Takes an optional message to display, defaults to "[Y/n]?".

    """
    while True:
        answer = raw_input(msg)
        if answer == '':
            return True
        elif len(answer):
            answer = answer.lower()[0]
            if answer == 'y':
                return True
                break
            elif answer == 'n':
                return False
                break
            else:
                print "Invalid option. Please try again."
                continue


</t>
<t tx="ekr.20090728090618.2845">def main(write_to):
    """Generate a dictionary for Vim of python module attributes."""
    submodules = []

    for module_name in sys.argv[1:]:
        try:
            imported_module = my_import(module_name)
        except ImportError, err:
            print "Couldn't import: %s. %s" % (module_name, err)
            sys.argv.remove(module_name)

    cli_modules = sys.argv[1:]

    # Step through each command line argument:
    for module_name in cli_modules:
        print "Trying module: %s" % module_name
        submodules = get_submodules(module_name, submodules)

        # Step through the current module's submodules:
        for submodule_name in submodules:
            submodules = get_submodules(submodule_name, submodules)

    # Add the top-level modules to the list too:
    for module_name in cli_modules:
        submodules.append(module_name)

    submodules.sort()

    # Step through all of the modules and submodules to create the dict file:
    for submodule_name in submodules:
        write_dictionary(submodule_name)

    # Close and Reopen the file for reading and remove all duplicate lines:
    write_to.close()
    print "Removing duplicates..."
    f = open(PYDICTION_DICT, 'r')
    file_lines = f.readlines()
    file_lines = remove_duplicates(file_lines, ('\n'))
    f.close()

    # Delete the original file:
    os.unlink(PYDICTION_DICT)

    # Recreate the file, this time it won't have any duplicates lines:
    f = open(PYDICTION_DICT, 'w')
    for attr in file_lines:
        f.write(attr)
    f.close()
    print "Done."
</t>
<t tx="ekr.20090728090618.2846">@language vim
" ============================================================================
" python_pydiction.vim - Module and Keyword completion for Python
" ============================================================================
"
" Author: Ryan Kulla (rkulla AT gmail DOT com)
" Version: 1.0, for Vim 7
" URL: http://www.vim.org/scripts/script.php?script_id=850
" Last Modified: July 18th, 2009
" Installation: On Linux, put this file in ~/.vim/after/ftplugin/
"               On Windows, put this file in C:\vim\vimfiles\ftplugin\
"                        (assuming you installed vim in C:\vim\).
"               You may install the other files anywhere. 
"               In .vimrc, add the following:
"                   filetype plugin on
"                   let g:pydiction_location = 'path/to/complete-dict'
"               Optionally, you set the completion menu height like:
"                   let g:pydiction_menu_height = 20
"               The default menu height is 15
"               To do case-sensitive searches, set noignorecase (:set noic).
" License: BSD
" Copyright: Copyright (c) 2003-2009 Ryan Kulla
"            All rights reserved.
"
"            Redistribution and use in source and binary forms, with or without
"            modification, are permitted provided that the following conditions
"            are met:
"            1. Redistributions of source code must retain the above copyright
"               notice, this list of conditions and the following disclaimer.
"            2. Redistributions in binary form must reproduce the above
"               copyright notice, this list of conditions and the following
"               disclaimer in the documentation and/or other materials provided
"               with the distribution.
"            3. The name of the author may not be used to endorse or promote 
"               products derived from this software without specific prior 
"               written permission.
"
"            THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
"            OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
"            WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
"            ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
"            DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
"            DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
"            GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
"            INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
"            WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
"            NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
"            THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"
"

if v:version &lt; 700
    echoerr "Pydiction requires vim version 7 or greater."
    finish
endif


" Make the Tab key do python code completion:
inoremap &lt;silent&gt; &lt;buffer&gt; &lt;Tab&gt; 
         \&lt;C-R&gt;=&lt;SID&gt;SetVals()&lt;CR&gt;
         \&lt;C-R&gt;=&lt;SID&gt;TabComplete()&lt;CR&gt;
         \&lt;C-R&gt;=&lt;SID&gt;RestoreVals()&lt;CR&gt;


if !exists("*s:TabComplete")
    function! s:TabComplete()
        " Check if the char before the char under the cursor is an 
        " underscore, letter, number, dot or opening parentheses.
        " If it is, and if the popup menu is not visible, use 
        " I_CTRL-X_CTRL-K ('dictionary' only completion)--otherwise, 
        " use I_CTRL-N to scroll downward through the popup menu.
        " If the char is some other character, insert a normal Tab:
        if searchpos('[_a-zA-Z0-9.(]\%#', 'nb') != [0, 0] 
            if !pumvisible()
                return "\&lt;C-X&gt;\&lt;C-K&gt;"
            else
                return "\&lt;C-N&gt;"
            endif
        else
            return "\&lt;Tab&gt;"
        endif
    endfunction
endif


if !exists("*s:SetVals") 
    function! s:SetVals()
        " Save and change any config values we need.

        " Temporarily change isk to treat periods and opening 
        " parenthesis as part of a keyword -- so we can complete
        " python modules and functions:
        let s:pydiction_save_isk = &amp;iskeyword
        setlocal iskeyword +=.,(

        " Save any current dictionaries the user has set:
        let s:pydiction_save_dictions = &amp;dictionary
        " Temporarily use only pydiction's dictionary:
        let &amp;dictionary = g:pydiction_location

        " Save the ins-completion options the user has set:
        let s:pydiction_save_cot = &amp;completeopt
        " Have the completion menu show up for one or more matches:
        let &amp;completeopt = "menu,menuone"

        " Set the popup menu height:
        let s:pydiction_save_pumheight = &amp;pumheight
        if !exists('g:pydiction_menu_height')
            let g:pydiction_menu_height = 15
        endif
        let &amp;pumheight = g:pydiction_menu_height

        return ''
    endfunction
endif


if !exists("*s:RestoreVals")
    function! s:RestoreVals()
        " Restore the user's initial values.

        let &amp;dictionary = s:pydiction_save_dictions
        let &amp;completeopt = s:pydiction_save_cot
        let &amp;pumheight = s:pydiction_save_pumheight
        let &amp;iskeyword = s:pydiction_save_isk

        return ''
    endfunction
endif
</t>
<t tx="ekr.20090728090618.2847">@nocolor
Pydiction 1.0 by Ryan Kulla (http://www.vim.org/scripts/script.php?script_id=850)
-------------

Pydiction is a filetype plugin for python files to be able to tab-complete Python code, including Python's keywords, standard library and even third-party libraries.  

It consists of three main files: 
    python_pydiction.vim -- This is the ftplugin you put in your non-system ftplugin directory. (i.e., ~/.vim/after/ftplugin/, on Unix or C:\vim\vimfiles\ftplugin\, on Windows)
    complete-dict -- This is a vim dictionary file that consists of Python keywords and modules. This is what python_pydiction.vim looks at to know which things are completeable.
    pydiction.py -- This is a Python script that was used to generate complete-dict. You can optionally run this script to add more modules to complete-dict to be able to complete them.


Installing
----------
Unix/Linux: Put python_pydiction.vim in ~/.vim/after/ftplugin/   (if that directory doesn't exist, create it. Vim will know to look there automatically.)
Windows: Put python_pydiction.vim in C:\vim\vimfiles\ftplugin  (assuming you installed vim in C:\vim\).

You may install the other files (complete-dict and pydiction.py) anywhere you want. For this example, we'll assume you put them in "C:\vim\vimfiles\ftplugin\pydiction\" (Do not put any file but python_pydiction.vim in the ftplugin\ directory, only .vim files should go there. It's ok to make a subdirectory in it though, like I just did.)

In your .vimrc file, first add the following line to enable filetype plugins:

    filetype plugin on

then make sure you set "g:pydiction_location" to the full path of where yo uinstalled complete-dict. Ie:

    let g:pydiction_location = 'C:/vim/vimfiles/ftplugin/pydiction/complete-dict'

You can optionally set the height of the completion menu by setting "g:pydiction_menu_height" in your vimrc. The default height is 15:

    let g:pydiction_menu_height = 20

By default, pydiction ignores case while doing Tab-completion. If you want it to do case-sensitive searches, then set noignorecase (:set noic).


Pydiction versus other forms of completion 
------------------------------------------
Pydiction can complete Python Keywords, as well as Python module names, and their attributes and methods. It can also complete both the fully-qualified module names such as "module.method(", as well as non-fully qualified names such as "method(".

Pydiction only uses the Tab-key to complete, uses a special dictionary file to complete from, and only attempts to do it on python files. This has the advantages of only requiring one keystroke to do completion and of not polluting all of your completion menus that you may be using for other types of completion, such as Vim's regular omni-completion, or other completion scripts that you may be running.

Since pydiction uses a dictionary file of possible completion items, it can complete 3rd party modules much more accurately than other ways. You have full control over what it can and can't complete. If it's unable to complete anything you can either use pydiction.py to automatically add a new module's contents to the dictionary or you can even manually add them using a text editor. The dictionary is just a normal text file, which also makes it portable across all platforms.  For example, if you're a PyQT user, you can add all the PyQT related modules to the dictionary file (complete-dict) by using pydiction.py.

Also, because pydiction uses a dictionary file, You don't have to import a module before you can complete it. Nor do you even have to have the module installed. This frees you up to use pydiction as a way of looking up what a module attribute is called without having to install it first.

Pydiction is smart enough to know when you're completing callable method or not and if you are, it will automatically insert an opening parentheses for you.

The Tab key will work as normally expected for everything else. Pydiction will only try to use it to complete python code if you're editing a python file and you first type part of some python code, as specified in complete-dict.

Pydiction doesn't even require that python support be compiled into your version of vim!

python_pydiction.vim
--------------------
Pydiction will make it so your the Tab key on your keyboard is able to complete python code (as long as the functionality has been added to complete-dict).

Version 1.0 of pydiction uses a new file called python_pydiction.vim, which is an ftplugin that only activates when you're editing a python file (e.g., you're editing a file with a ".py" extension or you've manually typed ":set filetype=python").  Past versions of pydiction didn't use a plugin and instead just required you to change the value of "isk" in your .vimrc, which was not desirable. Version 1.0 and greater do not require you to manually change the value of isk, it changes it for you safely by only setting it while you're doing tab completion (of python code only), and automatically changes isk back to its original value whenever tab completion isn't being activated.

Pydiction works by using Vim's omni-completion functionality by temporarily remapping the Tab key to do the same thing as I_CTRL-X_CTRL_K (dictionary only completion). This means, whenever you're editing a Python file and you start typing the name of a python keyword or module, you can press the Tab key to complete it. For example, if you type "os.pa" and then press Tab, pydiction will pop up a completion menu in vim that will look like:
    os.pardir
    os.path
    os.pathconf(
    os.pathconf_names
    os.path.
    os.path.__all__
    os.path.__builtins__
    os.path.__doc__
    ...
Pressing Tab again while the menu is open will scroll down the menu so you can choose whatever item you want to go with, using the normal omni-completion keys:
    &lt;Ctrl-y&gt; will accept the current word.
    &lt;Space&gt; will accept the current word and insert a space.
    &lt;Ctrl-e&gt; will close the menu and not accept any word.

pydiction.py
------------
This is the Python script used to create the "complete-dict" vim dictionary file.  I have created and bundled a default complete-dict for your use. I created it in Ubuntu 9.04 Linux, so there won't be any win32 specific support in it. You're free to run pydiction.py to add as many more modules as you want.  The dictionary file will still work if you're using windows, but it won't complete win32 related modules unless you tell it to.      

Usage: In a command prompt, run: 
    $ python pydiction.py &lt;module&gt; ... [-v]
You have to have python 2.x installed.


Say you wanted to add a module called "mymodule" to complete-dict, do the following:
    $ python pydiction.py mymodule

You can input more than one module name on the command-line, just separate them by spaces:
    $ python pydiction.py mymodule1 mymodule2 mymodule3

The -v option will just write the results to stdout (standard output) instead of the complete-dict file.

If the backfup file "complete-dict.last" doesn't exist in the current directory, pydiction.py will create it for you. You should always keep a backup of your last working dictionary in case anything goes wrong, as it can get tedious having to recreate the file from scratch.

If complete-dict.last already exists, pydiction will ask you if you want to overwrite your old backup with the new backup.

If you try to add a module that already exists in complete-dict, pydiction will tell you it already exists, so don't worry about adding duplicates. In fact, you can't add duplicates, everytime pydiction.py runs it looks for and removes any duplicates in the file.

When pydiction adds new modules to complete-dict, it does so in two phases. First, it adds the fully-qualified name of the module. For example:
    module.attribute
    module.method(

then it adds the non-fully qualified name:
    attribute
    method(

this allows you to complete your python code the way that you imported it in the first place. E.g.:
    import module
or:
    from module import method

Say you want to complete "pygame.display.set_mode". If you imported Pygame using "import pygame", then you can Tab-complete using:
    pygame.di&lt;Tab&gt;
to expand to "pygame.display.". Then type:
    se&lt;Tab&gt; 
to expand to "pygame.display.set_mode("

Now say you imported using "from pygame import display". To expand to "display.set_mode(" just type:
    display.se&lt;Tab&gt;

And if you imported using "from pygame.display import set_mode" just type:
    se&lt;Tab&gt;

Keep in mind that if you don't use fully-qualified module names that you may get a lot of possible menu options popping up and so you may want to use more than just two letters to try to narrow it down. 


complete-dict
-------------
Again, this is the vim dictionary file that python_pydiction.vim reads from and pydiction.py writes to. Without this file, pydiction wouldn't know what python keywords and modules it can Tab-complete.

complete-dict is only an optional file in the sense that you can create your own if you don't want to use the default one that is bundled with pydiction.  The default complete-dict gives you a major headstart as far as what you can Tab-complete because I did my best to put all of the Python keywords, standard library and some popular third party modules in it for you. 

It currently contains:

    Python keywords:

        and       del       for       is        raise    
        assert    elif      from      lambda    return   
        break     else      global    not       try      
        class     except    if        or        while    
        continue  exec      import    pass      yield    
        def       finally   in        print
    
    Most of the standard library and builtins:  __builtin__, __future__, os, sys, time, re, sets, string, math, Tkinter, hashlib, urllib, etc... 

    It also contains some popular third-party libraries: pygame, wxPython, twisted, numarray and OpenGL.

If you open complete-dict in your text editor you'll see sections in it for each module, such as:
 
    --- os module with "os." prefix ---
    os.EX_CANTCREAT
    os.EX_CONFIG
    os.EX_DATAERR
    ...

    --- os module without "os." prefix ---
    EX_CANTCREAT
    EX_CONFIG
    EX_DATAERR
    ...

if certain attributes seem to be missing, it's probably because pydiction removed them because they were duplicates. This mainly happens with the non-fully qualified module sections. So first try searching the entire file for whatever string you assume is missing before you try adding it. For example, if you don't see "__doc__" under "--- sys module without "sys." prefix ---", it's because a previous module, such as "os" already has it.
    
If you try to recreate complete-dict from scratch, you'll need to manually add the Python keywords back to it, as those aren't generated with pydiction.py.

</t>
<t tx="ekr.20090728090618.2848">"""Process the command line."""

if sys.version_info[0:2] &lt; (2, 3):
    sys.exit("You need a Python 2.x version of at least Python 2.3")

if len(sys.argv) &lt;= 1:
    sys.exit("%s requires at least one argument. None given." % 
              sys.argv[0])

if '-v' in sys.argv:
    write_to = sys.stdout
    sys.argv.remove('-v')
elif os.path.exists(PYDICTION_DICT):
        # See if any of the given modules have already been pydiction'd:
        f = open(PYDICTION_DICT, 'r')
        file_lines = f.readlines()
        for module_name in sys.argv[1:]:
            for line in file_lines:
                if line.find('--- %s module with' % module_name) != -1:
                    print '"%s" already exists in %s. Skipping...' % \
                           (module_name, PYDICTION_DICT)
                    sys.argv.remove(module_name)
                    break
        f.close()

        if len(sys.argv) &lt; 2:
            # Check if there's still enough command-line arguments:
            sys.exit("Nothing new to do. Aborting.")

        if os.path.exists(PYDICTION_DICT_BACKUP):
            answer = get_yesno('Overwrite existing backup "%s" [Y/n]? ' % \
                                PYDICTION_DICT_BACKUP)
            if (answer):
                print "Backing up old dictionary to: %s" % \
                       PYDICTION_DICT_BACKUP
                try:
                    shutil.copyfile(PYDICTION_DICT, PYDICTION_DICT_BACKUP)
                except IOError, err:
                    print "Couldn't back up %s. %s" % (PYDICTION_DICT, err)
            else:
                print "Skipping backup..."

            print 'Appending to: "%s"' % PYDICTION_DICT
        else:
            print "Backing up current %s to %s" % \
                   (PYDICTION_DICT, PYDICTION_DICT_BACKUP)
            try:
                shutil.copyfile(PYDICTION_DICT, PYDICTION_DICT_BACKUP)
            except IOError, err:
                print "Couldn't back up %s. %s" % (PYDICTION_DICT, err)
else:
    print 'Creating file: "%s"' % PYDICTION_DICT

write_to = open(PYDICTION_DICT, 'a')

main(write_to)</t>
<t tx="ekr.20090728090618.2849">"""

pydiction.py 1.0 by Ryan Kulla (rkulla AT gmail DOT com).

Description: Creates a Vim dictionary of Python module attributes for Vim's 
             completion feature.  The created dictionary file is used by
             the Vim ftplugin "python_pydiction.vim".

Usage: pydiction.py &lt;module&gt; ... [-v]
Example: The following will append all the "time" and "math" modules'
         attributes to a file, in the current directory, called "pydiction"
         with and without the "time." and "math." prefix:
             $ python pydiction.py time math
         To print the output just to stdout, instead of appending to the file, 
         supply the -v option: 
             $ python pydiction.py -v time math

License: BSD.
"""
</t>
<t tx="ekr.20090815161520.1815">Reasonable values are iconclick2, icondclick2 and select2.

When using select2, you may want to use the detach-editor-toggle command.
</t>
<t tx="ekr.20091010091628.1836">@language python

'''Create a script button that will search for the icon-like
pattern in the selected node'''

from leo.plugins import mod_scripting as scripting

script = p.b + '\n'

sc = g.app.gui.ScriptingControllerClass(c)

shortcut = sc.getShortcut(p.h)
statusLine = 'pattern find button'
if shortcut: statusLine = '%s = %s' % (statusLine,shortcut)

patC = patController(c,script)
script = patC.setup() # Modify the script

sc.createAtButtonHelper(p,p.h,statusLine,shortcut,verbose=False)
</t>
<t tx="ekr.20091010091628.1837"># This will be done automatically.
import sys
import string
path = r'c:\python25\lib\site-customize\matching'
if path not in sys.path: sys.path.append(path)
from matching.patterns_b import *
from matching.textpatterns_b import *
from matching.MatchingInput import *

print '*' * 20
subject = MatchingInput (p.b) #"abcdefgh23;ijklmn")
while True:
    if subject ^ AnyOfP (string.letters) [4] &gt;&gt; "four letters":
       print "found four letters: \"" + subject ["four letters"] + "\""
    elif subject ^ AnyOfP (string.digits) [2:] &gt;&gt; "the digits" &amp; IsP (";"):
       print "found two or more digits followed by a semicolon: \"" + \
             subject ["the digits"] + "\""
    elif subject ^ AnyOfP (string.letters) [1:3] &gt;&gt; "1 2 3 letters":
       print "found less than four letters: \"" + \
             subject ["1 2 3 letters"] + "\""
    else: break
</t>
<t tx="ekr.20091010104145.1840">class patController:
    
    '''A class supporting icon-like find scripts using
    a very-slightly modified version of library at
    http://www.wilmott.ca/python/patternmatching.html'''
    
    @others</t>
<t tx="ekr.20091010104145.1842">def __init__ (c,script,forward=True):
    
    self.c = c
    self.v = c.p.v # The node containing the find-script to be applied.
    self.script = script # Will be modified in setup.</t>
<t tx="ekr.20091010104145.1843">def setup(self):
    
    pass</t>
<t tx="ekr.20091010104145.1844">def driver (self,forward=True):
    
    '''Search for the pattern in p and all following nodes
    until a match is found.'''
    
    if forward:
        while p:
            i = self.find(p)
            if i == -1:
                p.moveToThreadNext()
            else:
                self.select(p,i) ; break
    else:
        while p:
            i = self.findr(p)
            if i == -1:
                p.moveToThreadBack()
            else:
                self.select(p,i) ; break</t>
<t tx="ekr.20091010104145.1845">def find (self,p):
    
    '''Search for self.pattern in p.
    If p is the presently selected node, start at the cursor position.
    Otherwise, start at the start of the node.
    '''</t>
<t tx="ekr.20091010104145.1846"></t>
<t tx="ekr.20091011110344.1853">import string
import sys
path = r'c:\python25\lib\site-customize\matching'
if path not in sys.path: sys.path.append(path)
from matching.patterns_b import *
from matching.textpatterns_b import *
from matching.MatchingInput import *

def find(p):
    s = MatchingInput (p.b)
    while True:
        g.trace(s.Pos)
        if s ^ AnyOfP (string.letters) [4] &gt;&gt; 'pat':
            found = 'AnyOfP (letters) [4]'
        elif s ^ AnyOfP (string.digits) [2:] &gt;&gt; 'pat' &amp; IsP (';'):
            found = 'AnyOfP(digits)[2:]'
        elif s ^ AnyOfP (string.letters) [1:3] &gt;&gt; 'pat':
            found = 'AnyOfP (letters) [1:3]'
        else:
            found = False
        if found:
            pat = s['pat']
            print ('found: %s --&gt; %s' % (found,pat))
            yield s.Pos,pat
        else:
            raise StopIteration

print '*'*20
while p:
    print '----- searching',p.h
    for pos,pat in find(p):
        print pos,pat
    p.moveToThreadNext()
print('done')
</t>
<t tx="ekr.20091013153026.2721">@
This work has been mostly abandoned.

The idea was to use icon-like patterns, based on
http://www.wilmott.ca/python/patternmatching.html

There are several problems with this approach:
    
1. This library, while elegant, isn't necessarily so useful.
   Indeed, the typical "find script" in scripts.leo uses
   either the string method s.find (or s.findr) or similar
   g.match methods.
   
2. Unlike the python regex module, there do not appear to
   be the equivalent of search or findall methods.  This
   means that the search code must either
   a) step through the search string explicitly or 
   b) use more complicated search patterns that match anywhere.
   
3. Search scripts are typically more complex than other @button scripts.
   The search scripts in scripts.leo avoid this problem by doing all
   the replacements at once, without prompts.
   
State of the prototype code:
    
- \@button find script a kinda works, but it only finds patterns at
  the start of body text.  It does shows that generators are useful.
  
- \@button create find button doesn't do anything, and it's not clear
  that is can ever be extended to be useful.
  
  The idea of this button was that clicking on a node, say "pat a",
  containing an icon-like script, would create *another* @button node,
  say "@button pat-find pat a" that would (interactively?) find all
  nodes matched by the script in "pat a".  This isn't going to be easy.</t>
<t tx="ekr.20091217210235.1866">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20091229092257.1930">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20091229101227.1902">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20091230064146.1911"># For xml-tags-test.xml
xml
test.a
test-b

# For layout.html
html
body
head
py:if
py:match
script
</t>
<t tx="ekr.20091230064146.1912">@language xml
@tabwidth -4
@others
</t>
<t tx="ekr.20091230081322.1919">import unicodedata as u
table = ('a','9','_',':','.',)
table2 = (
    (0xc0,0xd6),(0xd8,0xf6),(0xf8,0x2ff),(0x370,0x37d),(0x37f,0x1fff),
    (0x200c,0x200d),(0x2070,0x218f),(0x2c00,0x2fef),(0x3001,0xd7ff),
    (0xf900,0xfdcf),(0xfdf0,0xfffd),(0x10000,0xeffff),
    # Valid only after the start of a word.
    (0xb7,0xb7+1),(0x0300,0x036f),(0x203f,0x2040),
)
for ch in table:
    ch = g.u(ch)
    g.es(ch,u.category(ch))
for i,j in table2:
    g.es('*** range %xd %xd' % (i,j))
    for n in range(i,min(i+5,j)):
        if g.isPython3: ch = chr(n)
        else: ch = unichr(n)
        g.es(ch,u.category(ch))</t>
<t tx="ekr.20091230090645.1925">@language xml
@tabwidth -4
@others
</t>
<t tx="ekr.20091230121016.1931"></t>
<t tx="ekr.20091230160238.1922">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20100103112623.1951"># This script insert a raw form-feed into the Leo outline.
# Leo's atFile write code should remove this.
s = p.b
p.b = s + '\n#\f'

# 
# </t>
<t tx="ekr.20100108090658.1958">&lt;&lt; imports&gt;&gt;
&lt;&lt; constants &gt;&gt;

@others

ec = leoEditCommands.editCommandsClass
table = (
    (ec,'next-line','Down'),
    (ec,'previous-line','Up'),
    (ec,'next-line-extend-selection','Shift+Down'),
    (ec,'previous-line-extend-selection','Shift+Up'),
)

for theClass,command,stroke in table:
    overrideCommand(command,theClass,stroke)

# testKeys()

# aa
</t>
<t tx="ekr.20100108090658.1959">@nocolor-node
@

For a list of official key symbols, see
http://doc.trolltech.com/4.4/qt.html#Key-enum

QKeyEvent::QKeyEvent (
    Type type, int key,
    Qt::KeyboardModifiers modifiers,
    const QString &amp; text = QString(),
    bool autorep = false, ushort count = 1 )

Modifiers
Qt::NoModifier	0x00000000	    No modifier key.
Qt::ShiftModifier	0x02000000	  A Shift key on the keyboard.
Qt::ControlModifier	0x04000000  A Ctrl key on the keyboard.
Qt::AltModifier	0x08000000	  An Alt key on the keyboard.
Qt::MetaModifier	0x10000000	  A Meta key on the keyboard.
</t>
<t tx="ekr.20100108102030.1962">import PyQt4.QtCore as QtCore
import PyQt4.QtGui as QtGui
Qt = QtCore.Qt

import leo.core.leoEditCommands as leoEditCommands</t>
<t tx="ekr.20100108102030.1963">noMod = Qt.NoModifier
shift = Qt.ShiftModifier
ctrl  = Qt.ControlModifier
alt   = Qt.AltModifier
meta  = Qt.MetaModifier</t>
<t tx="ekr.20100108102217.1966">def overrideCommand(command,theClass,stroke): # mods,key):

    qtKey,qtMods = setKeyAndMods(stroke)

    # Do the actual override
    f = c.commandsDict.get(command)
    if f:
        # Capture the lambda bindings.
        def qt_command_callback(self,event=None,qtKey=qtKey,qtMods=qtMods):
            g.trace(event,command,stroke)
            text=''
            qtKey = QtGui.QKeyEvent(QtCore.QEvent.KeyPress,qtKey,qtMods,text)
            w = c.frame.body.bodyCtrl.widget ### should be event.widget
            QtCore.QCoreApplication.sendEvent(w,qtKey)

        callback = qt_command_callback
        # g.trace(id(f),command,stroke)
        adjustBindings(command,callback,f,stroke,theClass)

    else:
        g.trace('no such command:',command)



</t>
<t tx="ekr.20100108102217.1967">def setKeyAndMods(stroke):

    d = {'Up':Qt.Key_Up,'Down':Qt.Key_Down,}

    mods = stroke.split('+')
    key = mods[-1]
    mods = mods[:-1]

    qtMods = Qt.NoModifier
    if mods:
        for mod in mods:
            mod = mod.lower()
            if mod.startswith('s'):
                qtMods |= Qt.ShiftModifier
            elif mod.startswith('c'):
                qtMods |= Qt.ControlModifier
            elif mod.startswith('a'):
                qtMods |= Qt.AltModifier
            elif mod.startswith('m'):
                qtMods |= Qt.MetaModifier
            else:
                tags.append('Unknown modifier: %s' % mod)

    qtKey = d.get(key,key)
    return qtKey,qtMods
</t>
<t tx="ekr.20100108102217.1968">def testKeys():

    table = (
        (ord('a'),noMod,'a'),
        (Qt.Key_Up,shift,''),
    )

    # Put new characters at end.
    w = c.frame.body.bodyCtrl
    w.setInsertPoint('end')

    for key,mod,text in table:
        key = QtGui.QKeyEvent(QtCore.QEvent.KeyPress,key,mod,text)
        for w in (
            # c.frame.top, # a DynamicWindow. Nothing happens.
            c.frame.body.bodyCtrl.widget,
            # c.frame.log.logCtrl.widget, # works
        ):
            QtCore.QCoreApplication.sendEvent(w,key)
</t>
<t tx="ekr.20100108111728.2076"># This will become something like k.replaceCommand

def adjustBindings (command,callback,f,stroke,theClass):

    # f is the *old* function, to be replaced by callback.
    trace = True and not g.unitTesting
    k = c.k
    g.funcToMethod(callback,theClass,name=f.__name__)
    if trace: g.trace('=====',command,id(f),f.__name__)


    stroke = c.k.shortcutFromSetting(stroke)
    bindStroke = c.k.tkbindingFromStroke(stroke)

    # Replace all entries for command in all bindings dicts...
    c.commandsDict [command] = None ### callback

    # k.masterGuiBindingsDict:
    # Keys are strokes; value is a list of widgets for which stroke is bound.
    k.masterGuiBindingsDict[bindStroke] = []

    # k.bindingsDict:
    # Keys are shortcuts;
    # values are *lists* of g.bunch(func,name,warningGiven)
    d = k.bindingsDict
    aList = d.get(stroke,[])
    if aList:
        result = []
        for b in aList:
            # g.trace(id(b.func),b.func.__name__)
            if b.func == f:
                if trace: g.trace('*** removing k.bindingsDict',stroke)
                ### b.func = callback
            else:
                result.append(b)
        d[stroke] = result

    # k.masterBindingsDict:
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts:  keys are strokes,
    # values are g.Bunch(commandName,func,pane,stroke)
    d = k.masterBindingsDict
    for key in list(k.masterBindingsDict.keys()):
        d2 = k.masterBindingsDict.get(key,{})
        b = d2.get(stroke,None)
        if b:
            # g.trace(b.pane,id(b.func),b.func.__name__)
            if b.func == f:
                if trace: g.trace('*** removing k.masterBindingsDict',stroke)
                b.func = callback
                d2[stroke] = None ### b
</t>
<t tx="ekr.20100108111728.2077">@nocolor-node

@
c.commandsDict:
    Keys are emacs command names; values are functions f.

k.inverseCommandsDict:
    Keys are f.__name__; values are emacs command names.

k.bindingsDict:
    Keys are shortcuts; values are *lists* of g.bunch(func,name,warningGiven)

k.masterBindingsDict:
    Keys are scope names: 'all','text',etc. or mode names.
    Values are dicts:  keys are strokes, values are g.Bunch(commandName,func,pane,stroke)

k.masterGuiBindingsDict:
    Keys are strokes; value is a list of widgets for which stroke is bound.

k.settingsNameDict:
    Keys are lowercase settings; values are 'real' Tk key specifiers.
    Important: this table has no inverse.

not an ivar (computed by k.computeInverseBindingDict):

inverseBindingDict
    Keys are emacs command names; values are *lists* of shortcuts.
</t>
<t tx="ekr.20100109081612.1984">import PyQt4.QtGui as QtGui

w = c.frame.body.bodyCtrl.widget
w.moveCursor(QtGui.QTextCursor.Up)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20100109081746.1988">import PyQt4.QtGui as QtGui

w = c.frame.body.bodyCtrl.widget
w.moveCursor(QtGui.QTextCursor.Down)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20100109081746.1990">import PyQt4.QtGui as QtGui

w = c.frame.body.bodyCtrl.widget
w.moveCursor(QtGui.QTextCursor.Up,QtGui.QTextCursor.KeepAnchor)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20100109081746.1992">import PyQt4.QtGui as QtGui

w = c.frame.body.bodyCtrl.widget
w.moveCursor(QtGui.QTextCursor.Down,QtGui.QTextCursor.KeepAnchor)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20100109081746.1993">import PyQt4.QtGui as QtGui

w = c.frame.body.bodyCtrl.widget
cursor = w.textCursor()
cursor.movePosition(QtGui.QTextCursor.Up,QtGui.QTextCursor.KeepAnchor,15)
w.setTextCursor(cursor)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20100109084336.1996"></t>
<t tx="ekr.20100110151049.2004">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20100110172917.1916"></t>
<t tx="ekr.20100110172917.1917">section 2

</t>
<t tx="ekr.20100110172917.1918">.. rst3: filename: html\intro.html

</t>
<t tx="ekr.20100110172917.1919">Leo is a power tool for people who want to organize, study and work with data,
especially complex data like computer programs, books, web sites and data bases.
Superficially, Leo may look like other outlining programs, code folding editors
or class browsers, but it most certainly is not.

People say Leo is a revolutionary tool, and that Leo is fun to use, even
additive. There is a unique "Leo way" of managing data; the term **Leonine**
describes how people treat data in "the world according to Leo". Leo definitely
takes a bit of work to understand. Leo's users speak of an "Aha" moment, when
they see how these pieces fit together: outline structure is significant
everywhere.

Leo is freely available in source or binary form for all major platforms. You
may download Leo from http://sourceforge.net/projects/leo/files/Leo/ Leo is Open
Software and may be freely distributed.

`Leo's home page`_ contains additional documentation and links to other
resources. For another introduction to Leo, open the file quickstart.leo in the
leo/doc folder.

This tutorial introduces the reader to the basic concepts and features of Leo.
It helps to have Leo running for hands-on experience, but all examples here are
self-contained, so the tutorial can be read off-line as well.
See `Leo's Installation Guide`_. for detailed installation instructions. If you
have problems installing Leo, please ask for help on `Leo's help forum`_. 

This tutorial does not attempt to be comprehensive and cover every single
feature of Leo, or even every commonly used feature. Instead, it introduces many
of Leo's most noteworthy features, and will give you a good idea of Leo's flavor
and style. After reading it, you will be able to use Leo in basic ways to create
external files, organize data and run simple scripts. You will then be ready to
learn more about Leo's many advanced features in `Leo's Users Guide`_.

.. The :ref:`glossary` is also worth going through.

.. contents::

.. Links used in this document...

.. ----- External references.

.. _`LaTeX`:                    http://www.latex-project.org/
.. _`Leo's help forum`:         http://groups.google.com/group/leo-editor-users
.. _`Leo's home page`:          http://webpages.charter.net/edreamleo/front.html
.. _`Literate Programming`:     http://www.literateprogramming.com/
.. _`MySQL`:                    http://www.mysql.com/
.. _`noweb`:                    http://www.eecs.harvard.edu/~nr/noweb/
.. _`Python`:                   http://www.python.org/
.. _`reStructuredText`:         http://docutils.sourceforge.net/rst.html
.. _`XML`:                      http://en.wikipedia.org/wiki/XML

.. ----- Relative links....

.. _`external file`:        `external files`_
.. _glossary:               glossary.html
.. _`Good style and bad`:   `style`_
.. _outline:                `Leo's main window`_
.. _outlines:               `Leo's main window`_
.. _plugin:                 `extending`_
.. _plugins:                `extending`_
.. .. _quickstart:             `Quick start for programmers`_
.. _scripts:                `scripting`_
.. _settings:               `config`_
.. _`Configuring Leo`:      `config`_

.. ----- References to other chapters.

.. _`What people are saying about Leo`:             testimonials.html
.. _`@@auto trees`:                                  directives.html#auto-trees
.. _command:                                        commands.html
.. _commands:                                       commands.html
.. _directive:                                      directives.html
.. _directives:                                     directives.html
.. _`Leo directives`:                               directives.html
.. _`editing commands`:                             commands.html#the-edit-menu
.. _front:                                          front.html
.. _`install Leo`:                                  install.html
.. _`launch Leo`:                                   install.html#running-leo
.. _`Leo's Users Guide`:                            leo_TOC.html
.. _`Leo's Installation Guide`:                     install.html
.. _`Chapter 4: Writing Programs in Leo`:           directives.html
.. _`Chapter 5: Using Leo's Commands`:              commands.html
.. _`Chapter 6: Leo and Literate Programming`:      design.html
.. _`Chapter 7: Scripting Leo with Python`:         scripting.html
.. _`Chapter 8: Customizing Leo`:                   customizing.html

.. ----- References to the glossary

.. _`@@auto`:                    glossary.html#auto
.. _`@file`:                    glossary.html#file
.. _`@nosent`:                  glossary.html#nosent
.. _`@others`:                  glossary.html#others
.. _`@thin`:                    glossary.html#thin
.. _`@thin trees`:              glossary.html#thin-trees
.. _`body text`:                glossary.html#body-text
.. _ancestor:                   glossary.html#ancestor
.. _children:                   glossary.html#child
.. _clone:                      glossary.html#clone
.. _cloned:                     glossary.html#cloned
.. _cloning:                    glossary.html#clone
.. _clones:                     glossary.html#clones
.. _`code part`:                glossary.html#code-part
.. _`doc part`:                 glossary.html#doc-part
.. _descendant:                 glossary.html#descendant
.. _descendants:                glossary.html#descendants
.. _`doc part`:                 glossary.html#doc-part
.. _grandchildren:              glossary.html#grandchildren
.. _headline:                   glossary.html#headline
.. _headlines:                  glossary.html#headlines
.. _`organizer node`:           glossary.html#organizer-node
.. _`organizer nodes`:          glossary.html#organizer-nodes
.. _`outline order`:            glossary.html#outline-order
.. _node:                       glossary.html#node
.. _nodes:                      glossary.html#nodes
.. _reference:                  glossary.html#reference
.. _references:                 glossary.html#references
.. _root:                       glossary.html#root
.. _`root node`:   	            glossary.html#root
.. _section:                    glossary.html#section
.. _sections:                   glossary.html#section
.. _`section definition`:       glossary.html#section-definition
.. _`section definitions`:      glossary.html#section-definitions
.. _`section definition nodes`: glossary.html#section-definition-nodes
.. _`section name`:             glossary.html#section-name
.. _`section names`:            glossary.html#section-names
.. _`section reference`:        glossary.html#section-reference
.. _`section references`:       glossary.html#section-references
.. _siblings:                   glossary.html#siblings

.. For reasons unknown, this image must appear in the _images folder on the web site.
.. |leoMainWindow| image:: screen-shots/leo-qt-main-window.JPG

</t>
<t tx="ekr.20100110172917.1920">Let's start looking at Leo in detail. We'll start with what you see when you
first open Leo, Leo's main window. Leo's main window, shown below, represents an
entire project. As you can see, the main window contains three panes: the
**outline pane** at the top left, the **log pane** at the top right, and the
**body pane** at the bottom. The window also contains an **icon area** at the
very top, a **status area** and a **mini-buffer** at the very bottom.

|leoMainWindow|

The outline pane
    The outline pane shows your project as an outline. The outline
    contains all your project's data. An outline consists of **nodes**. The
    **icon box** is a small icon directly to the left of the headline text. If a
    node contains children, a smaller icon appears to the left of the icon box.
    This icon contains a '+' or '-' symbol. Clicking this **expansion box**
    expands or contracts the node.
    
Nodes
    Nodes have two parts, a **headline** and **body text**. The outline pane
    shows headlines. Selecting a headline selects the entire node; the node's
    body text appears in the body pane. Leo uses standard terminology to
    describe the relationships of nodes in an outline. We speak of **parent**
    nodes, **child** nodes, **ancestor** nodes and **descendant** nodes.

Body pane
    The body pane contains the body text of the node selected in the
    outline pane.

Log pane
    The log pane contains informational messages from Leo or your scripts.

Icon area Depending on what plugins are enabled, the icon area may contain
    buttons and other widgets that extend what Leo can do. The scripting plugin
    makes it easy to add buttons to the icon area.

Status area
    The status area shows the line and column containing the body text's cursor,
    and the **UNL** (Uniform Node Location), the path from the top of the outline
    to the selected node.  This path will change as you change outline nodes.

Mini-buffer
    You can type command and search strings in the minibuffer. It works much
    like the Emacs mini-buffer. To enter a command, type &lt;Alt-x&gt; followed by the
    command name and then &lt;return&gt;. To type a search string, type &lt;ctrl-f&gt;
    followed by the search string and then &lt;return&gt;. For full details, see
    `Chapter 5: Using Leo's Commands`_.

</t>
<t tx="ekr.20100110172917.1921">You can use Leo as fairly typical outliner. Play around with some of the
commands from the Outline menu:

- Click the expansion box of nodes to show and hide their children.

- The Insert Node command (Ctrl+I) inserts a new headline into the outline.

- The Cut Node command (Ctrl+Shift+X) deletes a headline and all its children,
  and copies the structure to clipboard - ready to paste with Paste Node command
  (Ctrl+Shift+V). Use the Copy Node command (Ctrl+Shift+C) to copy node to
  clipboard without deleting it from outline. Copy-paste command family works
  across different Leo documents.

- The Move Up (Ctrl+U), Move Down (Ctrl+D), Move Left (Ctrl+L) and Move Right
  (Ctrl+R) commands move the currently selected node, along with all its
  descendants.

- The Promote (Ctrl+}) command makes all the children of a headline siblings of
  the headline. The Demote (Ctrl+{) command makes all following siblings of a
  headline children of the headline.

- Move around the tree and expand/collapse nodes by pressing Alt + arrow keys.
  This also moves the focus to tree, so, after pressing Alt + arrow, you can
  move around by using arrow keys alone. Return the focus to the body control by
  pressing Enter.

- To edit the headline, use press Ctrl+H. This works regardless of whether body
  or headline has focus.

- We'll discuss the Clone Node command in the next section.

You enter body text for any node by selecting the node's headline in the outline
pane and then typing in the body pane. Leo has a full range of `editing
commands`_ that apply to the body pane.

</t>
<t tx="ekr.20100110172917.1922">.. _`external files`:

Leo stores outline data on your file system in **.leo files**. The format of
these files is `XML`_. You don't have to store all your data in .leo files: Leo
allows you to store parts of your outline data **external files**, that is,
other files on your file system.

**@file nodes** create external files. \@file nodes have headlines starting with
\@file followed by a file name. Some examples::

    @file leoNodes.py
    @file ../../notes.text
    
The file name can be an absolute path or a relative path to the file that starts
at Leo's **load directory**, the directory containing the .leo file.

Leo reads and writes external files automatically when you open or save your Leo
outline:

- When you open an outline (.leo file) Leo reads all the external files created
  by the \@file nodes in the outline. If you have changed an external file
  outside of Leo, Leo will update the corresponding \@file tree to reflect those
  changes when Leo next opens the outline.

- When you save your outline, Leo writes all **dirty** \@file nodes. An \@file
  is dirty if the node or any of its descendant nodes has changed.
  **Important**: When Leo writes an external file, Leo writes all the essential
  information in the \@file tree to the external file, *not* to the .leo file.
  The only nodes that gets written to the .leo file are nodes that are not
  contained in any \@file tree.

</t>
<t tx="ekr.20100110172917.1923">We come now to one of Leo's most important and unusual features. When Leo writes
an external file, it does so in a flexible manner, directed by **outline-based
markup**. This markup tells Leo exactly how to create the external file from an
\@file node.

The **obvious** way to write an external file would be to write the \@file node
itself followed by all the descendant nodes in **outline order** (the order in
which nodes appear in the outline). But Leo does *not* write external files
exactly this way.

Yes, Leo does indeed start by writing the \@file node itself. But Leo writes the
\@file node's descendants only only when it sees one of three kinds of Leo
markup: section references, the \@others directive and the \@all directive.
We'll discuss these three kinds of markup in the next section.

Section references and the \@others and \@all directives tell Leo to write the
**expansion** of one or more descendant nodes to the external file. Programmers
will recognize this process as akin to macro expansion. The following sections
will explain this process in detail.

</t>
<t tx="ekr.20100110172917.1924">A **section reference** is a line of body text of the form::

    &lt;&lt; a section name &gt;&gt;
    
Here, "a section name" can be any descriptive text not containing "&gt;&gt;". When Leo
encounters a section reference, Leo searches all the descendants of the node
containing the reference looking for a node whose headline matches the section
reference. That is, Leo looks for a descendant node whose headline starts with::

     &lt;&lt; a section name &gt;&gt;
     
We call such nodes **named nodes**. Leo doesn't require an exact match. Leo
ignores whitespace and the case of letters when comparing headlines to section
reference. Also, Leo ignores anything that may follow the section name in a
named node. For example, the following headline will match the section reference
above::

    &lt;&lt; A Section Name &gt;&gt; (to do)

If Leo does find a match, Leo *replaces* the section reference ("&lt;&lt; a section
name&gt;&gt;") by the *expansion* of the body text of the matched node. That is, Leo
replaces the section reference by the body text of the matched node, but Leo
**expands all markup** in the matched node *before* making the replacement. The
entire expansion of the matched node replaces the original section reference.
Programmers will recognize this process as recursive macro expansion.

We have just discussed what happens if Leo does find a descendant named node
that matches the section reference. If no such match is found the section
reference is said to be **undefined** and Leo does not write any data to the
external file. This is *not* a serious error: Leo will will save the erroneous
\@&lt;file&gt; tree in the .leo file instead of the external file. No information is
lost. By the way, Leo's syntax coloring will indicate undefined section
reference by underlining the section name.

**Important**: the indentation of section references matters. When expanding a
section reference, Leo indents every line of the expansion by the leading
whitespace that occurs before the section reference. Note also that you can't
write something after a section reference and expect it to end up on the same
line after expansion--Leo always writes a newline after the expansion.

</t>
<t tx="ekr.20100110172917.1925">The **@others directive** is the second (and most common) way of including
descendant nodes in an external files. When Leo encounters the \@others
directive it replaces the \@others directive by the *expansion* of all
**unnamed** descendant nodes. As with section references, Leo replaces all
markup in the descendant nodes, and the entire expansion replaces the \@others
directive.

In short, section references write *named* nodes; \@others directives write all
*unnamed* nodes. By the way, no node may contain more than one \@others
directive because there would be no way to "apportion" descendant nodes to more
than one \@others directive. However, nodes may contain as many section
references as you like.

As with section references, the indentation of the \@others directive matters.
This allows Leo to handle Python source code properly. For exmple, the following
is a common way of representing a Python class::

    class myClass:
        '''a docstring'''
        @others
        
When Leo writes this node to an external file, Leo will write the first two
lines to the external file, with the indentation in effect for the node. Leo
will then write all descendant nodes to the external files, with *additional*
indentation equal to the leading whitespace appearing before the \@others
directive.

</t>
<t tx="ekr.20100110172917.1926">The \@all directive is the third, simplest (and least common) way of including
descendant nodes. This directive causes Leo to write all descendant nodes in
outline order, regardless of whether they are named or not. Furthermore, the
\@all directive does not expand any markup in descendant nodes. This results in
Leo writing the external file in the "obvious" way. That is, Leo writes all
descendant nodes in outline order.

Use the all directive if your external file contains unrelated nodes. For
example, I use an external file to store programming notes. These notes
typically contain snippets of programming source code, but there is no real
relationships between the snippets--the file is simply a grab bag of
information. The \@all directive is designed for this situation.

</t>
<t tx="ekr.20100110172917.1927">.. _style:

Newcomers to Leo frequently ask when to use the \@others directive and when to
use sections. It is good style to use section references only when the order of
text within a external file matters. For example, Python programmers put
docstrings and imports at the start of files. So the body text of
\@file nodes typically look something like this::

    &lt;&lt; docstring &gt;&gt;
    @language python
    @tabwidth -4
    &lt;&lt; imports &gt;&gt;
    @others

This ensures that the docstring is first in the file, followed by imports,
followed by everything else. Note that the order in which functions are defined
in a file, or methods defined within a class, typically does *not* matter. Thus,
it is good style to define classes like this::

  class myClass:
        &lt;&lt; class attributes &gt;&gt;
        @others

It would be bad style to define a class like this::

  class myClass:
        &lt;&lt; class attributes &gt;&gt;
        &lt;&lt; method 1 &gt;&gt;
        &lt;&lt; method 2 &gt;&gt;
        ...

Not only does this over-specify the order in which methods are defined, but it
requires lots of extra typing. Not only must you add a line for each method, but
headlines must contain section names such as &lt;&lt; method 1 &gt;&gt;, &lt;&lt;method 2&gt;&gt;, etc.
When using \@others it is good style simply to put the name of each method in the
headline.

</t>
<t tx="ekr.20100110172917.1928">A few more words about style:

- It is good style to put each class, function or method in its own node. This
  makes it easy to see the shape of your code.

- It is good style to use organizer nodes to group related functions or methods.
  An organizer node has no content except maybe for comments. Like this::

    + myClass
        + birth and death
            + __init__
            etc.
        + getters
            etc.
        + setters
            etc.
        + misc methods
            etc.

  (In this notation, '+' denotes a headline.) This organization is far superior
  to using hideous comments like::

    ###########
    # Getters #
    ###########

- It is bad style to use \@others in organizer nodes. There is no need to do so.

- It is bad style to use \@others when order does matter. The reason is that it
  is very easy to move nodes in a tree by mistake, say by alphabetizing nodes.
  One wants to make the meaning of a external file immune from such movements.

One last word about style. The world won't end if you happen to use bad style by
mistake: you just might cause a bit more work for yourself than was strictly
necessary. Feel free to invent your own style of using Leo. Still, it would be
wise to "know the rules before you break them."

</t>
<t tx="ekr.20100110172917.1929">A **clone** is a node that appears in more than one place in a Leo outline.
Clones are marked with a small red arrow in the icon box. All clones of a node
are actually *the same node*, so any change to one clone affects all clones. For
example, inserting, moving or deleting any child of a clone will change all
other clones on the screen.

Please take a few moments to experiment with clones. Create a node whose
headline is A. Clone node A using the Clone Node command in Leo's Outline menu.
Type some text into the body of either clone of A. The same text appears in the
bodies of all other clones of A. Now insert a node, say B, as a child of any of
the A nodes. All the A nodes now have a B child. See what happens if you clone
B. See what happens if you insert, delete or move nodes that are children of A.
Verify that when you delete the penultimate clone, the last clone becomes a
regular node again.

Clones are much more than a cute feature. Clones allow multiple views of data to
exist **within a single outline**. With Leo, there is no such thing as a single,
"correct" view of data. You can have as many views of data as you like.

To create a new view of the data in your outline, just do the following:

1. Create an *ordinary* node, that will represent the view. We call these nodes
   **view nodes** merely to indicate they represent a view.
   
2. Clone all the nodes from the outline that you want the view to contain. Move
   these clones so they become children of the view node.
   
3. (Optional) You can add regular nodes as children of the view node too.
   
For example, when I fix a bug in Leo, I create an ordinary node to represent the
bug. This **bug node** is my view of all the data in Leo's source code that
relates to the bug. As I discover code related to the bug, I clone their nodes
and move them under the bug node. I'll also add ordinary nodes as children of
the bug node. These nodes contain the original bug report, descriptions of how I
fixed the bug, test data, or any other notes I might want to keep.

Once I have created the bug node, I concentrate *only* on that node and its
children. I can examine the bug node and its children without having to jump
around the outline. Everything I need is in one place. When I get around to
actually fixing the bug I can do so by changing the clones. Again, I do not have
to jump around the outline. It doesn't matter how big or complex the entire
outline is: I am only dealing with the bug node and its children. This extremely
narrow focus makes it *much* easier to fix bugs.

By the way, I never have to remember to save external files. When I change any
clone, Leo marks all instances of that clone throughout the entire outline as
dirty (changed). When I save the Leo outline, Leo automatically writes all the
external files that contain dirty nodes.

Views have an unlimited number of uses. Use them whenever you want to focus your
attention on some smaller set of nodes. For example, I often create view nodes
when studying other people's code. The view node helps me concentrate on just
the part of the code that interests me at the moment.

</t>
<t tx="ekr.20100110172917.1930">Leo's **directives** control such things as syntax coloring, line wrapping
within the body pane and the width of tabs. Leo directives may appear in
headlines or body text. Leo directives start with '@' in the leftmost column,
followed by the name of the directive. Here are some of Leo's directives::

    @language python
    @tabwidth -4
    @wrap
    @nowrap
    @color
    @nocolor
    @killcolor
    
Directives apply until overridden in a subtree. All of these directives apply to
the node they are contained in, and also to the entire tree of descendant nodes,
unless **over-ridden** by a similar directive in a descendant node. For example,
the directive::

    @language python
    
tells Leo to syntax color the node and all descendant nodes as Python code.
However, some descendant node mignt contain::

    @language rest
    
which tells Leo to color that node and all of *its* decendants as
reStructureText. This principle applies to almost all of Leo's directives: the
directive is in effect throughout a tree, unless overridden in some subtree.

- **\@color**, **\@nocolor** and **\@killcolor** control syntax coloring.

  You can mix \@nocolor and \@color directives in a single node, but these
  directives apply to descendant nodes only if they are **unambiguous**, that
  is, only if the ancestor node contains exactly one \@color or \@nocolor
  directive.

- **\@encoding** Sets the Unicode encoding used in external files.

- **\@first** directives orces lines to appear before the first sentinel of a
  external file.

    This directive may only appear in \@&lt;file&gt; nodes. A common use of \@first
    directives is to add shebang lines::
    
        @first #! /usr/bin/env python
        
    or Python encoding specifications::
    
        @first # -*- coding: utf-8 -*-

- **\@language** Sets the language used for syntax coloring **and** sets the
  comment delimiters used in sentinel lines and in doc parts. Some examples::

    @language python
    @language c
    @language rest # restructured text
    @language plain # text, that is, no syntax coloring.

- **\@last** Forces lines to appear after the last sentinel of a external file.

- **\@lineending** Specifies the line ending to be used in external files.

- **\@pagewidth** Sets the page width used to break doc parts into lines.

- **\@path** Sets the path to be prepended to filenames in descendant \@file
  nodes.

- **\@tabwidth** sets the width of tabs.

  Negative tab widths cause Leo to convert tabs to spaces and are highly
  recommended for Python programming.

- **\@wrap** and **\@nowrap** enable or disable line wrapping the Leo's body pane.

Leo treats lines starting with \@ as a normal code line unless the \@ starts a
Leo directive. In particular, Leo will output Python decorators correctly,
provided the name of the decorator does not conflict with a Leo directive.

</t>
<t tx="ekr.20100110172917.1931">.. _scripting:

Leo is fully scriptable using the Python language. Leo can execute any body text
as a Python script. To run the entire body text as a script, simply choose the
node and execute the Execute Script command (Ctrl+B). If text is selected, the
Execute Script command will run just the selected text as the script.

The Execute Script command **preprocesses** the script before executing it, in
exactly the same way that Leo writes external files. Leo expands section
references and processes \@others directives before executing the script. This
allows you to use all of Leo's outlining capabilities to organize your scripts.

Your Python scripts can easily access data in an outline. Leo's execute-script
(Ctrl-B) command predefines three variables, c, g and p, that scripts can use to
easily access any part of any Leo outline, and Leo's own source code. For
example, the following script will print all the headlines in an outline::

    for p in c.all_positions():
        print ' '*p.level(),p.h

The example above is only the beginning of what scripts can do. See `Chapter 7:
Scripting Leo with Python`_ for a complete discussion of scripting Leo.

.. _extending:

**Plugins** are Python modules that change how Leo works. Leo's user have
contributed dozens of plugins that have extended Leo's capabilities in many new
directions. The file leoPlugins.leo contains all plugins that are included in
Leo distributions.

.. _config:

Plugins and other parts of Leo can get options from **@settings** trees.
\@settings trees allow plugins to get options without any further support from
Leo's core code. For a full discussion of \@settings trees, see `Chapter 8:
Customizing Leo`_.

</t>
<t tx="ekr.20100110172917.1932">Using Leo quickly becomes second nature:

- You can use Leo like any ordinary outliner, as a filing cabinet, but Leo's
  clones makes this filing cabinet much more flexible and useful than usual.

- You create external files using \@file trees. Within \@file trees, you use
  section references and the \@others directive to tell Leo how to write nodes
  to the external file. Directives such as \@tabwidth and \@language provide other
  information to Leo. Leo's \@file trees allow you to organize your scripts
  and programs with Leo's outline structure.
  
- You can execute Python scripts from any node in a Leo outline. Leo scripts
  have full, easy, access to all the information in the outline. Using scripts
  and plugins, you can easily add new features to Leo.

</t>
<t tx="ekr.20100110172917.1933">LeoPyRef.leo (in the core subdirectory of the leo folder) contains almost all of
Leo's source code. It provides hundreds of examples of everything discussed
here. This file will repay close study. For full details on all aspects of Leo
see LeoDocs.leo or `Leo's Users Guide`_.

</t>
<t tx="ekr.20100110172917.1934">:Author: Richard Jones
:Version: $Revision: 5801 $
:Copyright: This document has been placed in the public domain.

.. contents::


The text below contains links that look like "(quickref__)".  These
are relative links that point to the `Quick reStructuredText`_ user
reference.  If these links don't work, please refer to the `master
quick reference`_ document.

__
.. _Quick reStructuredText: quickref.html
.. _master quick reference:
   http://docutils.sourceforge.net/docs/user/rst/quickref.html

.. Note:: This document is an informal introduction to
   reStructuredText.  The `What Next?`_ section below has links to
   further resources, including a formal reference.

</t>
<t tx="ekr.20100110172917.1935">From the outset, let me say that "Structured Text" is probably a bit
of a misnomer.  It's more like "Relaxed Text" that uses certain
consistent patterns.  These patterns are interpreted by a HTML
converter to produce "Very Structured Text" that can be used by a web
browser.

The most basic pattern recognised is a **paragraph** (quickref__).
That's a chunk of text that is separated by blank lines (one is
enough).  Paragraphs must have the same indentation -- that is, line
up at their left edge.  Paragraphs that start indented will result in
indented quote paragraphs. For example::

  This is a paragraph.  It's quite
  short.

     This paragraph will result in an indented block of
     text, typically used for quoting other text.

  This is another one.

Results in:

  This is a paragraph.  It's quite
  short.

     This paragraph will result in an indented block of
     text, typically used for quoting other text.

  This is another one.

__ quickref.html#paragraphs

</t>
<t tx="ekr.20100110172917.1936">(quickref__)

__ quickref.html#inline-markup

Inside paragraphs and other bodies of text, you may additionally mark
text for *italics* with "``*italics*``" or **bold** with
"``**bold**``".  This is called "inline markup".

If you want something to appear as a fixed-space literal, use
"````double back-quotes````".  Note that no further fiddling is done
inside the double back-quotes -- so asterisks "``*``" etc. are left
alone.

If you find that you want to use one of the "special" characters in
text, it will generally be OK -- reStructuredText is pretty smart.
For example, this lone asterisk * is handled just fine, as is the
asterisk in this equation: 5*6=30.  If you actually
want text \*surrounded by asterisks* to **not** be italicised, then
you need to indicate that the asterisk is not special.  You do this by
placing a backslash just before it, like so "``\*``" (quickref__), or
by enclosing it in double back-quotes (inline literals), like this::

    ``*``

__ quickref.html#escaping

.. Tip:: Think of inline markup as a form of (parentheses) and use it
   the same way: immediately before and after the text being marked
   up.  Inline markup by itself (surrounded by whitespace) or in the
   middle of a word won't be recognized.  See the `markup spec`__ for
   full details.

__ ../../ref/rst/restructuredtext.html#inline-markup

</t>
<t tx="ekr.20100110172917.1937">Lists of items come in three main flavours: **enumerated**,
**bulleted** and **definitions**.  In all list cases, you may have as
many paragraphs, sublists, etc. as you want, as long as the left-hand
side of the paragraph or whatever aligns with the first line of text
in the list item.

Lists must always start a new paragraph -- that is, they must appear
after a blank line.

**enumerated** lists (numbers, letters or roman numerals; quickref__)
  __ quickref.html#enumerated-lists

  Start a line off with a number or letter followed by a period ".",
  right bracket ")" or surrounded by brackets "( )" -- whatever you're
  comfortable with.  All of the following forms are recognised::

    1. numbers

    A. upper-case letters
       and it goes over many lines

       with two paragraphs and all!

    a. lower-case letters

       3. with a sub-list starting at a different number
       4. make sure the numbers are in the correct sequence though!

    I. upper-case roman numerals

    i. lower-case roman numerals

    (1) numbers again

    1) and again

  Results in (note: the different enumerated list styles are not
  always supported by every web browser, so you may not get the full
  effect here):

  1. numbers

  A. upper-case letters
     and it goes over many lines

     with two paragraphs and all!

  a. lower-case letters

     3. with a sub-list starting at a different number
     4. make sure the numbers are in the correct sequence though!

  I. upper-case roman numerals

  i. lower-case roman numerals

  (1) numbers again

  1) and again

**bulleted** lists (quickref__)
  __ quickref.html#bullet-lists

  Just like enumerated lists, start the line off with a bullet point
  character - either "-", "+" or "*"::

    * a bullet point using "*"

      - a sub-list using "-"

        + yet another sub-list

      - another item

  Results in:

  * a bullet point using "*"

    - a sub-list using "-"

      + yet another sub-list

    - another item

**definition** lists (quickref__)
  __ quickref.html#definition-lists

  Unlike the other two, the definition lists consist of a term, and
  the definition of that term.  The format of a definition list is::

    what
      Definition lists associate a term with a definition.

    *how*
      The term is a one-line phrase, and the definition is one or more
      paragraphs or body elements, indented relative to the term.
      Blank lines are not allowed between term and definition.

  Results in:

  what
    Definition lists associate a term with a definition.

  *how*
    The term is a one-line phrase, and the definition is one or more
    paragraphs or body elements, indented relative to the term.
    Blank lines are not allowed between term and definition.

</t>
<t tx="ekr.20100110172917.1938">(quickref__)

__ quickref.html#literal-blocks

To just include a chunk of preformatted, never-to-be-fiddled-with
text, finish the prior paragraph with "``::``".  The preformatted
block is finished when the text falls back to the same indentation
level as a paragraph prior to the preformatted block.  For example::

  An example::

      Whitespace, newlines, blank lines, and all kinds of markup
        (like *this* or \this) is preserved by literal blocks.
    Lookie here, I've dropped an indentation level
    (but not far enough)

  no more example

Results in:

  An example::

      Whitespace, newlines, blank lines, and all kinds of markup
        (like *this* or \this) is preserved by literal blocks.
    Lookie here, I've dropped an indentation level
    (but not far enough)

  no more example

Note that if a paragraph consists only of "``::``", then it's removed
from the output::

  ::

      This is preformatted text, and the
      last "::" paragraph is removed

Results in:

::

    This is preformatted text, and the
    last "::" paragraph is removed

</t>
<t tx="ekr.20100110172917.1939">(quickref__)

__ quickref.html#section-structure

To break longer text up into sections, you use **section headers**.
These are a single line of text (one or more words) with adornment: an
underline alone, or an underline and an overline together, in dashes
"``-----``", equals "``======``", tildes "``~~~~~~``" or any of the
non-alphanumeric characters ``= - ` : ' " ~ ^ _ * + # &lt; &gt;`` that you
feel comfortable with.  An underline-only adornment is distinct from
an overline-and-underline adornment using the same character.  The
underline/overline must be at least as long as the title text.  Be
consistent, since all sections marked with the same adornment style
are deemed to be at the same level::

  Chapter 1 Title
  ===============

  Section 1.1 Title
  -----------------

  Subsection 1.1.1 Title
  ~~~~~~~~~~~~~~~~~~~~~~

  Section 1.2 Title
  -----------------

  Chapter 2 Title
  ===============

This results in the following structure, illustrated by simplified
pseudo-XML::

    &lt;section&gt;
        &lt;title&gt;
            Chapter 1 Title
        &lt;section&gt;
            &lt;title&gt;
                Section 1.1 Title
            &lt;section&gt;
                &lt;title&gt;
                    Subsection 1.1.1 Title
        &lt;section&gt;
            &lt;title&gt;
                Section 1.2 Title
    &lt;section&gt;
        &lt;title&gt;
            Chapter 2 Title

(Pseudo-XML uses indentation for nesting and has no end-tags.  It's
not possible to show actual processed output, as in the other
examples, because sections cannot exist inside block quotes.  For a
concrete example, compare the section structure of this document's
source text and processed output.)

Note that section headers are available as link targets, just using
their name.  To link to the Lists_ heading, I write "``Lists_``".  If
the heading has a space in it like `text styles`_, we need to quote
the heading "```text styles`_``".

</t>
<t tx="ekr.20100110172917.1940">The title of the whole document is distinct from section titles and
may be formatted somewhat differently (e.g. the HTML writer by default
shows it as a centered heading).

To indicate the document title in reStructuredText, use a unique adornment
style at the beginning of the document.  To indicate the document subtitle,
use another unique adornment style immediately after the document title.  For
example::

    ================
     Document Title
    ================
    ----------
     Subtitle
    ----------

    Section Title
    =============

    ...

Note that "Document Title" and "Section Title" above both use equals
signs, but are distict and unrelated styles.  The text of
overline-and-underlined titles (but not underlined-only) may be inset
for aesthetics.

</t>
<t tx="ekr.20100110172917.1941">(quickref__)

__ quickref.html#directives

To include an image in your document, you use the the ``image`` directive__.
For example::

  .. image:: images/biohazard.png

results in:

.. image:: images/biohazard.png

The ``images/biohazard.png`` part indicates the filename of the image
you wish to appear in the document. There's no restriction placed on
the image (format, size etc).  If the image is to appear in HTML and
you wish to supply additional information, you may::

  .. image:: images/biohazard.png
     :height: 100
     :width: 200
     :scale: 50
     :alt: alternate text

See the full `image directive documentation`__ for more info.

__ ../../ref/rst/directives.html
__ ../../ref/rst/directives.html#images

</t>
<t tx="ekr.20100110172917.1942">This primer introduces the most common features of reStructuredText,
but there are a lot more to explore.  The `Quick reStructuredText`_
user reference is a good place to go next.  For complete details, the
`reStructuredText Markup Specification`_ is the place to go [#]_.

Users who have questions or need assistance with Docutils or
reStructuredText should post a message to the Docutils-users_ mailing
list.

.. [#] If that relative link doesn't work, try the master document:
   http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html.

.. _reStructuredText Markup Specification:
   ../../ref/rst/restructuredtext.html
.. _Docutils-users: ../mailing-lists.html#docutils-users
.. _Docutils project web site: http://docutils.sourceforge.net/

</t>
<t tx="ekr.20100110172917.1943">&lt;xml&gt;
&lt;/xml&gt;
</t>
<t tx="ekr.20100110172917.1944">&lt;test.a&gt;
a
&lt;/test.a&gt;
</t>
<t tx="ekr.20100110172917.1945">&lt;test-b&gt;
b
&lt;/test-b&gt;
</t>
<t tx="ekr.20100110172917.1946">&lt;!DOCTYPE xml&gt;
</t>
<t tx="ekr.20100110172917.1947">&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:py="http://genshi.edgewall.org/" py:strip=""&gt;
  &lt;?python v=value_of; import time?&gt;
  @others
&lt;/html&gt;
</t>
<t tx="ekr.20100110172917.1948">&lt;py:match path="head"&gt;
  @others
&lt;/py:match&gt;
</t>
<t tx="ekr.20100110172917.1949">&lt;head py:attrs="select('@*')"&gt;
  @others
  &lt;script py:for="i in v('jscripts',[])" 
    type='text/javascript' src="${url('/js/'+i)}"/&gt;
  &lt;link rel="stylesheet" href="${url('/css/main.css')}" type="text/css"/&gt;
  &lt;link py:for="i in v('css',[])" 
    rel="stylesheet" type='text/javascript' href="${url('/css/'+i)}"/&gt;
  ${select('node()')}
&lt;/head&gt;
</t>
<t tx="ekr.20100110172917.1950">&lt;py:if test="v('jscripts',[])"&gt;
  &lt;script type='text/javascript' src="${url('/js/jquery.js')}"/&gt;
  &lt;!--! CSS for JQuery UI --&gt;
  &lt;link rel="stylesheet" href="${url('/js/themes/flora/flora.all.css')}" type="text/css"/&gt;
  &lt;script type='text/javascript' src="${url('/js/ui.calendar.js')}"/&gt;
&lt;/py:if&gt;
</t>
<t tx="ekr.20100110172917.1951">&lt;py:match path="body"&gt;
  @others
&lt;/py:match&gt;
</t>
<t tx="ekr.20100110172917.1952">&lt;body py:attrs="select('@*')"&gt;
  &lt;div class="sections"&gt;${select('node()')}&lt;/div&gt;
  &lt;div class="site-footer"&gt;Generated ${time.ctime()}&lt;/div&gt;
&lt;/body&gt;
</t>
<t tx="ekr.20100110172917.1953">&lt;py:match path="xh1"&gt;
  &lt;div class="h1"&gt;
    &lt;h1 py:attrs="select('@*')" &gt;${select('node()')}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/py:match&gt;
</t>
<t tx="ekr.20100110172917.1954">&lt;py:match path="NOTp"&gt;
  &lt;div py:for="i in range(2)" class="slide" style="border: solid red 3px;"&gt;
    &lt;p py:attrs="select('@*')"&gt;${i}. ${select('node()')}&lt;/p&gt;
  &lt;/div&gt;
&lt;/py:match&gt;
</t>
<t tx="ekr.20100110172917.1955">:Info: See &lt;http://docutils.sf.net/rst.html&gt; for introductory docs.
:Author: David Goodger &lt;goodger@python.org&gt;
:Date: $Date: 2006-01-23 02:13:55 +0100 (Mon, 23 Jän 2006) $
:Revision: $Revision: 4321 $
:Description: This is a "docinfo block", or bibliographic field list

</t>
<t tx="ekr.20100110172917.1956">Section titles are underlined or overlined &amp; underlined.

</t>
<t tx="ekr.20100110172917.1957">Grid table:

+--------------------------------+-----------------------------------+
| Paragraphs are flush-left,     | Literal block, preceded by "::":: |
| separated by blank lines.      |                                   |
|                                |     Indented                      |
|     Block quotes are indented. |                                   |
+--------------------------------+ or::                              |
| &gt;&gt;&gt; print 'Doctest block'      |                                   |
| Doctest block                  | &gt; Quoted                          |
+--------------------------------+-----------------------------------+
| | Line blocks preserve line breaks &amp; indents. [new in 0.3.6]       |
| |     Useful for addresses, verse, and adornment-free lists; long  |
|       lines can be wrapped with continuation lines.                |
+--------------------------------------------------------------------+

Simple tables:

================  ============================================================
List Type         Examples
================  ============================================================
Bullet list       * items begin with "-", "+", or "*"
Enumerated list   1. items use any variation of "1.", "A)", and "(i)"
                  #. also auto-enumerated
Definition list   Term is flush-left : optional classifier
                      Definition is indented, no blank line between
Field list        :field name: field body
Option list       -o  at least 2 spaces between option &amp; description
================  ============================================================

================  ============================================================
Explicit Markup   Examples (visible in the `text source &lt;cheatsheet.txt&gt;`_)
================  ============================================================
Footnote          .. [1] Manually numbered or [#] auto-numbered
                     (even [#labelled]) or [*] auto-symbol
Citation          .. [CIT2002] A citation.
Hyperlink Target  .. _reStructuredText: http://docutils.sf.net/rst.html
                  .. _indirect target: reStructuredText_
                  .. _internal target:
Anonymous Target  __ http://docutils.sf.net/docs/ref/rst/restructuredtext.html
Directive ("::")  .. image:: images/biohazard.png
Substitution Def  .. |substitution| replace:: like an inline directive
Comment           .. is anything else
Empty Comment     (".." on a line by itself, with blank lines before &amp; after,
                  used to separate indentation contexts)
================  ============================================================

</t>
<t tx="ekr.20100110172917.1958">*emphasis*; **strong emphasis**; `interpreted text`; `interpreted text
with role`:emphasis:; ``inline literal text``; standalone hyperlink,
http://docutils.sourceforge.net; named reference, reStructuredText_;
`anonymous reference`__; footnote reference, [1]_; citation reference,
[CIT2002]_; |substitution|; _`inline internal target`.

</t>
<t tx="ekr.20100110172917.1959">See &lt;http://docutils.sf.net/docs/ref/rst/directives.html&gt; for full info.

================  ============================================================
Directive Name    Description (Docutils version added to, in [brackets])
================  ============================================================
attention         Specific admonition; also "caution", "danger",
                  "error", "hint", "important", "note", "tip", "warning"
admonition        Generic titled admonition: ``.. admonition:: By The Way``
image             ``.. image:: picture.png``; many options possible
figure            Like "image", but with optional caption and legend
topic             ``.. topic:: Title``; like a mini section
sidebar           ``.. sidebar:: Title``; like a mini parallel document
parsed-literal    A literal block with parsed inline markup
rubric            ``.. rubric:: Informal Heading``
epigraph          Block quote with class="epigraph"
highlights        Block quote with class="highlights"
pull-quote        Block quote with class="pull-quote"
compound          Compound paragraphs [0.3.6]
container         Generic block-level container element [0.3.10]
table             Create a titled table [0.3.1]
list-table        Create a table from a uniform two-level bullet list [0.3.8]
csv-table         Create a table from CSV data (requires Python 2.3+) [0.3.4]
contents          Generate a table of contents
sectnum           Automatically number sections, subsections, etc.
header, footer    Create document decorations [0.3.8]
target-notes      Create an explicit footnote for each external target
meta              HTML-specific metadata
include           Read an external reST file as if it were inline
raw               Non-reST data passed untouched to the Writer
replace           Replacement text for substitution definitions
unicode           Unicode character code conversion for substitution defs
date              Generates today's date; for substitution defs
class             Set a "class" attribute on the next element
role              Create a custom interpreted text role [0.3.2]
default-role      Set the default interpreted text role [0.3.10]
title             Set the metadata document title [0.3.10]
================  ============================================================

</t>
<t tx="ekr.20100110172917.1960">See &lt;http://docutils.sf.net/docs/ref/rst/roles.html&gt; for full info.

================  ============================================================
Role Name         Description
================  ============================================================
emphasis          Equivalent to *emphasis*
literal           Equivalent to ``literal`` but processes backslash escapes
PEP               Reference to a numbered Python Enhancement Proposal
RFC               Reference to a numbered Internet Request For Comments
raw               For non-reST data; cannot be used directly (see docs) [0.3.6]
strong            Equivalent to **strong**
sub               Subscript
sup               Superscript
title             Title reference (book, etc.); standard default role
================  ============================================================

</t>
<t tx="ekr.20100110172917.1961">Section 1: Ę

</t>
<t tx="ekr.20100118122048.2003"># For new colorizer

python_keyword1_font_family = DejaVu Sans Mono
python_keyword1_font_size = 12
python_keyword1_font_slant = roman
    # roman, italic
python_keyword1_font_weight = bold
    # normal, bold</t>
<t tx="ekr.20100118133026.2008">python_keyword3_font_family = DejaVu Sans Mono
python_keyword3_font_size = 12
python_keyword3_font_slant = italic
    # roman, italic
python_keyword3_font_weight = bold
    # normal, bold
</t>
<t tx="ekr.20100118141712.2011">@nocolor-node

Use 40 for @tabwidth 4
Use 80 for @tabwidth 8</t>
<t tx="ekr.20100118190256.2012"></t>
<t tx="ekr.20100118190256.2013"></t>
<t tx="ekr.20100118190256.2014"></t>
<t tx="ekr.20100118190256.2015"></t>
<t tx="ekr.20100118190256.2016"></t>
<t tx="ekr.20100119095312.2041"># bold

rest_keyword2_font_size = 14
rest_keyword2_font_family = Bitstream Charter
rest_keyword2_font_slant = roman
rest_keyword2_font_weight = bold</t>
<t tx="ekr.20100119095726.2043">@language rest

This is **bold** and this is *italic*.</t>
<t tx="ekr.20100119100926.2046"># Italics
rest_keyword4_font_size = 14
rest_keyword4_font_family = Bitstream Charter
rest_keyword4_font_slant = italic
    # roman, italic
rest_keyword4_font_weight = normal
    # normal, bold</t>
<t tx="ekr.20100122125233.2053">root = p.copy()
while p.hasChildren():
   p.firstChild().doDelete(newNode = None)

print(g.app.gui.guiName())

try:
   p1 = p.insertAsLastChild()
   p1.expand()
   body = 'foo'
   # p1.setBodyString(body)
   p1.b = body
   c.selectPosition(p1)
   c.copyOutline()
   c.pasteOutline()
finally:
   c.redraw_now()
</t>
<t tx="ekr.20100127111116.2059">@nowrap

aaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccc ddddddddddddddddddddddd eeeeeeeeeeeeeeeeeee fffffffffffffffffffffff
aaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccc ddddddddddddddddddddddd eeeeeeeeeeeeeeeeeee fffffffffffffffffffffff
aaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccc ddddddddddddddddddddddd eeeeeeeeeeeeeeeeeee fffffffffffffffffffffff</t>
<t tx="ekr.20100127111425.2062"># Searching on Windows 7 is absolutely wretched.
import glob
import os

@others

pattern = "idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')"
ignoreCase = True
paths = (
    # r'C:\Python31\Lib\site-packages\docutils',
    # r'C:\Python26\Lib\site-packages\pylint-0.19.0-py2.6.egg\pylint',
    # r'C:\Python31\Lib\site-packages\docutils',
    r'C:\Python26\Lib\site-packages\docutils-0.6-py2.6.egg\docutils',
)

os.system('CLS')
print('\n%s pattern: %s' % ('-'*20,pattern))
for path in paths:
    searchDir(path,pattern)
</t>
<t tx="ekr.20100127122240.2063">@nocolor

Select the following string: वादक.
Typing and undo now work.</t>
<t tx="ekr.20100130095415.2023"># @first # -*- coding: mbcs -*-
# @first # -*- coding: utf-8 -*-

path = 'c:\prog\Leo Stuff\chinese脖folder'

for encoding in ('mbcs','utf-8'):
    valid = g.isValidEncoding(encoding)
    theDir = g.os_path_finalize(path,encoding='utf-8')
    g.es(encoding,valid,theDir)
    print(encoding,valid,g.os_path_exists(theDir))</t>
<t tx="ekr.20100202115249.2023">@first # -*- coding: utf-8 -*-
@language python
import sys
from PyQt4 import Qt

isPython3 = sys.version_info &gt;= (3,0,0)
if isPython3:
    def gu(s): return s
else:
    def gu(s): return unicode(s)

s = gu('''Select the following string: वादक.
This string consists of 4 characters, followed by a period.
Hit do, then undo.
Notice that the selection range now includes the period.
''')

n1,n2 = None,None # The selection range.
app = Qt.QApplication(sys.argv) 
f = Qt.QFrame()
f.setLayout(Qt.QVBoxLayout())
w = Qt.QTextEdit()
w.setPlainText(s)

b1 = Qt.QPushButton("Do")
b2 = Qt.QPushButton("Undo")

f.layout().addWidget(w)
f.layout().addWidget(b1)
f.layout().addWidget(b2)
f.show()

def showselect():
    tc = w.textCursor()
    s = w.toPlainText()
    su = gu(s)
    n1,n2 = tc.selectionStart(),tc.selectionEnd()
    print(n1,n2,'length',abs(n2-n1),len(s),len(su),gu(s[n1:n2]).encode('utf-8'))

def do():
    # w.textCursor().removeSelectedText() # works
    global n1,n2,w
    tc = w.textCursor()
    n1,n2 = tc.selectionStart(),tc.selectionEnd()
    tc = w.textCursor()
    tc.removeSelectedText()
    w.setTextCursor(tc) # Has no effect.

def undo():
    global n1,n2,s,w
    w.setPlainText(s)
    tc = w.textCursor()
    if n1 &gt; n2: n1,n2 = n2,n1
    tc.setPosition(n1)
    tc.setPosition(n2,tc.KeepAnchor)
    # tc.movePosition(tc.Right,tc.KeepAnchor,n2-n1)
    w.setTextCursor(tc)

app.connect(w, Qt.SIGNAL("selectionChanged()"), showselect)
app.connect(b1, Qt.SIGNAL("clicked()"), do)
app.connect(b2, Qt.SIGNAL("clicked()"), undo)
app.exec_()
</t>
<t tx="ekr.20100203174233.2032"># My problem: the node that is being created by c.pasteOutline() has an
# empty body. If after running the test I type 'paste-node' in the
# minibuffer, a new node appears, it has 'foo' in the body.

root = p.copy()
while p.hasChildren():
   p.firstChild().doDelete(newNode = None)
try:
   p1 = p.insertAsLastChild()
   body = 'foo'
   p1.setBodyString(body)
   c.selectPosition(p1)
   c.copyOutline()
   c.pasteOutline()
finally:
   c.redraw_now()</t>
<t tx="ekr.20100203233053.2033">@language python

#@path aPathaab

# This is a test2</t>
<t tx="ekr.20100204062222.2035">This crashed Leo in path.py during startup</t>
<t tx="ekr.20100204082851.2038">@language python
@tabwidth -4
@others
Pmw.forwardmethods(ComboBox, Pmw.ScrolledListBox, '_list')
Pmw.forwardmethods(ComboBox, Pmw.EntryField, '_entryfield')
</t>
<t tx="ekr.20100204085410.2060">@language python
@tabwidth -4
@others
Pmw.forwardmethods(ComboBox, Pmw.ScrolledListBox, '_list')
Pmw.forwardmethods(ComboBox, Pmw.EntryField, '_entryfield')
</t>
<t tx="ekr.20100204085631.2041"># This file illustrates some off-by-n problems in goto-global-line.

# Actually, there may be a bigger problem with the @auto file write logic.
# Adding /deleteing blank lines here doesn't change the file!!!



# Based on iwidgets2.2.0/combobox.itk code.

import os
import string
import types
import Tkinter
import Pmw

</t>
<t tx="ekr.20100204085631.2042">class ComboBox(Pmw.MegaWidget):
    @others
    self._selectCmd()


</t>
<t tx="ekr.20100204085631.2043">def __init__(self, parent = None, **kw):

</t>
<t tx="ekr.20100204085631.2044"># Define the megawidget options.
INITOPT = Pmw.INITOPT
optiondefs = (
    ('autoclear',          0,          INITOPT),
    ('buttonaspect',       1.0,        INITOPT),
    ('dropdown',           1,          INITOPT),
    ('fliparrow',          0,          INITOPT),
    ('history',            1,          INITOPT),
    ('labelmargin',        0,          INITOPT),
    ('labelpos',           None,       INITOPT),
    ('listheight',         200,        INITOPT),
    ('selectioncommand',   None,       None),
    ('sticky',            'ew',        INITOPT),
    ('unique',             1,          INITOPT),
)
self.defineoptions(kw, optiondefs)

# Initialise the base class (after defining the options).
Pmw.MegaWidget.__init__(self, parent)

# Create the components.
interior = self.interior()

self._entryfield = self.createcomponent('entryfield',
    (('entry', 'entryfield_entry'),), None,
    Pmw.EntryField, (interior,))
self._entryfield.grid(column=2, row=2, sticky=self['sticky'])
interior.grid_columnconfigure(2, weight = 1)
self._entryWidget = self._entryfield.component('entry')

if self['dropdown']:
    self._isPosted = 0
        interior.grid_rowconfigure(2, weight = 1)

    # Create the arrow button.
    self._arrowBtn = self.createcomponent('arrowbutton',
        (), None,
        Tkinter.Canvas, (interior,), borderwidth = 2,
        relief = 'raised',
        width = 16, height = 16)
        if 'n' in self['sticky']:
            sticky = 'n'
        else:
            sticky = ''
        if 's' in self['sticky']:
            sticky = sticky + 's'
    self._arrowBtn.grid(column=3, row=2, sticky = sticky)
    self._arrowRelief = self._arrowBtn.cget('relief')

    # Create the label.
    self.createlabel(interior, childCols=2)

    # Create the dropdown window.
    self._popup = self.createcomponent('popup',
        (), None,
        Tkinter.Toplevel, (interior,))
    self._popup.withdraw()
    self._popup.overrideredirect(1)

    # Create the scrolled listbox inside the dropdown window.
    self._list = self.createcomponent('scrolledlist',
        (('listbox', 'scrolledlist_listbox'),), None,
        Pmw.ScrolledListBox, (self._popup,),
        hull_borderwidth = 2,
        hull_relief = 'raised',
        hull_height = self['listheight'],
        usehullsize = 1,
        listbox_exportselection = 0)
    self._list.pack(expand=1, fill='both')
    self.__listbox = self._list.component('listbox')

    # Bind events to the arrow button.
    self._arrowBtn.bind('&lt;1&gt;', self._postList)
    self._arrowBtn.bind('&lt;Configure&gt;', self._drawArrow)
    self._arrowBtn.bind('&lt;3&gt;', self._next)
    self._arrowBtn.bind('&lt;Shift-3&gt;', self._previous)
    self._arrowBtn.bind('&lt;Down&gt;', self._next)
    self._arrowBtn.bind('&lt;Up&gt;', self._previous)
    self._arrowBtn.bind('&lt;Control-n&gt;', self._next)
    self._arrowBtn.bind('&lt;Control-p&gt;', self._previous)
    self._arrowBtn.bind('&lt;Shift-Down&gt;', self._postList)
    self._arrowBtn.bind('&lt;Shift-Up&gt;', self._postList)
    self._arrowBtn.bind('&lt;F34&gt;', self._postList)
    self._arrowBtn.bind('&lt;F28&gt;', self._postList)
    self._arrowBtn.bind('&lt;space&gt;', self._postList)

    # Bind events to the dropdown window.
    self._popup.bind('&lt;Escape&gt;', self._unpostList)
    self._popup.bind('&lt;space&gt;', self._selectUnpost)
    self._popup.bind('&lt;Return&gt;', self._selectUnpost)
    self._popup.bind('&lt;ButtonRelease-1&gt;', self._dropdownBtnRelease)
    self._popup.bind('&lt;ButtonPress-1&gt;', self._unpostOnNextRelease)

    # Bind events to the Tk listbox.
    self.__listbox.bind('&lt;Enter&gt;', self._unpostOnNextRelease)

    # Bind events to the Tk entry widget.
    self._entryWidget.bind('&lt;Configure&gt;', self._resizeArrow)
    self._entryWidget.bind('&lt;Shift-Down&gt;', self._postList)
    self._entryWidget.bind('&lt;Shift-Up&gt;', self._postList)
    self._entryWidget.bind('&lt;F34&gt;', self._postList)
    self._entryWidget.bind('&lt;F28&gt;', self._postList)

        # Need to unpost the popup if the entryfield is unmapped (eg: 
        # its toplevel window is withdrawn) while the popup list is
        # displayed.
        self._entryWidget.bind('&lt;Unmap&gt;', self._unpostList)

else:
    # Create the scrolled listbox below the entry field.
    self._list = self.createcomponent('scrolledlist',
        (('listbox', 'scrolledlist_listbox'),), None,
        Pmw.ScrolledListBox, (interior,),
                selectioncommand = self._selectCmd)
    self._list.grid(column=2, row=3, sticky='nsew')
    self.__listbox = self._list.component('listbox')

    # The scrolled listbox should expand vertically.
    interior.grid_rowconfigure(3, weight = 1)

    # Create the label.
    self.createlabel(interior, childRows=2)

self._entryWidget.bind('&lt;Down&gt;', self._next)
self._entryWidget.bind('&lt;Up&gt;', self._previous)
self._entryWidget.bind('&lt;Control-n&gt;', self._next)
self._entryWidget.bind('&lt;Control-p&gt;', self._previous)
self.__listbox.bind('&lt;Control-n&gt;', self._next)
self.__listbox.bind('&lt;Control-p&gt;', self._previous)

if self['history']:
    self._entryfield.configure(command=self._addHistory)

# Check keywords and initialise options.
self.initialiseoptions()

def destroy(self):
</t>
<t tx="ekr.20100204085631.2045">if self['dropdown'] and self._isPosted:
        Pmw.popgrab(self._popup)
    Pmw.MegaWidget.destroy(self)

#======================================================================

# Public methods

def get(self, first = None, last=None):
</t>
<t tx="ekr.20100204085631.2046">if first is None:
    return self._entryWidget.get()
else:
    return self._list.get(first, last)

def invoke(self):
</t>
<t tx="ekr.20100204085631.2047">if self['dropdown']:
    self._postList()
else:
    return self._selectCmd()

def selectitem(self, index, setentry=1):
</t>
<t tx="ekr.20100204085631.2048">if type(index) == types.StringType:
    text = index
    items = self._list.get(0, 'end')
    if text in items:
    index = list(items).index(text)
    else:
        raise IndexError, 'index "%s" not found' % text
elif setentry:
    text = self._list.get(0, 'end')[index]

self._list.select_clear(0, 'end')
self._list.select_set(index, index)
self._list.activate(index)
self.see(index)
if setentry:
    self._entryfield.setentry(text)

# Need to explicitly forward this to override the stupid
# (grid_)size method inherited from Tkinter.Frame.Grid.
def size(self):
</t>
<t tx="ekr.20100204085631.2049">return self._list.size()

# Need to explicitly forward this to override the stupid
# (grid_)bbox method inherited from Tkinter.Frame.Grid.
def bbox(self, index):
</t>
<t tx="ekr.20100204085631.2050">return self._list.bbox(index)

def clear(self):
</t>
<t tx="ekr.20100204085631.2051">self._entryfield.clear()
self._list.clear()

#======================================================================

# Private methods for both dropdown and simple comboboxes.

def _addHistory(self):
</t>
<t tx="ekr.20100204085631.2052">input = self._entryWidget.get()

if input != '':
    index = None
    if self['unique']:
    # If item is already in list, select it and return.
    items = self._list.get(0, 'end')
    if input in items:
        index = list(items).index(input)

    if index is None:
    index = self._list.index('end')
    self._list.insert('end', input)

    self.selectitem(index)
    if self['autoclear']:
    self._entryWidget.delete(0, 'end')

    # Execute the selectioncommand on the new entry.
    self._selectCmd()

def _next(self, event):
</t>
<t tx="ekr.20100204085631.2053">size = self.size()
if size &lt;= 1:
    return

cursels = self.curselection()

if len(cursels) == 0:
    index = 0
else:
    index = string.atoi(cursels[0])
    if index == size - 1:
    index = 0
    else:
    index = index + 1

self.selectitem(index)

def _previous(self, event):
</t>
<t tx="ekr.20100204085631.2054">size = self.size()
if size &lt;= 1:
    return

cursels = self.curselection()

if len(cursels) == 0:
    index = size - 1
else:
    index = string.atoi(cursels[0])
    if index == 0:
    index = size - 1
    else:
    index = index - 1

self.selectitem(index)

def _selectCmd(self, event=None):

</t>
<t tx="ekr.20100204085631.2055">sels = self.getcurselection()
if len(sels) == 0:
    item = None
else:
    item = sels[0]
    self._entryfield.setentry(item)

cmd = self['selectioncommand']
if callable(cmd):
        if event is None:
            # Return result of selectioncommand for invoke() method.
            return cmd(item)
        else:
            cmd(item)

#======================================================================

# Private methods for dropdown combobox.

def _drawArrow(self, event=None, sunken=0):
    arrow = self._arrowBtn
</t>
<t tx="ekr.20100204085631.2056">if sunken:
    self._arrowRelief = arrow.cget('relief')
    arrow.configure(relief = 'sunken')
else:
    arrow.configure(relief = self._arrowRelief)

if self._isPosted and self['fliparrow']:
        direction = 'up'
    else:
        direction = 'down'
    Pmw.drawarrow(arrow, self['entry_foreground'], direction, 'arrow')

def _postList(self, event = None):
    self._isPosted = 1
    self._drawArrow(sunken=1)

    # Make sure that the arrow is displayed sunken.
    self.update_idletasks()

    x = self._entryfield.winfo_rootx()
    y = self._entryfield.winfo_rooty() + \
        self._entryfield.winfo_height()
    w = self._entryfield.winfo_width() + self._arrowBtn.winfo_width()
    h =  self.__listbox.winfo_height()
    sh = self.winfo_screenheight()

    if y + h &gt; sh and y &gt; sh / 2:
        y = self._entryfield.winfo_rooty() - h

    self._list.configure(hull_width=w)

    Pmw.setgeometryanddeiconify(self._popup, '+%d+%d' % (x, y))

    # Grab the popup, so that all events are delivered to it, and
    # set focus to the listbox, to make keyboard navigation
    # easier.
    Pmw.pushgrab(self._popup, 1, self._unpostList)
    self.__listbox.focus_set()

    self._drawArrow()

    # Ignore the first release of the mouse button after posting the
    # dropdown list, unless the mouse enters the dropdown list.
    self._ignoreRelease = 1

</t>
<t tx="ekr.20100204085631.2057">def _dropdownBtnRelease(self, event):
</t>
<t tx="ekr.20100204085631.2058">if (event.widget == self._list.component('vertscrollbar') or
    event.widget == self._list.component('horizscrollbar')):
    return

if self._ignoreRelease:
    self._unpostOnNextRelease()
    return

    self._unpostList()

if (event.x &gt;= 0 and event.x &lt; self.__listbox.winfo_width() and
    event.y &gt;= 0 and event.y &lt; self.__listbox.winfo_height()):
    self._selectCmd()

def _unpostOnNextRelease(self, event = None):
</t>
<t tx="ekr.20100204085631.2059">self._ignoreRelease = 0

def _resizeArrow(self, event):
</t>
<t tx="ekr.20100204085631.2060">bw = (string.atoi(self._arrowBtn['borderwidth']) + 
    string.atoi(self._arrowBtn['highlightthickness']))
newHeight = self._entryfield.winfo_reqheight() - 2 * bw
newWidth = int(newHeight * self['buttonaspect'])
self._arrowBtn.configure(width=newWidth, height=newHeight)
self._drawArrow()

def _unpostList(self, event=None):
</t>
<t tx="ekr.20100204085631.2061">if not self._isPosted:
        # It is possible to get events on an unposted popup.  For
        # example, by repeatedly pressing the space key to post
        # and unpost the popup.  The &lt;space&gt; event may be
        # delivered to the popup window even though
        # Pmw.popgrab() has set the focus away from the
        # popup window.  (Bug in Tk?)
        return

    # Restore the focus before withdrawing the window, since
    # otherwise the window manager may take the focus away so we
    # can't redirect it.  Also, return the grab to the next active
    # window in the stack, if any.
    Pmw.popgrab(self._popup)
self._popup.withdraw()

self._isPosted = 0
self._drawArrow()

def _selectUnpost(self, event):
    self._unpostList()
</t>
<t tx="ekr.20100205074729.2085"></t>
<t tx="ekr.20100205074729.2086">line 1: node a changed 2</t>
<t tx="ekr.20100205074729.2087">@all</t>
<t tx="ekr.20100205114630.2089"># This file illustrates some off-by-n problems in goto-global-line.

# Actually, there may be a bigger problem with the @auto file write logic.
# Adding /deleteing blank lines here doesn't change the file!!!


# Based on iwidgets2.2.0/combobox.itk code.

import os
import string
</t>
<t tx="ekr.20100205114630.2090">class ComboBox(Pmw.MegaWidget):
    pass
</t>
<t tx="ekr.20100205114630.2091"></t>
<t tx="ekr.20100329100226.2108">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20100329100841.2109">Level 1</t>
<t tx="ekr.20100329100841.2110">Level 2</t>
<t tx="ekr.20100330082345.2120">@language pseudoplain

This is a [[test]] of something.</t>
<t tx="ekr.20100330084954.2125"></t>
<t tx="ekr.20100507151756.2123"></t>
<t tx="ekr.20100516140428.2135">import base64
import getpass
import hashlib

print(getpass.getuser())

m = hashlib.sha1()
m.update("Nobody inspect2s")
key = m.digest()
key = base64.urlsafe_b64encode(str(key))
print(key)
</t>
<t tx="ekr.20100521101729.2148"># Just playing with part of a template system, the (partial) mock up for "range()" is:

def tabStopNaming (event=None):

  stateName = 'naming'
  k = c.k
  state = k.getState(stateName)

  help = ('start-value -- optional, -&gt; fill-in or tab eliminate.  ',
           'end-value -- required, -&gt; fill-in.  ',
           'step -- optional, -&gt;fill-in or tab to eliminate.  ')
  tabStop = ('start-value', 'end-value', 'step')

  if state == 0:
      k.setLabelBlue(help[0],protect=True)
      k.getArg(event,stateName,1,tabStopNaming)
      # g.es('does this ever executed?') # yes, imediately!
  else:
      k.clearState()
      g.es_print('%s : %s' % (tabStop[0], k.arg))
      k.setLabelBlue('')

tabStopNaming()</t>
<t tx="ekr.20100526075442.2155">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20100526092131.2157"></t>
<t tx="ekr.20100526092131.2158"></t>
<t tx="ekr.20100526092131.2159">::

  digraph G {
      main -&gt; parse -&gt; execute;
      main -&gt; init;
      main -&gt; cleanup;
      execute -&gt; make_string;
      execute -&gt; printf
      init -&gt; make_string;
      main -&gt; printf;
      execute -&gt; compare;
      }


.. graphviz::

  digraph G {
      main -&gt; parse -&gt; execute;
      main -&gt; init;
      main -&gt; cleanup;
      execute -&gt; make_string;
      execute -&gt; printf
      init -&gt; make_string;
      main -&gt; printf;
      execute -&gt; compare;
      }

</t>
<t tx="ekr.20100526092131.2160">::

    digraph G {
        size ="4,4";
        main [shape=box];    /* this is a comment */
        main -&gt; parse [weight=8];
        parse -&gt; execute;
        main -&gt; init [style=dotted];
        main -&gt; cleanup;
        execute -&gt; { make_string; printf}
        init -&gt; make_string;
        edge [color=red];    // so is this
        main -&gt; printf [style=bold,label="100 times"];
        make_string [label="make a\nstring"];
        node [shape=box,style=filled,color=".7 .3 1.0"];
        execute -&gt; compare;
    }

.. graphviz::

    digraph G {
        size ="4,4";
        main [shape=box];    /* this is a comment */
        main -&gt; parse [weight=8];
        parse -&gt; execute;
        main -&gt; init [style=dotted];
        main -&gt; cleanup;
        execute -&gt; { make_string; printf}
        init -&gt; make_string;
        edge [color=red];    // so is this
        main -&gt; printf [style=bold,label="100 times"];
        make_string [label="make a\nstring"];
        node [shape=box,style=filled,color=".7 .3 1.0"];
        execute -&gt; compare;
    }

</t>
<t tx="ekr.20100526092131.2161">::

    digraph G {
        a -&gt; b -&gt; c;
        b -&gt; d;
        a [shape=polygon,sides=5,peripheries=3,color=lightblue,style=filled];
        c [shape=polygon,sides=4,skew=.4,label="hello world"]
        d [shape=invtriangle];
        e [shape=polygon,sides=4,distortion=.7];
    }
    
.. graphviz::

    digraph G {
        a -&gt; b -&gt; c;
        b -&gt; d;
        a [shape=polygon,sides=5,peripheries=3,color=lightblue,style=filled];
        c [shape=polygon,sides=4,skew=.4,label="hello world"]
        d [shape=invtriangle];
        e [shape=polygon,sides=4,distortion=.7];
    }

</t>
<t tx="ekr.20100526092131.2162">::

    digraph structs {
    node [shape=record];
        struct1 [shape=record,label="&lt;f0&gt; left|&lt;f1&gt; mid\ dle|&lt;f2&gt; right"];
        struct2 [shape=record,label="&lt;f0&gt; one|&lt;f1&gt; two"];
        struct3 [shape=record,label="hello\nworld |{ b |{c|&lt;here&gt; d|e}| f}| g | h"];
        struct1 -&gt; struct2;
        struct1 -&gt; struct3;
    }

.. graphviz::

    digraph structs {
    node [shape=record];
        struct1 [shape=record,label="&lt;f0&gt; left|&lt;f1&gt; mid\ dle|&lt;f2&gt; right"];
        struct2 [shape=record,label="&lt;f0&gt; one|&lt;f1&gt; two"];
        struct3 [shape=record,label="hello\nworld |{ b |{c|&lt;here&gt; d|e}| f}| g | h"];
        struct1 -&gt; struct2;
        struct1 -&gt; struct3;
    }

</t>
<t tx="ekr.20100526092131.2163">::

    digraph html {
        abc [shape=none, margin=0, label=&lt;
    &lt;TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4"&gt;
      &lt;TR&gt;&lt;TD ROWSPAN="3"&gt;&lt;FONT COLOR="red"&gt;hello&lt;/FONT&gt;&lt;BR/&gt;world&lt;/TD&gt;
          &lt;TD COLSPAN="3"&gt;b&lt;/TD&gt;
          &lt;TD ROWSPAN="3" BGCOLOR="lightgrey"&gt;g&lt;/TD&gt;
          &lt;TD ROWSPAN="3"&gt;h&lt;/TD&gt;
      &lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;c&lt;/TD&gt;
          &lt;TD PORT="here"&gt;d&lt;/TD&gt;
          &lt;TD&gt;e&lt;/TD&gt;
      &lt;/TR&gt;
      &lt;TR&gt;&lt;TD COLSPAN="3"&gt;f&lt;/TD&gt;
      &lt;/TR&gt;
    &lt;/TABLE&gt;&gt;];
    }

.. graphviz::

    digraph html {
        abc [shape=none, margin=0, label=&lt;
    &lt;TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4"&gt;
      &lt;TR&gt;&lt;TD ROWSPAN="3"&gt;&lt;FONT COLOR="red"&gt;hello&lt;/FONT&gt;&lt;BR/&gt;world&lt;/TD&gt;
          &lt;TD COLSPAN="3"&gt;b&lt;/TD&gt;
          &lt;TD ROWSPAN="3" BGCOLOR="lightgrey"&gt;g&lt;/TD&gt;
          &lt;TD ROWSPAN="3"&gt;h&lt;/TD&gt;
      &lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;c&lt;/TD&gt;
          &lt;TD PORT="here"&gt;d&lt;/TD&gt;
          &lt;TD&gt;e&lt;/TD&gt;
      &lt;/TR&gt;
      &lt;TR&gt;&lt;TD COLSPAN="3"&gt;f&lt;/TD&gt;
      &lt;/TR&gt;
    &lt;/TABLE&gt;&gt;];
    }

</t>
<t tx="ekr.20100526092131.2164">::

    digraph asde91 {
        ranksep=.75; size = "7.5,7.5";
        {
            node [shape=plaintext, fontsize=16];
            /* the time-line graph */
            past -&gt; 1978 -&gt; 1980 -&gt; 1982 -&gt; 1983 -&gt; 1985 -&gt; 1986 -&gt;
                     1987 -&gt; 1988 -&gt; 1989 -&gt; 1990 -&gt; "future";
            /* ancestor programs */
            "Bourne sh"; "make"; "SCCS"; "yacc"; "cron"; "Reiser cpp";
            "Cshell"; "emacs"; "build"; "vi"; "&lt;curses&gt;"; "RCS"; "C*";
        }
        { rank = same;
            "Software IS"; "Configuration Mgt"; "Architecture &amp; Libraries";
            "Process";
        };
        node [shape=box];
        { rank = same; "past"; "SCCS"; "make"; "Bourne sh"; "yacc"; "cron"; }
        { rank = same; 1978; "Reiser cpp"; "Cshell"; }
        { rank = same; 1980; "build"; "emacs"; "vi"; }
        { rank = same; 1982; "RCS"; "&lt;curses&gt;"; "IMX"; "SYNED"; }
        { rank = same; 1983; "ksh"; "IFS"; "TTU"; }
        { rank = same; 1985; "nmake"; "Peggy"; }
        { rank = same; 1986; "C*"; "ncpp"; "ksh-i"; "&lt;curses-i&gt;"; "PG2"; }
        { rank = same; 1987; "Ansi cpp"; "nmake 2.0"; "3D File System"; "fdelta";
            "DAG"; "CSAS";}
        { rank = same; 1988; "CIA"; "SBCS"; "ksh-88"; "PEGASUS/PML"; "PAX";
            "backtalk"; }
        { rank = same; 1989; "CIA++"; "APP"; "SHIP"; "DataShare"; "ryacc";
            "Mosaic"; }
        { rank = same; 1990; "libft"; "CoShell"; "DIA"; "IFS-i"; "kyacc"; "sfio";
            "yeast"; "ML-X"; "DOT"; }
        { rank = same; "future"; "Adv. Software Technology"; }
        "PEGASUS/PML" -&gt; "ML-X";
        "SCCS" -&gt; "nmake";
        "SCCS" -&gt; "3D File System";
        "SCCS" -&gt; "RCS";
        "make" -&gt; "nmake";
        "make" -&gt; "build";
        .
        .
        .
    }

.. graphviz::

    digraph asde91 {
        ranksep=.75; size = "7.5,7.5";
        {
            node [shape=plaintext, fontsize=16];
            /* the time-line graph */
            past -&gt; 1978 -&gt; 1980 -&gt; 1982 -&gt; 1983 -&gt; 1985 -&gt; 1986 -&gt;
                     1987 -&gt; 1988 -&gt; 1989 -&gt; 1990 -&gt; "future";
            /* ancestor programs */
            "Bourne sh"; "make"; "SCCS"; "yacc"; "cron"; "Reiser cpp";
            "Cshell"; "emacs"; "build"; "vi"; "&lt;curses&gt;"; "RCS"; "C*";
        }
        { rank = same;
            "Software IS"; "Configuration Mgt"; "Architecture &amp; Libraries";
            "Process";
        };
        node [shape=box];
        { rank = same; "past"; "SCCS"; "make"; "Bourne sh"; "yacc"; "cron"; }
        { rank = same; 1978; "Reiser cpp"; "Cshell"; }
        { rank = same; 1980; "build"; "emacs"; "vi"; }
        { rank = same; 1982; "RCS"; "&lt;curses&gt;"; "IMX"; "SYNED"; }
        { rank = same; 1983; "ksh"; "IFS"; "TTU"; }
        { rank = same; 1985; "nmake"; "Peggy"; }
        { rank = same; 1986; "C*"; "ncpp"; "ksh-i"; "&lt;curses-i&gt;"; "PG2"; }
        { rank = same; 1987; "Ansi cpp"; "nmake 2.0"; "3D File System"; "fdelta";
            "DAG"; "CSAS";}
        { rank = same; 1988; "CIA"; "SBCS"; "ksh-88"; "PEGASUS/PML"; "PAX";
            "backtalk"; }
        { rank = same; 1989; "CIA++"; "APP"; "SHIP"; "DataShare"; "ryacc";
            "Mosaic"; }
        { rank = same; 1990; "libft"; "CoShell"; "DIA"; "IFS-i"; "kyacc"; "sfio";
            "yeast"; "ML-X"; "DOT"; }
        { rank = same; "future"; "Adv. Software Technology"; }
        "PEGASUS/PML" -&gt; "ML-X";
        "SCCS" -&gt; "nmake";
        "SCCS" -&gt; "3D File System";
        "SCCS" -&gt; "RCS";
        "make" -&gt; "nmake";
        "make" -&gt; "build";
    }

</t>
<t tx="ekr.20100526092131.2165">Machine
 
 - physical
 - virtual
 
  - id
  
   - mac
   - ip
   - description
   - name
     - hostname
     - netbios
     - fqname
     
   - storage
   - ram
     
App

Input, Output

 - keyboard
 - mouse
 - file
 
   - config
   - log
   - data
   
 - stream

</t>
<t tx="ekr.20100526092131.2166">/etc/dhcp3/dhcpd.conf::

	option ntp-servers 192.168.0.12;
	option root-path "";
	option routers 192.168.0.12;
	option broadcast-address 192.168.0.255;
	option domain-name-servers 192.168.0.253, 192.168.0.12;
	use-host-decl-names on;
	default-lease-time 86400;
	max-lease-time 86400;
	#stop


	# Courthouse
	subnet 192.168.0.0 netmask 255.255.255.0 {
		range dynamic-bootp 192.168.0.151 192.168.0.225;
		}
	# Kent's W2k workstation
	host itstation2 {
		hardware ethernet 00:16:E6:9C:24:DF;
		fixed-address 192.168.0.32;
		}
	# Office workstation
	host itstation3 {
		hardware ethernet 00:24:1d:d1:4d:4b;
		fixed-address 192.168.0.33;
		}
	# lappy wireless
	host lappy-wireless {
		hardware ethernet 00:12:F0:E9:55:84;
		fixed-address 192.168.0.35;
		}
	# Plotter/Scanner storage
	host hpdjcc {
		hardware ethernet 00:d0:c9:98:92:2a;
		fixed-address 192.168.0.90;
		}
	# DNR License machine in Clerks office
	host DNRLICENSES {
		hardware ethernet 00:03:2d:0d:57:e2;
		fixed-address 192.168.0.40;
		}
	# Peg Kurilla laptop
	host COUNTYADMIN {
		hardware ethernet 00:19:7d:c9:25:d2;
		fixed-address 192.168.0.50;
		}
	# Netgear WG511v2 PCMCIA card (UWEX)
	host uwextwin98 {
		hardware ethernet 00:1b:2f:28:f0:91;
		fixed-address 192.168.0.51;
		}
	# GIS-MAIN Gis workstation
	host GIS-MAIN {
		hardware ethernet 00:0a:a6:8d:4f:2f;
		fixed-address 192.168.0.36;
		}
	# Mable in ROD
	host DEEDS-MABLE {
		hardware ethernet 00:18:f3:50:5c:e2;
		fixed-address 192.168.0.55;
		}
	# Kathie in Deeds
	host AUDITMACHINE {
		hardware ethernet 00:0c:6e:f5:7f:95;
		fixed-address 192.168.0.56;
		}
	# Karen in Deeds
	host KM-SCANNER {
		hardware ethernet 00:11:09:b4:fb:5d;
		fixed-address 192.168.0.57;
		}
	# Counter in Deeds
	host DEEDS-COUNTER {
		hardware ethernet 00:01:03:c4:d8:96;
		fixed-address 192.168.0.58;
		}

	# Lappy wired
	host lappy {
		hardware ethernet 00:0a:e4:37:00:80;
		fixed-address 192.168.0.34;
		}
	# laserfiche host
	host laserfiche {
		hardware ethernet 00:26:18:fb:98:8e;
		fixed-address 192.168.0.10;
		}
	# laserfiche VM
	host laserfichexp {
		hardware ethernet 08:00:27:d3:74:a7;
		fixed-address 192.168.0.11;
		}
	# Tape drive host in Child Support
	host csa-tape01 {
		hardware ethernet 00:40:63:d7:ae:e6;
		fixed-address 192.168.0.17;
		}
	# Child Support MX680 Canon all in one
	host CSA-MX680 {
		hardware ethernet 00:1e:8f:9c:1e:d8;
		fixed-address 192.168.0.30;
		}
	# Darlene in Child Support
	host CSA-70 {
		hardware ethernet 90:e6:ba:88:2f:ca;
		fixed-address 192.168.0.70;
		}
	# Jenny in Child Support
	host CSA-71 {
		hardware ethernet e0:cb:4e:32:09:2d;
		fixed-address 192.168.0.71;
		}
	# Bev's desktop workstation (in Lenovo case)
	host CSA-72 {
		hardware ethernet e0:cb:4e:24:33:1d;
		fixed-address 192.168.0.72;
		}
	# Patty in Treasurers
	host TREAS-85 {
		hardware ethernet 00:50:fc:cf:08:91;
		fixed-address 192.168.0.85;
		}
	# Tracey's computer
	host TREAS-86 {
		hardware ethernet 00:40:63:d8:9d:ce;
		fixed-address 192.168.0.86;
		}
	# Jeff Beirl's computer
	host ADMIN-91 {
		hardware ethernet 00:17:31:88:55:a1;
		fixed-address 192.168.0.91;
		}
	# Peg Kurilla's laptop
	host ADMIN-93 {
		hardware ethernet 00:19:7d:c9:25:d2;
		fixed-address 192.168.0.93;
		}
	# Treasurer counter machine
	host TREAS-87 {
		hardware ethernet 00:40:f4:4e:9c:b7;
		fixed-address 192.168.0.87;
		}
	# Sid in CSA
	host CSA-75 {
		hardware ethernet 00:26:55:43:9f:b9;
		fixed-address 192.168.0.76;
		}
	# Larry Hildebrandt
	host ZONE-100 {
		hardware ethernet 00:24:21:f0:f1:4b;
		fixed-address 192.168.0.100;
		}
	# Patience in CSA
	host CSA-73 {
		hardware ethernet 90:e6:ba:3a:47:56;
		fixed-address 192.168.0.73;
		}
	# Griff
	host CSA-77 {
		hardware ethernet 00:23:5a:d4:e5:2d;
		fixed-address 192.168.0.77;
		}
	# Traci in CSA
	host CSA-74 {
		hardware ethernet 18:a9:05:16:a6:4b;
		fixed-address 192.168.0.74;
		}
	# Joan in CSA
	host CSA-75 {
		hardware ethernet 18:a9:05:1f:98:df;
		fixed-address 192.168.0.75;
		}

</t>
<t tx="ekr.20100526092131.2167">&gt;&gt;&gt; import networkx as nx

&gt;&gt;&gt; G=nx.Graph()
&gt;&gt;&gt; G.add_node("spam")
&gt;&gt;&gt; G.add_edge(1,2)
&gt;&gt;&gt; print G.nodes()
[1, 2, 'spam']
&gt;&gt;&gt; print G.edges()
[(1, 2)]

</t>
<t tx="ekr.20100526092131.2168">.. include:: /home/ktenney/work/fetched/networkx/doc/source/tutorial/tutorial.rst

</t>
<t tx="ekr.20100526092131.2169"></t>
<t tx="ekr.20100526092131.2170">.. code-block:: python

 import networkx
 import pygraphviz
 import os
 G = networkx.Graph()
 
 contents = os.listdir('/tmp')
 
 
 G.add_nodes_from(contents)
 networkx.write_dot(G, '/tmp/networkx')
 
.. graphviz::
 
   digraph  {
	"pulse-LNhuxKcTtQ7o";
	"manuel-testrunner.py";
	"orbit-root";
	".ICE-unix";
	".esd-1000";
	".X0-lock";
	"keyring-IaomNN";
	"virtual-ktenney.OPfhI7";
	"orbit-ktenney";
	"ssh-AHVfka1250";
	"server-B20D7FC79C7F597315E3E501AEF10E0D866E8E92.xkm";
	"serverauth.XfwQdCpMON";
	".X11-unix";
	"tracker-ktenney";
	networkx;
	".exchange-ktenney";
	"Miro_Download_Daemon_1000.txt";
	"manuel-testfile.py";
      }

</t>
<t tx="ekr.20100526092131.2171"># differences between pygraphviz and networkx
# http://networkx.lanl.gov/pygraphviz/reference/api_notes.html
&gt;&gt;&gt; import pygraphviz
&gt;&gt;&gt; pygraphviz

</t>
<t tx="ekr.20100526092131.2172">.. code-block:: python

    import networkx

</t>
<t tx="ekr.20100615095815.2189">import leo.core.leoPlugins as leoPlugins

def on_deactivate(tag,keys):
    c = keys.get('c')
    g.trace(c)

def on_activate(tag,keys):
    c = keys.get('c',keys)
    g.trace(c)

leoPlugins.registerHandler("deactivate", on_deactivate)
leoPlugins.registerHandler("activate", on_activate)

print('window events activated')</t>
<t tx="ekr.20100616085524.2191">for name,val,c,letter in g.app.config.config_iter(c):
    print('%45s %s %s' % (name,letter,val))</t>
<t tx="ekr.20100729114420.2152">@language plain

This is a test.</t>
<t tx="ekr.20100731123441.2155">def searchDir(path,pattern):
    print('\ndir',path)
    paths = glob.glob(g.os_path_join(path,'*'))
    files = [z for z in paths if not g.os_path_isdir(z)]
    dirs  = [z for z in paths if g.os_path_isdir(z)]
    for fn in files:
        if not fn.endswith('.pyc'):
            print(g.shortFileName(fn))
            found = False
            s,e = g.readFileIntoString(fn)
            if ignoreCase:
                s = s.lower()
                pattern = pattern.lower()
            i = 0
            while i &lt; len(s):
                i = s.find(pattern,i)
                if i == -1: break
                n1,n2 = g.getLine(s,i)
                i = n2
                if not found:
                    g.pr('\n','-' * 10,g.shortFileName(fn))
                    found = True
                g.pr(s[n1:n2-1])
    for fn in dirs:
        searchDir(g.os_path_join(path,fn),pattern)</t>
<t tx="ekr.20100812102648.2193">@ @rst-markup
########################
Leo's code markup script
########################
@c
'''A script showing how to convert code in Leo outlines to rST/Sphinx code.

The defaultOptions dict specifies default options.

This script uses leoRst.py:code_to_rst_command.'''

if 1: # Format a particular node.
    h = '@button format-code'
    p = g.findNodeAnywhere(c,h)

&lt;&lt; options &gt;&gt;

if p:
    c.rstCommands.code_to_rst_command(scriptSettingsDict=scriptSettingsDict)
else:
    print('not found',h)
</t>
<t tx="ekr.20100812102648.2195">@ Here are the options
@c
fn = '%s.html' % (g.sanitize_filename(p.h))

# g.es('output file',repr(fn))

scriptSettingsDict = {
    'output-file-name': 'format-code-output.html', # fn,
    'call-docutils': True,
    'number-code-lines': True,
    'show_doc_parts_as_paragraphs': True,
    'stylesheet_name': 'default.css',
    # 'stylesheet_path': '../doc', # Must be None, not ''.
    'write-intermediate-file': True,
    'write_intermediate_extension': 'txt'
}

# old_dict = {

    # # The following options are definitely used in the script.
    # 'generate-rst-header-comment': True,
    # 'output-file-name': fn,
    # 'show_headlines': True,
    # 'show_options_nodes': False,
    # 'show_organizer_nodes': True,
    # 'show_sections': True,
    # 'underline_characters': '''#=+*^~"'`-:&gt;&lt;_''',
    # 'verbose': True,

    # # The following are not used, but probably should be used.
    # 'code_block_string': '::',
    # 'default_path': None, # Must be None, not ''.
    # 'encoding': 'utf-8',
    # 'publish_argv_for_missing_stylesheets': None,
    # 'stylesheet_embed': True,
    # 'stylesheet_name': 'default.css',
    # 'stylesheet_path': None, # Must be None, not ''.

    # # The following are not used. Their status is unclear.
    # 'show_leo_directives': False,
# }
</t>
<t tx="ekr.20100812114823.2176"></t>
<t tx="ekr.20100812114823.2177">def code_to_rst_command (self,event=None,p=None,scriptSettingsDict=None):

    '''Format the presently selected node as computer code.

    When run from the minibuffer, initial settings come from the outline, as usual.

    When called from a script, initial setting may come from scriptSettingsDict.

    Return true and set self.source and self.output if all requested files were written.
    '''

    trace = False and not g.unitTesting
    c = self.c
    if p: p = p.copy()
    else: p = c.p

    # **Important**: This command works as much like the rst3 command as possible.
    # Difference arise because there is no @rst node to specify a filename.
    # Instead we get the filename from scriptSettingsDict, or use 'code_to_rst.html'

    # Capture the settings, munging all settings.
    self.scriptSettingsDict = {}
    d = scriptSettingsDict
    if d:
        for key in d.keys():
            self.scriptSettingsDict[self.munge(key)] = d.get(key)

    # From processTree...
    self.topLevel = p.level() # Define toplevel separately for each rst file.
    self.preprocessTree(p)
    self.scanAllOptions(p) # So we can get the next options.

    # getOption will not work until scanAllOptions::initOptionsFromSettings has been called.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')
    g.trace(self.getOption('output-file-name'))
    outputFileName = self.getOption('output-file-name') or 'code_to_rst.html'
    junk,self.ext = g.os_path_splitext(outputFileName)
    isHtml = self.ext in ('.html','.htm')

    # From writeSpecialTree...
    self.initWrite(p)
    self.outputFile = StringIO()
    self.write_code_tree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if callDocutils or writeIntermediateFile:
        # **Note**: self.outputFileName does not exist.
        self.outputFileName = self.computeOutputFileName(outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = c.os_path_finalize(theDir)
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.es_print('did not create:',theDir,color='red')
                return False

    if writeIntermediateFile:
        ext = self.getOption('write_intermediate_extension') or '.txt' # .txt by default.
        if not ext.startswith('.'): ext = '.' + ext
        name = self.outputFileName.rsplit('.',1)[0] + ext
        if trace: g.trace('intermediate file',name)
        if g.isPython3:
            f = open(name,'w',encoding=self.encoding)
        else:
            f = open(name,'w')
        f.write(self.source)
        f.close()
        self.report(name)

    if callDocutils:
        if trace: g.trace('calling docutils')
        try:
            output = self.writeToDocutils(self.source)
            if g.isBytes(output):
                output = g.toUnicode(output)
        except Exception:
            g.pr('Exception in docutils')
            g.es_exception()
            return False

        if isHtml:
            import re
            if g.isBytes(output):
                output = g.toUnicode(output)
            idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')
            if idxTitle &gt; -1:
                m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', output)
                if not m:
                    m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', output)
                if m:
                    output = output.replace(
                        '&lt;title&gt;&lt;/title&gt;',
                        '&lt;title&gt;%s&lt;/title&gt;' % m.group(1)
                    )

        self.stringOutput = output # Always useful for scripts.

        # Write the file to the directory containing the .leo file.
        f = open(self.outputFileName,'w')
        f.write(output)
        f.close()
        self.report(self.outputFileName)

    return True
</t>
<t tx="ekr.20100812114823.2178">def write_code_body (self,p):

    trace = False
    self.p = p.copy() # for traces.
    if not p.b.strip():
        return # No need to write any more newlines.

    showDocsAsParagraphs = self.getOption('show_doc_parts_as_paragraphs')
    lines = g.splitLines(p.b)
    parts = self.split_parts(lines,showDocsAsParagraphs)
    result = []
    for kind,lines in parts:
        if trace: g.trace(kind,len(lines),p.h)
        if kind == '@rst-option': # Also handles '@rst-options'
            pass # The prepass has already handled the options.
        elif kind == '@rst-markup':
            lines.extend('\n')
            result.extend(lines)
        elif kind == '@doc':
            if showDocsAsParagraphs:
                result.extend(lines)
                result.append('\n')
            else:
                result.extend(self.write_code_block(lines))
        elif kind == 'code':
            result.extend(self.write_code_block(lines))
        else:
            g.trace('Can not happen',kind)

    # Write the lines with exactly two trailing newlines.
    s = ''.join(result).rstrip() + '\n\n'
    self.write(s)
</t>
<t tx="ekr.20100812114823.2179">def split_parts (self,lines,showDocsAsParagraphs):

    '''Split a list of body lines into a list of tuples (kind,lines).'''

    kind,parts,part_lines = 'code',[],[]
    for s in lines:
        if g.match_word(s,0,'@ @rst-markup'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind = '@rst-markup'
            n = len('@ @rst-markup')
            after = s[n:].strip()
            part_lines = g.choose(after,[after],[])
        elif s.startswith('@ @rst-option'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind,part_lines = '@rst-option',[s] # part_lines will be ignored.
        elif s.startswith('@ ') or s.startswith('@\n') or s.startswith('@doc'):
            if showDocsAsParagraphs:
                if part_lines: parts.append((kind,part_lines[:]),)
                kind = '@doc'
                # Put only what follows @ or @doc
                n = g.choose(s.startswith('@doc'),4,1)
                after = s[n:].lstrip()
                part_lines = g.choose(after,[after],[])
            else:
                part_lines.append(s) # still in code mode.
        elif g.match_word(s,0,'@c') and kind != 'code':
            if kind == '@doc' and not showDocsAsParagraphs:
                    part_lines.append(s) # Show the @c as code.
            parts.append((kind,part_lines[:]),)
            kind,part_lines = 'code',[]
        else:
            part_lines.append(s)

    if part_lines:
        parts.append((kind,part_lines[:]),)

    return parts
</t>
<t tx="ekr.20100812114823.2180">def write_code_block (self,lines):

    result = ['::\n\n'] # ['[**code block**]\n\n']

    if self.getOption('number-code-lines'):
        i = 1
        for s in lines:
            result.append('    %d: %s' % (i,s))
            i += 1
    else:
        result.extend(['    %s' % (z) for z in lines])

    s = ''.join(result).rstrip()+'\n\n'
    return g.splitLines(s)
</t>
<t tx="ekr.20100812114823.2181">def write_code_headline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''


    docOnly             = self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.write_code_headline_helper(p)
</t>
<t tx="ekr.20100812114823.2182">def write_code_headline_helper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for @rst-option or @rst-options or @rst-no-head.
        if word in ('@rst-option','@rst-options','@rst-no-head','@rst-no-headlines'):
            return

        for prefix in ('@rst-ignore-node','@rst-ignore-tree','@rst-ignore'):
            if word == prefix:
                h = h [len(word):].strip()
                break

    if not h.strip(): return

    if self.getOption('show_sections'):
        self.write(self.underline(h,p))
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
</t>
<t tx="ekr.20100812114823.2183">def write_code_node (self,p):

    '''Format a node according to the options presently in effect.

    Side effect: advance p'''

    h = p.h.strip()
    self.scanAllOptions(p)

    if self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.write_code_headline(p)
        self.write_code_body(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20100812114823.2184">def write_code_tree (self,p):

    '''Write p's tree as code to self.outputFile.'''

    self.scanAllOptions(p) # So we can get the next option.

    if self.getOption('generate_rst_header_comment'):
        self.write('.. rst3: filename: %s\n\n' % self.outputFileName)

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.write_code_node(p) # Side effect: advances p.
</t>
<t tx="ekr.20100812114823.2185"></t>
<t tx="ekr.20100812114823.2186">def getOption (self,name):

    # 2010/08/12: munging names here is safe because setOption munges.
    return self.optionsDict.get(self.munge(name))

def setOption (self,name,val,tag):

    self.optionsDict [self.munge(name)] = val
</t>
<t tx="ekr.20100812114823.2187">def initOptionsFromSettings (self):

    c = self.c

    d = self.defaultOptionsDict
    keys = sorted(d)

    for key in keys:
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break

    # 2010/08/12: Script settings override everything else.
    d2 = self.scriptSettingsDict or {}
    for key in d2.keys():
        val = d2.get(key)
        # g.trace(key,val)
        self.setOption(key,val,'initOptionsFromSettings')

    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.es('No http_server_support: can not import mod_http plugin',color='red')
        self.setOption('http_server_support',False)
</t>
<t tx="ekr.20100812114823.2188">def writeSpecialTree (self,p,toString,justOneFile):

    c = self.c
    isHtml = self.ext in ('.html','.htm')
    if isHtml and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            g.es('SilverCity not present so no syntax highlighting')

    self.initWrite(p)
        # was encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if not toString:
        # Compute this here for use by intermediate file.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = c.os_path_finalize(theDir)
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.es_print('did not create:',theDir,color='red')
                return False

        if self.getOption('write_intermediate_file'):
            ext = self.getOption('write_intermediate_extension')
            if not ext.startswith('.'): ext = '.' + ext
            name = self.outputFileName.rsplit('.',1)[0] + ext 
            if g.isPython3: # 2010/04/21
                f = open(name,'w',encoding=self.encoding)
            else:
                f = open(name,'w')
            f.write(self.source)
            f.close()
            self.report(name)

    # g.trace('call_docutils',self.getOption('call_docutils'))
    if not self.getOption('call_docutils'):
        return False

    try:
        output = self.writeToDocutils(self.source)
        if g.isBytes(output):
            output = g.toUnicode(output)
        ok = output is not None
    except Exception:
        g.pr('Exception in docutils')
        g.es_exception()
        ok = False

    if ok:
        if isHtml:
            import re
            # g.trace(repr(output)) # Type is byte for Python3.
            idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')
            if idxTitle &gt; -1:
                m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', output)
                if not m:
                    m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', output)
                if m:
                    output = output.replace(
                        '&lt;title&gt;&lt;/title&gt;',
                        '&lt;title&gt;%s&lt;/title&gt;' % m.group(1)
                    )

        if toString:
            self.stringOutput = output
        else:
            # Write the file to the directory containing the .leo file.
            f = open(self.outputFileName,'w')
            f.write(output)
            f.close()
            self.http_endTree(self.outputFileName, p, justOneFile=justOneFile)

    return ok
</t>
<t tx="ekr.20100821214143.2190">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;!--@+leo-ver=5-thin--&gt;
&lt;!--@+node:ekr.20100808060203.4273: * @thin html/front.html--&gt;
&lt;!--@@first--&gt;
&lt;!--@@first--&gt;

&lt;!--@@language html--&gt;
&lt;!--@@tabwidth -2--&gt;

&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
    &lt;!--@+&lt;&lt; head &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4274: ** &lt;&lt; head &gt;&gt;--&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;

    &lt;title&gt;Leo's Home Page&lt;/title&gt;
    &lt;link rel="stylesheet" href="_static/default.css" type="text/css" /&gt;
    &lt;link rel="stylesheet" href="_static/pygments.css" type="text/css" /&gt;
    &lt;!--
    &lt;script type="text/javascript"&gt;
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.7-final',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    &lt;/script&gt;
    --&gt;
    &lt;!-- &lt;script type="text/javascript" src="_static/jquery.js"&gt;&lt;/script&gt;--&gt;
    &lt;!-- &lt;script type="text/javascript" src="_static/doctools.js"&gt;&lt;/script&gt;--&gt;
    &lt;link rel="top" title="Leo v4.7-final documentation" href="index.html" /&gt;
    &lt;link rel="Users Guide" title="Leo&amp;#8217;s Users Guide" href="leo_toc.html" /&gt;
    &lt;!-- &lt;link rel="prev" title="Chapter 5: Using LeoÃ¢â‚¬â„¢s Commands" href="commands.html" /&gt;--&gt; 
    &lt;!--@-&lt;&lt; head &gt;&gt;--&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--@+&lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4276: ** &lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;div class="related"&gt;
      &lt;h3&gt;Navigation&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li class="right" style="margin-right: 10px"&gt;
          &lt;a href="genindex.html" title="General Index"
             accesskey="I"&gt;index&lt;/a&gt;&lt;/li&gt;
        &lt;li class="right" &gt;
          &lt;a href="leo_toc.html" title="Leo&amp;#8217;s Users Guide"
             accesskey="N"&gt;contents&lt;/a&gt; |&lt;/li&gt;
        &lt;!--
        &lt;li class="right" &gt;
          &lt;a href="commands.html" title="Chapter 5: Using Leo&amp;#8217;s Commands"
             accesskey="P"&gt;previous&lt;/a&gt; |&lt;/li&gt;
        --&gt;
        &lt;li&gt;&lt;a href="leo_toc.html"&gt;Leo v4.7-final documentation&lt;/a&gt; &amp;raquo;&lt;/li&gt;

      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;div class="document"&gt;
      &lt;div class="documentwrapper"&gt;
        &lt;div class="bodywrapper"&gt;
          &lt;div class="body"&gt;
            &lt;!--@+&lt;&lt; div outer section &gt;&gt;--&gt;
            &lt;!--@+node:ekr.20100808060203.4286: ** &lt;&lt; div outer section &gt;&gt;--&gt;
            &lt;div class="section" id="Leo&amp;#8217;s Home page"&gt;

                &lt;h1&gt;Leo&amp;#8217;s Home Page&lt;/h1&gt;

                Leo is...

                &lt;!--@+&lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;!--@+node:ekr.20100808060203.4288: *3* &lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;li&gt;
                    An outline-oriented &lt;i&gt;browser&lt;/i&gt; and &lt;i&gt;project manager&lt;/i&gt; that organizes&lt;br&gt;
                    programs, web sites, URL's, pictures, movies or any other kind of data.&lt;br&gt;
                    You can organize your data in as many ways as you like within a &lt;i&gt;single&lt;/i&gt; outline.&lt;/li&gt;
                &lt;li&gt;
                    A &lt;i&gt;programmer's editor&lt;/i&gt; that fully integrates outline structure with programming.
                    &lt;!--
                    &lt;a HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/a&gt; and
                    &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt; markup.&lt;/li&gt;
                    --&gt;
                &lt;li&gt;
                    &lt;i&gt;Fully scriptable&lt;/i&gt; using &lt;a HREF="http://www.python.org/"&gt;Python&lt;/a&gt;.
                    Leo's core is 100% pure Python.&lt;/li&gt;
                &lt;li&gt;
                    &lt;i&gt;Portable&lt;/i&gt;. Leo runs on Windows, Linux and MacOS X.&lt;br&gt;
                    Leo requires either the
                    &lt;a HREF="http://docs.python.org/library/tkinter.html"&gt;Tkinter&lt;/a&gt; or
                    &lt;a HREF="http://www.riverbankcomputing.co.uk/software/pyqt/intro"&gt;PyQt&lt;/a&gt; widget set.&lt;br&gt;
                    Leo's outline files are &lt;a HREF="http://www.w3.org/XML/"&gt;XML&lt;/a&gt; format.&lt;/li&gt;
                &lt;li&gt;
                    &lt;a href="http://www.opensource.org/"&gt;&lt;i&gt;Open Software&lt;/i&gt;&lt;/a&gt;,
                    distributed under the
                    &lt;a href="http://www.opensource.org/licenses/mit-license.php/"&gt;MIT License&lt;/a&gt;.&lt;/li&gt;
                &lt;!--@-&lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;!-- div body toc --&gt;
                &lt;!-- &lt; &lt; inner sections &gt; &gt; --&gt;

                &lt;p&gt;Leo has an active community of helpful users and developers.&lt;br&gt;
                Please use the &lt;a href="http://groups.google.com/group/leo-editor"&gt;leo-editor&lt;/a&gt;
                group to ask questions and make suggestions.&lt;/p&gt;

                &lt;p&gt;Leo's author is &lt;a HREF="ekr.html"&gt;Edward K. Ream&lt;/a&gt;&lt;/p&gt;

            &lt;/div&gt;
            &lt;!--@-&lt;&lt; div outer section &gt;&gt;--&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;!--@+&lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;!--@+node:ekr.20100808060203.4282: ** &lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;div class="sphinxsidebar"&gt;
          &lt;div class="sphinxsidebarwrapper"&gt;
              &lt;!--@+&lt;&lt; sidebar contents &gt;&gt;--&gt;
              &lt;!--@+node:ekr.20100808060203.4283: *3* &lt;&lt; sidebar contents &gt;&gt;--&gt;
              &lt;p class="logo"&gt;&lt;a href="leo_toc.html"&gt;
                &lt;img class="logo" src="_static/Leo4-80-border.jpg" alt="Logo"/&gt;&lt;/a&gt;&lt;/p&gt;

              &lt;a class="reference external" href="intro.html"&gt;
                Read this tutorial first&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;
                Another tutorial&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http:screen-shots.html"&gt;
                Screen shots of Leo&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="testimonials.html"&gt;
                Quotes from Leo&amp;#8217;s Users&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external"
                href="http://sourceforge.net/project/showfiles.php?group_id=3458&amp;amp;package_id=29106"&gt;
                Download Leo&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://groups.google.com/group/leo-editor"&gt;
                leo-editor: Google Groups&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://launchpad.net/leo-editor"&gt;
                leo-editor: Launchpad&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://leo.zwiki.org"&gt;
                Leo&amp;#8217;s Wiki&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://www.mind-mapping.org/"&gt;
                Mind Mapping&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="leoLinks.html"&gt;
                More links...&lt;/a&gt;&lt;br&gt;

              &lt;!-- &lt;a class="reference external"  href="install.html"&gt;Installing Leo&lt;/a&gt;&lt;br&gt;--&gt; 
              &lt;!-- &lt;a class="reference external"  href="intro.html"&gt;Beginners Guide&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- &lt;a class="reference external"  href="leo_toc.html"&gt;Users Guide&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- &lt;a class="reference external"  href="FAQ.html"&gt;FAQ&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!--Leo&amp;#8217;s &lt;a class="reference external" href="http://www.greygreen.org/leo/"&gt;Daily snapshots&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- 
              &lt;h5&gt;Edward K. Ream&lt;/h5&gt;
              &lt;a class="reference external" href="ekr.html"&gt;Home&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="mailto:edreamleo@gmail.com"&gt;Contact&lt;/a&gt;&lt;br&gt;
              --&gt; 
              &lt;!--@-&lt;&lt; sidebar contents &gt;&gt;--&gt;
          &lt;!-- &lt; &lt; sidebar links &gt; &gt; --&gt;
          &lt;!-- &lt; &lt; searchbox &gt; &gt; --&gt;
          &lt;/div&gt;
      &lt;/div&gt;
      &lt;!--@-&lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;div class="clearer"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;!--@+&lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4277: ** &lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;div class="related"&gt;
      &lt;h3&gt;Navigation&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li class="right" style="margin-right: 10px"&gt;
          &lt;a href="genindex.html" title="General Index"
             &gt;index&lt;/a&gt;&lt;/li&gt;
        &lt;li class="right" &gt;
          &lt;a href="leo_toc.html" title="Leo&amp;#8217;s Users Guide"
             &gt;contents&lt;/a&gt; |&lt;/li&gt;
        &lt;!--
        &lt;li class="right" &gt;
          &lt;a href="commands.html" title="Chapter 5: Using Leo&amp;#8217;s Commands"
             &gt;previous&lt;/a&gt; |&lt;/li&gt;
        --&gt;
        &lt;li&gt;&lt;a href="leo_toc.html"&gt;Leo v4.7-final documentation&lt;/a&gt; &amp;raquo;&lt;/li&gt; 
      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;!--@+&lt;&lt; div footer &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4278: ** &lt;&lt; div footer &gt;&gt;--&gt;
    &lt;div class="footer"&gt;
      &amp;copy; Copyright 2010, Edward K. Ream.
      Last updated on Aug 08, 2010.
      Created using &lt;a href="http://sphinx.pocoo.org/"&gt;Sphinx&lt;/a&gt; 0.6.3.
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div footer &gt;&gt;--&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;!--@-leo--&gt;
</t>
<t tx="ekr.20100824124015.2195">for p in c.allNodes_iter():
    v = p.v
    icons = v.u and v.u.get('icons')
    if icons:
        for d in icons:
            fn = d.get('file')
            icon = g.app.gui.getIconImage(fn)
            print('v %s icon %s %s' % (id(v),id(icon),fn))
print('done')
</t>
<t tx="ekr.20100907114225.2209">from leo.external import lproto
import os

addr = open(os.path.expanduser('~/.leo/leoserv_sockname')).read()
print("will connect to",addr)
pc  = lproto.LProtoClient(addr)
pc.send("""

g.es("hello world from remote") 
c = g.app.commanders()[0]

""")

# note how c persists between calls
pc.send("""
c.k.simulateCommand('stickynote')
""")</t>
<t tx="ekr.20100910124218.2257"></t>
<t tx="ekr.20100910124218.2258"></t>
<t tx="ekr.20100910124218.2259"></t>
<t tx="ekr.20100911195503.2426">import os

cd = os.path.normcase(g.os_path_finalize(os.getcwd())) # .replace('c:','C:')
ld = os.path.normcase(g.os_path_finalize(g.app.loadDir))
doc = os.path.normcase(g.os_path_finalize_join(ld,'..','doc'))
ss = os.path.normcase(g.os_path_finalize_join(ld,'..','doc','html','screen-shots'))
fn = g.os_path_finalize(c.fileName())
fd,junk = g.os_path_split(fn)
fd = os.path.normcase(fd)

table = (
    (cd,doc),
    (ld,doc),
    #(fd,doc),
    (cd,ss),
    (ld,ss),
)
for start,path in table:
    print(start,path,'--&gt;',os.path.relpath(path,start).replace('\\','/'))</t>
<t tx="ekr.20101004104134.2347">
</t>
<t tx="ekr.20101009105505.2295">True (recommended):
    Write "E" attribute bits in &lt;v&gt; elements.
    Leo outlines will record the expansion state of all nodes.
    
False:
    (Good for files like unitTest.leo)
    Suppress "E" attribute bits in &lt;v&gt; elements.
    Only the ancestors of the presently selected node will
    be expanded when Leo opens an outline.</t>
<t tx="ekr.20101014040509.2310">../Icons/SplashScreen.ico

</t>
<t tx="ekr.20101014040509.2311">C:\Users\Public\Videos\Sample Videos\Wildlife.wmv
</t>
<t tx="ekr.20101014040509.2312">C:\Users\edreamleo\Documents\Music\2001- A Space Odyssey [Rhino]\06 Gayane Ballet Suite.mp3</t>
<t tx="ekr.20101014040509.2313">http://www.weather.com/weather/today/Madison+WI+53705?from=hp_promolocator&amp;lswe=53705&amp;lwsa=Weather36HourHealthCommand</t>
<t tx="ekr.20101014040509.2314">http://mail.google.com/mail/#inbox</t>
<t tx="ekr.20101014040509.2316">import PyQt4.phonon as phonon
phonon = phonon.Phonon

top = c.frame.top # A DynamicWindow
sw = top.stackedWidget # QStackedWidget

@others

run(p)
</t>
<t tx="ekr.20101014040509.2317">def run(p):

    tag = '@movie'

    if not g.match_word(p.h,0,tag):
        return g.es('Not an %s node' % (tag))

    if p.b.strip():
        fn = p.b.strip()
    else:
        fn = p.h[len(tag):].strip()
    path = g.os_path_finalize_join(g.app.loadDir,fn)
    if not g.os_path_exists(path):
        return g.es('Not found: %s' % (fn))
        
    g.trace(path)

    if hasattr(top,'video_player'):
        vp = top.video_player
    else:
        # This call creates a big problem later.
        top.video_player = vp = phonon.VideoPlayer(phonon.VideoCategory)
    vw = vp.videoWidget()
    vp.load(phonon.MediaSource(path))
    sw.addWidget(vw)
    sw.setCurrentWidget(vw)
    sw.show()
    vp.play()
</t>
<t tx="ekr.20101014040509.2318">top = c.frame.top
sw = top.stackedWidget

if hasattr(top,'video_player'):
    vp = top.video_player
    vw = vp.videoWidget()
    sw.setCurrentWidget(vw)
    sw.show()
    if vp.isPlaying():
        vp.pause()
    else:
        vp.play()
</t>
<t tx="ekr.20101014040509.2319">top = c.frame.top
sw = top.stackedWidget

if hasattr(top,'video_player'):
    vp = top.video_player
    vp.stop()
    # vp.deleteLater()
    delattr(top,'video_player')

sw.setCurrentWidget(top.text_page)
sw.show()</t>
<t tx="ekr.20101014040509.2320">top = c.frame.top
sw = top.stackedWidget

g.es('stacked widgets...')
for i in range(sw.count()):
    g.es(i,sw.widget(i))</t>
<t tx="ekr.20101014040509.2321">import PyQt4.phonon as phonon
phonon = phonon.Phonon

top = c.frame.top # A DynamicWindow
sw = top.stackedWidget # QStackedWidget

def run(p):
    
    tag = '@movie'

    if not g.match_word(p.h,0,tag):
        return g.es('Not an %s node' % (tag))

    if p.b.strip():
        fn = p.b.strip()
    else:
        fn = p.h[len(tag):].strip()
    path = g.os_path_finalize_join(g.app.loadDir,fn)
    if not g.os_path_exists(path):
        return g.es('Not found: %s' % (fn))

    if hasattr(top,'video_player'):
        vp = top.video_player
    else:
        # This call creates a big problem later.
        vp = phonon.VideoPlayer(phonon.VideoCategory)
    
    top.video_player = vp
    vw = vp.videoWidget()
    if 0:
        sw.addWidget(vw)
        sw.setCurrentWidget(vw)
        sw.show()
    vp.load(phonon.MediaSource(path))
    vp.play()

if 0:
    vp = phonon.VideoPlayer(phonon.VideoCategory)
    # top.video_player = vp
    # delattr(top,'video_player')
else:
    run(p)
g.es('crash test done')
</t>
<t tx="ekr.20101103135707.2439">import leo.core.leoImport as leoImport

leoImport.headToPrevNode(event={'c':c})
</t>
<t tx="ekr.20101103170034.2445">import leo.core.leoImport as leoImport

leoImport.tailToNextNode(event={'c':c})
</t>
<t tx="ekr.20101110190130.2451">from leo.external import lproto
import os

addr = open(os.path.expanduser('~/.leo/leoserv_sockname')).read()
print("will connect to",addr)
pc  = lproto.LProtoClient(addr)
pc.send("""

g.es("hello world from remote") 
c = g.app.commanders()[0]

""")

# note how c persists between calls
pc.send("""
c.k.simulateCommand('stickynote')
""")</t>
<t tx="ekr.20110127090822.2451">@language python



aList = list(c.k.bindingsDict.keys())
aList.sort()
for z in aList: print(z)</t>
<t tx="ekr.20110320203616.2489"></t>
<t tx="ekr.20110320203616.2491">@language rest

#####
Title
#####

This is **bold** and *italics*

Section
=======

- Bullet list
- Another item
- Third item.</t>
<t tx="ekr.20110320203616.2492">''' Creates a window for *live* rendering of rst, html, etc.  (Qt only).

Commands
========

viewrendered.py creates the following (``Alt-X``) commands:

``viewrendered``
    opens a new window where the current body text is rendered as HTML
    (if it starts with '&lt;'), or otherwise reStructuredText.
``viewrendered-big``
    as above, but zoomed in, useful for presentations
``viewrendered-html``
    displays the html source generated from reStructuredText, useful for
    debugging

``viewrendered`` sets the process current directory (os.chdir()) to the path
to the node being rendered, to allow relative paths to work in
``.. image::`` directives.

reStructuredText errors and warnings may be shown.  For example, both::

    Heading
    -------

    `This` is **really** a line of text.

and::

    &lt;h1&gt;Heading&lt;h1&gt;

    &lt;tt&gt;This&lt;/tt&gt; is &lt;b&gt;really&lt;/b&gt; a line of text.

will look something like:

**Heading**

`This` is **really** a line of text.

Settings
========

@string view-rendered-default-kind = rst
----------------------------------------

The default kind of rendering.  One of (big,rst,html)
    
@bool view-rendered-auto-create = False
---------------------------------------

When True, the plugin will create a rendering pane automatically.

'''
</t>
<t tx="ekr.20110320203616.2493">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;!--@+leo-ver=5-thin--&gt;
&lt;!--@+node:ekr.20100808060203.4273: * @thin html/front.html--&gt;
&lt;!--@@first--&gt;
&lt;!--@@first--&gt;

&lt;!--@@language html--&gt;
&lt;!--@@tabwidth -2--&gt;

&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
    &lt;!--@+&lt;&lt; head &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4274: ** &lt;&lt; head &gt;&gt;--&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;

    &lt;title&gt;Leo's Home Page&lt;/title&gt;
    &lt;link rel="stylesheet" href="_static/default.css" type="text/css" /&gt;
    &lt;link rel="stylesheet" href="_static/pygments.css" type="text/css" /&gt;
    &lt;!--
    &lt;script type="text/javascript"&gt;
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.7-final',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    &lt;/script&gt;
    --&gt;
    &lt;!-- &lt;script type="text/javascript" src="_static/jquery.js"&gt;&lt;/script&gt;--&gt;
    &lt;!-- &lt;script type="text/javascript" src="_static/doctools.js"&gt;&lt;/script&gt;--&gt;
    &lt;link rel="top" title="Leo v4.7-final documentation" href="index.html" /&gt;
    &lt;link rel="Users Guide" title="Leo&amp;#8217;s Users Guide" href="leo_toc.html" /&gt;
    &lt;!-- &lt;link rel="prev" title="Chapter 5: Using LeoÃ¢â‚¬â„¢s Commands" href="commands.html" /&gt;--&gt; 
    &lt;!--@-&lt;&lt; head &gt;&gt;--&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--@+&lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4276: ** &lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;div class="related"&gt;
      &lt;h3&gt;Navigation&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li class="right" style="margin-right: 10px"&gt;
          &lt;a href="genindex.html" title="General Index"
             accesskey="I"&gt;index&lt;/a&gt;&lt;/li&gt;
        &lt;li class="right" &gt;
          &lt;a href="leo_toc.html" title="Leo&amp;#8217;s Users Guide"
             accesskey="N"&gt;contents&lt;/a&gt; |&lt;/li&gt;
        &lt;!--
        &lt;li class="right" &gt;
          &lt;a href="commands.html" title="Chapter 5: Using Leo&amp;#8217;s Commands"
             accesskey="P"&gt;previous&lt;/a&gt; |&lt;/li&gt;
        --&gt;
        &lt;li&gt;&lt;a href="leo_toc.html"&gt;Leo v4.7-final documentation&lt;/a&gt; &amp;raquo;&lt;/li&gt;

      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;div class="document"&gt;
      &lt;div class="documentwrapper"&gt;
        &lt;div class="bodywrapper"&gt;
          &lt;div class="body"&gt;
            &lt;!--@+&lt;&lt; div outer section &gt;&gt;--&gt;
            &lt;!--@+node:ekr.20100808060203.4286: ** &lt;&lt; div outer section &gt;&gt;--&gt;
            &lt;div class="section" id="Leo&amp;#8217;s Home page"&gt;

                &lt;h1&gt;Leo&amp;#8217;s Home Page&lt;/h1&gt;

                Leo is...

                &lt;!--@+&lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;!--@+node:ekr.20100808060203.4288: *3* &lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;li&gt;
                    An outline-oriented &lt;i&gt;browser&lt;/i&gt; and &lt;i&gt;project manager&lt;/i&gt; that organizes&lt;br&gt;
                    programs, web sites, URL's, pictures, movies or any other kind of data.&lt;br&gt;
                    You can organize your data in as many ways as you like within a &lt;i&gt;single&lt;/i&gt; outline.&lt;/li&gt;
                &lt;li&gt;
                    A &lt;i&gt;programmer's editor&lt;/i&gt; that fully integrates outline structure with programming.
                    &lt;!--
                    &lt;a HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/a&gt; and
                    &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt; markup.&lt;/li&gt;
                    --&gt;
                &lt;li&gt;
                    &lt;i&gt;Fully scriptable&lt;/i&gt; using &lt;a HREF="http://www.python.org/"&gt;Python&lt;/a&gt;.
                    Leo's core is 100% pure Python.&lt;/li&gt;
                &lt;li&gt;
                    &lt;i&gt;Portable&lt;/i&gt;. Leo runs on Windows, Linux and MacOS X.&lt;br&gt;
                    Leo requires either the
                    &lt;a HREF="http://docs.python.org/library/tkinter.html"&gt;Tkinter&lt;/a&gt; or
                    &lt;a HREF="http://www.riverbankcomputing.co.uk/software/pyqt/intro"&gt;PyQt&lt;/a&gt; widget set.&lt;br&gt;
                    Leo's outline files are &lt;a HREF="http://www.w3.org/XML/"&gt;XML&lt;/a&gt; format.&lt;/li&gt;
                &lt;li&gt;
                    &lt;a href="http://www.opensource.org/"&gt;&lt;i&gt;Open Software&lt;/i&gt;&lt;/a&gt;,
                    distributed under the
                    &lt;a href="http://www.opensource.org/licenses/mit-license.php/"&gt;MIT License&lt;/a&gt;.&lt;/li&gt;
                &lt;!--@-&lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;!-- div body toc --&gt;
                &lt;!-- &lt; &lt; inner sections &gt; &gt; --&gt;

                &lt;p&gt;Leo has an active community of helpful users and developers.&lt;br&gt;
                Please use the &lt;a href="http://groups.google.com/group/leo-editor"&gt;leo-editor&lt;/a&gt;
                group to ask questions and make suggestions.&lt;/p&gt;

                &lt;p&gt;Leo's author is &lt;a HREF="ekr.html"&gt;Edward K. Ream&lt;/a&gt;&lt;/p&gt;

            &lt;/div&gt;
            &lt;!--@-&lt;&lt; div outer section &gt;&gt;--&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;!--@+&lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;!--@+node:ekr.20100808060203.4282: ** &lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;div class="sphinxsidebar"&gt;
          &lt;div class="sphinxsidebarwrapper"&gt;
              &lt;!--@+&lt;&lt; sidebar contents &gt;&gt;--&gt;
              &lt;!--@+node:ekr.20100808060203.4283: *3* &lt;&lt; sidebar contents &gt;&gt;--&gt;
              &lt;p class="logo"&gt;&lt;a href="leo_toc.html"&gt;
                &lt;img class="logo" src="_static/Leo4-80-border.jpg" alt="Logo"/&gt;&lt;/a&gt;&lt;/p&gt;

              &lt;a class="reference external" href="intro.html"&gt;
                Read this tutorial first&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;
                Another tutorial&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http:screen-shots.html"&gt;
                Screen shots of Leo&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="testimonials.html"&gt;
                Quotes from Leo&amp;#8217;s Users&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external"
                href="http://sourceforge.net/project/showfiles.php?group_id=3458&amp;amp;package_id=29106"&gt;
                Download Leo&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://groups.google.com/group/leo-editor"&gt;
                leo-editor: Google Groups&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://launchpad.net/leo-editor"&gt;
                leo-editor: Launchpad&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://leo.zwiki.org"&gt;
                Leo&amp;#8217;s Wiki&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://www.mind-mapping.org/"&gt;
                Mind Mapping&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="leoLinks.html"&gt;
                More links...&lt;/a&gt;&lt;br&gt;

              &lt;!-- &lt;a class="reference external"  href="install.html"&gt;Installing Leo&lt;/a&gt;&lt;br&gt;--&gt; 
              &lt;!-- &lt;a class="reference external"  href="intro.html"&gt;Beginners Guide&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- &lt;a class="reference external"  href="leo_toc.html"&gt;Users Guide&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- &lt;a class="reference external"  href="FAQ.html"&gt;FAQ&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!--Leo&amp;#8217;s &lt;a class="reference external" href="http://www.greygreen.org/leo/"&gt;Daily snapshots&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- 
              &lt;h5&gt;Edward K. Ream&lt;/h5&gt;
              &lt;a class="reference external" href="ekr.html"&gt;Home&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="mailto:edreamleo@gmail.com"&gt;Contact&lt;/a&gt;&lt;br&gt;
              --&gt; 
              &lt;!--@-&lt;&lt; sidebar contents &gt;&gt;--&gt;
          &lt;!-- &lt; &lt; sidebar links &gt; &gt; --&gt;
          &lt;!-- &lt; &lt; searchbox &gt; &gt; --&gt;
          &lt;/div&gt;
      &lt;/div&gt;
      &lt;!--@-&lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;div class="clearer"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;!--@+&lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4277: ** &lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;div class="related"&gt;
      &lt;h3&gt;Navigation&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li class="right" style="margin-right: 10px"&gt;
          &lt;a href="genindex.html" title="General Index"
             &gt;index&lt;/a&gt;&lt;/li&gt;
        &lt;li class="right" &gt;
          &lt;a href="leo_toc.html" title="Leo&amp;#8217;s Users Guide"
             &gt;contents&lt;/a&gt; |&lt;/li&gt;
        &lt;!--
        &lt;li class="right" &gt;
          &lt;a href="commands.html" title="Chapter 5: Using Leo&amp;#8217;s Commands"
             &gt;previous&lt;/a&gt; |&lt;/li&gt;
        --&gt;
        &lt;li&gt;&lt;a href="leo_toc.html"&gt;Leo v4.7-final documentation&lt;/a&gt; &amp;raquo;&lt;/li&gt; 
      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;!--@+&lt;&lt; div footer &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4278: ** &lt;&lt; div footer &gt;&gt;--&gt;
    &lt;div class="footer"&gt;
      &amp;copy; Copyright 2010, Edward K. Ream.
      Last updated on Aug 08, 2010.
      Created using &lt;a href="http://sphinx.pocoo.org/"&gt;Sphinx&lt;/a&gt; 0.6.3.
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div footer &gt;&gt;--&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;!--@-leo--&gt;
</t>
<t tx="ekr.20110320203616.2497"></t>
<t tx="ekr.20110320205650.2495"></t>
<t tx="ekr.20110321010339.2496">../Icons/bubbles.svg
</t>
<t tx="ekr.20110321012354.2495">c.executeMinibufferCommand('pause-play-movie')</t>
<t tx="ekr.20110321012354.2496">c.executeMinibufferCommand('toggle-rendering-pane')</t>
<t tx="ekr.20110321073942.2490">c.executeMinibufferCommand('lock-unlock-rendering-pane')
</t>
<t tx="ekr.20110321213439.2493" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e">gs.clear()
gs.addText('\n%s\n%s' % (gv,gs))

if 0:
    for i in range(50):
        gs.addText('\n' * i +'More')
</t>
<t tx="ekr.20110321213439.2495">c.executeMinibufferCommand('update-rendering-pane')
</t>
<t tx="ekr.20110321213552.2497"># This should be done only for selected files.</t>
<t tx="ekr.20110321213552.2499"></t>
<t tx="ekr.20110321213552.2500"></t>
<t tx="ekr.20110322101711.2507">@nocolor-node
&lt;?xml version="1.0" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd"&gt;
&lt;svg width="20cm" height="15cm" viewBox="0 0 800 600"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlik/"
     baseProfile="tiny" version="1.2"&gt;
   &lt;title&gt;Spheres&lt;/title&gt;
   &lt;desc&gt;Semi-transparent bubbles on a colored background.&lt;/desc&gt;
     &lt;defs&gt;
       &lt;!-- Create radial gradients for each bubble. --&gt;
       &lt;radialGradient id="blueBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#cdcdff" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#cdaacd" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="redBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#ffcdcd" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#bbbb99" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="greenBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#cdffcd" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#99aaaa" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="yellowBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#ffffcd" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#bbbbaa" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="background" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="400" fx="250" fy="250"&gt;
         &lt;stop offset="0%" stop-color="#ffffee" /&gt;
         &lt;stop offset="100%" stop-color="#ccccaa" /&gt;
       &lt;/radialGradient&gt;
       &lt;linearGradient id="surface" gradientUnits="userSpaceOnUse"
                       x1="-100" y1="200" x2="400" y2="200"&gt;
         &lt;stop offset="0%" stop-color="#ffffcc" /&gt;
         &lt;stop offset="100%" stop-color="#bbbb88" /&gt;
       &lt;/linearGradient&gt;

       &lt;!-- Create radial gradients for each circle to make them look like
            spheres. --&gt;
       &lt;radialGradient id="blueSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="blue" /&gt;
         &lt;stop offset="100%" stop-color="#222244" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="redSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="red" /&gt;
         &lt;stop offset="100%" stop-color="#442222" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="greenSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="green" /&gt;
         &lt;stop offset="100%" stop-color="#113311" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="yellowSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="yellow" /&gt;
         &lt;stop offset="100%" stop-color="#444422" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="shadowGrad" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="50"&gt;
         &lt;stop offset="0%" stop-color="black" stop-opacity="1.0" /&gt;
         &lt;stop offset="100%" stop-color="black" stop-opacity="0.0" /&gt;
       &lt;/radialGradient&gt;

       &lt;!-- Define a shadow for each sphere. --&gt;
       &lt;circle id="shadow" fill="url(#shadowGrad)" cx="0" cy="0" r="100" /&gt;
       &lt;g id="bubble"&gt;
         &lt;circle fill="black" cx="0" cy="0" r="50" /&gt;
         &lt;circle fill="#a6ce39" cx="0" cy="0" r="33" /&gt;
         &lt;path fill="black" d="M 37,50 L 50,37 L 12,-1 L 22,-11 L 10,-24 L -24,10
                               L -11,22 L -1,12 Z" /&gt;
         &lt;circle cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/defs&gt;
   &lt;g&gt;
     &lt;rect fill="url(#background)" x="0" y="0" width="800" height="600" /&gt;
   &lt;/g&gt;

   &lt;g transform="translate(200,700)"&gt;
     &lt;use xlink:href="#bubble" fill="url(#blueBubble)" /&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="1s" dur="10s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(315,700)"&gt;
     &lt;g transform="scale(0.5,0.5)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#redBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="3s" dur="7s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(80,700)"&gt;
     &lt;g transform="scale(0.65,0.65)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#greenBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="5s" dur="9s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(255,700)"&gt;
     &lt;g transform="scale(0.3,0.3)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#yellowBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="2s" dur="6s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(565,700)"&gt;
     &lt;g transform="scale(0.4,0.4)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#blueBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="4s" dur="8s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(715,700)"&gt;
     &lt;g transform="scale(0.6,0.6)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#redBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="1s" dur="4s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(645,700)"&gt;
     &lt;g transform="scale(0.375,0.375)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#greenBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="0s" dur="11s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(555,700)"&gt;
     &lt;g transform="scale(0.9,0.9)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#yellowBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="3s" dur="7.5s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;

   &lt;g transform="translate(360,700)"&gt;
     &lt;g transform="scale(0.5,0.5)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#blueBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="3s" dur="6s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(215,700)"&gt;
     &lt;g transform="scale(0.45,0.45)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#redBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="5.5s" dur="7s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(420,700)"&gt;
     &lt;g transform="scale(0.75,0.75)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#greenBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="1s" dur="9s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(815,700)"&gt;
     &lt;g transform="scale(0.6,0.6)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#yellowBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="2s" dur="9.5s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;

   &lt;g transform="translate(225,375)" &gt;
     &lt;g transform="scale(1.0,0.5)" &gt;
       &lt;path d="M 0 0 L 350 0 L 450 450 L -100 450 z"
             fill="url(#surface)" stroke="none" /&gt;
     &lt;/g&gt;
   &lt;/g&gt;
     &lt;g transform="translate(200,0)" &gt;
     &lt;g transform="translate(200,490) scale(2.0,1.0) rotate(45)" &gt;
       &lt;rect fill="#a6ce39" x="-69" y="-69" width="138" height="138" /&gt;
       &lt;circle fill="black" cx="0" cy="0" r="50" /&gt;
       &lt;circle fill="#a6ce39" cx="0" cy="0" r="33" /&gt;
       &lt;path fill="black" d="M 37,50 L 50,37 L 12,-1 L 22,-11 L 10,-24 L -24,10
                             L -11,22 L -1,12 Z" /&gt;
       &lt;animateTransform attributeName="transform"  type="rotate" additive="sum" values="0; 360"
                  begin="0s" dur="10s" fill="freeze" repeatCount="indefinite" /&gt;
     &lt;/g&gt;
     &lt;g transform="translate(200,375)"&gt;
       &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
       &lt;circle fill="url(#blueSphere)" cx="0" cy="0" r="100" /&gt;
     &lt;/g&gt;
     &lt;g transform="translate(315,440)"&gt;
       &lt;g transform="scale(0.5,0.5)"&gt;
         &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
         &lt;circle fill="url(#redSphere)" cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/g&gt;
     &lt;g transform="translate(80,475)"&gt;
       &lt;g transform="scale(0.65,0.65)"&gt;
         &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
         &lt;circle fill="url(#greenSphere)" cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/g&gt;
     &lt;g transform="translate(255,525)"&gt;
       &lt;g transform="scale(0.3,0.3)"&gt;
         &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
         &lt;circle fill="url(#yellowSphere)" cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/g&gt;
   &lt;/g&gt;
&lt;/svg&gt;</t>
<t tx="ekr.20110325142419.2337"># This has been superceded by Autocompleter test node in this file.

from PyQt4 import QtGui, QtCore

@others

if __name__ == "__main__":
    main()</t>
<t tx="ekr.20110325142419.2338">if 0: # Not used:  We'll use QCompleter instead.

    class DictionaryCompleter(QtGui.QCompleter):
    
        def __init__(self, parent=None):
            words = []
            try:
                f = open("/usr/share/dict/words","r")
                for word in f:
                    words.append(word.strip())
                f.close()
            except IOError:
                print "dictionary not in anticipated location"
    
            QtGui.QCompleter.__init__(self, words, parent)
</t>
<t tx="ekr.20110325142419.2339">if 0: # Not used:  We'll use LeoQTextBrowser instead.

    STARTTEXT = ('This TextEdit provides autocompletions for words that have ' +
    'more than 3 characters.\nYou can trigger autocompletion using %s\n\n'''% (
    QtGui.QKeySequence("Ctrl+E").toString(QtGui.QKeySequence.NativeText)))
    
    
    class CompletionTextEdit(QtGui.QTextEdit):
        
        @others</t>
<t tx="ekr.20110325142419.2340">def __init__(self, parent=None):
    super(CompletionTextEdit, self).__init__(parent)
    self.setMinimumWidth(400)
    self.setPlainText(STARTTEXT)
    self.completer = None
    self.moveCursor(QtGui.QTextCursor.End)

</t>
<t tx="ekr.20110325142419.2341">def setCompleter(self, completer):
    if self.completer:
        self.disconnect(self.completer, 0, self, 0)
    if not completer:
        return

    completer.setWidget(self)
    completer.setCompletionMode(QtGui.QCompleter.PopupCompletion)
    completer.setCaseSensitivity(QtCore.Qt.CaseInsensitive)
    self.completer = completer
    self.connect(self.completer,
        QtCore.SIGNAL("activated(const QString&amp;)"), self.insertCompletion)

</t>
<t tx="ekr.20110325142419.2342">def insertCompletion(self, completion):

    tc = self.textCursor()
    extra = (completion.length() -
        self.completer.completionPrefix().length())
    
    tc.movePosition(QtGui.QTextCursor.Left)
    tc.movePosition(QtGui.QTextCursor.EndOfWord)
    tc.insertText(completion.right(extra))
    self.setTextCursor(tc)

</t>
<t tx="ekr.20110325142419.2343">def textUnderCursor(self):

    tc = self.textCursor()
    tc.select(QtGui.QTextCursor.WordUnderCursor)
    return tc.selectedText()

</t>
<t tx="ekr.20110325144059.2350">def main():
    
    app = QtGui.QApplication([])
    completer = DictionaryCompleter()
    te = CompletionTextEdit()
    te.setCompleter(completer)
    te.show()
    app.exec_()
</t>
<t tx="ekr.20110325144059.2351">def focusInEvent(self, event):

    if self.completer:
        self.completer.setWidget(self);

    QtGui.QTextEdit.focusInEvent(self, event)
</t>
<t tx="ekr.20110325144059.2352">def keyPressEvent(self, event):
    if self.completer and self.completer.popup().isVisible():
        if event.key() in (
        QtCore.Qt.Key_Enter,
        QtCore.Qt.Key_Return,
        QtCore.Qt.Key_Escape,
        QtCore.Qt.Key_Tab,
        QtCore.Qt.Key_Backtab):
            event.ignore()
            return

    ## has ctrl-E been pressed??
    isShortcut = (event.modifiers() == QtCore.Qt.ControlModifier and
                  event.key() == QtCore.Qt.Key_E)
    if (not self.completer or not isShortcut):
        QtGui.QTextEdit.keyPressEvent(self, event)

    ## ctrl or shift key on it's own??
    ctrlOrShift = event.modifiers() in (QtCore.Qt.ControlModifier ,
            QtCore.Qt.ShiftModifier)
    if ctrlOrShift and event.text().isEmpty():
        # ctrl or shift key on it's own
        return

    eow = QtCore.QString("~!@#$%^&amp;*()_+{}|:\"&lt;&gt;?,./;'[]\\-=") #end of word

    hasModifier = ((event.modifiers() != QtCore.Qt.NoModifier) and
                    not ctrlOrShift)

    completionPrefix = self.textUnderCursor()

    if (not isShortcut and (hasModifier or event.text().isEmpty() or
    completionPrefix.length() &lt; 3 or
    eow.contains(event.text().right(1)))):
        self.completer.popup().hide()
        return

    if (completionPrefix != self.completer.completionPrefix()):
        self.completer.setCompletionPrefix(completionPrefix)
        popup = self.completer.popup()
        popup.setCurrentIndex(
            self.completer.completionModel().index(0,0))

    cr = self.cursorRect()
    cr.setWidth(self.completer.popup().sizeHintForColumn(0)
        + self.completer.popup().verticalScrollBar().sizeHint().width())
    self.completer.complete(cr) ## popup it up!</t>
<t tx="ekr.20110414063538.2372">@first # -*- coding: utf-8 -*-

'''A script that writes/reads .leo files in JSON format.'''

&lt;&lt; imports &gt;&gt;

# To do:
# Create putDescendentVnodeUas, putDescendentAttributes.
# Write "marked" item if the node is marked.
# Decide on the final names for all items.

@others

# os.system('cls')

TestClass(c).main()
</t>
<t tx="ekr.20110414063538.2373">def putFile(self):
    
    self.put('[\n')
    self.putVnodes()
    self.put(',\n')
    self.putTnodes()
    self.put(']\n')
    return ''.join(self.result)
</t>
<t tx="ekr.20110414063538.2374">def putTnode (self,v):

    # Call put just once.
    gnx = g.app.nodeIndices.toString(v.fileIndex)
    ua = hasattr(v,'unknownAttributes') and self.putUnknownAttributes(v) or ''
    b = v.b or ''

    if self.json:
        comma = g.choose(self.needJsonComma,',\n','')
        if ua:
            self.put('%s{"id":%s,"head":%s,"ua":%s,"body":%s}' % (
                comma,self.escape(gnx),self.escape(v.h),self.escape(ua),self.escape(b)))
        else:
            self.put('%s{"id":%s,"head":%s,"body":%s}' % (
                comma,self.escape(gnx),self.escape(v.h),self.escape(b)))
        self.needJsonComma = True
    else:
        body = xml.sax.saxutils.escape(b)
        self.put('&lt;t tx="%s"%s&gt;%s&lt;/t&gt;\n' % (gnx,ua,body))
</t>
<t tx="ekr.20110414063538.2375">def putTnodes (self):

    """Puts all tnodes as required for copy or save commands"""

    c = self.c
    
    if self.json:
        self.needJsonComma = False
        self.put('{"tnodes":[\n')
    else:
        self.put("&lt;tnodes&gt;\n")
    &lt;&lt; write only those tnodes that were referenced &gt;&gt;
    if self.json:
        self.put('\n]}\n')
    else:
        self.put("&lt;/tnodes&gt;\n")
</t>
<t tx="ekr.20110414063538.2376">if self.usingClipboard: # write the current tree.
    theIter = c.p.self_and_subtree()
else: # write everything
    theIter = c.all_unique_positions()

# Populate tnodes
tnodes = {}
nodeIndices = g.app.nodeIndices
for p in theIter:
    # Make *sure* the file index has the proper form.
    # g.trace(p.v.fileIndex)
    try:
        theId,t,n = p.v.fileIndex
    except ValueError:
        try:
            theId,t,n = p.v.fileIndex,''
        except Exception:
            raise BadLeoFile('bad p.v.fileIndex' % repr(p.v.fileIndex))

    if n is None:
        n = g.u('0')
    elif g.isPython3:
        n = str(n)
    else:
        n = unicode(n)
    index = theId,t,n
    tnodes[index] = p.v

# Put all tnodes in index order.
for index in sorted(tnodes):
    # g.trace(index)
    v = tnodes.get(index)
    if v:
        # Write only those tnodes whose vnodes were written.
        if v.isWriteBit():
            self.putTnode(v)
    else:
        g.trace('can not happen: no vnode for',repr(index))
        # This prevents the file from being written.
        raise BadLeoFile('no vnode for %s' % repr(index))
</t>
<t tx="ekr.20110414063538.2377">def putVnode (self,p,isIgnore=False):

    """Write a &lt;v&gt; element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    json = fc.json
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
        # 2010/09/02: @edit nodes must not have children.
        # If they do, the entire tree is written to the outline.
    isFile   = p.isAtFileNode()
    isShadow = p.isAtShadowFileNode()
    isThin   = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # 2010/10/22: force writes of orphan @edit, @auto and @shadow trees.
    if   isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = isOrphan  # Force write of orphan @auto trees.
    elif isEdit:   forceWrite = isOrphan  # Force write of orphan @edit trees.
    elif isFile:   forceWrite = isOrphan  # Force write of orphan @file trees.
    elif isShadow: forceWrite = isOrphan  # Force write of @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Force write of  orphan @thin trees.
    else:          forceWrite = True      # Write all other @&lt;file&gt; trees.

    &lt;&lt; Set gnx = vnode index &gt;&gt;
    attrs = []
    &lt;&lt; Append attribute bits to attrs &gt;&gt;
    &lt;&lt; Append unKnownAttributes to attrs &gt;&gt;
    attrs = ''.join(attrs)

    if json:
        comma = g.choose(self.needJsonComma,',\n','')
        if attrs:
            v_head = '%s%s{"id":"%s","%s"' % (comma,self.indent(),gnx,attrs)
        else:
            v_head = '%s%s{"id":"%s"' % (comma,self.indent(),gnx)
        self.needJsonComma = True
    else:
        v_head = '&lt;v t="%s"%s&gt;' % (gnx,attrs)
        
    h = xml.sax.saxutils.escape(p.v.headString()) or ''
    if gnx in fc.vnodesDict:
        if json:
            fc.put('%s}' % v_head)
        else:
            fc.put(v_head+'&lt;/v&gt;\n')
    else:
        fc.vnodesDict[gnx]=True
        
        if json:
            pass
        else:
            v_head += '&lt;vh&gt;%s&lt;/vh&gt;' % (h)
        # The string catentation is faster than repeated calls to fc.put.
        if not self.usingClipboard:
            &lt;&lt; issue informational messages &gt;&gt;
        # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            if json:
                fc.put('%s,"children":[\n' % v_head) # Newline is good here.
            else:
                fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            oldNeedComma = self.needJsonComma
            self.needJsonComma = False
            self.level += 1
            while 1:
                fc.putVnode(p,isIgnore)
                if p.hasNext(): p.moveToNext()
                else:           break
            self.level -= 1
            p.moveToParent() # Restore p in the caller.
            self.needJsonComma = oldNeedComma
            if json:
                fc.put(']}')
            else:
                fc.put('&lt;/v&gt;\n')
        else:
            if json:
                fc.put('%s}' % v_head)
            else:
                fc.put('%s&lt;/v&gt;\n' % v_head) # Call put only once.
</t>
<t tx="ekr.20110414063538.2378">gnx = g.app.nodeIndices.toString(v.fileIndex)

if forceWrite or self.usingClipboard:
    v.setWriteBit() # 4.2: Indicate we wrote the body text.
</t>
<t tx="ekr.20110414063538.2379"># These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren() and c.putBitsFlag:
        attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"
    if attr:
        if json:
            attrs.append(',a="%s"' % attr)
        else:
            attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions &lt;v&gt; element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = v.u
    str_pos = ','.join(aList)
    if d.get('str_leo_pos'):
        del d['str_leo_pos']
    # Don't write the current position if we can cache it. 
    if g.enableDB and c.mFileName:
        c.cacher.setCachedStringPosition(str_pos)
    elif c.fixed:
        pass
    else:
        d['str_leo_pos'] = str_pos
    v.u = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
</t>
<t tx="ekr.20110414063538.2380"># v.unknownAttributes are now put in &lt;t&gt; elements.

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    if not isAuto: # Bug fix: 2008/8/7.
        attrs.append(self.putDescendentVnodeUas(p)) # New in Leo 4.5.
        attrs.append(self.putDescendentAttributes(p))
</t>
<t tx="ekr.20110414063538.2381">if isOrphan and isThin:
    g.es("writing erroneous:",p.h,color="blue")
    p.clearOrphan()
</t>
<t tx="ekr.20110414063538.2382">def putVnodes (self):

    """Puts all &lt;v&gt; elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    if self.json:
        self.needJsonComma = False
        self.put('{"vnodes":[\n')
    else:
        self.put("&lt;vnodes&gt;\n")

    # Make only one copy for all calls.
    self.currentPosition = c.p 
    self.rootPosition    = c.rootPosition()
    # self.topPosition     = c.topPosition()
    self.vnodesDict = {}

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings():
            # New in Leo 4.4.2 b2 An optimization:
            self.putVnode(p,isIgnore=p.isAtIgnoreNode()) # Write the next top-level node.

    if self.json:
        self.put('\n]}')
    else:
        self.put("&lt;/vnodes&gt;\n")
</t>
<t tx="ekr.20110414063538.2383">class TestClass:
    
    def __init__(self,c):

        # These ivars are from the fileCommands class.
        self.c = c
        self.usingClipboard = True # True: write only the current tree.
        
        # Read ivars.
        self.t_dict = {} # Keys are id strings, values are tnodes.
        self.v_dict = {} # Keys are id strings, values are vnodes.
        
        # Ivars added for this class.
        self.json = True
        self.level = 0
        self.needJsonComma = False
        self.result = []

    @others
</t>
<t tx="ekr.20110414063538.2384">def main (self):
    
    trace = False
    tc = self
    
    tag = '@input-tree'
    p = g.findNodeAnywhere(self.c,tag)
    assert p,'not found: %s' % tag
    c.selectPosition(p)
    
    s = tc.putFile()
    if trace: g.trace(repr(s))
    aList = json.loads(s)
    if trace: pprint.pprint(aList)
    
    if 1: # A consistency check.
        s2 = json.dumps(aList)
        if trace: print(s2)
        aList2 = json.loads(s2)
        assert(aList==aList2)
    
    tc.create_v_dict()
    tc.read_json_data(aList)
    c.redraw_now()</t>
<t tx="ekr.20110414063538.2385">import leo.core.leoNodes as leoNodes

import json
import pprint
import xml.sax
import xml.sax.saxutils
import os</t>
<t tx="ekr.20110414073628.2389">def escape(self,s):
    '''Perform the json string escapes on s, enclosing the result in double quotes.'''
    return json.dumps(s)

def indent(self):
    return ' '*self.level

def put(self,s):
    self.result.append(s)

def putUnknownAttributes(self,v):
    pass
</t>
<t tx="ekr.20110414094917.2391"></t>
<t tx="ekr.20110414094917.2406"></t>
<t tx="ekr.20110414094917.2408">def create_json_children (self,json_node,parent_v):

    c = self.c
    trace = False and not g.unitTesting
    children = []
    json_children = json_node.get('children',[])

    for json_child in json_children:
        gnx = json_child.get('id')
        v = self.v_dict.get(gnx)

        if v: # A clone.
            if trace: g.trace('**clone',v)
            v = self.create_json_vnode(json_child,parent_v,v=v)   
        else:
            v = self.create_json_vnode(json_child,parent_v)
            self.create_json_children(json_child,v)

        children.append(v)

    parent_v.children = children
    for child in children:
        child.parents.append(parent_v)
        if trace:
            g.trace('*** added parent %s to %s len(child.parents) %s' % (
                parent_v,child,len(child.parents)))

    return children
</t>
<t tx="ekr.20110414094917.2409">def create_json_vnode (self,json_node,parent_v,v=None):

    c = self.c
    trace = False and not g.unitTesting
    gnx = json_node.get('id','')
    json_tnode = self.t_dict.get(gnx)
    assert json_tnode
    assert json_tnode.get('id') == gnx
    h = json_tnode.get('head','')
    b = json_tnode.get('body','')

    if v:
        # The body of the later node overrides the earlier.
        if v.b != b:
            if trace: g.trace('***update\nold: %s\nnew: %s' % (v.b,b))
            v.b = b 
    else:
        v = leoNodes.vnode(context=c)
        v.setBodyString(b)
        v.setHeadString(h)
        v.fileIndex = g.app.nodeIndices.scanGnx(gnx,0)
        self.v_dict [gnx] = v

    if trace:
        g.trace('gnx: %-22s v: %s len(body): %-4d %s' % (
            gnx,id(v),len(b),h))

    self.handle_json_tnode_attributes(json_node,v)
    self.handle_json_vnode_attributes(json_node,v)
    return v
</t>
<t tx="ekr.20110414094917.2410">def handle_json_tnode_attributes (self,json_node,v):

    trace = False and not g.unitTesting
    d = json_node.get('tnodeAttributes',{})
    if trace and d: g.trace(json_node,list(d.keys()))

    aDict = {}
    for key in d:
        val = g.toUnicode(d.get(key)) # 2011/02/22
        val2 = self.get_json_ua(key,val)
        # g.trace(key,val,val2)
        aDict[key] = val2

    if aDict:
        if trace: g.trace('uA',v,list(aDict.keys()))
        v.unknownAttributes = aDict
</t>
<t tx="ekr.20110414094917.2411"># The native attributes of &lt;v&gt; elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnodeUnknownAttributes.
# New in Leo 4.5: added descendentVnodeUnknownAttributes to native attributes.

def handle_json_vnode_attributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.get('attributes',{})

    s = d.get('a')
    if s:
        if trace and 'E' in s: g.trace('expand',v)
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnodeList will be resolved later.
        if trace: g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentTnodeUaDictList',aDict)
            self.descendentTnodeUaDictList.append(aDict)

    s = d.get('descendentVnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentVnodeUaDictList',aDict)
            self.descendentVnodeUaDictList.append((v,aDict),)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d:
        if key in self.nativeVnodeAttributes:
            # This is not a bug.
            if False and trace: g.trace(
                '****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # if trace: g.trace('uA',v,aDict)
        v.unknownAttributes = aDict
</t>
<t tx="ekr.20110414094917.2413">def get_json_ua(self,attr,val,kind=None): # Kind is for unit testing.

    """Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element.
    The unknown tag has been pickled and hexlify'd.
    """

    try:
        # val = str(val)
        val = g.toEncodedString(val) # 2011/02/22.
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None


    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return val

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except Exception:
        # Python 2.x throws TypeError
        # Python 3.x throws binascii.Error
        # Assume that Leo 4.1 wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw','unit test failed: kind=' % repr(kind)
        else:
            g.trace('can not unhexlify %s=%s' % (attr,val))
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return val2
    except (pickle.UnpicklingError,ImportError,AttributeError,ValueError):
        g.trace('can not unpickle %s=%s' % (attr,val))
        return val
</t>
<t tx="ekr.20110414094917.2415">def readSaxFile (self,theFile,fileName,silent,inClipboard,reassignIndices,s=None):

    dump = False and not g.unitTesting
    fc = self ; c = fc.c

    # Pass one: create the intermediate nodes.
    saxRoot = fc.parse_leo_file(theFile,fileName,
        silent=silent,inClipboard=inClipboard,s=s)

    if dump: fc.dumpSaxTree(saxRoot,dummy=True)

    # Pass two: create the tree of vnodes and tnodes from the intermediate nodes.
    if saxRoot:
        parent_v = c.hiddenRootNode
        children = fc.createSaxChildren(saxRoot,parent_v)
        assert c.hiddenRootNode.children == children
        v = children and children[0] or None
        return v
    else:
        return None
</t>
<t tx="ekr.20110414094917.2416">def resolve_tnode_lists (self):

    trace = False and not g.unitTesting
    c = self.c

    for p in c.all_unique_positions():
        if hasattr(p.v,'tempTnodeList'):
            # g.trace(p.v.headString())
            result = []
            for tnx in p.v.tempTnodeList:
                index = self.canonicalTnodeIndex(tnx)
                v = self.gnxDict.get(index)
                if v:
                    if trace: g.trace(tnx,v)
                    result.append(v)
                else:
                    g.trace('*** No vnode for %s' % tnx)
            if result:
                p.v.tnodeList = result
                # g.trace('*** tnodeList for',p.h,result)
            delattr(p.v,'tempTnodeList')
</t>
<t tx="ekr.20110414094917.2417">def resolve_archived_position(self,archivedPosition,root_v):

    '''Return a vnode corresponding to the archived position relative to root node root_v.'''

    def oops (message):
        if not g.app.unitTesting:
            g.es_print('bad archived position: %s' % (message),color='red')

    try:
        aList = [int(z) for z in archivedPosition.split('.')]
        aList.reverse()
    except Exception:
        return oops('"%s"' % archivedPosition)

    if not aList:
        return oops('empty')

    last_v = root_v
    n = aList.pop()
    if n != 0:
        return oops('root index="%s"' % n )

    while aList:
        n = aList.pop()
        children = last_v.children
        if n &lt; len(children):
            last_v = children[n]
        else:
            return oops('bad index="%s", len(children)="%s"' % (n,len(children)))

    return last_v
</t>
<t tx="ekr.20110414094917.2418">def setPositionsFromVnodes (self):

    trace = False and not g.unitTesting
    c = self.c ; p = c.rootPosition()
    current,str_pos = None,None

    use_db = g.enableDB and c.mFileName
    if use_db:
        str_pos = c.cacher.getCachedStringPosition()

    if not str_pos:
        d = hasattr(p.v,'unknownAttributes') and p.v.unknownAttributes
        if d: str_pos = d.get('str_leo_pos')
        if trace: g.trace('from p.v.u',str_pos)

    if str_pos:
        current = self.archivedPositionToPosition(str_pos)

    c.setCurrentPosition(current or c.rootPosition())
</t>
<t tx="ekr.20110414094917.2419">def archivedPositionToPosition (self,s):

    c = self.c
    s = g.toUnicode(s) # 2011/02/25
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level &lt; len(aList):
        i = aList[level]
        while i &gt; 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.h,c)
                return None
        level += 1
        if level &lt; len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.h)
    return p
</t>
<t tx="ekr.20110414094917.2420">if 0:
    @others</t>
<t tx="ekr.20110414094917.2422">def read_json_data (self,json_list,reassignIndices=True):
    
    '''Create Leo's vnodes from data, a Python object created by json.loads.'''

    trace = True and not g.unitTesting
    fc = self ; c = fc.c ; tag = '@json-outline'
    if not json_list: return None
    
    vnodes,tnodes = json_list
    assert vnodes
    assert tnodes
    fc.create_t_dict(tnodes)

    parent_p = g.findNodeAnywhere(c,'@json-outline')
        ### parent_v = c.hiddenRootNode

    if not parent_p:
        return g.trace('not found: %s' % tag)
        
    aList = vnodes.get('vnodes',[])
    assert aList
    
    # Create a dummy node so all we have to do is call create_json_children.
    dummy_json_node = { "children":aList }
    parent_v = parent_p.v
    children = fc.create_json_children(dummy_json_node,parent_v)
        
    assert parent_v.children == children,'parent_p.children: %s, children: %s' % (
        parent_v.children,children)
        
    v = children and children[0] or None
    return v
</t>
<t tx="ekr.20110414094917.2423"># The root node for testing read_json_data.</t>
<t tx="ekr.20110414094917.2424"></t>
<t tx="ekr.20110414094917.2425"># child 1 text: test of escapes: "\"</t>
<t tx="ekr.20110414094917.2426"></t>
<t tx="ekr.20110414094917.2427"># grandchild11 body.</t>
<t tx="ekr.20110414094917.2428"></t>
<t tx="ekr.20110414094917.2429"></t>
<t tx="ekr.20110414094917.2432">def create_t_dict(self,json_node):
    
    tnodes = json_node.get('tnodes',[])
    assert tnodes
    
    for z in tnodes:
        gnx = z.get('id')
        assert gnx
        self.t_dict[gnx] = z
        </t>
<t tx="ekr.20110414185051.2435">def create_v_dict(self):
    
    '''A kludge so we can properly link nodes during testing.
    
    (In actual practice, this would not be needed because
    there would be no previously existing nodes.)'''
    
    c = self.c
    
    for v in c.all_unique_nodes():
        self.v_dict[v.gnx] = v
</t>
<t tx="ekr.20110416065515.2437">from jinja2 import Template
t = Template('Hello {{ name }}!')
s = t.render(name='Edward K. Ream')
print(s)
</t>
<t tx="ekr.20110510110227.2439"></t>
<t tx="ekr.20110510110227.2440"></t>
<t tx="ekr.20110511061102.5232">True:  enable autocompletion initially.
False: disable autocomopletion initially.

You can use the enable-autocompleter and disable-autocompleter
commands to enable or disable autocompletion at any time.

Note: The 'initially' prefix is needed to distinguish this setting from
enable-autocompleter command. Otherwised they would get 'munged' to the same
configuration value.</t>
<t tx="ekr.20110511140347.2445">from PyQt4 import QtCore

timer = QtCore.QTimer()
timer.setSingleShot(True)

def callBack():
    g.trace('atIdleCallBack')

# Use a QTimer with 0 timeout.
timer.connect(timer,QtCore.SIGNAL("timeout()"),callBack)
timer.start(0)
</t>
<t tx="ekr.20110512085154.2447"></t>
<t tx="ekr.20110512225930.2456"></t>
<t tx="ekr.20110521072459.2463"></t>
<t tx="ekr.20110521072459.2464">builtins, including cython builtins</t>
<t tx="ekr.20110521072459.2465">cython keywords</t>
<t tx="ekr.20110525093203.2470"></t>
<t tx="ekr.20110526180653.2467"></t>
<t tx="ekr.20110526180653.2468"></t>
<t tx="ekr.20111020134534.2594"></t>
<t tx="ekr.20120311074029.2727"></t>
<t tx="ekr.20120311074029.2728"></t>
<t tx="ekr.20120311074029.2729"></t>
<t tx="ekr.20120311074029.2730"></t>
<t tx="ekr.20120311074029.2731"></t>
<t tx="ekr.20120311074029.2732"></t>
<t tx="ekr.20120311074029.2733"></t>
<t tx="ekr.20120311074029.2734"></t>
<t tx="ekr.20120311074029.2735"></t>
<t tx="ekr.20120311074029.2736"></t>
<t tx="ekr.20120312075951.2740">print(c.openDirectory)</t>
<t tx="ekr.20120320072350.2731"></t>
<t tx="ekr.20120426175039.2682">import asyncore
import socket

@others

host,port = '127.0.0.1',24

try:
    s = socket.socket(socket.AF_INET)
    s.connect((host,port),)
    print('Leo already running') #  at %s:%s' % (host,port))

except socket.error:
    s = None
    
if not s:
    try:
        s=Server(host,port,RequestHandler)
        print('Starting Leo')
    except socket.error:
        g.es_exception()
</t>
<t tx="ekr.20120426175039.2683">class Server(asyncore.dispatcher):

    @others
</t>
<t tx="ekr.20120426175039.2684">def __init__ (self, host, port, handler):

    self.ip = host
    self.port = port
    self.handler=handler

    asyncore.dispatcher.__init__ (self)
    self.create_socket (socket.AF_INET,socket.SOCK_STREAM)

    self.set_reuse_addr()
    self.bind ((host,port),)
    self.listen (2)
    g.es_print('listening on %s:%s' % (host,port))
</t>
<t tx="ekr.20120426175039.2685">def handle_accept (self):
    
    try:
        conn, addr = self.accept()
        g.trace('accepted connection: %s' % (addr))
    except socket.error:
        self.log_info ('warning: server accept() threw an exception', 'warning')
        return
    except TypeError:
        self.log_info ('warning: server accept() threw EWOULDBLOCK', 'warning')
        return

    # creates an instance of the handler class to handle the request/response
    # on the incoming connexion
    self.handler(conn,addr,self)
</t>
<t tx="ekr.20120426175039.2686">class RequestHandler:
    
    pass
    
    if 0:
        def __init__(self,conn,addr,server):
            g.es_print('RequestHandler.ctor conn: %s addr: %s server: %s' % (
                conn,addr,server))
</t>
<t tx="ekr.20120505111317.2735">'''Write node &amp; links version of json.'''

# from __future__ import print_function
import json

class JsonController:
    @others

g.cls()
jc = JsonController()
s = jc.to_json(c,p=None)
d = json.loads(s)

nodes = {}
print('nodes...')
for d2 in d.get('nodes'):
    gnx = d2.get('gnx')
    print('%-25s %s' % (d2.get('gnx'),d2.get('h')))
    nodes[gnx] = d2
    
keys = sorted(list(nodes.keys()))

if 0:
    print()
    print('keys',keys)

aList = d.get('top')
print()
print('top...')
for gnx in aList:
    assert gnx in keys,gnx
    d2 = nodes.get(gnx)
    print('%-25s %s' % (d2.get('gnx'),d2.get('h')))
</t>
<t tx="ekr.20120505111317.2736">def to_json (self,c,p=None):
    
    '''Convert p's tree to JSON, or the entire outline if p is None.'''
    
    if p:
        top = [p.v.gnx]
        nodes = list(set([p.v for p in p.self_and_subtree()]))
    else:
        top = [v.gnx for v in c.hiddenRootNode.children]
        nodes = [v for v in c.all_unique_nodes()]

    nodes = [self.vnode_dict(v) for v in nodes]
    d = {'top':top,'nodes':nodes}
    s = json.dumps(d)
    return s
</t>
<t tx="ekr.20120505111317.2737">def vnode_dict (self,v):
    
    return {
        'gnx': v.gnx,
        'h':v.h, 'b':v.b,
        # 'ua': v.u,
        'children': [z.gnx for z in v.children]
    }
</t>
<t tx="ekr.20120913105857.2914"></t>
<t tx="ekr.20120913105857.2915">This is a brief tutorial for getting familiar with basic Leo
functionality. Click around and experiment.

Note that you probably want to save your own "working copy"
of this file before proceeding further. Do that by "File -&gt;
Save as".

This guide is intentionally quite brief and minimal -
therefore, it merely scratches the surface of what Leo can
do. You can begin leveraging Leo for mindmapping-like tasks
by just reading the node "Tree manipulation basics", and
moving on to other topics after acquiring some basic
familiarity. </t>
<t tx="ekr.20120913105857.2918">"External file" means a file that resides on your file
system. If you are programming, these are the files you
eventually want to create to get something useful out of
Leo, for example, your C++ or Python source code files.</t>
<t tx="ekr.20120913105857.2919">Remove the first @ from @thin in the subtree below and save
(ctrl+s) to create an "external" file which is directly
usable outside leo - try opening the resulting myfile.py in
a normal text editor (e.g. from right-click menu on the @thin node) 
to see what it looks like.

Note the @others directive, and the the lines that look like

#@-node:ville.20090627211608.10122:class Foo

These are called "sentinels", and they are needed to
preserve the tree structure in the external files. They
allow your tree structure to survive, even when someone else
edits the source (or you edit it yourself in an external
editor).</t>
<t tx="ekr.20120913105857.2920"> </t>
<t tx="ekr.20120913105857.2921">@language python
@others
</t>
<t tx="ekr.20120913105857.2922"></t>
<t tx="ekr.20120913105857.2923">import os
import sys

</t>
<t tx="ekr.20120913105857.2924">def init1():
    print "init1"

def init2():
    print "init2"</t>
<t tx="ekr.20120913105857.2925">class Foo:
    &lt;&lt; docstring &gt;&gt;
    @others


</t>
<t tx="ekr.20120913105857.2926">""" Some sort of useful class """

</t>
<t tx="ekr.20120913105857.2927">def spam(self):
    pass

</t>
<t tx="ekr.20120913105857.2928">def eggs(self):
    pass</t>
<t tx="ekr.20120913105857.2929">If the sentinels in thin nodes are unacceptable for your workflow 
(typically the case when you are the only one using Leo in a 
particular project), you can use @auto nodes to "play well with 
others". @auto nodes understand the structure of the source code
(parsers exist for popular languages), and create the "typical"
outline for the code when the file is loaded. When you save, the outline is 
written back.

Do the same thing you did with @@thin - i.e., 

- Remove the first @, and save. 
- Check the resulting file (`/myfile_auto.py) and observe that it has 
  no sentinels.   
- There is no "magic" involved. If you execute 'File -&gt; Read auto nodes" 
  (or right click on @auto node and choose "Refresh from disk", or reopen 
  this document), you'll note that  the outline structure was lost, 
  and the "parsed" structure is created instead. This is the cost
  of using @auto nodes.</t>
<t tx="ekr.20120913105857.2930"></t>
<t tx="ekr.20120913105857.2931">@language python
@others
</t>
<t tx="ekr.20120913105857.2932"></t>
<t tx="ekr.20120913105857.2933">import os
import sys

</t>
<t tx="ekr.20120913105857.2934">def init1():
    print "init1"

def init2():
    print "init2"</t>
<t tx="ekr.20120913105857.2935">class Foo:
    &lt;&lt; docstring &gt;&gt;
    @others


</t>
<t tx="ekr.20120913105857.2936">""" Some sort of useful class """

</t>
<t tx="ekr.20120913105857.2937">def spam(self):
    pass

</t>
<t tx="ekr.20120913105857.2938">def eggs(self):
    pass</t>
<t tx="ekr.20120913105857.2939">In this tree, you can experiment with @shadow. It combines the benefits
of @thin and @auto - namely, it publishes a file without sentinels, but
still allows the tree structure to survive, even if the external file
is edited outside Leo.

The cost is complexity - @shadow relies on a "shadow file" that remembers
the structure, and a sophisticated diff/patch algorithm that merges
the changes from the external file to the tree structure.

Experiment by editing the external file outside Leo and doing Right click
-&gt; refresh from disk on the @shadow node. </t>
<t tx="ekr.20120913105857.2940"></t>
<t tx="ekr.20120913105857.2941">@language python
@others
</t>
<t tx="ekr.20120913105857.2942"></t>
<t tx="ekr.20120913105857.2943">import os
import sys

</t>
<t tx="ekr.20120913105857.2944">def init1():
    print "init1"

def init2():
    print "init2"</t>
<t tx="ekr.20120913105857.2945">class Foo:
    &lt;&lt; docstring &gt;&gt;
    @others


</t>
<t tx="ekr.20120913105857.2946">""" Some sort of useful class """

</t>
<t tx="ekr.20120913105857.2947">def spam(self):
    pass

</t>
<t tx="ekr.20120913105857.2948">def eggs(self):
    pass</t>
<t tx="ekr.20120913105857.2949">reStructuredText (http://docutils.sourceforge.net/rst.html)
is an efficient way of authoring documentation as plain text.
Leo provides first-class support for RST authoring, including 
the unique feature of representing RST outline structure
as Leo tree. You can find an example in the tree below - again,
just remove the first @ character from @@auto-rst and save,
opening the external file afterwards.
</t>
<t tx="ekr.20120913105857.2950"></t>
<t tx="ekr.20120913105857.2951" rst-import="7d710028580b000000756e6465726c696e657332710158000000007102580b000000756e6465726c696e65733171036802752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.

</t>
<t tx="ekr.20120913105857.2952">Observe the underlining style of the headings.
</t>
<t tx="ekr.20120913105857.2953">Some text in first other chapter.
</t>
<t tx="ekr.20120913105857.2954">More text in other chapter.</t>
<t tx="ekr.20120913105857.2955">If you are just starting, you should create your own myLeoSettings.leo in ~/.leo. We'll do that next.

Create the file first: 
  - File -&gt; New (or ctrl+N)
  - File -&gt; Save as
  - Navigate to ~/.leo
  - save as myLeoSettings.leo

In the current tree, there is @@settings subtree. We are
copying this to the new file. Go to node @@settings, and
copy the whole tree to clipboard (ctrl+shift+c).
  
Select the document that has myLeoSettings.leo (the one you
just created). Drop the settings tree there (ctrl+shift+v),
Remove extra @ from @@settings, and save again.

Now, you should be all set. Verify that it worked by Help-&gt;open myLeoSettings.leo
</t>
<t tx="ekr.20120913105857.2956"># execute this script by ctrl+b to find out where your ~/.leo is

g.es('Homedir is at ',g.app.homeLeoDir)

</t>
<t tx="ekr.20120913105857.2957"></t>
<t tx="ekr.20120913105857.2958"># Leo loads plugins in the order they appear here.
# File names may be indented as desired.

# Standard plugins enabled in official distributions....

plugins_menu.py
leo_to_html.py
mod_scripting.py
quicksearch.py
UNL.py
contextmenu.py
nav_qt.py

# The plugins manager plugin does not
# understand @enabled-plugins nodes.
# plugin_manager.py

# The rst3 plugin is no longer needed.
# It's code has been moved to Leo's core
# rst3.py

# These plugins used to be enabled when using the tk plugin.
# cleo.py
# hoist.py
# image.py
# nav_buttons.py
# threading_colorizer.py

# All other plugins.
# Order is important for enabled plugins that
# add items to the icon area.

# ConceptualSort.py
# EditAttributes.py
# FileActions.py
# Library.py
# nodeActions.py
# UASearch.py
# URLloader.py
# UniversalScrolling.py

# add_directives.py
# arrows.py
# at_folder.py
# at_view.py
# autotrees.py
# base64Packager.py
# bibtex.py
# chapter_hoist.py
# cleo.py
# color_markup.py
# datenodes.py
# detect_urls.py
# dyna_menu.py
# fastGotoNode.py
# footprints.py
# groupOperations.py
# hoist.py
# image.py
# import_cisco_config.py
# ipython.py
# keybindings.py
# leoOPML.py
# leo_to_html.py
# leo_to_rtf.py
# leoupdate.py
# macros.py
# mod_autosave.py
# mod_http.py
# mod_labels.py
# mod_read_dir_outline.py
# mod_shadow.py
# multifile.py
# nav_buttons.py
# newButtons.py
# niceNosent.py
# nodebar.py
# nodenavigator.py
# open_shell.py
# open_with.py
# paste_as_headlines.py
# pie_menus.py
# pretty_print.py
# print_cp.py
# quickMove.py
# rClick.py
# read_only_nodes.py
# rowcol.py
# run_nodes.py
# s_menu.py
# scheduler.py
# searchbox.py
# shortcut_button.py
# slideshow.py
# table.py
# templates.py
# trace_tags.py
# vim.py
# word_count.py
# word_export.py
# xcc_nodes.py
# xemacs.py
# xsltWithNodes.py
# zodb.py
# quicksearch.py
# tomboy_import.py
# ctagscompleter.py
# colorize_headlines.py</t>
<t tx="ekr.20120913105857.2959">horizontal: body pane to the left
vertical: body pane on the botton

vertical is the default; you may prefer horizontal for small but wide screens (e.g. on laptops)</t>
<t tx="ekr.20120913105857.2960">This tree containt some suggested "looks" for Leo.

To experiment, you may want to use a @button that applies
the stylesheet in current node; look for "@button set-style-sheet" 
in scripts.leo.

For information on stylesheets, see

http://doc.trolltech.com/stylesheet.html

Style contributions are welcome.</t>
<t tx="ekr.20120913105857.2961">Classic Leo colors. This should look good on Linux.</t>
<t tx="ekr.20120913105857.2962">/* Documentation of Qt stylesheets at http://doc.trolltech.com/stylesheet.html 

To experiment, you may want to use a @button that applies
the current stylesheet; look for "@button set-style-sheet" in
scripts.leo.

*/

/* Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords */

/* A QWidget: supports only background attributes.*/

QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: white;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: DejaVu Sans Mono;
    /* font-family: Courier New; */
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}

/* The mini-buffer */
QLineEdit#lineEdit {
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLineEdit#status1 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
}

QLineEdit#status2 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
}

XXQPushButton {
    background-color: #fdf5f5; /* A kind of pink. */
    margin: 2px;
    padding; 4px;
    border-width: 2px;
    border-style: solid;
    border-color: darkgrey;
}

/* QMenuBar works, but not QMenu... */
XXQMenuBar {
    font-family: DejaVu Sans Mono;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}
</t>
<t tx="ekr.20120913105857.2963">This is the classic Leo look, but with fonts that
allegedly look better on Mac.</t>
<t tx="ekr.20120913105857.2964">/* Documentation of Qt stylesheets at http://doc.trolltech.com/4.2/stylesheet.html */

/* Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords */

/* A QWidget: supports only background attributes.*/

QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    font-family: Lucida Grande;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    font-family: Lucida Grande;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: white;
    selection-background-color: blue;
    font-family: Monaco;
    font-size: 10px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: Monaco;
    /* font-family: Courier New; */
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family: Lucida Grande;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family: Lucida Grande;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}

/* The mini-buffer */
QLineEdit#lineEdit {
    selection-color: white;
    selection-background-color: lightgrey;
    font-family: Monaco;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLineEdit#status1 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
}

QLineEdit#status2 {
    background-color: lightgrey;
    border-width: 1px;
    border-style: solid;
    border-color: darkgrey;
}

XXQPushButton {
    background-color: #fdf5f5; /* A kind of pink. */
    margin: 2px;
    padding; 4px;
    border-width: 2px;
    border-style: solid;
    border-color: darkgrey;
}

/* QMenuBar works, but not QMenu... */
XXQMenuBar {
    font-family: Lucida Grande;
    font-size: 12px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}</t>
<t tx="ekr.20120913105857.2965">If zero, all nodes are colorized, regardless of length of body text.
If &gt; 0, only nodes whose body text are smaller than this limit are colorized.</t>
<t tx="ekr.20120913105857.2966"># Add commands to contextmenu
# The format is &lt;command&gt; SPACE &lt;description&gt;

# stickynote Create a sticky note
# read-at-file-nodes Read file node</t>
<t tx="ekr.20120913105857.2967">Avoid red focus borders in body pane (if it's not in your aesthetic taste)</t>
<t tx="ekr.20120913105857.2968">Press ctrl + F to enter "minibuffer find" mode. Press F3 to
"find again".

For large scale searches (classic "find in files"
functionality for the whole tree), look for the "Nav" tab in
the log pane (in upper right of the screen). Enter your
search string and press enter, then click on the matches.

You can also activate the "Nav" functionality with ctrl+shift+f.

To perform find-and replace, press ctrl-f, enter the text
to search, then press ctrl+shift+r, and enter the text to replace
the matches with, and press Enter.

To limit the replace operations to particular external file,
you can use your external editor. That is, right click on
the @thin node (say, @thin myfile.py), choose "Edit
myfile.py in MYEDITOR", and perform the necessary operations.
After that, right click on the node and choose "Refresh from 
disk".
</t>
<t tx="ekr.20120913105857.2969">The minibuffer is the text input area at the bottom of the
screen, familiar to users of emacs and vi.

Press alt-x to enter a minibuffer command (e.g. alt-x
fill-paragraph). Press ctrl+p (repeat-complex-command)
folowed by Enter to re-run a previous minibuffer command.</t>
<t tx="ekr.20120913105857.2970">Eventually, you will want to add extra functionality to your
Leo documents. There are a few simple ways, and unlimited 
power for advanced users

</t>
<t tx="ekr.20120913105857.2971">You can write scripts in your document trees, and execute
them with ctrl+b. Try it on the child of this node - it
should display the list of nodes that have a headline
starting with @ in the log pane.

It will also append the summary as a new node under itself.

</t>
<t tx="ekr.20120913105857.2972">@language python
# c is "commander", central api object specific to current document 

# get a list of "position" objects
nodes = c.find_h('^@')

res = []
for n in nodes:
    # .b gets the body text, .h is headline
    body = n.b
    res.append("- " + n.h)
    
    res.append("   " + str(body.count('\n')) + " lines")
    
# 'p' is the 'current position'    
child = p.insertAsLastChild()    
child.b = "\n".join(res)
child.h = "Report"

c.redraw()    </t>
<t tx="ekr.20120913105857.2973">You can create buttons in the button bar by adding @button
nodes to your outline.

A button does not appear automatically when you add it - you
need to reopen the document to make it appear.

</t>
<t tx="ekr.20120913105857.2974"># p is current position

g.es("p.h is " + p.h)</t>
<t tx="ekr.20120914093811.2824">c.save()

m = c.screencast_controller
assert m

if 1:
    # Start at c.p
    m.start(c.p)   
else:
    # You can start a screencast anywhere:
    # it continues until the first node that contains a call to m.quit()
    # However, this automatic find feature is a convenience.
    p = m.find_screencast(p)
    assert p
    m.start(p)</t>
<t tx="ekr.20120914093811.2825"></t>
<t tx="ekr.20120914093811.2826"># Create a root node for the examples.

m.p1.contract()
c.redraw_now(m.p1)

# Speed up typing.
# m.n1 = m.n2 = 0.0

m.log('Ctrl-I inserts a new node')

# Put the new node after the @screencast node.
m.command('insert-node')
</t>
<t tx="ekr.20120914104624.2829">m.log('Ctrl-H begins editing')
m.command('edit-headline')
</t>
<t tx="ekr.20120914104624.2832">m.log('Return puts focus in the body pane')
m.focus('body')
</t>
<t tx="ekr.20120914104624.2833">m.log('Now we can type some text')
m.body_keys('This is some body text.\n')
m.body_keys('Some more body text.\n',n1=0.0,n2=0.0)
m.log(
    'The little square in the icon box\n' +
    'indicates that the node has body text')</t>
<t tx="ekr.20120914104624.2834">m.log("Let's insert a new node")
m.command('insert-node')
</t>
<t tx="ekr.20120914104624.2835">m.log('Ctrl-R moves the outline right')
m.command('move-outline-right')
</t>
<t tx="ekr.20120914104624.2836">m.log('UpArrow selects the previous node')
m.command('goto-prev-visible')
</t>
<t tx="ekr.20120914104624.2837">m.log('LeftArrow collapses the node')
m.command('contract-node')
</t>
<t tx="ekr.20120914104624.2838">m.log('RightArrow expands the node')
m.command('expand-node')</t>
<t tx="ekr.20120914174750.2850">m.log('That\'s all folks!')
</t>
<t tx="ekr.20120914174750.2851">p2 = m.p1.next()
if p2 and p2.h == 'Node 1':
    p2.doDelete()
    c.redraw_now(m.p1)
m.quit()</t>
<t tx="ekr.20120914174750.2853">m.log(
    'The new node has a black icon border '
    'indicating that the node has changed')
</t>
<t tx="ekr.20120914182320.2853">m.log("We'll type in the headline")
m.head_keys('Node 1')
</t>
<t tx="ekr.20120914183137.2850"></t>
<t tx="ekr.20120914183137.2851">m.tree('This is the tree pane')</t>
<t tx="ekr.20120914183137.2853">m.log('This is the log pane')</t>
<t tx="ekr.20120914183137.2855">m.body('This is the body pane')</t>
<t tx="ekr.20120914183137.2856">m.body('The minibuffer is below the body pane')</t>
<t tx="ekr.20120914183137.2857">m.tree('The icon area appears above the tree pane')</t>
<t tx="ekr.20120915073533.2862"></t>
<t tx="ekr.20120915112650.2864">m.log('The icon for a changed node has a black border.')
m.image('tree','box08.GIF',center=True,height=100)</t>
<t tx="ekr.20120915114713.2866">m.log('The icon for an empty, unchanged node has a gray border.')
m.image('tree','box00.GIF',center=True,height=100)</t>
<t tx="ekr.20120915122112.2868"></t>
<t tx="ekr.20120915122112.2869">m.log('A marked node has an icon with a red vertical line.')
m.image('tree','box02.GIF',center=True,height=100)</t>
<t tx="ekr.20120915122112.2870">m.log('A cloned node has an icon with a red arrow.')
m.image('tree','box04.GIF',center=True,height=100)</t>
<t tx="ekr.20120915122112.2871">m.log('A node with body text has a small blue square in its icon')
m.image('tree','box01.GIF',center=True,height=100)</t>
<t tx="ekr.20120915122112.2872">m.log('This changed, cloned, marked node has body text')
m.image('tree','box15.GIF',center=True,height=100)</t>
<t tx="ekr.20120915122112.2873">m.log('Each node has an oblong icon box to the left of its headline')
</t>
<t tx="ekr.20120915122112.2874">m.log('The save command clears all black borders')
m.image('tree','box07.GIF',center=True,height=100)</t>
<t tx="ekr.20120915162554.2882"></t>
<t tx="ekr.20120915162554.2883">m.body(
    'The minibuffer is an area at the bottom of the screen.\n'
    'You use the minibuffer to enter commands by name.\n'
    '&lt;Alt-X&gt; opens the minibuffer')
m.single_key('alt-x')

</t>
<t tx="ekr.20120915164308.2886">m.body(
    'We only need to type the start of long command names.\n'
    'Here we have typed "ins" to begin one of Leo\'s insert commands.')
m.plain_keys('ins')
</t>
<t tx="ekr.20120915170516.2888">m.body(
    'The &lt;Tab&gt; key does tab completion.\n'
    'The Completion tab shows all the valid completions.\n'
    'The minibuffer shows the longest common prefix.')
m.plain_keys('\t')
</t>
<t tx="ekr.20120915173000.2894">m.body(
    'Typing "no&lt;Tab&gt;" is enough to complete the command:\n'
    'only one command appears in the Completion tab.')
m.plain_keys('no\t')
</t>
<t tx="ekr.20120915173000.2895">m.body(
    'When only one item appears in the Completion list\n'
    'The &lt;Return&gt; key will execute the command'
)
</t>
<t tx="ekr.20120915174321.2898">m.body('A new node has been inserted')
m.plain_keys('\n')
</t>
<t tx="ekr.20120915175727.2905">m.body('Deleting the newly-inserted node concludes this slideshow.')

</t>
<t tx="ekr.20120915181136.2907"></t>
<t tx="ekr.20120916063628.2912">m.tree('This screencasts discusses Leo\'s basic Find/Change commands')</t>
<t tx="ekr.20120916063628.2913">
m.quit()</t>
<t tx="ekr.20120916063628.2922">m.quit()</t>
<t tx="ekr.20120916065229.2914">assert m.p1
p2 = m.p1.next()
assert p2
if p2.h == 'newHeadline' and not p2.b:
    p2.doDelete()

m.quit()</t>
<t tx="ekr.20120916065229.2916">m.tree(
    'Typing &lt;Ctrl-F&gt; starts the find command.\n'
    'Leo shows the Find Tab in the Log pane.\n'
    'The minibuffer prompts you for a Find string'
)

m.single_key('ctrl-f')
m.plain_keys('def spam')
</t>
<t tx="ekr.20120916140331.2916">m.tree('Typing &lt;Return&gt; starts the search')
</t>
<t tx="ekr.20120916184021.2918">def spam():
    pass</t>
<t tx="ekr.20120916184840.2920">m.tree('The search succeeds')

p2 = g.findNodeInTree(c,m.p1,'spam')
m.redraw(p2)

m.plain_keys('\n')
</t>
<t tx="ekr.20120916185527.2922">m.body('Typing o&lt;Tab&gt; gets us back to the insert-node command')
m.plain_keys('o\t')
</t>
<t tx="ekr.20120917133405.2948">m.body('Typing a single &lt;BackSpace&gt; shows the same completions')
m.plain_keys('\b')
</t>
<t tx="ekr.20120917133405.2950">m.body('Typing another &lt;BackSpace&gt; still shows the same completions')
m.plain_keys('\b')
</t>
<t tx="ekr.20120917133405.2952">m.body('Typing a third &lt;BackSpace&gt; shows more completions')
m.plain_keys('\b')
</t>
<t tx="ekr.20120917133405.2953">m.body('Typing "e" followed by &lt;Tab&gt; completes the insert-newline command')
m.plain_keys('e\t')</t>
<t tx="ekr.20120917133405.2955">m.body('Typing &lt;BackSpace&gt; six more times restores the previous completions')
m.plain_keys('\b\b\b\b\b\b')
</t>
<t tx="ekr.20120917200834.2928"></t>
<t tx="ekr.20120918103721.2944">@language rest</t>
<t tx="ekr.20120918103721.2948">m.quit()</t>
<t tx="ekr.20120918111016.2955">Let's go behind the scenes to see how this slidewhow works...</t>
<t tx="ekr.20120918113531.2956">This screencast discusses how to make screencasts with the screencasts
plugin. This screencasts goes "behind the scenes" to revealing the inner
workings of screencasts that are usually hidden. So this screencast is
**unusual**, much like a TeX document that discusses TeX will be unusual.

Indeed, this first "scene" of the screencast simply shows this particular
node. As we shall see, screencasts usually do more than just show text.

When you have finished reading this node, hit the Right Arrow key to to go
the next scene.
</t>
<t tx="ekr.20120918113531.2957">This is some *emphasized* motivation.</t>
<t tx="ekr.20120918115916.2954">m.log(
    'All screencasts should end with a call to m.quit(). '
    'For this last slide, we\'ll show the *next* slide '
    'by calling m.redraw(m.p.next()).')
m.redraw(m.p.next())</t>
<t tx="ekr.20120918121401.2957">It's easy to show the text of another node in the present slideshow whose
headline h is known::

    p2 = g.findNodeInTree(c,m.p1,h)
    m.redraw(p2)
    
This selects p2 in the outline and shows the body text of p2.
</t>
<t tx="ekr.20120918123030.2960">m.log('This screencast shows the different parts of Leo\'s screen')</t>
<t tx="ekr.20120918143835.2964">- Make it easy to demonstrate Leo's features.

- Generate graphics and comments easily.

- Easily scriptable.

- Easy to generate *finished* slides.</t>
<t tx="ekr.20120918144251.2964">The screencast plugin creates a **screencast**, a series of **slides** or **scenes**.
Slides are static; scenes may contain animations.

By default, a screencast is made up of an @screencast node and all its
descendants. Each node represents one slide or scene. The screencast moves
from node to node. Each node executes a **screencast script**. Typically,
the script in each node modifies some part of Leo's window by switching
nodes, show commands in action, or by displaying graphics or captions.</t>
<t tx="ekr.20120918144251.2965">The screencast plugin came about in order to make it easier to show Leo in
action, and to make it easier for Leo's users to show how they use Leo.

A screencast is composed of the nodes of an **@screencast tree**.

Each **screencast node** represents a **slide**. A slide is simply the
appearance of the Leo window.

Each screencast node contains a **screencast script**. Screencast scripts
are Leo scripts, so they can do anything, they alter the appearance of the
Leo main window in some way.

Screencast scripts have access to the 'c', 'g' and 'p' vars as usual.
Screencast scripts also have access to the 'm' variable, representing the
**screencast controller** for the commander c.  Methods of the screencast
controller make it easy to show graphics, including captions.

A **caption** is a text area that overlays part of Leo's screen.  By default,
captions have a distinctive yellow background.

When showing a screencast, the **presenter** moves from slide to slide
merely by typing the Right Arrow key.  This key executes the screencast nodes
in outline order.</t>
<t tx="ekr.20120918164428.2968">m.log(
    'A screencasts is made up of nodes. '
    'Like this one.')
m.redraw(m.p)</t>
<t tx="ekr.20120918170133.2973">m.log(
    'Nodes contain scripts. '
    'Within such scripts, '
    '"m" is bound to a ScreenShotController object.'
)
m.redraw(m.p)</t>
<t tx="ekr.20120918170133.2974">m.log('This screencast is different: it shows its own nodes by calling m.redraw(m.p)')
m.redraw(m.p)</t>
<t tx="ekr.20120918170133.2975">m.log('m.p is the "program counter" of the screencast.')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2976">m.log('Most screencasts do *not* show the nodes comprising the screencast.')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2979">m.log('m.p is the position of the node whose script is being executed')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2981">m.log('As we has seen, m.log puts "caption" text in the log pane')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2982">m.log('A caption is text that overlays one of Leo\'s panes')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2983">m.log('The m.tree method puts a caption in the outline (tree) pane')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2984">m.tree('Like this')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2986">m.log('The m.body method puts a caption in the body pane')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2987">m.body('Like this')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2989">m.log('The m.redraw(p) method selects node p and redraws the screen.')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2990">m.log("It's unusual for scripts to call attention to themselves by calling m.redraw(m.p)")
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2991">m.log('Most scripts call m.redraw(p) to show a node p outside the @screencast tree')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2992">m.log('The m.image method puts up an image in an indicated pane.')
m.redraw(m.p)
</t>
<t tx="ekr.20120918170946.2993">m.log('Like this.')
m.image('tree','box00.GIF',center=True,height=100)
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2994"></t>
<t tx="ekr.20120918170946.2997">m.log('Several methods deal with key handling.')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2998">m.log('m.head_keys simulates typing in a headline')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.2999">m.log('Like this')
m.head_keys('Typing in the headline')
m.redraw(m.p)</t>
<t tx="ekr.20120918170946.3000">m.log('Oops.  Let\'s restore the previous headline.')
m.p.back().back().h = 'm.head_keys'
m.redraw(m.p)</t>
<t tx="ekr.20120918174346.3014">m.log('Similarly, m.body keys simulates typing in the body pane')
m.redraw(m.p)</t>
<t tx="ekr.20120918174346.3015">m.log("We'll put the body text in the child node. ")

c.selectPosition(m.p.firstChild())
m.body_keys('This is body text')
m.redraw(m.p)
m.p.firstChild().b = ''</t>
<t tx="ekr.20120918174346.3016"></t>
<t tx="ekr.20120918174346.3018">m.log('You can organize screencasts in several ways')
m.redraw(m.p)</t>
<t tx="ekr.20120918174346.3019">m.log('Nodes without body text act as organizer nodes. ')
m.redraw(m.p)</t>
<t tx="ekr.20120918174346.3020">m.log(
    '@ignore-node nodes are also ignored. '
    'They can contain any kind of body text.'
)
m.redraw(m.p)</t>
<t tx="ekr.20120918174346.3021">m.log('In this example, well do m.redraw(m.p.firstChild()) to show the skipped node.')
m.redraw(m.p.firstChild())</t>
<t tx="ekr.20120918174346.3022">@language rest

This node can contain any kind of text.

It is *not* treated as a screencast script.
</t>
<t tx="ekr.20120918174346.3023">m.log('The other screencasts in this file give more typical examples '
    'of how to use the methods of the ScreenCastController object.'
)
m.redraw(m.p)</t>
<t tx="ekr.20120918174346.3024"></t>
<t tx="ekr.20120918174346.3025">m.log('There ScreenCastController object has several useful convenience methods')
m.redraw(m.p)</t>
<t tx="ekr.20120918174346.3026"></t>
<t tx="ekr.20120918174346.3027">m.log('All nodes in an @ignore-tree tree are completely ignored.')
m.redraw(m.p)</t>
<t tx="ekr.20120918174346.3028"></t>
<t tx="ekr.20120918174346.3029"></t>
<t tx="ekr.20120921072549.3028"></t>
<t tx="ekr.20120922123519.3032">menu = m.open_menu('file')
</t>
<t tx="ekr.20120922123519.3033">m.open_menu('recent-files')</t>
<t tx="ekr.20120922123519.3034">m.open_menu('read/write')</t>
<t tx="ekr.20120922123519.3035">m.open_menu('export')</t>
<t tx="ekr.20120922123519.3037">m.open_menu('openwith')
</t>
<t tx="ekr.20120922123519.3038">m.open_menu('edit')</t>
<t tx="ekr.20120922123519.3039">m.open_menu('edit-body')</t>
<t tx="ekr.20120922123519.3040">m.open_menu('edit-headline')</t>
<t tx="ekr.20120922123519.3041">m.open_menu('find')</t>
<t tx="ekr.20120922124750.3050">m.open_menu('outline')</t>
<t tx="ekr.20120922124750.3051">m.open_menu('check')</t>
<t tx="ekr.20120922124750.3052">m.open_menu('expand/contract')</t>
<t tx="ekr.20120922124750.3053">m.open_menu('move')</t>
<t tx="ekr.20120922124750.3054">m.open_menu('mark')</t>
<t tx="ekr.20120922124750.3055">m.open_menu('goto')</t>
<t tx="ekr.20120922124750.3057">m.open_menu('cmds')
</t>
<t tx="ekr.20120922124750.3058">m.open_menu('plugins')</t>
<t tx="ekr.20120922124750.3059">m.open_menu('core')</t>
<t tx="ekr.20120922124750.3060">m.open_menu('window')</t>
<t tx="ekr.20120922124750.3061">m.open_menu('help')</t>
<t tx="ekr.20120922124750.3062">m.open_menu('helpcommands')</t>
<t tx="ekr.20120922124750.3063">m.open_menu('abbrev')</t>
<t tx="ekr.20120922124750.3064">m.open_menu('bodyeditors')</t>
<t tx="ekr.20120922124750.3065">m.open_menu('buffers')</t>
<t tx="ekr.20120922124750.3066">m.open_menu('chapters')</t>
<t tx="ekr.20120922124750.3067">m.open_menu('cursorselection')</t>
<t tx="ekr.20120922124750.3068">m.open_menu('cursorback')</t>
<t tx="ekr.20120922124750.3069">m.open_menu('cursorbackextendselection')</t>
<t tx="ekr.20120922124750.3070">m.open_menu('cursorbackextendto')</t>
<t tx="ekr.20120922124750.3071">m.open_menu('cursorforward')</t>
<t tx="ekr.20120922124750.3072">m.open_menu('cursorforwardextendselection')</t>
<t tx="ekr.20120922124750.3073">m.open_menu('debugging')</t>
<t tx="ekr.20120922124750.3074">m.open_menu('filesanddirectories')</t>
<t tx="ekr.20120922124750.3075">m.open_menu('focus')</t>
<t tx="ekr.20120922124750.3076">m.open_menu('icons')</t>
<t tx="ekr.20120922124750.3077">m.open_menu('macros')</t>
<t tx="ekr.20120922124750.3078">m.open_menu('minibuffer')</t>
<t tx="ekr.20120922124750.3079">m.open_menu('pickers')</t>
<t tx="ekr.20120922124750.3080">m.open_menu('rectangles')</t>
<t tx="ekr.20120922124750.3081">m.open_menu('registers')</t>
<t tx="ekr.20120922124750.3082">m.open_menu('rstcommands')</t>
<t tx="ekr.20120922124750.3084">m.open_menu('runscripttests')</t>
<t tx="ekr.20120922124750.3085">m.open_menu('scrolling')</t>
<t tx="ekr.20120922124750.3086">m.open_menu('shell')</t>
<t tx="ekr.20120922124750.3087">m.open_menu('spellcheck')</t>
<t tx="ekr.20120922124750.3088">m.open_menu('textcommands')</t>
<t tx="ekr.20120922124750.3089">m.open_menu('togglesettings')</t>
<t tx="ekr.20120922124750.3090">m.open_menu('yankandkill')</t>
<t tx="ekr.20120922191243.3126">@nocolor-node

At present, opening a menu with m.open_menu "hangs" the screencast until
the presenter hits &lt;esc&gt; enough times to dismiss the menu.

I'd like to be able to call m.dismiss_menu_bar after waiting, say, 2
seconds, but the menu won't be shown until after the entire script is
executed!

For example, the following code does not work. The menu's outline is shown
after the redraws, but that is all. The calls to repaint have no effect.

    menu = m.open_menu('outline')
    menu.parent().repaint()
    menu.raise_()
    menu.repaint() # Doen't work.
    m.wait(1)
    m.dismiss_menu_bar()
</t>
<t tx="ekr.20120923063534.3130">p2 = g.findNodeAnywhere(c,'Example Tree')
p2.contract()
m.select_position(p2)

m.body(
    'This is a brief tutorial slideshow showing the basics of Leo.\n'''
    'The Right Arrow key goes to the next slide.\n'
    'The Ctrl-G key quits this tutorial.'
)</t>
<t tx="ekr.20120923105702.3128">c.screencast_controller.start(
    g.findNodeAnywhere(c,'@screencast Tutorial'))</t>
<t tx="ekr.20120923110028.3130"></t>
<t tx="ekr.20120923110028.3131"></t>
<t tx="ekr.20120923110028.3132">p2 = g.findNodeAnywhere(c,'Example Tree')
p3 = g.findNodeInTree(c,p2,'newHeadline')
if p3:
    p3.doDelete()
    m.redraw()
m.body(
    'Deleting the inserted node concludes the slideshow. '
    'We have merely scratched the surface of what Leo can do.\n'
)</t>
<t tx="ekr.20120923110028.3133"></t>
<t tx="ekr.20120923110028.3136"></t>
<t tx="ekr.20120923110028.3137"></t>
<t tx="ekr.20120923110028.3138"></t>
<t tx="ekr.20120923115619.3155"></t>
<t tx="ekr.20120925073640.3143">@language rest

'''

This is known to cause scrolling problems.

Scroll to end, either with mouse wheel or ctrl-end.
Then click:  the unwanted scroll happens.

Overview
========

This plugin is a tool for people wanting to demonstrate Leo or some Leonine
project to others. Using this plugin, a human demonstrator can prepare an
automated talk ahead of time. The talk is a series of slides created by Leo
itself. Each slide is simply Leo as it appears at a particular time. When
giving the talk, the presenter moves from one slide to the next by hitting
the RtArrow (Right Arrow) key. The presenter may also back up from the
present slide to the previous slide using the LtArrow (Left Arrow) key.

To create the presentation, the presenter creates an **@screencast** node.
This node, and all its descendants, is called the **controlling tree**.
Each node of this tree may contain a script in its body text; each script
creates a slide. Nodes without scripts can be used as organizer nodes as
usual. **@ignore-node** nodes and **@ignore-tree** trees are ignored.
Normally, the controlling tree will be hidden from view during the
presentation--the presentation will be about *other* parts of the tree.

The screencast-start command starts a screencast. This command shows the
first slide of the nearest \@screencast node. Thereafter, the plugin
executes the next script in controlling tree when the demonstrator types
the RtArrow key. These scripts are normal Leo scripts, except that they
also have access to an "m" variable that denotes a **ScreenCastController**
(SCC), an object created by this plugin. The term **screencast script**
denotes a script that has access to the "m" variable.

The SCC provides convenience methods that screencast scripts can use to
draw attention to various parts of Leo's screen. A typical script will
consist of just one or two of the following calls:

- **m.image(file_name)** overlays a scaled image on Leo's window. For
  example, a screencast could discuss Leo's icon box by shown greatly
  magnified images of various kinds of icon box.
  
- **m.body(text)** overlays a caption on Leo's body pane. By default,
  captions have a bright yellow background so that they clearly stand out
  from the normal appearance of Leo's screen. Similarly **m.log(text)** and
  **m.tree(text)** overlay captions on Leo's log and tree panes.
  
- **m.body_keys(text)** and **m.head_keys(text)** animate typing of text in
  body text and headlines respectively.

- **m.single_key(key_setting)** allows any key to be handled exactly as if
  the user had typed the key.
  
- **m.open_menu(menu_name)** opens a menu as if the demonstrator had opened it
  with a mouse click. **m.dismiss_menubar()** closes all open menus.

To summarize: the presenter moves from slide to slide using the RtArrow
key. The RtArrow key causes the SCC executes the next script in the
controlling tree. The script alters the screen, say by selecting inserting,
deleting, expanding and contracting nodes, or by inserting, deleting or
changing headline or body text. The script will typically also show images
or captions to highlight what the slide is supposed to be showing. In
short:

- A screencast is a sequence of slides.  A slide is the appearance
  of Leo after a screencast script is executed.

- The human presenter moves to the next slide using the RtArrow key.
  The LtArrow key moves back to the previous slide.
  
- Scripts in an \@screencast tree create slides. The 'm' variable allows
  such scripts to animate keystrokes or overlay images or captions on the
  screen.
  
Before reading further, please look at the example \@screencast trees in
test.leo. Then run those screencasts to see the what the scripts do.
  

Reference
=========

The screencast-start command
----------------------------

The screencast-start command starts a screencast. This command first
searches backwards for the nearest \@screencast node. If no such node is
found, the command searches forwards for the next \@screencast node. This
command then executes the script in the body text, and pauses. Thereafter,
the Right Arrow key executes the script in the next slide node (in outline
order). The Left Arrow key executes the script in the previous slide node.
The Escape or Ctrl-G keys terminate any screencast.

Screencast scripts
------------------

Screencast scripts are Leo scripts that have access to the 'm' variable,
which is bound to c.screencastController, and instance of
ScreenCastController. Such scripts typically use 'm' to access convenience
methods, but advanced scripts can use 'm' in other ways.

The ScreenCastController
------------------------

The ScreenCastController (SCC) controls key handling during screencasts and
executes screencast scripts as the screencast moves from node to node.

The SCC only traps the RtArrow and LtArrow keys during a screencast. The
SCC passes all other keys to Leo's key-handling code. This allows key
handling in key-states during the execution of a screencast. For example::
    
    m.single_key('Alt-X')
    m.plain_keys('ins\\tno\\t\\n')
    
actually executes the insert-node command!

SCC methods
-----------

The following paragraphs discuss the SCC methods that screencasts scripts
may use.

**m.body(s)**, **m.log(s)** and **m.tree(s)** create a caption with text s
in the indicated pane. A **caption** is a text area that overlays part of
Leo's screen. By default, captions have a distinctive yellow background.
The appearance of captions can be changed using Qt stylesheets. See below.

**m.body_keys(s,n1=None,n2=None)** Draws the string s in the body pane of
the presently selected node. n1 and n2 give the range of delays to be
inserted between typing. If n1 and n2 are both None, values are given that
approximate a typical typing rate.

**m.command(command_name)** Executes the named command.

**m.dismiss_menubar()** Dismisses the menu opened with m.open_menu.

**m.focus(pane)** Immediately forces focus to the indicated pane. Valid
values are 'bodly', 'log' or 'tree'.

**m.image(pane,fn,center=None,height=None,width=None)** Overlays an image
in a pane. The valid values for `pane` are 'body', 'log' or 'tree'. `fn` is
the path to the image file, resolved to the leo/Icons directory if fn is a
relative path. If `height` is given, the image is scaled so it is height
pixels high. If `width` is given, the image is scaled so it width pixels
wide. If `center` is True, the image is centered horizontally in the given
pane.

**m.head_keys(s,n1=None,n2=None)** Same as m.body_keys, except that the
keys are "typed" into the headline of the presently selected node.

**m.open_menu(menu_name)** Opens the menu whose name is given, ignoring
case and any non-alpha characters in menu_name. This method shows all
parent menus, so m.open_menu('cursorback') suffices to show the
"Cmds\:Cursor/Selection\:Cursor Back..." menu.

**m.plain_keys(s,n1=None,n2=None,pane='body')** Same as m.body_keys, except
that the keys are typed into the designated pane. The valid values for the
'pane' argument are 'body','log' or 'tree'.

**m.quit** ends the screencast. By definition, the last slide of screencast
is the screencast node that calls m.quit.

**m.redraw(p)** Forces an immediate redraw of the outline pane. If p is
given, that position becomes c.p, the presently selected node.

**m.selectPosition(p)** Same as m.redraw(p)

**m.single_key(setting)** generates a key event. Examples::
    
   m.single_key('Alt-X') # Activates the minibuffer
   m.single_key('Ctrl-F') # Activates Leo's Find command
   
The 'setting' arg can be anything that would be a valid key setting. The
following are equivalent: "ctrl-f", "Ctrl-f", "Ctrl+F", etc., but "ctrl-F"
is different from "ctrl-shift-f".

**m.start(p)** Starts a screencast at node p, regardless of whether p is an
\@screencast node. This is useful during development while testing the
script in node p.

The program counter, m.p
------------------------

Most presenters will want to keep the nodes of the presentation tree
hidden. Instead, presentation will make *other* nodes visible by calling
m.selectPosition(p) or m.redraw(p).

Thus, there must be a sharp distinction between the presently *selected*
node, c.p, and the present screencast node, m.p. You can think of m.p as
the program counter for the screencast.

By default, after executing a screencast script, the SCC advances m.p to
the next non-empty, non-ignored node in the \@screencast tree. However, if
the just-executed screencast script has set m.p to a new, non-empty value,
that value will be the new value of m.p.
  
Stylesheets
-----------

Presenters may alter the appearance of captions by using changing the
following stylesheet::

    QPlainTextEdit#screencastcaption {
        background-color: yellow;
        font-family: DejaVu Sans Mono;
        font-size: 18pt;
        font-weight: normal; /* normal,bold,100,..,900 */
        font-style: normal; /* normal,italic,oblique */
    }

You will find this stylesheet in the node @data
``qt-gui-plugin-style-sheet`` in leoSettings.leo or myLeoSettings.leo.


'''
</t>
<t tx="ekr.20120925084214.3144">w = c.frame.body.bodyCtrl.widget
print(w)


vsb = w.verticalScrollBar()
vpos = vsb.sliderPosition()
print(vpos)</t>
<t tx="ekr.20120925105035.3146">def sp(s=''):
    old = g._old_sp
    pos1 = c.frame.body.bodyCtrl.getYScrollPosition()
    vsb = c.frame.body.bodyCtrl.widget.verticalScrollBar()
    vmax = vsb.maximum()
    pos2 = vsb.sliderPosition()
    if s or old is None or old != pos1 or old != pos2:
        g._old_sp = pos2
        print(pos1,pos2,vmax)
    if g._force_vscroll is not None:
        vsb.setSliderPosition(g._force_vscroll)
        g._force_vscroll = None


g._force_vscroll = None
g._sp = sp
g._old_sp = None
g.registerHandler('idle', lambda a,b:g._sp())
g.cls()</t>
<t tx="ekr.20120928085003.3150">g.note('note')
g.warning('warning')
g.error('error')
g.es('pink',color='pink')
g.es_print('purple',color='purple')
g.es('default')</t>
<t tx="ekr.20120928143821.3161"></t>
<t tx="ekr.20120928143821.3162">Color for error messages written to the log window.</t>
<t tx="ekr.20120928143821.3163">Foreground color of log text.

</t>
<t tx="ekr.20120928143821.3164">Background color of log text.</t>
<t tx="ekr.20120928143821.3168"></t>
<t tx="ekr.20121005071615.3175">path = g.os_path_join(g.app.loadDir,'..','modes')

for language in ('rest','plain'):
    fileName = g.os_path_join(path,'%s.py' % (language))
    if g.os_path_exists(fileName):
        mode = g.importFromPath (language,path)
    else:
        mode = None
    print(language,mode)</t>
<t tx="ekr.20121008164702.3281"></t>
<t tx="ekr.20121008164702.3282"># Convert a .ipynb file to a Leo outline.

import json

&lt;&lt; define s &gt;&gt;

@others

IpynbReader(c).parse(s)

print('done')
</t>
<t tx="ekr.20121008164702.3283">s = r"""
{
  "metadata": {
    "name": "Part 2: Dataset Basics and Concepts"
  }, 
  "nbformat": 3, 
  "nbformat_minor": 0, 
  "worksheets": [
    {
      "cells": [
        {
          "cell_type": "heading", 
          "level": 1, 
          "metadata": {}, 
          "source": [
            "Part 2: Dataset Basics and Concepts"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Note*", 
            "\n\n", 
            "This tutorial part is also available for download as an ", 
            "[IPython notebook][IPython notebook]:\n[", 
            "[ipynb][ipynb]]", 
            "- - -\n"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "A ", 
            "[Dataset](http://pymvpa.org/generated/mvpa2.datasets.base.Dataset.html#mvpa2-datasets-base-dataset) is the basic data container in PyMVPA. It\nserves as the primary form of input data storage, but also as container for\nmore complex results returned by some algorithm. In this tutorial part we will\ntake a look at what a dataset consists of, and how it works.\n\n", 
            "In the simplest case, a dataset only contains ", 
            "*data* that is a matrix of\nnumerical values."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "from mvpa2.tutorial_suite import *\n", 
            "data = [[  1,  1, -1],\n        [  2,  0,  0],\n        [  3,  1,  1],\n        [  4,  0, -1]]\n", 
            "ds = Dataset(data)\n", 
            "ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In the above example, every row vector in the `data` matrix becomes an\nobservation or a ", 
            "[sample](http://pymvpa.org/glossary.html#term-sample) in the dataset, and every column vector\nrepresents an individual variable or a ", 
            "[feature](http://pymvpa.org/glossary.html#term-feature). The concepts of samples\nand features are essential for a dataset, hence we take a further, closer look.\n\n", 
            "The dataset assumes the first axis of the data to be the samples separating\ndimension. If the dataset is created using a one-dimensional vector it will\ntherefore have as many samples as elements in the vector, and only one feature."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "one_d = [ 0, 1, 2, 3 ]\n", 
            "one_ds = Dataset(one_d)\n", 
            "one_ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "On the other hand, if a dataset is created from multi-dimensional data, only its\nsecond axis represents the features"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "import numpy as np\n", 
            "m_ds = Dataset(np.random.random((3, 4, 2, 3)))\n", 
            "m_ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "m_ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In this case we have a dataset with three samples and four features, where each\nfeature is a 2x3 matrix. In case somebody is wondering now, why not simply each\nvalue in the data array is considered as its own feature (yielding 24 features)\n-- stay tuned, as this is going to be of importance later on."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Attributes"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "What we have seen so far does not really warrant the use of a dataset over a\nplain array or a matrix with samples. However, in the MVPA context we often need\nto know more about each samples than just the value of its features.  In the\nprevious tutorial part we have already seen that per-sample ", 
            "[target](http://pymvpa.org/glossary.html#term-target)\nvalues are required for supervised-learning algorithms, and that a dataset\noften has to be split based on the origin of specific groups of samples.  For\nthis type of auxiliary information a dataset can also contain collections of\nthree types of ", 
            "[attribute](http://pymvpa.org/glossary.html#term-attribute)s: ", 
            "[sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute), ", 
            "[feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute), and\n", 
            "[dataset attribute](http://pymvpa.org/glossary.html#term-dataset-attribute)."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For Samples"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In a dataset each ", 
            "[sample](http://pymvpa.org/glossary.html#term-sample) can have an arbitrary number of additional\nattributes. They are stored as vectors of the same length as the number of samples\nin a collection, and are accessible via the `sa` attribute. A collection is\nderived from a standard Python ", 
            "`dict`, and hence adding sample attributes\nworks identical to adding elements to a dictionary:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'] = [ 0., 1, 1, 3 ]\n", 
            "ds.sa.keys()"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "However, sample attributes are not directly stored as plain data, but for\nvarious reasons as a so-called ", 
            "[Collectable](http://pymvpa.org/generated/mvpa2.base.collections.Collectable.html#mvpa2-base-collections-collectable) that in\nturn embeds a NumPy array with the actual attribute:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "type(ds.sa['some_attr'])"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'].value"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "This \"complication\" is done to be able to extend attributes with additional\nfunctionality that is often needed and can offer significant speed-up of\nprocessing. For example, sample attributes carry a list of their unique values.\nThis list is only computed once (upon first request) and can subsequently be\naccessed directly without repeated and expensive searches:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['some_attr'].unique"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "However, for most interactive uses of PyMVPA this type of access to attributes'\n`.value` is relatively cumbersome (too much typing), therefore collections offer direct\nattribute access by name:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Another purpose of the sample attribute collection is to preserve data\nintegrity, by disallowing improper attributes:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['invalid'] = 4"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['invalid'] = [ 1, 2, 3, 4, 5, 6 ]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "But other than basic plausibility checks no further constraints on values of\nsamples attributes exist. As long as the length of the attribute vector matches\nthe number of samples in the dataset, and the attributes values can be stored\nin a NumPy array, any value is allowed. For example, it is perfectly possible\nand supported to store literal attributes. It should also be noted that each\nattribute may have its own individual data type, hence it is possible to have\nliteral and numeric attributes in the same dataset."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa['literal'] = ['one', 'two', 'three', 'four']\n", 
            "sorted(ds.sa.keys())"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "for attr in ds.sa:\n   print \"%s: %s\" % (attr, ds.sa[attr].value.dtype.name)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For Features"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "[Feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute)s are almost identical to ", 
            "[sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute)s the ", 
            "*only* difference is that instead of having one attribute value per\nsample, feature attributes have one value per (guess what? ...) ", 
            "*feature*.\nMoreover, they are stored in a separate collection in the datasets that is\ncalled `fa`:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.fa['my_fav'] = [0, 1, 0]\n", 
            "ds.fa['responsible'] = ['me', 'you', 'nobody']\n", 
            "sorted(ds.fa.keys())"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 3, 
          "metadata": {}, 
          "source": [
            "For The Dataset"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Finally, there can be also attributes, not per each sample, or each\nfeature, but for the dataset as a whole: so called ", 
            "[dataset](http://pymvpa.org/glossary.html#term-dataset)s. Assigning such attributes and accessing them later on work in\nexactly the same way as for the other two types of attributes, except that dataset\nattributes are stored in their own collection which is accessible via the\n`a` property of the dataset.  However, in contrast to sample and feature\nattribute no constraints on the type or size are imposed -- anything can be\nstored. Let's store a list with all files in the current directory, just\nbecause we can:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "from glob import glob\n", 
            "ds.a['pointless'] = glob(\"*\")\n", 
            "'setup.py' in ds.a.pointless"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Slicing, resampling, feature selection"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "At this point we can already construct a dataset from simple arrays and\nenrich it with an arbitrary number of additional attributes. But just\nhaving a dataset isn't enough. From part one of this tutorial we already\nknow that we need to be able to select subsets of a dataset for further\nprocessing, and we also know that this is possible with PyMVPA's datasets.\nNow it is time to have a closer look into how it works.\n\n", 
            "Slicing a dataset (i.e. selecting specific subsets) is very similar to\nslicing a NumPy array. It actually works ", 
            "*almost* identical. A dataset\nsupports Python's ", 
            "`slice` syntax, but also selection by boolean masks, and\nindices. The following three slicing operations\nresult in equivalent output datasets, by always selecting every other samples\nin the dataset:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[::2].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "mask = np.array([True, False, True, False])\n", 
            "ds[mask].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[[0, 2]].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Exercise*", 
            "\n\n", 
            "Search the `NumPy documentation`_ for the difference between \"basic slicing\"\nand \"advanced indexing\". Especially the aspect of memory consumption\napplies to dataset slicing as well, and being aware of this fact might\nhelp to write more efficient analysis scripts. Which of the three slicing\napproaches above is the most memory-efficient?  Which of the three slicing\napproaches above might lead to unexpected side-effects if output dataset\ngets modified?"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "# you can use this cell to for this exercise"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n", 
            "\n\n", 
            "All three slicing-styles are equally applicable to the selection of feature\nsubsets within a dataset. Remember, features are represented on the second axis\nof a dataset."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds[:, [1,2]].samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "By applying a selection by indices to the second axis, we can easily get\nthe last two features of our example dataset. Please note the ", 
            "`:` is supplied\nas first axis slicing. This is the Python way to indicate ", 
            "*take everything\nalong this axis*, hence including all samples.\n\n", 
            "As you can guess, it is also possible to select subsets of samples and\nfeatures at the same time."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "subds = ds[[0,1], [0,2]]\n", 
            "subds.samples"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "If you have prior experience with NumPy you might be confused now. What you\nmight have expected is this:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.samples[[0,1], [0,2]]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "The above code applies the same slicing directly to the NumPy array with\nthe samples, and the result is fundamentally different. For NumPy arrays\nthis style of slicing allows to select specific elements by their indices on\neach axis of an array. For PyMVPA's datasets this mode is not very useful,\ninstead we typically want to select rows and columns, i.e. samples and\nfeatures given by their indices."
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Exercise*", 
            "\n\n", 
            "Try to select samples [0,1] and features [0,2,3] simultaneously using\ndataset slicing.  Now apply the same slicing to the samples array itself\n(`ds.samples`) -- make sure that the result doesn't surprise you and find\na pure NumPy way to achieve similar selection."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "# you can use this cell to for this exercise"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n", 
            "\n\n", 
            "One last interesting thing to look at, in the context of dataset slicing\nare the attributes. What happens to them when a subset of samples and/or\nfeatures is chosen? Our original dataset had both samples and feature attributes:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.fa.responsible"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Now let's look at what they became in the subset-dataset we previously\ncreated:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print subds.sa.some_attr"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print subds.fa.responsible"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We see that both attributes are still there and, moreover, also the\nappropriate subsets have been selected."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Loading fMRI data"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Enough of theoretical foreplay -- let's look at a concrete example of an\nfMRI dataset. PyMVPA has several helper functions to load data from\nspecialized formats, and the one for fMRI data is\n", 
            "[fmri_dataset()](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset). The example dataset we are going to\nlook at is a single subject from Haxby et al. (2001) that we already\nloaded in part one of this tutorial. For more convenience, and less typing\nwe first specify the path of the directory with the fMRI data."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "path=os.path.join(tutorial_data_path, 'data')"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In the simplest case, we now let ", 
            "[fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) do its job, by just\npointing it to the fMRI data file. The data is stored as a NIfTI file that has\nall runs of the experiment concatenated into a single file."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'))\n", 
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.shape"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We can notice two things. First, it worked! Second, we get a\ntwo-dimensional dataset with 1452 samples (these are volumes in the NIfTI\nfile), and over 160k features (these are voxels in the volume). The voxels\nare represented as a one-dimensional vector, and it seems that they have\nlost their association with the 3D-voxel-space. However, this is not the\ncase, as we will see in the next chapter.  PyMVPA represents\ndata in this simple format to make it compatible with a vast range of generic\nalgorithms that expect data to be a simple matrix.\n\n", 
            "We just loaded all data from that NIfTI file, but usually we would be\ninterested in a subset only, i.e. \"brain voxels\".\n", 
            "[fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) is capable of performing data masking. We just need to\nspecify a mask image. Such mask image is generated in pretty much any fMRI\nanalysis pipeline -- may it be a full-brain mask computed during\nskull-stripping, or an activation map from a functional localizer. We are going\nto use the original GLM-based localizer mask of ventral temporal cortex\nfrom Haxby et al. (2001). We already know that it comprises 577 voxels.\nLet's reload the dataset:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'),\n                  mask=os.path.join(path, 'mask_vt.nii.gz'))\n", 
            "len(ds)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.nfeatures"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "As expected, we get the same number of samples and also only 577 features\n-- voxels corresponding to non-zero elements in the mask image. Now, let's\nexplore this dataset a little further.\n\n", 
            "Besides samples the dataset offers number of attributes that enhance the\ndata with information that is present in the NIfTI image header in the file. Each sample has\ninformation about its volume ID in the time series and the actual acquisition\ntime (relative to the beginning of the file). Moreover, the original voxel\nindex (sometimes referred to as `ijk`) for each feature is available too.\nFinally, the dataset also contains information about the dimensionality\nof the input volumes, voxel size, and any other NIfTI-specific information\nsince it also includes a dump of the full NIfTI image header."
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "- - -\n*Note*", 
            "\n\n", 
            "Previously (0.4.x versions and 0.5 development prior March 03, 2010),\nPyMVPA exposed 4D (and 3D with degenerate 1st dimension) data in `tkji`\n(corresponds to `tzyx` if volumes were axial slices in\nneurologic convention) order of dimensions.  Now it uses more convenient\norder `tijk` (corresponding to `txyz`), which will match the order exposed\nby NiBabel (PyNIfTI and NiftiImage still expose them as `tkji`).", 
            "- - -\n"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.time_indices[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.sa.time_coords[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.fa.voxel_indices[:5]"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.a.voxel_eldim"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.a.voxel_dim"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "'imghdr' in ds.a"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "In addition to all this information, the dataset also carries a key\nattribute: the ", 
            "*mapper*. A mapper is an important concept in PyMVPA, and\nhence worth devoting the whole ", 
            "*next tutorial chapter* to it."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "print ds.a.mapper"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Having all these attributes being part of a dataset is often a useful thing\nto have, but in some cases (e.g. when it comes to efficiency, and/or very\nlarge datasets) one might want to have a leaner dataset with just the\ninformation that is really necessary. One way to achieve this, is to strip\nall unwanted attributes. The Dataset class'\n", 
            "[AttrDataset.copy()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.copy) method can help with that."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "stripped = ds.copy(deep=False, sa=['time_coords'], fa=[], a=[])\n", 
            "print stripped"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "We can see that all attributes besides `time_coords` have been filtered out.\nSetting the `deep` arguments to `False` causes the copy function to reuse the\ndata from the source dataset to generate the new stripped one, without\nduplicating all data in memory -- meaning both datasets now share the sample\ndata and any change done to `ds` will also affect `stripped`."
          ]
        }, 
        {
          "cell_type": "heading", 
          "level": 2, 
          "metadata": {}, 
          "source": [
            "Storage"
          ]
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Some data preprocessing can take a long time.  One would rather prevent\ndoing it over and over again, and instead just store the preprocessed data\ninto a file for subsequent analyses. PyMVPA offers functionality to store a\nlarge variety of objects, including datasets, into ", 
            "[HDF5][HDF5] files. A variant\nof this format is also used by recent versions of Matlab to store data.\n\n", 
            "For HDF5 support PyMVPA depends on the ", 
            "[h5py][h5py] package. If it is available,\nany dataset can be saved to a file by simply calling\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) with the desired filename."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "import tempfile, shutil\n", 
            "tempdir = tempfile.mkdtemp()\n", 
            "ds.save(os.path.join(tempdir, 'mydataset.hdf5'))"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "HDF5 is a flexible format that also supports, for example, data\ncompression. To enable it, you can pass additional arguments to\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) that are supported by\n", 
            "`Group.create_dataset()`. Instead of using\n", 
            "[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) one can also use the ", 
            "[h5save()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5save.html#mvpa2-base-hdf5-h5save)\nfunction in a similar way. Saving the same dataset with maximum\ngzip-compression looks like this:"
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "ds.save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), compression=9)\n", 
            "h5save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), ds, compression=9)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "markdown", 
          "metadata": {}, 
          "source": [
            "\n\n", 
            "Loading datasets from a file is easy too. ", 
            "[h5load()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5load.html#mvpa2-base-hdf5-h5load) takes a filename as\nan argument and returns the stored dataset. Compressed data will be handled\ntransparently."
          ]
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "loaded = h5load(os.path.join(tempdir, 'mydataset.hdf5'))\n", 
            "np.all(ds.samples == loaded.samples)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }, 
        {
          "cell_type": "code", 
          "collapsed": false, 
          "input": [
            "shutil.rmtree(tempdir, ignore_errors=True)"
          ], 
          "language": "python", 
          "metadata": {}, 
          "outputs": []
        }
      ], 
      "metadata": {}
    }
  ]
}
"""</t>
<t tx="ekr.20121008164702.3284">class IpynbReader:
    
    @others
</t>
<t tx="ekr.20121008164702.3285">def __init__ (self,c):
    
    self.c = c

    self.root = root = g.findNodeAnywhere(c,'ipynb tree')
    assert root
    for p2 in root.children():
        p2.doDelete(root)

</t>
<t tx="ekr.20121008164702.3286">def do_cell(self,cell,level):
    
    trace = False
    ct  = cell.get('cell_type')
    src = cell.get('source') or []
    if ct == 'heading':
        level = cell.get('level')
        # h = 'heading level %s %s' % (level,src)
        h = src[0] if src else 'heading: ** no aList **'
        if trace: g.trace('** heading: %s %s' % (level,h))
        p = self.get_node(h,level)
    else:
        h = ct
        if trace: g.trace('** node: %s %s' % (level,h))
        p = self.get_node(ct,level+1)
        if ct == 'markdown':
            p.b = '@language rest\n\n' + ''.join(src).strip()
        elif ct == 'code':
            aList = cell.get('input') or []
            language = cell.get('language')
            if language:
                aList.insert(0,'@language %s\n\n' % (language))
            p.b = ''.join(aList)
            outputs = cell.get('outputs')
            if outputs:
                # To do: handle this.
                g.trace(outputs)
                
        # Make sure we haven't missed anything.
        for key in sorted(cell.keys()):
            keys = ('cell_type','code','collapsed','input','language','markdown','outputs','source')
            if key not in keys and cell.get(key) not in (None,{},[]):
                print('%10s %s' % (key,cell.get(key)))
                
    return level</t>
<t tx="ekr.20121008164702.3287">def do_worksheet(self,d):

    level = 0
    cells = d.get('cells')
    for cell in cells:
        level = self.do_cell(cell,level)
</t>
<t tx="ekr.20121008164702.3288">def get_node (self,h,level):
    
    '''Return a new node at the indicated level.'''
    
    # g.trace(level,len(self.stack),h)
    
    if 1 &gt; level &gt; len(self.stack) + 1:
        g.trace('bad level: %s' % level)
        return None
    else:
        parent = self.stack[level-1]
        p = parent.insertAsLastChild()
        p.h = h 
        self.stack = self.stack[:level]
        self.stack.append(p)
        assert len(self.stack) == level+1
        return p</t>
<t tx="ekr.20121008164702.3289">def parse (self,s):
    
    d = json.loads(g.toUnicode(s),strict=False)

    count = 1
    for d2 in d.get('worksheets'):
        local_root = self.root.insertAsLastChild()
        metadata = d2.get('metadata')
        if metadata:
            local_root.h = 'worksheet %s %s' % (count,metadata)
        else:
            local_root.h = 'worksheet %s' % count
        self.stack = [local_root]
        self.do_worksheet(d2)
        count += 1

    self.c.redraw()
</t>
<t tx="ekr.20121008164702.3290"></t>
<t tx="ekr.20121008164702.3291"></t>
<t tx="ekr.20121008164702.3292"></t>
<t tx="ekr.20121008164702.3293">@language rest

- - -
*Note*

This tutorial part is also available for download as an [IPython notebook][IPython notebook]:
[[ipynb][ipynb]]- - -</t>
<t tx="ekr.20121008164702.3294">@language rest

A [Dataset](http://pymvpa.org/generated/mvpa2.datasets.base.Dataset.html#mvpa2-datasets-base-dataset) is the basic data container in PyMVPA. It
serves as the primary form of input data storage, but also as container for
more complex results returned by some algorithm. In this tutorial part we will
take a look at what a dataset consists of, and how it works.

In the simplest case, a dataset only contains *data* that is a matrix of
numerical values.</t>
<t tx="ekr.20121008164702.3295">@language python

from mvpa2.tutorial_suite import *
data = [[  1,  1, -1],
        [  2,  0,  0],
        [  3,  1,  1],
        [  4,  0, -1]]
ds = Dataset(data)
ds.shape</t>
<t tx="ekr.20121008164702.3296">@language python

len(ds)</t>
<t tx="ekr.20121008164702.3297">@language python

ds.nfeatures</t>
<t tx="ekr.20121008164702.3298">@language python

ds.samples</t>
<t tx="ekr.20121008164702.3299">@language rest

In the above example, every row vector in the `data` matrix becomes an
observation or a [sample](http://pymvpa.org/glossary.html#term-sample) in the dataset, and every column vector
represents an individual variable or a [feature](http://pymvpa.org/glossary.html#term-feature). The concepts of samples
and features are essential for a dataset, hence we take a further, closer look.

The dataset assumes the first axis of the data to be the samples separating
dimension. If the dataset is created using a one-dimensional vector it will
therefore have as many samples as elements in the vector, and only one feature.</t>
<t tx="ekr.20121008164702.3300">@language python

one_d = [ 0, 1, 2, 3 ]
one_ds = Dataset(one_d)
one_ds.shape</t>
<t tx="ekr.20121008164702.3301">@language rest

On the other hand, if a dataset is created from multi-dimensional data, only its
second axis represents the features</t>
<t tx="ekr.20121008164702.3302">@language python

import numpy as np
m_ds = Dataset(np.random.random((3, 4, 2, 3)))
m_ds.shape</t>
<t tx="ekr.20121008164702.3303">@language python

m_ds.nfeatures</t>
<t tx="ekr.20121008164702.3304">@language rest

In this case we have a dataset with three samples and four features, where each
feature is a 2x3 matrix. In case somebody is wondering now, why not simply each
value in the data array is considered as its own feature (yielding 24 features)
-- stay tuned, as this is going to be of importance later on.</t>
<t tx="ekr.20121008164702.3305"></t>
<t tx="ekr.20121008164702.3306">@language rest

What we have seen so far does not really warrant the use of a dataset over a
plain array or a matrix with samples. However, in the MVPA context we often need
to know more about each samples than just the value of its features.  In the
previous tutorial part we have already seen that per-sample [target](http://pymvpa.org/glossary.html#term-target)
values are required for supervised-learning algorithms, and that a dataset
often has to be split based on the origin of specific groups of samples.  For
this type of auxiliary information a dataset can also contain collections of
three types of [attribute](http://pymvpa.org/glossary.html#term-attribute)s: [sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute), [feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute), and
[dataset attribute](http://pymvpa.org/glossary.html#term-dataset-attribute).</t>
<t tx="ekr.20121008164702.3307"></t>
<t tx="ekr.20121008164702.3308">@language rest

In a dataset each [sample](http://pymvpa.org/glossary.html#term-sample) can have an arbitrary number of additional
attributes. They are stored as vectors of the same length as the number of samples
in a collection, and are accessible via the `sa` attribute. A collection is
derived from a standard Python `dict`, and hence adding sample attributes
works identical to adding elements to a dictionary:</t>
<t tx="ekr.20121008164702.3309">@language python

ds.sa['some_attr'] = [ 0., 1, 1, 3 ]
ds.sa.keys()</t>
<t tx="ekr.20121008164702.3310">@language rest

However, sample attributes are not directly stored as plain data, but for
various reasons as a so-called [Collectable](http://pymvpa.org/generated/mvpa2.base.collections.Collectable.html#mvpa2-base-collections-collectable) that in
turn embeds a NumPy array with the actual attribute:</t>
<t tx="ekr.20121008164702.3311">@language python

type(ds.sa['some_attr'])</t>
<t tx="ekr.20121008164702.3312">@language python

ds.sa['some_attr'].value</t>
<t tx="ekr.20121008164702.3313">@language rest

This "complication" is done to be able to extend attributes with additional
functionality that is often needed and can offer significant speed-up of
processing. For example, sample attributes carry a list of their unique values.
This list is only computed once (upon first request) and can subsequently be
accessed directly without repeated and expensive searches:</t>
<t tx="ekr.20121008164702.3314">@language python

ds.sa['some_attr'].unique</t>
<t tx="ekr.20121008164702.3315">@language rest

However, for most interactive uses of PyMVPA this type of access to attributes'
`.value` is relatively cumbersome (too much typing), therefore collections offer direct
attribute access by name:</t>
<t tx="ekr.20121008164702.3316">@language python

ds.sa.some_attr</t>
<t tx="ekr.20121008164702.3317">@language rest

Another purpose of the sample attribute collection is to preserve data
integrity, by disallowing improper attributes:</t>
<t tx="ekr.20121008164702.3318">@language python

ds.sa['invalid'] = 4</t>
<t tx="ekr.20121008164702.3319">@language python

ds.sa['invalid'] = [ 1, 2, 3, 4, 5, 6 ]</t>
<t tx="ekr.20121008164702.3320">@language rest

But other than basic plausibility checks no further constraints on values of
samples attributes exist. As long as the length of the attribute vector matches
the number of samples in the dataset, and the attributes values can be stored
in a NumPy array, any value is allowed. For example, it is perfectly possible
and supported to store literal attributes. It should also be noted that each
attribute may have its own individual data type, hence it is possible to have
literal and numeric attributes in the same dataset.</t>
<t tx="ekr.20121008164702.3321">@language python

ds.sa['literal'] = ['one', 'two', 'three', 'four']
sorted(ds.sa.keys())</t>
<t tx="ekr.20121008164702.3322">@language python

for attr in ds.sa:
   print "%s: %s" % (attr, ds.sa[attr].value.dtype.name)</t>
<t tx="ekr.20121008164702.3323"></t>
<t tx="ekr.20121008164702.3324">@language rest

[Feature attribute](http://pymvpa.org/glossary.html#term-feature-attribute)s are almost identical to [sample attribute](http://pymvpa.org/glossary.html#term-sample-attribute)s the *only* difference is that instead of having one attribute value per
sample, feature attributes have one value per (guess what? ...) *feature*.
Moreover, they are stored in a separate collection in the datasets that is
called `fa`:</t>
<t tx="ekr.20121008164702.3325">@language python

ds.nfeatures</t>
<t tx="ekr.20121008164702.3326">@language python

ds.fa['my_fav'] = [0, 1, 0]
ds.fa['responsible'] = ['me', 'you', 'nobody']
sorted(ds.fa.keys())</t>
<t tx="ekr.20121008164702.3327"></t>
<t tx="ekr.20121008164702.3328">@language rest

Finally, there can be also attributes, not per each sample, or each
feature, but for the dataset as a whole: so called [dataset](http://pymvpa.org/glossary.html#term-dataset)s. Assigning such attributes and accessing them later on work in
exactly the same way as for the other two types of attributes, except that dataset
attributes are stored in their own collection which is accessible via the
`a` property of the dataset.  However, in contrast to sample and feature
attribute no constraints on the type or size are imposed -- anything can be
stored. Let's store a list with all files in the current directory, just
because we can:</t>
<t tx="ekr.20121008164702.3329">@language python

from glob import glob
ds.a['pointless'] = glob("*")
'setup.py' in ds.a.pointless</t>
<t tx="ekr.20121008164702.3330"></t>
<t tx="ekr.20121008164702.3331">@language rest

At this point we can already construct a dataset from simple arrays and
enrich it with an arbitrary number of additional attributes. But just
having a dataset isn't enough. From part one of this tutorial we already
know that we need to be able to select subsets of a dataset for further
processing, and we also know that this is possible with PyMVPA's datasets.
Now it is time to have a closer look into how it works.

Slicing a dataset (i.e. selecting specific subsets) is very similar to
slicing a NumPy array. It actually works *almost* identical. A dataset
supports Python's `slice` syntax, but also selection by boolean masks, and
indices. The following three slicing operations
result in equivalent output datasets, by always selecting every other samples
in the dataset:</t>
<t tx="ekr.20121008164702.3332">@language python

ds.samples</t>
<t tx="ekr.20121008164702.3333">@language python

ds[::2].samples</t>
<t tx="ekr.20121008164702.3334">@language python

mask = np.array([True, False, True, False])
ds[mask].samples</t>
<t tx="ekr.20121008164702.3335">@language python

ds[[0, 2]].samples</t>
<t tx="ekr.20121008164702.3336">@language rest

- - -
*Exercise*

Search the `NumPy documentation`_ for the difference between "basic slicing"
and "advanced indexing". Especially the aspect of memory consumption
applies to dataset slicing as well, and being aware of this fact might
help to write more efficient analysis scripts. Which of the three slicing
approaches above is the most memory-efficient?  Which of the three slicing
approaches above might lead to unexpected side-effects if output dataset
gets modified?</t>
<t tx="ekr.20121008164702.3337">@language python

# you can use this cell to for this exercise</t>
<t tx="ekr.20121008164702.3338">@language rest

- - -


All three slicing-styles are equally applicable to the selection of feature
subsets within a dataset. Remember, features are represented on the second axis
of a dataset.</t>
<t tx="ekr.20121008164702.3339">@language python

ds[:, [1,2]].samples</t>
<t tx="ekr.20121008164702.3340">@language rest

By applying a selection by indices to the second axis, we can easily get
the last two features of our example dataset. Please note the `:` is supplied
as first axis slicing. This is the Python way to indicate *take everything
along this axis*, hence including all samples.

As you can guess, it is also possible to select subsets of samples and
features at the same time.</t>
<t tx="ekr.20121008164702.3341">@language python

subds = ds[[0,1], [0,2]]
subds.samples</t>
<t tx="ekr.20121008164702.3342">@language rest

If you have prior experience with NumPy you might be confused now. What you
might have expected is this:</t>
<t tx="ekr.20121008164702.3343">@language python

ds.samples[[0,1], [0,2]]</t>
<t tx="ekr.20121008164702.3344">@language rest

The above code applies the same slicing directly to the NumPy array with
the samples, and the result is fundamentally different. For NumPy arrays
this style of slicing allows to select specific elements by their indices on
each axis of an array. For PyMVPA's datasets this mode is not very useful,
instead we typically want to select rows and columns, i.e. samples and
features given by their indices.</t>
<t tx="ekr.20121008164702.3345">@language rest

- - -
*Exercise*

Try to select samples [0,1] and features [0,2,3] simultaneously using
dataset slicing.  Now apply the same slicing to the samples array itself
(`ds.samples`) -- make sure that the result doesn't surprise you and find
a pure NumPy way to achieve similar selection.</t>
<t tx="ekr.20121008164702.3346">@language python

# you can use this cell to for this exercise</t>
<t tx="ekr.20121008164702.3347">@language rest

- - -


One last interesting thing to look at, in the context of dataset slicing
are the attributes. What happens to them when a subset of samples and/or
features is chosen? Our original dataset had both samples and feature attributes:</t>
<t tx="ekr.20121008164702.3348">@language python

print ds.sa.some_attr</t>
<t tx="ekr.20121008164702.3349">@language python

print ds.fa.responsible</t>
<t tx="ekr.20121008164702.3350">@language rest

Now let's look at what they became in the subset-dataset we previously
created:</t>
<t tx="ekr.20121008164702.3351">@language python

print subds.sa.some_attr</t>
<t tx="ekr.20121008164702.3352">@language python

print subds.fa.responsible</t>
<t tx="ekr.20121008164702.3353">@language rest

We see that both attributes are still there and, moreover, also the
appropriate subsets have been selected.</t>
<t tx="ekr.20121008164702.3354"></t>
<t tx="ekr.20121008164702.3355">@language rest

Enough of theoretical foreplay -- let's look at a concrete example of an
fMRI dataset. PyMVPA has several helper functions to load data from
specialized formats, and the one for fMRI data is
[fmri_dataset()](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset). The example dataset we are going to
look at is a single subject from Haxby et al. (2001) that we already
loaded in part one of this tutorial. For more convenience, and less typing
we first specify the path of the directory with the fMRI data.</t>
<t tx="ekr.20121008164702.3356">@language python

path=os.path.join(tutorial_data_path, 'data')</t>
<t tx="ekr.20121008164702.3357">@language rest

In the simplest case, we now let [fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) do its job, by just
pointing it to the fMRI data file. The data is stored as a NIfTI file that has
all runs of the experiment concatenated into a single file.</t>
<t tx="ekr.20121008164702.3358">@language python

ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'))
len(ds)</t>
<t tx="ekr.20121008164702.3359">@language python

ds.nfeatures</t>
<t tx="ekr.20121008164702.3360">@language python

ds.shape</t>
<t tx="ekr.20121008164702.3361">@language rest

We can notice two things. First, it worked! Second, we get a
two-dimensional dataset with 1452 samples (these are volumes in the NIfTI
file), and over 160k features (these are voxels in the volume). The voxels
are represented as a one-dimensional vector, and it seems that they have
lost their association with the 3D-voxel-space. However, this is not the
case, as we will see in the next chapter.  PyMVPA represents
data in this simple format to make it compatible with a vast range of generic
algorithms that expect data to be a simple matrix.

We just loaded all data from that NIfTI file, but usually we would be
interested in a subset only, i.e. "brain voxels".
[fmri_dataset](http://pymvpa.org/generated/mvpa2.datasets.mri.fmri_dataset.html#mvpa2-datasets-mri-fmri-dataset) is capable of performing data masking. We just need to
specify a mask image. Such mask image is generated in pretty much any fMRI
analysis pipeline -- may it be a full-brain mask computed during
skull-stripping, or an activation map from a functional localizer. We are going
to use the original GLM-based localizer mask of ventral temporal cortex
from Haxby et al. (2001). We already know that it comprises 577 voxels.
Let's reload the dataset:</t>
<t tx="ekr.20121008164702.3362">@language python

ds = fmri_dataset(os.path.join(path, 'bold.nii.gz'),
                  mask=os.path.join(path, 'mask_vt.nii.gz'))
len(ds)</t>
<t tx="ekr.20121008164702.3363">@language python

ds.nfeatures</t>
<t tx="ekr.20121008164702.3364">@language rest

As expected, we get the same number of samples and also only 577 features
-- voxels corresponding to non-zero elements in the mask image. Now, let's
explore this dataset a little further.

Besides samples the dataset offers number of attributes that enhance the
data with information that is present in the NIfTI image header in the file. Each sample has
information about its volume ID in the time series and the actual acquisition
time (relative to the beginning of the file). Moreover, the original voxel
index (sometimes referred to as `ijk`) for each feature is available too.
Finally, the dataset also contains information about the dimensionality
of the input volumes, voxel size, and any other NIfTI-specific information
since it also includes a dump of the full NIfTI image header.</t>
<t tx="ekr.20121008164702.3365">@language rest

- - -
*Note*

Previously (0.4.x versions and 0.5 development prior March 03, 2010),
PyMVPA exposed 4D (and 3D with degenerate 1st dimension) data in `tkji`
(corresponds to `tzyx` if volumes were axial slices in
neurologic convention) order of dimensions.  Now it uses more convenient
order `tijk` (corresponding to `txyz`), which will match the order exposed
by NiBabel (PyNIfTI and NiftiImage still expose them as `tkji`).- - -</t>
<t tx="ekr.20121008164702.3366">@language python

ds.sa.time_indices[:5]</t>
<t tx="ekr.20121008164702.3367">@language python

ds.sa.time_coords[:5]</t>
<t tx="ekr.20121008164702.3368">@language python

ds.fa.voxel_indices[:5]</t>
<t tx="ekr.20121008164702.3369">@language python

ds.a.voxel_eldim</t>
<t tx="ekr.20121008164702.3370">@language python

ds.a.voxel_dim</t>
<t tx="ekr.20121008164702.3371">@language python

'imghdr' in ds.a</t>
<t tx="ekr.20121008164702.3372">@language rest

In addition to all this information, the dataset also carries a key
attribute: the *mapper*. A mapper is an important concept in PyMVPA, and
hence worth devoting the whole *next tutorial chapter* to it.</t>
<t tx="ekr.20121008164702.3373">@language python

print ds.a.mapper</t>
<t tx="ekr.20121008164702.3374">@language rest

Having all these attributes being part of a dataset is often a useful thing
to have, but in some cases (e.g. when it comes to efficiency, and/or very
large datasets) one might want to have a leaner dataset with just the
information that is really necessary. One way to achieve this, is to strip
all unwanted attributes. The Dataset class'
[AttrDataset.copy()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.copy) method can help with that.</t>
<t tx="ekr.20121008164702.3375">@language python

stripped = ds.copy(deep=False, sa=['time_coords'], fa=[], a=[])
print stripped</t>
<t tx="ekr.20121008164702.3376">@language rest

We can see that all attributes besides `time_coords` have been filtered out.
Setting the `deep` arguments to `False` causes the copy function to reuse the
data from the source dataset to generate the new stripped one, without
duplicating all data in memory -- meaning both datasets now share the sample
data and any change done to `ds` will also affect `stripped`.</t>
<t tx="ekr.20121008164702.3377"></t>
<t tx="ekr.20121008164702.3378">@language rest

Some data preprocessing can take a long time.  One would rather prevent
doing it over and over again, and instead just store the preprocessed data
into a file for subsequent analyses. PyMVPA offers functionality to store a
large variety of objects, including datasets, into [HDF5][HDF5] files. A variant
of this format is also used by recent versions of Matlab to store data.

For HDF5 support PyMVPA depends on the [h5py][h5py] package. If it is available,
any dataset can be saved to a file by simply calling
[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) with the desired filename.</t>
<t tx="ekr.20121008164702.3379">@language python

import tempfile, shutil
tempdir = tempfile.mkdtemp()
ds.save(os.path.join(tempdir, 'mydataset.hdf5'))</t>
<t tx="ekr.20121008164702.3380">@language rest

HDF5 is a flexible format that also supports, for example, data
compression. To enable it, you can pass additional arguments to
[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) that are supported by
`Group.create_dataset()`. Instead of using
[AttrDataset.save()](http://pymvpa.org/generated/mvpa2.base.dataset.AttrDataset.html#mvpa2.base.dataset.AttrDataset.save) one can also use the [h5save()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5save.html#mvpa2-base-hdf5-h5save)
function in a similar way. Saving the same dataset with maximum
gzip-compression looks like this:</t>
<t tx="ekr.20121008164702.3381">@language python

ds.save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), compression=9)
h5save(os.path.join(tempdir, 'mydataset.gzipped.hdf5'), ds, compression=9)</t>
<t tx="ekr.20121008164702.3382">@language rest

Loading datasets from a file is easy too. [h5load()](http://pymvpa.org/generated/mvpa2.base.hdf5.h5load.html#mvpa2-base-hdf5-h5load) takes a filename as
an argument and returns the stored dataset. Compressed data will be handled
transparently.</t>
<t tx="ekr.20121008164702.3383">@language python

loaded = h5load(os.path.join(tempdir, 'mydataset.hdf5'))
np.all(ds.samples == loaded.samples)</t>
<t tx="ekr.20121008164702.3384">@language python

shutil.rmtree(tempdir, ignore_errors=True)</t>
<t tx="ekr.20121011100948.4582">'''Recursively import all python files in theDir and clean the result.'''

import os
import time

safe_at_file = True # True: create @@file nodes instead of @file nodes.

# theTypes = ('.py',)
# theDir = r'C:\Python26\Lib\site-packages\rope'
theTypes = ('.ts',)
theDir = r'C:\prog\typescript-fe3bc0bfce1f\src\compiler'

@others

if g.os_path_exists(theDir):
    if 1: # Production.
        # Import all files in theDir after c.p.
        ImportController().run(c,p,theDir,theTypes)
    else: # Testing.
        p = g.findNodeAnywhere(c,'Imported files')
        ImportController().post_process(c,p,theDir,theTypes)
    c.redraw()
else:
    print('Does not exist: %s' % (theDir))
</t>
<t tx="ekr.20121011100948.4583">def import_dir(self,c,root,theDir,theTypes):

    g.es("dir: " + theDir,color="blue")
    dirs,files,files2 = [],os.listdir(theDir),[]
    for f in files:
        path = g.os_path_join(theDir,f)
        if g.os_path_isfile(path):
            name, ext = g.os_path_splitext(f)
            if not theTypes or ext in theTypes:
                files2.append(path)
        else: # elif recursive:
            dirs.append(path)
    if files2 or dirs:
        child = root.insertAsLastChild()
        child.h = theDir
        c.selectPosition(child,enableRedrawFlag=False)
    if files2:
        # files2 = [files2[0]] ### Just import one file.
        c.importCommands.importFilesCommand(files2,'@file',redrawFlag=False) # '@auto' causes problems.
    if dirs:
        for theDir in sorted(dirs):
            prefix = theDir
            self.import_dir(c,child,theDir,theTypes)
</t>
<t tx="ekr.20121011100948.4584">def clean_all (self,c,p):
    
    for p in p.self_and_subtree():
        if p.h.startswith('@file') or p.h.startswith('@@file'):
            self.clean(c,p)
</t>
<t tx="ekr.20121011100948.4585">def clean(self,c,p):
    
    '''
    - Move a shebang line from the first child to the root.
    - Move a leading docstring in the first child to the root.
    - Use a section reference for declarations.
    - Remove leading and trailing blank lines from all nodes.
    - Merge a node containing nothing but comments with the next node.
    - Merge a node containing no class or def lines with the previous node.
    '''

    root = p.copy()
    for tag in ('@@file','@file'):
        if p.h.startswith(tag):
            p.h = p.h[len(tag):].strip()
            break
            
    self.move_shebang_line(c,root)
    self.move_doc_string(c,root)
    self.rename_decls(c,root)

    for p in root.self_and_subtree():
        self.clean_blank_lines(c,p)
    for p in root.subtree():
        self.merge_comment_nodes(c,p)
    for p in root.subtree():
        self.merge_extra_nodes(c,p)
    for p in root.subtree():
        self.move_decorator_lines(c,p)
</t>
<t tx="ekr.20121011100948.4586">def clean_blank_lines(self,c,p):
    
    '''Remove leading and trailing blank lines from all nodes.
    '''
    
    s = p.b
    if not s.strip():
        return
    
    result = g.splitLines(s)
    for i in 0,-1:
        while result:
            if result[i].strip():
                break
            else:
                del result[i]
        
    s = ''.join(result)
    if not s.endswith('\n'): s = s + '\n'
    if s != p.b:
        p.b = s
        # p.setDirty()
        # p.setMarked()
        # c.setChanged(True)
        # self.changed += 1
</t>
<t tx="ekr.20121011100948.4587">def merge_comment_nodes(self,c,p):
    
    '''Merge a node containing nothing but comments with the next node.'''

    h = p.h
    
    if p.hasChildren() or not h.strip().startswith('#'):
        return
        
    p2 = p.next()
    if p2:
        b = p.b.lstrip()
        b = b + ('\n' if b.endswith('\n') else '\n\n')
        p2.b = b + p2.b
        p.doDelete(p2)
        # p2.setDirty()
        # p2.setMarked()
        # c.setChanged(True)
        # self.changed += 1
        # g.trace(h,' --&gt; ',p2.h)
</t>
<t tx="ekr.20121011100948.4588">def merge_extra_nodes(self,c,p):
    
    '''Merge a node containing no class or def lines with the previous node'''
    
    s = p.b
    if p.hasChildren() or p.h.strip().startswith('&lt;&lt;') or not s.strip():
        return
        
    for s2 in g.splitLines(s):
        if s2.strip().startswith('class') or s2.strip().startswith('def'):
            return

    p2 = p.back()
    if p2:
        nl = '\n' if s.endswith('\n') else '\n\n'
        p2.b = p2.b + nl + s
        h = p.h
        p.doDelete(p2)
        # p2.setDirty()
        # p2.setMarked()
        # c.setChanged(True)
        # self.changed += 1
        # g.trace(h,' --&gt; ',p2.h)
</t>
<t tx="ekr.20121011100948.4589">def move_decorator_lines (self,c,p):
    
    '''Move trailing decorator lines to the next node.'''
    
    trace = False
    p2 = p.next()
    if not p2: return False
    
    lines = g.splitLines(p.b)
    n = len(lines) -1
    while n &gt;= 0:
        s = lines[n]
        if s.startswith('@'):
            i = g.skip_id(s,1,chars='-')
            word = s[1:i]
            if word in g.globalDirectiveList:
                break
            else:
                n -= 1
        else:
            break
        
    head = ''.join(lines[:n+1])
    tail = ''.join(lines[n+1:])
    if not tail: return False

    assert head.endswith('\n')
    assert p.b == head+tail
    
    if trace:
        if tail not in seen:
            seen.append(tail)
            g.trace(tail.strip())
    
    if 1:
        nl = '' if tail.endswith('\n') else '\n'
        p.b = head
        p2.b = tail+nl+p2.b
        
    return True
    # p2.setDirty()
    # p2.setMarked()
    # c.setChanged(True)
    # self.changed += 1
</t>
<t tx="ekr.20121011100948.4590">def move_doc_string(self,c,root):

    '''Move a leading docstring in the first child to the root node.'''
    
    # To do: copy comments before docstring
    
    p = root.firstChild()
    s = p and p.b or ''
    if not s: return
    
    # if root.h.endswith('pgen.py'):
        # g.pdb()

    result = []
    for s2 in g.splitLines(s):
        delim = None
        s3 = s2.strip()
        if not s3:
            result.append(s2)
        elif s3.startswith('#'):
            result.append(s2)
        elif s3.startswith('"""'):
            delim = '"""'
            break
        elif s3.startswith("'''"):
            delim = "'''"
            break
        else:
            break
       
    if not delim:
        comments = ''.join(result)
        if comments:
            nl = '\n\n' if root.b.strip() else ''
            if root.b.startswith('@first #!'):
                lines = g.splitLines(root.b)
                root.b = lines[0] + '\n' + comments + nl + ''.join(lines[1:])
            else:
                root.b = comments + nl + root.b
            p.b = s[len(comments):]
        return

    i = s.find(delim)
    assert i &gt; -1
    i = s.find(delim,i+3)
    if i == -1:
        return
        
    doc = s[:i+3]
    p.b = s[i+3:].lstrip()
    
    # Move docstring to front of root.b, but after any shebang line.
    nl = '\n\n' if root.b.strip() else ''
    if root.b.startswith('@first #!'):
        lines = g.splitLines(root.b)
        root.b = lines[0] + '\n' + doc + nl + ''.join(lines[1:])
    else:
        root.b = doc + nl + root.b
        
    # p.setDirty()
    # p.setMarked()
    # root.setDirty()
    # root.setMarked()
    # c.setChanged(True)

    # self.changed += 1
    # g.trace('%s --&gt; %s' % (p.h,root.h))
</t>
<t tx="ekr.20121011100948.4591">def move_shebang_line (self,c,root):
    
    '''Move a shebang line from the first child to the root.'''
    
    p = root.firstChild()
    s = p and p.b or ''
    if not s.startswith('#!'):
        return
        
    lines = g.splitLines(s)
    nl = '\n\n' if root.b.strip() else ''
    root.b = '@first ' + lines[0] + nl + root.b
    p.b = ''.join(lines[1:])
    # p.setDirty()
    # p.setMarked()
    # root.setDirty()
    # root.setMarked()
    # c.setChanged(True)

    # self.changed += 1
    # g.trace('%s --&gt; %s' % (p.h,root.h))
</t>
<t tx="ekr.20121011100948.4592">def rename_decls (self,c,root):
    
    '''Use a section reference for declarations.'''
    
    p = root.firstChild()
    h = p and p.h or ''
    
    tag = 'declarations'
    if not h.endswith(tag):
        return
        
    if not p.b.strip():
        return # The blank node will be deleted.

    name = h[:-len(tag)].strip()
    decls = g.angleBrackets(tag)
    p.h = '%s (%s)' % (decls,name)
    
    i = root.b.find('@others')
    if i == -1:
        g.trace('can not happen')
        return
    else:
        nl = '' if i == 0 else '\n'
        root.b = root.b[:i] + nl + decls + '\n' + root.b[i:]

    # p.setDirty()
    # root.setDirty()
    # root.setMarked()
    # c.setChanged(True)

    # self.changed += 1
    #g.trace('%s --&gt; %s' % (p.h,root.h))
</t>
<t tx="ekr.20121011100948.4593">def post_process (self,c,p,prefix,theTypes):
    
    '''Traverse p's tree, replacing all nodes that start with prefix
       by the smallest equivalent @path or @file node.
    '''

    assert p
    root = p.copy()
    self.fix_back_slashes(root.copy())
    prefix = prefix.replace('\\','/')
    
    # self.dump_headlines(root.copy())
    self.remove_empty_nodes(c,root.copy())
    self.minimize_headlines(c,root.copy().firstChild(),prefix,theTypes)
    self.clear_dirty_bits(c,root.copy())
    
    ## self.munge_at_file(c,root.copy().firstChild())
</t>
<t tx="ekr.20121011100948.4594">def clear_dirty_bits (self,c,p):
    
    c.setChanged(False)
    for p in p.self_and_subtree():
        p.clearDirty()
</t>
<t tx="ekr.20121011100948.4595">def dump_headlines (self,p):
    
    # show all headlines.
    for p in p.self_and_subtree():
        print(p.h)
</t>
<t tx="ekr.20121011100948.4596">def fix_back_slashes (self,p):
    
    '''Convert backslash to slash in all headlines.'''

    for p in p.self_and_subtree():
        s = p.h.replace('\\','/')
        if s != p.h:
            p.h = s
</t>
<t tx="ekr.20121011100948.4597">def minimize_headlines (self,c,p,prefix,theTypes):
    
    '''Create @path nodes to minimize the paths required in descendant nodes.'''

    trace = False
    
    # This could only happen during testing.
    if p.h.startswith('@'):
        g.trace('** skipping: %s' % (p.h))
        return
        
    h2 = p.h[len(prefix):].strip()
    
    ends_with_ext = any([h2.endswith(z) for z in theTypes])
    
    if p.h == prefix:
        if trace: g.trace('@path %s' % (p.h))
        p.h = '@path %s' % (p.h)
        for p in p.children():
            self.minimize_headlines(c,p,prefix,theTypes)
    elif h2.find('/') &lt;= 0 and ends_with_ext:
            if h2.startswith('/'): h2 = h2[1:]
            if safe_at_file:
                if trace: g.trace('@@file %s' % (h2))
                p.h = '@@file %s' % (h2)
            else:
                if trace: g.trace('@file %s' % (h2))
                p.h = '@file %s' % (h2)
            # We never scan the children of @file nodes.
    else:
        if h2.startswith('/'): h2 = h2[1:]
        if trace:
            print('')
            g.trace('@path [%s/]%s' % (prefix,h2))
        p.h = '@path %s' % (h2)
        prefix2 = prefix if prefix.endswith('/') else prefix + '/'
        prefix2 = prefix2 + h2
        for p in p.children():
            self.minimize_headlines(c,p,prefix2,theTypes)
</t>
<t tx="ekr.20121011100948.4598">def remove_empty_nodes (self,c,p):
    
    root = p.copy()
    
    # Restart the scan once a node is deleted.
    changed = True
    while changed:
        changed = False
        for p in root.self_and_subtree():
            if not p.b and not p.hasChildren():
                # g.trace('** deleting',p.h)
                p.doDelete()
                c.selectPosition(root)
                changed = True
                break
                
</t>
<t tx="ekr.20121011100948.4599"># def munge_at_file (self,c,p):
    
    # for p in p.self_and_subtree():
        # if p.h.startswith('@@file'):
            # p.h = p.h[1:]
            # s = p.b
            # i = s.find('@tabwidth -4\n')
            # if i &gt; 0:
                # i = g.skip_line(s,i)
                # p.b = s[:i] + '@others\n' + s[i:]
            # else:
                # g.trace('@tabwidth not found')
</t>
<t tx="ekr.20121011100948.4600">def run (self,c,p,theDir,theTypes):
    
    '''Import all the .py files in theDir.'''

    try:
        t1 = time.time()
        p1 = p.copy()
        g.app.disable_redraw = True
        bunch = c.undoer.beforeChangeTree(p1)
        assert p == c.p
        root = p.insertAfter()
        # root.h = '@path %s' % (theDir)
        root.h = 'imported files'
        prefix = theDir
        self.import_dir(c,root.copy(),theDir,theTypes)
        n = 0
        for p in root.self_and_subtree():
            n += 1
        self.clean_all(c,root.copy())
        self.post_process(c,root.copy(),theDir,theTypes)
        c.undoer.afterChangeTree(p1,'recursive-import',bunch)
    finally:
        g.app.disable_redraw = False
        root.contract()
        c.redraw(root)
    
    t2 = time.time()
    g.trace('imported %s nodes in %2.2f sec' % (n,t2-t1))
</t>
<t tx="ekr.20121011100948.4601">class ImportController():
    
    # There is no ctor.

    @others
</t>
<t tx="ekr.20121011195530.3405">import PyV8

s = '''\
var Greeter = (function () {
    function Greeter(message) {
        this.greeting = message;
    }
    Greeter.prototype.greet = function () {
        return "Hello, " + this.greeting;
    };
    return Greeter;
})();
var greeter = new Greeter("world");
if (false) {
    var button = document.createElement('button');
    button.innerText = "Say Hello";
    button.onclick = function () {
        alert(greeter.greet());
    };
    document.body.appendChild(button);
}
'''

if 1:
    cx = PyV8.JSContext()   # create a context with an implicit global object
    cx.enter()              # enter the context (also support with statement)
    # print(cx.eval("1+2"))
    print(cx.eval(s))
    
if 0:

    class Global(PyV8.JSClass):
        def hello(self):
            print "Hello World"    
    
    cx = PyV8.JSContext(Global())
    cx.enter()                    
    cx.eval("hello()")
</t>
</tnodes>
</leo_file>
