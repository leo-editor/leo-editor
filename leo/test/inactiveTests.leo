<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20190113114631.1"><vh>Older unused tests</vh>
<v t="ekr.20111113194727.3869"><vh>@@test BaseTextWrapper methods</vh></v>
<v t="ekr.20110615130436.3319"><vh>@@test writing a .leo file retains orphan bits</vh></v>
<v t="ekr.20150529183247.1"><vh>@@test ptb.comment_leo_lines &amp; ptb.uncomment_leo_lines</vh>
<v t="ekr.20150529183259.1"><vh>indented docstring</vh></v>
<v t="ekr.20150529184545.1"><vh>indented docstring2</vh></v>
</v>
<v t="ekr.20150214063940.11"><vh>@@shadow tests</vh>
<v t="ekr.20111210175541.3957"><vh>@@test at.readOneAtShadowNode retains @shadow links clones</vh>
<v t="ekr.20120228174052.3929"><vh>Node 1</vh></v>
</v>
<v t="ekr.20110610122533.3397"><vh>@@test goto-global-line @shadow</vh></v>
</v>
<v t="ekr.20130503061511.4137"><vh>from leoPy.leo</vh>
<v t="ekr.20130503061511.4140"><vh>@@test html string</vh>
<v t="ekr.20130503061511.4141"><vh>@@file c:/leo.repo/trunk/leo/core/html string</vh>
<v t="ekr.20130503061511.4150"><vh>html</vh>
<v t="ekr.20130503061511.4151"><vh>head</vh></v>
<v t="ekr.20130503061511.4152"><vh>body</vh></v>
</v>
</v>
<v t="ekr.20130503061511.4145"><vh>@@file c:/leo.repo/trunk/leo/core/html string</vh>
<v t="ekr.20130503061511.4150"></v>
</v>
<v t="ekr.20130503061511.4149"><vh>@@file c:/leo.repo/trunk/leo/core/html string</vh>
<v t="ekr.20130503061511.4150"></v>
</v>
</v>
<v t="ekr.20130503061511.4153"><vh>@@test HtmlScanner.filterTokens</vh></v>
<v t="ekr.20130503061511.4154"><vh>@@test import dataN.html</vh></v>
<v t="ekr.20130503061511.4155"><vh>@@test unicode stuff</vh></v>
<v t="ekr.20130503061511.4156"><vh>@@test external text operations</vh></v>
<v t="ekr.20130503061511.4157"><vh>@@test nullBody text operations</vh></v>
<v t="ekr.20130503061511.4158"><vh>@@test g.python_tokenize</vh></v>
</v>
<v t="ekr.20130503061820.4217"><vh>LeoInspect unit tests</vh>
<v t="ekr.20130503061820.4218"><vh>Basic tests</vh>
<v t="ekr.20130503061820.4219"><vh>@@test leoInspect with multiple files</vh>
<v t="ekr.20130503061820.4220"><vh>&lt;&lt; define old_s &gt;&gt;</vh></v>
<v t="ekr.20130503061820.4221"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
<v t="ekr.20130503061820.4222"><vh>test</vh></v>
</v>
<v t="ekr.20130503061820.4223"><vh>@@test leoInspect.module.classes</vh></v>
<v t="ekr.20130503061820.4224"><vh>@@test leoInspect.module.defs</vh></v>
<v t="ekr.20130503061820.4225"><vh>@@test leoInspect.module.classes 2</vh></v>
<v t="ekr.20130503061820.4226"><vh>@@test leoInspect.module.statements</vh></v>
<v t="ekr.20130503061820.4227"><vh>@@test leoInspect (leoEditCommands.py)</vh></v>
<v t="ekr.20130503061820.4228"><vh>@@test leoInspect.module (s)</vh>
<v t="ekr.20130503061820.4229"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20130503061820.4230"><vh>leoInspect speed tests</vh>
<v t="ekr.20130503061820.4231"><vh>@@test speed of leoInspect.module (all core files)</vh></v>
<v t="ekr.20130503061820.4232"><vh>@@test speed of AstTraverser (all Leo core files)</vh></v>
</v>
<v t="ekr.20130503061820.4233"><vh>@@test compute all ivars in all classes</vh></v>
<v t="ekr.20130503061820.4234"><vh>@@test find all ctors</vh></v>
<v t="ekr.20130503061820.4235"><vh>@@test pickling</vh></v>
<v t="ekr.20130503061820.4236"><vh>@@test cache contexts</vh></v>
<v t="ekr.20130503061820.4237"><vh>@@test AstFormatter</vh></v>
<v t="ekr.20130503061820.4238"><vh>@@test g_files_in_dir</vh></v>
<v t="ekr.20130503061820.4239"><vh>@@test print-chains</vh></v>
<v t="ekr.20130503061820.4240"><vh>@@test print-calls</vh></v>
<v t="ekr.20130503061820.4241"><vh>@@test print-returns</vh></v>
<v t="ekr.20130503061820.4242"><vh>@@test global names</vh></v>
<v t="ekr.20130503061820.4189"><vh>@@test leoInspect.token_range (s)</vh>
<v t="ekr.20130503061820.4190"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20131231093529.3984"><vh>leoViews.py</vh>
<v t="ekr.20140110141116.4267"><vh>@@test vc.create_tree_structure (rewrite)</vh>
<v t="ekr.20140110141116.4322"><vh>root_restore</vh>
<v t="ekr.20140110141116.4323"><vh>aClass</vh>
<v t="ekr.20140110141116.4324"><vh>before</vh></v>
<v t="ekr.20140110141116.4325"><vh>child11</vh></v>
<v t="ekr.20140110141116.4326"><vh>child12</vh></v>
<v t="ekr.20140110141116.4327"><vh>middle</vh></v>
<v t="ekr.20140110141116.4328"><vh>child21</vh></v>
<v t="ekr.20140110141116.4329"><vh>child22</vh></v>
<v t="ekr.20140110141116.4330"><vh>after</vh></v>
<v t="ekr.20140110141116.4331"><vh>last1</vh></v>
</v>
<v t="ekr.20140110141116.4332"><vh>top1</vh></v>
<v t="ekr.20140110141116.4333"><vh>top2</vh></v>
</v>
<v t="ekr.20140110141116.4351"><vh>root_before</vh>
<v t="ekr.20140110141116.4352"><vh>aClass</vh>
<v t="ekr.20140110141116.4353"><vh>before</vh></v>
<v t="ekr.20140110141116.4354"><vh>organizer node</vh>
<v t="ekr.20140110141116.4368"><vh>intermediate node</vh>
<v t="ekr.20140110141116.4355"><vh>inner org1</vh>
<v t="ekr.20140110141116.4356"><vh>child11</vh></v>
<v t="ekr.20140110141116.4357"><vh>child12</vh></v>
</v>
<v t="ekr.20140110141116.4358"><vh>middle</vh></v>
<v t="ekr.20140110141116.4359"><vh>inner org2</vh>
<v t="ekr.20140110141116.4360"><vh>child21</vh></v>
<v t="ekr.20140110141116.4361"><vh>child22</vh></v>
</v>
</v>
</v>
<v t="ekr.20140110141116.4362"><vh>after</vh></v>
<v t="ekr.20140110141116.4363"><vh>last organizer</vh>
<v t="ekr.20140110141116.4364"><vh>last1</vh></v>
</v>
</v>
<v t="ekr.20140110141116.4365"><vh>top-level</vh>
<v t="ekr.20140110141116.4366"><vh>top1</vh></v>
<v t="ekr.20140110141116.4367"><vh>top2</vh></v>
</v>
</v>
<v t="ekr.20140121160228.4834"><vh>root_after</vh>
<v t="ekr.20140121160228.4835"><vh>aClass</vh>
<v t="ekr.20140121160228.4836"><vh>before</vh></v>
<v t="ekr.20140121160228.4837"><vh>child11</vh></v>
<v t="ekr.20140121160228.4838"><vh>child12</vh></v>
<v t="ekr.20140121160228.4839"><vh>middle</vh></v>
<v t="ekr.20140121160228.4840"><vh>child21</vh></v>
<v t="ekr.20140121160228.4841"><vh>child22</vh></v>
<v t="ekr.20140121160228.4842"><vh>after</vh></v>
<v t="ekr.20140121160228.4843"><vh>last1</vh></v>
</v>
<v t="ekr.20140121160228.4844"><vh>top1</vh></v>
<v t="ekr.20140121160228.4845"><vh>top2</vh></v>
</v>
</v>
<v t="ekr.20140110044125.4362"><vh>@@test atFile.new_auto</vh></v>
<v t="ekr.20140109162112.4219"><vh>@@test p.sort_key</vh></v>
<v t="ekr.20140105222052.4170"><vh>@@test vc.clean_nodes (to do)</vh>
<v t="ekr.20140105222052.4171"><vh>root1</vh></v>
<v t="ekr.20140105222052.4172"><vh>root2</vh></v>
</v>
<v t="ekr.20140103102956.4142"><vh>@@test vc.create_clone_links</vh>
<v t="ekr.20140103102956.4143"><vh>@clones</vh></v>
<v t="ekr.20140211090146.4438"><vh>node1</vh></v>
<v t="ekr.20140103102956.4145"><vh>root</vh>
<v t="ekr.20140211090146.4438"></v>
</v>
</v>
<v t="ekr.20140105185509.4140"><vh>@@test vc.create_organizer_node</vh>
<v t="ekr.20140105190941.4170"><vh>root_restore</vh>
<v t="ekr.20140105190941.4171"><vh>aClass</vh>
<v t="ekr.20140105190941.4172"><vh>before</vh></v>
<v t="ekr.20140105190941.4174"><vh>child1</vh></v>
<v t="ekr.20140105190941.4175"><vh>extra2</vh></v>
<v t="ekr.20140105190941.4176"><vh>child2</vh></v>
<v t="ekr.20140105190941.4178"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20140105185509.4141"><vh>root_before</vh>
<v t="ekr.20140105185509.4142"><vh>aClass</vh>
<v t="ekr.20140105185509.4143"><vh>before</vh></v>
<v t="ekr.20140105185509.4144"><vh>organizer node</vh>
<v t="ekr.20140105185509.4145"><vh>child1</vh></v>
<v t="ekr.20140113034711.4461"><vh>extra2</vh></v>
<v t="ekr.20140105185509.4146"><vh>child2</vh></v>
</v>
<v t="ekr.20140105185509.4147"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20140211090146.4446"><vh>root_after</vh>
<v t="ekr.20140211090146.4447"><vh>aClass</vh>
<v t="ekr.20140211090146.4448"><vh>before</vh></v>
<v t="ekr.20140211090146.4459"><vh>organizer node</vh>
<v t="ekr.20140211090146.4460"><vh>child1</vh></v>
<v t="ekr.20140211090146.4461"><vh>extra2</vh></v>
<v t="ekr.20140211090146.4462"><vh>child2</vh></v>
</v>
<v t="ekr.20140211090146.4452"><vh>after</vh></v>
</v>
</v>
</v>
<v t="ekr.20140106094713.4176"><vh>@@test vc.drop_all_organizers_in_unl</vh></v>
<v t="ekr.20140103102956.4146"><vh>@@test vc.find_absolute_unl_node</vh></v>
<v t="ekr.20140103102956.4165"><vh>@@test vc.find_at_views_node</vh></v>
<v t="ekr.20140103102956.4147"><vh>@@test vc.find_position_for_relative_unl</vh>
<v t="ekr.20140103102956.4148"><vh>node1</vh>
<v t="ekr.20140103102956.4149"><vh>child11</vh></v>
<v t="ekr.20140103102956.4150"><vh>child12</vh></v>
</v>
<v t="ekr.20140103102956.4151"><vh>node2</vh>
<v t="ekr.20140103102956.4152"><vh>child21</vh></v>
<v t="ekr.20140103102956.4153"><vh>child22</vh></v>
</v>
</v>
<v t="ekr.20140103102956.4154"><vh>@@test vc.find_representative_node</vh>
<v t="ekr.20140103102956.4155"><vh>root</vh>
<v t="ekr.20140103102956.4157"><vh>clone</vh></v>
</v>
<v t="ekr.20140103102956.4157"></v>
</v>
<v t="ekr.20140103102956.4158"><vh>@@test vc.find_views/clones/organizers_node</vh>
<v t="ekr.20140103102956.4159"><vh>root</vh>
<v t="ekr.20140103102956.4160"><vh>aClass</vh>
<v t="ekr.20140103102956.4164"><vh>clone</vh></v>
</v>
<v t="ekr.20140103102956.4162"><vh>organizer node</vh>
<v t="ekr.20140103102956.4163"><vh>child2</vh></v>
</v>
</v>
<v t="ekr.20140103102956.4164"></v>
</v>
<v t="ekr.20140105185509.4198"><vh>@@test vc.has_*_node</vh>
<v t="ekr.20140105185509.4199"><vh>root</vh>
<v t="ekr.20140105185509.4200"><vh>aClass</vh>
<v t="ekr.20140105185509.4204"><vh>clone-test</vh></v>
<v t="ekr.20140105185509.4202"><vh>organizer node</vh>
<v t="ekr.20140105185509.4203"><vh>child2</vh></v>
</v>
</v>
</v>
<v t="ekr.20140105185509.4204"></v>
</v>
<v t="ekr.20140103102956.4166"><vh>@@test vc.is_at_auto_node</vh></v>
<v t="ekr.20140103102956.4167"><vh>@@test vc.is_organizer_node</vh>
<v t="ekr.20140103102956.4168"><vh>test python True</vh>
<v t="ekr.20140103102956.4169"><vh>child</vh></v>
</v>
<v t="ekr.20140103102956.4170"><vh>test python 2</vh>
<v t="ekr.20140103102956.4171"><vh>child</vh></v>
</v>
<v t="ekr.20140103102956.4172"><vh>test html True</vh>
<v t="ekr.20140103102956.4173"><vh>child</vh></v>
</v>
<v t="ekr.20140103102956.4174"><vh>test html 2</vh>
<v t="ekr.20140103102956.4175"><vh>child</vh></v>
</v>
</v>
<v t="ekr.20140103102956.4176"><vh>@@test vc.unl</vh></v>
<v t="ekr.20140105185509.4181"><vh>@@test vc.update_before_write_at_auto_file</vh>
<v t="ekr.20140105185509.4182"><vh>root</vh>
<v t="ekr.20140105185509.4183"><vh>aClass</vh>
<v t="ekr.20140105185509.4187"><vh>clone</vh></v>
</v>
<v t="ekr.20140105185509.4185"><vh>organizer node</vh>
<v t="ekr.20140105185509.4216"><vh>child1</vh></v>
<v t="ekr.20140105185509.4186"><vh>child2</vh></v>
</v>
</v>
<v t="ekr.20140105185509.4187"></v>
</v>
<v t="ekr.20140103102956.4184"><vh>@@test view-pack &amp; view_unpack</vh>
<v t="ekr.20140103102956.4188"><vh>clone</vh></v>
<v t="ekr.20140103102956.4186"><vh>@view test</vh>
<v t="ekr.20140103102956.4187"><vh>not a clone</vh></v>
<v t="ekr.20140103102956.4188"></v>
</v>
</v>
<v t="ekr.20140106135225.4203"><vh>@@test vc.create_organizer_node (nested organizers)</vh>
<v t="ekr.20140106135225.4204"><vh>root_restore</vh>
<v t="ekr.20140106135225.4285"><vh>aClass</vh>
<v t="ekr.20140106135225.4286"><vh>before</vh></v>
<v t="ekr.20140106135225.4289"><vh>child11</vh></v>
<v t="ekr.20140106135225.4290"><vh>child12</vh></v>
<v t="ekr.20140108143431.4248"><vh>middle</vh></v>
<v t="ekr.20140106135225.4292"><vh>child21</vh></v>
<v t="ekr.20140106135225.4293"><vh>child22</vh></v>
<v t="ekr.20140106135225.4294"><vh>after</vh></v>
<v t="ekr.20140109035139.4277"><vh>last1</vh></v>
</v>
<v t="ekr.20140109180433.4248"><vh>top1</vh></v>
<v t="ekr.20140109180433.4249"><vh>top2</vh></v>
</v>
<v t="ekr.20140106135225.4213"><vh>root_before</vh>
<v t="ekr.20140106135225.4214"><vh>aClass</vh>
<v t="ekr.20140106135225.4215"><vh>before</vh></v>
<v t="ekr.20140106135225.4216"><vh>organizer node</vh>
<v t="ekr.20140106135225.4229"><vh>inner org1</vh>
<v t="ekr.20140106135225.4217"><vh>child11</vh></v>
<v t="ekr.20140106135225.4218"><vh>child12</vh></v>
</v>
<v t="ekr.20140108143431.4249"><vh>middle</vh></v>
<v t="ekr.20140106135225.4233"><vh>inner org2</vh>
<v t="ekr.20140106135225.4234"><vh>child21</vh></v>
<v t="ekr.20140106135225.4235"><vh>child22</vh></v>
</v>
</v>
<v t="ekr.20140106135225.4219"><vh>after</vh></v>
<v t="ekr.20140109035139.4274"><vh>last organizer</vh>
<v t="ekr.20140109035139.4276"><vh>last1</vh></v>
</v>
</v>
<v t="ekr.20140109180433.4253"><vh>top-level</vh>
<v t="ekr.20140109180433.4254"><vh>top1</vh></v>
<v t="ekr.20140109180433.4255"><vh>top2</vh></v>
</v>
</v>
<v t="ekr.20140211090146.4494"><vh>root_after</vh>
<v t="ekr.20140211090146.4495"><vh>aClass</vh>
<v t="ekr.20140211090146.4496"><vh>before</vh></v>
<v t="ekr.20140211090146.4516"><vh>organizer node</vh>
<v t="ekr.20140211090146.4518"><vh>inner org1</vh>
<v t="ekr.20140211090146.4526"><vh>child11</vh></v>
<v t="ekr.20140211090146.4527"><vh>child12</vh></v>
</v>
<v t="ekr.20140211090146.4525"><vh>middle</vh></v>
<v t="ekr.20140211090146.4520"><vh>inner org2</vh>
<v t="ekr.20140211090146.4528"><vh>child21</vh></v>
<v t="ekr.20140211090146.4529"><vh>child22</vh></v>
</v>
</v>
<v t="ekr.20140211090146.4502"><vh>after</vh></v>
<v t="ekr.20140211090146.4522"><vh>last organizer</vh>
<v t="ekr.20140211090146.4530"><vh>last1</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20140111164124.4414"><vh>@@test vc.create_organizer_node (intermediate organizers)</vh>
<v t="ekr.20140111164124.4415"><vh>root_restore</vh>
<v t="ekr.20140111164124.4416"><vh>aClass</vh>
<v t="ekr.20140111164124.4417"><vh>before</vh></v>
<v t="ekr.20140111164124.4418"><vh>child11</vh></v>
<v t="ekr.20140111164124.4419"><vh>child12</vh></v>
<v t="ekr.20140111164124.4420"><vh>middle</vh></v>
<v t="ekr.20140111164124.4421"><vh>child21</vh></v>
<v t="ekr.20140111164124.4422"><vh>child22</vh></v>
<v t="ekr.20140111164124.4423"><vh>after</vh></v>
<v t="ekr.20140111164124.4424"><vh>last1</vh></v>
</v>
<v t="ekr.20140111164124.4425"><vh>top1</vh></v>
<v t="ekr.20140111164124.4426"><vh>top2</vh></v>
</v>
<v t="ekr.20140111164124.4427"><vh>root_before</vh>
<v t="ekr.20140111164124.4428"><vh>aClass</vh>
<v t="ekr.20140111164124.4429"><vh>before</vh></v>
<v t="ekr.20140111164124.4430"><vh>organizer node</vh>
<v t="ekr.20140111164124.4431"><vh>inner org1</vh>
<v t="ekr.20140111164124.4432"><vh>child11</vh></v>
<v t="ekr.20140111164124.4433"><vh>child12</vh></v>
</v>
<v t="ekr.20140111164124.4434"><vh>middle</vh></v>
<v t="ekr.20140111164124.4435"><vh>inner org2</vh>
<v t="ekr.20140111164124.4436"><vh>child21</vh></v>
<v t="ekr.20140111164124.4437"><vh>child22</vh></v>
</v>
</v>
<v t="ekr.20140111164124.4438"><vh>after</vh></v>
<v t="ekr.20140111164124.4439"><vh>last organizer</vh>
<v t="ekr.20140111164124.4440"><vh>last1</vh></v>
</v>
</v>
<v t="ekr.20140111164124.4441"><vh>top-level</vh>
<v t="ekr.20140111164124.4442"><vh>top1</vh></v>
<v t="ekr.20140111164124.4443"><vh>top2</vh></v>
</v>
</v>
<v t="ekr.20140211090146.4545"><vh>root_after</vh>
<v t="ekr.20140211090146.4546"><vh>aClass</vh>
<v t="ekr.20140211090146.4547"><vh>before</vh></v>
<v t="ekr.20140211090146.4567"><vh>organizer node</vh>
<v t="ekr.20140211090146.4569"><vh>inner org1</vh>
<v t="ekr.20140211090146.4577"><vh>child11</vh></v>
<v t="ekr.20140211090146.4578"><vh>child12</vh></v>
</v>
<v t="ekr.20140211090146.4576"><vh>middle</vh></v>
<v t="ekr.20140211090146.4571"><vh>inner org2</vh>
<v t="ekr.20140211090146.4579"><vh>child21</vh></v>
<v t="ekr.20140211090146.4580"><vh>child22</vh></v>
</v>
</v>
<v t="ekr.20140211090146.4553"><vh>after</vh></v>
<v t="ekr.20140211090146.4573"><vh>last organizer</vh>
<v t="ekr.20140211090146.4581"><vh>last1</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20131111160618.4261"><vh>leoVim</vh>
<v t="ekr.20131111162157.4276"><vh>Unused</vh>
<v t="ekr.20131111162157.4270"><vh>@@test command regex</vh></v>
<v t="ekr.20131111162157.4272"><vh>@@test motion regex</vh></v>
<v t="ekr.20131111162157.4271"><vh>@@test vim motion</vh></v>
</v>
<v t="ekr.20131111155107.4239"><vh>@@test h middle of line</vh>
<v t="ekr.20131111155107.4240"><vh>work</vh></v>
<v t="ekr.20131111155107.4241"><vh>before sel=1.5,1.5</vh></v>
<v t="ekr.20131111155107.4242"><vh>after sel=1.4,1.4</vh></v>
</v>
<v t="ekr.20131111162157.4275"><vh>@@test vr.exec_</vh></v>
<v t="ekr.20131113071911.4281"><vh>@@test vr.scan</vh>
<v t="ekr.20131113071911.4282"><vh>&lt;&lt; define test tables &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20080703104536.1"><vh>mini tests</vh>
<v t="ekr.20100203163606.5365"><vh>2to3 script</vh></v>
<v t="ekr.20100127162342.5123"><vh>Import all plugins script</vh></v>
<v t="ekr.20051104081502.99"><vh>Manual tests...</vh>
<v t="ekr.20051104081502.101"><vh>Other Reformat Paragraph tests</vh></v>
<v t="ekr.20051104081502.102"><vh>Test of @tabwidth</vh></v>
<v t="ekr.20051104081502.103"><vh>Test of pasting into big node</vh></v>
<v t="ekr.20051104081502.104"><vh>Test of Remove sentinels</vh></v>
<v t="ekr.20051104081502.105"><vh>Test new docutils stull</vh></v>
<v t="ekr.20040712101754.221"><vh>Manual test of TM.replaceOutline</vh>
<v t="ekr.20040712101754.222"><vh>outline1</vh>
<v t="ekr.20040712101754.223"><vh>a</vh></v>
</v>
<v t="ekr.20040712101754.224"><vh>outline2</vh>
<v t="ekr.20040712101754.225"><vh>b</vh></v>
</v>
</v>
</v>
<v t="ekr.20051104081502.220"><vh>Mini test arguments to hooks</vh>
<v t="ekr.20051104081502.221"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20051104081502.222"><vh>&lt;&lt; define hookData &gt;&gt;</vh></v>
<v t="ekr.20051104081502.223"><vh>&lt;&lt; define typeData &gt;&gt;</vh></v>
<v t="ekr.20051104081502.224"><vh>&lt;&lt; defineCheckHook &gt;&gt;</vh></v>
<v t="ekr.20051104081502.225"><vh>checkOneHook</vh></v>
</v>
<v t="ekr.20111121113227.4035"><vh>Mini test of add-editor</vh></v>
<v t="ekr.20051104081502.312"><vh>Mini test of g.es_exception</vh></v>
<v t="ekr.20051104081502.311"><vh>Mini test of g.pdb</vh></v>
<v t="ekr.20111108170253.3968"><vh>Mini test of unicode stuff</vh></v>
<v t="ekr.20111121081052.3909"><vh>Mini test that g.es leaves focus unchanged</vh></v>
<v t="ekr.20111121090700.3914"><vh>mini test that print-bindings puts results in Bindings tab</vh></v>
<v t="ekr.20051104081502.106"><vh>Mini tests of script buttons</vh>
<v t="ekr.20051104081502.107"><vh>Redundant: @suite run all doctests in @file nodes</vh></v>
<v t="ekr.20051104081502.108"><vh>runProfile button mini-test</vh></v>
<v t="ekr.20051104081502.109"><vh>runTimeit mini-test</vh></v>
<v t="ekr.20051104081502.110"><vh>profile redraws</vh></v>
</v>
<v t="ekr.20051104081502"><vh>Other tests</vh>
<v t="ekr.20051104081502.542"><vh>@@nosent test-niceNosent</vh>
<v t="ekr.20051104081502.543"><vh>part 1</vh></v>
<v t="ekr.20051104081502.544"><vh>part 2</vh></v>
<v t="ekr.20051104081502.545"><vh>part 3</vh></v>
</v>
<v t="ekr.20051104081502.320"><vh>@@nowrap tests</vh></v>
<v t="ekr.20051104081502.22"><vh>Experiments</vh>
<v t="ekr.20051104081502.23"><vh>Test of moving positions</vh></v>
<v t="ekr.20051104081502.24"><vh>Test of using an iterator inside a list comprehension</vh></v>
<v t="ekr.20051104081502.25"><vh>Test of using c.allNodes_iter to create a list of all positions</vh></v>
<v t="ekr.20051104081502.26"><vh>Creating a list of distinct vnodes</vh></v>
<v t="ekr.20051104081502.28"><vh>test of list comparisons</vh></v>
<v t="ekr.20051104081502.29"><vh>test that childIndex doesn't mess with p</vh></v>
<v t="ekr.20051104081502.30"><vh>Test of __cmp__ vrs equal</vh></v>
<v t="ekr.20051104081502.31"><vh>Test print</vh></v>
<v t="ekr.20051104081502.32"><vh>String-based imports...</vh>
<v t="ekr.20051104081502.33"><vh>import from string</vh>
<v t="ekr.20051104081502.34"><vh>@@test import from string</vh></v>
</v>
<v t="ekr.20051104081502.35"><vh>Subclass the file type for use with imp module</vh></v>
<v t="ekr.20051104081502.36"><vh>Use parser module to simulate import from string</vh>
<v t="ekr.20051104081502.37"><vh>test1</vh></v>
</v>
</v>
</v>
<v t="ekr.20051104081502.209"><vh>Make sure openWith changes are benign</vh></v>
<v t="ekr.20051104081502.111"><vh>Perfect import stuff...</vh>
<v t="ekr.20051104081502.112"><vh>Mulder Update script</vh>
<v t="ekr.20051104081502.113"><vh>sync</vh>
<v t="ekr.20051104081502.114"><vh>&lt;&lt; compute sourcetime and targettime &gt;&gt;</vh></v>
<v t="ekr.20051104081502.115"><vh>&lt;&lt; compute operation &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.116"><vh>Perfect Import Script</vh></v>
</v>
<v t="ekr.20051104081502.117"><vh>Printing tests...</vh>
<v t="ekr.20051104081502.118"><vh>Print findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20051104081502.119"><vh>Print iterations: do not delete</vh>
<v t="ekr.20051104081502.120"><vh>b</vh>
<v t="ekr.20051104081502.121"><vh>c</vh>
<v t="ekr.20051104081502.122"><vh>c2</vh>
<v t="ekr.20051104081502.123"><vh>c3</vh></v>
<v t="ekr.20051104081502.124"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20051104081502.125"><vh>Clone test data</vh>
<v t="ekr.20051104081502.126"><vh>aa</vh></v>
<v t="ekr.20051104081502.127"><vh>a</vh>
<v t="ekr.20051104081502.120"></v>
</v>
<v t="ekr.20051104081502.128"><vh>d</vh>
<v t="ekr.20051104081502.127"></v>
</v>
<v t="ekr.20051104081502.129"><vh>e</vh></v>
<v t="ekr.20051104081502.130"><vh>z</vh></v>
</v>
<v t="ekr.20051104081502.131"><vh>last node</vh></v>
</v>
<v t="ekr.20051104081502.145"><vh>Print isAnyAtFileNode</vh></v>
<v t="ekr.20051104081502.146"><vh>Print fundChildrenOf and</vh></v>
<v t="ekr.20051104081502.147"><vh>Tests of pickle &amp; hexlify</vh></v>
<v t="ekr.20051104081502.148"><vh>Test of undo registration</vh></v>
<v t="ekr.20051104081502.149"><vh>Test of unknownAttributes</vh></v>
<v t="ekr.20051104081502.150"><vh>Test of "end1" hook</vh></v>
<v t="ekr.20051104081502.151"><vh>Print timestamps of all nodes</vh></v>
<v t="ekr.20051104081502.152"><vh>test of focus</vh></v>
<v t="ekr.20051104081502.153"><vh>Using a generator instead of readLinesClass</vh></v>
<v t="ekr.20051104081502.154"><vh>Test of better error messages in Execute Script command</vh>
<v t="ekr.20051104081502.155"><vh>Contains error</vh></v>
</v>
<v t="ekr.20051104081502.157"><vh>print all docstrings from a module</vh>
<v t="ekr.20051104081502.158"><vh>&lt;&lt; print names sorted by type &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.216"><vh>Registering &amp; unregistering the "new" drawing hooks</vh>
<v t="ekr.20051104081502.217"><vh>Register all new hooks</vh></v>
<v t="ekr.20051104081502.218"><vh>Unregister all new hooks</vh></v>
<v t="ekr.20051104081502.219"><vh>Print all new hooks</vh></v>
</v>
<v t="ekr.20051104081502.538"><vh>ReportLab sample scripts</vh>
<v t="ekr.20051104081502.539"><vh>text</vh></v>
<v t="ekr.20051104081502.540"><vh>pencil</vh></v>
<v t="ekr.20051104081502.541"><vh>penciltip</vh></v>
</v>
<v t="ekr.20051104081502.272"><vh>Standalone imports</vh>
<v t="ekr.20051104081502.273"><vh>test that of standalone imports of leo files</vh></v>
<v t="ekr.20051104081502.274"><vh>Script to run in Idle</vh></v>
</v>
<v t="ekr.20051104081502.307"><vh>test local settings (c.redirect_execute_script_output_to_log_pane)</vh></v>
<v t="ekr.20051104081502.164"><vh>test of 4.3 str_ attributes</vh>
<v t="ekr.20051104081502.165"><vh>set</vh></v>
<v t="ekr.20051104081502.166"><vh>get</vh></v>
</v>
<v t="ekr.20051104081502.316"><vh>test of an exception in another module</vh></v>
<v t="ekr.20051104081502.210"><vh>Test of autocompleter</vh></v>
<v t="ekr.20051104081502.322"><vh>Test of g.getScript with forcePythonSentinels = False</vh>
<v t="ekr.20051104081502.323"><vh>g.getScript</vh></v>
<v t="ekr.20051104081502.324"><vh>html stuff</vh>
<v t="ekr.20051104081502.325"><vh>body</vh></v>
</v>
</v>
<v t="ekr.20051104081502.315"><vh>test of NameError traceback</vh></v>
<v t="ekr.20051104081502.318"><vh>Test of os.spawnv calls to c.openWith</vh></v>
<v t="ekr.20051104081502.321"><vh>Test of redirected scipt with error</vh></v>
<v t="ekr.20051104081502.183"><vh>Test of reportBadChars</vh></v>
<v t="ekr.20051104081502.234"><vh>test of tab_width &amp; tab_width ivars</vh></v>
<v t="ekr.20051104081502.211"><vh>Test of template plugin</vh>
<v t="ekr.20051104081502.213"><vh>A node that uses the template</vh></v>
</v>
<v t="ekr.20051104081502.214"><vh>test of using changes to Go To Line number to handle scripts</vh>
<v t="ekr.20051104081502.215"><vh>node that throws exception</vh></v>
</v>
<v t="ekr.20051104081502.547"><vh>Test of warnings of conflicting shortcuts</vh></v>
<v t="ekr.20051104081502.551"><vh>test k.registerCommand</vh></v>
<v t="ekr.20051104081502.226"><vh>Tests of leoGlobals</vh>
<v t="ekr.20051104081502.227"><vh>@@test g.rawPrint</vh></v>
<v t="ekr.20051104081502.232"><vh>test of g.pdb</vh></v>
<v t="ekr.20051104081502.233"><vh>Test of g.app.debugSwitch</vh></v>
</v>
<v t="ekr.20051104081502.326"><vh>Tests of rst3 plugin</vh>
<v t="ekr.20051104081502.327"><vh>@@rst ../doc/ListManagerDocs.html</vh>
<v t="ekr.20051104081502.328"><vh>wxListManager.py</vh>
<v t="ekr.20051104081502.329"><vh>Initial stuff</vh>
<v t="ekr.20051104081502.330"><vh>Module Imports</vh>
<v t="ekr.20051104081502.331"><vh>@@rst-no-head About imports</vh></v>
</v>
<v t="ekr.20051104081502.332"><vh>Constants</vh></v>
<v t="ekr.20051104081502.333"><vh>Menu IDs</vh></v>
<v t="ekr.20051104081502.334"><vh>Read Config File</vh>
<v t="ekr.20051104081502.335"><vh>@@rst-no-head About configuration files</vh></v>
</v>
</v>
<v t="ekr.20051104081502.336"><vh>class ListManager</vh>
<v t="ekr.20051104081502.337"><vh>Instantiation</vh>
<v t="ekr.20051104081502.338"><vh>def __init__</vh>
<v t="ekr.20051104081502.339"><vh>@@rst-no-head About the ctor</vh></v>
<v t="ekr.20051104081502.340"><vh>&lt;&lt; List Manager Attributes &gt;&gt;</vh>
<v t="ekr.20051104081502.341"><vh>@@rst</vh></v>
</v>
<v t="ekr.20051104081502.342"><vh>&lt;&lt; Menu Setup &gt;&gt;</vh>
<v t="ekr.20051104081502.343"><vh>@@rst</vh></v>
</v>
<v t="ekr.20051104081502.344"><vh>&lt;&lt; Toolbar Setup &gt;&gt;</vh></v>
<v t="ekr.20051104081502.346"><vh>&lt;&lt; Menu/Toolbar Events &gt;&gt;</vh></v>
<v t="ekr.20051104081502.348"><vh>&lt;&lt; Create Controls&gt;&gt;</vh></v>
<v t="ekr.20051104081502.350"><vh>&lt;&lt; Other Events &gt;&gt;</vh></v>
<v t="ekr.20051104081502.352"><vh>&lt;&lt; Layout Stuff &gt;&gt;</vh></v>
<v t="ekr.20051104081502.354"><vh>&lt;&lt; GUI Instance Objects &gt;&gt;</vh></v>
<v t="ekr.20051104081502.356"><vh>&lt;&lt; Create Socket &gt;&gt;</vh></v>
<v t="ekr.20051104081502.358"><vh>&lt;&lt; Load Recent Files &gt;&gt;</vh></v>
<v t="ekr.20051104081502.360"><vh>&lt;&lt; Idle Timer &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.362"><vh>Ownerlist creation methods (used by thread)</vh>
<v t="ekr.20051104081502.364"><vh>def createownerlist</vh></v>
<v t="ekr.20051104081502.366"><vh>def createownerdialog</vh></v>
</v>
<v t="ekr.20051104081502.368"><vh>Notebook methods</vh>
<v t="ekr.20051104081502.370"><vh>def CreateNewNotebookPage</vh>
<v t="ekr.20051104081502.372"><vh>&lt;&lt; Fill OwnerListBox &gt;&gt;</vh></v>
<v t="ekr.20051104081502.374"><vh>&lt;&lt; ListControl Events &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.376"><vh>def OnPageChange</vh>
<v t="ekr.20051104081502.378"><vh>&lt;&lt; Find Highlighted Row &gt;&gt;</vh></v>
<v t="ekr.20051104081502.380"><vh>&lt;&lt; Update Title &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.382"><vh>Tickler methods</vh>
<v t="ekr.20051104081502.383"><vh>def OnShowTickler</vh></v>
<v t="ekr.20051104081502.384"><vh>def OnActivateTickler</vh></v>
</v>
<v t="ekr.20051104081502.385"><vh>Email methods</vh>
<v t="ekr.20051104081502.386"><vh>OnMailItem</vh></v>
<v t="ekr.20051104081502.387"><vh>OnMailView</vh></v>
</v>
<v t="ekr.20051104081502.388"><vh>Cut/Copy/Paste methods</vh>
<v t="ekr.20051104081502.389"><vh>OnCopyItems</vh>
<v t="ekr.20051104081502.390"><vh>&lt;&lt; Find Highlighted Items &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.391"><vh>OnPasteItems</vh></v>
<v t="ekr.20051104081502.392"><vh>OnDeleteItems</vh></v>
</v>
<v t="ekr.20051104081502.393"><vh>MouseDown methods</vh>
<v t="ekr.20051104081502.394"><vh>OnLeftDown (Action depends on x coordinate)</vh></v>
<v t="ekr.20051104081502.395"><vh>OnRightDown (Display popup sendto menu)</vh></v>
</v>
<v t="ekr.20051104081502.396"><vh>Move/Combine items methods</vh>
<v t="ekr.20051104081502.397"><vh>OnCombineItems</vh></v>
<v t="ekr.20051104081502.398"><vh>OnMoveToList</vh></v>
<v t="ekr.20051104081502.399"><vh>OnMoveToSpecificList</vh></v>
</v>
<v t="ekr.20051104081502.400"><vh>Change/update items methods</vh>
<v t="ekr.20051104081502.401"><vh>OnToggleFinished</vh>
<v t="ekr.20051104081502.402"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.403"><vh>OnPriority</vh>
<v t="ekr.20051104081502.404"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.405"><vh>Inplace Edit Methods</vh>
<v t="ekr.20051104081502.406"><vh>OnDisplayInPlaceEditor</vh></v>
<v t="ekr.20051104081502.407"><vh>OnCloseInPlaceEditor</vh></v>
</v>
<v t="ekr.20051104081502.408"><vh>OnDueDate</vh></v>
<v t="ekr.20051104081502.409"><vh>OnEditOwner</vh>
<v t="ekr.20051104081502.410"><vh>&lt;&lt; Common Owner Code &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.411"><vh>OnUpdate</vh>
<v t="ekr.20051104081502.412"><vh>&lt;&lt; Common Owner Code &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.413"><vh>OnNewItem</vh>
<v t="ekr.20051104081502.414"><vh>&lt;&lt; Clear data fields &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.415"><vh>Conflict (not in use)</vh></v>
<v t="ekr.20051104081502.416"><vh>OnEditNote</vh></v>
</v>
<v t="ekr.20051104081502.417"><vh>File menu methods</vh>
<v t="ekr.20051104081502.418"><vh>OnNewList</vh></v>
<v t="ekr.20051104081502.419"><vh>OnFileList</vh></v>
<v t="ekr.20051104081502.420"><vh>OnOpenList</vh></v>
<v t="ekr.20051104081502.421"><vh>OnDeleteList</vh></v>
<v t="ekr.20051104081502.422"><vh>OnCloseList</vh></v>
<v t="ekr.20051104081502.423"><vh>OnCloseAll</vh></v>
<v t="ekr.20051104081502.424"><vh>OnSaveAsText</vh></v>
<v t="ekr.20051104081502.425"><vh>OnArchive</vh></v>
<v t="ekr.20051104081502.426"><vh>OnWorkOffline</vh></v>
</v>
<v t="ekr.20051104081502.428"><vh>Display methods</vh>
<v t="ekr.20051104081502.429"><vh>OnItemSelected</vh></v>
<v t="ekr.20051104081502.430"><vh>OnItemActivated</vh></v>
<v t="ekr.20051104081502.431"><vh>OnShowAll</vh></v>
<v t="ekr.20051104081502.432"><vh>OnRefresh</vh></v>
<v t="ekr.20051104081502.433"><vh>OnFilterOwners</vh></v>
<v t="ekr.20051104081502.434"><vh>OnColumnClick (to sort columns)</vh></v>
<v t="ekr.20051104081502.435"><vh>OnShowFinished</vh></v>
<v t="ekr.20051104081502.436"><vh>OnColumnRightClick (popup to change date displayed)</vh></v>
<v t="ekr.20051104081502.437"><vh>OnDisplayDateCategory</vh></v>
<v t="ekr.20051104081502.438"><vh>ChangeDateDisplayed</vh></v>
<v t="ekr.20051104081502.439"><vh>DisplayList</vh>
<v t="ekr.20051104081502.440"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.441"><vh>Printing methods</vh>
<v t="ekr.20051104081502.442"><vh>OnPageSetup</vh></v>
<v t="ekr.20051104081502.443"><vh>OnPrint</vh></v>
</v>
<v t="ekr.20051104081502.444"><vh>Exiting methods</vh>
<v t="ekr.20051104081502.445"><vh>OnWindowExit</vh></v>
<v t="ekr.20051104081502.446"><vh>OnExit</vh>
<v t="ekr.20051104081502.447"><vh>&lt;&lt;save configuration file&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.448"><vh>Find methods</vh>
<v t="ekr.20051104081502.449"><vh>OnFind</vh></v>
<v t="ekr.20051104081502.450"><vh>FindString</vh></v>
<v t="ekr.20051104081502.451"><vh>FindNode</vh></v>
</v>
<v t="ekr.20051104081502.452"><vh>Database-related methods</vh>
<v t="ekr.20051104081502.453"><vh>GetCursor</vh></v>
<v t="ekr.20051104081502.454"><vh>GetNote</vh></v>
<v t="ekr.20051104081502.455"><vh>CreateTable</vh></v>
<v t="ekr.20051104081502.456"><vh>ReadFromDB (returns db results)</vh></v>
<v t="ekr.20051104081502.457"><vh>CreateAndDisplayList (returns Item List)</vh>
<v t="ekr.20051104081502.458"><vh>&lt;&lt; assign item attributes &gt;&gt;</vh></v>
<v t="ekr.20051104081502.459"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104081502.460"><vh>OnSync</vh></v>
<v t="ekr.20051104081502.461"><vh>TimeStamper</vh></v>
</v>
<v t="ekr.20051104081502.462"><vh>Evaluate methods</vh>
<v t="ekr.20051104081502.463"><vh>OnShowEvaluate</vh></v>
<v t="ekr.20051104081502.464"><vh>OnEvaluate</vh></v>
</v>
<v t="ekr.20051104081502.465"><vh>Help menu methods</vh>
<v t="ekr.20051104081502.466"><vh>OnShowAbout</vh></v>
<v t="ekr.20051104081502.467"><vh>OnShowHelp</vh></v>
</v>
<v t="ekr.20051104081502.468"><vh>GetUID</vh></v>
<v t="ekr.20051104081502.469"><vh>OnIdle</vh>
<v t="ekr.20051104081502.471"><vh>&lt;&lt; Check for Transfers From Outlook &gt;&gt;</vh></v>
<v t="ekr.20051104081502.473"><vh>&lt;&lt; Check if Edited File has Changed &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104081502.475"><vh>class ListCtrl</vh>
<v t="ekr.20051104081502.476"><vh>__init__</vh></v>
<v t="ekr.20051104081502.477"><vh>SetUpColumns</vh></v>
<v t="ekr.20051104081502.478"><vh>OnColBeginDrag</vh></v>
</v>
<v t="ekr.20051104081502.479"><vh>class MyApp</vh>
<v t="ekr.20051104081502.480"><vh>OnInit</vh></v>
</v>
<v t="ekr.20051104081502.481"><vh>class Logger</vh></v>
<v t="ekr.20051104081502.482"><vh>run</vh></v>
</v>
<v t="ekr.20051104081502.483"><vh>LMDialogs.py</vh>
<v t="ekr.20051104081502.484"><vh>class PopDialog</vh>
<v t="ekr.20051104081502.485"><vh>__init__</vh></v>
<v t="ekr.20051104081502.486"><vh>OnLeftDown</vh></v>
<v t="ekr.20051104081502.487"><vh>OnForward</vh></v>
<v t="ekr.20051104081502.488"><vh>OnMail</vh></v>
</v>
<v t="ekr.20051104081502.489"><vh>class StartupDialog</vh>
<v t="ekr.20051104081502.490"><vh>__init__</vh></v>
<v t="ekr.20051104081502.491"><vh>OnSelection</vh></v>
</v>
<v t="ekr.20051104081502.492"><vh>class ModifierDialog</vh>
<v t="ekr.20051104081502.493"><vh>__init__</vh></v>
<v t="ekr.20051104081502.494"><vh>GetUserInput</vh></v>
<v t="ekr.20051104081502.495"><vh>SelectCurrent</vh></v>
<v t="ekr.20051104081502.496"><vh>ClearSelections</vh></v>
</v>
<v t="ekr.20051104081502.497"><vh>class MailDialog</vh>
<v t="ekr.20051104081502.498"><vh>__init__</vh></v>
</v>
<v t="ekr.20051104081502.499"><vh>class CalendarDialog</vh>
<v t="ekr.20051104081502.500"><vh>__init__</vh></v>
<v t="ekr.20051104081502.501"><vh>OnCalSelected</vh></v>
<v t="ekr.20051104081502.502"><vh>OnChangeMonth</vh></v>
<v t="ekr.20051104081502.503"><vh>OnCloseWindow</vh></v>
<v t="ekr.20051104081502.504"><vh>GetDate</vh></v>
</v>
<v t="ekr.20051104081502.505"><vh>class FindDialog</vh>
<v t="ekr.20051104081502.506"><vh>__init__</vh></v>
</v>
<v t="ekr.20051104081502.507"><vh>class EvalDialog</vh>
<v t="ekr.20051104081502.508"><vh>__init__</vh></v>
<v t="ekr.20051104081502.509"><vh>PostOKEvent</vh></v>
</v>
<v t="ekr.20051104081502.510"><vh>class LoggerDialog</vh>
<v t="ekr.20051104081502.511"><vh>__init__</vh></v>
<v t="ekr.20051104081502.512"><vh>OnSave</vh></v>
</v>
<v t="ekr.20051104081502.513"><vh>class FinishedDialog</vh>
<v t="ekr.20051104081502.514"><vh>__init__</vh></v>
<v t="ekr.20051104081502.515"><vh>OnSpin</vh></v>
<v t="ekr.20051104081502.516"><vh>OnCheck</vh></v>
</v>
<v t="ekr.20051104081502.517"><vh>class TreeDialog</vh>
<v t="ekr.20051104081502.518"><vh>__init__</vh></v>
<v t="ekr.20051104081502.519"><vh>OnLeftDClick:</vh></v>
</v>
</v>
<v t="ekr.20051104081502.520"><vh>outlookAddin.py</vh>
<v t="ekr.20051104081502.521"><vh>&lt;&lt; outlookAddin declarations &gt;&gt;</vh></v>
<v t="ekr.20051104081502.522"><vh>class ButtonEvent</vh>
<v t="ekr.20051104081502.523"><vh>OnClick</vh></v>
</v>
<v t="ekr.20051104081502.524"><vh>class FolderEvent</vh>
<v t="ekr.20051104081502.525"><vh>OnItemAdd</vh></v>
</v>
<v t="ekr.20051104081502.526"><vh>class OutlookAddin</vh>
<v t="ekr.20051104081502.527"><vh>&lt;&lt; class OutlookAddin declarations &gt;&gt;</vh></v>
<v t="ekr.20051104081502.528"><vh>OnConnection</vh></v>
<v t="ekr.20051104081502.529"><vh>OnDisconnection</vh></v>
<v t="ekr.20051104081502.530"><vh>OnAddInsUpdate</vh></v>
<v t="ekr.20051104081502.531"><vh>OnStartupComplete</vh></v>
<v t="ekr.20051104081502.532"><vh>OnBeginShutdown</vh></v>
</v>
<v t="ekr.20051104081502.533"><vh>RegisterAddin</vh></v>
<v t="ekr.20051104081502.534"><vh>UnregisterAddin</vh></v>
</v>
</v>
<v t="ekr.20051104081502.535"><vh>@@rst ../doc/pdfTest.pdf</vh>
<v t="ekr.20051104081502.536"><vh>child node</vh>
<v t="ekr.20051104081502.537"><vh>@@rst</vh></v>
</v>
</v>
</v>
<v t="ekr.20051104081502.546"><vh>Tests of settings when opened from another .leo file</vh></v>
<v t="ekr.20051104081502.159"><vh>Tk bindtags test</vh></v>
<v t="ekr.20051104081502.305"><vh>Unicode stuff</vh></v>
<v t="ekr.20051104081502.549"><vh>Write to log tab</vh></v>
<v t="ekr.20051104081502.548"><vh>Write to test tab</vh></v>
</v>
<v t="ekr.20100125180231.5120"><vh>Print a unicode character</vh></v>
<v t="ekr.20051104081502.108"></v>
<v t="ekr.20051104081502.109"></v>
<v t="ekr.20080821123427.2"><vh>Standard print test</vh></v>
<v t="ekr.20051104081502.160"><vh>User Icon tests</vh>
<v t="ekr.20051104081502.161"><vh>Delete user icons</vh></v>
<v t="ekr.20051104081502.162"><vh>Test of user icons</vh>
<v t="ekr.20051104081502.163"><vh>&lt;&lt; define event callbacks &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20140906072925.5224"><vh>Scintilla fails</vh>
<v t="ekr.20100223123103.5382"><vh>@@test expand/contract-pane</vh></v>
<v t="ekr.20111112171235.3854"><vh>@@test add/delete html comments</vh>
<v t="ekr.20111112171235.3855"><vh>html</vh></v>
</v>
<v t="ekr.20111112171235.3858"><vh>@@test add/delete python comments</vh>
<v t="ekr.20111112171235.3859"><vh>python</vh></v>
</v>
<v t="ekr.20061101121602.126"><vh>@@test backward-kill-paragraph</vh>
<v t="ekr.20061101121602.127"><vh>work</vh></v>
<v t="ekr.20061101121602.128"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.129"><vh>after sel=7.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.154"><vh>@@test center-region</vh>
<v t="ekr.20061101121602.155"><vh>work</vh></v>
<v t="ekr.20061101121602.156"><vh>before sel=1.0,7.0</vh></v>
<v t="ekr.20061101121602.157"><vh>after sel=1.0,7.0</vh></v>
</v>
<v t="ekr.20061101121602.174"><vh>@@test downcase-region</vh>
<v t="ekr.20061101121602.175"><vh>work</vh></v>
<v t="ekr.20061101121602.176"><vh>before sel=3.0,4.0</vh></v>
<v t="ekr.20061101121602.177"><vh>after sel=3.0,4.0</vh></v>
</v>
<v t="ekr.20061101121602.282"><vh>@@test kill-paragraph</vh>
<v t="ekr.20061101121602.283"><vh>work</vh></v>
<v t="ekr.20061101121602.285"><vh>before sel=9.0,9.0</vh></v>
<v t="ekr.20061101121602.284"><vh>after sel=8.0,8.0</vh></v>
</v>
<v t="ekr.20071113145804.4"><vh>@@test selfInsertCommand-1</vh></v>
<v t="ekr.20061101121602.350"><vh>@@test upcase-region</vh>
<v t="ekr.20061101121602.351"><vh>work</vh></v>
<v t="ekr.20061101121602.352"><vh>before sel=3.0,4.0</vh></v>
<v t="ekr.20061101121602.353"><vh>after sel=3.0,4.0</vh></v>
</v>
<v t="ekr.20110118082508.3766"><vh>@@test reformat-paragraph paragraph 1 of 3</vh>
<v t="ekr.20110118082508.3772"><vh>work</vh></v>
<v t="ekr.20110118082508.3773"><vh>before sel=1.0,1.0</vh></v>
<v t="ekr.20110118082508.3792"><vh>after sel=11.14,11.14</vh></v>
</v>
<v t="ekr.20110118082508.3779"><vh>@@test reformat-paragraph paragraph 2 of 3</vh>
<v t="ekr.20110118082508.3780"><vh>work</vh></v>
<v t="ekr.20110118082508.3781"><vh>before sel=13.0,13.0</vh></v>
<v t="ekr.20110118082508.3782"><vh>after sel=23.33,23.33</vh></v>
</v>
<v t="ekr.20110118082508.3787"><vh>@@test reformat-paragraph paragraph 3 of 3</vh>
<v t="ekr.20110118082508.3788"><vh>work</vh></v>
<v t="ekr.20110118082508.3789"><vh>before sel=25.10,25.10</vh></v>
<v t="ekr.20110118082508.3790"><vh>after sel=32.11,32.11</vh></v>
</v>
<v t="ekr.20100204165850.5373"><vh>@@test most toggle commands</vh></v>
<v t="ekr.20040712101754.37"><vh>@@suite Edit body tests</vh>
<v t="ekr.20040712101754.38"><vh>editBodyTests</vh>
<v t="ekr.20060127120604"><vh>tempNode</vh></v>
<v t="ekr.20050417202713"><vh>addComments</vh>
<v t="ekr.20050417202713.1"><vh>before</vh></v>
<v t="ekr.20050417202713.2"><vh>after</vh></v>
<v t="ekr.20050417202713.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417204940"><vh>convertAllBlanks</vh>
<v t="ekr.20050417204940.1"><vh>before</vh></v>
<v t="ekr.20050417204940.2"><vh>after</vh></v>
<v t="ekr.20050417204940.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417205012"><vh>convertAllTabs</vh>
<v t="ekr.20050417205012.1"><vh>before</vh></v>
<v t="ekr.20050417205012.2"><vh>after</vh></v>
<v t="ekr.20050417205012.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417203114"><vh>convertBlanks</vh>
<v t="ekr.20050417203310"><vh>before</vh></v>
<v t="ekr.20050417203310.1"><vh>after</vh></v>
<v t="ekr.20050417203336"><vh>selection</vh></v>
</v>
<v t="ekr.20050417203114.1"><vh>convertTabs</vh>
<v t="ekr.20050417204834"><vh>before</vh></v>
<v t="ekr.20050417204830"><vh>after</vh></v>
<v t="ekr.20050417204901"><vh>selection</vh></v>
</v>
<v t="ekr.20040712101754.49"><vh>dedentBody</vh>
<v t="ekr.20040712101754.50"><vh>before</vh></v>
<v t="ekr.20040712101754.51"><vh>after</vh></v>
<v t="ekr.20040712101754.52"><vh>selection</vh></v>
</v>
<v t="ekr.20050417202817"><vh>deleteComments</vh>
<v t="ekr.20050417202817.1"><vh>before</vh></v>
<v t="ekr.20050417202817.2"><vh>after</vh></v>
<v t="ekr.20050417202817.3"><vh>selection</vh></v>
</v>
<v t="ekr.20111112211307.3910"><vh>deleteComments</vh>
<v t="ekr.20111112211307.3911"><vh>before</vh></v>
<v t="ekr.20111112211307.3912"><vh>after</vh></v>
<v t="ekr.20111112211307.3913"><vh>selection</vh></v>
</v>
<v t="ekr.20050417201845"><vh>extract test1</vh>
<v t="ekr.20050417201845.1"><vh>before</vh></v>
<v t="ekr.20050417201845.2"><vh>after</vh>
<v t="ekr.20050417201845.3"><vh>&lt;&lt; section &gt;&gt; @nonl</vh></v>
</v>
<v t="ekr.20050417201845.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050518070540"><vh>extract test2</vh>
<v t="ekr.20050518070540.1"><vh>before</vh></v>
<v t="ekr.20050518070545"><vh>after</vh></v>
<v t="ekr.20050518070540.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050518070927"><vh>extractSection test1</vh>
<v t="ekr.20050518070927.1"><vh>before</vh></v>
<v t="ekr.20050518070927.2"><vh>after</vh>
<v t="ekr.20050518070927.3"><vh>&lt;&lt; section &gt;&gt; @nonl</vh></v>
</v>
<v t="ekr.20050518070927.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050518071251"><vh>extractSection test2</vh>
<v t="ekr.20050518071251.1"><vh>before</vh></v>
<v t="ekr.20050518071258"><vh>after</vh></v>
<v t="ekr.20050518071251.4"><vh>selection</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20130503061511.4175"><vh>Unit tests for settings</vh>
<v t="ekr.20130503061511.4176"><vh>print dicts unit tests</vh>
<v t="ekr.20130503061511.4177"><vh>@@test printMenusList</vh></v>
<v t="ekr.20130503061511.4178"><vh>@@test printInverseBindingDict</vh></v>
<v t="ekr.20130503061511.4179"><vh>@@test printBindingsDict</vh></v>
<v t="ekr.20130503061511.4180"><vh>@@test printMasterBindingsDict</vh></v>
</v>
<v t="ekr.20130503061511.4181"><vh>passed</vh>
<v t="ekr.20130503061511.4182"><vh>@@test mode-related info</vh></v>
<v t="ekr.20130503061511.4183"><vh>@@test types of contents of settings dicts</vh>
<v t="ekr.20130503061511.4184"><vh>test_dict_of_dicts</vh></v>
<v t="ekr.20130503061511.4185"><vh>test_dict_of_lists</vh></v>
<v t="ekr.20130503061511.4186"><vh>test_dict_of_objects</vh></v>
<v t="ekr.20130503061511.4187"><vh>Unused</vh></v>
</v>
<v t="ekr.20130503061511.4188"><vh>@@test merge_settings_dicts</vh>
<v t="ekr.20130503061511.4189"><vh>dump &amp; dump_dict (@test merge_settings_dicts)</vh></v>
<v t="ekr.20130503061511.4190"><vh>test (@test merge_settings_dicts)</vh></v>
</v>
<v t="ekr.20130503061511.4191"><vh>@@test KeyStroke</vh></v>
<v t="ekr.20130503061511.4192"><vh>@@test g.TypedDict</vh></v>
</v>
</v>
<v t="ekr.20111107113442.3849"><vh>unused tests</vh>
<v t="ekr.20111112193817.3908"><vh>@@test delete-body-editor 3 times</vh></v>
<v t="ekr.20100225094004.5405"><vh>@@test loading .leo file with @file nodes</vh></v>
<v t="ekr.20061104172236.23"><vh>@@test tkBody.onClick</vh></v>
<v t="ekr.20051107115231.25"><vh>@@test typing in headline recomputes width</vh></v>
<v t="ekr.20061008162912"><vh>@@test write .leo file with @ignore node</vh>
<v t="ekr.20061008162912.1"><vh>child</vh></v>
</v>
<v t="ekr.20101021205258.6013"><vh>general file stuff</vh>
<v t="ekr.20100204153116.5369"><vh>@@test raw file copy</vh></v>
<v t="ekr.20080806211453.5"><vh>@@test round-trip-uAs for @shadow</vh>
<v t="ekr.20080806211453.1"><vh>@@shadow uA_test_shadow_file.py</vh>
<v t="ekr.20080822160527.1"><vh>uA_test_shadow_file declarations</vh></v>
</v>
</v>
<v t="ekr.20080806095923.2"><vh>@@test round-trip-uAs for @thin</vh>
<v t="ekr.20080806084924.2"><vh>@@thin uA_test_file.py</vh>
<v t="ekr.20080806084924.3"><vh>child1</vh>
<v t="ekr.20080806084924.4"><vh>grandChild1</vh>
<v t="ekr.20080806084924.5"><vh>greatGrandChild1</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20100223094723.5375"><vh>New import tests</vh>
<v t="ekr.20100223094723.5376"><vh>@@test skipToTheNextClassOrFunction (a class next)</vh></v>
<v t="ekr.20100223094723.5377"><vh>@@test skipToTheNextClassOrFunction (a function next)</vh></v>
<v t="ekr.20100223094723.5378"><vh>@@test skipToTheNextClassOrFunction (nothing next)</vh></v>
<v t="ekr.20100223094723.5379"><vh>@@test skipToTheNextClassOrFunction (indented def next)</vh></v>
</v>
<v t="ekr.20110610122533.3388"><vh>Old Tests with @auto as the root</vh>
<v t="ekr.20110610122533.3389"><vh>@@test goto-line-number @auto 1</vh></v>
<v t="ekr.20110610122533.3390"><vh>@@test goto-global-line @auto 2</vh></v>
<v t="ekr.20110610122533.3391"><vh>@@test goto-global-line @auto 3</vh></v>
<v t="ekr.20110610122533.3392"><vh>@@test goto-global-line @auto 4</vh></v>
<v t="ekr.20110610122533.3406"><vh>@@test goto-global-line @auto 5</vh></v>
<v t="ekr.20110610122533.3401"><vh>@@test GoToLineNumber.find_root 1</vh></v>
</v>
</v>
<v t="ekr.20100208230953.5383"><vh>Cache tests</vh>
<v t="ekr.20100208095817.5387"><vh>@@test leoCache</vh></v>
</v>
<v t="ekr.20040712101754.2"><vh>Load tests for .leo files</vh>
<v t="ekr.20040712101754.3"><vh>@@test test.leo</vh></v>
<v t="ekr.20040803090901"><vh>@@test leoDist.leo</vh></v>
<v t="ekr.20081121164135.1"><vh>@@test leoGuiPluginsRef.leo</vh></v>
<v t="ekr.20040712101754.4"><vh>@@test LeoPyRef.leo</vh></v>
<v t="ekr.20040712101754.5"><vh>@@test leoPluginsRef.leo</vh></v>
<v t="ekr.20040712101754.6"><vh>@@test LeoDocs.leo</vh></v>
<v t="ekr.20040730181601"><vh>@@test minimalLeoFile.leo</vh></v>
<v t="ekr.20040730181610"><vh>@@test minimalLeoFile2.leo</vh></v>
<v t="ekr.20040831104758"><vh>@@test minimalLeoFile3.leo</vh></v>
</v>
<v t="ekr.20080405085247.1"><vh>slow tests</vh>
<v t="ekr.20060208195054"><vh>@@test k.inverseCommandsDict is inverse of c.commandsDict</vh>
<v t="ekr.20070926095117"><vh>mungeKey</vh></v>
</v>
<v t="ekr.20110728154927.3324"><vh>@@test position &gt; operator</vh></v>
</v>
</v>
<v t="ekr.20190113114613.2"><vh>Newer unused tests</vh>
<v t="ekr.20190113114613.3"><vh>@@suite @nosent with javascript</vh>
<v t="ekr.20190113114613.4"><vh>@@shadow-tests</vh>
<v t="ekr.20190113114613.5"><vh>@@shadow-test equal @nosent @doc</vh>
<v t="ekr.20190113114613.6"><vh>old</vh>
<v t="ekr.20190113114613.7"><vh>node 1</vh></v>
</v>
<v t="ekr.20190113114613.8"><vh>new</vh>
<v t="ekr.20190113114613.9"><vh>node 1</vh></v>
</v>
</v>
<v t="ekr.20190113114613.10"><vh>@@shadow-test replace in node new &lt; old</vh>
<v t="ekr.20190113114613.11"><vh>old</vh>
<v t="ekr.20190113114613.12"><vh>node 1</vh></v>
</v>
<v t="ekr.20190113114613.13"><vh>new</vh>
<v t="ekr.20190113114613.14"><vh>node 1</vh></v>
</v>
</v>
<v t="ekr.20190113114613.15"><vh>@@shadow-test change middle line</vh>
<v t="ekr.20190113114613.16"><vh>old</vh></v>
<v t="ekr.20190113114613.17"><vh>new</vh></v>
</v>
<v t="ekr.20190113114613.18"><vh>@@shadow-test change first line</vh>
<v t="ekr.20190113114613.19"><vh>old</vh></v>
<v t="ekr.20190113114613.20"><vh>new</vh></v>
</v>
<v t="ekr.20190113114613.21"><vh>@@shadow-test change last line</vh>
<v t="ekr.20190113114613.22"><vh>old</vh></v>
<v t="ekr.20190113114613.23"><vh>new</vh></v>
</v>
<v t="ekr.20190113114613.24"><vh>@@shadow-test delete first line</vh>
<v t="ekr.20190113114613.25"><vh>old</vh></v>
<v t="ekr.20190113114613.26"><vh>new</vh></v>
</v>
<v t="ekr.20190113114613.27"><vh>@@shadow-test delete middle line</vh>
<v t="ekr.20190113114613.28"><vh>old</vh></v>
<v t="ekr.20190113114613.29"><vh>new</vh></v>
</v>
<v t="ekr.20190113114613.30"><vh>@@shadow-test delete last line</vh>
<v t="ekr.20190113114613.31"><vh>old</vh></v>
<v t="ekr.20190113114613.32"><vh>new</vh></v>
</v>
<v t="ekr.20190113114613.33"><vh>@@shadow-test insert before first line</vh>
<v t="ekr.20190113114613.34"><vh>old</vh></v>
<v t="ekr.20190113114613.35"><vh>new</vh></v>
</v>
<v t="ekr.20190113114613.36"><vh>@@shadow-test insert middle line (after first line)</vh>
<v t="ekr.20190113114613.37"><vh>old</vh></v>
<v t="ekr.20190113114613.38"><vh>new</vh></v>
</v>
<v t="ekr.20190113114613.39"><vh>@@shadow-test insert middle line (before last line)</vh>
<v t="ekr.20190113114613.40"><vh>old</vh></v>
<v t="ekr.20190113114613.41"><vh>new</vh></v>
</v>
<v t="ekr.20190113114613.42"><vh>@@shadow-test insert after last line</vh>
<v t="ekr.20190113114613.43"><vh>old</vh></v>
<v t="ekr.20190113114613.44"><vh>new</vh></v>
</v>
<v t="ekr.20190113114613.45"><vh>@@shadow-test-lax insert between nodes: at end of prev node</vh>
<v t="ekr.20190113114613.46"><vh>old</vh>
<v t="ekr.20190113114613.47"><vh>node 1</vh></v>
<v t="ekr.20190113114613.48"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.49"><vh>new</vh>
<v t="ekr.20190113114613.50"><vh>node 1</vh></v>
<v t="ekr.20190113114613.51"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.52"><vh>@@shadow-test delete between nodes: at end of prev node</vh>
<v t="ekr.20190113114613.53"><vh>old</vh>
<v t="ekr.20190113114613.54"><vh>node 1</vh></v>
<v t="ekr.20190113114613.55"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.56"><vh>new</vh>
<v t="ekr.20190113114613.57"><vh>node 1</vh></v>
<v t="ekr.20190113114613.58"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.59"><vh>@@shadow-test delete between nodes: at start of next node</vh>
<v t="ekr.20190113114613.60"><vh>old</vh>
<v t="ekr.20190113114613.61"><vh>node 1</vh></v>
<v t="ekr.20190113114613.62"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.63"><vh>new</vh>
<v t="ekr.20190113114613.64"><vh>node 1</vh></v>
<v t="ekr.20190113114613.65"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.66"><vh>@@shadow-test change end of prev node</vh>
<v t="ekr.20190113114613.67"><vh>old</vh>
<v t="ekr.20190113114613.68"><vh>node 1</vh></v>
<v t="ekr.20190113114613.69"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.70"><vh>new</vh>
<v t="ekr.20190113114613.71"><vh>node 1</vh></v>
<v t="ekr.20190113114613.72"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.73"><vh>@@shadow-test change start of next node</vh>
<v t="ekr.20190113114613.74"><vh>old</vh>
<v t="ekr.20190113114613.75"><vh>node 1</vh></v>
<v t="ekr.20190113114613.76"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.77"><vh>new</vh>
<v t="ekr.20190113114613.78"><vh>node 1</vh></v>
<v t="ekr.20190113114613.79"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.80"><vh>@@shadow-test-lax multiple-line insert between nodes: at end of prev node</vh>
<v t="ekr.20190113114613.81"><vh>old</vh>
<v t="ekr.20190113114613.82"><vh>node 1</vh></v>
<v t="ekr.20190113114613.83"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.84"><vh>new</vh>
<v t="ekr.20190113114613.85"><vh>node 1</vh></v>
<v t="ekr.20190113114613.86"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.87"><vh>@@shadow-test multiple-line change end of prev node</vh>
<v t="ekr.20190113114613.88"><vh>old</vh>
<v t="ekr.20190113114613.89"><vh>node 1</vh></v>
<v t="ekr.20190113114613.90"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.91"><vh>new</vh>
<v t="ekr.20190113114613.92"><vh>node 1</vh></v>
<v t="ekr.20190113114613.93"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.94"><vh>@@shadow-test multiple-line change start of next node</vh>
<v t="ekr.20190113114613.95"><vh>old</vh>
<v t="ekr.20190113114613.96"><vh>node 1</vh></v>
<v t="ekr.20190113114613.97"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.98"><vh>new</vh>
<v t="ekr.20190113114613.99"><vh>node 1</vh></v>
<v t="ekr.20190113114613.100"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.101"><vh>@@shadow-test multiple-NODE changes</vh>
<v t="ekr.20190113114613.102"><vh>old</vh>
<v t="ekr.20190113114613.103"><vh>node 1</vh></v>
<v t="ekr.20190113114613.104"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.105"><vh>new</vh>
<v t="ekr.20190113114613.106"><vh>node 1</vh></v>
<v t="ekr.20190113114613.107"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.108"><vh>@@shadow-test multiple-line delete between nodes: at end of prev node</vh>
<v t="ekr.20190113114613.109"><vh>old</vh>
<v t="ekr.20190113114613.110"><vh>node 1</vh></v>
<v t="ekr.20190113114613.111"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.112"><vh>new</vh>
<v t="ekr.20190113114613.113"><vh>node 1</vh></v>
<v t="ekr.20190113114613.114"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.115"><vh>@@shadow-test multiple-line delete between nodes: at start of next node</vh>
<v t="ekr.20190113114613.116"><vh>old</vh>
<v t="ekr.20190113114613.117"><vh>node 1</vh></v>
<v t="ekr.20190113114613.118"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.119"><vh>new</vh>
<v t="ekr.20190113114613.120"><vh>node 1</vh></v>
<v t="ekr.20190113114613.121"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.122"><vh>@@shadow-test verbatim sentinels-delete verbatim line</vh>
<v t="ekr.20190113114613.123"><vh>old</vh>
<v t="ekr.20190113114613.124"><vh>node 1</vh></v>
<v t="ekr.20190113114613.125"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.126"><vh>new</vh>
<v t="ekr.20190113114613.127"><vh>node 1</vh></v>
<v t="ekr.20190113114613.128"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.129"><vh>@@shadow-test verbatim sentinels-delete verbatim line: at start of node</vh>
<v t="ekr.20190113114613.130"><vh>old</vh>
<v t="ekr.20190113114613.131"><vh>node 1</vh></v>
<v t="ekr.20190113114613.132"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.133"><vh>new</vh>
<v t="ekr.20190113114613.134"><vh>node 1</vh></v>
<v t="ekr.20190113114613.135"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.136"><vh>@@shadow-test verbatim sentinels-no change</vh>
<v t="ekr.20190113114613.137"><vh>old</vh>
<v t="ekr.20190113114613.138"><vh>node 1</vh></v>
<v t="ekr.20190113114613.139"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.140"><vh>new</vh>
<v t="ekr.20190113114613.141"><vh>node 1</vh></v>
<v t="ekr.20190113114613.142"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.143"><vh>@@shadow-test verbatim sentinels-delete verbatim line: at end of node</vh>
<v t="ekr.20190113114613.144"><vh>old</vh>
<v t="ekr.20190113114613.145"><vh>node 1</vh></v>
<v t="ekr.20190113114613.146"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.147"><vh>new</vh>
<v t="ekr.20190113114613.148"><vh>node 1</vh></v>
<v t="ekr.20190113114613.149"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.150"><vh>@@shadow-test verbatim sentinels-add verbatim line</vh>
<v t="ekr.20190113114613.151"><vh>old</vh>
<v t="ekr.20190113114613.152"><vh>node 1</vh></v>
<v t="ekr.20190113114613.153"><vh>node 2</vh></v>
</v>
<v t="ekr.20190113114613.154"><vh>new</vh>
<v t="ekr.20190113114613.155"><vh>node 1</vh></v>
<v t="ekr.20190113114613.156"><vh>node 2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.157"><vh>@@shadow-test no change, no ending newline</vh>
<v t="ekr.20190113114613.158"><vh>old</vh></v>
<v t="ekr.20190113114613.159"><vh>new</vh></v>
</v>
</v>
</v>
<v t="ekr.20190113114613.160"><vh>@@suite run all plugin test routines</vh>
<v t="ekr.20190113114613.161"><vh>&lt;&lt; class testRoutineTestCase &gt;&gt;</vh>
<v t="ekr.20190113114613.162"><vh>__init__</vh></v>
<v t="ekr.20190113114613.163"><vh> fail</vh></v>
<v t="ekr.20190113114613.164"><vh>runTest</vh></v>
<v t="ekr.20190113114613.165"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20190113114613.166"><vh>addTestRoutinesInPluginToSuite</vh></v>
<v t="ekr.20190113114613.167"><vh>findTestsInModule</vh>
<v t="ekr.20190113114613.168"><vh>&lt;&lt; print classes, methods &amp; functions &gt;&gt;</vh></v>
</v>
<v t="ekr.20190113114613.169"><vh>removeLeadingWs</vh></v>
</v>
<v t="ekr.20190113114613.170"><vh>@@test (minitest) x.show_error</vh></v>
<v t="ekr.20190113114613.171"><vh>@@test @file no newline</vh>
<v t="ekr.20190113114613.172"><vh>#@file</vh></v>
<v t="ekr.20190113114613.173"><vh>Output</vh></v>
</v>
<v t="ekr.20190113114613.174"><vh>@@test @file one newline</vh>
<v t="ekr.20190113114613.175"><vh>#@file</vh></v>
<v t="ekr.20190113114613.176"><vh>Output</vh></v>
</v>
<v t="ekr.20190113114613.177"><vh>@@test @file two newlines</vh>
<v t="ekr.20190113114613.178"><vh>#@file</vh></v>
<v t="ekr.20190113114613.179"><vh>Output</vh></v>
</v>
<v t="ekr.20190113114613.180"><vh>@@test @file: shape of tree</vh></v>
<v t="ekr.20190113114613.181"><vh>@@test @shadow: shape of tree</vh></v>
<v t="ekr.20190113114613.182"><vh>@@test add-editor &amp; delete-editor</vh></v>
<v t="ekr.20190113114613.183"><vh>@@test AdminPermission.java</vh></v>
<v t="ekr.20190113114613.184"><vh>@@test at.deleteUnvistedNodes</vh></v>
<v t="ekr.20190113114613.185"><vh>@@test at.massageDocPart</vh></v>
<v t="ekr.20190113123110.1"><vh>@@test at.open/closeAtShadowStringFile</vh></v>
<v t="ekr.20190113114613.186"><vh>@@test at.openForWrite: not a shadow file</vh></v>
<v t="ekr.20190113114613.187"><vh>@@test at.rename</vh></v>
<v t="ekr.20190114095901.2"><vh>@@test at.replaceFileWithString</vh></v>
<v t="ekr.20190114095901.3"><vh>@@test at.replaceFileWithString (does not exist)</vh></v>
<v t="ekr.20190113114613.188"><vh>@@test atFile.printError</vh></v>
<v t="ekr.20190113114613.189"><vh>@@test bodyCtrl property</vh></v>
<v t="ekr.20190113114613.190"><vh>@@test c# ref card</vh></v>
<v t="ekr.20190113114613.191"><vh>@@test c.checkAllPythonCode</vh></v>
<v t="ekr.20190113114613.192"><vh>@@test c.checkFileTimeStamp &amp; c.setFileTimeStamp</vh></v>
<v t="ekr.20190113114613.193"><vh>@@test c.openTempFileInExternalEditor</vh></v>
<v t="ekr.20190113114613.194"><vh>@@test constants.java</vh></v>
<v t="ekr.20190113114613.195"><vh>@@test delete-editor</vh></v>
<v t="ekr.20190113114613.196"><vh>@@test detect_urls.py</vh></v>
<v t="ekr.20190113114613.197"><vh>@@test efc.create_temp_file</vh></v>
<v t="ekr.20190113114613.198"><vh>@@test fc.handleNodeConflicts</vh></v>
<v t="ekr.20190113114613.199"><vh>@@test fill-region (one paragraph)</vh>
<v t="ekr.20190113114613.200"><vh>work</vh></v>
<v t="ekr.20190113114613.201"><vh>before sel=1.0,9.7</vh></v>
<v t="ekr.20190113114613.202"><vh>after sel=6.7,6.7</vh></v>
</v>
<v t="ekr.20190113114613.203"><vh>@@test fill-region (three paragraphs)</vh>
<v t="ekr.20190113114613.204"><vh>work</vh></v>
<v t="ekr.20190113114613.205"><vh>before sel=1.0,24.78</vh></v>
<v t="ekr.20190113114613.206"><vh>after sel=18.19,18.19</vh></v>
</v>
<v t="ekr.20190113114613.207"><vh>@@test Find keeps focus in body &amp; shows selected text</vh></v>
<v t="ekr.20190113114613.208"><vh>@@test find_file_line: @auto-rst</vh></v>
<v t="ekr.20190113114613.209"><vh>@@test find_h / find_b / filter_h / filter_b</vh></v>
<v t="ekr.20190113114613.210"><vh>@@test g.app.config.getShortcuts works when no local shortcuts</vh></v>
<v t="ekr.20190113114613.211"><vh>@@test g.es_exception (heroic)</vh></v>
<v t="ekr.20190113114613.212"><vh>@@test g.reportBadChars</vh></v>
<v t="ekr.20190113114613.213"><vh>@@test html whitespace bug</vh></v>
<v t="ekr.20190113114613.214"><vh>@@test ic.createOutline: at-auto with lines that look like section references</vh></v>
<v t="ekr.20190113114613.215"><vh>@@test ic.parse-body</vh>
<v t="ekr.20190113114613.216"><vh>copy</vh></v>
<v t="ekr.20190113114613.217"><vh>before</vh>
<v t="ekr.20190113114613.218"><vh>class aClass</vh>
<v t="ekr.20190113114613.219"><vh>__init__</vh></v>
<v t="ekr.20190113114613.220"><vh>spam</vh></v>
</v>
<v t="ekr.20190113114613.221"><vh>bClass = aClass</vh></v>
</v>
<v t="ekr.20190113114613.222"><vh>expected</vh>
<v t="ekr.20190113114613.223"><vh>class aClass</vh>
<v t="ekr.20190113114613.224"><vh>__init__</vh></v>
<v t="ekr.20190113114613.225"><vh>spam</vh></v>
</v>
</v>
</v>
<v t="ekr.20190113114613.226"><vh>@@test ic.parse-body mypy</vh>
<v t="ekr.20190113114613.227"><vh>copy</vh></v>
<v t="ekr.20190113114613.228"><vh>before</vh>
<v t="ekr.20190113114613.229"><vh>class TypeJoinVisitor</vh></v>
</v>
<v t="ekr.20190113114613.230"><vh>expected</vh>
<v t="ekr.20190113114613.231"><vh>class TypeJoinVisitor</vh>
<v t="ekr.20190113114613.232"><vh>__init__</vh></v>
<v t="ekr.20190113114613.233"><vh>visit_unbound_type</vh></v>
<v t="ekr.20190113114613.234"><vh>visit_union_type</vh></v>
<v t="ekr.20190113114613.235"><vh>visit_error_type</vh></v>
<v t="ekr.20190113114613.236"><vh>visit_type_list</vh></v>
<v t="ekr.20190113114613.237"><vh>visit_any</vh></v>
<v t="ekr.20190113114613.238"><vh>visit_void</vh></v>
<v t="ekr.20190113114613.239"><vh>visit_none_type</vh></v>
<v t="ekr.20190113114613.240"><vh>visit_erased_type</vh></v>
<v t="ekr.20190113114613.241"><vh>visit_type_var</vh></v>
<v t="ekr.20190113114613.242"><vh>visit_instance</vh></v>
<v t="ekr.20190113114613.243"><vh>visit_callable_type</vh></v>
<v t="ekr.20190113114613.244"><vh>visit_overloaded</vh></v>
<v t="ekr.20190113114613.245"><vh>visit_tuple_type</vh></v>
<v t="ekr.20190113114613.246"><vh>join</vh></v>
<v t="ekr.20190113114613.247"><vh>default</vh></v>
</v>
</v>
</v>
<v t="ekr.20190113114613.248"><vh>@@test ifgui</vh></v>
<v t="ekr.20190113114613.249"><vh>@@test item2position</vh></v>
<v t="ekr.20190113114613.250"><vh>@@test JSON</vh></v>
<v t="ekr.20190113114613.251"><vh>@@test k.autoCompleterClass.calltip</vh></v>
<v t="ekr.20190113114613.252"><vh>@@test macros.parameterize</vh></v>
<v t="ekr.20190113114613.253"><vh>@@test nodeIndices.toString(None) allocates a new index</vh></v>
<v t="ekr.20190113114613.254"><vh>@@test p.t == p.v</vh></v>
<v t="ekr.20190113114613.255"><vh>@@test pd.find_absolute_unl_node</vh></v>
<v t="ekr.20190113114613.256"><vh>@@test pd.pack &amp; pd.unpack</vh>
<v t="ekr.20190113114613.260"><vh>clone</vh></v>
<v t="ekr.20190113114613.258"><vh>@@view test</vh>
<v t="ekr.20190113114613.259"><vh>not a clone</vh></v>
<v t="ekr.20190113114613.260"></v>
</v>
</v>
<v t="ekr.20190113114613.261"><vh>@@test pd.prepass</vh></v>
<v t="ekr.20190113114613.262"><vh>@@test pd.recovery_ua_for_gnx</vh></v>
<v t="ekr.20190113114613.263"><vh>@@test print calls to jedit.setTag</vh></v>
<v t="ekr.20190113114613.264"><vh>@@test print('end python tests')</vh></v>
<v t="ekr.20190113114613.265"><vh>@@test print('start python tests')</vh></v>
<v t="ekr.20190113114613.266"><vh>@@test show_doc_parts_in_rst_mode</vh></v>
<v t="ekr.20190113114613.267"><vh>@@test test imports for modes</vh></v>
<v t="ekr.20190113114613.268"><vh>@@test that all @test nodes in derived files start with if g.unitTesting</vh>
<v t="ekr.20190113114613.269"><vh>checkFile</vh></v>
</v>
<v t="ekr.20190113114613.270"><vh>@@test that clones share subtrees</vh></v>
<v t="ekr.20190113114613.271"><vh>@@test unbound Alt-9 key is completely ignored</vh></v>
<v t="ekr.20190113114613.272"><vh>@@test visback</vh>
<v t="ekr.20190113114613.273"><vh>a</vh>
<v t="ekr.20190113114613.274"><vh>b</vh>
<v t="ekr.20190113114613.275"><vh>c2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.276"><vh>limit</vh>
<v t="ekr.20190113114613.277"><vh>d</vh></v>
</v>
<v t="ekr.20190113114613.278"><vh>e</vh></v>
</v>
<v t="ekr.20190113114613.279"><vh>@@test x.rename</vh></v>
<v t="ekr.20190113114613.280"><vh>@@test zap-to-chararacter</vh>
<v t="ekr.20190113114613.281"><vh>work</vh></v>
</v>
</v>
<v t="ekr.20190113114613.282"><vh>Test files</vh>
<v t="ekr.20190113114613.283"><vh>@@auto unittest/at-auto-section-ref-test.py</vh>
<v t="ekr.20190113114613.284"><vh>at-auto-section-ref-test declarations</vh></v>
</v>
<v t="ekr.20190113114613.285"><vh>@@auto-rst unittest/at-auto-rst-line-number-test.rst</vh>
<v t="ekr.20190113114613.286"><vh>@@nosent c:\test\bug-354-test.py</vh>
<v t="ekr.20190113114613.287"><vh>&lt;&lt; u:1 &gt;&gt;</vh></v>
<v t="ekr.20190113114613.288"><vh>&lt;&lt; ue:1 &gt;&gt;</vh></v>
<v t="ekr.20190113114613.289"><vh>&lt;&lt; u:2 &gt;&gt;</vh></v>
<v t="ekr.20190113114613.290"><vh>&lt;&lt; ue: 2&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20190113114613.291"><vh>@@file nonexistent-directory/orphan-bit-test.txt</vh></v>
<v t="ekr.20190113114613.292"><vh>@@shadow unittest/at-shadow-line-number-test.py</vh>
<v t="ekr.20190113114613.293"><vh>spam</vh></v>
<v t="ekr.20190113114613.294"><vh>eggs</vh></v>
</v>
<v t="ekr.20190113114613.295"><vh>@@shadow unittest/at-shadow-test.py</vh>
<v t="ekr.20190113114613.296"><vh>spam</vh></v>
<v t="ekr.20190113114613.297"><vh>eggs</vh></v>
</v>
<v t="ekr.20190113114613.298"><vh>@@shadow unittest/at-shadow-unlink-clones.py</vh>
<v t="ekr.20190113114613.299"><vh>Node 1</vh></v>
<v t="ekr.20190113114613.300"><vh>Node 2</vh></v>
</v>
<v t="ekr.20190113114613.301"><vh>@@asis unittest/at-asis-test.py</vh>
<v t="ekr.20190113114613.302"><vh>spam</vh></v>
<v t="ekr.20190113114613.303"><vh>eggs</vh></v>
</v>
<v t="ekr.20190113114613.304"><vh>@@auto unittest/at-auto-line-number-test.py</vh>
<v t="ekr.20190113114613.305"><vh>at_auto_child</vh></v>
</v>
<v t="ekr.20190113114613.306"><vh>@@auto unittest/at-auto-md-line-number-test.md</vh>
<v t="ekr.20190113114613.307"><vh>!Declarations</vh></v>
<v t="ekr.20190113114613.308"><vh>section 1</vh></v>
<v t="ekr.20190113114613.309"><vh>section 2</vh></v>
</v>
<v t="ekr.20190113114613.310"><vh>@@auto unittest/at-auto-test.py</vh>
<v t="ekr.20190113114613.311"><vh>spam</vh></v>
<v t="ekr.20190113114613.312"><vh>eggs</vh></v>
</v>
<v t="ekr.20190113114613.313"><vh>@@auto unittest/at-auto-unit-test.py</vh>
<v t="ekr.20190113114613.314"><vh>class class1</vh>
<v t="ekr.20190113114613.315"><vh>class1_method1</vh></v>
<v t="ekr.20190113114613.316"><vh>class1_method2</vh></v>
</v>
<v t="ekr.20190113114613.317"><vh>class class2</vh>
<v t="ekr.20190113114613.318"><vh>class2_method1</vh></v>
<v t="ekr.20190113114613.319"><vh>class2_method2</vh></v>
</v>
</v>
<v t="ekr.20190113114613.320"><vh>@@auto-ctext unittest/at-auto-ctext-test.txt</vh>
<v t="ekr.20190113114613.321"><vh>A level one node</vh></v>
<v t="ekr.20190113114613.322"><vh>Another level one node</vh>
<v t="ekr.20190113114613.323"><vh>A level 2 node</vh></v>
</v>
</v>
<v t="ekr.20190113114613.324"><vh>@@auto-org unittest/at-auto-org-line-number-test.org</vh>
<v t="ekr.20190113114613.325"><vh>section 1</vh></v>
<v t="ekr.20190113114613.326"><vh>section 2</vh></v>
</v>
<v t="ekr.20190113114613.327"><vh>@@auto-otl unittest/at-auto-otl-line-number-test.otl</vh>
<v t="ekr.20190113114613.328"><vh>First line.</vh></v>
<v t="ekr.20190113114613.329"><vh>section 1</vh></v>
<v t="ekr.20190113114613.330"><vh>section 2</vh></v>
</v>
<v t="ekr.20190113114613.331"><vh>@@auto-rst unittest/at-auto-rst-line-number-test.txt</vh></v>
<v t="ekr.20190113114613.332"><vh>@@clean unittest/at-clean-line-number-test.c</vh>
<v t="ekr.20190113114613.333"><vh>spam</vh></v>
<v t="ekr.20190113114613.334"><vh>eggs</vh></v>
</v>
<v t="ekr.20190113114613.335"><vh>@@clean unittest/at-clean-line-number-test.py</vh>
<v t="ekr.20190113114613.336"><vh>spam</vh></v>
<v t="ekr.20190113114613.337"><vh>eggs</vh></v>
</v>
<v t="ekr.20190113114613.338"><vh>@@file C:/leo.repo/leo-editor/leo/test/unittest/input/cweave.w</vh></v>
<v t="ekr.20190113114613.339"><vh>@@file unittest/at-file-line-number-test.c</vh>
<v t="ekr.20190113114613.340"><vh>at-file-child</vh></v>
</v>
<v t="ekr.20190113114613.341"><vh>@@file unittest/at-file-line-number-test.py</vh>
<v t="ekr.20190113114613.342"><vh>at-file-child</vh></v>
</v>
<v t="ekr.20190113114613.343"><vh>@@file unittest/tex-error.tex</vh>
<v t="ekr.20190113114613.344"><vh>&lt;&lt; Document &gt;&gt;</vh></v>
</v>
<v t="ekr.20190113114613.345"><vh>@@file unittest/utf-16-test.txt</vh></v>
<v t="ekr.20190113114613.346"><vh>@@nosent unittest/at-nosent-line-number-test.py</vh>
<v t="ekr.20190113114613.347"><vh>spam</vh></v>
<v t="ekr.20190113114613.348"><vh>eggs</vh></v>
</v>
<v t="ekr.20190113114613.349"><vh>@@nosent unittest/at-nosent-test.py</vh>
<v t="ekr.20190113114613.350"><vh>spam</vh></v>
<v t="ekr.20190113114613.351"><vh>eggs</vh></v>
</v>
<v t="ekr.20190113114613.352"><vh>@@thin unittest/at-thin-html-test.html</vh>
<v t="ekr.20190113114613.353"><vh>&lt;&lt; a section reference &gt;&gt;</vh></v>
</v>
<v t="ekr.20190113114613.354"><vh>@@thin unittest/at-thin-line-number-test.py</vh>
<v t="ekr.20190113114613.355"><vh>at-thin-child</vh></v>
</v>
<v t="ekr.20190113114613.356"><vh>@@thin unittest/at-thin-test.py</vh>
<v t="ekr.20190113114613.357"><vh>spam</vh></v>
<v t="ekr.20190113114613.358"><vh>eggs</vh></v>
</v>
<v t="ekr.20190113114613.359"><vh>@@thin unittest/batchTest.py</vh></v>
<v t="ekr.20190113114613.360"><vh>@@thin unittest/errorTest.py</vh></v>
</v>
<v t="ekr.20190113114613.361"><vh>Slow tests</vh>
<v t="ekr.20190113114613.362"><vh>@@test import all Leo's core files</vh></v>
</v>
<v t="ekr.20190113114613.363"><vh>Qt-only tests (do not delete!)</vh>
<v t="ekr.20190113114613.364"><vh>@@test all top-level read/write commands give proper read/write error dialogs</vh>
<v t="ekr.20190113114613.365"><vh>child</vh></v>
</v>
<v t="ekr.20190113114613.366"><vh>@@test c.frame.log relationships</vh></v>
<v t="ekr.20190113114613.367"><vh>@@test c.frame.log.numberOfVisibleTabs</vh></v>
<v t="ekr.20190113114613.368"><vh>@@test c.frame.log.put &amp; putNl</vh></v>
<v t="ekr.20190113114613.369"><vh>@@test c.frame.minimize-all</vh></v>
<v t="ekr.20190113114613.370"><vh>@@test c.frame.pasteText</vh></v>
<v t="ekr.20190113114613.371"><vh>@@test c.frame.pasteText 2</vh></v>
<v t="ekr.20190113114613.372"><vh>@@test c.frame.resize-to-screen</vh></v>
<v t="ekr.20190113114613.373"><vh>@@test Ctrl-I inserts only one headline</vh></v>
<v t="ekr.20190113114613.374"><vh>@@test cycle-all-focus</vh></v>
<v t="ekr.20190113114613.375"><vh>@@test cycle-tab-focus</vh></v>
<v t="ekr.20190113114613.376"><vh>@@test delete-word (no selection)</vh>
<v t="ekr.20190113114613.377"><vh>work</vh></v>
<v t="ekr.20190113114613.378"><vh>before sel=1.10,1.10</vh></v>
<v t="ekr.20190113114613.379"><vh>after sel=1.10,1.10</vh></v>
</v>
<v t="ekr.20190113114613.380"><vh>@@test delete-word (selection)</vh>
<v t="ekr.20190113114613.381"><vh>work</vh></v>
<v t="ekr.20190113114613.382"><vh>before sel=1.7,1.12</vh></v>
<v t="ekr.20190113114613.383"><vh>after sel=1.7,1.7</vh></v>
</v>
<v t="ekr.20190113114613.384"><vh>@@test deleting the last body character text redraws the screen (and icon)</vh></v>
<v t="ekr.20190113114613.385"><vh>@@test editLabel selects entire headline</vh></v>
<v t="ekr.20190113114613.386"><vh>@@test expand/contract-pane</vh></v>
<v t="ekr.20190113114613.387"><vh>@@test g.es_print</vh></v>
<v t="ekr.20190113114613.388"><vh>@@test g.es_trace</vh></v>
<v t="ekr.20190113114613.389"><vh>@@test g.pr</vh></v>
<v t="ekr.20190113114613.390"><vh>@@test g.toUnicode(QString)</vh></v>
<v t="ekr.20190113114613.391"><vh>@@test g.trace</vh></v>
<v t="ekr.20190113114613.392"><vh>@@test illegal drag gives warning</vh>
<v t="ekr.20190113114613.393"><vh>a</vh></v>
</v>
<v t="ekr.20190113114613.394"><vh>@@test interfaces using API classes</vh></v>
<v t="ekr.20190113114613.395"><vh>@@test k.handleDefaultChar from log pane</vh></v>
<v t="ekr.20190113114613.396"><vh>@@test move-marked-nodes</vh>
<v t="ekr.20190113114613.397"><vh>data</vh></v>
</v>
<v t="ekr.20190113114613.398"><vh>@@test onHyperLinkControlClick</vh></v>
<v t="ekr.20190113114613.399"><vh>@@test paste from menu into body sticks</vh></v>
<v t="ekr.20190113114613.400"><vh>@@test paste from menu to body recolors the body</vh></v>
<v t="ekr.20190113114613.401"><vh>@@test print redraw count</vh></v>
<v t="ekr.20190113114613.402"><vh>@@test toggle-find-x</vh></v>
<v t="ekr.20190113114613.403"><vh>@@test typing in empty body text redraws the screen (and icon)</vh></v>
</v>
<v t="ekr.20190113114613.404"><vh>Unit tests that fail for others</vh>
<v t="ekr.20190113114613.405"><vh>Terry's failures</vh>
<v t="ekr.20190113114613.406"><vh>@@test x.makeShadowDirectory</vh>
<v t="ekr.20190113114613.407"><vh>deleteShadowDir</vh></v>
</v>
<v t="ekr.20190113114613.408"><vh>@@test all commands have an event arg</vh></v>
<v t="ekr.20190113114613.409"><vh>add/delete comments</vh>
<v t="ekr.20190113114613.410"><vh>@@test add comments with multiple @language directives</vh>
<v t="ekr.20190113114613.411"><vh>rest and python</vh></v>
</v>
<v t="ekr.20190113114613.412"><vh>@@test delete comments with multiple @language directives</vh>
<v t="ekr.20190113114613.413"><vh>rest and python</vh></v>
</v>
<v t="ekr.20190113114613.414"><vh>@@test add html comments</vh>
<v t="ekr.20190113114613.415"><vh>@language html</vh>
<v t="ekr.20190113114613.416"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20190113114613.417"><vh>@@test delete html comments</vh>
<v t="ekr.20190113114613.418"><vh>@language html</vh>
<v t="ekr.20190113114613.419"><vh>html</vh></v>
</v>
</v>
<v t="ekr.20190113114613.420"><vh>@@test add python comments</vh>
<v t="ekr.20190113114613.421"><vh>python</vh></v>
</v>
<v t="ekr.20190113114613.422"><vh>@@test delete python comments</vh>
<v t="ekr.20190113114613.423"><vh>python</vh></v>
</v>
</v>
<v t="ekr.20190113114613.424"><vh>rst import test that fail for Terry</vh>
<v t="ekr.20190113114613.425"><vh>@@test rST import test: simple</vh></v>
<v t="ekr.20190113114613.426"><vh>@@test rST import test: no double-underlines</vh></v>
<v t="ekr.20190113114613.427"><vh>@@test rST import test</vh></v>
<v t="ekr.20190113114613.428"><vh>@@test rST import test: trailing whitespace</vh></v>
<v t="ekr.20190113114613.429"><vh>@@test rST import test: long overlines</vh></v>
<v t="ekr.20190113114613.430"><vh>@@test rST import test: long underlines</vh></v>
<v t="ekr.20190113114613.431"><vh>@@test leo_rst</vh></v>
</v>
</v>
<v t="ekr.20190113114613.432"><vh>xgid failures</vh>
<v t="ekr.20190113114613.433"><vh>@@test g.app.config @buttons and @commands logic</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20040712101754.2">@language python
@tabwidth -4

# These work well with the qttabs gui.
</t>
<t tx="ekr.20040712101754.221">outline1 = p.firstChild()
outline2 = outline1.next()
assert(outline1.h=="outline1")
assert(outline2.h=="outline2")

c.testManager.replaceOutline(outline1,outline2)
c.redraw()
c.checkOutline()
</t>
<t tx="ekr.20040712101754.222"></t>
<t tx="ekr.20040712101754.223"></t>
<t tx="ekr.20040712101754.224"></t>
<t tx="ekr.20040712101754.225"></t>
<t tx="ekr.20040712101754.3">path = g.os_path_join(g.app.loadDir,"..","test","test.leo")
c.testManager.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.37"># Create unit tests in g.app.scriptDict["suite"]

suite = c.testManager.makeEditBodySuite(p)

# g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20040712101754.38">@language plain
@

The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:

- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
</t>
<t tx="ekr.20040712101754.4">path = g.os_path_join(g.app.loadDir,"..","core","LeoPyRef.leo")
c.testManager.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.49"></t>
<t tx="ekr.20040712101754.5">path = g.os_path_join(g.app.loadDir,"..","plugins","leoPluginsRef.leo")
c.testManager.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.50">line 1
    line 2
    line 3
line 4
</t>
<t tx="ekr.20040712101754.51">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20040712101754.52">2.0
3.5
</t>
<t tx="ekr.20040712101754.6">path = g.os_path_join(g.app.loadDir,"..","doc","LeoDocs.leo")
c.testManager.runLeoTest(path)
</t>
<t tx="ekr.20040730181601">path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile.leo")
c.testManager.runLeoTest(path)
</t>
<t tx="ekr.20040730181610">path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile2.leo")
c.testManager.runLeoTest(path)
</t>
<t tx="ekr.20040803090901">path = g.os_path_join(g.app.loadDir,"..","dist","leoDist.leo")
c.testManager.runLeoTest(path)
</t>
<t tx="ekr.20040831104758">path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile3.leo")
c.testManager.runLeoTest(path)
</t>
<t tx="ekr.20050417201845"></t>
<t tx="ekr.20050417201845.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20050417201845.2">before
    &lt;&lt; section &gt;&gt;
after
</t>
<t tx="ekr.20050417201845.3">sec line 1
    sec line 2 indented
sec line 3
</t>
<t tx="ekr.20050417201845.4">2.0
5.10
</t>
<t tx="ekr.20050417202713"></t>
<t tx="ekr.20050417202713.1">@language python

def addCommentTest():

    if 1:
        a = 2
        b = 3

    pass
</t>
<t tx="ekr.20050417202713.2">@language python

def addCommentTest():

    # if 1:
        # a = 2
        # b = 3

    pass
</t>
<t tx="ekr.20050417202713.3">5.0
7.8
</t>
<t tx="ekr.20050417202817"># created by new add-comments
</t>
<t tx="ekr.20050417202817.1">@language python

def deleteCommentTest():

#     if 1:
#         a = 2
#         b = 3

    pass
</t>
<t tx="ekr.20050417202817.2">@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3

    pass
</t>
<t tx="ekr.20050417202817.3">5.0
7.8
</t>
<t tx="ekr.20050417203114"></t>
<t tx="ekr.20050417203114.1"></t>
<t tx="ekr.20050417203310">@tabwidth -4

line 1
    line 2
      line 3
line4
</t>
<t tx="ekr.20050417203310.1">@tabwidth -4

line 1
	line 2
	  line 3
line4
</t>
<t tx="ekr.20050417203336">1.0
6.5
</t>
<t tx="ekr.20050417204830">@tabwidth -4

line 1
    line 2
      line 3
line4
</t>
<t tx="ekr.20050417204834">@tabwidth -4

line 1
	line 2
	  line 3
line4
</t>
<t tx="ekr.20050417204901">1.0
6.5
</t>
<t tx="ekr.20050417204940"></t>
<t tx="ekr.20050417204940.1">@tabwidth -4

line 1
    line 2
      line 3
line4
</t>
<t tx="ekr.20050417204940.2">@tabwidth -4

line 1
	line 2
	  line 3
line4
</t>
<t tx="ekr.20050417204940.3">1.0
6.5
</t>
<t tx="ekr.20050417205012"></t>
<t tx="ekr.20050417205012.1">@tabwidth -4

line 1
	line 2
	  line 3
line4
</t>
<t tx="ekr.20050417205012.2">@tabwidth -4

line 1
    line 2
      line 3
line4
</t>
<t tx="ekr.20050417205012.3">1.0
6.5
</t>
<t tx="ekr.20050518070540"></t>
<t tx="ekr.20050518070540.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20050518070540.4">2.0
2.16
</t>
<t tx="ekr.20050518070545">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20050518070927"></t>
<t tx="ekr.20050518070927.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20050518070927.2">before
    &lt;&lt; section &gt;&gt;
after
</t>
<t tx="ekr.20050518070927.3">sec line 1
    sec line 2 indented
sec line 3
</t>
<t tx="ekr.20050518070927.4">2.0
5.10
</t>
<t tx="ekr.20050518071251"></t>
<t tx="ekr.20050518071251.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20050518071251.4">2.0
2.16
</t>
<t tx="ekr.20050518071258">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after
</t>
<t tx="ekr.20051104081502">@language python
@tabwidth -4
</t>
<t tx="ekr.20051104081502.101">@language plain
@pagewidth 40

A one-line paragraph one two three four five six seven eight nine ten...

An @rawfile tree is a tree whose root headline starts with
@rawfile &lt;filename&gt;. Similarly, an @silentfile tree is a
tree whose root headline starts with an @silentfile
&lt;filename&gt; directive.

    Leo creates derived files from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. Exception: Leo recognizes the @ignore directive in @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:

  This
  is
  a
  test.

  1. This is the first line and it is really really really long. And it has
     a hanging indentation.
     and another line.

  2. This is a lllllllllllllllllllllllllllllllllllloooooooooooooooooong
     next item.
     And it too has a hanging indentation.

  3. This is an exxxxxxxxxxxxxxxxxxxxxxxxtrrrrrrrrrrrrrrreeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeemlylong
     word.
And it too has a hanging indentation.
</t>
<t tx="ekr.20051104081502.102">@tabwidth -4
@language plain


    a   b   c
a   b   c   d
aa  b   c   d
aaa b   c   d
end
</t>
<t tx="ekr.20051104081502.103">@killcolor
@language plain

Note: Previously, one could crash Leo by pasting a large text into a headline.  Leo now truncates that text, and furthermore Leo no longer makes all headline text into one gigantic line.  Therefore, we don't have to test Tk's ability to handle super-long lines.

The test:  Copy the following and paste it into a headline.  Leo should give 2 truncation messages:

- Truncating headline to one line.
- Truncating headline to 250 characters.

About a year ago I found the website at www.literateprogamming.com and was immediately convinced that the basic idea of Literate Programming is an important breakthrough. At the time I was working on a contract trying to decipher a true masterpiece of over-engineering, and if at any time during the construction of this masterpiece the perpetrators had been required to explain themselves in English, my client would have saved millions of dollars.

I never did try CWEB or NOWEB though, because on the literate programming site I read about a tool named Leo that combined outlines with Literate Programming techniques. Since Ive always found outlining tools very useful I downloaded and tried this. I found that using this tool completely changed my programming practice and brought out all of the power inherent in the original Literate Programming idea as I understood it.
</t>
<t tx="ekr.20051104081502.104">import os

g.pr(os.getcwd())
name = g.os_path_join("test","removeSentTest.txt")
c.importCommands.removeSentinelsCommand(name)
</t>
<t tx="ekr.20051104081502.105">import glob

g.pr('-' * 40)

tm = c.testManager

if 0:
    g.pr("modules in test.leo...")
    paths = tm.findAllAtFileNodes(c)
    modules = tm.importAllModulesInPathList(paths)
    for module in modules:
        g.pr(module)

if 1:
    g.pr("modules in leo/src...")
    path = g.os_path_join(g.app.loadDir,"..","src")
    modules = tm.importAllModulesInPath(path)
    for module in modules:
        g.pr(module)

if 0:
    directory = g.os_path_join(g.app.loadDir,"..","src")
    glob_path = g.os_path_join(directory,"leo*.py")
    files = glob.glob(glob_path)
    modules = tm.importAllModulesInPathList(files)
    for module in modules:
        g.pr(module)
</t>
<t tx="ekr.20051104081502.106"></t>
<t tx="ekr.20051104081502.107">import doctest
import unittest

tm = c.testManager

createUnitTest = True

if createUnitTest:
    suite = unittest.makeSuite(unittest.TestCase)
else:
    suite = None

paths   = tm.findAllAtFileNodes(c)
modules = tm.importAllModulesInPathList(paths)

if createUnitTest:
    suite = tm.createUnitTestsFromDoctests(modules)
else:
    for module in modules:
        doctest.testmod(module,verbose=True,report=False)

if suite:
    g.app.scriptDict['suite'] = suite
</t>
<t tx="ekr.20051104081502.108">for i in range(10000):
    if i and (i % 1000) == 0:
        g.pr(i)
</t>
<t tx="ekr.20051104081502.109">i = 0
for i in range(100000):
    i += 1
    i -= 1
</t>
<t tx="ekr.20051104081502.110"># c.redraw just schedules the actual drawing.
# We want to profile the actual idle-time drawing.

c.frame.tree.idle_redraw()
</t>
<t tx="ekr.20051104081502.111">@language python
@tabwidth -4
</t>
<t tx="ekr.20051104081502.112"># EKR: I don't remember the status of this.

@language python

import shutil

testing = True
sourcedir=r"c:/prog/test/perfectImport"
targetdir=r"c:/prog/test/perfectImport/leo"
s1 = g.os_path_join(sourcedir,"leoAtFile.py")
t1 = g.os_path_join(targetdir,"leoAtFile.py")
files = [(s1,t1)]

@others

g.pr('\n' + '-' * 20)
sync(files) # push or pull, depending on date.
</t>
<t tx="ekr.20051104081502.113">def sync(files):

    """Do a pull or a push, depending on the date of the files."""

    none, push, pull = 'None', 'push', 'pull'
    mu = g.mulderUpdateAlgorithm()

    for sourcefilename, targetfilename in files:
        &lt;&lt; compute sourcetime and targettime &gt;&gt;
        &lt;&lt; compute operation &gt;&gt;
        if operation == push:
            if testing: g.pr(push, sourcefilename, targetfilename)
            strippedLines = mu.removeSentinelsFromFile(sourcefilename)
            mu.write_if_changed(strippedLines,sourcefilename,targetfilename)
            mu.copy_time(sourcefilename,targetfilename)
        elif operation == pull:
            if testing: g.pr(pull, sourcefilename, targetfilename)
            if sourcetime:
                mu.propagateDiffsToSentinelsFile(sourcefilename,targetfilename)
                mu.copy_time(targetfilename,sourcefilename)
            else:
                shutil.copy2(targetfilename,sourcefilename)
</t>
<t tx="ekr.20051104081502.114">sourcetime = targettime = None

if g.os_path_exists(sourcefilename):
    sourcetime = g.os_path_getmtime(sourcefilename)

if g.os_path_exists(targetfilename):
    targettime = g.os_path_getmtime(targetfilename)
</t>
<t tx="ekr.20051104081502.115">operation = None
if sourcetime:
    if targettime:
        if sourcetime &gt; targettime:
            operation = push
        elif sourcetime &lt; targettime:
            operation = pull
    else:
        operation = push
elif targettime:
    operation = pull
</t>
<t tx="ekr.20051104081502.116"># Run this script to import a file.
# This is undoable because the Import @file command is undoable.

path = r"c:\prog\test\perfectImport"

# Two files from Python23/Lib
name1 = g.os_path_join(path,"formatter.py")
name2 = g.os_path_join(path,"SimpleHTTPServer.py")
names = [name1]

c.importCommands.importFilesCommand (names,"@file",
    perfectImport=True,testing=False,verbose=True)
</t>
<t tx="ekr.20051104081502.117"></t>
<t tx="ekr.20051104081502.118">g.pr('-'*20)

for p in c.allNodes_iter():
    if p.isDirty():
        vnodes = p.findAllPotentiallyDirtyNodes()
        g.pr('-'*5, p)
        for v in vnodes:
            g.pr(v)

g.pr("done")
</t>
<t tx="ekr.20051104081502.119">import leoNodes

position = leoNodes.position

@others

current = pos = c.p
child1 = current.firstChild()
child2 = child1.firstChild()

if 0:
    g.pr('-'*10, "parents")
    for p in child2.parents_iter(): g.pr(p)
if 0:
    g.pr('-'*10, "subtree")
    for p in pos.subtree_iter(): g.pr(p)
if 0:
    g.pr('-'*10, "children")
    for p in child1.children_iter(): g.pr(p)
if 0:
    g.pr('-'*10, "siblings")
    for p in pos.siblings_iter(): g.pr(p)
if 1:
    g.pr('-'*10, "all nodes")
    for p in c.allNodes_iter():
        g.pr(p.isCloned(),p)
</t>
<t tx="ekr.20051104081502.120"></t>
<t tx="ekr.20051104081502.121"></t>
<t tx="ekr.20051104081502.122"></t>
<t tx="ekr.20051104081502.123"></t>
<t tx="ekr.20051104081502.124"></t>
<t tx="ekr.20051104081502.125"></t>
<t tx="ekr.20051104081502.126"></t>
<t tx="ekr.20051104081502.127"></t>
<t tx="ekr.20051104081502.128"></t>
<t tx="ekr.20051104081502.129"></t>
<t tx="ekr.20051104081502.130"></t>
<t tx="ekr.20051104081502.131"></t>
<t tx="ekr.20051104081502.145">g.pr('-'*20)

for p in c.allNodes_iter():
    if p.isAnyAtFileNode():
        g.pr(p)

g.pr("done")
</t>
<t tx="ekr.20051104081502.146">tm = c.testManager

g.pr("children", '-' * 20)
children = tm.findChildrenOf(p)
for child in children: g.pr(child.h)

g.pr("subtree", '-' * 20)
descendants = tm.findSubnodesOf(p)
for descendant in descendants: g.pr(descendant.h)
</t>
<t tx="ekr.20051104081502.147">import binascii
import pickle

d = { "a":True }

g.pr('-' * 40)

s = pickle.dumps(d,bin=True)
s2 = binascii.hexlify(s)
g.pr(`s`,s2)

s3 = binascii.unhexlify(s2)
d2 = cPickle.loads(s3)

g.pr(`d2`)
g.pr(d == d2, d is d2)
</t>
<t tx="ekr.20051104081502.148">def redoBletch(self):
    g.trace()

def undoBletch(self):
    g.trace()

u = c.undoer

if 0:
    # bad functions
    u.registerUndoHandlers("Bletch","abc","xyz")
else:
    u.registerUndoHandlers("Bletch",undoBletch,redoBletch)

# "Execute" the Bletch command :-)  The Edit command should contain "Undo Bletch"
u.setUndoParams("Bletch",p)

# Selecting "Undo Bletch" will enable "Redo Bletch", etc.
</t>
<t tx="ekr.20051104081502.149">d = { "a":True }

if 1:
    # Warning: executing this in the a2 code base will cause any save operation to fail.
    p.v.unknownAttributes = { "myPlugin" : d }

g.pr(repr(p.v.unknownAttributes))
</t>
<t tx="ekr.20051104081502.150">import leoPlugins

def onEnd (tag,keys):
    g.pr("onEnd",tag,keys)

count = 0

def onIdle (tag,keys):
    global count ; count += 1
    if count % 10 == 0:
        g.pr("onIdle",count,keys.get("c"))

leoPlugins.registerHandler("end1", onEnd)
g.pr("onEnd registered as end1 hook")

leoPlugins.registerHandler("idle", onIdle)
g.pr("onIdle registered as idle hook")
</t>
<t tx="ekr.20051104081502.151">for p in c.all_positions_iter():
    g.pr(p.v.t.fileIndex)
</t>
<t tx="ekr.20051104081502.152">g.pr(c.frame.bodyCtrl.focus())
</t>
<t tx="ekr.20051104081502.153"># This kind of code is used in the prototypes of new commands.

from __future__ import generators

@others

lines = "a\nb\nc\nd"

if 1: # Both work
    readline = g.readLinesGenerator(lines).next
else:
    readline = g.readLinesClass(lines).next

g.pr('-' * 20)

if 1: # Both work
    for s in g.readLinesGenerator(lines):
        g.pr(s,)
else:
    while 1:
        s = readline()
        if s: g.pr(s,)
        else: break

g.pr('\n' + '-' * 20)
</t>
<t tx="ekr.20051104081502.154"># Test
@others
# Last
</t>
<t tx="ekr.20051104081502.155">a = 1
g.pr("hello")
c = b
</t>
<t tx="ekr.20051104081502.157">import leoTest
import types

specialDictNames = ('__builtins__','__doc__','__name__','__file__','__module__')

def printDoc(x,s):
    if hasattr(x,"__doc__") and x.__doc__:
        g.pr("%4d %s" % (len(x.__doc__),s))
    else:
        g.pr("%4s %s" % (' ',s))

g.pr('-' * 60)
g.pr("%4d %s" % (len(leoTest.__doc__),"leoTest"))

if 1:
    for s in leoTest.__dict__:
        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) != types.ModuleType:
                printDoc(x,s)
                if type(x) == types.ClassType:
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            g.pr(' '*4,)
                            printDoc(x2,s2)
else:
    &lt;&lt; print names sorted by type &gt;&gt;
</t>
<t tx="ekr.20051104081502.158">for theType,typeName in (
    (types.ModuleType,"modules"),
    (types.ClassType,"classes"),
    (types.FunctionType,"functions"),
):

    g.pr("\n%s..." % typeName)
    for s in leoTest.__dict__:

        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) == theType:
                printDoc(x,s)
                if theType == types.ClassType:
                    g.pr("\tmethods...")
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            g.pr("\t",newline=False)
                            printDoc(x2,s2)
</t>
<t tx="ekr.20051104081502.159">import Tkinter as Tk

root = Tk.Tk()
c = Tk.Canvas(root,background='white')
g.pr(c.bindtags())

if 0:
    c.pack(expand=1,fill='both')
    f = Tk.Frame(c)
    c.create_window(0,0,window=f,anchor='nw')
    f.pack_configure(fill='both',expand=1)
    body = olCreateControl(self,frame,f)
    c.on = False 
    sel = lambda event, c = c, body = body:select(event,c,body)
    ai = lambda event, c = c, body = body, colorizer = frame.body:add_item(event,c,body,colorizer.getColorizer())
    c.bind("&lt;Key&gt;",watcher,'+')
    c.bind("&lt;Key&gt;",sel,'+')
    c.bind("&lt;Key&gt;",ai,'+')
    ctags = c.bindtags()
    btags = body.bindtags()
    btags =(ctags[0],btags[0],btags[1],btags[2],btags[3])
    body.bindtags(btags)
</t>
<t tx="ekr.20051104081502.160"></t>
<t tx="ekr.20051104081502.161">for p in c.allNodes_iter():

    if hasattr(p.v.t,"unknownAttributes"):
        a = p.v.t.unknownAttributes
        iconsList = a.get("icons")
        if dict:
            a["icons"] = []
            a["lineYOffset"] = 0

c.redraw()
</t>
<t tx="ekr.20051104081502.162">p.v.t.unknownAttributes = {}
a = p.v.t.unknownAttributes

&lt;&lt; define event callbacks &gt;&gt;

path = g.os_path_join(g.app.loadDir,"..","Icons")
icon1 = g.os_path_join(path,"lt_arrow_enabled.gif")
icon2 = g.os_path_join(path,"rt_arrow_enabled.gif")

d1 = {
    "type" : "file", "file" : icon1,
    "where" : "beforeIcon",
    "yoffset" : -3,
    # "yoffset" : 5, "ypad" : -5,
    # "height" : 40, # automatically adjust headline y position.
    "xpad": 2
}

# Classes and functions can only be pickled if they are at the top level of a module.
    #"onClick" : onClick,
    #"onRightClick" : onRightClick,
    #"onDoubleClick" : onDoubleClick }

d2 = {
    "type" : "file", "file" : icon2,
    "where" : "beforeHeadline",
    "yoffset" : -3,
    "xoffset" : 2, "xpad" : -2 }

a["icons"] = [d1,d2] # [d1,d2]
a["lineYOffset"] = 3

c.redraw()
</t>
<t tx="ekr.20051104081502.163">def onClick(p=p):

    g.trace(p)

def onRightClick(p=p):

    g.trace(p)

def onDoubleClick(p=p):

    g.trace(p)
</t>
<t tx="ekr.20051104081502.164"></t>
<t tx="ekr.20051104081502.165"># Set the attribute.
d = {'str_ekr_attribute': 'abc'}
p.v.t.unknownAttributes = d
</t>
<t tx="ekr.20051104081502.166">for p in c.allNodes_iter():
    h = p.h
    if hasattr(p.v.t,'unknownAttributes'):
        d = p.v.t.unknownAttributes
        val = d.get('str_ekr_attribute')
        if val:
           g.es('str_ekr_attribute is: %s' % val)
</t>
<t tx="ekr.20051104081502.183">s = u""

g.reportBadChars(s,"latin_1")

g.pr(g.toEncodedString(s,"latin_1"))
</t>
<t tx="ekr.20051104081502.209">arg = "arg" ; filename = "fileName"
path = "path" ; shortPath = "shortPath"
vtuple = "vtuple"

def test(a,b):
    assert(a==b)

test(
    "os.system("+arg+shortPath+")",
    "os.system(%s)" % (arg+shortPath))
test(
    "os.startfile("+arg+shortPath+")",
    "os.startfile(%s)" % (arg+shortPath))
# test(
    # "exec("+arg+shortPath+")",
    # "exec(%s)" % (arg+shortPath))
test(
    "os.spawnl("+arg+","+filename+','+ shortPath+")",
    "os.spawnl(%s,%s,%s)" % (arg,filename,shortPath))
test(
    "os.spawnv("+arg[0]+","+repr(vtuple)+")",
    "os.spawnv(%s,%s)" % (arg[0],repr(vtuple)))
</t>
<t tx="ekr.20051104081502.210">@language python

# Type a period to autocomplete
leoTest

# Type an open paren to bring up calltip.
c.testManager.findAllAtFileNodes
</t>
<t tx="ekr.20051104081502.211"></t>
<t tx="ekr.20051104081502.213"></t>
<t tx="ekr.20051104081502.214"># Go To Line number now assumes that selected node is
# the root of a script if there is no ancestor @file node.

@others

# last line
</t>
<t tx="ekr.20051104081502.215"># We should also be able to use the goto line number command to get to the erroneous line.

a = 1/0 # ZeroDivisionError

b = 2
</t>
<t tx="ekr.20051104081502.216"></t>
<t tx="ekr.20051104081502.217">import leoPlugins as plugins

def traceHook(tag,event):
    g.trace(tag)

tags = (
    "boxclick1","boxclick2",
    "drag1","drag2",
    "dragging1","dragging2",
    "enddrag1","enddrag2",
    "iconclick1","iconclick2"  , 
    "iconrclick1","iconrclick2",
    "icondclick1","icondclick2",
)

plugins.registerHandler(tags,traceHook)

handlers = plugins.getHandlersForTag(tags)
if handlers:
    g.pr("-" * 20)
    for h in handlers:
        g.pr(h)
</t>
<t tx="ekr.20051104081502.218">import leoPlugins as plugins

tags = (
    "boxclick1","boxclick2",
    "drag1","drag2",
    "dragging1","dragging2",
    "enddrag1","enddrag2",
    "iconclick1","iconclick2"  , 
    "iconrclick1","iconrclick2",
    "icondclick1","icondclick2",
)

for tag in tags:
    handlers = plugins.getHandlersForTag(tag)
    if handlers:
        g.pr(handlers)
        for f in handlers:
            plugins.unregisterHandler(tag,f)

handlers = plugins.getHandlersForTag(tags)
if handlers:
    g.pr("-" * 20)
    for h in handlers:
        g.pr(h)
</t>
<t tx="ekr.20051104081502.219">import leoPlugins as plugins

tags = (
    "boxclick1","boxclick2",
    "drag1","drag2",
    "dragging1","dragging2",
    "enddrag1","enddrag2",
    "iconclick1","iconclick2"  , 
    "iconrclick1","iconrclick2",
    "icondclick1","icondclick2",
)

handlers = plugins.getHandlersForTag(tags)
if handlers:
    g.pr("-" * 20)
    for h in handlers:
        g.pr(h)
</t>
<t tx="ekr.20051104081502.22"></t>
<t tx="ekr.20051104081502.220">"""Mini test that documentation of hooks in leoDocs.leo is correct.

hookData should match that documentation for this test to be effective.

This is not a complete unit test:  it does not force executions of all hooks.
"""

&lt;&lt; imports &gt;&gt;
&lt;&lt; define hookData &gt;&gt;
&lt;&lt; define typeData &gt;&gt;
checked = [] # List of all hooks that have been checked.

@others

tags = [] 
for name,args in hookData:
    tags.append(name)
    &lt;&lt; define checkHook &gt;&gt;
    leoPlugins.registerHandler(name,checkHook)

if 0: # print all hooks.
    handlers = leoPlugins.getHandlersForTag(tags)
    if handlers:
        g.pr("-" * 20)
        for h in handlers:
            g.pr(h)
</t>
<t tx="ekr.20051104081502.221">import leoColor
import leoCommands
import leoNodes
import leoPlugins
import leoTkinterTree

import types
import Tkinter as Tk
</t>
<t tx="ekr.20051104081502.222">hookData = (
    ("bodyclick1",   ("c","p","v","event")),
    ("bodyclick2",   ("c","p","v","event")),
    ("bodydclick1",  ("c","p","v","event")),
    ("bodydclick2",  ("c","p","v","event")),
    ("bodykey1",     ("c","p","v","ch","oldSel","undoType")),
    ("bodykey2",     ("c","p","v","ch","oldSel","undoType")),
    ("bodyrclick1",  ("c","p","v","event")),
    ("bodyrclick2",  ("c","p","v","event")),
    ("boxclick1",    ("c","p","v","event")),
    ("boxclick2",    ("c","p","v","event")),
    ("command1",     ("c","p","v","label")),
    ("command2",     ("c","p","v","label")),
    ("drag1",        ("c","p","v","event")),
    ("drag2",        ("c","p","v","event")),
    ("dragging1",    ("c","p","v","event")),
    ("dragging2",    ("c","p","v","event")),
    ("end1",         None),
    ("enddrag1",     ("c","p","v","event")),
    ("enddrag2",     ("c","p","v","event")),
    ("headclick1",   ("c","p","v","event")),
    ("headclick2",   ("c","p","v","event")),
    ("headrclick1",  ("c","p","v","event")),
    ("headrclick2",  ("c","p","v","event")),
    ("headkey1",     ("c","p","v","ch")),
    ("headkey2",     ("c","p","v","ch")),
    ("hypercclick1", ("c","p","v","event")),
    ("hypercclick2", ("c","p","v","event")),
    ("hyperenter1",  ("c","p","v","event")),
    ("hyperenter2",  ("c","p","v","event")),
    ("hyperleave1",  ("c","p","v","event")),
    ("hyperleave2",  ("c","p","v","event")),
    ("iconclick1",   ("c","p","v","event")),
    ("iconclick2",   ("c","p","v","event")),
    ("iconrclick1",  ("c","p","v","event")),
    ("iconrclick2",  ("c","p","v","event")),
    ("icondclick1",  ("c","p","v","event")),
    ("icondclick2",  ("c","p","v","event")),
    ("idle",         ("c",)),
    ("menu1",        ("c","p","v")),
    ("menu2",        ("c","p","v")),
    ("open1",        ("old_c","new_c","fileName")),
    ("open2",        ("old_c","new_c","fileName")),
    ("openwith1",    ("c","p","v","openType","arg","ext")),
    ("openwith2",    ("c","p","v","openType","arg,ext" )),
    ("recentfiles1", ("c","p","v","fileName","closeFlag")),
    ("recentfiles2", ("c","p","v","fileName","closeFlag")),
    ("save1",        ("c","p","v","fileName" )),
    ("save2",        ("c","p","v","fileName" )),
    ("select1",      ("c","new_p","old_p","new_v","old_v")),
    ("select2",      ("c","new_p","old_p","new_v","old_v")),
    ("select3",      ("c","new_p","old_p","new_v","old_v")),
    ("set-mark",     ("c","p","v")),
    ("start1",       None),
    ("start2",       ("c","p","v","fileName" )),
    ("unselect1",    ("c","new_p","old_p","new_v","old_v")),
    ("unselect2",    ("c","new_p","old_p","new_v","old_v")),
    ("@url1",        ("c","p","v")),
    ("@url2",        ("c","p","v")),
    # Stub hooks.
    ("after-redraw-outline",         ("c",)),
    ("clear-mark",                   ("c","p","v")),
    ("close-frame",                  ("c",)),
    ("color-optional-markup",        ("colorer","p","v","s","i","j","colortag")),
    ("create-optional-menus",        ("c",)),
    ("destroy-all-global-windows",   None),
    ("draw-outline-box",             ("tree","p","v","x","y")), #
    ("draw-outline-icon",            ("tree","p","v","x","y")), #
    ("draw-outline-node",            ("tree","p","v","x","y")), #
    ("draw-outline-text-box",        ("tree","p","v","x","y")), #
    ("create-popup-menu-items",      ("c","p","v","event")),
    ("enable-popup-menu-items",      ("c","p","v","event")),
    ("init-color-markup",            ("colorer","p","v")),
    ("new",                          ("old_c","new_c")),
    ("redraw-entire-outline",        ("c",)),
    ("scan-directives",              ("c","p","v","s","old_dict","dict","pluginsList")),
    ("set-mark",                     ("c","p","v" )),
    ("show-popup-menu",              ("c","p","v","event")),
)
</t>
<t tx="ekr.20051104081502.223">typeData = {
    "arg":      types.StringType,
    "c":        leoCommands.Commands,
    "ch":       types.StringType,
    "closeFlag":types.StringType,
    "colorer":  leoColor.colorizer,
    "colortag": types.StringType,
    "dict":     types.DictType,
    "event":    Tk.Event,
    "ext":      types.StringType,
    "fileName": types.StringType,
    "i":        types.IntType,
    "j":        types.IntType,
    "label":    types.StringType,
    "new_c":    leoCommands.Commands,
    "new_p":    leoNodes.position,
    "newSel":   types.TupleType,
    "new_v":    leoNodes.position,
    "old_c":    leoCommands.Commands,
    "old_dict": types.DictType,
    "old_p":    leoNodes.position,
    "oldSel":   types.TupleType,
    "old_v":    leoNodes.position,
    "openType": types.StringType,
    "p":        leoNodes.position,
    "pluginsList": types.ListType,
    "s":        types.UnicodeType,
    "tree":     leoTkinterTree.leoTkinterTree,
    "v":        leoNodes.position,
    "undoType": types.StringType,
    "x":        types.IntType,
    "y":        types.IntType,
}
</t>
<t tx="ekr.20051104081502.224">def checkHook (tag,keywords,args=args):

    """Check to see that the keywords passed to the hook are as described in args.
    Each arg is a list of strings whose type is defined in typeData."""

    global checked, verbose
    if tag in checked: return
    ok = True
    checked.append(tag)
    if args is None: args = []
    args = list(args)
    args.sort()
    keys = list(keywords.keys())
    keys.sort()

    if len(args) != len(keys):
        g.pr("%25s expected:" % (tag),args)
        g.pr("%25s      got:" % (tag),keys)
        ok = False
    else:
        for arg,key in zip(args,keys):
            arg_type = typeData.get(arg)
            val = keywords.get(key)
            if not checkOneHook(arg_type,val):
                g.pr("%25s      arg:" % (tag), arg)
                g.pr("%25s expected:" % (tag), arg_type)
                g.pr("%25s      got:" % (tag), type(val))
                ok = False
    if ok:
        g.pr(tag)
</t>
<t tx="ekr.20051104081502.225">def checkOneHook (arg_type, val):

    if 0:
        if arg_type != type(val):
            g.trace(arg,key,arg_type,type(val))

    return (
        (arg_type is type(val)) or
        (arg_type == types.StringType and type(val) is types.UnicodeType) or
        (type(arg_type) == types.ClassType and isinstance(val,arg_type)))
</t>
<t tx="ekr.20051104081502.226"></t>
<t tx="ekr.20051104081502.227">g.rawPrint("Test of g.rawPrint")
g.redirectStdout()
g.rawPrint("Test of g.rawPrint")
g.restoreStdout()
</t>
<t tx="ekr.20051104081502.23">class position:
    def __init__(self):
        self.v = "a"
    def move(self):
        self.v = "b"

p = position()
v = p.v
g.pr("before", v, p.v, v is p.v)
p.move()
g.pr("after ", v, p.v, v is p.v)
</t>
<t tx="ekr.20051104081502.232">g.pdb()
</t>
<t tx="ekr.20051104081502.233">g.pr(g.app.debugSwitch)

g.app.debugSwitch = 0 # 2: drop into pdb

zerodivide = 1 / 0
</t>
<t tx="ekr.20051104081502.234">g.pr(c)
g.pr('use_plugins',c.use_plugins)
g.pr('tab_width',c.tab_width)
g.pr('page_width',c.page_width)
</t>
<t tx="ekr.20051104081502.24">class test_iter_class:
    def __init__ (self):
        self.vals = ("a","b","c")
        self.n = 0
    def __iter__(self):
        return self
    def next(self):
        if self.n &lt; len(self.vals):
            val = self.vals[self.n]
            self.n += 1
            return val
        else:
            raise StopIteration

def test_iter(): return test_iter_class()

vals = [val for val in test_iter()]

g.pr(vals)
</t>
<t tx="ekr.20051104081502.25">g.pr('-'*20)

# These are equivalent.
positions1 = [p for p in c.allNodes_iter(copy=True)]
positions2 = [p.copy() for p in c.allNodes_iter()]

assert(len(positions1) == len(positions2))
for i in range(len(positions1)):
    assert(positions1[i] == positions2[i])

if 0:
    for p in positions1:
        g.pr(p)
g.pr("done")
</t>
<t tx="ekr.20051104081502.26">g.pr('-'*20)

positions = [p.copy() for p in c.allNodes_iter()]

tnodes = {} ; vnodes = []
for p in c.allNodes_iter():
    t = p.v.t
    if tnodes.get(t) is None:
        tnodes[t]=t
        vnodes.append(p.v)

g.pr(len(positions),len(vnodes))

for v in vnodes:
    g.pr(v)
</t>
<t tx="ekr.20051104081502.272"></t>
<t tx="ekr.20051104081502.273">import glob,sys,traceback

def printModules():
    mods = sys.modules.keys()
    mods.sort()
    for mod in mods: g.pr(mod)

def leoModules():
    files = glob.glob(r'%s\*.py' % g.app.loadDir)
    modules = []
    for file in files:
        path,file = g.os_path_split(file)
        module,ext = g.os_path_splitext(file)
        if g.match(module,0,'leo'):
            modules.append(module)
    return modules

def delLeoModules():
    for module in leoModules():
        if module in sys.modules:
            del sys.modules[module]

def test():
    for module in leoModules():
        g.pr(module)
        exec 'import %s' % module in {},{}
        del sys.modules[module]

delLeoModules()        
test()
# printModules()
</t>
<t tx="ekr.20051104081502.274">def test():
    '''Tests whether all files can be imported.'''
    import glob, os, sys, traceback
    dir = r'c:\prog\leoCVS\leo\src'
    files = glob.glob(r'%s\*.py' % dir)
    modules = []
    for file in files:
        path,file = os.path.split(file)
        module,ext = os.path.splitext(file)
        if module[:3] == 'leo':
            modules.append(module)
    for module in modules:
        g.pr(module)
        try:
            exec 'import %s' % module in {},{}
            del sys.modules[module]
        except:
            traceback.print_exc()

def printModules():
    import sys
    mods = sys.modules.keys()
    mods.sort()
    for mod in mods: g.pr(mod)

</t>
<t tx="ekr.20051104081502.28">stack1 = ["a","b","c"]
stack2 = ["a","b","c"]
stack3 = ["a","b","d"]
stack4 = ["a","b"]
g.pr(stack1 == stack2)
g.pr(stack1 == stack3)
g.pr(stack1 == stack4)
</t>
<t tx="ekr.20051104081502.29">g.pr(p.h)
g.pr(p.childIndex())
g.pr(p.h)
</t>
<t tx="ekr.20051104081502.30">import timeit

s1 = '''\
class test(object):
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s2 = '''\
class test:
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s3 = '''\
import leoNodes
p1 = leoNodes.position(None,[])
p2 = leoNodes.position(None,[])'''

for s in (s1,s2,s3):
    t1 = timeit.Timer(stmt='p1==p2',setup=s).timeit()
    t2 = timeit.Timer(stmt='p1.equal(p2)',setup=s).timeit()
    g.pr("%2.2f,%2.2f,%0.2f" % (t1,t2,t1/t2))
</t>
<t tx="ekr.20051104081502.305">stuff = g.toEncodedString(u'','utf-8')
g.pr(type(stuff))
g.pr('*' * 10)
for ch in stuff:
    g.pr(ch, ord(ch),newline=False)
g.pr()
</t>
<t tx="ekr.20051104081502.307">g.es(c.redirect_execute_script_output_to_log_pane)
g.es(c.config.redirect_execute_script_output_to_log_pane)
g.pr('hello')

#assert c.redirect_execute_script_output_to_log_pane is True
#assert c.config.redirect_execute_script_output_to_log_pane is True
</t>
<t tx="ekr.20051104081502.31"># "LPT1:", "PRN:" and "PRN" all freeze

s = 'stuff\n'
port = 'USB002'

try:
    f = file(port,'w')
    f.write(s)
    f.flush()
    f.close()
    g.pr("done")
except IOError:
    g.pr("Can not open",port)
</t>
<t tx="ekr.20051104081502.311"># Running this as a unit test would hang the unit tests!
g.pdb()
</t>
<t tx="ekr.20051104081502.312">try:
    assert False, 'Assert False'
except AssertionError:
    g.es_exception()
</t>
<t tx="ekr.20051104081502.315"># Comment

g.pr(z)
</t>
<t tx="ekr.20051104081502.316">c.testManager.throwAssertionError()
</t>
<t tx="ekr.20051104081502.318">table = ('spawnv',None,(
    'os.spawnv',[
    r'c:\vim\vim63\gvim.exe',
    ' --servername LEO ',
    ' --remote-silent ',
    ],
    ".py")),

c.frame.menu.createOpenWithMenuFromTable(table)
</t>
<t tx="ekr.20051104081502.32">@ By far the simplest way is just to write the string to a temp file, then import the temp files.

All other approaches quickly get deeply involved with Leo's internals...
</t>
<t tx="ekr.20051104081502.320">@nowrap
aaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbb cccccccccccccccccccc ddddddddddddddd eeeeeeeeeeeeeee ffffffffffffffff 
</t>
<t tx="ekr.20051104081502.321"># To run this test, set @bool redirect_execute_script_output_to_log_pane = True in the @settings tree.

g.pr('hi')
g.pr(c.config.redirect_execute_script_output_to_log_pane)
g.pr(c.xyzzy)
</t>
<t tx="ekr.20051104081502.322">@language html
</t>
<t tx="ekr.20051104081502.323">g.pr('-'*20)
g.pr(g.getScript(c,p,forcePythonSentinels=False))
</t>
<t tx="ekr.20051104081502.324">&lt;body&gt;
@others
&lt;/body&gt;
</t>
<t tx="ekr.20051104081502.325">This is a body
</t>
<t tx="ekr.20051104081502.326">@nocolor
@pagewidth 100
@language python
</t>
<t tx="ekr.20051104081502.327">@language python

@ @rst-options
code_mode = False
show_leo_directives = True
number_code_lines = False
@c

#########################
ListManager Documentation
#########################

:Author: Steven Zatz, Modified by EKR.
:Contact: slzatz@hotmail.com
:Date: $Date: 2008/02/14 14:59:04 $
:Status: This is a "work in progress"
:Revision: $Revision: 1.247 $
:Copyright: Application and documentation use the Python license which is compatible with the GPL. 

This is experimental documentation of a program called ListManager, written in
Python and wxPython using Leo to create both the application code and the
associated reST documentation.

ListManager is an application that allows a group of people working on a joint
project to maintain a common list of todos and related items that have owners,
due dates and associated notes. The application uses mysql as its database for
group use and also uses sqlite for locally resident databases for personal
lists. It works in conjunction with Outlook to allow email messages to be sent
to ListManager for inclusion in lists and uses Outlook to mail messages to
users.

.. contents:: Table of Contents
</t>
<t tx="ekr.20051104081502.328">@language python
@color
@others

@ @rst-options
code_mode = True
@c
</t>
<t tx="ekr.20051104081502.329">@ @rst-markup

Nothing unusual in what follows:  we start with the module imports, setting some global constants including Menu Ids and read the ListManager.ini file.
</t>
<t tx="ekr.20051104081502.33">@language plain

The first idea was to use Python's imp module to simulate an import from a file.  This does not work well because imp expects a file, not a StringIO object.

The second idea was to use Python's parser module.  But this returns an instance type, not a module.

A third idea would be to subclass the file type to fool the imp module.

A fourth idea would be to use the ihooks module.  Apparently this module was designed to do something like what I am trying to do!  However, there doesn't seem to be docs for it, so I have imported the code...

@color
</t>
<t tx="ekr.20051104081502.330">from wxPython.wx import *
from wxPython.lib.mixins.listctrl import wxListCtrlAutoWidthMixin

import os
import time
import pickle
import socket
import select
import random
import ConfigParser
import threading
import re
import sys

from pywintypes import CreateGuid
from win32com.client import Dispatch
#import win32pdh
import win32api
#from win32com.client import constants #--&gt; just needed two constants...

import MySQLdb
import sqlite
import mx.DateTime

from LMDialogs import CalendarDialog, ModifierDialog, TicklerDialog, MailDialog,LoggerDialog, FinishedDialog, FindDialog, EvalDialog, TreeDialog, StartupDialog
#from wxTreeCtrl import TreeDialog

from printout import PrintTable
</t>
<t tx="ekr.20051104081502.331">@nocolor

os
    uses ``os.getcwd``, ``os.path.split``, ``os.chdir``, ``os.path.join``, ``os.path.getmtime``, ``os.startfile``, ``os.environ``

time
    uses ``time.sleep``, ``time.asctime``

pickle
    used to serialize data that is moved from Outlook to ListManager via sockets.  

socket
    as noted above, a socket is opened between Outlook and ListManager to move messages back and forth

select
    ListManager selects on the socket to see if there is a message that has been queued by Outlook

random
    used by the reminder popup to select messages

ConfigParser
    not surprisingly, using ConfiParser to parse the ListManager.ini file.  

threading
    more for fun than absolute necessity, a thread is opened on starting the program that constructs the list of owners for items.  In theory, if the datasize and number of Lists were large enough it could delay the appearance of the GUI and its initial responsiveness if we didn't construct the ownerlist in a thread.  On the other hand, it really let me play with threads and with creating a custom event that signalled the construction of the owner list to the main thread by posting a custom event.

re
    mainly using ``re.sub('[\\/:*"&lt;&gt;|\?]','-',f)`` to make sure that files are constructed only with legal characters.  Also searching the body text of nodes using re because it allows case insensitive searches through ``re.compile(pat, re.I)``.

pywintypes.CreateGuid
    probably should use pure python GUID that is in ASPN cookbook but it was easiest to just use the Windows GUID function.  Thank you Mark Hammond for win32all.

win32com.client.Dispatch
    used when launching Outlook to send email messages

win32api
    using win32api.GetUserName() in case there is no user name in the ini file or no ini file

MySQLdb
    using Andy Dustman's python extension module to connect to mysql back-end.

sqlite
    using  D. Richard Hipp's python extension to connect to local sqlite databases

import mx.DateTime
    using Marc-Andr Lemburg's mx.DateTime for dealing with datetime stuff in the databases

CalendarDialog, ModifierDialog, TicklerDialog, MailDialog,LoggerDialog, FinishedDialog, FindDialog, EvalDialog, TreeDialog, StartupDialog
   should just import LMDialogs and then access each dialog class by LM.WhateverDialog

printout.PrintTable
    There was an existing wxPython print module for printing from tables that I have modified to print Lists.

*#from win32com.client import constants*
    probably not wise but since the app only needs two constants from this module, just set the directly.  If MSFT decides to change the api, this is not good.
</t>
<t tx="ekr.20051104081502.332">cwd = os.getcwd()
DIRECTORY = os.path.split(cwd)[0]
os.chdir(DIRECTORY)
del cwd

#Outlook Constants
olMailItem = 0x0
olFlagMarked = 0x2

OFFLINE_ONLY = False #False-&gt; Online only  ; True-&gt; Online and Offline possible; REMOTE_HOST = None -&gt; Offline only

VERSION = '1.02'

@ @rst-markup

The following two global constants are needed to create emails through Outlook via COM::

    olMailItem = 0x0
    olFlagMarked = 0x2

For some reason, it seemed easier to just include them explicitly rather than worrying about generating all the Outlook constants in order to use early binding.  I supppose if MSFT changes the api, that would be a problem.
</t>
<t tx="ekr.20051104081502.333">@ @rst-markup
Menu Ids -- not much more to say although there should be something to say.
@c

#File Menu-----------------#
idNEWLIST = 1000
idOPENLIST = 1010
idCLOSELIST = 1015
idCLOSEALL = 1017
idSAVEAS = 1020
idDELETELIST = 1025
idPAGESETUP = 1030
idPRINT = 1035
idPRINTPREV = 1040
idMAILLIST = 1045
idOFFLINE = 1048
idEXIT = 1050

#Edit Menu-----------------
idCUT = 1055
idCOPY = 1060
idPASTE = 1065
idDELETEITEMS = 1070
idCOMBINEITEMS = 1075
idFIND = 1080

#Item Menu-------------------
idNEWITEM = 1085
idTOGGLEFINISHED = 1090
idEDITOWNER = 1095
idDUEDATE = 1100
idEDITNOTE = 1105
idMAILITEM =1110

#Diplay Menu---------------------
idSHOWFINISHED = 1115
idSHOWALL = 1120
idREFRESH = 1125
idDISPLAYDATE = 1130

#Tool Menu------------------------
idTICKLERACTIVE = 1135
idSHOWNEXT = 1140
idSYNC = 1145
idARCHIVE = 1150
idEVALUATE = 1155
idTOOLPRINT = 1165
idSENDTO = 1170

#Help Menu-------------------------
idABOUT = 1175
idHELP = 1180


</t>
<t tx="ekr.20051104081502.334">config_file = os.path.join(DIRECTORY, "List Manager.ini")
defaults = dict(pw='python', db='listmanager', ext='txt', local='wxLMDB:sqlite', x='700', y='400')
cp = ConfigParser.ConfigParser(defaults=defaults)
cp.read(config_file) #ConfigParser closes the file

USER = cp.has_option('User','user') and cp.get('User','user') or win32api.GetUserName()

# the following all have default values provided in the constructor
PW = cp.get('User','pw')
DB = cp.get('Database','db')
NOTE_EXT = cp.get('Note','ext')
LOCAL_HOST = cp.get('Hosts','local')
X = cp.getint('Configuration','x')
Y = cp.getint('Configuration','y')

# the folloowing default to None
MAIL_LIST_PATH = cp.has_option('Mail','path') and cp.get('Mail','path') or None
QUICK_LIST = cp.has_option('User','quicklist') and cp.get('User','quicklist') or None

# the following default to False
STARTUP_DIALOG = cp.has_option('User','startup_dialog') and cp.getboolean('User','startup_dialog')
DELETE_LIST = cp.has_option('User','delete_list') and cp.getboolean('User','delete_list')
OUTLOOK = cp.has_option('Mail','outlook') and cp.getboolean('Mail','outlook')

if cp.has_option('Hosts','remote'):
    REMOTE_HOST = cp.get('Hosts','remote')
else:
    REMOTE_HOST = None
    OFFLINE_ONLY = True

# reading it again because of the way defaults are handled
cp = ConfigParser.ConfigParser()
cp.read(config_file) #ConfigParser closes the file

if cp.has_section('Synchronization'):
    SYNC_TABLES = [t[1] for t in cp.items('Synchronization')]
else:
    SYNC_TABLES = ['follow_ups']

</t>
<t tx="ekr.20051104081502.335">@nocolor

.. sidebar:: A typical *List Manager.ini* file:

    ::

        [Files]
        path0 = wxLMDB:sqlite:mine
        path1 = nycpsszatzsql:mysql:follow_ups

        [Database]
        db = listmanager

        [Note]
        ext = txt

        [Synchronization]
        sync2 = follow_ups
	sync1 = test

        [Hosts]
        remote = nycpsszatzsql:mysql
        local = wxLMDB:sqlite

        [User]
        startup_dialog = true
        user = szatz
        pw = python

        [Mail]
	outlook = true
	path = wxLMDB:sqlite:mail_transfer

        [Configuration]
        y = 642
        x = 975

Application uses the ``ConfigParser`` module ito parse the ini file.  Unfortunately, ``ConfigParser`` doesn't work exactly like I think it should although it has been improved in 2.3.  My main issue is in the handling of default options.  The default options specified through the constructor show up in every section.  For example, if you use the items(*section*) method
then in addition to returning a list of tuples with whatever option/value pairs exist in the section, the list will include all the default option/value pairs, which does not make a whole lot of sense to me.  At the least, there should be a 'nodefaults' argument whose default was *False* but which could be set to *True*.  The following methods should have this option:

- items
- options
- has_option

In any event, because a nodefaults option does not exist, I create the ConfigParser object twice -- once with default options and once without them.  

The application will work fine if there is no ini file. In an effort to save some typing but not be too obscure, many of the options are read such that they default to the correct value either through explicit defaults in the constructor or statements that evaluate to *None* or *False*.

    ``QUICK_LIST = cp.has_option('User','quicklist') and cp.get('User','quicklist') or None``

    ``OUTLOOK = cp.has_option('Mail','outlook') and cp.getboolean('Mail,'outlook')``
</t>
<t tx="ekr.20051104081502.336">class ListManager(wxFrame):
    @others

@ @rst-markup

ListManager is the main class in the application and is a sublass of ``wxFrame``, which is typical for a wxPython application.  From a GUI standpoint, the main child window of the ListManager object is a ``wxNoteBook`` object that holds one ``wxListCtrl`` per notebook page and one ``wxListBox``.  The ``wxListCtrl``\s display item information (e.g., name of the item, owners of the item, etc.) for a particular List and the ``wxListBox``\es displays a list of owners that is used to filter the items displayed by the ``wxListCtrl`` object.

Each ``wxListCtrl`` object has its own set of events that it is hooked to (see CreateNewNotebookPage`&lt;&lt; ListControl Events &gt;&gt;`_.
</t>
<t tx="ekr.20051104081502.337"></t>
<t tx="ekr.20051104081502.338">def __init__(self, parent, id, title, size):
    wxFrame.__init__(self, parent, id, title, size = size)

    self.SetIcon(wxIcon('bitmaps//wxpdemo.ico', wxBITMAP_TYPE_ICO))
    self.CreateStatusBar()

    &lt;&lt; ListManager Attributes &gt;&gt;
    &lt;&lt; Menu Setup &gt;&gt;
    &lt;&lt; Toolbar Setup &gt;&gt;
    &lt;&lt; Menu/Toolbar Events &gt;&gt;
    &lt;&lt; Create Controls&gt;&gt;
    &lt;&lt; Layout Stuff &gt;&gt;
    &lt;&lt; Other Events &gt;&gt;
    &lt;&lt; GUI Instance Objects &gt;&gt;
    &lt;&lt; Create Socket &gt;&gt;
    &lt;&lt; Load Recent Files &gt;&gt;
    &lt;&lt; Idle Timer &gt;&gt;

    ownerthread = threading.Thread(target=self.createownerlist)
    ownerthread.start()
    self.ModifierDialog = None

</t>
<t tx="ekr.20051104081502.339">@nocolor

The ListManager ``__init__`` method is pretty straightforward.  The ``__init__`` arguments are the ones that need to be passed to ``wxFrame __init__`` method. The wxFrame class has the following form:

    ``wxFrame(parent, id, title, pos=wxDefaultPosition, size=wxDefaultSize, style=wxDEFAULT_FRAME_STYLE, name="frame")``

The default style (``wxDEFAULT_FRAME_STYLE``) includes ``wxMINIMIZE_BOX``, ``wxMAXIMIZE_BOX``, ``wxRESIZE_BORDER``, ``wxSYSTEM_MENU``, ``wxCAPTION`` (the latter is the text that appears in the title bar).

``SetIcon`` is a method of ``wxFrame`` that sets the icon in the upper left of the title bar of the frame.  The wxIcon class has the following form:

    ``wxIcon(filename, type, desiredWidth=-1, desiredHeight=-1)``

``CreateStatusBar`` is a method of ``wxFrame``. The wxPython form is:

        ``CreateStatusBar(number=1, style=0, id=-1)``

*number* --&gt;
    number of fields to create. Specify a value greater than 1 to create a multi-field status bar.

``CreateStatusBar`` needs to be called before &lt;&lt; Load Recent Files &gt;&gt;.

The various sections of ``__init__`` are explained in their corresponding section::

    &lt;&lt; ListManager Attributes &gt;&gt;
    &lt;&lt; Menu Setup &gt;&gt;
    &lt;&lt; Toolbar Setup &gt;&gt;
    &lt;&lt; Menu/Toolbar Events &gt;&gt;
    &lt;&lt; Create Controls&gt;&gt;
    &lt;&lt; Layout Stuff &gt;&gt;
    &lt;&lt; Other Events &gt;&gt;
    &lt;&lt; GUI Instance Objects &gt;&gt;
    &lt;&lt; Create Socket &gt;&gt;
    &lt;&lt; Load Recent Files &gt;&gt;
</t>
<t tx="ekr.20051104081502.34">import imp
import StringIO

@
load_module( name, file, filename, description) 

Load a module that was previously found by find_module() (or by an otherwise conducted search yielding compatible results). This function does more than importing the module: if the module was already imported, it is equivalent to a reload()! The name argument indicates the full module name (including the package name, if this is a submodule of a package). The file argument is an open file, and filename is the corresponding file name; these can be None and '', respectively, when the module is not being loaded from a file. The description argument is a tuple, as would be returned by get_suffixes(), describing what kind of module must be loaded. 
If the load is successful, the return value is the module object; otherwise, an exception (usually ImportError) is raised. 

Important: the caller is responsible for closing the file argument, if it was not None, even when an exception is raised. This is best done using a try ... finally statement.
@c

s = """

def foobar(): pass

"""

@ get_suffixes( ) 

Return a list of triples, each describing a particular type of module. Each triple has the form (suffix, mode, type), where suffix is a string to be appended to the module name to form the filename to search for, mode is the mode string to pass to the built-in open() function to open the file (this can be 'r' for text files or 'rb' for binary files), and type is the file type, which has one of the values PY_SOURCE, PY_COMPILED, or C_EXTENSION, described below.
@c

g.pr('-' * 20)
description = (".py","r",imp.PY_SOURCE)
theFile = StringIO.StringIO(s) # Create a file-like object
g.pr(repr(theFile))
try:
    imp.load_module("myModule",theFile,"myFileName",description)
except:
    g.es_exception()



</t>
<t tx="ekr.20051104081502.340">self.PropertyDicts = []
self.ItemLists = []
self.ListCtrls = []
self.OwnerLBoxes = []

self.L = -1
self.curIdx = -1

self.printdata = wxPrintData()
self.printdata.SetPaperId(wxPAPER_LETTER)
self.printdata.SetOrientation(wxPORTRAIT)

#self._options = {} #would be used in loadconfig

self.copyitems = []    
self.modified = {}
self.tickler_active = False

#there is a wxPanel in the AddListControl method so each wxListCtrl has a different panel as parent
#there is a nb_sizer = wxNotebookSizer(nb) class but doesn't seem to make any difference

self.editor = []

self.Cursors = {}
self.sqlite_connections = []
self.popupvisible = False
self.in_place_editor = None
self.showrecentcompleted = 0

self.LC_font = wxFont(9, wxSWISS, wxNORMAL, wxNORMAL)

self.date_titles = {'createdate':"Create Date",'duedate':"Due Date",'timestamp':"Last Modified",'finisheddate':"Completion Date"}
self.attr2col_num = {'priority':0, 'name':1,'owners':2, 'date':3}

self.FindDialog = FindDialog(self, "Find...", "")
self.EvalDialog = EvalDialog(self, "Evaluate...", "")
</t>
<t tx="ekr.20051104081502.341">@nocolor

self.PropertyDicts
    list of dictionaries that describe properties of each ListManager List (note that when referring to a collection of ListManager items a capital *L* List and table are used interchangeably).

self.ItemLists
    list of lists that consist of instance objects of class ``Item``.  Each of the lists contained in self.ItemLists correspond to the items that are being displayed in the ListCtrl.  So ``self.Itemlist[2]`` corresponds to the 2nd tab of the notebook and to the items in self.ListCtrls[2].

The class ``Item`` is just an empty class being used as a convenience to hold item attributes::

    class Item:
        pass

The purpose of the class is just to create an object that can have various attributes as follows:

+-----------------+----------------------------------------------------+
|item.id          |GUID                                                |
+-----------------+----------------------------------------------------+
|item.name        |string that describes the item                      |
+-----------------+----------------------------------------------------+
|item.priority    |integer ranging from 1 (high) to 3 (low)            |
+-----------------+----------------------------------------------------+
|item.owners      |list of the form ["Zatz, Steve", "Hoffman, Steve"]  |
+-----------------+----------------------------------------------------+
|item.note        |string that provides additional info on item        |
+-----------------+----------------------------------------------------+
|item.timestamp   |timestamp indicating when an item was last modified |
+-----------------+----------------------------------------------------+
|item.duedate     |default is None; mx.DateTime date                   |
+-----------------+----------------------------------------------------+
|item.createdate  |mx.DateTime.now() mx.DateTime timestamp             |
+-----------------+----------------------------------------------------+
|item.finisheddate|efaut is None; mx.DateTime date                     |
+-----------------+----------------------------------------------------+

self.ListCtrls
    list of of instance objects of class ListCtrls, which are a subclass of wxPython class wxListCtrl.

self.OwnerLBoxes
    list of of instance objects of wxPython class wxListBox, which is a simple one column List Control.

The wxPython constructor for a wxListBox is:

    ``wxListBox(parent, id, pos=wxDefaultPosition, size=wxDefaultSize, choices=[], style=0)``

self.L
    index of the currently active notebook tab.  If there are any tabs in the notebook then one of them is always selected.  If there are no tabs then this is indicated by setting ``self.L = -1``.

self.curIdx
    currently selected row in the active ``ListCtrl``.  There are times like after a row is deleted in which there may be rows visible but no row is selected.

The following lines set the default printer data::

    self.printdata = wxPrintData()
    self.printdata.SetPaperId(wxPAPER_LETTER)
    self.printdata.SetOrientation(wxPORTRAIT)


The wxPython class ``wxPrintData`` holds a variety of information related to printers and printer device contexts. This class is used to create a wxPrinterDC and a wxPostScriptDC. It is also used as a data member of wxPrintDialogData and wxPageSetupDialogData, as part of the mechanism for transferring data between the print dialogs and the application.

self.copyitems
    list that contains item instance objects that have been copied from one list to be moved to another list.

self.modified
    dictionary that contains the information concerning whether any of several elements have been changed.  Chose a dictionary more to test the idea that I could create a simple method that would update the dictionary and here is an example:

    ``EVT_TEXT(self, self.name.GetId(), lambda e: self.modified.update({'name':1}))``

So this lambda function means that if an ``EVT_TEXT`` event occurs then update the dictionary by adding the key to the dictionary (the value is not used and arbitrarily set to 1).  The wxPython form for the macro ``EVT_TEXT`` is:

    ``EVT_TEXT(window, id, func)``

A ``wxEVT_COMMAND_TEXT_UPDATED`` event is generated when the text in a ``wxTextCtrl`` changes and that is what ``EVT_TEXT`` catches. Note that this event will always be sent when the text controls content changes - whether this is due to user input or comes programmatically (for example, if ``SetValue()`` is called)

self.Cursors
    dictionary that holds the database cursor objects.  For example, it will look like:  ``{'sqlite':&lt;sqlite cursor object&gt;,'nycpsltszatz':&lt;mysql cursor object&gt;}``

self.tickler_active
    booean determines whether the tickler capabililty is active; can be shut off by unchecking Tickler menu item

self.editor
    list that holds the dictionaries that describe the notes that are edited by the external text editor::

        [
        {
        'table': 'mine',
        'host': 'wxLMDB:sqlite',
        'path': 'C:\\DOCUME~1\\STEVEN~1\\LOCALS~1\\Temp\\Journal Scan schedule.txt',
        'id': '1AB34FB9-9EE6-4AFC-8AF0-FFCA50103BF3',
        'time': 1070850894
        }, 
        {
        'table': 'factoids',
        'host': 'wxLMDB:sqlite',
        'path': 'C:\\DOCUME~1\\STEVEN~1\\LOCALS~1\\Temp\\How many cme programs are sponsored- - 91%.txt', 
        'id': '9CAC4D18-DE1C-4535-B9A5-4CDB1AD3F304', 
        'time': 1070850908
        }
        ]

The method that uses self.editor is `&lt;&lt; Check if Edited File has Changed &gt;&gt;`_.

There is a ``wxPanel`` in the ``AddListControl`` method so each ``wxListCtrl`` has a different panel as parent.

There is a nb_sizer = wxNotebookSizer(nb) class but doesn't seem to make any difference.

self.sqlite_connections
    Here because the sqlite connection has a weakreference that deletes it when you want it around

self.popupvisible
    boolean that is used to ensure that two reminder popups aren't visible at the same time.

self.in_place_editor 
    boolean that indicates whether the inplace item name text editor is active or not.

self.showrecentcompleted
    integer that determines the number of days in the past to retain completed items in the display.

self.LC_font
    default font for all of the ``ListCtrls``:  ``self.LC_font = wxFont(9, wxSWISS, wxNORMAL, wxNORMAL)``

The wxPython ``wxFont`` constructor is:

    ``wxFont(pointSize, family, style, weight, underline=False, faceName="", wencoding=wxFONTENCODING_DEFAULT)``

self.date_titles
    dictionary that holds the various dates that are associated with each item and which can be displayed in the date column.  The dictionary is not modified.  We use one column of each ``ListCtrl`` to display any one of the four dates that that the application tracks. This dictionary associates the item attribute with the text that will be displayed in both the column header for the date and in the dropdown that allows you to change the date:  ``self.date_titles = {'createdate':"Create Date",'duedate':"Due Date",'timestamp':"Last Modified",'finisheddate':"Completion Date"}``

self.attr2col_num
    dictionary that associates the item attribute with the column that attribute is displayed in in the ``ListCtrl``:  ``self.attr2col_num = {'priority':0, 'name':1,'owners':2, 'date':3}``

The following lines construct the Find Dialog and the Dialog that catches errors and shows expressions for debugging::

    self.FindDialog = FindDialog(self, "Find...", "")
    self.EvalDialog = EvalDialog(self, "Evaluate...", "")
</t>
<t tx="ekr.20051104081502.342">filemenu = wxMenu()
filemenu.Append(idNEWLIST, "New List...", "Create a new List")
filemenu.Append(idOPENLIST, "Open List...", "Open a List")
filemenu.Append(idCLOSELIST, "Close", "Close the current List")
filemenu.Append(idCLOSEALL, "Close All", "Close all open Lists")
filemenu.Append(idSAVEAS, "Save As Text File...", "Save the current List")
filemenu.AppendSeparator()
filemenu.Append(idDELETELIST, "Delete List...", "Select a list to delete")
filemenu.AppendSeparator()
filemenu.Append(idPAGESETUP, "Page Setup...")
filemenu.Append(idPRINT, "Print...", "Print the current view")
filemenu.Append(idPRINTPREV, "Print Preview")
filemenu.AppendSeparator()
filemenu.Append(idMAILLIST, "Mail...", "Mail the current view")
filemenu.AppendSeparator()
filemenu.AppendCheckItem(idOFFLINE, "Work Offline")
filemenu.AppendSeparator()
filemenu.Append(idEXIT, "Exit", "Exit the program")

editmenu = wxMenu()
editmenu.Append(idCUT, "Cut\tCtrl+X")
editmenu.Append(idCOPY, "Copy\tCtrl+C")
editmenu.Append(idPASTE, "Paste\tCtrl+V")
editmenu.AppendSeparator()
editmenu.Append(idDELETEITEMS, "Delete")
editmenu.AppendSeparator()
editmenu.Append(idCOMBINEITEMS, "Combine Items...")
editmenu.AppendSeparator()
editmenu.Append(idFIND, "Find...")

itemmenu = wxMenu()
itemmenu.Append(idNEWITEM, "New Item")
itemmenu.AppendSeparator()
itemmenu.Append(idTOGGLEFINISHED, "Toggle Finished")
itemmenu.Append(idEDITOWNER, "Owner...")
itemmenu.Append(idDUEDATE, "Due Date...")
itemmenu.Append(idEDITNOTE, "Note...")
itemmenu.AppendSeparator()
itemmenu.Append(idMAILITEM, "Mail...")

displaymenu = wxMenu()
displaymenu.Append(idSHOWFINISHED, "Show/Hide Finished...")
displaymenu.AppendSeparator()
displaymenu.Append(idSHOWALL, "Show All", "Show all items in the current list")
displaymenu.AppendSeparator()
displaymenu.Append(idREFRESH, "Refresh Display", "Refresh the Display")
displaymenu.Append(idDISPLAYDATE, "Select Date to Display")

toolmenu = wxMenu()
toolmenu.AppendCheckItem(idTICKLERACTIVE, "Tickler Active")
toolmenu.Check(idTICKLERACTIVE,False)
toolmenu.Append(idSHOWNEXT, "Show Next Reminder")
toolmenu.Append(idSYNC, "Synchronize local and remote DBs")
toolmenu.Append(idARCHIVE, "Archive completed items in list...")
toolmenu.Append(idEVALUATE, "Evaluate an expression...")

helpmenu = wxMenu()
helpmenu.Append(idABOUT, "About ListManager")
helpmenu.Append(idHELP, "Help")

menubar = wxMenuBar()
menubar.Append(filemenu, '&amp;File')
menubar.Append(editmenu, 'Edit')
menubar.Append(itemmenu, 'Item')
menubar.Append(displaymenu, 'Display')
menubar.Append(toolmenu, 'Tools')
menubar.Append(helpmenu, 'Help')
self.SetMenuBar(menubar)
toolmenu.Enable(idSHOWNEXT,self.tickler_active)
filemenu.Enable(idDELETELIST,DELETE_LIST)
filemenu.Check(idOFFLINE,OFFLINE_ONLY)

#file history
self.filehistory = wxFileHistory()
self.filehistory.UseMenu(filemenu)

</t>
<t tx="ekr.20051104081502.343">@nocolor

+------------------------+------------------------------------------------+
|**File Menu**           |                                                |
+------------------------+------------------------------------------------+
| "New List... "         ||nl| ``self.OnNewList``                         |
+------------------------+------------------------------------------------+
| "Open List..."         ||ol| ``self.OnOpenList``                        |
+------------------------+------------------------------------------------+
| "Close"                |``self.OnCloseList``                            |
+------------------------+------------------------------------------------+
| "Close All"            |``self.OnCloseAll``                             |
+------------------------+------------------------------------------------+
| "Save As Text File..." |``self.OnSaveAsText``                           |
+------------------------+------------------------------------------------+
| "Delete List..."       ||de| ``self.OnDeleteList``                      |
+------------------------+------------------------------------------------+
| "Page Setup..."        ||ps| ``self.OnPageSetup``                       |
+------------------------+------------------------------------------------+
| "Print..."             ||pt| ``self.OnPrint``                           |
+------------------------+------------------------------------------------+
| "Print Preview"        ||pp| ``lambda e: self.OnPrint(e, prev=True)``   |
+------------------------+------------------------------------------------+
| "Mail..."              |``self.OnMailView``                             |
+------------------------+------------------------------------------------+
| "Work Offline"         |``self.OnWorkOffline``                          |
+------------------------+------------------------------------------------+
| "Exit"                 |``self.OnExit``                                 |
+------------------------+------------------------------------------------+
| **Edit Menu**          |                                                |
+------------------------+------------------------------------------------+
| "Cut" [Ctrl+X ]        ||ec| ``lambda e: self.OnCopyItems(e, cut=True)``|
+------------------------+------------------------------------------------+
| "Copy" [Ctrl+C]        ||ey| ``self.OnCopyItems``                       |
+------------------------+------------------------------------------------+
| "Paste" [Ctrl+V]       ||ep| ``self.OnPasteItems``                      |
+------------------------+------------------------------------------------+
| "Delete"               ||de| ``self.OnDeleteItems``                     |
+------------------------+------------------------------------------------+
| "Combine Items..."     |``self.OnCombineItems``                         |
+------------------------+------------------------------------------------+
| "Find..."              ||fi| ``self.OnFind``                            |
+------------------------+------------------------------------------------+
| **Item Menu**          |                                                |
+------------------------+------------------------------------------------+
| "New Item"             ||ni| ``self.OnNewItem``                         |
+------------------------+------------------------------------------------+
| "Toggle Finished"      ||co| ``self.OnToggleFinished``                  |
+------------------------+------------------------------------------------+
| "Owner..."             ||ow| ``self.OnEditOwner``                       |
+------------------------+------------------------------------------------+
| "Due Date..."          ||dd| ``self.OnDueDate``                         |
+------------------------+------------------------------------------------+
| "Note..."              ||en| ``self.OnEditNote``                        |
+------------------------+------------------------------------------------+
| "Mail..."              ||mi| ``self.OnMailItem``                        |
+------------------------+------------------------------------------------+
| **Display Menu**       |                                                |
+------------------------+------------------------------------------------+
| "Show/Hide Finished..."|``self.OnShowFinished``                         |
+------------------------+------------------------------------------------+
| "Show All"             |``self.OnShowAll``                              |
+------------------------+------------------------------------------------+
| "Refresh Display"      ||re| ``self.OnRefresh``                         |
+------------------------+------------------------------------------------+
|"Select Date to Display"|``self.OnDisplayDateCategory``                  |
+------------------------+------------------------------------------------+
| **Tool Menu**          |                                                |
+------------------------+------------------------------------------------+
| "Tickler Active"       |``self.OnActivateTickler``                      |
+------------------------+------------------------------------------------+
| "Show Next Reminder"   |``self.OnShowTickler``                          |
+------------------------+------------------------------------------------+
| "Synchronize ..."      |``self.OnSync``                                 |
+------------------------+------------------------------------------------+
| "Archive completed..." |``self.OnArchive``                              |
+------------------------+------------------------------------------------+
| "Evaluate expression"  |``self.OnShowEvaluate``                         |
+------------------------+------------------------------------------------+
| **Help Menu**          |                                                |
+------------------------+------------------------------------------------+
| "About ListManager"    |``self.OnShowAbout``                            |
+------------------------+------------------------------------------------+
| "Help"                 |``self.OnShowHelp``                             |
+------------------------+------------------------------------------------+




</t>
<t tx="ekr.20051104081502.344">tb = self.CreateToolBar(wxTB_HORIZONTAL|wxTB_FLAT)

tb.AddLabelTool(idNEWLIST, "New (local) List", wxBitmap('bitmaps\\new.bmp'), shortHelp="Create New List")
tb.AddLabelTool(idOPENLIST, "Open", wxBitmap('bitmaps\\open.bmp'), shortHelp="Open List")
tb.AddSeparator()
tb.AddLabelTool(idTOOLPRINT, "Print", wxBitmap('bitmaps\\print.bmp'), shortHelp="Print List")
tb.AddLabelTool(idPRINTPREV, "Preview", wxBitmap('bitmaps\\preview.bmp'), shortHelp="Print Preview")
tb.AddLabelTool(idPAGESETUP, "Setup", wxBitmap('bitmaps\\setup.bmp'), shortHelp="Page Setup")
tb.AddSeparator()
tb.AddLabelTool(idNEWITEM, "New Item", wxBitmap('bitmaps\\new_item.bmp'), shortHelp="Create New Item")
tb.AddSeparator()
tb.AddLabelTool(idREFRESH, "Refresh", wxBitmap('bitmaps\\refresh.bmp'), shortHelp="Refresh Display")     
tb.AddSeparator()
tb.AddLabelTool(idEDITNOTE, "Edit Note", wxBitmap('bitmaps\\edit_doc.bmp'), shortHelp="Edit Note")
tb.AddSeparator()
tb.AddLabelTool(idFIND, "Find", wxBitmap('bitmaps\\find.bmp'), shortHelp = "Find Item")        
tb.AddSeparator()
tb.AddLabelTool(idCUT, "Cut", wxBitmap('bitmaps\\editcut.bmp'), shortHelp ="Cut Item")        
tb.AddLabelTool(idCOPY, "Copy", wxBitmap('bitmaps\\copy.bmp'), shortHelp ="Copy Item")
tb.AddLabelTool(idPASTE, "Paste", wxBitmap('bitmaps\\paste.bmp'), shortHelp="Paste Item")
tb.AddSeparator()
tb.AddLabelTool(idTOGGLEFINISHED, "Toggle Date", wxBitmap('bitmaps\\filledbox.bmp'), shortHelp="Toggle Finished Date")
tb.AddLabelTool(idDELETEITEMS, "Delete", wxBitmap('bitmaps\\delete.bmp'), shortHelp="Delete Item")
tb.AddLabelTool(idDUEDATE, "Due Date", wxBitmap('bitmaps\\calendar.bmp'), shortHelp="Enter Due Date")
tb.AddLabelTool(idEDITOWNER,"Owner", wxBitmap('bitmaps\\owners.bmp'), shortHelp="Select Owner(s)")
tb.AddSeparator()
tb.AddLabelTool(idMAILITEM, "Mail", wxBitmap('bitmaps\\mail.bmp'), shortHelp="Mail Item")

if QUICK_LIST:
    tb.AddSeparator()
    tb.AddLabelTool(idSENDTO, "Send to", wxBitmap('bitmaps\\sendto.bmp'), shortHelp="Send to %s"%QUICK_LIST)

tb.Realize()
</t>
<t tx="ekr.20051104081502.346">#File Menu ------------------------------------
EVT_MENU(self, idNEWLIST, self.OnNewList)
EVT_MENU(self, idOPENLIST, self.OnOpenList)
EVT_MENU(self, idCLOSELIST, self.OnCloseList)
EVT_MENU(self, idCLOSEALL, self.OnCloseAll)
EVT_MENU(self, idSAVEAS, self.OnSaveAsText)
EVT_MENU(self, idDELETELIST, self.OnDeleteList)
EVT_MENU(self, idPAGESETUP, self.OnPageSetup)
EVT_MENU(self, idPRINT, self.OnPrint)
EVT_MENU(self, idPRINTPREV, lambda e: self.OnPrint(e, prev=True))
EVT_MENU(self, idOFFLINE, self.OnWorkOffline)
EVT_MENU(self, idMAILLIST, self.OnMailView)      
EVT_MENU_RANGE(self, wxID_FILE1, wxID_FILE9, self.OnFileList)
EVT_MENU(self, idEXIT, self.OnExit)
#Edit Menu ------------------------------------
EVT_MENU(self, idCUT, lambda e: self.OnCopyItems(e, cut=True))        
EVT_MENU(self, idCOPY, self.OnCopyItems)
EVT_MENU(self, idPASTE, self.OnPasteItems)
EVT_MENU(self, idDELETEITEMS, self.OnDeleteItems)
EVT_MENU(self, idCOMBINEITEMS, self.OnCombineItems)
EVT_MENU(self, idFIND, self.OnFind)
#item Menu ------------------------------------
EVT_MENU(self, idNEWITEM, self.OnNewItem)
EVT_MENU(self, idTOGGLEFINISHED, self.OnToggleFinished)             
EVT_MENU(self, idDUEDATE, self.OnDueDate)
EVT_MENU(self, idEDITOWNER, self.OnEditOwner)
EVT_MENU(self, idEDITNOTE, self.OnEditNote)
EVT_MENU(self, idMAILITEM, self.OnMailItem)
#Dips Menu ------------------------------------
EVT_MENU(self, idSHOWFINISHED, self.OnShowFinished)
EVT_MENU(self, idSHOWALL, self.OnShowAll)
EVT_MENU(self, idREFRESH, self.OnRefresh)
EVT_MENU(self, idDISPLAYDATE, self.OnDisplayDateCategory)
#Tool Menu ---------------------------------------
EVT_MENU(self, idTICKLERACTIVE, self.OnActivateTickler)
EVT_MENU(self, idSHOWNEXT, self.OnShowTickler)
EVT_MENU(self, idSYNC, self.OnSync)
EVT_MENU(self, idARCHIVE, self.OnArchive)
EVT_MENU(self, idEVALUATE, self.OnShowEvaluate)
#Help Menu -----------------------------------------
EVT_MENU(self, idABOUT, self.OnShowAbout)
EVT_MENU(self, idHELP, self.OnShowHelp)

EVT_TOOL(self, idTOOLPRINT, lambda e: self.OnPrint(e,showprtdlg=False))

if QUICK_LIST:
    EVT_TOOL(self, idSENDTO, lambda e: self.OnMoveToSpecificList(e,QUICK_LIST))
</t>
<t tx="ekr.20051104081502.348">upper_panel = wxPanel(self, -1)   #size = (900,400)
bottom_panel = wxPanel(self, -1, size = (900,150)) #900 note that 000 seems to work???

nb = wxNotebook(upper_panel, -1, size=(900,500), style=wxNB_BOTTOM)

f = wxFont(10, wxSWISS, wxNORMAL, wxNORMAL)
self.name = wxTextCtrl(bottom_panel, -1, size = (285,42), style = wxTE_MULTILINE|wxTE_RICH2)#34 #wxTE_PROCESS_ENTER
self.name.SetDefaultStyle(wxTextAttr("BLACK", font = f))

self.owners = wxTextCtrl(bottom_panel, -1, size = (250,42),style = wxTE_MULTILINE|wxTE_RICH2)
self.owners.SetDefaultStyle(wxTextAttr("BLACK", font = f))

self.note = wxTextCtrl(bottom_panel, -1, size = (400,50), style=wxTE_MULTILINE)

</t>
<t tx="ekr.20051104081502.35">if 0:
    class myFile(file):
        pass

    g.pr(myFile)
    g.pr(issubclass(myFile,file))
    g.pr(isinstance(myFile,file))
    g.pr(super(myFile))
    g.pr(__import__)

if 0:
    old_import = __import__

    def myImport(*args,**keys):
        g.pr("myImport")
        global old_import
        old_import(*args,**keys)

    __import__ = myImport

mod = __import__("leoApp")
g.pr(mod)
</t>
<t tx="ekr.20051104081502.350">EVT_TEXT(self, self.name.GetId(), lambda e: self.modified.update({'name':1}))
EVT_TEXT(self, self.note.GetId(), lambda e: self.modified.update({'note':1}))
EVT_TEXT(self, self.owners.GetId(), lambda e: self.modified.update({'owners':1}))

EVT_CLOSE(self, self.OnWindowExit)

EVT_IDLE(self, self.OnIdle)

</t>
<t tx="ekr.20051104081502.352">#Appears necessary to really get the listcontrol to size with the overall window  
#upper_panel sizer
sizer = wxBoxSizer(wxHORIZONTAL)
sizer.Add(nb,1,wxALIGN_LEFT|wxEXPAND)
upper_panel.SetSizer(sizer)        

#sizer for the row of data items
box = wxBoxSizer(wxHORIZONTAL)
box.Add(self.name,1,wxEXPAND)
box.Add(self.owners,0)

#bottom_panel sizer  
sizer = wxBoxSizer(wxVERTICAL)        
sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
sizer.Add(self.note,1,wxALIGN_LEFT|wxEXPAND)
bottom_panel.SetSizer(sizer)

sizer = wxBoxSizer(wxVERTICAL)
sizer.Add(upper_panel,1,wxALIGN_TOP|wxEXPAND)
sizer.Add(bottom_panel,0,wxALIGN_TOP|wxEXPAND)

self.SetAutoLayout(1)
self.SetSizer(sizer)
#sizer.Fit(self) #actively does bad things to the dimensions on startup
</t>
<t tx="ekr.20051104081502.354">self.toolmenu = toolmenu
self.filemenu = filemenu
self.nb = nb
self.tb = tb
</t>
<t tx="ekr.20051104081502.356">if OUTLOOK:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Create a TCP socket
    s.bind(('localhost',8888)) # Bind to port 8888
    s.listen(5) # Listen, but allow no more than
    self.sock = s
</t>
<t tx="ekr.20051104081502.358">try:
    pathlist = [f[1] for f in cp.items('Files')]
except:
    pathlist = []

if pathlist:
    pathlist.sort()
    pathlist.reverse()
    for path in pathlist[1:]:
        self.OnFileList(path=path)

    #don't want to trigger the page change event until n-1 of n files are loaded
    EVT_NOTEBOOK_PAGE_CHANGED(self,nb.GetId(),self.OnPageChange)

    self.OnFileList(path=pathlist[0])
else:
    EVT_NOTEBOOK_PAGE_CHANGED(self,nb.GetId(),self.OnPageChange)



</t>
<t tx="ekr.20051104081502.36">import compiler

for child in p.children_iter():
    h = child.h
    body = child.b

    try:
        val = compiler.parse(body)
        g.pr(type(val))
        g.pr(val)
    except SyntaxError:
        g.es("Syntax error: %s" % h,color="blue")
</t>
<t tx="ekr.20051104081502.360">ID_TIMER = wxNewId()
self.timer = wxTimer(self, ID_TIMER) 
EVT_TIMER(self,  ID_TIMER, self.OnIdle)
self.timer.Start(3000)
</t>
<t tx="ekr.20051104081502.362"></t>
<t tx="ekr.20051104081502.364">def createownerlist(self):

    if REMOTE_HOST and OFFLINE_ONLY is False:
        cursor = self.GetCursor(REMOTE_HOST)
        sql = "SHOW TABLES" #sorted
    else:
        cursor = self.GetCursor(LOCAL_HOST)
        sql = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"

    cursor.execute(sql)
    results = cursor.fetchall()

    #excluding 'system' tables and archive tables
    excluded_tables = ['user_sync','sync','owners']
    tables = [t for (t,) in results if t.find('_archive')== -1 and t not in excluded_tables]

    sql_list = []
    for table in tables:
        sql_list.append("""SELECT owner1 FROM %s UNION SELECT owner2 FROM %s UNION SELECT owner3 FROM %s"""%((table,)*3))

    sql = " UNION ".join(sql_list)
    cursor.execute(sql)
    results = cursor.fetchall()

    _list = [x[0] for x in results]
    if '' in _list:
        _list.remove('')
    if None in _list:
        _list.remove(None)

    self._list = _list

    #posting custom event to signal that this thread is done
    evt = wxPyEvent()
    evt_id = wxNewEventType()
    evt.SetEventType(evt_id)
    self.Connect(-1, -1, evt_id, self.createownerdialog)
    wxPostEvent(self, evt)

</t>
<t tx="ekr.20051104081502.366">def createownerdialog(self, evt=None):
    self.ModifierDialog = ModifierDialog(parent=self, title="Select owner(s)", size=(180,300), style=wxCAPTION, modifierlist = self._list)
    del self._list

</t>
<t tx="ekr.20051104081502.368"></t>
<t tx="ekr.20051104081502.37">import doctest
g.pr(doctest)
</t>
<t tx="ekr.20051104081502.370">def CreateNewNotebookPage(self, host, table):

    Properties = {'owner':'*ALL',
                'LCdate':'duedate',
                'sort':{'attribute':'priority','direction':0}, #these could be set in Config
                'showfinished':0} #-1 show them all; 0 show none; integer show for that many days

    Properties['table'] = table
    Properties['host'] = host

    self.PropertyDicts.append(Properties)

    self.L = len(self.ItemLists)#could use self.ListCtrls, self.OwnerLBoxes, etc. with a -1

    results = self.ReadFromDB()
    if results is None:
        self.PropertyDicts = self.PropertyDicts[:-1]
        self.L = self.L - 1
        return

    panel = wxPanel(self.nb, -1, size = (900,400))
    LCtrl = ListCtrl(panel, -1, style=wxLC_REPORT|wxSUNKEN_BORDER|wxLC_VRULES|wxLC_HRULES)
    LCtrl.SetFont(self.LC_font)
    self.ListCtrls.append(LCtrl)

    OLBox = wxListBox(panel, -1, size = (126,550), choices = [""], style=wxLB_SORT|wxSUNKEN_BORDER)
    self.OwnerLBoxes.append(OLBox)

    sizer = wxBoxSizer(wxHORIZONTAL)
    sizer.Add(OLBox,0,wxALIGN_LEFT|wxEXPAND)
    sizer.Add(LCtrl,1,wxALIGN_LEFT|wxEXPAND)
    panel.SetSizer(sizer)

    self.ItemLists.append(self.CreateAndDisplayList(results)) 

    &lt;&lt; Fill OwnerListBox &gt;&gt;
    &lt;&lt; ListControl Events &gt;&gt;

    #img_num = LCtrl.arrows[Properties['sort']['direction']]
    #LCtrl.SetColumnImage(self.attr2col_num[Properties['sort']['attribute']], img_num)

    rdbms = host.split(':')[1]
    if rdbms == 'mysql':
        tab_title = '%s (remote)'%table
    else:
        tab_title = table

    if table in SYNC_TABLES:
        tab_title = '*'+tab_title

    self.nb.AddPage(panel,tab_title)
    self.nb.SetSelection(self.L)

    self.filehistory.AddFileToHistory('%s:%s'%(host,table))

    self.SetStatusText("Successfully loaded %s"%tab_title)

</t>
<t tx="ekr.20051104081502.372">cursor = self.GetCursor(host)
if cursor is None:
    g.pr("Couldn't get cursor to fill OwnerListBox")
    return

cursor.execute("SELECT owner1 FROM %s UNION SELECT owner2 FROM %s UNION SELECT owner3 FROM %s"%((table,)*3))

owners = [x for (x,) in cursor.fetchall()]

if None in owners:
    owners.remove(None)
if '' in owners:
    owners.remove('')

OLBox.Clear()
for name in owners: 
    OLBox.Append(name)
OLBox.Append('*ALL')
OLBox.SetSelection(0)

</t>
<t tx="ekr.20051104081502.374">LCId = LCtrl.GetId()
EVT_LIST_ITEM_SELECTED(self, LCId, self.OnItemSelected)
EVT_LIST_ITEM_ACTIVATED(self, LCId, self.OnDisplayInPlaceEditor)
EVT_LEFT_DOWN(LCtrl, self.OnLeftDown) 
EVT_LEFT_DCLICK(LCtrl, self.OnLeftDown)
EVT_RIGHT_DOWN(LCtrl, self.OnRightDown)
EVT_LIST_COL_CLICK(self, LCId, self.OnColumnClick)
EVT_LIST_COL_RIGHT_CLICK(self, LCId, self.OnColumnRightClick)

# the following is a ListBox event
EVT_LISTBOX(self, OLBox.GetId(), self.OnFilterOwners)

</t>
<t tx="ekr.20051104081502.376">def OnPageChange(self, evt=None):
    if self.modified:
        self.OnUpdate()

    self.L = L = self.nb.GetSelection()

    &lt;&lt; Find Highlighted Row &gt;&gt;
    &lt;&lt; Update Title &gt;&gt;

    evt.Skip() #051403

</t>
<t tx="ekr.20051104081502.378">idx = self.ListCtrls[L].GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
if idx != -1:
    self.curIdx = idx
    #LCtrl.EnsureVisible(idx)
    self.OnItemSelected()
elif self.ItemLists[L]:
    self.curIdx = 0
    self.ListCtrls[L].SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
    #the line above triggers an OnItemSelected EVT so don't need self.OnItemSelected() 092803
else:
    self.curIdx = -1

</t>
<t tx="ekr.20051104081502.380">location,rdbms = self.PropertyDicts[L]['host'].split(':')
table = self.PropertyDicts[L]['table']
self.SetTitle("List Manager:  %s:  %s:  %s"%(location,rdbms,table))

</t>
<t tx="ekr.20051104081502.382"></t>
<t tx="ekr.20051104081502.383">def OnShowTickler(self, evt=None):
    if self.popupvisible:
        return

    self.popupvisible = True

    host = 'wxLMDB:sqlite'
    cursor = self.Cursors[host]
    table = 'follow_ups'

    sql = "SELECT COUNT() FROM "+table+" WHERE finisheddate IS NULL AND priority &gt; 1"
    cursor.execute(sql)
    results = cursor.fetchone()

    num_items = int(results[0])

    if not num_items:
        return

    if self.modified: #Should decide if this should be put back or not
        self.OnUpdate()

    n = random.randint(0,num_items-1)

    sql = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp,note FROM "+table+" WHERE finisheddate IS NULL AND priority &gt; 1 LIMIT 1 OFFSET %d"%n

    try:
        cursor.execute(sql)
    except:
        g.pr("In OnShowTickler and attempt to Select an item failed")
        return

    row = cursor.fetchone()

    class Item: pass
    item = Item()

    item.priority = int(row[0]) #int(row[0]) needs int because it seems to come back as a long from MySQL
    item.name = row[1]
    item.createdate = row[2]
    item.finisheddate = row[3]
    item.duedate = row[4]
    item.owners = [z for z in row[5:7] if z is not None] #if you carry around ['tom',None,None] you have an issue when you go write it
    item.id = row[8]
    item.timestamp = row[9]
    item.note = row[10]

    dlg = TicklerDialog(self, "", "Do something about this!!!", size=(550,350))
    TC = dlg.TC

    f = wxFont(14, wxSWISS, wxITALIC, wxBOLD, False)
    TC.SetDefaultStyle(wxTextAttr("BLUE",wxNullColour, f))
    TC.AppendText("%s..."%item.name)

    if item.priority == 3:
        TC.SetDefaultStyle(wxTextAttr("RED","YELLOW",f))
    TC.AppendText("%d\n\n"%item.priority)

    f = wxFont(8, wxSWISS, wxNORMAL, wxNORMAL)
    TC.SetDefaultStyle(wxTextAttr("BLACK","WHITE", f))
    TC.AppendText("owners: %s\n"%", ".join(item.owners))
    TC.AppendText("created on: %s\n"%item.createdate.Format('%m/%d/%y'))
    if item.duedate:
        ddate = item.duedate.Format('%m/%d/%y')
    else:
        ddate = "&lt;no due date&gt;"
    TC.AppendText("due on: %s\n\n"%ddate)

    note = item.note
    if not note:
        note = "&lt;no note&gt;"
    TC.AppendText("%s\n\n"%note)
    f = wxFont(10, wxSWISS, wxITALIC, wxBOLD)
    TC.SetDefaultStyle(wxTextAttr("BLACK",wxNullColour, f))
    TC.AppendText('follow_ups')
    TC.ShowPosition(0)   #did not do anything
    TC.SetInsertionPoint(0)
    result = dlg.ShowModal()
    dlg.Destroy()
    self.popupvisible = False     

    if result in (wxID_OK, wxID_APPLY):

        for L,Properties in enumerate(self.PropertyDicts):
            if Properties['table'] == table:
                break
        else:
            g.pr("Can't find %s"%table)
            return

        self.nb.SetSelection(L) #if the page changes it sends a EVT_NOTEBOOK_PAGE_CHANGED, which calls OnPageChange
        self.L = L
        self.FindNode(item)
        if result==wxID_APPLY:
            self.OnMailItem(item)

    elif result==wxID_FORWARD:
        self.OnShowTickler()

</t>
<t tx="ekr.20051104081502.384">def OnActivateTickler(self, evt):
    self.tickler_active = not self.tickler_active
    self.toolmenu.Enable(idSHOWNEXT,self.tickler_active)


</t>
<t tx="ekr.20051104081502.385"></t>
<t tx="ekr.20051104081502.386">def OnMailItem(self, evt=None, item=None):
    if item is None:
        if self.curIdx == -1:
            return
        else:
            item = self.ItemLists[self.L][self.curIdx]

    dlg = MailDialog(self,"Mail a reminder", size=(450,500),
               recipients=item.owners,    
               subject=item.name,
               body=self.GetNote())          
    result = dlg.ShowModal()
    if result==wxID_OK:
        outlook= Dispatch("Outlook.Application")
        newMsg = outlook.CreateItem(olMailItem) #outlook.CreateItem(constants.olMailItem)
        newMsg.To = to = dlg.RTC.GetValue()
        newMsg.Subject = subject = dlg.STC.GetValue()
        newMsg.Body = body = dlg.BTC.GetValue()

        #newMsg.FlagStatus = constants.olFlagMarked

        newMsg.Display()

        dlg.Destroy()            
        #del outlook

        self.note.SetSelection(0,0)
        self.note.WriteText("**************************************************\n")
        self.note.WriteText("Email sent on %s\n"%mx.DateTime.today().Format("%m/%d/%y"))
        self.note.WriteText("To: %s\n"%to)
        self.note.WriteText("Subject: %s\n"%subject)
        self.note.WriteText("%s\n"%body)
        self.note.WriteText("**************************************************\n")

</t>
<t tx="ekr.20051104081502.387">def OnMailView(self, evt=None):
    recipients = [self.PropertyDicts[self.L]['owner']]

    body = ""
    for i,item in enumerate(self.ItemLists[self.L]):
        body = body+"%d. %s (%d)\n"%(i+1, item.name, item.priority)

    subject = "Follow-ups " + mx.DateTime.today().Format("%m/%d/%y")

    dlg = MailDialog(self,"Follow-up List", size=(450,500),
               recipients=recipients,
               subject=subject,
               body=body)

    val = dlg.ShowModal()
    dlg.Destroy()
    if val==wxID_OK:
        outlook= Dispatch("Outlook.Application")
        newMsg = outlook.CreateItem(olMailItem) #outlook.CreateItem(constants.olMailItem)
        newMsg.To = dlg.RTC.GetValue()
        newMsg.Subject = dlg.STC.GetValue()
        newMsg.Body = dlg.BTC.GetValue()

        newMsg.FlagStatus = olFlagMarked #constants.olFlagMarked
        newMsg.Categories = "Follow-up"

        newMsg.Display()

        #del outlook

</t>
<t tx="ekr.20051104081502.388"></t>
<t tx="ekr.20051104081502.389">def OnCopyItems(self, event=None, cut=False):
    if self.curIdx == -1:
        return

    L = self.L
    IList = self.ItemLists[L]
    LCtrl = self.ListCtrls[L]

    &lt;&lt; Find Highlighted Items &gt;&gt;

    self.SetStatusText("%d items copied"%len(copyitems))
    if cut:
        self.OnDeleteItems()

</t>
<t tx="ekr.20051104081502.390">copyitems = []
i = -1
while 1:
    i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
    if i==-1:
        break
    item = IList[i]
    item.notes = self.GetNote(L,item) #handles the database situation
    copyitems.append(item)

self.copyitems = copyitems
</t>
<t tx="ekr.20051104081502.391">def OnPasteItems(self, evt=None, L=None): #noselect 051603
    #used by OnMoveToList, OnMoveToSpecificList and called directly
    if not self.copyitems:
        g.pr("Nothing was selected to be copied")
        return

    if L is None: #this is not needed by OnMoveTo or OnDragToTab but is for a straight call
        L = self.L

    Properties = self.PropertyDicts[L]
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]

    items = self.copyitems
    numitems = len(items)

    for item in items:

        z = item.owners+[None,None,None]

        id = self.GetUID() #we do give it a new id
        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        createdate = mx.DateTime.now() #need this or else it won't be seen as a new item when synching; would be seen as updated
        command = "INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
        cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))

        timestamp = self.TimeStamper(host, cursor, table, id)

        #creating a new item breaks the connection between item.x and new_item.x
        class Item: pass
        new_item = Item()
        new_item.id = id
        new_item.priority = item.priority
        new_item.owners = item.owners
        new_item.name = item.name
        new_item.timestamp = timestamp
        new_item.duedate =item.duedate
        new_item.finisheddate = item.finisheddate
        new_item.createdate = createdate
        IList.insert(0,new_item)

    self.DisplayList(IList,L)

    #If we didn't come from OnMoveToList or OnMoveToSpecificList where L != self.L
    if L==self.L:
        for i in range(numitems):
            LCtrl.SetItemState(i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = numitems-1



</t>
<t tx="ekr.20051104081502.392">def OnDeleteItems(self, event=None):
    """Called directly and by OnCopyItems (cut = true)
    """
    if self.curIdx == -1: #not absolutely necessary but gets you out quickly
        return

    L = self.L
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]
    Properties = self.PropertyDicts[L]

    i = -1
    while 1:
        i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
        if i==-1:
            break
        item = IList.pop(i)
        LCtrl.DeleteItem(i)

        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        cursor.execute("DELETE from "+table+" WHERE id = %s", (item.id,))

        #Track Deletes for Syncing ############################################
        if table in SYNC_TABLES:
            if host.split(':')[1] == 'sqlite':
                timestamp = mx.DateTime.now()
                cursor.execute("INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,item.name,timestamp))
            else:
                cursor.execute("INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,USER,item.name))
        #########################################################################
        i-=1

    self.name.Clear()
    self.owners.Clear()
    self.note.Clear()
    #note that Clearing does cause self.modified --&gt;{'name':1}
    self.modified = {}
    self.curIdx = -1

</t>
<t tx="ekr.20051104081502.393"></t>
<t tx="ekr.20051104081502.394">def OnLeftDown(self, evt):
    g.pr("Here")
    if self.modified:
        #if inplace editor is open and you click anywhere (same or different row from current row) but in the editor itself then just to close editor
        flag = self.modified.has_key('inplace')
        self.OnUpdate()
        if flag:
            evt.Skip() #without Skip, EVT_LIST_ITEM_SELECTED is not generated if you click in a new row
            return

    x,y = evt.GetPosition()
    LCtrl = self.ListCtrls[self.L]

    #Using HitTest to obtain row clicked on because there was a noticable delay in the generation of an
    #EVT_LIST_ITEM_SELECTED event when you click on the already selected row
    idx,flags = LCtrl.HitTest((x,y))

    #if you are below rows of items then idx = -1 which could match self.curIdx = -1
    if idx == -1:
        return

    # only if you click on the currently selected row do the following events occur
    if idx == self.curIdx:
        if x &lt; 18:
            self.OnToggleFinished()
        elif x &lt; 33:
            self.OnPriority()
        elif x &lt; 33 + LCtrl.GetColumnWidth(1):
            self.OnDisplayInPlaceEditor()
        elif x &lt; 33 + LCtrl.GetColumnWidth(1) + LCtrl.GetColumnWidth(2): 
            self.OnEditOwner()
        else:
            self.OnDueDate
    else:
        evt.Skip() #without Skip, EVT_LIST_ITEM_SELECTED is not generated if you click in a new row



</t>
<t tx="ekr.20051104081502.395">def OnRightDown(self, evt):
    x,y = evt.GetPosition()

    sendtomenu = wxMenu()

    open_tables = []
    for page,Properties in enumerate(self.PropertyDicts):
        host,table = Properties['host'],Properties['table']
        open_tables.append((host,table))
        sendtomenu.Append(1+page,"%s (%s)"%(table,host))
        EVT_MENU(self, 1+page, lambda e,p=page: self.OnMoveToList(e,p))

    sendtomenu.Delete(self.L+1) # don't send it to the page you're already on
    sendtomenu.AppendSeparator()

    self.closed_tables = []
    for host,cursor in self.Cursors.items():

        location, rdbms = host.split(':')

        if rdbms == 'sqlite':
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
        elif rdbms == 'mysql':
            cursor.execute("SHOW tables")

        results = cursor.fetchall()

        page+=1
        for (table,) in results:
            if not ((host,table) in open_tables or table in ['user_sync','owners','sync']):
                self.closed_tables.append((host,table))
                sendtomenu.Append(1+page,"%s (%s)"%('*'+table,host))
                EVT_MENU(self, 1+page, lambda e,p=page: self.OnMoveToList(e,p))
                page+=1

    self.PopupMenu(sendtomenu,(x+125,y+40))
    sendtomenu.Destroy()

</t>
<t tx="ekr.20051104081502.396"></t>
<t tx="ekr.20051104081502.397">def OnCombineItems(self, evt):
    L = self.L
    idx = self.curIdx
    IList = self.ItemLists[L]
    LCtrl = self.ListCtrls[L]

    combine_list = []
    i = -1
    while 1:
        i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
        if i==-1:
            break
        combine_list.append((IList[i].createdate,IList[i]))


    if len(combine_list) &lt; 2:
        g.pr("Fewer than two items highlighted")
        return

    combine_list.sort()
    combine_list.reverse()

    dlg = wxMessageDialog(self,
                        "Combine the %d selected items?"%len(combine_list),
                        "Combine Items?",
                        wxICON_QUESTION|wxYES_NO)

    if dlg.ShowModal() == wxID_YES:
        Properties = self.PropertyDicts[L]
        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        t_item = combine_list[0][1]
        merge_list = combine_list[1:]
        new_note = ""

        for date,item in merge_list:
            note = self.GetNote(item=item)
            date = date.Format("%m/%d/%y")
            new_note = "%s\n%s %s\n\n%s"%(new_note, date, item.name, note)

            cursor.execute("DELETE from "+table+" WHERE id = %s", (item.id,))
            #Track Deletes for Syncing ############################################
            if table in SYNC_TABLES:
                if host.split(':')[1] == 'sqlite':
                    timestamp = mx.DateTime.now()
                    cursor.execute("INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,item.name,timestamp))
                else:
                    cursor.execute("INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,USER,item.name))
            #########################################################################

        t_note = self.GetNote(item=t_item)
        t_note = "%s\n%s"%(t_note,new_note)

        #What about combining owners?######################################

        cursor.execute("UPDATE "+table+" SET name = %s, note = %s WHERE id = %s", (t_item.name+"*",t_note,t_item.id))
        t_item.timestamp = self.TimeStamper(host, cursor, table, t_item.id)

        self.OnRefresh()
        LCtrl.SetItemState(0, 0, wxLIST_STATE_SELECTED)
        IList = self.ItemLists[L]
        id = t_item.id
        idx = -1
        for item in IList:
            idx+=1
            if id == item.id:
                break
        else:
            idx = -1 

        #should never be -1
        if idx != -1:	
            LCtrl.SetItemState(idx, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
            LCtrl.EnsureVisible(idx)
        self.curIdx = idx

    dlg.Destroy()

</t>
<t tx="ekr.20051104081502.398">def OnMoveToList(self, evt=None, page=0):
    self.OnCopyItems(cut=True)
    pc = self.nb.GetPageCount()
    if page &lt; pc:		
        self.OnPasteItems(L=page)
    else:
        host,table = self.closed_tables[page-pc]
        cursor = self.Cursors[host]# in ini self.Cursors[host]

        for item in self.copyitems:
            z = item.owners+[None,None,None]
            id = self.GetUID() #give it a new id

            #need this or else it won't be seen as a new item when syncing; would be seen as updated
            createdate = mx.DateTime.now() 
            command = "INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
            cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))
            timestamp = self.TimeStamper(host, cursor, table, id)

    self.copyitems = []

</t>
<t tx="ekr.20051104081502.399">def OnMoveToSpecificList(self, evt=None, table='follow_ups'):
    matches = {}
    for page,Properties in enumerate(self.PropertyDicts):
        host,tble = Properties['host'],Properties['table']
        if tble == table:
            rdbms = host.split(':')[1]
            matches[rdbms] = page

    self.OnCopyItems(cut=True)

    if matches:
        if matches.get('mysql'):	
            self.OnPasteItems(L=matches['mysql'])
        else:
            self.OnPasteItems(L=matches['sqlite'])
    else:
        cursor = self.Cursors[LOCAL_HOST]

        for item in self.copyitems:
            z = item.owners+[None,None,None]
            id = self.GetUID() #give it a new id

            #need this or else it won't be seen as a new item when syncing; would be seen as updated
            createdate = mx.DateTime.now() 
            command = "INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
            cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))
            timestamp = self.TimeStamper(host, cursor, table, id)

    self.copyitems = []



</t>
<t tx="ekr.20051104081502.400"></t>
<t tx="ekr.20051104081502.401">def OnToggleFinished(self, evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx

    item = self.ItemLists[L][idx]
    LC_Item = LCtrl.GetItem(idx)

    if not item.finisheddate:
        item.finisheddate = mx.DateTime.today()
        LC_Item.SetImage(LCtrl.idx0)
    else:
        item.finisheddate = None
        LC_Item.SetImage(LCtrl.idx1)

    &lt;&lt; draw item &gt;&gt;

    self.tb.EnableTool(30, True)

    host = Properties['host']	
    cursor = self.Cursors[host]
    table = Properties['table']

    cursor.execute("UPDATE "+table+" SET finisheddate = %s WHERE id = %s", (item.finisheddate, item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
    elif Properties['LCdate'] == 'finisheddate':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.finisheddate.Format('%m/%d/%y'))



</t>
<t tx="ekr.20051104081502.402">if item.finisheddate:
    #It appears that SetTextColour resets font weight to Normal but this makes no sense
    #This means that all finished items have Normal weight whether they are priority 3,2 or 1
    #May actually be that GetItem() and then SetItem() sets the weight to Normal no matter what it was originally
    LC_Item.SetTextColour(wxLIGHT_GREY)

elif item.priority==1:
    #see note above about SetTextColour apparently resetting weight
    LC_Item.SetTextColour(wxBLACK)

elif item.priority==2:
    #LC_Item.SetTextColour(wxBLACK) -- this line should be necessary but it does not appear to be
    # ? font is black so ? if have to reset it
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

else:
    LC_Item.SetTextColour(wxRED) #appears to be the only way to set color - can't through font
    f = self.LC_font #LCtrl.font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

LCtrl.SetItem(LC_Item)
</t>
<t tx="ekr.20051104081502.403">def OnPriority(self, event=None, input=None):
    L = self.L
    idx = self.curIdx
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    item = self.ItemLists[L][idx]

    if input:
        item.priority=input

    else:
        if item.priority &lt; 3:
            item.priority+= 1
        else:
            item.priority=1

    LC_Item = LCtrl.GetItem(idx)

    &lt;&lt; draw item &gt;&gt;

    text = str(item.priority)        
    LCtrl.SetStringItem(idx, 0, text)

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']

    cursor.execute("UPDATE "+table+" SET priority = %s WHERE id = %s", (item.priority,item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format('%m/%d %H:%M:%S'))

    wxCallAfter(LCtrl.SetFocus)

</t>
<t tx="ekr.20051104081502.404">if item.finisheddate:
    #It appears that SetTextColour resets font weight to Normal but this makes no sense
    #This means that all finished items have Normal weight whether they are priority 3,2 or 1
    #May actually be that GetItem() and then SetItem() sets the weight to Normal no matter what it was originally
    LC_Item.SetTextColour(wxLIGHT_GREY)

elif item.priority==1:
    #see note above about SetTextColour apparently resetting weight
    LC_Item.SetTextColour(wxBLACK)

elif item.priority==2:
    #LC_Item.SetTextColour(wxBLACK) -- this line should be necessary but it does not appear to be
    # ? font is black so ? if have to reset it
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

else:
    LC_Item.SetTextColour(wxRED) #appears to be the only way to set color - can't through font
    f = self.LC_font #LCtrl.font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

LCtrl.SetItem(LC_Item)
</t>
<t tx="ekr.20051104081502.405"></t>
<t tx="ekr.20051104081502.406">def OnDisplayInPlaceEditor(self,evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx
    item = self.ItemLists[L][idx]

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']

    #if self.Conflict(host, cursor, table, item): return #works -- may be overkill so i've commented it out

    TCid = wxNewId()
    y = LCtrl.GetItemPosition(idx)[1] 
    length = LCtrl.GetColumnWidth(1)

    editor = wxTextCtrl(self, TCid, pos = (167,y+28), size = (length,23), style=wxTE_PROCESS_ENTER)
    editor.SetFont(wxFont(9, wxSWISS, wxNORMAL, wxNORMAL))
    editor.SetBackgroundColour(wxColour(red=255,green=255,blue=175)) #Yellow
    editor.AppendText(item.name)
    editor.Show(True)
    editor.Raise()
    editor.SetSelection(-1,-1)
    editor.SetFocus()	

    EVT_TEXT_ENTER(self, TCid, self.OnCloseInPlaceEditor)		

    self.in_place_editor = editor
    self.modified['inplace'] = 1	





</t>
<t tx="ekr.20051104081502.407">def OnCloseInPlaceEditor(self,evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx
    item = self.ItemLists[L][idx]

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    LCdate = Properties['LCdate']

    #if self.Conflict(host, cursor, table, item)...

    text = self.in_place_editor.GetValue().strip()[:150]
    item.name = text
    LCtrl.SetStringItem(idx, self.attr2col_num['name'], text)
    self.in_place_editor.Destroy()

    cursor.execute("UPDATE "+table+" SET name = %s WHERE id = %s", (text, item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format('%m/%d %H:%M:%S'))

    self.name.Clear()
    self.name.AppendText(text) #this will cause self.modified['name'] = 1, which is dealt with below

    #using default in case for some reason self.modified does not have the keys
    self.modified.pop('inplace', None)
    self.modified.pop('name', None)

    wxCallAfter(LCtrl.SetFocus) #sets focus on LCtrl and current selection to be highlighted



</t>
<t tx="ekr.20051104081502.408">def OnDueDate(self, evt=None):
    idx = self.curIdx
    if idx == -1:
        return
    L = self.L
    Properties = self.PropertyDicts[L]
    item = self.ItemLists[L][idx]
    LCtrl = self.ListCtrls[L]

    if item.duedate:
        date = wxDateTime()
        date.SetTimeT(item.duedate) #I am surprised it takes a mx.DateTime object; supposed to need ticks
    else:
        date = 0
    dlg = CalendarDialog(parent=self,
                 title="Select a date",
                 size=(400,400),
                 style=wxCAPTION,
                 date = date)
    if dlg.ShowModal()==wxID_OK:
        date = dlg.cal.GetDate() # this is some date object
        #date = date.GetTicks()
        item.duedate = mx.DateTime.DateFromTicks(date.GetTicks())

        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        cursor.execute("UPDATE "+table+" SET duedate = %s WHERE id = %s", (item.duedate,item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)
        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
        elif Properties['LCdate'] == 'duedate':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.duedate.Format('%m/%d/%y'))
    dlg.cal.Destroy()
    dlg.Destroy()

</t>
<t tx="ekr.20051104081502.409">def OnEditOwner(self, evt=None): #, new=False) removed Aug. 31 for simplicity
    idx = self.curIdx
    if idx == -1:
        return
    L = self.L
    Properties = self.PropertyDicts[L]
    LCtrl = self.ListCtrls[L]
    item = self.ItemLists[L][idx]
    if not self.ModifierDialog:
        g.pr("self.ModifierDialog is still being constructed")
        return
    #need to clear the current selections or you'll just be making more and more selections
    self.ModifierDialog.SelectCurrent(item.owners)
    self.ModifierDialog.tc.Clear()
    self.ModifierDialog.CenterOnParent()

    val = self.ModifierDialog.ShowModal()

    if val == wxID_OK:
        item.owners, new_names = self.ModifierDialog.GetUserInput()

        &lt;&lt; Common Owner Code &gt;&gt;

        for owner in item.owners:
            if self.OwnerLBoxes[L].FindString(owner) == -1:
                self.OwnerLBoxes[L].Append(owner)

        for owner in new_names:
            self.ModifierDialog.lb.Append(owner)

        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        cursor.execute("UPDATE "+table+" SET owner1 = %s, owner2 = %s, owner3 = %s WHERE id = %s", (z[0],z[1],z[2],item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)
        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))

        if 'owners' in self.modified:
            del self.modified['owners']

    wxCallAfter(LCtrl.SetFocus)

</t>
<t tx="ekr.20051104081502.410">owner_str = '; '.join(item.owners)
LCtrl.SetStringItem(idx, self.attr2col_num['owners'], owner_str)
self.owners.Clear()
self.owners.AppendText(owner_str)

z = item.owners+[None,None,None] #note that + creates a new list
</t>
<t tx="ekr.20051104081502.411">def OnUpdate(self, evt=None):
    if 'inplace' in self.modified:
        self.OnCloseInPlaceEditor()
        if not self.modified:
            return

    L = self.L
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]
    Properties = self.PropertyDicts[L]
    OLBox = self.OwnerLBoxes[L]
    idx = self.curIdx

    # there is some chance that it is never true that idx == -1 and then this could be eliminated
    if idx != -1:
        item = IList[idx]
    else:
        msg = wxMessageDialog(self, "There is no selected item to update", "", wxICON_ERROR|wxOK)
        msg.ShowModal()
        msg.Destroy()
        self.modified = {}
        return

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']

    if 'name' in self.modified:
        item.name = self.name.GetValue().strip()[:150]
        LCtrl.SetStringItem(idx, self.attr2col_num['name'], item.name)
        cursor.execute("UPDATE "+table+" SET name =%s WHERE id = %s",(item.name,item.id))

    if 'note' in self.modified:
        note = self.note.GetValue() #a blank note starts out as None but after this it becomes '' -- ??
        cursor.execute("UPDATE "+table+" SET note =%s WHERE id = %s",(note,item.id))

    if 'owners' in self.modified:
        owner_str = self.owners.GetValue().strip()
        item.owners = []
        if owner_str:
            owner_list = [x.strip() for x in owner_str.split(';')]
            for owner in owner_list:
                owner = ", ".join([x.strip().title() for x in owner.split(',')])
                item.owners.append(owner)

        &lt;&lt; Common Owner Code &gt;&gt;

        cursor.execute("UPDATE "+table+" SET owner1 = %s, owner2 = %s, owner3 = %s WHERE id = %s", (z[0],z[1],z[2],item.id))

        for owner in item.owners:
            if self.ModifierDialog.lb.FindString(owner) == -1:
                self.ModifierDialog.lb.Append(owner)
                OLBox.Append(owner)
            elif OLBox.FindString(owner) == -1:
                OLBox.Append(owner)		

    item.timestamp = self.TimeStamper(host, cursor, table, item.id)
    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, 3, item.timestamp.Format("%m/%d %H:%M:%S"))

    self.modified = {}


</t>
<t tx="ekr.20051104081502.412">owner_str = '; '.join(item.owners)
LCtrl.SetStringItem(idx, self.attr2col_num['owners'], owner_str)
self.owners.Clear()
self.owners.AppendText(owner_str)

z = item.owners+[None,None,None] #note that + creates a new list
</t>
<t tx="ekr.20051104081502.413">def OnNewItem(self, evt=None):
    L=self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]

    if self.curIdx != -1:
        LCtrl.SetItemState(self.curIdx, 0, wxLIST_STATE_SELECTED)

    &lt;&lt; Clear data fields &gt;&gt;

    class Item: pass
    item = Item()
    item.name = '&lt;New Item&gt;'
    item.priority = 1
    item.owners = []
    item.createdate = mx.DateTime.now() #need this to be a timestamp and not just date for syncing
    item.duedate = item.finisheddate = None

    self.ItemLists[L].insert(0,item)

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    item.id = self.GetUID()

    cursor.execute("INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,id) VALUES (%s,%s,%s,%s,%s,%s)",
                (item.priority,item.name,item.createdate,None,None,item.id))

    item.timestamp = self.TimeStamper(host, cursor, table, item.id)

    #tracking new item for syncing will happen in Edit Name

    LCtrl.InsertImageStringItem(0,"1", LCtrl.idx1)
    LCtrl.SetStringItem(0,1,item.name)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(0, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
    elif Properties['LCdate'] == 'createdate':
        LCtrl.SetStringItem(0, self.attr2col_num['date'], item.createdate.Format('%m/%d/%y'))

    self.curIdx = 0

    #if Display is being filtered we assume that is the owner of the new node
    owner = Properties['owner']	
    if owner and owner!='*ALL':
        self.ListCtrls[L].SetStringItem(0, self.attr2col_num['owners'], owner)
        item.owners = [owner]

        self.owners.Clear()
        self.owners.AppendText(owner)

        cursor.execute("UPDATE "+table+" SET owner1 = %s WHERE id = %s", (owner,item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)  #not really necessary since just got a timestamp

    # decided that it was actually better not to ask for the owner on a new node	
    #else:
        #self.OnEditOwner()

    LCtrl.SetFocus() #needed for the in place editor to look right
    LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)

    self.OnDisplayInPlaceEditor() #(new=True)
</t>
<t tx="ekr.20051104081502.414">self.name.Clear()
self.owners.Clear()
self.note.Clear()
</t>
<t tx="ekr.20051104081502.415">@ Need to decide if we are going to have timestamp checking to be sure something hasn't changed
Note that there would not need to be timestamp checking on a new node
Also  there is no need to timestamp check on a local DB
The following code seems to work fine, however, I have just commented out the calls to it in NameEditor methods
@c
def Conflict(self, host, cursor, table, item):
    if host is 'sqlite':
        return False
    cursor.execute("Select timestamp from "+table+" WHERE id = %s", (item.id,))
    db_timestamp = cursor.fetchone()[0]
    if db_timestamp != item.timestamp:
        g.pr("There is a conflict and you should refresh display")
        return True
    else:
        return False
</t>
<t tx="ekr.20051104081502.416">def OnEditNote(self, evt=None):
    if self.modified:
        self.OnUpdate()

    idx = self.curIdx

    if idx == -1:
        return

    L = self.L

    #if self.editor:
        #machine = None
        #win32pdh.EnumObjects(None, machine, 0, 1) # resets Enum otherwise it seems to hold onto old data
        #object = "Process"
        #items, instances = win32pdh.EnumObjectItems(None,None,"Process", -1)
        #if 'TextPad' in instances:
            #g.pr("TextPad is running")
        #else:
            #self.editor = {}

    item = self.ItemLists[L][idx]
    file_name = re.sub('[\\/:*"&lt;&gt;|\?]','-',item.name) #make sure all chars are legal file name characters

    path = os.path.join(os.environ['TMP'],file_name[:50])+'.%s'%NOTE_EXT

    f = file(path,'w')
    f.write(self.GetNote())
    f.close()

    os.startfile(path)

    id = item.id
    for d in self.editor:
        if d['id'] == id:
            return

    ed = {}
    ed['time'] = os.path.getmtime(path)
    ed['host'] = self.PropertyDicts[L]['host']
    ed['table'] = self.PropertyDicts[L]['table']
    ed['path'] = path
    ed['id'] = item.id

    self.editor.append(ed)

    time.sleep(.1)
</t>
<t tx="ekr.20051104081502.417"></t>
<t tx="ekr.20051104081502.418">def OnNewList(self, event=None):
    if self.modified:
        self.OnUpdate()

    if OFFLINE_ONLY is True or REMOTE_HOST is None:
        hosts = [LOCAL_HOST]
    else:
        hosts = [LOCAL_HOST, REMOTE_HOST]

    dlg = wxSingleChoiceDialog(self, 'Databases', 'Choose a database:', hosts, wxCHOICEDLG_STYLE)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        host = dlg.GetStringSelection()
    else:
        return

    cursor = self.GetCursor(host)
    if cursor is None:
        return

    dlg = wxTextEntryDialog(self, 'What is the name of the new table?', 'Create Table')
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        table = dlg.GetValue()
    else:
        return

    if not table:
        return

    location, rdbms = host.split(':')

    if rdbms == 'sqlite':
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
    else:
        cursor.execute("SHOW tables")

    if (table,) in cursor.fetchall():
        msg = wxMessageDialog(self,
                              "Table '%s' already exists"%table,
                              "Duplicate Table",
                              wxICON_ERROR|wxOK)
        msg.ShowModal()
        msg.Destroy()
        return

    dlg = wxMessageDialog(self,
          "Are you sure you want to create Table '%s'?"%table,
          "Create Table?",
          wxICON_QUESTION|wxYES_NO)

    if dlg.ShowModal() == wxID_YES:
        self.CreateTable(host,table)
        self.CreateNewNotebookPage(host,table)

        #self.AddListControl(tab_title) #add listcontrol displays the list

        #self.OnNewItem()

    dlg.Destroy()


</t>
<t tx="ekr.20051104081502.419">def OnFileList(self, evt=None, path=None):
    if self.modified:
        self.OnUpdate()

    #if there is no event, we got here through the start up loading of lists
    if evt:
        fileNum = evt.GetId() - wxID_FILE1			
        path = self.filehistory.GetHistoryFile(fileNum)
        location, rdbms, table = path.split(':')
        host = '%s:%s'%(location, rdbms)
        # only need to check if table is open if this is not at startup
        if table in [p['table'] for p in self.PropertyDicts if p['host'] == host]:
            dlg = wxMessageDialog(self,"%s (%s) is already open!"%(table,host),"List Open",wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            return

    else:
        location, rdbms, table = path.split(':')
        host = '%s:%s'%(location, rdbms)

    cursor = self.GetCursor(host)
    if cursor is None:
        return

    if rdbms == 'sqlite':
        sql = "SELECT name FROM sqlite_master WHERE name = '%s'"%table
    else:
        sql = "SHOW TABLES LIKE '%s'"%table

    cursor.execute(sql)
    if not cursor.fetchall():
        dlg = wxMessageDialog(self,
                    "Table '%s' at host '%s' does not appear to exist!"%(table,host),
                    "Table does not exist",
                    wxICON_ERROR|wxOK)
        dlg.ShowModal()
        dlg.Destroy()
        return

    self.CreateNewNotebookPage(host,table)

</t>
<t tx="ekr.20051104081502.420">def OnOpenList(self, evt=None):
    if self.modified:
        self.OnUpdate()

    tree = {}

    if OFFLINE_ONLY is True or REMOTE_HOST is None:
        hosts = [LOCAL_HOST]
    else:
        hosts = [LOCAL_HOST, REMOTE_HOST]

    for host in hosts:
        cursor = self.GetCursor(host)
        if cursor:
            if host.split(':')[1] == 'sqlite':
                sql = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
            else:
                sql = "SHOW TABLES" #sorted

            cursor.execute(sql)
            results = cursor.fetchall()

            #excluding already open tables + 'system' tables
            excluded_tables = [p['table'] for p in self.PropertyDicts if p['host'] == host]
            excluded_tables.extend(['user_sync','sync','owners'])

            tables = [t for (t,) in results if t not in excluded_tables]

            tree[host] = tables

    dlg = TreeDialog(self, "Open List", tree=tree)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        sel = dlg.TreeCtrl.GetSelection()
        table = dlg.TreeCtrl.GetItemText(sel)
        sel = dlg.TreeCtrl.GetItemParent(sel)
        host = dlg.TreeCtrl.GetItemText(sel)

        if host in hosts: #takes care of highlighting root or hosts
            self.CreateNewNotebookPage(host,table)
</t>
<t tx="ekr.20051104081502.421">def OnDeleteList(self, evt=None):
    #ini controls whether the menu item is enabled
    Properties = self.PropertyDicts[self.L]
    host = Properties['host']
    table = Properties['table']

    #if table is in SYNC_TABLES, should we make a point of that?
    dlg = wxMessageDialog(self,
                        "Are you sure that you want to delete table %s (%s)?\n(Please note that you cannot recover it once it is deleted!)"%(table,host),
                        "Delete Table...",
                        wxICON_EXCLAMATION|wxYES_NO|wxNO_DEFAULT)

    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return

    rdbms = host.split(':')[1]

    if rdbms == 'mysql':
        dlg = wxMessageDialog(self,
                        "Are you sure really really sure you want to delete table %s (%s)?\n(You really really cannot recover it once it is deleted)"%(table,host),
                        "Delete Table...",
                        wxICON_EXCLAMATION|wxYES_NO|wxNO_DEFAULT)

        val = dlg.ShowModal()
        dlg.Destroy()
        if val == wxID_NO:
            return

    cursor = self.Cursors[host]
    cursor.execute("DROP TABLE %s"%table)

    self.OnCloseList()

</t>
<t tx="ekr.20051104081502.422">def OnCloseList(self, evt=None):
    if self.modified:
        self.OnUpdate()

    L = self.L

    del self.ItemLists[L]
    del self.PropertyDicts[L]
    del self.ListCtrls[L]
    del self.OwnerLBoxes[L]

    self.nb.DeletePage(L)        

    ln = len(self.PropertyDicts)
    if ln:
        self.nb.SetSelection(0)
        self.L = 0
    else:
        self.L = -1




</t>
<t tx="ekr.20051104081502.423">def OnCloseAll(self, evt=None):
    if self.modified:
        self.OnUpdate()

    while self.L != -1:
        self.OnCloseList()

    self.name.Clear()
    self.owners.Clear()
    self.note.Clear()
    #note that Clearing does set self.modified (eg {'name':1})
    self.modified = {}

</t>
<t tx="ekr.20051104081502.424">def OnSaveAsText(self, evt=None):
    if self.modified:
        self.OnUpdate()

    Properties = self.PropertyDicts[self.L]
    wildcard = "txt files (*.txt)|*.txt|All files (*.*)|*.*"
    #dlg = wxFileDialog(self, "Save file", "", Properties['table'], wildcard, wxSAVE|wxOVERWRITE_PROMPT|wxCHANGE_DIR)

    body = ""
    for i,item in enumerate(self.ItemLists[self.L]):
        body = body+"%d. %s (%d)\n"%(i+1, item.name, item.priority)

    table = Properties['table']
    location, rdbms = Properties['host'].split(':')
    filename = re.sub('[\\/:*"&lt;&gt;|\?]','-','%s-%s-%s'%(location,rdbms,table)) 
    filename = filename[:50]+'.txt'

    path = os.path.join(DIRECTORY,filename)

    f = file(path,'w')
    f.write(body)
    f.close()

    os.startfile(path)

    self.SetStatusText("Saved file %s"%path)

</t>
<t tx="ekr.20051104081502.425">def OnArchive(self, evt=None):
    if self.modified:
        self.OnUpdate()

    Properties = self.PropertyDicts[self.L]
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    rdbms = host.split(':')[1]

    table_archive = table+'_archive'

    #need to test for existence of table_archive
    if rdbms == 'sqlite':
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
    else:
        cursor.execute("SHOW tables")

    results = cursor.fetchall()

    if (table_archive,) not in results:
        dlg = wxMessageDialog(self,
                    "Do you want to create an archive for table %s (%s)"%(table,rdbms),
                    "Create an archive...",
                    wxICON_QUESTION|wxYES_NO)
        val = dlg.ShowModal()
        dlg.Destroy()
        if val==wxID_YES:
            self.CreateTable(host,table_archive)
        else:
            return

    label1 = "In table %s (%s) \narchive all finished items older than:"%(table,rdbms)
    label2 = "Archive all finished items"
    dlg = FinishedDialog(self, "Archive completed items", days=7, spin_label=label1, check_label=label2)

    val = dlg.ShowModal()
    dlg.Destroy() #dialogs and frames not destroyed right away to allow processing events, methods
    if val==wxID_CANCEL:
        return

    if dlg.check.GetValue():
        cursor.execute("SELECT id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note FROM "+table+" WHERE finisheddate IS NOT NULL")
    else:
        days = dlg.text.GetValue()
        date = mx.DateTime.today() - int(days)
        cursor.execute("SELECT id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note FROM "+table+" WHERE finisheddate &lt; %s",(date,))

    results = cursor.fetchall()
    dlg = wxMessageDialog(self,
                        "Archiving will remove %d records from %s.\nDo you want to proceed?"%(len(results),table),
                        "Proceed to archive...",
                        wxICON_QUESTION|wxYES_NO)

    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return

    if table in SYNC_TABLES:
        if rdbms == 'sqlite':
            def track_deletes():
                timestamp = mx.DateTime.now()
                cursor.execute("INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)",(id,'d',table,name,timestamp))
        else:
            def track_deletes():
                cursor.execute("INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)",(id,'d',table,USER,name))
    else:
        def track_deletes():
            pass	

    for row in results:
        # the next line is necessary because pysqlite returns a tuple-like object that is not a tuple
        r = tuple(row)
        id = r[0]
        name = r[2]
        cursor.execute("INSERT INTO "+table_archive+"  (id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)",r)
        timestamp = self.TimeStamper(host, cursor, table_archive, id)
        cursor.execute("DELETE from "+table+" WHERE id = %s", (id,))
        track_deletes()

    self.OnRefresh()
    dlg = wxMessageDialog(self,
                        "Table %s had items older than %s days successfully archived"%(table,days),
                        "Archiving successful...",
                        wxICON_INFORMATION|wxOK)
    dlg.ShowModal()
</t>
<t tx="ekr.20051104081502.426">def OnWorkOffline(self, evt=None):
    global OFFLINE_ONLY
    OFFLINE_ONLY = not OFFLINE_ONLY
    if OFFLINE_ONLY:
        del self.Cursors[REMOTE_HOST]
    else:
        server = REMOTE_HOST.split(':')[0]
        try:
            socket.gethostbyname(server)
        except:
            dlg = wxMessageDialog(None, "Cannot connect to remote server! Will set to work offline.", "ListManager", style=wxOK|wxICON_EXCLAMATION|wxSTAY_ON_TOP)
            dlg.ShowModal()
            dlg.Destroy()
            OFFLINE_ONLY = True

    self.filemenu.Check(idOFFLINE,OFFLINE_ONLY)

</t>
<t tx="ekr.20051104081502.428"></t>
<t tx="ekr.20051104081502.429">def OnItemSelected(self, evt=None):
    if self.modified:
        self.OnUpdate()

    if evt:
        idx = evt.GetIndex()
    elif self.curIdx != -1:
        idx = self.curIdx
    else: # really to catch self.curIdx = -1 (see OnDelete and OnRefresh)
        self.name.Clear() # could be moved out of if
        self.owners.Clear() # could be moved out of if
        self.note.Clear()
        #note that Clearing does set self.modified (eg {'name':1})
        self.modified = {}
        return

    L = self.L
    item = self.ItemLists[L][idx]

    self.name.Clear()
    self.name.AppendText(item.name) #SetValue(item.name) - if you use setvalue you don't get the font

    self.owners.Clear()
    self.owners.AppendText('; '.join(item.owners))

    note = self.GetNote(L,item)
    if note.find("&lt;leo_file&gt;") != -1:
        self.note.SetValue("Leo Outline")
        self.note.SetEditable(False)
    else:
        self.note.SetValue(note)
        self.note.SetEditable(True)

    self.ListCtrls[L].EnsureVisible(idx)
    self.curIdx = idx

    #writing to text widgets caused wxEVT_COMMAND_TEXT_UPDATED which is caught by EVT_TEXT, which updates self.modified
    self.modified={}

</t>
<t tx="ekr.20051104081502.430">def OnItemActivated(self,evt):
    g.pr("On Activated")

</t>
<t tx="ekr.20051104081502.431">def OnShowAll(self, evt=None):
    L = self.L
    OLBox = self.OwnerLBoxes[L]

    Properties = self.PropertyDicts[L]
    Properties['showfinished'] = -1
    Properties['owner'] = '*ALL'

    OLBox.SetStringSelection('*ALL')

    self.OnRefresh()
</t>
<t tx="ekr.20051104081502.432">def OnRefresh(self, evt=None):
    #OnItemSelected should be able to handle no items so this could be very short
    L = self.L

    results = self.ReadFromDB()
    self.ItemLists[L] = self.CreateAndDisplayList(results)

    if self.ItemLists[L]:
        self.ListCtrls[L].SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = 0
    else:
        self.curIdx = -1		

    self.OnItemSelected()
</t>
<t tx="ekr.20051104081502.433">def OnFilterOwners(self, evt=None):
    if self.modified:
        self.OnUpdate()
    sel = self.OwnerLBoxes[self.L].GetStringSelection()

    if sel:
        self.PropertyDicts[self.L]['owner'] = sel
        self.OnRefresh()
</t>
<t tx="ekr.20051104081502.434">def OnColumnClick(self, evt):
    col_num = evt.GetColumn()
    L = self.L
    LCtrl = self.ListCtrls[L]
    Sort = self.PropertyDicts[L]['sort']
    attr2col = self.attr2col_num

    prev_sort_attr = Sort.get('attribute') #if this is the first sort Properties['sort'] is {}

    #following is a little bit ugly but gets the key from the value, which is col_num
    Sort['attribute'] = attr2col.keys()[attr2col.values().index(col_num)]

    if prev_sort_attr == Sort['attribute']:
        Sort['direction'] = not Sort['direction']
    else:
        Sort['direction'] = 0

    self.OnRefresh()

    LCtrl.ClearColumnImage(attr2col['priority'])
    LCtrl.ClearColumnImage(attr2col['date'])
    img_num = LCtrl.arrows[Sort['direction']]
    LCtrl.SetColumnImage(col_num, img_num)

</t>
<t tx="ekr.20051104081502.435">def OnShowFinished(self,evt):
    Properties = self.PropertyDicts[self.L]
    label1 = "Enter the number of days to retain\ncompleted tasks in the display:"
    label2 = "Show all finished items"
    dlg = FinishedDialog(self, "Display of completed items", days=Properties['showfinished'], spin_label=label1, check_label=label2)
    if dlg.ShowModal()==wxID_OK:
        if dlg.check.GetValue():
            Properties['showfinished'] = -1
        else:
            days = dlg.text.GetValue()
            Properties['showfinished'] = int(days)			
        self.OnRefresh()
    dlg.Destroy()

</t>
<t tx="ekr.20051104081502.436">def OnColumnRightClick(self, evt=None):
    col = evt.GetColumn()
    if col != self.attr2col_num['date']:
        return

    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]

    #x,y = evt.GetPosition()
    datemenu = wxMenu()

    for i,date in enumerate(['Create Date','Last Modified','Due Date','Completion Date']):
        datemenu.Append(200+i, date)
        EVT_MENU(self, 200+i, lambda e, i=i: self.ChangeDateDisplayed(e,i))

    x = LCtrl.GetColumnWidth(1)+ LCtrl.GetColumnWidth(2) + LCtrl.GetColumnWidth(3)
    self.PopupMenu(datemenu,(x,40))
    datemenu.Destroy()


</t>
<t tx="ekr.20051104081502.437">def OnDisplayDateCategory(self, evt=None):
    dlg = wxSingleChoiceDialog(self, 'Date Display', 'Choose a date to display:',
                    ['Create Date','Last Modified','Due Date','Completion Date']
                    , wxOK|wxCANCEL)
    val = dlg.ShowModal()
    dlg.Destroy()

    if val == wxID_OK:
        idx = dlg.GetSelection()
        self.ChangeDateDisplayed(i=idx)

</t>
<t tx="ekr.20051104081502.438">def ChangeDateDisplayed(self, evt=None, i=0):
    L = self.L
    LCtrl = self.ListCtrls[L]
    self.PropertyDicts[L]['LCdate'] = displaydate = ('createdate','timestamp','duedate','finisheddate')[i]	
    col_num = self.attr2col_num['date']
    col_info = LCtrl.GetColumn(col_num)
    col_info.SetText(self.date_titles[displaydate])
    LCtrl.SetColumn(col_num,col_info)
    self.DisplayList(self.ItemLists[L])
    #self.OnRefresh() #have gone back and forth but think that it should be self.DisplayList
</t>
<t tx="ekr.20051104081502.439">def DisplayList(self, List, L=None):
    #OnPasteItems needs to be able to have an L that is not self.L
    if L is None:
        L = self.L
    LCtrl = self.ListCtrls[L]
    LCdate = self.PropertyDicts[L]['LCdate']
    if LCdate == 'timestamp':
        format = '%m/%d %H:%M:%S'
    else:
        format = '%m/%d/%y'
    LCtrl.DeleteAllItems()

    for x,item in enumerate(List):
        &lt;&lt; draw item &gt;&gt;


</t>
<t tx="ekr.20051104081502.440">LCtrl.InsertImageStringItem(x, str(item.priority), LCtrl.idx1)
LCtrl.SetStringItem(x,1,item.name)
LCtrl.SetStringItem(x,2,'; '.join(item.owners))
date = item.__dict__[LCdate]
LCtrl.SetStringItem(x,3,date and date.Format(format) or "")

if item.finisheddate:
    LC_Item = LCtrl.GetItem(x)
    LC_Item.SetImage(LCtrl.idx0) #might just want generic number or greyed one two three
    LC_Item.SetTextColour(wxLIGHT_GREY)
    LCtrl.SetItem(LC_Item)

elif item.priority==2:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #resetting weight
    LCtrl.SetItem(LC_Item)

elif item.priority==3:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #return to normal
    LC_Item.SetTextColour(wxRED)
    LCtrl.SetItem(LC_Item)
</t>
<t tx="ekr.20051104081502.441"></t>
<t tx="ekr.20051104081502.442">def OnPageSetup(self, evt):
    #need to pass printdata to tableprint

    psdata = wxPageSetupDialogData()

    # if want to vary margins will need to save them as ivars and then set
    #psdata.SetMarginTopLeft((self.Left,self.Top))
    psdata.EnableMargins(False)
    psdata.SetPrintData(self.printdata) #gets Paper Orientation and PaperId info from printdata

    dlg = wxPageSetupDialog(self, psdata)
    if dlg.ShowModal() == wxID_OK:
        self.printdata = dlg.GetPageSetupData().GetPrintData()
        dlg.Destroy()
</t>
<t tx="ekr.20051104081502.443">def OnPrint(self, evt=None, prev=False, showprtdlg=True): 		#???self.psdata = psdata
    IList = self.ItemLists[self.L]
    Properties = self.PropertyDicts[self.L]

    prt = PrintTable(self.printdata) #self.printdata is the wxPrintData object with Orientation Info

    font_name = prt.default_font_name
    prt.text_font = {'Name':font_name, 'Size':11, 'Colour':[0, 0, 0], 'Attr':[0, 0, 0]}
    prt.label_font = {'Name':font_name, 'Size':12, 'Colour':[0, 0, 0], 'Attr':[1, 0, 0]}
    prt.header_font = {'Name':font_name, 'Size':14, 'Colour':[0, 0, 0], 'Attr':[1, 0, 0]}

    prt.row_def_line_colour = wxLIGHT_GREY
    prt.column_def_line_colour = wxLIGHT_GREY

    prt.left_margin = 0.5

    data = []
    for row,item in enumerate(IList):	
        data.append([str(item.priority),
                    item.name,
                    item.duedate and item.duedate.Format('%m/%d/%y') or '',
                    '; '.join([x.split(',')[0] for x in item.owners])]) #just last names

        if item.finisheddate:
            prt.SetCellText(row, 0, wxLIGHT_GREY)
            prt.SetCellText(row, 1, wxLIGHT_GREY)
            prt.SetCellText(row, 2, wxLIGHT_GREY)
            prt.SetCellText(row, 3, wxLIGHT_GREY)

    prt.data = data
    prt.label = ['P','Item','Due','Owner']

    if self.printdata.GetOrientation() == wxPORTRAIT:
        prt.set_column = [.2, 5, .65, 1]
    else:
        prt.set_column = [.2, 7, .65, 1.5]

    title = "Table: %s   Owner: %s    "%(Properties['table'],Properties['owner'])
    prt.SetHeader(title, type='Date &amp; Time', align=wxALIGN_LEFT, indent = 1.5)
    prt.SetFooter("Page No ", type ="Num")

    if prev:
        prt.Preview()
    else:
        prt.Print(prompt=showprtdlg)
</t>
<t tx="ekr.20051104081502.444"></t>
<t tx="ekr.20051104081502.445">def OnWindowExit(self, evt):
    #this is called if you close the ListManager Window with the X
    if evt.CanVeto():
        self.OnExit()
    else:
        evt.Skip()
</t>
<t tx="ekr.20051104081502.446">def OnExit(self, event=None):   
    &lt;&lt; save configuration file &gt;&gt;
    sys.stderr.dlg.Destroy() #destroys the error dialog; need to do this to shut down correctly
    if self.ModifierDialog: #only reason to check is if closed before ModifierDialog is constructed
        self.ModifierDialog.Destroy()
    self.Close(1)
</t>
<t tx="ekr.20051104081502.447">cp.remove_section('Files')
cp.add_section("Files")

x,y = self.GetSizeTuple()

cp.set('Configuration','x', str(x))
cp.set('Configuration','y', str(y))

numfiles = self.filehistory.GetNoHistoryFiles()

for n in range(numfiles):
    cp.set("Files", "path%d"%n, self.filehistory.GetHistoryFile(n))

try:
    #you have to give ConfigParser a writable object
    cfile = file(config_file, 'w')
    cp.write(cfile)
    cfile.close()
except IOError:
    g.pr("The configuration file can't be written!")
    time.sleep(10) #so you can see that there was a problem
</t>
<t tx="ekr.20051104081502.448"></t>
<t tx="ekr.20051104081502.449">def OnFind(self, evt=None):
    self.FindDialog.Show(True)
    self.FindDialog.FindText.SetSelection(-1,-1)
    self.FindDialog.FindText.SetFocus()


</t>
<t tx="ekr.20051104081502.450">def FindString(self, evt=None):
    L = self.L
    Properties = self.PropertyDicts[L]
    cursor = self.Cursors[Properties['host']]
    table = Properties['table']

    pat = self.FindDialog.FindText.GetValue()
    likepat = r"'%"+pat+r"%'"
    finished = self.FindDialog.SearchFinished.GetValue()
    notes = self.FindDialog.SearchNotes.GetValue()

    if finished:
        WHERE = "WHERE "
    else:
        WHERE = "WHERE finisheddate IS NULL AND "

    if notes:
        SELECT = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp,note FROM %s "%table
        WHERE = WHERE + "(name LIKE %s OR note LIKE %s) ORDER BY timestamp DESC"%(likepat,likepat)
    else:
        SELECT = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp FROM %s "%table
        WHERE = WHERE + "name LIKE %s ORDER BY timestamp DESC"%likepat

    sql = SELECT + WHERE			
    try:
        cursor.execute(sql)
    except:
        g.pr("Cannot read %s: %s"%(Properties['host'],table))
        return
    else:
        results = cursor.fetchall()

    case = self.FindDialog.MatchCase.GetValue()
    whole = self.FindDialog.MatchWhole.GetValue()

    if whole:
        pat = '\\b%s\\b'%pat

    if case:
        z = re.compile(pat)
    else:
        z =re.compile(pat, re.I)

    if notes:
        results = [x for x in results if re.search(z,x[1]) or re.search(z,x[10])]
    else:
        results = [x for x in results if re.search(z,x[1])]

    Properties['LCdate'] = 'timestamp'
    self.ItemLists[L]= IList = self.CreateAndDisplayList(results)

    LCtrl = self.ListCtrls[L]
    col_num = self.attr2col_num['date']
    col_info = LCtrl.GetColumn(col_num)
    col_info.SetText(self.date_titles['timestamp'])
    LCtrl.SetColumn(col_num,col_info)

    if IList:
        self.curIdx = 0
        LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
    else:		
        self.curIdx = -1

    self.OnItemSelected()

    Properties['sort'] = {'direction':0,'attribute':'date'}
    Properties['owner'] = '*ALL'

    owner_idx = self.OwnerLBoxes[L].GetSelection()
    if owner_idx != -1:
        self.OwnerLBoxes[L].SetSelection(owner_idx, 0) #get exception if index = -1

    self.SetStatusText("Found %d items"%len(IList))
</t>
<t tx="ekr.20051104081502.451">def FindNode(self, item, showfinished=True):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]

    Properties['owner'] = '*ALL'
    Properties['showfinished'] = showfinished

    self.ItemLists[L] = IList = self.CreateAndDisplayList(self.ReadFromDB())

    id = item.id
    idx = -1
    for item in IList:
        idx+=1
        if id == item.id:
            break
    else:
        idx = -1

    if idx != -1:	
        LCtrl.SetItemState(idx, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        LCtrl.EnsureVisible(idx)
    self.curIdx = idx

</t>
<t tx="ekr.20051104081502.452"></t>
<t tx="ekr.20051104081502.453">def GetCursor(self, host):
    cursor = self.Cursors.get(host)
    if cursor:
        return cursor

    location, rdbms = host.split(':')

    if rdbms == 'sqlite':
        db = os.path.join(DIRECTORY,location,DB)
        try:
            Con = sqlite.connect(db=db, autocommit=1)
            cursor = Con.cursor()
            self.sqlite_connections.append(Con)  #getting a weak reference error from PySQLite and this makes it go away
        except:
            dlg = wxMessageDialog(self,
                    "Could not connect to SQLite database at %s"%location,
                    "Connection problem!",
                    wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            cursor = None

    elif not OFFLINE_ONLY:
        try:
            Con = MySQLdb.connect(host=location, user=USER, passwd=PW, db=DB)
            cursor = Con.cursor()
        except:
            dlg = wxMessageDialog(self,
                    "host = %s | user = %s | password = %s**** | db = %s - could not connect!"%(host,USER,PW[:3],DB),
                    "Connection problem",
                    wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            cursor = None

    if cursor:
        self.Cursors[host] = cursor

    return cursor


</t>
<t tx="ekr.20051104081502.454">def GetNote(self, L=None, item=None):
    if L is None:
        L = self.L

    if item is None:
        if self.curIdx != -1:
            item = self.ItemLists[L][self.curIdx]
        else:
            return ''

    Properties = self.PropertyDicts[L]

    cursor = self.Cursors[Properties['host']]
    table = Properties['table']
    cursor.execute("SELECT note from "+table+" WHERE id = %s", (item.id,))

    ###### Debug -- this does happen where note brings back None 053003
    z = cursor.fetchone()
    if z is None:
        g.pr("In GetNote -&gt; SELECT should not bring back None")
        g.pr("           -&gt; item.id=",item.id)
        z = (None,)
    note = z[0]
    if note is None:
        note = ''
    return note

</t>
<t tx="ekr.20051104081502.455">def CreateTable(self, host, table):
    cursor = self.Cursors[host]
    rdbms = host.split(':')[1]
    if rdbms == 'sqlite':
        sql = """CREATE TABLE '%s' ('id' varchar(36) PRIMARY KEY,
'priority' int(1),
'name' varchar(150),
'createdate' datetime,
'finisheddate' date,
'duedate' date,
'owner1' varchar(25),
'owner2' varchar(25),
'owner3' varchar(25),
'note' text,
'timestamp' timestamp(14))"""%table
    else:
        sql = """CREATE TABLE `%s` (`id` varchar(36) NOT NULL default '',
`priority` int(1) NOT NULL default '1',
`name` varchar(150) NOT NULL default '',
`createdate` datetime NOT NULL default '0000-00-00 00:00:00',
`finisheddate` date default '0000-00-00',
`duedate` date default '0000-00-00',
`owner1` varchar(25) default '',
`owner2` varchar(25) default '',
`owner3` varchar(25) default '',
`note` text,
`timestamp` timestamp(14) NOT NULL,PRIMARY KEY  (`id`)) TYPE=MyISAM"""%table

    cursor.execute(sql)
</t>
<t tx="ekr.20051104081502.456">def ReadFromDB(self):
    L = self.L
    Properties = self.PropertyDicts[L]

    host = Properties['host']
    cursor = self.GetCursor(host)
    if cursor is None:
        return None

    table = Properties['table']

    owner = Properties['owner']
    if owner == '*ALL':
        WHERE = ""
    else:
        WHERE = 'WHERE (owner1 = "%s" OR owner2 = "%s" OR owner3 = "%s")'%(owner,owner,owner)

    #-1 show them all; 0 show none; integer show for that many days
    days = Properties['showfinished']	
    if days != -1:
        if days:
            date = mx.DateTime.now() - days
            t = "(finisheddate IS NULL OR finisheddate &gt; '%s')"%date
        else:
            t = "finisheddate IS NULL"

        if WHERE:
            WHERE = "%s AND %s"%(WHERE,t)
        else:
            WHERE = " WHERE %s"%t

    Sort = Properties['sort']
    if Sort:
        sort_attr = Sort['attribute']
        if sort_attr == 'date':
            sort_attr = Properties['LCdate']
        elif sort_attr == 'owners':
            sort_attr = 'owner1'

        WHERE = WHERE + " ORDER BY " + sort_attr
        #if not direction: WHERE = WHERE + " DESC"   works because ASC is the default
        if not Sort['direction']:
            WHERE = WHERE + " DESC" 

    sql = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp FROM %s %s"%(table,WHERE)

    try:
        cursor.execute(sql)
    except:
        g.pr("Cannot read %s: %s"%(Properties['host'],table))
        return None #[]
    else:
        return cursor.fetchall()



</t>
<t tx="ekr.20051104081502.457">def CreateAndDisplayList(self, results):
    LCtrl = self.ListCtrls[self.L]
    LCdate = self.PropertyDicts[self.L]['LCdate']
    if LCdate == 'timestamp':
        format = '%m/%d %H:%M:%S'
    else:
        format = '%m/%d/%y'
    itemlist = []

    LCtrl.DeleteAllItems()
    class Item: pass

    for x,row in enumerate(results):

        item = Item()
        &lt;&lt; assign item attributes &gt;&gt;
        itemlist.append(item)

        &lt;&lt; draw item &gt;&gt;

    return itemlist


</t>
<t tx="ekr.20051104081502.458">item.priority = int(row[0]) #int(row[0]) needs int because it seems to come back as a long from MySQL
item.name = row[1]
item.createdate = row[2]
item.finisheddate = row[3]
item.duedate = row[4]
item.owners = [y for y in row[5:8] if y] #if you carry around ['tom',None,None] Note this is 5:8 not 5:7
item.id = row[8]
item.timestamp = row[9]

</t>
<t tx="ekr.20051104081502.459">LCtrl.InsertImageStringItem(x, str(item.priority), LCtrl.idx1)
LCtrl.SetStringItem(x,1,item.name)
LCtrl.SetStringItem(x,2,'; '.join(item.owners))
date = item.__dict__[LCdate]
LCtrl.SetStringItem(x,3,date and date.Format(format) or "")

if item.finisheddate:
    LC_Item = LCtrl.GetItem(x)
    LC_Item.SetImage(LCtrl.idx0) #might just want generic number or greyed one two three
    LC_Item.SetTextColour(wxLIGHT_GREY)
    LCtrl.SetItem(LC_Item)

elif item.priority==2:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #resetting weight
    LCtrl.SetItem(LC_Item)

elif item.priority==3:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #return to normal
    LC_Item.SetTextColour(wxRED)
    LCtrl.SetItem(LC_Item)
</t>
<t tx="ekr.20051104081502.460">def OnSync(self, evt=None):
    if self.modified:
        self.OnUpdate()
    #Note that the results of an sqlite query are an instance that you need to turn into a tuple or MySQL gets unhappy

    if OFFLINE_ONLY:
        dlg = wxMessageDialog(self, "You need to be online to synchronize!", style = wxOK|wxICON_ERROR)
        dlg.ShowModal()
        dlg.Destroy()
        return

    dlg = wxMessageDialog(self,"Synchronize Table(s): "+" and ".join(SYNC_TABLES),"Synchronize...",wxICON_QUESTION|wxYES_NO)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return

    if REMOTE_HOST is None:
        g.pr("There doesn't appear to be a Remote Server")
        return

    if LOCAL_HOST is None:
        g.pr("There doesn't appear to be a Local Server")
        return

    g.pr("LOCAL_HOST=",LOCAL_HOST)
    g.pr("REMOTE_HOST=",REMOTE_HOST)

    r_cursor = self.GetCursor(REMOTE_HOST)
    if r_cursor is None:
        g.pr("Couldn't get a cursor for %s"%REMOTE_HOST)
        return

    l_cursor = self.GetCursor(LOCAL_HOST)
    if l_cursor is None:
        g.pr("Couldn't get a cursor for %s"%LOCAL_HOST)
        return

    # moving the sync time back a second to make sure that we don't lose track of any nodes
    #that are being updated or inserted at the same time as we are syncing
    r_cursor.execute("SELECT NOW()")
    l_now = mx.DateTime.now()-mx.DateTime.oneSecond
    r_now = r_cursor.fetchone()[0]-mx.DateTime.oneSecond
    #because of some inconsistent rounding appears necessary to make sure the sqlite timestamp is less than l_now
    #having seen same issue for mysql but for consistency (and because sqlite could also be "server" rdbms
    l_ts = l_now - mx.DateTime.DateTimeDelta(0,0,0,0.02)
    r_ts = r_now - mx.DateTime.DateTimeDelta(0,0,0,0.02)
    g.pr("l_now=",l_now, "l_ts =",l_ts)
    g.pr("r_now=",r_now, "r_ts=",r_ts)

    r_cursor.execute("SELECT MAX(last_sync) FROM user_sync WHERE user = %s", (USER,))
    r_last_sync = r_cursor.fetchone()[0]
    g.pr("last sync (remote time) =",r_last_sync)

    l_cursor.execute("SELECT MAX(last_sync) FROM user_sync")
    l_last_sync = l_cursor.fetchone()[0] #note MAX returns a string with sqlite so we turn it make into DateTime
    l_last_sync = mx.DateTime.DateTimeFrom(l_last_sync)
    g.pr("last sync (local time) =",l_last_sync)

    for table in SYNC_TABLES:
        # Need to pick up changes for both so syncing one doesn't add new things and screw up the second sync
        g.pr("Checking "+table+" on the Remote Server; changes (excluding deletes) are:")
        r_cursor.execute("SELECT id,createdate from "+table+" WHERE timestamp &gt; %s AND timestamp &lt;= %s",(r_last_sync,r_now)) 
        r_results = r_cursor.fetchall()
        g.pr("Server changes (excluding deletes)")
        g.pr(r_results)

        g.pr("Checking "+table+" on Local; changes (excluding deletes) are:")
        l_cursor.execute("SELECT id,createdate from "+table+" WHERE timestamp &gt; %s AND timestamp &lt;= %s",(l_last_sync,l_now))
        l_results = l_cursor.fetchall()
        g.pr("Local changes (excluding deletes)")
        g.pr(l_results)

        for id, createdate in r_results:
            r_cursor.execute("SELECT priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id FROM "+table+" WHERE ID = %s",(id,))
            row = r_cursor.fetchone()
            if row:
                if createdate &gt; r_last_sync:
                    l_cursor.execute("INSERT INTO "+table+" (priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)", row) #*row also works
                    g.pr("Created %s in %s on Local"%(id,table))
                else:
                    l_cursor.execute("UPDATE "+table+" SET priority = %s, name =%s, owner1 = %s, owner2 = %s, owner3 = %s, createdate = %s, finisheddate = %s, duedate = %s, note = %s WHERE id = %s", row)
                    g.pr("Updated %s in %s on Local"%(id,table))
                # for reasons I don't understand l_now here is a 1/100 ahead of l_now when inserted into user_sync
                l_cursor.execute("UPDATE "+table+" SET timestamp = %s WHERE id = %s", (l_ts,id))

        for id, createdate in l_results:
            l_cursor.execute("SELECT priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id FROM "+table+" WHERE ID = %s",(id,))
            row = l_cursor.fetchone()
            if row:
                row = tuple(row)
                #above needed because sqlite returns an enhanced tuple-like object that is not a tuple
                if createdate &gt; l_last_sync:
                    r_cursor.execute("INSERT INTO "+table+" (priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)", row)
                    g.pr("Created %s in %s on Server"%(id,table))
                else:
                    r_cursor.execute("UPDATE "+table+" SET priority = %s, name =%s, owner1 = %s, owner2 = %s, owner3 = %s, createdate = %s, finisheddate = %s, duedate = %s, note = %s WHERE id = %s", row)
                    g.pr("Updated %s in %s on Server"%(id,table))
                r_cursor.execute("UPDATE "+table+" SET timestamp = %s WHERE id = %s", (r_ts,id))

    #Handle the deletes; Note if at some point only 'd's are being written won't have to check for 'd'
    r_cursor.execute("SELECT id,table_name FROM sync WHERE timestamp &gt; %s AND timestamp &lt;= %s AND action = 'd'",(r_last_sync,r_now))
    r_results = r_cursor.fetchall()

    l_cursor.execute("SELECT id,table_name FROM sync WHERE timestamp &gt; %s AND timestamp &lt;= %s AND action = 'd'",(l_last_sync,l_now))
    l_results = l_cursor.fetchall()

    for id,table in l_results:
        r_cursor.execute("DELETE from "+table+" WHERE id = %s", (id,))
        g.pr("Deleted %s from %s on Server (if it existed there)"%(id,table))

    for id,table in r_results:
        l_cursor.execute("DELETE from "+table+" WHERE id = %s", (id,))
        g.pr("Deleted %s from %s on Local (if it existed there)"%(id,table)	)
    #End of deletes code

    #update the user_sync database with the latest sync times
    l_cursor.execute("INSERT INTO user_sync (user,last_sync) VALUES (%s,%s)", (USER,l_now)) #don't really need USER for local
    r_cursor.execute("INSERT INTO user_sync (user,last_sync) VALUES (%s,%s)", (USER,r_now)) 

    g.pr("Synchronization completed")

</t>
<t tx="ekr.20051104081502.461">def TimeStamper(self, host, cursor, table, id):
    #note that you can insert a timestamp value into an mysql timestamp field
    if host.split(':')[1] == 'sqlite': #host -&gt; location:rdbms
        timestamp = mx.DateTime.now()
        cursor.execute("UPDATE "+table+" SET timestamp = %s WHERE id = %s", (timestamp,id))
    else:
        cursor.execute("Select timestamp from "+table+" WHERE id = %s", (id,))
        timestamp = cursor.fetchone()[0]

    return timestamp
</t>
<t tx="ekr.20051104081502.462"></t>
<t tx="ekr.20051104081502.463">def OnShowEvaluate(self, evt=None):

    self.EvalDialog.Show(True)
    self.EvalDialog.EvalText.SetSelection(-1,-1)
    self.EvalDialog.EvalText.SetFocus()

</t>
<t tx="ekr.20051104081502.464">def OnEvaluate(self, evt=None):
    expr = self.EvalDialog.EvalText.GetValue()
    g.pr("%s =&gt; "%expr,newline=False)
    g.pr(eval(expr))

</t>
<t tx="ekr.20051104081502.465"></t>
<t tx="ekr.20051104081502.466">def OnShowAbout(self, evt=None):
    from about import AboutBox
    dlg = AboutBox(self, app_version = VERSION)
    dlg.ShowModal()
    dlg.Destroy()

</t>
<t tx="ekr.20051104081502.467">def OnShowHelp(self, evt=None):
    os.startfile('ListManager.chm')

</t>
<t tx="ekr.20051104081502.468">def GetUID(self):
    pyiid = CreateGuid()
    # the str(pyiid) looks like {....} and doing [1:-1] strips that off
    return str(pyiid)[1:-1]

</t>
<t tx="ekr.20051104081502.469">def OnIdle(self, evt):	
    &lt;&lt; Check for Transfers From Outlook &gt;&gt;
    &lt;&lt; Check if Edited File has Changed &gt;&gt;

</t>
<t tx="ekr.20051104081502.471">if OUTLOOK:
    input,output,exc = select.select([self.sock],[],[],0)
    if input:
        client,addr = self.sock.accept() # Get a connection
        rec = client.recv(8192)
        d = pickle.loads(rec)

        class Item: pass

        item = Item()
        item.id = self.GetUID()
        item.priority = 1
        item.createdate = mx.DateTime.now()
        item.duedate = item.finisheddate = None

        #outlook strings are unicode; ascii encode makes sure no chars above 127
        name = d['Subject'].encode('ascii','replace') 
        item.name = name[:150]

        owner = d['SenderName'].encode('ascii','replace') #encode takes unicode to standard strings
        owner = owner[:25]
        item.owners = [owner]

        note = d['CreationTime'] + '\n' + d['Body'].encode('ascii','replace')
        #foldername = d['Parent.Name']

        #location, rdbms, table = MAIL_LIST_PATH.split(':')
        #host = '%s:%s'%(location,rdbms)
        host, table = re.split('(.*?:.*?):', MAIL_LIST_PATH)[1:3] #really just for fun

        cursor = self.Cursors[host]

        cursor.execute("INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,owner1,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s)",
            (item.priority, name, item.createdate, item.finisheddate, item.duedate, owner, note, item.id))

        item.timestamp = self.TimeStamper(host, cursor, table, item.id)

        #check to see if table is open
        for L,Properties in enumerate(self.PropertyDicts):
            if Properties['table'] == table and Properties['host'] == host:
                break
        else:
            g.pr("Table not open but wrote to database anyway") #Needs to be a dialog box
            return

        # could have started to edit something and never finished it
        if self.modified:
            self.OnUpdate()

        if self.L != L:
            self.nb.SetSelection(L) # Note that this does not call OnPageChange if the page doesn't change

        LCtrl = self.ListCtrls[L]

        if self.curIdx != -1:
            LCtrl.SetItemState(self.curIdx, 0, wxLIST_STATE_SELECTED)

        self.ItemLists[L].insert(0,item)    
        LCtrl.InsertImageStringItem(0,"1", LCtrl.idx1)
        LCtrl.SetStringItem(0,self.attr2col_num['name'],name)
        LCtrl.SetStringItem(0, self.attr2col_num['owners'], owner)

        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(0, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
        elif Properties['LCdate'] == 'createdate':
            LCtrl.SetStringItem(0, self.attr2col_num['date'], item.createdate.Format('%m/%d/%y'))

        LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = 0 

</t>
<t tx="ekr.20051104081502.473">for ed in self.editor:
    path = ed['path']
    t = os.path.getmtime(path)
    if t != ed['time']:
        f = file(path,'r')
        note = f.read()
        f.close()
        ed['time'] = t

        host = ed['host']
        cursor = self.Cursors[host]
        table = ed['table']
        id = ed['id']
        cursor.execute("UPDATE "+table+" SET note = %s WHERE id = %s", (note,id)) 
        # see @rst documentation note
        ts = self.TimeStamper(host, cursor, table, id)

        idx = self.curIdx
        L = self.L
        if idx != -1:
            item = self.ItemLists[L][idx]
            if item.id == id:
                self.note.SetValue(note)
                item.timestamp = ts

                if self.PropertyDicts[L]['LCdate'] == 'timestamp':
                    self.ListCtrls[L].SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))

                if 'note' in self.modified: #if necessary only if somehow note text didn't change
                    del self.modified['note']

</t>
<t tx="ekr.20051104081502.475">class ListCtrl(wxListCtrl, wxListCtrlAutoWidthMixin):
    @others
</t>
<t tx="ekr.20051104081502.476">def __init__(self, parent, ID, pos=wxDefaultPosition, size=wxDefaultSize, style=0):
    wxListCtrl.__init__(self, parent, ID, pos, size, style)
    wxListCtrlAutoWidthMixin.__init__(self)

    self.il = wxImageList(16,16)

    sm_up = self.il.Add(wxBitmap('bitmaps\\up_arrow.bmp')) #(images.getSmallUpArrowBitmap())
    sm_dn = self.il.Add(wxBitmap('bitmaps\\down_arrow.bmp'))
    self.arrows = (sm_up,sm_dn)

    self.idx1 = self.il.Add(wxBitmap('bitmaps\\box.bmp'))
    self.idx0 = self.il.Add(wxBitmap('bitmaps\\filledwhitebox.bmp'))    

    self.SetImageList(self.il, wxIMAGE_LIST_SMALL)

    EVT_LIST_COL_BEGIN_DRAG(self, self.GetId(), self.OnColBeginDrag)    

    self.SetUpColumns()

</t>
<t tx="ekr.20051104081502.477">def SetUpColumns(self):
    #Need to to construct column heads for columns with sorting by hand to get sorting images on columns
    info = wxListItem()
    info.m_mask = wxLIST_MASK_TEXT | wxLIST_MASK_IMAGE | wxLIST_MASK_FORMAT
    info.m_image = -1

    #Oth column is priority which is sortable
    info.m_format = wxLIST_FORMAT_LEFT
    info.m_text = "P"
    self.InsertColumnInfo(0, info)
    self.SetColumnWidth(0, 35)

    self.InsertColumn(1, "Name")
    self.SetColumnWidth(1, 590)

    self.InsertColumn(2, "Owner")
    self.SetColumnWidth(2, 100)

    #3th column is create ate and same as with priority - needs to constructed by hand
    info.m_format = wxLIST_FORMAT_LEFT
    info.m_text = "Due Date"
    self.InsertColumnInfo(3, info)
    self.SetColumnWidth(3, 75)                

</t>
<t tx="ekr.20051104081502.478">def OnColBeginDrag(self, evt):
    #if inplace editor then change its dimensions
    if evt.GetColumn() == 0:
        evt.Veto()
</t>
<t tx="ekr.20051104081502.479">class MyApp(wxApp):
    @others
</t>
<t tx="ekr.20051104081502.480">def OnInit(self):
    global OFFLINE_ONLY, CANCEL
    wxInitAllImageHandlers()

    if STARTUP_DIALOG:
        startup = StartupDialog(None, 'List Manager')
        val = startup.ShowModal()
        startup.Destroy()
        if val == wxID_YES:
            OFFLINE_ONLY = True
        elif val == wxID_NO:
            OFFLINE_ONLY = False
        elif val == wxID_CANCEL:
            CANCEL = True
            return True

    if OFFLINE_ONLY is False:
        server = REMOTE_HOST.split(':')[0]
        try:
            socket.gethostbyname(server)
        except:
            dlg = wxMessageDialog(None, "Cannot connect to remote server! Only offline access is possible.", "ListManager", style=wxOK|wxICON_EXCLAMATION|wxSTAY_ON_TOP)
            dlg.ShowModal()
            dlg.Destroy()
            OFFLINE_ONLY = True

    frame = ListManager(None, -1, "List Manager", size = (X,Y))
    frame.Show(True)
    self.SetTopWindow(frame)
    CANCEL = False
    return True


</t>
<t tx="ekr.20051104081502.481">class Logger:
    def __init__(self):
        self.dlg = LoggerDialog(None, "", "Alerts and Exceptions", dir=DIRECTORY)
    def write(self, error_msg):
        if not self.dlg.IsShown():
            self.dlg.text.AppendText("\n%s\n"%time.asctime())
            self.dlg.Show(True)

        self.dlg.text.AppendText(error_msg)

</t>
<t tx="ekr.20051104081502.482">def run():
    app = MyApp(0)
    if not CANCEL:
        sys.stderr = sys.stdout = Logger()
        app.MainLoop()

if __name__ == '__main__':
    run()
</t>
<t tx="ekr.20051104081502.483">@ @rst-options
code_mode = True
@c


@language python
from wxPython.wx import *
# the following two are needed for the calendar
from wxPython.calendar import *
from wxPython.utils import *
import os
@others
</t>
<t tx="ekr.20051104081502.484">class TicklerDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.485">def __init__(self, parent, msg, caption, pos = wxDefaultPosition, size = wxDefaultSize):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP | wxTHICK_FRAME | wxCAPTION)

    TC = wxTextCtrl(self, -1, msg, wxDefaultPosition,
                    (450,250),
                    wxTE_MULTILINE | wxTE_READONLY | wxTE_RICH2)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)        

    sizer.Add(TC, 1, wxALIGN_CENTRE|wxALL, 5)
    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)

    sizer.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)
    btn = wxButton(self, wxID_OK, "GO TO ITEM")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_FORWARD, "SHOW NEXT")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_APPLY, "MAIL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)        

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)

    EVT_LEFT_DOWN(TC, self.OnLeftDown)
    EVT_BUTTON(self, wxID_FORWARD, self.OnForward)
    EVT_BUTTON(self, wxID_APPLY, self.OnMail)

    TC.SetCursor(wxStockCursor(wxCURSOR_ARROW))        

    self.TC = TC
</t>
<t tx="ekr.20051104081502.486">def OnLeftDown(self, evt):
    self.EndModal(wxID_OK)
</t>
<t tx="ekr.20051104081502.487">def OnForward(self, evt):
    self.EndModal(wxID_FORWARD)
</t>
<t tx="ekr.20051104081502.488">def OnMail(self, evt):
    self.EndModal(wxID_APPLY)        
</t>
<t tx="ekr.20051104081502.489">class StartupDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.490">def __init__(self, parent, caption, pos=wxDefaultPosition, size=(300,115)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)

    msg = "You can connect to the server using the network,\nor work offline, or cancel this logon."

    image = wxStaticBitmap(self, -1, wxBitmap('bitmaps\\wxpdemo.bmp'), (-1,-1), size=(32,32)) #sizer determines position
    text = wxStaticText(self, -1, msg, (-1,-1), size=(250,32)) #sizer determines position

    rect = wxBoxSizer(wxHORIZONTAL)
    rect.Add(image, 0, wxALIGN_LEFT|wxALL, 4)
    rect.Add(text, 1, wxALIGN_CENTER|wxTOP, 7)
    sizer = wxBoxSizer(wxVERTICAL)


    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_NO, 'Connect')
    box.Add(btn, 0, wxALL, 10)
    btn.SetDefault()

    btn = wxButton(self, wxID_YES, 'Work Offline')
    box.Add(btn, 0, wxALL, 10)

    btn = wxButton(self, wxID_CANCEL, 'Cancel')
    box.Add(btn, 0, wxALL, 10)

    sizer.AddSizer(rect)
    sizer.AddSizer(box)

    self.SetSizer(sizer)

    EVT_BUTTON(self, wxID_NO, self.OnSelection)
    EVT_BUTTON(self, wxID_YES, self.OnSelection)
    EVT_BUTTON(self, wxID_CANCEL, self.OnSelection)
</t>
<t tx="ekr.20051104081502.491">def OnSelection(self,evt):
    val = evt.GetId()
    self.EndModal(val)
</t>
<t tx="ekr.20051104081502.492">class ModifierDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.493">def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxCAPTION,
             modifierlist=None,
             curselections = ''):
    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    sizer1 = wxBoxSizer(wxVERTICAL)
    sizer2 = wxBoxSizer(wxHORIZONTAL)

    tc = wxTextCtrl(self, -1, "", size = (150,-1))
    sizer1.Add(tc, 0, wxALIGN_CENTRE|wxALL, 5)
    self.tc = tc

    if not modifierlist:
        modifierlist = []
    lb = wxListBox(self, -1,  wxDefaultPosition, (150,300), #wxPoint(90, 80)
                    modifierlist, wxLB_MULTIPLE|wxLB_SORT)

    sizer1.Add(lb, 1, wxALIGN_CENTRE|wxALL, 5)

    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    sizer1.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)


    btn = wxButton(self, wxID_OK, "OK")
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer1.AddSizer(sizer2, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer1)
    self.SetAutoLayout(True)
    sizer1.Fit(self)

    for sel in curselections:
        index = lb.FindString(sel)
        if index !=-1:
            lb.SetSelection(index)

    self.lb = lb

    EVT_BUTTON(self, wxID_CANCEL, self.ClearSelections)


</t>
<t tx="ekr.20051104081502.494">def GetUserInput(self):
    idx_list = self.lb.GetSelections()
    mod_list =[]
    for i in idx_list:
        mod_list.append(self.lb.GetString(i))
        self.lb.Deselect(i) #071203

    new_list = []
    manual_string = self.tc.GetValue() #text entry box

    if manual_string:
        manual_list = [x.strip() for x in manual_string.split(';')]
        for name in manual_list:
            clean_name = ", ".join([x.strip().title() for x in name.split(',')])
            if clean_name not in mod_list:
                mod_list.append(clean_name)
                new_list.append(clean_name)


    return (mod_list, new_list)
</t>
<t tx="ekr.20051104081502.495">def SelectCurrent(self, cur_sel):
    for sel in cur_sel:
        index = self.lb.FindString(sel)
        if index !=-1:
            self.lb.SetSelection(index)


</t>
<t tx="ekr.20051104081502.496">def ClearSelections(self, evt=None):
    idx_list = self.lb.GetSelections() #note you can't just use the indexes of the SelectCurrent since they may have clicked before cancelling
    for i in idx_list:
        self.lb.Deselect(i)

    evt.Skip()
</t>
<t tx="ekr.20051104081502.497">class MailDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.498">def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxSTAY_ON_TOP| wxTHICK_FRAME|wxCAPTION|wxSYSTEM_MENU,
             recipients='',
             subject = '',
             body = ''):

    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)

    recipients = "; ".join(recipients)
    label = wxStaticText(self, -1, "To:",wxDefaultPosition, size=(40,-1), style=wxALIGN_LEFT)
    RTC = wxTextCtrl(self, -1, recipients, size = (480,-1))
    box.Add(label)
    box.Add(RTC)

    #sizer.Add(10,10,0)      

    sizer.AddSizer(box)        

    box = wxBoxSizer(wxHORIZONTAL)       
    label = wxStaticText(self, -1, "Subject:",wxDefaultPosition, size=(40,-1),style=wxALIGN_LEFT)
    STC = wxTextCtrl(self, -1, subject, size = (480,-1)) 
    box.Add(label)
    box.Add(STC)

    sizer.AddSizer(box)
    sizer.Add(1, 5, 0)

    BTC = wxTextCtrl(self, -1, body, wxDefaultPosition, size = (500,400), style=wxTE_MULTILINE|wxTE_RICH2)

    sizer.Add(BTC)

    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_OK, "SEND MAIL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer.AddSizer(box)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)

    self.RTC = RTC
    self.STC = STC
    self.BTC = BTC

</t>
<t tx="ekr.20051104081502.499">class CalendarDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.500">def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxCAPTION,
             date=0):

    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    if not date:
        date = wxDateTime_Now()

    cal = wxCalendarCtrl(self, -1, date, #pos = (25,50),
                         style = wxCAL_SHOW_HOLIDAYS | wxCAL_SUNDAY_FIRST)

    EVT_CALENDAR(self, cal.GetId(), self.OnCalSelected)

    #EVT_CLOSE(self, self.OnCloseWindow)          

    self.cal = cal

    # Set up control to display a set of holidays:
    EVT_CALENDAR_MONTH(self, cal.GetId(), self.OnChangeMonth)

    self.holidays = [(1,1), (10,31), (12,25) ]    # (these don't move around)

    self.OnChangeMonth()        

#-------------------------------------------------------------------------        
    sizer1 = wxBoxSizer(wxVERTICAL)
    sizer2 = wxBoxSizer(wxHORIZONTAL)

    sizer1.Add(cal, 0, wxALIGN_CENTRE|wxALL, 5)

    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    sizer1.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxRIGHT|wxTOP, 5)


    btn = wxButton(self, wxID_OK, "OK")
    btn.SetDefault()
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    #btn.SetDefault()
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer1.AddSizer(sizer2, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer1)
    self.SetAutoLayout(True)
    sizer1.Fit(self)
</t>
<t tx="ekr.20051104081502.501">def OnCalSelected(self, evt):
    self.result = evt.GetDate()
    self.EndModal(wxID_OK)
</t>
<t tx="ekr.20051104081502.502">def OnChangeMonth(self, evt=None):
    cur_month = self.cal.GetDate().GetMonth() + 1   # convert wxDateTime 0-11 =&gt; 1-12
    for month, day in self.holidays:
        if month == cur_month:
            self.cal.SetHoliday(day)        
</t>
<t tx="ekr.20051104081502.503">def OnCloseWindow(self, event):
    #self.cal.Destroy
    #self.Destroy()
    g.pr("I got to close window")
</t>
<t tx="ekr.20051104081502.504">def GetDate(self):
    return self.result
</t>
<t tx="ekr.20051104081502.505">class FindDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.506">def __init__(self, parent, caption, msg, pos=wxDefaultPosition, size=(300,120)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)    

    self.FindText = wxTextCtrl(self, -1, msg, wxDefaultPosition,(200,24))

    box_a = wxBoxSizer(wxHORIZONTAL)
    box_a.Add(self.FindText, 1, wxALIGN_CENTER|wxALL, 5)

    box_b = wxBoxSizer(wxVERTICAL)        
    btn = wxButton(self, wxID_OK, "OK")
    box_b.Add(btn, 0, wxALIGN_CENTER|wxALL,5)
    btn.SetDefault()               

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box_b.Add(btn, 0, wxALIGN_CENTER)

    box_a.AddSizer(box_b)

    self.MatchCase = wxCheckBox(self, -1, "Match Case")
    self.MatchWhole = wxCheckBox(self, -1, "Match Whole Word")
    box_c = wxBoxSizer(wxVERTICAL)
    box_c.Add(self.MatchCase, 0, wxLEFT|wxBOTTOM, 5)
    box_c.Add(self.MatchWhole, 0, wxLEFT, 5)

    self.SearchNotes = wxCheckBox(self, -1, "Search Notes")
    self.SearchFinished = wxCheckBox(self, -1, "Search Finished")
    box_d = wxBoxSizer(wxVERTICAL)
    box_d.Add(self.SearchNotes, 0, wxLEFT|wxBOTTOM, 5)
    box_d.Add(self.SearchFinished, 0, wxLEFT, 5)

    box_e = wxBoxSizer(wxHORIZONTAL)
    box_e.AddSizer(box_c)
    box_e.AddSizer(box_d)

    sizer = wxBoxSizer(wxVERTICAL)
    sizer.AddSizer(box_a)
    sizer.AddSizer(box_e)

    self.SetSizer(sizer)

    EVT_BUTTON(self, wxID_OK, parent.FindString)


</t>
<t tx="ekr.20051104081502.507">class EvalDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.508">def __init__(self, parent, caption, msg, pos=wxDefaultPosition, size=(300,80)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)    

    EvalText = wxTextCtrl(self, -1, msg, wxDefaultPosition,(200,24))


    box_a = wxBoxSizer(wxHORIZONTAL)
    box_a.Add(EvalText, 1, wxALIGN_CENTER|wxALL, 5)

    box_b = wxBoxSizer(wxVERTICAL)        
    btn = wxButton(self, wxID_OK, "OK")
    box_b.Add(btn, 0, wxALIGN_CENTER|wxALL,5)
    btn.SetDefault()               

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box_b.Add(btn, 0, wxALIGN_CENTER)

    box_a.AddSizer(box_b)

    self.SetSizer(box_a)

    self.EvalText = EvalText
    self.parent = parent

    #EVT_BUTTON(self, wxID_OK, self.PostOKEvent)
    EVT_BUTTON(self, wxID_OK, parent.OnEvaluate)



</t>
<t tx="ekr.20051104081502.509">def PostOKEvent(self, evt=None):
    wxPostEvent(self.parent, evt)
</t>
<t tx="ekr.20051104081502.510">class LoggerDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.511">def __init__(self, parent, msg, caption, pos=(-1,-1), size=(500,300), dir=None):
    wxDialog.__init__(self, parent, -1, caption, pos, size)
    #if pos == (-1,-1):
        #self.CenterOnScreen(wxBOTH)

    if dir:
        self.dir = dir
    else:
        self.dir = os.getcwd()

    text = wxTextCtrl(self, -1, msg, (-1,-1), (450,250), wxTE_MULTILINE | wxTE_READONLY)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)        

    sizer.Add(text, 1, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_OK, "Close")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    ID_SAVE = wxNewId()

    btn = wxButton(self, ID_SAVE, "Save to File")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)        

    sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)

    self.text = text

    EVT_BUTTON(self, ID_SAVE, self.OnSave)
</t>
<t tx="ekr.20051104081502.512">def OnSave(self, evt):

    path = os.path.join(self.dir, 'logfile.txt')

    f = file(path,'a')
    f.write(self.text.GetValue())
    f.close()

    dlg = wxMessageDialog(self,"Appended text to logfile.text", "Notice", wxICON_INFORMATION|wxOK)
    dlg.ShowModal()
    dlg.Destroy()

    self.text.Clear()
</t>
<t tx="ekr.20051104081502.513">class FinishedDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.514">def __init__(self, parent, title,
            pos=wxDefaultPosition,
            size=wxDefaultSize,
            style=wxCAPTION,
            days=0,
            spin_label="",
            check_label=""):

    wxDialog.__init__(self, parent, -1, title, pos, size)
    self.Centre()

    self.check = wxCheckBox(self, -1, check_label)

    if days == -1:
        self.check.SetValue(True)
        days = 0

    panel = wxPanel(self, -1, (-1,-1),(225,75))
    wxStaticText(panel, -1, spin_label,(15, 15))
    self.text = wxTextCtrl(panel, -1, str(days), (30, 50), (30, -1))
    h = self.text.GetSize().height
    self.spin = wxSpinButton(panel, -1, (56, 50), (h, h), wxSP_VERTICAL)
    wxStaticText(panel, -1, 'days',(76, 53))
    self.spin.SetRange(0, 14)
    self.spin.SetValue(days)

    H_sizer = wxBoxSizer(wxHORIZONTAL)

    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)

    btn = wxButton(self, wxID_OK, "OK")
    H_sizer.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    H_sizer.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    V_sizer = wxBoxSizer(wxVERTICAL)
    V_sizer.Add(panel,1,wxALIGN_CENTER|wxEXPAND)
    V_sizer.Add(-1,5)
    V_sizer.Add(self.check,0,wxALIGN_LEFT|wxALL,5)
    V_sizer.Add(line,0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)
    V_sizer.AddSizer(H_sizer, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)

    self.SetSizer(V_sizer)
    self.SetAutoLayout(True)
    V_sizer.Fit(self)

    EVT_SPIN(self, self.spin.GetId(), self.OnSpin)
    EVT_CHECKBOX(self, self.check.GetId(), self.OnCheck)

    if self.check.GetValue():
        self.spin.Enable(False)
        self.text.Enable(False)

    self.Layout() #doesn't appear necessary


</t>
<t tx="ekr.20051104081502.515">def OnSpin(self, evt):
    self.text.SetValue(str(evt.GetPosition()))
</t>
<t tx="ekr.20051104081502.516">def OnCheck(self, evt=None):
    if self.check.GetValue():
        self.spin.Enable(False)
        self.text.Enable(False)
    else:
        self.spin.Enable(True)
        self.text.Enable(True)
</t>
<t tx="ekr.20051104081502.517">class TreeDialog(wxDialog):
    @others
</t>
<t tx="ekr.20051104081502.518">def __init__(self, parent, caption, pos=wxDefaultPosition, size=(300,400), tree={}):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)

    TreeCtrl = wxTreeCtrl(self, -1, wxDefaultPosition, (300,400), wxTR_HAS_BUTTONS)    #|wxTR_HIDE_ROOT)#wxDefaultSize,

    sizer = wxBoxSizer(wxVERTICAL)
    sizer.Add(TreeCtrl, 1, wxALIGN_CENTER|wxALL, 5)

    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_OK, "OK")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer.AddSizer(box)
    self.SetAutoLayout(1)
    self.SetSizer(sizer)

    il = wxImageList(16,16)

    fldridx = il.Add(wxBitmap('bitmaps\\folder.bmp'))
    fldropenidx = il.Add(wxBitmap('bitmaps\\folder_open.bmp'))
    listidx =  il.Add(wxBitmap('bitmaps\\list.bmp'))

    TreeCtrl.SetImageList(il)

    root = TreeCtrl.AddRoot("List Manager")
    TreeCtrl.SetItemImage(root, fldridx, wxTreeItemIcon_Normal)
    TreeCtrl.SetItemImage(root, fldropenidx, wxTreeItemIcon_Expanded)

    for host in tree:
        child = TreeCtrl.AppendItem(root, host)
        TreeCtrl.SetItemImage(child, fldridx, wxTreeItemIcon_Normal)
        TreeCtrl.SetItemImage(child, fldropenidx, wxTreeItemIcon_Expanded)
        for listname in tree[host]:
            last = TreeCtrl.AppendItem(child, listname)
            TreeCtrl.SetItemImage(last, listidx, wxTreeItemIcon_Normal)
            TreeCtrl.SetItemImage(last, listidx, wxTreeItemIcon_Selected)

    TreeCtrl.Expand(root)

    self.TreeCtrl= TreeCtrl
    self.il = il #? prevents GC

    EVT_LEFT_DCLICK(TreeCtrl, self.OnLeftDClick)
</t>
<t tx="ekr.20051104081502.519">def OnLeftDClick(self, event=None):
    self.EndModal(wxID_OK)
</t>
<t tx="ekr.20051104081502.520">@ @rst-options
code_mode = True
@c

@language python
&lt;&lt; outlookAddin declarations &gt;&gt;
@others

if __name__ == '__main__':
    import win32com.server.register
    win32com.server.register.UseCommandLine(OutlookAddin)
    if "--unregister" in sys.argv:
        UnregisterAddin(OutlookAddin)
    else:
        RegisterAddin(OutlookAddin)
</t>
<t tx="ekr.20051104081502.521"># This is mainly stolen from Mark Hammond's demo plugin for win32com.client
# A demo plugin for Microsoft Outlook (NOT Outlook Express)

from win32com import universal
from win32com.server.exception import COMException
from win32com.client import gencache, DispatchWithEvents
from win32com.client import Dispatch
import winerror
import pythoncom
from win32com.client import constants
import win32ui ##
import sys
from socket import *
import pickle

# Support for COM objects we use.
#sz comment gencache.EnsureModule makes sure you are using makepy if the makepy-derived
#file doesn't already exist
#but as long as you did run makepy then you should just be alble to do a normal dispatch

mod = gencache.EnsureModule('{00062FFF-0000-0000-C000-000000000046}', 0, 9, 0, bForDemand=True) # Outlook 9
gencache.EnsureModule('{2DF8D04C-5BFA-101B-BDE5-00AA0044DE52}', 0, 2, 1, bForDemand=True) # Office 9

# The TLB defining the interfaces we implement
universal.RegisterInterfaces('{AC0714F2-3D04-11D1-AE7D-00A0C90F26F4}', 0, 1, 0, ["_IDTExtensibility2"])

Target = 'mail_transfer'


</t>
<t tx="ekr.20051104081502.522">class ButtonEvent:
    @others
</t>
<t tx="ekr.20051104081502.523">def OnClick(self, button, cancel):
    #activeExplorer and MailTransferFolder are globals defined in OnConnection
    sel = activeExplorer.Selection

    for i in range(1,sel.Count+1):
        item = sel.Item(i)
        item.Move(MailTransferFolder)

    return cancel

</t>
<t tx="ekr.20051104081502.524">class FolderEvent:
    @others
</t>
<t tx="ekr.20051104081502.525">def OnItemAdd(self, item):
    try:
        s = socket(AF_INET,SOCK_STREAM)
        s.connect(('localhost', 8888))
        d = {}
        d['Parent.Name'] = item.Parent.Name
        d['SenderName'] = item.SenderName
        d['Subject'] = item.Subject
        d['Body'] = item.Body[:5000]
        d['CreationTime'] = item.CreationTime.Format()
        str = pickle.dumps(d)
        s.send(str) # ?Receive no more than 1024 bytes
        s.close()
        win32ui.MessageBox("Sent %s to ListManager"%item.Subject)
    except:
        pass
</t>
<t tx="ekr.20051104081502.526">class OutlookAddin:
    &lt;&lt; class OutlookAddin declarations &gt;&gt;
    @others
</t>
<t tx="ekr.20051104081502.527">_com_interfaces_ = ['_IDTExtensibility2']
_public_methods_ = []
_reg_clsctx_ = pythoncom.CLSCTX_INPROC_SERVER
_reg_clsid_ = "{0F47D9F3-598B-4d24-B7E3-92AC15ED27E2}"
_reg_progid_ = "Python.Test.OutlookAddin"
_reg_policy_spec_ = "win32com.server.policy.EventHandlerPolicy"
</t>
<t tx="ekr.20051104081502.528">def OnConnection(self, application, connectMode, addin, custom):
    global MailTransferFolder
    global activeExplorer
    # ActiveExplorer may be none when started without a UI (eg, WinCE synchronisation)
    activeExplorer = application.ActiveExplorer()
    if activeExplorer:
        bars = activeExplorer.CommandBars
        toolbar = bars.Item("Standard")
        item = toolbar.Controls.Add(Type=constants.msoControlButton, Temporary=True)
        item = self.toolbarButton = DispatchWithEvents(item, ButtonEvent) #? just need this to be an ivar
        item.Caption="List Manager"
        item.TooltipText = "Click to move"
        item.Enabled = True
        #self.toolbarButton = DispatchWithEvents(item, ButtonEvent) #need something that won't get GC'd. Note Dispatch returns item

    ns = application.GetNamespace("MAPI")
    Folders = ns.Folders

    for i in range(1,len(Folders)+1):
        if Folders[i].Name.find("Mailbox") != -1:
            folders = Folders[i].Folders
            break
    else:
        win32ui.MessageBox("Can't find Mailbox!")
        return	

    for i in range(1,len(folders)+1):
        if folders[i].Name == Target:
            MailTransferFolder = folders[i]
            self.targetMailbox = DispatchWithEvents(folders[i].Items, FolderEvent) #? just need this to be an ivar
            win32ui.MessageBox("Enabled: %s\nOutlookAddin3"%Target)
            break
    else:
        win32ui.MessageBox("Could not find mail folder: %s\nOutlookAddin3"%Target)
</t>
<t tx="ekr.20051104081502.529">def OnDisconnection(self, mode, custom):
    g.pr("OnDisconnection")
</t>
<t tx="ekr.20051104081502.530">def OnAddInsUpdate(self, custom):
    g.pr("OnAddInsUpdate", custom)
</t>
<t tx="ekr.20051104081502.531">def OnStartupComplete(self, custom):
    g.pr("OnStartupComplete", custom)
</t>
<t tx="ekr.20051104081502.532">def OnBeginShutdown(self, custom):
    g.pr("OnBeginShutdown", custom)
</t>
<t tx="ekr.20051104081502.533">def RegisterAddin(klass):
    import _winreg
    key = _winreg.CreateKey(_winreg.HKEY_CURRENT_USER, "Software\\Microsoft\\Office\\Outlook\\Addins")
    subkey = _winreg.CreateKey(key, klass._reg_progid_)
    _winreg.SetValueEx(subkey, "CommandLineSafe", 0, _winreg.REG_DWORD, 0)
    _winreg.SetValueEx(subkey, "LoadBehavior", 0, _winreg.REG_DWORD, 3)
    _winreg.SetValueEx(subkey, "Description", 0, _winreg.REG_SZ, klass._reg_progid_)
    _winreg.SetValueEx(subkey, "FriendlyName", 0, _winreg.REG_SZ, klass._reg_progid_)
</t>
<t tx="ekr.20051104081502.534">def UnregisterAddin(klass):
    import _winreg
    try:
        _winreg.DeleteKey(_winreg.HKEY_CURRENT_USER, "Software\\Microsoft\\Office\\Outlook\\Addins\\" + klass._reg_progid_)
    except WindowsError:
        pass
</t>
<t tx="ekr.20051104081502.535">########
Headline
########

@ @rst-options
.. These options have NO EFFECT for rst2 plugin!
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=c:\prog\leoCVS\leo\doc
write_intermediate_file = True
verbose=True
@c

This is a test of pdf stuff

.. contents::
</t>
<t tx="ekr.20051104081502.536"></t>
<t tx="ekr.20051104081502.537">child node text
</t>
<t tx="ekr.20051104081502.538">import sys
sys.path.append(r'c:\reportlab_1_20')

debug = True

@others

from reportlab.pdfgen import canvas
c = canvas.Canvas('hello.pdf')
for i in (10,50):
    text(c,'x'*10,i,i)
# pencil(c,text='Note')

key = 'key1'

c.bookmarkPage(key)
c.addOutlineEntry('OutlineEntry',key)


c.showPage()
c.save()
</t>
<t tx="ekr.20051104081502.539">def text(c,text,i=100,j=100):
    c.drawString(i,j,text)
</t>
<t tx="ekr.20051104081502.540">def pencil(canvas, text="No.2"):
    from reportlab.lib.colors import yellow, red, black,white
    from reportlab.lib.units import inch
    u = inch/10.0
    canvas.setStrokeColor(black)
    canvas.setLineWidth(4)
    # draw erasor
    canvas.setFillColor(red)
    canvas.circle(30*u, 5*u, 5*u, stroke=1, fill=1)
    # draw all else but the tip (mainly rectangles with different fills)
    canvas.setFillColor(yellow)
    canvas.rect(10*u,0,20*u,10*u, stroke=1, fill=1)
    canvas.setFillColor(black)
    canvas.rect(23*u,0,8*u,10*u,fill=1)
    canvas.roundRect(14*u, 3.5*u, 8*u, 3*u, 1.5*u, stroke=1, fill=1)
    canvas.setFillColor(white)
    canvas.rect(25*u,u,1.2*u,8*u, fill=1,stroke=0)
    canvas.rect(27.5*u,u,1.2*u,8*u, fill=1, stroke=0)
    canvas.setFont("Times-Roman", 3*u)
    canvas.drawCentredString(18*u, 4*u, text)
    # now draw the tip
    penciltip(canvas,debug=0)
    # draw broken lines across the body.
    canvas.setDash([10,5,16,10],0)
    canvas.line(11*u,2.5*u,22*u,2.5*u)
    canvas.line(22*u,7.5*u,12*u,7.5*u)
</t>
<t tx="ekr.20051104081502.541">def penciltip(canvas, debug=1):
    from reportlab.lib.colors import tan, black, green
    from reportlab.lib.units import inch
    u = inch/10.0
    canvas.setLineWidth(4)
    if debug:
        canvas.scale(2.8,2.8) # make it big
        canvas.setLineWidth(1) # small lines
    canvas.setStrokeColor(black)
    canvas.setFillColor(tan)
    p = canvas.beginPath()
    p.moveTo(10*u,0)
    p.lineTo(0,5*u)
    p.lineTo(10*u,10*u)
    p.curveTo(11.5*u,10*u, 11.5*u,7.5*u, 10*u,7.5*u)
    p.curveTo(12*u,7.5*u, 11*u,2.5*u, 9.7*u,2.5*u)
    p.curveTo(10.5*u,2.5*u, 11*u,0, 10*u,0)
    canvas.drawPath(p, stroke=1, fill=1)
    canvas.setFillColor(black)
    p = canvas.beginPath()
    p.moveTo(0,5*u)
    p.lineTo(4*u,3*u)
    p.lineTo(5*u,4.5*u)
    p.lineTo(3*u,6.5*u)
    canvas.drawPath(p, stroke=1, fill=1)
    if debug:
        canvas.setStrokeColor(green) # put in a frame of reference
        canvas.grid([0,5*u,10*u,15*u], [0,5*u,10*u])
</t>
<t tx="ekr.20051104081502.542"></t>
<t tx="ekr.20051104081502.543">part 1, line 1
part 2, line 2, no newline
</t>
<t tx="ekr.20051104081502.544">part 2, line 1, no newline
</t>
<t tx="ekr.20051104081502.545">part 3, line 1
part 3, line 2, newline
</t>
<t tx="ekr.20051104081502.546"># g.app.config.updateSettings(c)
g.es('test_setting',c.config.getBool('test_setting'))
</t>
<t tx="ekr.20051104081502.547"># This problem has been around forever.
g.pr('-' * 40)
# Yes. We *do* want to warn in c.config.exists.
g.pr('exists',g.app.config.exists(c,'showMinibuffer','bool'))
val = c.config.getBool('showMinibuffer')
g.pr('bool:showMinibuffer',val)
val = c.config.getShortcut('showMinibuffer')
g.pr('shortcut:showMinibuffer',val)
</t>
<t tx="ekr.20051104081502.548">c.frame.log.selectTab('Test')
g.es('Test',color='red',tabName='Test')
</t>
<t tx="ekr.20051104081502.549">c.frame.log.selectTab('Log')
g.es('Test',color='blue')
</t>
<t tx="ekr.20051104081502.551">k = c.keyHandler

def f (event):
    g.es_print('Hello',color='purple')

def f2 (event):
    g.es_print('Hello2',color='purple')

k.registerCommand('print-hello','Alt-Ctrl-Shift-p',f)
k.registerCommand('print-hello2',None,f2)
</t>
<t tx="ekr.20051104081502.99"></t>
<t tx="ekr.20051107115231.25"># getWidth no longer exists.
k = c.keyHandler
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    # assert w == w2 or hasattr(w,'widget') and w.widget == w2,'w: %s\nw2: %s' % (w,w2)
    w.setSelectionRange('end','end')
    n = w.getWidth()
    g.app.gui.event_generate(c,'X','Shift+X',w)
    g.app.gui.event_generate(c,'Y','Shift+Y',w)
    g.app.gui.event_generate(c,'Z','Shift+Z',w)
    g.app.gui.event_generate(c,'\n','Return',w)
    w.update()
    assert w, 'fail 2'
   
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20060127120604"></t>
<t tx="ekr.20060208195054"># c.commandsDict: keys are emacs command names, values are functions f.
# k.inverseCommandsDict: keys are f.__name__, values are emacs command names.

@others

d1 = c.commandsDict ; d2 = c.k.inverseCommandsDict

if 0:
    vals = d2.values() ; vals.sort()
    vals = [z for z in vals if z.startswith('contract')]
    g.pr('inverseCommandsDict.values()',vals)

keys1 = d1.keys() ; keys1.sort()
vals1 = d1.values()
vals1 = [f.__name__ for f in vals1]
vals1.sort()

keys2 = d2.keys() ; keys2.sort()
vals2 = d2.values(); vals2.sort()

if 0:
    g.pr(keys1,'\n\n')
    g.pr(vals2,'\n\n')
    g.pr(keys2,'\n\n')
    g.pr(vals1)

# g.trace(g.dictToString(c.k.abbreviationsDict))

abbrevDict = c.config.getAbbrevDict()

# Find @button and @command nodes in this file.
@others
buttonKeys = []
for p in c.allNodes_iter():
    h = p.h.strip().lower()
    for kind in ('@button','@command'):
        if h.startswith(kind):
            key1 = mungeKey(h,kind,substitute=False)
            if key1 not in buttonKeys:
                buttonKeys.append(key1)
            key = mungeKey(h,kind,substitute=True)
            if key not in buttonKeys:
                buttonKeys.append(key)

for z in g.app.config.atCommonButtonsList:
    h,junk = z
    key = mungeKey(h,'@button')
    # g.trace(key)
    if key not in buttonKeys:
        buttonKeys.append(key)

# g.pr('buttonKeys',buttonKeys)

for key in keys1:
    if key not in vals2 and key.lower() not in vals2:
        if (
            key.startswith('enter-') and key.endswith('-mode') or
            key.startswith('press-') and key.endswith('-button') or
            key.startswith('delete-') and key.endswith('-button') or
            key.startswith('nav-') and key.endswith('-menu')
        ):
            vals2.append(key)
        elif key in buttonKeys or key.lower() in buttonKeys:
            # List of buttons defined in this file, or in @settings tree.
            vals2.append(key)
        elif key.startswith('open-with-'):
            vals2.append(key)
        elif key in abbrevDict.keys():
            pass # g.trace('abbrev',key)
        else:
            assert False, '%s not in inverseCommandsDict.values()' % key

vals2.sort()
for val in vals2:
    if val not in keys1:
        assert False, '%s not in commandsDict.keys()' % (val)
</t>
<t tx="ekr.20061008162912">assert p.firstChild(), 'no child node'
assert p.firstChild().b.startswith('@ignore'), 'No @ignore in child'
ok = c.fileCommands.write_Leo_file(
    'file-name',outlineOnlyFlag=True,toString=True,toOPML=False)
assert ok, 'error writing file'
count = 0
s = g.app.write_Leo_file_string
for line in g.splitLines(s):
    if line.find('@ignore') != -1:
        count += 1
assert count &gt;=1, "not enough @ignore's in written file: count: %s, lines:\n%s" % (count,s)
</t>
<t tx="ekr.20061008162912.1">@ignore # Test that this node gets written.
</t>
<t tx="ekr.20061101121602.126">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.127">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.128">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.129">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.154">@pagewidth 70 # Required for unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.155">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20061101121602.156">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20061101121602.157">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20061101121602.174">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20061101121602.175">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.176">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.177">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.282">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20061101121602.283">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.284">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.285">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20061101121602.350">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20061101121602.351">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.352">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061101121602.353">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20061104172236.23">w = c.frame.body.bodyCtrl
y = 10
for x in range(0,100,10):
    event = g.app.gui.create_key_event(c,None,None,w,x=x,y=y)
    c.frame.body.onClick(event)
</t>
<t tx="ekr.20070926095117">def mungeKey (h,kind,substitute=True):

    key = h[len(kind):].strip()
    i = key.find('@key')
    if i &gt; -1: key = key[:i].strip()
    if substitute:
        key = key.replace(' ','-')
    # g.trace(key)
    return key


</t>
<t tx="ekr.20071113145804.4">@first # -*- coding: utf-8 -*-
@language python

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()

    # This strings tests unicode, paren matching, and auto-indentation.
    u = g.u('(a\u00c9\u03a9B\u3045\u4e7cz):\n') # '(aBE|cz):\n'
    u = g.u('(pdq):\n')
    w.setInsertPoint(len(s))
    for char in u:
        stroke = g.choose(char=='\n','Return',char)
        event = g.app.gui.create_key_event(c,char,stroke,w)
        ec.selfInsertCommand(event)
    result = w.getAllText()
    #g.trace('result',repr(result))
    assert result.endswith('    '),'result:\n%s' % result
    # Test of autocompleter.
finally:
    if 1:
        w.setAllText(s)
        p.setBodyString(s)
        # g.trace(repr(s))
        c.recolor()

# end:
</t>
<t tx="ekr.20080405085247.1"></t>
<t tx="ekr.20080703104536.1"></t>
<t tx="ekr.20080806084924.2">@others
</t>
<t tx="ekr.20080806084924.3">pass
</t>
<t tx="ekr.20080806084924.4">pass
</t>
<t tx="ekr.20080806084924.5">pass
</t>
<t tx="ekr.20080806095923.2">root = p.firstChild()
uA = 'unknownAttributes'
tag = 'round-trip-u.uA'
ttag = 'round-trip-t.uA'
trace = False

if 0: # Set the uA's.
    for p2 in root.self_and_subtree_iter():
        p2.v.unknownAttributes = {tag: p2.h}
else: # Test the uA's.
    # The root is a special case.
    v = root.v
    assert hasattr(v,uA),'no v.uA for %s' % v
    assert getattr(v,uA),'empty v.uA for %s' % v
    for p2 in root.self_and_subtree_iter():
        v = p2.v
        assert hasattr(v,uA),'no v.uA for %s' % v
        a = getattr(v,uA)
        d = {tag: v.h}
        if trace: print(d)
        assert a == d, 'expected v.uA: "%s", got "%s"' % (d,a)
</t>
<t tx="ekr.20080806211453.1">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080806211453.5">root = p.firstChild()
uA = 'unknownAttributes'
tag = 'round-trip-u.uA'
ttag = 'round-trip-t.uA'
trace = False

if 0: # Set the uA's.
    for p2 in root.self_and_subtree_iter():
        p2.v.unknownAttributes = {tag: p2.h}
else: # Test the uA's.
    # The root is a special case.
    v = root.v
    assert hasattr(v,uA),'no v.uA for %s' % v
    assert getattr(v,uA),'empty v.uA for %s' % v
    for p2 in root.self_and_subtree_iter():
        v = p2.v
        assert hasattr(v,uA),'no v.uA for %s' % v
        a = getattr(v,uA)
        d = {tag: v.h}
        if trace: print(d)
        assert a == d, 'expected v.uA: "%s", got "%s"' % (d,a)
</t>
<t tx="ekr.20080821123427.2">@first # -*- coding: utf-8 -*-

import sys

print('=' * 40)

e = sys.getdefaultencoding()
print('encoding',e)

table = (
    'La Pea',
    g.u('La Pea'),
    # u'La Pea',
    g.u('La Pe\xf1a')
)

for s in table:
    print(type(s))
    g.es_print('g.es_print',s)
    if type(s) != type(u'a'):
        s = unicode(s,e)
    print('print     ',s)
    print('repr(s)   ',repr(s))
</t>
<t tx="ekr.20080822160527.1">pass
pass
pass
</t>
<t tx="ekr.20081121164135.1">path = g.os_path_join(g.app.loadDir,"..","plugins","leoGuiPluginsRef.leo")
c.testManager.runLeoTest(path)
</t>
<t tx="ekr.20100125180231.5120">@first # -*- coding: utf-8 -*-

s = g.ue('','utf-8')
g.es(s)
g.pr(s)
s = ''
g.pr(s)
</t>
<t tx="ekr.20100127162342.5123">import glob,os

tkPass = (
    'EditAttributes','Library',
    'URLloader','UniversalScrolling','UASearch',
    'autotrees','chapter_hoist','cleo','dump_globals',
    'expfolder','geotag','graphed','groupOperations',
    'hoist','import_cisco_config',
    'keybindings','leoupdate',
    'maximizeNewWindows', 'mnplugins','mod_labels',
    'mod_read_dir_outline','mod_tempfname','multifile',
    'newButtons','nodeActions','nodenavigator',
    'open_with','pie_menus','pluginsTest',
    'read_only_nodes','rClick',
    'scheduler','searchbar','searchbox','shortcut_button',
    'script_io_to_body','searchbox',
    'templates','textnode','tkGui','toolbar',
    'xcc_nodes',
)
tkPassWithProblems = (
    'at_view', # at_view plugin not loaded: win32Clipboard not present.
    'image', # can not import ImageTk.
    'table', # failed to import 'tktable'
    'xsltWithNodes', # Can not import Ft from plugin leo.plugins.xsltWithNodes.
)
tkFail = (
    'ConceptualSort','at_produce','autocompleter','rowcol',
)
passList = (
    '__init__','FileActions','UNL',
    'active_path','add_directives','attrib_edit',
    'backlink','base64Packager','baseNativeTree','bibtex','bookmarks',
    'codewisecompleter','colorize_headlines','contextmenu',
    'ctagscompleter','cursesGui','datenodes','debugger_pudb',
    'detect_urls','dtest','empty_leo_file','enable_gc','initinclass',
    'leo_to_html','leo_interface','leo_pdf','leo_to_rtf',
    'leoOPML','leoremote','lineNumbers',
    'macros','mime','mod_autosave','mod_framesize','mod_leo2ascd',
    'mod_scripting','mod_speedups','mod_timestamp',
    'nav_buttons','nav_qt','niceNosent','nodeActions','nodebar',
    'open_shell','outline_export','quit_leo',
    'paste_as_headlines','plugins_menu','pretty_print','projectwizard',
    'qt_main','qt_quicksearch','qtframecommands',
    'quickMove',
        # Warning: changed this line by guessing!
        # func = types.MethodType(func, quickMove)
    'quicksearch','redirect_to_log','rClickBasePluginClasses',
    'run_nodes', # Changed thread.allocate_lock to threading.lock().acquire()
    'rst3',
    'scrolledmessage','setHomeDirectory','slideshow','spydershell','startfile',
    'testRegisterCommand','todo','trace_gc_plugin','trace_keys','trace_tags',
    'vim','xemacs',
)
passWithImportProblems = ( # Other than tk input problems.
    'ipython','word_export',
)
dead = (
    'at_folder','exampleTemacsExtension','ironPythonGui','LeoN',
    'rst2','swing_gui','temacs','usetemacs','wxGui',)
error = ( # Real errors with tracebacks.
)
fail = (
    'stickynotes_plus', # requires markdown.
    'zenity_file_dialogs', # requires zenity, and probably ubuntu.
)
noAttribute = (
    # AttributeError: 'module' object has no attribute &lt;module name&gt;
    # This was a sign of a missing init top-level function.
)
changed = (
    'LeoN',
)
plugins = g.os_path_abspath(g.os_path_join(
    g.app.loadDir,'..','plugins','*.py'))
files = glob.glob(plugins)
files.sort()
os.system('cls') # Clear the screen on windows.
for fn in files:
    m = g.shortFileName(fn)[:-3]
    # Change the next line to choose different plugins.
    if m in passList:
        try:
            __import__('leo.plugins.%s' % m)
            if 1: print('pass %s' % m)
        except ImportError:
            if 1: print('FAIL %s' % m)
        except Exception:
            if 1: g.es_exception()
            if 1: print('error %s' % m)
</t>
<t tx="ekr.20100203163606.5365">import os

def run(files):
    args = [r'python c:\python26\Tools\Scripts\2to3.py']
    for z in files:
        args.append(z)
        # args.append('-xprint')
    args.append('&gt;out2')
    args = ','.join(args)
    os.system(args)

tkPass = (
    'EditAttributes','Library',
    'URLloader','UniversalScrolling','UASearch',
    'autotrees','chapter_hoist','cleo','dump_globals',
    'expfolder','geotag','graphed','groupOperations',
    'hoist','import_cisco_config',
    'keybindings','leoupdate',
    'maximizeNewWindows', 'mnplugins','mod_labels',
    'mod_read_dir_outline','mod_tempfname','multifile',
    'newButtons','nodeActions','nodenavigator',
    'open_with','pie_menus','pluginsTest',
    'read_only_nodes','rClick',
    'scheduler','searchbar','searchbox','shortcut_button',
    'script_io_to_body','searchbox',
    'templates','textnode','tkGui','toolbar',
    'xcc_nodes',
)

passList = (
    '__init__','FileActions','UNL',
    'active_path','add_directives','attrib_edit',
    'backlink','base64Packager','baseNativeTree','bibtex','bookmarks',
    'codewisecompleter','colorize_headlines','contextmenu',
    'ctagscompleter','cursesGui','datenodes','debugger_pudb',
    'detect_urls','dtest','empty_leo_file','enable_gc','initinclass',
    'leo_to_html','leo_interface','leo_pdf','leo_to_rtf',
    'leoOPML','leoremote','lineNumbers',
    'macros','mime','mod_autosave','mod_framesize','mod_leo2ascd',
    'mod_scripting','mod_speedups','mod_timestamp',
    'nav_buttons','nav_qt','niceNosent','nodeActions','nodebar',
    'open_shell','outline_export','quit_leo',
    'paste_as_headlines','plugins_menu','pretty_print','projectwizard',
    'qt_main','qt_quicksearch','qtframecommands',
    'quickMove',
        # Warning: changed this line by guessing!
        # func = types.MethodType(func, quickMove)
    'quicksearch','redirect_to_log','rClickBasePluginClasses',
    'run_nodes', # Changed thread.allocate_lock to threading.lock().acquire()
    'rst3',
    'scrolledmessage','setHomeDirectory','slideshow','spydershell','startfile',
    'testRegisterCommand','todo','trace_gc_plugin','trace_keys','trace_tags',
    'vim','xemacs',
)
core_files = (
    'leoApp','leoAtFile','leoCache','leoChapters','leoCommands',
    'leoEditCommands','leoFileCommands','leoFind','leoFrame',
    'leoGlobals','leoGui','leoImport','leoMenu','leoNodes',
    'leoPlugins','leoShadow','leoTangle','leoUndo',
)
external_files = (
    'ipy_leo','lproto',
)
table = (
    ('plugins',passList),
    ('plugins',tkPass),
    ('core',core_files),
    ('external',external_files),
)
files = []
for theDir,aList in table:
    for z in aList:
        if not z.endswith('.py'): z = z + '.py'
        # print(z)
        fn = os.path.abspath(os.path.join('leo',theDir,z))
        if os.path.exists(fn): files.append(fn)
        else: print('*** file not found:',fn)

run(files)
print('done: results are in out2')
</t>
<t tx="ekr.20100204153116.5369">import tempfile
import os

s = 'Select the following string: . Typing and undo now work.'
fd,fn = tempfile.mkstemp(text=False)
s = g.toEncodedString(s)
os.write(fd,s)
os.close(fd)
f = open(fn,'rb')
s2 = f.read()
f.close()
assert s==s2
os.remove(fn)
print('deleted',fn)
</t>
<t tx="ekr.20100204165850.5373">k = c.k
colorizer = c.frame.body.getColorizer()
ed = c.editCommands

# These don't set ivars
    # 'toggle-active-pane'),
    # 'toggle-angle-brackets',
    # 'toggle-input-state'),
    # 'toggle-mini-buffer'),
    # 'toggle-split-direction'),

table = [
    (k,'abbrevOn','toggle-abbrev-mode'),
    (ed,'extendMode','toggle-extend-mode'),
]

# Not valid for external tests.
table2 = [
    (k,'enable_autocompleter','toggle-autocompleter'),
    (k,'enable_calltips','toggle-calltips'),
    (c,'sparse_find','toggle-find-collapses-nodes'),
    (colorizer,'showInvisibles','toggle-invisibles'),
    (c,'sparse_move','toggle-sparse-move'),
]

if not g.app.isExternalUnitTest:
    table.extend(table2)

for obj,ivar,command in table:
    val1 = getattr(obj,ivar)
    try:
        k.simulateCommand(command)
        val2 = getattr(obj,ivar)
        assert val2 == (not val1),'failed 1 %s' % command
        k.simulateCommand(command)
        val3 = getattr(obj,ivar)
        assert val3 == val1,'failed 2 %s' % command
        # print('pass',command)
    finally:
        setattr(obj,ivar,val1)
</t>
<t tx="ekr.20100208095817.5387"># Disabled this test because it's best to open this file without caching.

import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

assert cacher.test()
</t>
<t tx="ekr.20100208230953.5383"></t>
<t tx="ekr.20100223094723.5375"></t>
<t tx="ekr.20100223094723.5376">import leo.core.leoImport as leoImport
ic = c.importCommands

s = '''\

def one():
    pass

import a
from . import a

@language python

d = {} # An interior comment.

# This is a comment.
# and another comment.
@aDecorator
class cl: # An interior comment
    def method(self):
        pass

def two():
    pass

'''

# tree = c.importCommands.pythonUnitTest(p,s=s,showTree=True)

expected = s.find('# This is a comment')
scanner = leoImport.PythonScanner(importCommands=ic,atAuto=False)
i = s.find('import a')
assert i &gt; -1
i = scanner.skipToTheNextClassOrFunction(s,i,lastIndent=0)
assert i==expected,'expected %s, got %s %s' % (
    expected,i,repr(s[i:]))
</t>
<t tx="ekr.20100223094723.5377">import leo.core.leoImport as leoImport
ic = c.importCommands

s = '''\

def one():
    pass

import a
from . import a

d = {}

# This is a comment.
@tabwith -4 # This looks like a comment.
# and another comment.
@aDecorator
def two():
    pass

'''

# tree = c.importCommands.pythonUnitTest(p,s=s,showTree=True)

expected = s.find('# This is a comment')
scanner = leoImport.PythonScanner(importCommands=ic,atAuto=False)
i = s.find('import a')
assert i &gt; -1
i = scanner.skipToTheNextClassOrFunction(s,i,lastIndent=0)
assert i==expected,'expected %s, got %s %s' % (
    expected,i,repr(s[i:]))
</t>
<t tx="ekr.20100223094723.5378">import leo.core.leoImport as leoImport
ic = c.importCommands

s = '''\

def one():
    pass

import a
from . import a

d = {}

# This is a comment.
# and another comment.

@tabwidth -4

aList = ('a','b','def')

if __name__ == '__main__':
    pass

'''

lastLine = 'pass\n'
expected = s.find(lastLine) + len(lastLine) + 1
scanner = leoImport.PythonScanner(importCommands=ic,atAuto=False)
i = s.find('import a')
assert i &gt; -1
i = scanner.skipToTheNextClassOrFunction(s,i,lastIndent=0)
assert i==expected,'expected %s, got %s %s' % (
    expected,i,repr(s[i:]))
</t>
<t tx="ekr.20100223094723.5379">import leo.core.leoImport as leoImport
ic = c.importCommands

s = '''\

def one():
    pass

import a
from . import a

if 0:
    def two():
        pass

if __name__ == '__main__':
    pass

'''

scanner = leoImport.PythonScanner(importCommands=ic,atAuto=False)
expected = i = s.find('import a')
assert i &gt; -1
i = scanner.skipToTheNextClassOrFunction(s,i,lastIndent=0)
assert i==expected,'expected %s, got %s %s' % (
    expected,i,repr(s[i:]))
</t>
<t tx="ekr.20100223123103.5382">import leo.core.leoFrame as leoFrame

# Do nothing when run externally.
if g.app.isExternalUnitTest:
    pass
else:
    assert not isinstance(c.frame,leoFrame.NullFrame)
    def closeEnough(f1,f2):
        return abs(f1-f2) &lt; 0.0001
    f = c.frame
    ratio,ratio2 = f.ratio,f.secondary_ratio
    table = (
        c.bodyWantsFocusNow,
        c.logWantsFocusNow,
        c.treeWantsFocusNow,
    )
    for func in table:
        func()
        f.contractPane()
        if func == c.logWantsFocusNow:
            assert ratio2 != f.secondary_ratio,'fail 1'
        else:
            assert ratio != f.ratio,'fail 2: %s, %s' % (ratio,f.ratio)
        func()
        f.expandPane()
        assert closeEnough(ratio,f.ratio),'fail 3 %s != %s' % (
            ratio,f.ratio)
        assert closeEnough(ratio2,f.secondary_ratio),'fail 4 %s != %s' % (
            ratio2,f.secondary_ratio)
</t>
<t tx="ekr.20100225094004.5405"># test/at-file-test.leo contains tnodeList.
# test/at-file-test.py contains file-like sentinels.
g.app.unitTestDict={}
fn = g.os_path_finalize_join(g.app.loadDir,'..','test','unittest','at-file-test.leo')

try:
    c2 = g.openWithFileName(fn,c)
    assert c2
    assert c2.changed,'not changed'
    p2 = g.findNodeAnywhere(c2,'@file at-file-test.py')
    assert p2,'no p2'
    assert p2.isDirty(),'not dirty'
    assert g.app.unitTestDict.get('read-convert'),'not converted'
    ok = True
finally:
    if True: # and ok:
        # Close the frame without prompt.
        g.app.destroyWindow(c2.frame)
        c.setLog()
        c.bodyWantsFocus()
</t>
<t tx="ekr.20101021205258.6013"></t>
<t tx="ekr.20110118082508.3766"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3772">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3773">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3779"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3780">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3781">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3782">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3787"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20110118082508.3788">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3789">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3790">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20110118082508.3792">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20110610122533.3388"></t>
<t tx="ekr.20110610122533.3389"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:
    root = p.parent().parent()
    h = '@auto unittest/at-auto-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no @auto node'
    p, n, found = c.gotoCommands.find_file_line(1, target)
    assert found, 'not found'
    assert n == 1, 'n: %s' % (n)
    assert p.h == 'at_auto_child', p.h
</t>
<t tx="ekr.20110610122533.3390"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:
    h = '@auto unittest/at-auto-line-number-test.py'
    root = g.findNodeAnywhere(c, h)
    assert root, 'no root'
    p, n, found = c.gotoCommands.find_file_line(20, root)
    assert not found, 'not found'
</t>
<t tx="ekr.20110610122533.3391"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:
    h = '@auto unittest/at-auto-line-number-test.py'
    root1 = g.findNodeAnywhere(c, h)
    assert root1
    assert root1.isAnyAtFileNode()
    fileName, isScript, lines, n, root = c.gotoCommands.setup_file(n=3, p=root1)
    assert fileName == h[6:], 'fileName: %s' % (fileName)
    assert root == root1, 'root: %s, root1: %s' % (root and root.h, root1 and root1.h)
    if 0:
        print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
            root and root.h, isRaw, n, len(lines)))
</t>
<t tx="ekr.20110610122533.3392"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:
    h = '@auto unittest/at-auto-line-number-test.py'
    root1 = g.findNodeAnywhere(c, h)
    assert root1
    assert root1.isAnyAtFileNode()
    scriptData = {'p': root1.copy(), 'lines': ['a', 'b', 'c']}
    fileName, lines2, p2, root2 = c.gotoCommands.setup_script(scriptData)
    assert fileName == h[6:], 'fileName'
    assert lines2 == scriptData.get('lines'), 'lines'
    assert p2 == root1, 'p'
    assert root2 == root1, 'root'
    if 0:
        print('root:%s, n:%s, len(lines): %s' % (
            root and root.h, n, len(lines)))
</t>
<t tx="ekr.20110610122533.3397"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:

    h = '@shadow unittest/at-shadow-line-number-test.py'
    root1 = g.findNodeAnywhere(c,h)
    assert root1
    assert root1.isAnyAtFileNode()
    
    fileName,lines,n,root2 = c.GoToLineNumber(c).setup_file(n=6,p=root1)
    assert fileName == h[8:],'fileName'
    assert root2 == root1
    
    if 0:
        print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
            root and root.h,isRaw,n,len(lines)))
</t>
<t tx="ekr.20110610122533.3401"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:
    root = p.parent().parent()
    h = '@auto unittest/at-auto-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    child = target.firstChild()
    assert child.h == 'at_auto_child', 'child.h'
    p, found = c.gotoCommands.find_root(child)
    assert p == target, 'p' #p and p.h
    assert found, 'not found'
</t>
<t tx="ekr.20110610122533.3406"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:
    fn = '../test/at-auto-unit-test.py'
    root = g.findNodeAnywhere(c, '@auto %s' % (fn))
    assert root, 'no root'
    child1 = root.firstChild()
    assert child1, 'no child1'
    grand11 = child1.firstChild()
    assert grand11, 'no grand11'
    grand12 = grand11.next()
    assert grand12, 'no grand12'
    child2 = child1.next()
    assert child2, 'no child2'
    grand21 = child2.firstChild()
    assert grand21, 'no grand21'
    grand22 = grand21.next()
    assert grand22, 'no grand22'

    def oops(found, p2, node, n, n2):
        result = [' ']
        result.append('goto-global-line test failed at line %s' % (n))
        if not found:
            result.append('line %s not found', n)
        else:
            result.append('got node "%s", expected "%s"' % (p2.h, node.h))
            result.append('got offset %s, expected %s' % (n2, n))
        return '\n'.join(result)

    table = (
        # Use 1-based numbers externally.
        # find_file_line converts to zero-based numbers.
        (1, child1, 0),
        (2, grand11, 0),
        (3, grand11, 1),
        (4, grand12, 0),
        (5, grand12, 1),
        (6, child1, 2),
        (7, child2, 0),
        (8, grand21, 0),
        (9, grand21, 1),
        (10, grand22, 0),
        (11, grand22, 1),
        (12, root, 3),
    )
    # Test against actual lines of the file.
    path = g.os_path_finalize_join(g.app.loadDir, '..', 'test', fn)
    f = open(path, 'r'); s = f.read(); f.close()
    lines = g.splitLines(s) # The lines from the file.
    for n, node, index in table:
        p2, n2, found = c.gotoCommands.find_file_line(n, root)
            # n, the argument to find_file_line, is 1-based
            # n2, the returned index into p2.b, is zero-based
        n -= 1
            # Convert n to zero-based for the comparisons below.
        lines2 = g.splitLines(p2.b)
        if 0:
            print('%2d %s' % (n, repr(lines[n])))
        else:
            ok = lines2[n2].lstrip() == lines[n].lstrip()
            if not ok:
                i = 0
                for z in lines:
                    print('%2d %s' % (i, repr(z)))
                    i += 1
            if not ok:
                print('at line %s, index %s, node %s\ngot line %s\nexpected %s' % (
                    n, n2, p2.h, repr(lines2[n2].lstrip()), repr(lines[n].lstrip())))
            assert ok
</t>
<t tx="ekr.20110615130436.3319"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:
    
    # Writing a .leo file must retain orphan bits of erroneous external files.
    
    h = '@file nonexistent-directory/orphan-bit-test.txt'
    p2 = g.findNodeAnywhere(c,h)
    assert p2,'not found: %s' % (h)
    assert p2.isOrphan(),'not an orphan originally'
    
    # It's dangerous to do the write, but this does test the bug fix.
    c.atFileCommands.clearAllOrphanBits(p2)
    assert p2.isOrphan(),'not an orphan after calling at.clearAllOrphanBits'
</t>
<t tx="ekr.20110728154927.3324"># Disabled because very slow
aList = [z.copy() for z in c.all_positions()]

total = 0

for i in range(len(aList)):
    for j in range(0,i):
        assert aList[j] &lt; aList[i],(i,j)
        total += 1

g.es('"%s": total tests: %s' % (p.h,total))
</t>
<t tx="ekr.20111107113442.3849"></t>
<t tx="ekr.20111108170253.3968">@first # -*- coding: utf-8 -*-

table = (
    'test',
    '  ',
    '   after', # fails with cp6501: after is duplicated.
)

print('*'*20)
print('isPython3: %s' % g.isPython3)

for s in table:
    if g.isPython3:
        s = s.encode('ascii','replace') # create bytes.
    g.es(repr(s))
    g.es(s)
    g.pr ('g.pr(s)       : %s' % s)
    g.pr ('g.pr(repr(s)) : %s' % repr(s))
    print('print(s)      : %s' % s)
    print('print(repr(s)): %s' % s)
</t>
<t tx="ekr.20111112171235.3854">w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'html')
assert p,'no test node'
s = p.b
indent = c.config.getBool('indent_added_comments',default=True)
try:
    i = p.b.find('text')
    assert i &gt; -1,'fail1: %s' % (repr(p.b))
    c.selectPosition(p)
    w.setSelectionRange(i,i+4)
    c.addComments()
    if indent:
        i = p.b.find('&lt;!-- text')
    else:
        i = p.b.find('&lt;!--     text')
    assert i &gt; -1,'fail2: %s' % (repr(p.b))
    c.deleteComments()
    assert p.b == s,'fail3: s\n%s\nresult\n%s' % (repr(s),repr(p.b))
    # Add a comment delim without a blank.
    c.addComments()
    p.b = p.b.replace('&lt;!-- ','&lt;!--')
    i = p.b.find('&lt;!--')
    w.setSelectionRange(i,i+4)
    c.deleteComments()
    assert p.b == s,'fail5: s\n%s\nresult\n%s' % (repr(s),repr(p.b))
finally:
    # print('\n'.join([repr(z) for z in g.splitLines(p.b)]))
    p.b = s
</t>
<t tx="ekr.20111112171235.3855">@language html
&lt;html&gt;
    text 
&lt;/html&gt;
</t>
<t tx="ekr.20111112171235.3858"># Can't be run externally.
w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'python')
assert p,'no test node'
s = p.b
indent = c.config.getBool('indent_added_comments',default=True)

try:
    i = p.b.find('pass')
    assert i &gt; -1,'fail1: %s' % (repr(p.b))
    c.selectPosition(p)
    w.setSelectionRange(i,i+4)
    c.addComments()
    if indent:
        i = p.b.find('# pass')
    else:
        i = p.b.find('#     pass')
    assert i &gt; -1,'fail2: %s' % (repr(p.b))
    c.deleteComments()
    assert p.b == s,'fail3: %s' % (repr(p.b))
    # Add a comment delim without a blank.
    c.addComments()
    p.b = p.b.replace('# pass','#pass')
    i = p.b.find('#')
    w.setSelectionRange(i,i+4)
    c.deleteComments()
    assert p.b == s,'fail5: s\n%s\nresult\n%s' % (repr(s),repr(p.b))
finally:
    # print('\n'.join([repr(z) for z in g.splitLines(p.b)]))
    p.b = s
</t>
<t tx="ekr.20111112171235.3859">@language python

def spam():
    pass

# after
</t>
<t tx="ekr.20111112193817.3908">if 0:
    # This works, but the label sticks, presumably because of a race condition.
    # Therefore, this is best left as a mini-test.

    w = c.frame.body
    for i in range(4):
        print(i)
        w.addEditor()
        w.deleteEditor()
</t>
<t tx="ekr.20111112211307.3910"># created by old and new add-comments.
</t>
<t tx="ekr.20111112211307.3911">@language python

def deleteCommentTest():

#     if 1:
#         a = 2
#         b = 3

    # if 1:
        # a = 2
        # b = 3

    pass
</t>
<t tx="ekr.20111112211307.3912">@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3

    if 1:
        a = 2
        b = 3

    pass
</t>
<t tx="ekr.20111112211307.3913">5.0
12.8
</t>
<t tx="ekr.20111113194727.3869">import leo.core.leoFrame as leoFrame

w = leoFrame.BaseTextWrapper(c,'base-name','class-name',widget=None)

def check(expected):
    s = w.getAllText()
    assert s == expected,'expected %s got %s' % (expected,s)

w.setAllText('')        ; check('')
w.appendText('abc')     ; check('abc')
w.delete(1,2)           ; check('ac')
w.insert(0,'xy')        ; check('xyac')
w.insert(1,'z')         ; check('xzyac')
    # w.replace(2,4,'ABCD') ; check('xzABCDc')
        # This method no longer exists.  It is not used anywhere.
    # w.setSelectionRange(3,6)
    # s = w.getSelectedText()
    # assert s == 'BCD',repr(s)

w.deleteTextSelection() ; check('xzyac')
</t>
<t tx="ekr.20111121081052.3909">if g.app.isExternalUnitTest:
    pass # Prints to console, which is annoying.
else:
    old_focus = c.get_focus()
    
    for flag in (False,True):
        g.es('Hi')
        
    if flag:
        c.outerUpdate() # Restores focus, especially when run from a script.
    new_focus = c.get_focus()
    
    try:
        assert old_focus == new_focus,'old focus: %s new focus: %s' % (
            old_focus,new_focus)
    except AssertionError:
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20111121090700.3914">if g.app.isExternalUnitTest:
    pass
else:
    c.k.simulateCommand('print-bindings')
    log = c.frame.log
    
    # This works when run via execute-script.
    assert log.tabName == 'Bindings',log.tabName
    
    # w = c.frame.log.contentsDict.get('Bindings')
    # assert w,'no Bindings widget'
    # wrapper = w.leo_log_wrapper
    # s = wrapper.getAllText()
    # assert s,wrapper
</t>
<t tx="ekr.20111121113227.4035">c.k.simulateCommand('add-editor')
c.k.simulateCommand('delete-editor')
</t>
<t tx="ekr.20111210175541.3957"># Important: the child of this node must be a clone of
# the corresponding node in @shadow unittest/at-shadow-unlink-clones.py

# The @shadow node will not exist for an external test.
if not g.app.isExternalUnitTest:
    try:
        # print('start',p.h)
        b = c.undoer.beforeChangeTree(p)
        h = '@shadow unittest/at-shadow-unlink-clones.py'
        root = g.findNodeAnywhere(c,h)
        assert root
        assert root.h == h,repr(root.h)
        child = p.firstChild()
        assert child
        assert child.isCloned(),'fail 1: test not set up properly'
        c.selectPosition(root)
        fn = root.atShadowFileNodeName()
        assert fn
        c.atFileCommands.readOneAtShadowNode (fn,root,force=True)
        c.undoer.afterChangeTree(p,'fc.readOneAtShadowNode',b)
        assert child.isCloned(),'fail 2: intended test fails'
        c.undoer.undo()
    finally:
        c.selectPosition(p)
        c.redraw()
</t>
<t tx="ekr.20120228174052.3929"># node 1 text A.
</t>
<t tx="ekr.20130503061511.4137">import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.HtmlScanner(importCommands=ic,atAuto=True)

s1 = '''
&lt;table id="1"&gt; &lt;table id="2"&gt;
&lt;contents/&gt;
&lt;/table&gt;
&lt;/table&gt;
'''

s2 = '''
&lt;table id="1"&gt; 
&lt;table id="2"&gt;
&lt;contents/&gt;
&lt;/table&gt;
&lt;/table&gt;
'''

t1 = 
assert result == expected,'expected...\n%s\ngot...\n%s' % (
    repr(expected),repr(result))
</t>
<t tx="ekr.20130503061511.4140">s = '''\
&lt;HTML&gt;
&lt;head&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/head&gt;
&lt;body class='bodystring'&gt;
&lt;div id='bodydisplay'&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
'''

html_tags = ('body','head','html','table',) # 'div',
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.app.unitTestDict ['expectedErrors'] = 0

showTree = True

c.importCommands.htmlUnitTest(p,s=s,showTree=showTree)

if showTree:
    # g.cls()
    for p in p.subtree():
        print('\n***** %s\n' %p.h)
        print(p.b)
</t>
<t tx="ekr.20130503061511.4141">@language xml
@tabwidth -4
@others

</t>
<t tx="ekr.20130503061511.4145">@language xml
@tabwidth -4
@others

</t>
<t tx="ekr.20130503061511.4149">@language xml
@tabwidth -4
@others

</t>
<t tx="ekr.20130503061511.4150">&lt;HTML&gt;
@others
&lt;/html&gt;
</t>
<t tx="ekr.20130503061511.4151">
&lt;head&gt;
    &lt;title&gt;Bodystring&lt;/title&gt;
&lt;/head&gt;
</t>
<t tx="ekr.20130503061511.4152">&lt;body class='bodystring'&gt;
&lt;div id='bodydisplay'&gt;&lt;/div&gt;
&lt;/body&gt;
</t>
<t tx="ekr.20130503061511.4153">import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.HtmlScanner(importCommands=ic,atAuto=True)
strip = hs.stripTokens
dump  = hs.formatTokens

s1 = '''&lt;table id="1"&gt;&lt;table id="2"&gt;
&lt;contents/&gt;
&lt;/table&gt;
&lt;/table&gt;'''

s2 = '&lt;table id="1"&gt;&lt;table id="2"&gt;&lt;contents/&gt;&lt;/table&gt;&lt;/table&gt;'
    
t1 = hs.tokenize(s1)
t2 = hs.tokenize(s2)
f1 = hs.filterTokens(t1)
f2 = hs.filterTokens(t2)

assert strip(f1) == strip(f2),'f1...\n%s\nf2...\n%s' % (
    dump(f1),dump(f2))
    
if 0:
    print(dump(f1))
</t>
<t tx="ekr.20130503061511.4154">fn = r'c:\recent\data.html'

# fn = r'c:\recent\data-smaller.html'
# fn = r'c:\recent\data666.html'

# These all pass on data.html:
    # html_tags = ('html','head','body',)
    # html_tags = ('html','head','body','table',)
    # html_tags = ('html','head','body','table','div',)
    # html_tags = ('html','head','body','table','div','script',)
    # html_tags = ('html','head','body','table','div','script','link',)
    # html_tags = ('html','head','body','table','div','script','link','p',)

html_tags = ('html','head','body','table','div','script','p','td','tr',)

# Settings now work when run externally.
setting = 'import_html_tags'
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.cls()

c.importCommands.importFilesCommand(files=[fn], treeType='@file')
</t>
<t tx="ekr.20130503061511.4155">@first # -*- coding: utf-8 -*-

table = (
    'test',
    '  ',
    '   after', # fails with cp6501: after is duplicated.
)

print('*'*20)
print('isPython3: %s' % g.isPython3)

for s in table:
    if g.isPython3:
        s = s.encode('ascii','replace') # create bytes.
    g.es(repr(s))
    g.es(s)
    g.pr ('g.pr(s)       : %s' % s)
    g.pr ('g.pr(repr(s)) : %s' % repr(s))
    print('print(s)      : %s' % s)
    print('print(repr(s)): %s' % s)
</t>
<t tx="ekr.20130503061511.4156">assert g.app.isExternalUnitTest

body = c.frame.body
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl

w = body.bodyCtrl
w.setAllText(p.b)
assert p.b == w.getAllText()
</t>
<t tx="ekr.20130503061511.4157"># print('isExternalUnitTest',g.app.isExternalUnitTest)

if g.app.isExternalUnitTest:
    body = c.frame.body
else:
    import leo.core.leoCommands as leoCommands
    import leo.core.leoFrame as leoFrame
    import leo.core.leoGui as leoGui
    
    # Important: external unit tests should execute in this environment.
    nullGui   = leoGui.NullGui('null gui')
    nullFrame = leoFrame.NullFrame(title='nullFrame title',gui=nullGui)
    c2 = leoCommands.Commands(nullFrame,fileName='&lt;empty fileName&gt;')
    nullFrame.c = c2
    body = leoFrame.nullBody(frame=nullFrame,parentFrame=None)
    assert repr(body).startswith('&lt;leo.core.leoFrame.nullBody')

# Now test some basic operations.
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl
w = body.bodyCtrl

w.setAllText(p.b)
assert p.b == w.getAllText()
</t>
<t tx="ekr.20130503061511.4158"># h = 'g.python_tokenize'
# p = p.firstChild()
# assert p.h == h
tokens = g.python_tokenize(p.b,line_numbers=False)

# tokens = [(kind,val) for (kind,val,line_number) in tokens]

# First, the basic check
tokens1 = [val for kind,val in tokens]
s = ''.join(tokens1)
assert p.b == s,repr(s)

if 0:
    for z in tokens:
        kind,val = z
        print('%6s %s' % (kind,repr(val)))
        
# Next, start filtering.
tokens = [(kind,g.choose(kind=='string','"S"',val)) for kind,val in tokens]

if 0: # Delete whitespace.
    tokens = [(kind,val) for (kind,val) in tokens if kind != 'ws']
    tokens = [(kind,g.choose(kind=='id',val+' ',val)) for (kind,val) in tokens]

# Last: stringize.
tokens = [val for kind,val in tokens if kind != 'comment']
# print(''.join(tokens))

if 0: # Print lines containing '='
    s = ''.join(tokens)
    for ch in '()[]{}&lt;&gt;.,:=+-/':
        s = s.replace(' '+ch,ch)
    aList = [z for z in g.splitLines(s)
        if z.find('=') &gt; -1] # and not z.find('+=')&gt;-1 and not z.find('-=')&gt;-1]
    print(''.join(aList))
    
</t>
<t tx="ekr.20130503061511.4175"></t>
<t tx="ekr.20130503061511.4176"></t>
<t tx="ekr.20130503061511.4177">def printMenusList(aList,level=0):
    
    for z in aList:
        a,b,c = z
        print('*** kind',a)
        if type(b) in (type(()),type([])):
            for z2 in b:
                a1,b1,c1 = z2
                if a1.startswith('@menu') and type(b1) in (type(()),type([])):
                    print()
                    print('*** inner menu: %s' % (level+1))
                    print(a1)
                    for z3 in b1:
                        print(z3)
                    if c1: print(c1)
                else:
                    print(z2)
            if c: print(c)
        else:
            print(b)
        print()
        break #
        
printMenusList(c.config.getMenusList())
       
</t>
<t tx="ekr.20130503061511.4178">print('\ninverseBindingDict...\n')

d = c.k.computeInverseBindingDict()

for key in sorted(list(d.keys())):

    if 1 == len(d.get(key)):
        print(key,d.get(key))
    else:
        print()
        print(key)
        print(d.get(key))
        print()
</t>
<t tx="ekr.20130503061511.4179">import leo.core.leoConfig as leoConfig # for ShortcutInfo
    
partial = True

d = c.k.bindingsDict
    # Keys are shortcuts; values are *lists* leoConfig.ShortcutInfo objects.
    
print('\nk.bindingsDict%s...\n' % ' (partial)' if partial else '')
    
for key in list(sorted(d.keys())):
    aList = d.get(key,[])
    for b in aList:
        assert isinstance(b,leoConfig.ShortcutInfo)
        if not partial or b.kind != 'leosettings.leo':
            print(b)
</t>
<t tx="ekr.20130503061511.4180">partial = True

panes = ('all','body','button','log','tree','text',
    'command','insert','overwrite',)

d = c.k.masterBindingsDict
    # Keys are scope names (in panes) or mode names.
    # Values are dicts:
        # keys are strokes; values are leoConfig.ShortcutInfo objects.
        
print('\nk.masterBindingsDict%s...\n' % ' (partial)' if partial else '')

for pane in sorted(list(d.keys())):
    kind = 'pane' if pane in panes else 'mode'
    print('%s: %s...' % (kind,pane))
    d2 = d.get(pane)
    for stroke in sorted(list(d2.keys())):
        b = d2.get(stroke)
        if not partial or b.kind != 'leosettings.leo':
            print('%6s %25s %17s %s' % (b.pane,stroke,b.kind,b.commandName))
            assert b.pane == pane
            assert b.stroke == stroke
    print()
</t>
<t tx="ekr.20130503061511.4181"></t>
<t tx="ekr.20130503061511.4182">@

g.app.config.modeCommandsDict
    Keys are command names: enter-x-mode.
    Values are inner dictionaries:
        Keys are command names, values are lists of ShortcutInfo nodes.
@c

d = g.app.config.modeCommandsDict
    
for key in sorted(d.keys()):
    print('*** mode ***',key)
    d2 = d.get(key)
    for key2 in sorted(d2.keys()):
        aList = d2.get(key2)
        print(key2)
        for si in aList:
            print('   ',si)
</t>
<t tx="ekr.20130503061511.4183">@
ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           list of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     inner masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:
(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) inner masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
@c

si_type = c.k.ShortcutInfo
disabled_func_type = None # Should be any bound method.
k = c.k

@others

test_dict_of_objects(c.commandsDict,type('s'),disabled_func_type,'commandsDict')
test_dict_of_objects(k.inverseCommandsDict,type('s'),type('s'),'inverseCommandsDict')
test_dict_of_lists(k.bindingsDict,si_type,'bindingsDict')
test_dict_of_dicts(k.masterBindingsDict,si_type,'masterBindingsDict')
test_dict_of_lists(k.masterGuiBindingsDict,None,'masterGuiBindingsDict')
test_dict_of_objects(k.settingsNameDict,type('s'),type('s'),'settingsNameDict')
test_dict_of_lists(k.computeInverseBindingDict(),type(tuple()),'inverseBindingDict')

# Test individual dicts separately.
d = g.app.config.modeCommandsDict
test_dict_of_dicts(d,None,'modeCommandsDict')
for key in sorted(d.keys()):
    d2 = d.get(key)
    test_dict_of_lists(d2,si_type,'inner modeCommandsDict')
        # This requires a hack to special-case the
        # '*entry-commands*' and '*command-prompt*' keys.
</t>
<t tx="ekr.20130503061511.4184">def test_dict_of_dicts(d,theType,tag):

    assert d,tag

    for key in d.keys():
        d2 = d.get(key)
        assert type(d2) == type({})
        for key in d2.keys():
            obj = d2.get(key)
            if theType:
                assert type(obj) == theType,repr(obj)
</t>
<t tx="ekr.20130503061511.4185">def test_dict_of_lists(d,theType,tag):

    assert d,tag

    for key in d.keys():
        obj = d.get(key)
        if key in ('*entry-commands*','*command-prompt*'):
            # Special case for g.app.config.modeCommandsDict
            assert type(obj)==type([]),repr(obj)
        else:
            assert type(obj) == type([])
            # Don't check types of list elements if theType is None.
            if theType:
                for z in obj:
                    assert type(z)==theType,'key: %s obj: %s' % (key,repr(obj))
</t>
<t tx="ekr.20130503061511.4186">def test_dict_of_objects(d,keyType,valueType,tag):

    assert d,tag

    for key in d.keys():
        assert type(key) == keyType,repr(key)
        obj = d.get(key)
        # Don't check type of obj if valueType is None.
        if valueType:
            assert type(obj) == valueType,'\nobj: %s\nvalueType: %s' % (repr(obj),valueType)
</t>
<t tx="ekr.20130503061511.4187"># import types
# types.ListType does not exist in Python 3.x.
# assert isinstance(aList,list().__class__)
</t>
<t tx="ekr.20130503061511.4188">@others

# import os ; os.system('cls')
    
d1 = g.app.config.immutable_leo_settings_shortcuts_dict
d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
d3 = g.app.config.merge_settings_dicts(d1,d2)

if False:
    patterns = (
        'backward-find-character-extend-selection',
    )
    for pattern in patterns:
        print(dump_dict(d1,pattern,tag='d1'))
        print(dump_dict(d2,pattern,tag='d2'))
        print(dump_dict(d3,pattern,tag='d3'))

test(d1,d2,d3)
</t>
<t tx="ekr.20130503061511.4189">def dump(aList,pattern=None,tag=None):
    
    return '\n'.join([repr(z) for z in aList])
    

def dump_dict(d,pattern=None,tag=None):
    
    result = [] # '\ndump of %s...' % (tag)
    
    for key in d.keys():
        if pattern in (key,None):
            result.append(key)
            aList = d.get(key)
            for z in aList:
                result.append('    %s' % (z))
                
    return '\n'.join(result)
</t>
<t tx="ekr.20130503061511.4190">def test(old_d,new_d,result_d):
    
    '''Test that result_d is the result of upating old_d with new_d.
    
    This test is tricky: only inverted dicts have ShortcutInfo nodes as keys.'''
    
    invert,uninvert = g.app.config.invert,g.app.config.uninvert

    # Compute the inversions of all the dicts.
    inv_old,inv_new,inv_res = invert(old_d),invert(new_d),invert(result_d)
    
    # Part 1: Ensure we test all keys.
    keys = list(inv_old.keys())
    keys.extend(list(inv_new.keys()))
    keys.extend(list(inv_res.keys()))
    keys = sorted(list(set(keys)))
    assert None not in keys
    for key in inv_old.keys(): assert key in keys,key
    for key in inv_new.keys(): assert key in keys,key
    for key in inv_res.keys(): assert key in keys,key
    
    # Part 2: Carefully test the inverted result.
    def si_name_key(si): return si.commandName or ''

    for key in keys:
        # Compute the *sorted* list of 
        res_list = sorted(inv_res.get(key,[]),key=si_name_key)
        old_list = sorted(inv_old.get(key,[]),key=si_name_key)
        new_list = sorted(inv_new.get(key,[]),key=si_name_key)
        assert res_list,'no res_list.get(%s)' % (key)
        # if new_list: print(key,dump(new_list))
        if new_list:
            assert new_list == res_list,'key %s\nnew:\n%s\nres:\n%s' % (
                key,dump(new_list),dump(res_list))
        else:
            assert old_list == res_list,'key %s\nold:\n%s\nres:\n%s' % (
                key,dump(old_list),dump(res_list))
    
    # Part 3: Test that result_d == uninvert(invert(result_d)).
    # A.  They must have the same keys.
    unv_res = uninvert(inv_res)
    assert sorted(list(result_d.keys())) == sorted(list(unv_res.keys()))

    # B. The values of for each key must match after being sorted.
    def si_stroke_key(si): return si.stroke or ''
        
    for key in sorted(result_d.keys()):
        res_list = sorted(result_d.get(key,[]),key=si_stroke_key)
        unv_list = sorted( unv_res.get(key,[]),key=si_stroke_key)
        assert res_list == unv_list,'key %s\nres:\n%s\nunv:\n%s' % (
            key,dump(res_list),dump(unv_list))
   
</t>
<t tx="ekr.20130503061511.4191">ks = c.k.KeyStroke

@others

a1 = ks('a')
a2 = ks('a')
b1 = ks('b')
assert a1 == a2
d = {}
d[a1] = a1.s
d[a2] = a2.s
d[b1] = b1.s

for key in sorted(d):
    print(key,d.get(key))
</t>
<t tx="ekr.20130503061511.4192">d = g.TypedDictOfLists('ks',type('s'),type(9))
d.add('a',1)
d.add('a',2)
d.add('b',3)

print(d)
for s in sorted(d.keys()):
    print(s,d.get(s,[]))

print('after replace...')
d.replace('a',[8,9,10])

for s in sorted(d.keys()):
    print(s,d.get(s,[]))
</t>
<t tx="ekr.20130503061820.4189">import leo.core.leoInspect as inspect

# g.cls()

testing = g.unitTesting

def show(o,indent=0):
    pad = ' '*4*indent
    if not testing:
        # print('\n%s\n' % o.sd.dump_ast(o.tree()))
        print('%s%s' % (pad,o.format()))
        print('token range: %s' % (repr(o.token_range())))

&lt;&lt; define s &gt;&gt;
if not testing:
    print('Input...\n%s\n' % (s.rstrip()))

m = inspect.module(s=s)

if 0:
    show(m,0)
    
if 1:
    if not testing: print('\nAssignments to a...\n')
    for o in m.assignments_to('a'):
        # print(o.format())
        show(o)
if 0:
    if not testing: print('\nAssignments using d...\n')
    for o in m.assignments_using('d'):
        # print(o.format())
        show(o)
if 0:    
    if not testing: print('\nCalls to f...\n')
    for o in m.calls_to('f'):
        # print(o.format())
        show(o)
if 0:
    for s in m.statements():
        show(s)
    
    for f in m.functions():
        show(f,0)
        for z in f.statements():
            show(z,1)
    
    for cls in m.classes():
        show(cls,0)
        for d in cls.defs():
            show(d,1)
            for z in d.statements():
                show(z,1)
</t>
<t tx="ekr.20130503061820.4190">s = '''
# x.y = b(arg1,arg2=5,*args,**args).c[1:2:3].d
a=b+c
# f(a=1,b=2,*args,**keys)
'''


# def outer_function(a,b=99,c=88,*args,**keys):
    # print('hello')
    
# class myClass:
    # def method():
        # pass
    
</t>
<t tx="ekr.20130503061820.4217">@language python
</t>
<t tx="ekr.20130503061820.4218"></t>
<t tx="ekr.20130503061820.4219">import leo.core.leoInspect as leoInspect
import os
import time

&lt;&lt; define old_s &gt;&gt;
&lt;&lt; define s &gt;&gt;

@others

aList = (
    'leoAtFile.py',
    'leoEditCommands.py',
)
test(files=aList,print_stats=False,s=None,print_times=True)
</t>
<t tx="ekr.20130503061820.4220"># import leo.core.leoGlobals
# import leo.core.leoGlobals as g
# from leo.core.leoGlobals import pr as pr2
# from leo.core.leoGlobals import trace

s_old = '''\
import sys

aGlobal = 5
# aGlobal2 is not explicitly defined.

c = [z for z in 'abc']

def myFunc():
    n1,n2,n3,junk,junk=sys.version_info
    a = self.b
    for z in a:
        print(z)
    with A() as a:
        print(a,b)
        
def test():
    a = b # UnboundLocalError.
    b = 1
    c = 2 # Any def will do at present.
    print(g)
    print(c.frame.body)
    print(c.frame.body.xxx.yyy)
    print(b.yyy) # no check will be made.
    print(xxx.yyy)
    for c in 'abc':
        print(c,b)
        print(g)


class myClass:
    
    def __init__(self,c):
        self.a = True
        self.b = None
        c.frame.xxxx
        
    def spam(self,a,b,c=5,*args,**keys):
        global aGlobal2
        aGlobal2 = 'abc'
        self.a = b
        self.a = x
        
    def no_self(a):
        pass
        
    def test_lambda(self):
        f = lambda a,b: a

    def test_comprehension(self):
        z2 = [z for z in 'abc']
        
aGlobal3 = 4 # This should be defined everywhere.

def test():
    # a = ','.join(['a','b'])
    p = 5
    # print(p.parent().h)
    # print(g.app.windowList[0])
    print(p)
    print(g)

'''

# import leo.core.leoCommands as leoCommands
</t>
<t tx="ekr.20130503061820.4221">s = '''\

import leo.core.leoGlobals as g

def test(c):
    a = 5
    f = c.frame
    c.frame.body.bodyCtrl = w

'''

s = g.adjustTripleString(s,-4)
# print(s)
</t>
<t tx="ekr.20130503061820.4222">def test(files,print_stats=True,s=None,print_times=True):
   
    t1 = time.time()
    sd = leoInspect.SemanticData(controller=None)

    if s: # Use test string.
        fn = '&lt;test file&gt;'
        leoInspect.InspectTraverser(fn,sd).traverse(s)
    else:
        for fn in files:
            print(g.shortFileName(fn))
            s = leoInspect.LeoCoreFiles().get_source(fn)
            if s:
                leoInspect.InspectTraverser(fn,sd).traverse(s)
            else:
                print('file not found: %s' % (fn))
           
    sd.total_time = time.time()-t1
    
    if print_times: sd.print_times()
    if print_stats: sd.print_stats()
</t>
<t tx="ekr.20130503061820.4223">import leo.core.leoInspect as leoInspect

dump_classes = False
print_modules = True
print_functions = True
print_stats = False
print_times = False

# if dump_modules or print_stats:
    # g.cls()

m = leoInspect.module(fn='leoApp.py',sd=None,
    print_stats=print_stats,print_times=print_times)
    
if 0:
    print(m)
    for o in m.classes():
        if dump_classes:
            o.dump()
        if print_modules:
            print(o)
        if print_functions:
            for f in o.functions():
                print('  %s' % f)
</t>
<t tx="ekr.20130503061820.4224">import leo.core.leoInspect as leoInspect

# g.cls()

m = leoInspect.module(fn='leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
if 0:
    print(m)
    for z in m.classes():
        print(z)
        for z2 in z.defs():
            name = z2.tree_ptr.name
            aList = z2.call_args_of(name)
            args = ','.join(aList)
            print(' %s(%s)' % (name,args))
</t>
<t tx="ekr.20130503061820.4225">import leo.core.leoInspect as leoInspect

# g.cls()

m = leoInspect.module(fn='leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
if 0:
    for z in m.classes():
        print(z)
</t>
<t tx="ekr.20130503061820.4226">import leo.core.leoInspect as leoInspect

# g.cls()

m = leoInspect.module(fn='leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)

if 0:
    print(m)
    for z in m.classes():
        print(z)
        for z2 in z.defs():
            print(z2)
</t>
<t tx="ekr.20130503061820.4227">import leo.core.leoInspect as leoInspect

# g.cls()

m = leoInspect.module(fn='leoEditCommands.py')

def show(o):
    print('%-5s %s' % (o.line_number(),o.format()))

var = '.widget'
func = 'w.insert'

if 0:
    print('\nAssignments to %s...\n' % (var))
    for o in m.assignments_to(var):
        show(o)
        
    print('\nAssignments using %s...\n' % (var))
    for o in m.assignments_using(var):
        show(o)
        
    print('\nCalls to %s...\n' % (func))
    for o in m.calls_to(func):
        show(o)
        
    if 1:
        classes = m.classes()
        for d in classes[0].defs():
            print('')
            print(d)
            for z in d.statements():
                # print(z.tree())
                # print(z.sd.dump_ast(z.tree()))
                lines = g.splitLines(z.format())
                for line in lines:
                    print('  %s' % (line))
</t>
<t tx="ekr.20130503061820.4228">import leo.core.leoInspect as leoInspect

def show(o,indent=0):
    # print('\n%s\n' % o.sd.dump_ast(o.tree()))
    print('%s%s' % (' '*4*indent,o.format()))

&lt;&lt; define s &gt;&gt;
print('Input...\n%s\n' % (s.rstrip()))

m = leoInspect.module(s=s)

# print(show(m,0))

print('\nStatements...\n')
for o in m.statements():
    print(o.format())
    
if 0:
    print('\nAssignments...\n')
    for o in m.assignments():
        print(o.format())

print('\nAssignments to a...\n')
for o in m.assignments_to('a'):
    print(o.format())
    
print('\nAssignments using d...\n')
for o in m.assignments_using('d'):
    print(o.format())
    
print('\nCalls to f...\n')
for o in m.calls_to('f'):
    print(o.format())

if 0:
    for f in m.functions():
        show(f,0)
        for z in f.statements():
            show(z,1)
    
    for cls in m.classes():
        show(cls,0)
        for d in cls.defs():
            show(d,1)
            for z in d.statements():
                show(z,1)
</t>
<t tx="ekr.20130503061820.4229">s = '''
x.y = b(arg1,arg2=5,*args,**args).c[1:2:3].d
a=b+c
p,d,q[5]=f(a=1,b=2,*args,**keys)
'''


# def outer_function(a,b=99,c=88,*args,**keys):
    # print('hello')
    
# class myClass:
    # def method():
        # pass
    
</t>
<t tx="ekr.20130503061820.4230"></t>
<t tx="ekr.20130503061820.4231">import leo.core.leoInspect as leoInspect
import time

t1 = time.time()

sd = leoInspect.SemanticData()
count = 0
for fn in leoInspect.LeoCoreFiles().files:
    # print(fn)
    m = leoInspect.module(fn,sd=sd)
    count += 1

t2 = time.time()

print('file: %s time: %2.2f sec' % (count,t2-t1))

if 0:
    sd.print_stats()
if 1:
    sd.print_times()
</t>
<t tx="ekr.20130503061820.4232">import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

read_time,parse_time,traverse_time = 0.0,0.0,0.0
t_start = time.time()
count = 0
for fn in leoInspect.LeoCoreFiles().files:
    count += 1
    t2 = time.time()
    s = open(fn,'r').read()
    t3 = time.time()
    tree = ast.parse(s,filename=fn,mode='exec')
    t4 = time.time()
    leoInspect.AstTraverser(fn).visit(tree)
    t5 = time.time()

    read_time += t3-t2
    parse_time += t4-t3
    traverse_time += t5-t4
t_end = time.time()
total_time = t_end-t_start
if 1:
    print('files:     %s' % (count))
    print('read:      %2.3f sec.' % (read_time))
    print('ast.parse: %2.3f sec.' % (parse_time))
    print('traverse:  %2.3f sec.' % (traverse_time))
    print('total:     %2.3f sec.' % (total_time))

</t>
<t tx="ekr.20130503061820.4233">import imp
import time

import leo.core.leoInspect as li
imp.reload(li)
g_dump,g_format,g_kind = li.g_dump,li.g_format,li.g_kind

t1 = time.time()

print('starting pass 1...')

# Globals...
sd = li.SemanticData(controller=None)
g_d = {} # Keys are ivars, values are lists of classes.
n_files = 0

for fn in li.LeoCoreFiles().files:

    # Most of the time is spent creating the context objects.
    m = li.module(fn=fn,sd=sd)
    n_files += 1
    
    ### To do: create global assignments list.
    
    if 1: # Look for all targets. Takes about 0.15 sec.
        for class_ in m.classes():
            for def_ in class_.defs():
                for a in def_.assignments():
                    tree = a.tree()
                    kind = g_kind(tree)
                    # if g_kind(tree.value) == 'ListComp':
                        # print(a.format())
                        # print(g_dump(tree.value))
                    # print(a.format())
                    if kind == 'Assign':
                        for target in tree.targets:
                            # if False and g_kind(target) not in ('Attribute','Name','Tuple','Subscript'):
                                # print('assn target: %s' % g_format(target))
                                # print('assn target: %s' % g_dump(target))
                            name = g_format(target)
                            if name.startswith('self.'):
                                name = name[5:]
                            i = name.find('[')
                            if i &gt; -1:
                                name = name[:i]
                            aList = g_d.get(name,[])
                            if class_.name() not in aList:
                                aList.append(class_.name())
                                g_d[name] = aList
                    else:
                        assert kind == 'AugAssign',kind
                        name = g_format(tree.target)
                        aList = g_d.get(name,[])
                        if class_.name() not in aList:
                            aList.append(class_.name())
                            g_d[name] = aList

    # Takes about 0.1 sec. cumulative.
    if 0: # Look for all ivars.
        for class_ in m.classes():
            for def_ in class_.defs():
                if def_.name() == '__init__':
                    for a in def_.assignments_to('self'):
                        # Not all targets are ivars.
                        for target in a.tree().targets:
                            name = g_format(target)
                            if name.startswith('self.'):
                                name = name[5:]
                                aList = g_d.get(name,[])
                                if class_.name() not in aList:
                                    aList.append(class_.name())
                                    g_d[name] = aList
                       

t2 = time.time()

print('files: %s time: %2.2f sec, total ivars: %s' % (
    n_files,t2-t1,len(list(g_d.keys()))))

if 0:
    ambiguous,total = 0,0
    for key in sorted(g_d.keys()):
        aList = sorted(g_d.get(key))
        if 1 and len(aList) &gt; 1:
            w = 30 # Width of left column
            if total == 0: print('Global ivars dict...')
            if len(key) + 3 &gt; w: key = key[:w-3]+'...'
            aList2 = aList[:3]
            if len(aList2) &lt; len(aList): aList2.append('...')
            print('%30s %2s %s' % (key,len(aList),aList2))
        total += 1
        if len(aList) &gt; 1: ambiguous += 1
    print('total ivars: %s ambiguous: %s' % (total,ambiguous))

if 0:
    sd.print_stats()
</t>
<t tx="ekr.20130503061820.4234">g.cls()

import imp
import time

import leo.core.leoInspect as li
imp.reload(li)
g_dump,g_format,g_kind = li.g_dump,li.g_format,li.g_kind

t1 = time.time()

# Globals...
sd = li.SemanticData(controller=None)
d = sd.modules_dict

# Pass 1: Load all modules.
print('starting pass 1...')
for fn in li.LeoCoreFiles().files:
    li.module(fn=fn,sd=sd)

t2 = time.time()
print('pass 1: %2.3f sec files: %s' % (t2-t1,len(list(d.keys()))))
    
# Pass 2: compute all class names.
classes = set()
for fn in sorted(d):
    m = d.get(fn)
    for class_ in m.classes():
        classes.add(class_.name())
        
t3 = time.time()
print('pass 2: %2.3f sec' % (t3-t2))

classes = sorted(list(classes))

if 0:
    for z in classes:
        print(z)
        
# Pass 3: Find all calls to ctors.
ctors = set()
ctors_assns = []
for fn in sorted(d):
    m = d.get(fn)
    for class_ in m.classes():
        for def_ in class_.defs():
            for a in def_.assignments():
                rhs = a.tree().value
                if m.tree_kind(rhs) == 'Call':
                    s = li.g_find_function_call(rhs.func)
                    if s in classes:
                        ctors.add(s)
                        ctors_assns.append(a.format())
 
t4 = time.time()                            

if 0:
    for z in sorted(list(ctors)):
        print(z)
if 0:
    for s in ctors_assns:
        aList = s.split('=')
        print('%30s = %s' % (aList[0],'='.join(aList[1:])[:80]))

print('pass 3: %2.3f sec ctors assigns: %s' % (t4-t3,len(ctors_assns)))

if 1:
    sd.print_stats()
if 1:
    sd.print_times()
</t>
<t tx="ekr.20130503061820.4235"># g.cls()

import imp
import pickle
import time

import leo.core.leoInspect as li
imp.reload(li)
    
# Works, because TestPickleClass is a top-level class.
o = li.TestPickleClass()

try:
    s = pickle.dumps(o)
    print(len(s),o)
except pickle.PicklingError:
    print('can not pickle: %s' % repr(o))
</t>
<t tx="ekr.20130503061820.4236"># g.cls()

import imp
import pickle
import time

import leo.core.leoInspect as li
imp.reload(li)
g_dump,g_format,g_kind = li.g_dump,li.g_format,li.g_kind

# Pass 1: Load all modules.
t1 = time.time()
sd = li.SemanticData(controller=None)
files = li.LeoCoreFiles().files

print('starting pass 1...')
for fn in files:
    li.module(fn=fn,sd=sd)

t2 = time.time()
print('pass 1: %2.3f sec files: %s' % (t2-t1,len(list(sd.modules_dict.keys()))))

# Pass 2: pickle all modules.
for fn in sorted(sd.modules_dict.keys()):
    m = sd.modules_dict.get(fn)
    try:
        s = pickle.dumps(m)
        print('%6s %s' % (len(s),fn))
    except pickle.PicklingError:
        print('can not pickle: %s' % repr(m))
        
t3 = time.time()
print('pass 2: %2.3f sec' % (t3-t2))
</t>
<t tx="ekr.20130503061820.4237">g.cls()

import imp

import leo.core.leoInspect as li
imp.reload(li)
g_format = li.g_format

# Pass 1: Load all modules.
sd = li.SemanticData(controller=None)
files = li.LeoCoreFiles().files # [0:2]

s = '''
def spam():
    """This is a docstring"""
    a = 2
    try:
        pass
    except Exception as message: ###
        pass
    if f(1):
        g('a')
    else:
        g(2)
    while 1 &lt; 2:
        pass
    raise AttributeError ###
    return 2
'''

if 0: # String
    li.module(s=s,sd=sd)
else:
    print('starting pass 1...')
    for fn in files:
        li.module(fn=fn,sd=sd)
    
# Pass 2: format the module.
for fn in sorted(sd.modules_dict.keys()):
    m = sd.modules_dict.get(fn)
    # print(m.format())
    m.format() # Run for warnings.
</t>
<t tx="ekr.20130503061820.4238">import imp
import leo.core.leoInspect as li
imp.reload(li)

g.cls()

aList = li.g_files_in_dir(r'C:\Python26\Lib\lib2to3',
    extList = ['.py'],
    excludeDirs= ['tests'])

for z in aList:
    print(z)

print('files: %s' % (len(z)))
</t>
<t tx="ekr.20130503061820.4239">import ast
import imp
import time
import leo.core.leoInspect as li
imp.reload(li)

t1 = time.time()

g.cls()

last = c.rootPosition()
while last.hasNext():
    last = last.next()
    
parent = last.insertAfter()
parent.h = 'Chains: %s' % time.strftime('%Y/%m/%d/%H:%M:%S',time.localtime())
parent.b = '@killcolor'

count, total_chains,unusual_chains = 0,0,0
for fn in li.LeoCoreFiles().files: # [:2]:
    # print()
    # print(fn)
    s = open(fn,'r').read()
    tree = ast.parse(s,filename=fn,mode='exec')
    cp = li.ChainPrinter(fn)
    cp.visit(tree)
    p2 = parent.insertAsLastChild()
    p2.h = g.shortFileName(fn)
    n1,n2 = cp.showChains(p2)
    total_chains += n1
    unusual_chains += n2
    # print('chains: %s' % (n))
    count += 1
    
c.redraw(parent)

t2 = time.time()

print('files: %s total chains: %s unusual_chains: %s time: %2.2f sec' % (
    count,total_chains,unusual_chains,t2-t1))

# if 0:
    # sd.print_stats()
# if 0:
    # sd.print_times()
</t>
<t tx="ekr.20130503061820.4240">import ast
import imp
import time
import leo.core.leoInspect as li
imp.reload(li)

g.cls()

t1 = time.time()

last = c.rootPosition()
while last.hasNext():
    last = last.next()
    
parent = last.insertAfter()
parent.h = 'Calls: %s' % time.strftime('%Y/%m/%d/%H:%M:%S',time.localtime())
parent.b = '@killcolor'

g_d = {}
count=0
for fn in li.LeoCoreFiles().files: # [:3]:
    # print()
    # print(fn)
    s = open(fn,'r').read()
    tree = ast.parse(s,filename=fn,mode='exec')
    cp = li.CallPrinter(fn)
    cp.visit(tree)
    p2 = parent.insertAsLastChild()
    p2.h = g.shortFileName(fn)
    cp.showCalls(p2)
    for key in cp.d.keys():
        aList = g_d.get(key,[])
        aList.extend(cp.d.get(key))
        g_d[key] = sorted(list(set(aList)))
    count += 1
    
p2 = parent.insertAsLastChild()
p2.h = 'global calls'
cp.showCalls(p2,d=g_d)
c.selectPosition(parent)
c.redraw()

t2 = time.time()

print('files: %s time: %2.2f sec' % (count,t2-t1))
</t>
<t tx="ekr.20130503061820.4241">import ast
import imp
import time
import leo.core.leoInspect as li
imp.reload(li)

g.cls()

t1 = time.time()

last = c.rootPosition()
while last.hasNext():
    last = last.next()
    
project_name,verbose = 'leo',False # False: only print defs with more than one return.
files = li.g_get_files_by_project_name(project_name)

parent = last.insertAfter()
parent.h = 'Returns: %s verbose=%s %s' % (
    project_name, verbose,
    time.strftime('%Y/%m/%d/%H:%M:%S',time.localtime()))
parent.b = '@killcolor'

g_d = {}
count=0
for fn in files:
    # print(fn)
    s = open(fn,'r').read()
    try:
        tree = ast.parse(s,filename=fn,mode='exec')
    except SyntaxError:
        print('Syntax error in %s' % (fn))
        continue
    rp = li.ReturnPrinter(fn)
    rp.visit(tree)
    p2 = parent.insertAsLastChild()
    p2.h = g.shortFileName(fn)
    p2.b = rp.showReturns(verbose=verbose)
    for key in rp.d.keys():
        aList = g_d.get(key,[])
        aList2 = rp.d.get(key)
        if aList2:
            aList.extend(aList2)
            g_d[key] = aList
    count += 1
    
if 0:
    p2 = parent.insertAsLastChild()
    p2.h = 'global returns'
    rp.showReturns(p2,d=g_d)

c.redraw(parent)

t2 = time.time()

print('files: %s time: %2.2f sec' % (
    count,t2-t1))
</t>
<t tx="ekr.20130503061820.4242"># import ast
import imp
import time
import leo.core.leoInspect as li
imp.reload(li)

g.cls()

project_name,verbose = 'leo',False
files = li.g_get_files_by_project_name(project_name)
result = []

def put(s):
    result.append(s)
    # print(s)
    
t1 = time.time()

# Globals...
sd = li.SemanticData(controller=None)
m_d = sd.modules_dict

# Pass 1: Load all modules.
print('starting pass 1...')
for fn in files: ### [:2]:
    li.module(fn=fn,sd=sd)

t2 = time.time()
put('pass 1: %2.3f sec files: %s' % (t2-t1,len(list(m_d.keys()))))

# Pass 2: Update g_d.
g_d = {} # Keys are names, values are sets of Context names.
contexts = 0
for fn in sorted(m_d):
    m = m_d.get(fn)
    for cx in m.contexts(include_temp=True):
        # put(' '*len(cx.parent_contexts()),cx)
        contexts += 1
        d = cx.st.d # Keys are names, values are symbol table entries.
        for key in d.keys():
            e = d.get(key)
            name = e.name
            aSet = g_d.get(name,set())
            aSet.add(cx)
            g_d[name] = aSet
            
names = sorted(g_d.keys())
distribution = {} # Keys are lengths of context sets; values are number of ids with that length.
for key in names:
    aSet = g_d.get(key)
    context_list = sorted(list(set([repr(z) for z in aSet])))
    n = len(context_list)
    distribution[n] = distribution.get(n,0) + 1
    if verbose or n &gt; 9:
        if n &gt; 3:
            put('%20s %4s %s...' % (key,len(context_list),context_list[:3]))
        else:
            put('%20s %4s %s' % (key,len(context_list),context_list))
ids = len(names)
        
t3 = time.time()
put('pass 2: contexts: %s ids: %s %2.2f sec' % (contexts,ids,t3-t2))

if 1:
    put('\nDistribution of context lengths...')
    for key in sorted(distribution.keys()):
        put('%4s %s' % (key,distribution.get(key)))
    
if 1:
    last = c.rootPosition()
    while last.hasNext():
        last = last.next()
    parent = last.insertAfter()
    parent.h = 'Global names: %s verbose=%s %s' % (
        project_name, verbose,
        time.strftime('%Y/%m/%d/%H:%M:%S',time.localtime()))
    parent.b = '@killcolor\n\n%s' % '\n'.join(result)
    c.redraw(parent)

if 0:
    sd.print_stats()
if 0:
    sd.print_times()

</t>
<t tx="ekr.20131111155107.4239">c.testManager.runVimTest(p)

</t>
<t tx="ekr.20131111155107.4240">first line
</t>
<t tx="ekr.20131111155107.4241">first line
</t>
<t tx="ekr.20131111155107.4242">first line
</t>
<t tx="ekr.20131111160618.4261"></t>
<t tx="ekr.20131111162157.4270">@language python
# http://docs.python.org/2/library/re.html
import re
# g.cls()
trace = False
n =     r'(?P&lt;n&gt;[0-9]*)'    # Optional digits
cmd =   r'(?P&lt;cmd&gt;[^0-9]+)' # Required: anything *except* digits.
n2 =    r'(?P&lt;n2&gt;[0-9]*)'   # Optional digits
cmd2 =  r'(?P&lt;cmd2&gt;[a-zA-Z]?)' # Optional letter.
n_c = n+cmd+n2+cmd2
tables = (
    (n_c,('35N','N','2d2','d2d','gg',)),
)
for pat,aList in tables:
    fields = re.findall('\(\?P&lt;([a-z_A-Z0-9]+)&gt;',pat)
    if trace: print('pattern: %s\n fields: %s' % (pat,','.join(fields)))
    for s in aList:
        if trace: print('  %s' % s)
        m = re.search(pat,s)
        for field in fields:
            try:
                val = m.group(field)
            except Exception:
                g.es_exception()
                val = None
            if trace: print('    %7s %s' % (field,val or 'None'))
</t>
<t tx="ekr.20131111162157.4271">@language python
# g.cls()

# Unknown:
# N   H  (motion?) go to the Nth line in the window, on the first non-blank
# N   J  (motion?) join N-1 lines (delete newlines)
# VIS J  (motion?) join the highlighted lines
    # M  (motion?) go to the middle line in the window, on the first non-blank
# N   L  (motion?) go to the Nth line from the bottom, on the first non-blank
# o      (motion?) exchange cursor position with start of highlighting

# Not used:
# N %    goto line N percentage down in the file.
#        N must be given, otherwise it is the % command.

#   0    to first character in the line (also: &lt;Home&gt; key)
#   ^    go to first non-blank character in the line
#   %    find the next brace, bracket, comment,
#        or "#if"/ "#else"/"#endif" in this line and go to its match
# N +    down N lines, on the first non-blank character (also: CTRL-M and &lt;CR&gt;)
# N _    down N-1 lines, on the first non-blank character
# N -    up N lines, on the first non-blank character
# N ,    repeat the last "f", "F", "t", or "T" N times in opposite direction
# N ;    repeat the last "f", "F", "t", or "T" N times
# N (    N sentences backward
# N )    N sentences forward
# N {    N paragraphs backward
# N }    N paragraphs forward
# N |    to column N (default: 1)
# N $    go to the last character in the line (N-1 lines lower) (also: &lt;End&gt; key)
# N #    search backward for the identifier under the cursor
# N *    search forward  for the identifier under the cursor
# N B    N blank-separated WORDS backward
# N E    forward to the end of the Nth blank-separated WORD
# N G    goto line N (default: last line), on the first non-blank character
# N N    repeat last search, in opposite direction
# N W    N blank-separated WORDS forward
# N b    N words backward
# N e    forward to the end of the Nth word
# N h    left (also: CTRL-H, &lt;BS&gt;, or &lt;Left&gt; key)
# N j    down N lines (also: CTRL-J, CTRL-N, &lt;NL&gt;, and &lt;Down&gt;)
# N k    up N lines (also: CTRL-P and &lt;Up&gt;)
# N l    right (also: &lt;Space&gt; or &lt;Right&gt; key)
# N n    repeat last search
# N w    N words forward
single_char_motions = [ch for ch in '0^%_+-,;(){}|$#*BEGNWbehjklnw']
# N [#   N times back to unclosed "#if" or "#else"
# N [(   N times back to unclosed '('
# N [*   N times back to start of comment "/*"
# N [[   N sections backward, at start of section
# N []   N sections backward, at end of section
# N [{   N times back to unclosed '{'
m1  = ['['+ ch for ch in '#(*[]{']
# N ]#   N times forward to unclosed "#else" or "#endif"
# N ])   N times forward to unclosed ')'
# N ]*   N times forward to end of comment "*/"
# N ][   N sections forward, at end of section
# N ]]   N sections forward, at start of section
# N ]}   N times forward to unclosed '}'
m2 = [']'+ch for ch in '#)*[]}']
#   gD   goto global declaration of identifier under the cursor
#   gd   goto local declaration of identifier under the cursor
# N g^   to first non-blank character in screen line (differs from "^" when lines wrap)
# N g#   like "#", but also find partial matches
# N g$   to last character in screen line (differs from "$" when lines wrap)
# N g*   like "*", but also find partial matches
# N g0   to first character in screen line (differs from "0" when lines wrap)
# N gE   backward to the end of the Nth blank-separated WORD
# N ge   backward to the end of the Nth word
# N gg   goto line N (default: first line), on the first non-blank character
# N gj   down N screen lines (differs from "j" when line wraps)
# N gk   up N screen lines (differs from "k" when line wraps)
m3 = ['g'+ch for ch in '^#$*0DEdegjk']
# N /&lt;CR&gt;  repeat last search, in the forward direction
m4 = ['/\\n',]
# N F&lt;char&gt;  to the Nth occurrence of &lt;char&gt; to the left
# N T&lt;char&gt;  till before the Nth occurrence of &lt;char&gt; to the left
# N f&lt;char&gt;  to the Nth occurrence of &lt;char&gt; to the right
# N t&lt;char&gt;  till before the Nth occurrence of &lt;char&gt; to the right
char_motions = [ch for ch in 'FTft']
multi_char_leadins = '/g[]'
multi_char_motions = m1+m2+m3+m4
print('\n'.join(single_char_motions))
print('\n'.join(multi_char_motions))
print('\n'.join(['%s&lt;char&gt;' % (ch) for ch in char_motions]))
</t>
<t tx="ekr.20131111162157.4272">@language python

# http://docs.python.org/2/library/re.html
import re
# g.cls()

def escape(ch):
    return ch if ch.isalnum() else '\\%s' % ch
# Not yet.
# N /&lt;CR&gt; (motion) repeat last search, in the forward direction

# 0 (motion) to first character in the line (also: &lt;Home&gt; key)
# ^ (motion) go to first non-blank character in the line
# % (motion) find the next brace, bracket, comment,
#            or "#if"/ "#else"/"#endif" in this line and go to its match
plain_motion_chars = '0^%'
plain_motion =   '|'.join([escape(ch) for ch in plain_motion_chars])
# N + (motion) down N lines, on the first non-blank character (also: CTRL-M and &lt;CR&gt;)
# N _ (motion) down N-1 lines, on the first non-blank character
# N - (motion) up N lines, on the first non-blank character
# N , (motion) repeat the last "f", "F", "t", or "T" N times in opposite direction
# N ; (motion) repeat the last "f", "F", "t", or "T" N times
# N ( (motion) N sentences backward
# N ) (motion) N sentences forward
# N { (motion) N paragraphs backward
# N } (motion) N paragraphs forward
# N | (motion) to column N (default: 1)
# N $ (motion) go to the last character in the line (N-1 lines lower) (also: &lt;End&gt; key)
# N % (motion) goto line N percentage down in the file.  N must be given, otherwise it is the % command.
# N # (motion) search backward for the identifier under the cursor
# N * (motion) search forward for the identifier under the cursor
n_motion_chars = '+_-,;(){}|$%#*'
n_motion_alts = ' | '.join([escape(ch) for ch in n_motion_chars])
# N [#  (motion) N times back to unclosed "#if" or "#else"
# N [(  (motion) N times back to unclosed '('
# N [*  (motion) N times back to start of comment "/*"
# N [[  (motion) N sections backward, at start of section
# N []  (motion) N sections backward, at end of section
# N [{  (motion) N times back to unclosed '{'
open_bracket_chars  = ['[%s' % (ch) for ch in '#(*[]{']
# N ]#  (motion) N times forward to unclosed "#else" or "#endif"
# N ])  (motion) N times forward to unclosed ')'
# N ]*  (motion) N times forward to end of comment "*/"
# N ][  (motion) N sections forward, at end of section
# N ]]  (motion) N sections forward, at start of section
# N ]}  (motion) N times forward to unclosed '}'
close_bracket_chars = [']%s' % (ch) for ch in '#)*[]}']
bracket_chars = open_bracket_chars + close_bracket_chars
bracket_motion = ' | '.join(['%s%s' % (escape(s[0]),escape(s[1])) for s in bracket_chars])
bracket_alts =      r'(?P&lt;bracket_alt&gt;%s)' % (bracket_motion)
# print(bracket_alts)
# gD (motion) goto global declaration of identifier under the cursor
# gd (motion) goto local declaration of identifier under the cursor
g_bare_alts =   r'(?P&lt;bare_g_alts&gt;(gD|gd))'
# N g^      (motion) to first non-blank character in screen line (differs from "^" when lines wrap)
# N g#      (motion) like "#", but also find partial matches
# N g$      (motion) to last character in screen line (differs from "$" when lines wrap)
# N g*      (motion) like "*", but also find partial matches
# N g0      (motion) to first character in screen line (differs from "0" when lines wrap)
# N gE      (motion) backward to the end of the Nth blank-separated WORD
# N ge      (motion) backward to the end of the Nth word
# N gg      (motion) goto line N (default: first line), on the first non-blank character
# N gj      (motion) down N screen lines (differs from "j" when line wraps)
# N gk      (motion) up N screen lines (differs from "k" when line wraps)
g_alt_chars =   ' | '.join([escape(ch) for ch in '^#$*0Eegjk'])
g_alts =        r'(?P&lt;g_n&gt;[0-9]*)(?P&lt;g_alt&gt;g(%s))' % (g_alt_chars)
g_motion = 'g(%s | %s)' % (g_bare_alts,g_alts)
print(g_motion)
</t>
<t tx="ekr.20131111162157.4275">import leo.core.leoVim as leoVim
if 0: # When running from leoPy.leo
    import imp
    imp.reload(leoVim)
vc = leoVim.VimCommands(c)
table = (
    # 'gg','gk','#','dd','d3j',
    'h', # works
    # 'l', # works
    # 'j', # Not yet.
    # 'ggg',
)
for s in table:
    status,n1,command,n2,motion = vc.scan(s)
    # print('status',status,'command',command)
    if status == 'done':
        vc.exec_(command,n1,n2,motion)
    else:
        print('status: %s %s' % (status,s))
        vc.command = s
        vc.n1 = n1
        vc.n2 = n2
        vc.motion = motion
        vc.oops()

if g.unitTesting:
    # Unit testing messes up the focus.
    vc.runAtIdle(c.bodyWantsFocusNow)
</t>
<t tx="ekr.20131111162157.4276"></t>
<t tx="ekr.20131113071911.4281">import leo.core.leoVim as leoVim
if 0: # When running from leoPy.leo
    import imp
    imp.reload(leoVim)
import time
trace = False
trace_time = False
&lt;&lt; define test tables &gt;&gt;
vc = leoVim.VimCommands(c)
test_table = (
    ('done',complete_table),
    ('scan',incomplete_table),
    ('oops',error_table),
)
if trace_time: t1 = time.clock()
n = 0
for i in range(1):
    for expected,table in test_table:
        for s in table:
            if table == complete_table:
                command = s
                for expected,command2 in vc.simulate_typing(command):
                    status,n1,command3,n2,motion = vc.scan(command2)
                    n += 1
                    if trace:
                        err = '   ' if status == expected else '***'
                        print('%s%s %s' % (err,status,command2))
                    else:
                        assert status == expected,'expected %s, got %s command: %s' % (
                        expected,status,command2)
            else:
                for prefix in ('','1023456789'):
                    command = prefix + s
                    status,n1,command2,n2,motion = vc.scan(command)
                    n += 1
                    if trace:
                        err = '   ' if status == expected else '***'
                        print('%s%s %s' % (err,status,command))
                    else:
                        assert status == expected,'expected %s, got %s command: %s' % (
                        expected,status,command)
if trace_time:
    delta = time.clock()-t1
    print("%s %6.6f sec." % (n,delta/n))

</t>
<t tx="ekr.20131113071911.4282"># To do: handle d2d, 2dd, etc.
if 0: # Individual test:
    complete_table = ('ta',)
        # Note: gu is complete, so gu[] is an invalid test.
    incomplete_table = () # 'd3','d4t','dt',
    error_table = ()
else:
    complete_table = (
        '0',
        'N',
        '#',
        'gg','gk','dd',
        'd3j',
        '2dta', # d is not (yet) a motion
        'dFb',
        'gu',
        'g[]',
        'ta',
        't!',
    )
    incomplete_table = (
        'g',
        '[',
        ']',
        '25',
        'd3t',
        'd3',
    )
    error_table = (
        'gX','ZA',
    )
</t>
<t tx="ekr.20131231093529.3984"></t>
<t tx="ekr.20140103102956.4142">vc = c.viewController
clones = g.findNodeInTree(c,p,'@clones')
root = g.findNodeInTree(c,p,'root')
node1 = g.findNodeInTree(c,p,'node1')
assert clones and root and node1
root.deleteAllChildren()
new_node1 = root.insertAsLastChild()
new_node1.h = 'node1'
clones.b = 'gnx: %s\nunl: %s\n' % (node1.v.gnx,'node1')
try:
    ok = vc.create_clone_links(clones,root)
    assert ok
    # Important: p._relinkAsCloneOf leaves new_node1 unchanged,
    # but new_node1 should not be used.
finally:
    c.redraw()
</t>
<t tx="ekr.20140103102956.4143">gnx: ekr.20140211085929.5552
unl: node1
</t>
<t tx="ekr.20140103102956.4145"></t>
<t tx="ekr.20140103102956.4146">vc = c.viewController
root = c.rootPosition().insertAfter()
root.h = 'root'
child1 = root.insertAsLastChild()
child1.h = 'child1'
child2 = child1.insertAfter()
child2.h = 'child2'
child11 = child1.insertAsLastChild()
child11.h = 'child11'
try:
    for unl in ('root','root--&gt;child1','root--&gt;child2','root--&gt;child1--&gt;child11'):
        p = vc.find_absolute_unl_node(unl)
        parts = unl.split('--&gt;')
        assert p,unl
        assert p.h == parts[-1],p.h
finally:
    root.doDelete()
    c.selectPosition(p)
    c.redraw()
</t>
<t tx="ekr.20140103102956.4147">vc = c.viewController
parent = p.copy()
node1 = p.firstChild()
node2 = node1.next()
assert node1 and node2
child11 = node1.firstChild()
child12 = child11.next()
assert child11 and child12
child21 = node2.firstChild()
child22 = child21.next()
assert child21 and child22
table = (
    # ('node1',node1),
    ('',parent), # This special case is important.
    ('node1--&gt;child11',child11),
    ('node1--&gt;child12',child12),
    ('node2',node2),
    ('node2--&gt;child21',child21),
    ('node2--&gt;child22',child22),
    ('node3',None),
    ('node1--&gt;childx',None),
    ('node3--&gt;childx',None),
)
for unl,expected in table:
    got = vc.find_position_for_relative_unl(parent,unl)
    assert got == expected,'unl: %s expected: %s got: %s' % (
        unl,expected and expected.h,got and got.h)
</t>
<t tx="ekr.20140103102956.4148"></t>
<t tx="ekr.20140103102956.4149"></t>
<t tx="ekr.20140103102956.4150"></t>
<t tx="ekr.20140103102956.4151"></t>
<t tx="ekr.20140103102956.4152"></t>
<t tx="ekr.20140103102956.4153"></t>
<t tx="ekr.20140103102956.4154">vc = c.viewController
root = g.findNodeInTree(c,p,'root')
assert root
root.h = '@auto root'
try:
    clone = root.next()
    assert clone and clone.h == 'clone'
    inner_clone = root.firstChild()
    assert inner_clone
    assert clone.v == inner_clone.v
    rep = vc.find_representative_node(root,inner_clone)
    # Careful: cloning this test can cause problems.
    oops = '\n  rep: %s\nparent:%s\nclone: %s\nparent:%s\ninner: %s\nparent: %s' % (
        rep,rep.parent(),clone,clone.parent(),inner_clone,inner_clone.parent())
    if True: ### p.isCloned():
        assert rep.v == clone.v and rep.parent().v == clone.parent().v,oops
    else:
        assert rep == clone
finally:
    root.h = 'root' # root must not be an @auto node.
    c.redraw()
</t>
<t tx="ekr.20140103102956.4155"></t>
<t tx="ekr.20140103102956.4157"></t>
<t tx="ekr.20140103102956.4158"># Also a test of find_at_views_node, find_at_organizers_node and find_at_clones_node.
vc = c.viewController
root = g.findNodeInTree(c,p,'root')
assert root
views = g.findNodeAnywhere(c,'@views')
assert views,'1'
if views:
    views.deleteAllChildren()
try:
    root.h = '@auto root' # root must look like an @auto node.
    views = vc.find_at_views_node()
    assert views,'2'
    views2 = vc.find_at_views_node()
    assert views2 == views
    assert vc.find_at_clones_node(root)
    assert vc.find_at_organizers_node(root)
finally:
    root.h = 'root' # Make sure root is *not* an @auto node.
    # views.deleteAllChildren()
    c.selectPosition(p)
    c.redraw()
</t>
<t tx="ekr.20140103102956.4159"></t>
<t tx="ekr.20140103102956.4160">class aClass:
    @others
</t>
<t tx="ekr.20140103102956.4162"></t>
<t tx="ekr.20140103102956.4163">def spam():
    pass
</t>
<t tx="ekr.20140103102956.4164"></t>
<t tx="ekr.20140103102956.4165">vc = c.viewController
tag = '@views'
views = g.findNodeAnywhere(c,tag)
assert views
views2 = vc.has_at_views_node()
assert views == views2,(views,views2)
</t>
<t tx="ekr.20140103102956.4166">vc = c.viewController
p.deleteAllChildren()
auto = p.insertAsLastChild()
auto.h = '@auto test.py'
auto2 = p.insertAsLastChild()
auto2.h = '@auto-rst test2.py'
try:
    assert vc.is_at_auto_node(auto)
    assert not vc.is_at_auto_node(auto2)
finally:
    # This is required.
    p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20140103102956.4167">vc = c.viewController
redraw_flag = False
for child in p.children():
    # Add a child so the test doesn't depend on that.
    if not child.hasChildren():
        child2 = child.insertAsLastChild()
        child2.h = 'child'
        redraw_flag = True
        
    expected = child.h.strip().endswith('True')
    got = vc.is_organizer_node(child,child)
    assert expected == got,'expected: %s in: %s body...\n%s' % (
        expected,child.h,child.b)
if redraw_flag:
    c.redraw()
</t>
<t tx="ekr.20140103102956.4168">@language python

# An organizer node

# Another line.
</t>
<t tx="ekr.20140103102956.4169"></t>
<t tx="ekr.20140103102956.4170">@language python

def spam():
    pass
</t>
<t tx="ekr.20140103102956.4171"></t>
<t tx="ekr.20140103102956.4172">@language html

&lt;!-- comment --&gt;

&lt;!-- comment
continued comment
--&gt;

</t>
<t tx="ekr.20140103102956.4173"></t>
<t tx="ekr.20140103102956.4174">@language html

&lt;!-- comment --&gt;

&lt;p&gt; oops &lt;/p&gt;

&lt;!-- comment
continued comment
--&gt;

</t>
<t tx="ekr.20140103102956.4175"></t>
<t tx="ekr.20140103102956.4176">vc = c.viewController
unl = vc.unl(p)
assert unl.endswith('--&gt;'+p.h),repr(unl)
</t>
<t tx="ekr.20140103102956.4184">vc = c.viewController
views = g.findNodeAnywhere(c,'@views')
assert views
views.deleteAllChildren()
view = g.findNodeInTree(c,p,'@view test')
assert view
assert c.positionExists(view)
try:
    c.selectPosition(view)
    v_b = view.b
    vc.pack()
    assert c.p.v == view.v
    vc.unpack()
    assert view.b == v_b,view.b
    assert view.lastChild().isCloned()
finally:
    # views.deleteAllChildren()
    c.undoer.clearUndoState()
    c.redraw()
</t>
<t tx="ekr.20140103102956.4186">view body
</t>
<t tx="ekr.20140103102956.4187">not a clone text
</t>
<t tx="ekr.20140103102956.4188">clone body
</t>
<t tx="ekr.20140105185509.4140">vc = c.viewController
views = g.findNodeAnywhere(c,'@views')
if views: views.deleteAllChildren()
root_restore = g.findNodeInTree(c,p,'root_restore')
assert root_restore
root_before = g.findNodeInTree(c,p,'root_before')
assert root_before
root_after = g.findNodeInTree(c,p,'root_after')
if root_after: root_after.doDelete()
    # Root after: the results of the previous test.
c.selectPosition(root_restore)
c.copyOutline()
c.selectPosition(root_before)
c.pasteOutline()
root_after = c.p
try:
    # The roots must look like @auto nodes.
    root_before.h = '@auto root_before'
    root_after.h = '@auto root_after'
    vc.init() # Required.
    vc.update_before_write_at_auto_file(root_before)
    organizers = vc.has_at_organizers_node(root_before)
    assert organizers
    vc.create_organizer_nodes(organizers,root_after)
    ok = vc.compare_test_trees(root_before,root_after)
    assert ok,'\n\nexpected...\n%s\ngot...\n%s' % (
        vc.trial_write(root_before),vc.trial_write(root_after))
finally:
     # Make sure the roots are *not* @auto nodes.
    root_before.h = 'root_before'
    root_after.h = 'root_after'
    # Replace root_after by a copy of root_restore.
    # This ensures that the unit test can be run more than once.
    if 0:
        root_after.doDelete()
        c.selectPosition(root_restore)
        c.copyOutline()
        c.selectPosition(root_before)
        c.pasteOutline()
        assert c.p.h == 'root_restore'
        c.p.h = 'root_after'
        c.redraw()
</t>
<t tx="ekr.20140105185509.4141">@others
</t>
<t tx="ekr.20140105185509.4142">class aClass:
    @others
</t>
<t tx="ekr.20140105185509.4143">def before():
    pass
</t>
<t tx="ekr.20140105185509.4144"></t>
<t tx="ekr.20140105185509.4145">def child1():
    pass
</t>
<t tx="ekr.20140105185509.4146">def child2():
    pass
</t>
<t tx="ekr.20140105185509.4147">def after():
    pass
</t>
<t tx="ekr.20140105185509.4181">vc = c.viewController
root = g.findNodeInTree(c,p,'root')
assert root
views = g.findNodeAnywhere(c,'@views')
if views:
    views.deleteAllChildren()
try:
    root.h = '@auto root' # root must look like an @auto node.
    vc.update_before_write_at_auto_file(root)
    views = g.findNodeAnywhere(c,'@views')
    assert views
    clones = g.findNodeInTree(c,views,'@clones')
    assert clones
    assert clones.b.endswith('aClass--&gt;clone\n'),repr(clones.b)
    organizer = g.findNodeInTree(c,views,'@organizer: organizer node')
    assert organizer
    s1 = 'unl: organizer node--&gt;child1'
    s2 = 'unl: organizer node--&gt;child2'
    assert organizer.b == '\n'.join([s1,s2]),organizer.b
finally:
    root.h = 'root' # Make sure root is *not* an @auto node.
    if False and views:
        views.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20140105185509.4182"></t>
<t tx="ekr.20140105185509.4183">class aClass:
    @others
</t>
<t tx="ekr.20140105185509.4185"></t>
<t tx="ekr.20140105185509.4186">def spam():
    pass
</t>
<t tx="ekr.20140105185509.4187"></t>
<t tx="ekr.20140105185509.4198"># Test vc.has_at_auto_view_node, vc.has_at_clones_node and vc.has_at_organizers_node.
vc = c.viewController
views = g.findNodeAnywhere(c,'@views')
if views:
    assert vc.has_at_views_node()
    views.deleteAllChildren()
else:
    assert not vc.has_at_views_node()
    views = vc.find_at_views_node()
assert views
root = g.findNodeInTree(c,p,'root')
assert root
# The representative of clone_test node must appear outside of root's tree.
clone_test = g.findNodeInTree(c,p,'clone-test')
assert clone_test
assert clone_test.v == root.next().v,(clone_test.v,root.next().v)
try:
    root.h = '@auto root' # root must look like an @auto node.
    vc.update_before_write_at_auto_file(root)
    auto_view = g.findNodeInTree(c,views,'@auto-view:root')
    assert auto_view
    auto_view2 = vc.has_at_auto_view_node(root)
    assert auto_view2
    assert auto_view2 == auto_view,(auto_view,auto_view2)
    clones = g.findNodeInTree(c,auto_view,'@clones')
    assert clones
    clones2 = vc.has_at_clones_node(root)
    assert clones2
    assert clones2 == clones
    organizers = g.findNodeInTree(c,auto_view,'@organizers')
    assert organizers
    organizers2 = vc.has_at_organizers_node(root)
    assert organizers2
    assert organizers2 == organizers
finally:
    root.h = 'root' # Make sure root is *not* an @auto node.
    c.redraw()
</t>
<t tx="ekr.20140105185509.4199">@others
</t>
<t tx="ekr.20140105185509.4200">class aClass:
    @others
</t>
<t tx="ekr.20140105185509.4202"></t>
<t tx="ekr.20140105185509.4203">def spam():
    pass
</t>
<t tx="ekr.20140105185509.4204">def clone_test():
    pass
</t>
<t tx="ekr.20140105185509.4216"></t>
<t tx="ekr.20140105190941.4170">@others
</t>
<t tx="ekr.20140105190941.4171">class aClass:
    @others
</t>
<t tx="ekr.20140105190941.4172">def before():
    pass
</t>
<t tx="ekr.20140105190941.4174">def child1():
    pass
</t>
<t tx="ekr.20140105190941.4175">def extra2():
    pass
</t>
<t tx="ekr.20140105190941.4176">def child2():
    pass
</t>
<t tx="ekr.20140105190941.4178">def after():
    pass
</t>
<t tx="ekr.20140105222052.4170">vc = c.viewController
views = g.findNodeAnywhere(c,'@views')
assert views
views.deleteAllChildren()
views.b = None ####
root1 = g.findNodeInTree(c,p,'root1')
assert root1
try:
    root1.h = '@auto root1'
finally:
    root1.h = 'root1'
</t>
<t tx="ekr.20140105222052.4171"></t>
<t tx="ekr.20140105222052.4172"></t>
<t tx="ekr.20140106094713.4176">vc = c.viewController
organizer_unls = [
    'a--&gt;O1',
    'a--&gt;O1--&gt;O2',
    'a--&gt;O3',
    'a--&gt;O3--&gt;b--&gt;O4',
    'z',
]
table = (
    ('z--&gt;x','x'), # Test of dropping a leading --&gt;.
    ('a--&gt;O1--&gt;unl1','a--&gt;unl1'),
    ('a--&gt;O1--&gt;O2--&gt;unl2','a--&gt;unl2'),
    ('a--&gt;O3--&gt;unl3','a--&gt;unl3'),
    ('a--&gt;O3--&gt;b--&gt;O4--&gt;unl4','a--&gt;b--&gt;unl4'),
)
for unl,expected in table:
    got = vc.drop_all_organizers_in_unl(organizer_unls,unl)
    assert expected == got,'\nunl:      %s\nexpected: %s\ngot:      %s' % (unl,expected,got)
</t>
<t tx="ekr.20140106135225.4203">vc = c.viewController
views = g.findNodeAnywhere(c,'@views')
if views: views.deleteAllChildren()
    # Start with a pristine @views tree.
root_before  = g.findNodeInTree(c,p,'root_before')
    # Root before: used to generate @auto-view tree.
root_restore = g.findNodeInTree(c,p,'root_restore')
    # Create root_after from root_restore.
assert root_before,root_restore
root_after  = g.findNodeInTree(c,p,'root_after')
if root_after: root_after.doDelete()
    # Root after: the results of the previous test.
c.selectPosition(root_restore)
c.copyOutline()
c.selectPosition(root_before)
c.pasteOutline()
# The roots must look like @auto nodes.
root_after = c.p
assert root_after.h == 'root_restore',root_after.h
root_before.h = '@auto root_before'
root_after.h = '@auto root_after' 
try:
    vc.init() # Required.
    vc.update_before_write_at_auto_file(root_before)
    at_organizers = vc.has_at_organizers_node(root_before)
    assert at_organizers
    vc.create_organizer_nodes(at_organizers,root_after)
    ok = vc.compare_test_trees(root_before,root_after)
    assert ok,'\n\nexpected...\n%s\ngot...\n%s' % (
        vc.trial_write(root_before),vc.trial_write(root_after))
finally:
     # Make sure the roots are *not* @auto nodes.
    root_before.h = 'root_before'
    root_after.h = 'root_after'
    c.redraw()
</t>
<t tx="ekr.20140106135225.4204">@others
</t>
<t tx="ekr.20140106135225.4213">@others
</t>
<t tx="ekr.20140106135225.4214">class aClass:
    @others
</t>
<t tx="ekr.20140106135225.4215">def before(self):
    pass
</t>
<t tx="ekr.20140106135225.4216"></t>
<t tx="ekr.20140106135225.4217">def child11(self):
    pass
</t>
<t tx="ekr.20140106135225.4218">def child12(self):
    pass
</t>
<t tx="ekr.20140106135225.4219">def after(self):
    pass
</t>
<t tx="ekr.20140106135225.4229"></t>
<t tx="ekr.20140106135225.4233"></t>
<t tx="ekr.20140106135225.4234">def child21(self):
    pass
</t>
<t tx="ekr.20140106135225.4235">def child22(self):
    pass
</t>
<t tx="ekr.20140106135225.4285">class aClass:
    @others
</t>
<t tx="ekr.20140106135225.4286">def before(self):
    pass
</t>
<t tx="ekr.20140106135225.4289">def child11(self):
    pass
</t>
<t tx="ekr.20140106135225.4290">def child12(self):
    pass
</t>
<t tx="ekr.20140106135225.4292">def child21(self):
    pass
</t>
<t tx="ekr.20140106135225.4293">def child22(self):
    pass
</t>
<t tx="ekr.20140106135225.4294">def after(self):
    pass
</t>
<t tx="ekr.20140108143431.4248">def middle():
    pass
</t>
<t tx="ekr.20140108143431.4249">def middle():
    pass
</t>
<t tx="ekr.20140109035139.4274"></t>
<t tx="ekr.20140109035139.4276">def last1():
    pass
</t>
<t tx="ekr.20140109035139.4277">def last1():
    pass
</t>
<t tx="ekr.20140109162112.4219">aList = [p.copy() for p in c.all_positions()]
aList2 = sorted(reversed(aList),key=p.sort_key)
i = 0
for p in aList2:
    p2 = aList[i]
    i += 1
    assert p == p2,'\n%s:%s\n%s:%s' % (
        p.sort_key(p),p.h,p2.sort_key(p2),p2.h)
</t>
<t tx="ekr.20140109180433.4248">def top1():
    pass
</t>
<t tx="ekr.20140109180433.4249">def top2():
    pass
</t>
<t tx="ekr.20140109180433.4253"></t>
<t tx="ekr.20140109180433.4254">def top1():
    pass
</t>
<t tx="ekr.20140109180433.4255">def top2():
    pass
</t>
<t tx="ekr.20140110044125.4362"># To remind ourselves of the status of new_import.
import leo.core.leoAtFile as atFile
print('new_import: %s' % atFile.new_auto)
</t>
<t tx="ekr.20140110141116.4267">vc = c.viewController
views = g.findNodeAnywhere(c,'@views')
if views: views.deleteAllChildren()
    # Start with a pristine @views tree.
root_before  = g.findNodeInTree(c,p,'root_before')
    # Root before: used to generate @auto-view tree.
root_restore = g.findNodeInTree(c,p,'root_restore')
    # Create root_after from root_restore.
assert root_before,root_restore
root_after  = g.findNodeInTree(c,p,'root_after')
if root_after: root_after.doDelete()
    # Root after: the results of the previous test.
c.selectPosition(root_restore)
c.copyOutline()
c.selectPosition(root_before)
c.pasteOutline()
# The roots must look like @auto nodes.
root_after = c.p
assert root_after.h == 'root_restore',root_after.h
root_before.h = '@auto root_before'
root_after.h = '@auto root_after' 
try:
    vc.update_before_write_at_auto_file(root_before)
    at_organizers = vc.has_at_organizers_node(root_before)
    assert at_organizers
    # Called by vc.create_organizer_nodes(organizers,root_after):
    root = root_after
    vc.create_organizer_data(at_organizers,root)
    vc.create_actual_organizer_nodes()
    vc.create_tree_structure(root)
    # The body of demote_organized_nodes:
    for od in vc.all_ods:
        # Called by vc.update_helper.
        od_list = vc.find_all_organizer_nodes(od)
        assert od in od_list,od_list
    d = {
        'organizer node': ['intermediate node','inner org1','inner org2'],
        'intermediate node': ['inner org1','inner org2'],
    }
    for od in vc.organizer_data_list:
        aList = d.get(od.h,[])
        aList2 = [z.h for z in od.descendants or []]
        assert sorted(aList) == sorted(aList2),(aList,aList2)
finally:
    # Make sure the roots are *not* @auto nodes.
    vc.temp_node.doDelete()
    root_before.h = 'root_before'
    root_after.h = 'root_after'
    c.redraw()
</t>
<t tx="ekr.20140110141116.4322">@others
</t>
<t tx="ekr.20140110141116.4323">class aClass:
    @others
</t>
<t tx="ekr.20140110141116.4324">def spam_before(self):
    pass
</t>
<t tx="ekr.20140110141116.4325">def spam11(self):
    pass
</t>
<t tx="ekr.20140110141116.4326">def spam12(self):
    pass
</t>
<t tx="ekr.20140110141116.4327">def middle_spam():
    pass
</t>
<t tx="ekr.20140110141116.4328">def spam21(self):
    pass
</t>
<t tx="ekr.20140110141116.4329">def spam22(self):
    pass
</t>
<t tx="ekr.20140110141116.4330">def spam_after(self):
    pass
</t>
<t tx="ekr.20140110141116.4331">def spam_last1():
    pass
</t>
<t tx="ekr.20140110141116.4332">def spam_top1():
    pass
</t>
<t tx="ekr.20140110141116.4333">def spam_top2():
    pass
</t>
<t tx="ekr.20140110141116.4351">@others
</t>
<t tx="ekr.20140110141116.4352">class aClass:
    @others
</t>
<t tx="ekr.20140110141116.4353">def spam_before(self):
    pass
</t>
<t tx="ekr.20140110141116.4354"></t>
<t tx="ekr.20140110141116.4355"></t>
<t tx="ekr.20140110141116.4356">def spam11(self):
    pass
</t>
<t tx="ekr.20140110141116.4357">def spam12(self):
    pass
</t>
<t tx="ekr.20140110141116.4358">def middle_spam():
    pass
</t>
<t tx="ekr.20140110141116.4359"></t>
<t tx="ekr.20140110141116.4360">def spam21(self):
    pass
</t>
<t tx="ekr.20140110141116.4361">def spam22(self):
    pass
</t>
<t tx="ekr.20140110141116.4362">def spam_after(self):
    pass
</t>
<t tx="ekr.20140110141116.4363"></t>
<t tx="ekr.20140110141116.4364">def spam_last1():
    pass
</t>
<t tx="ekr.20140110141116.4365"></t>
<t tx="ekr.20140110141116.4366">def spam_top1():
    pass
</t>
<t tx="ekr.20140110141116.4367">def spam_top2():
    pass
</t>
<t tx="ekr.20140110141116.4368"></t>
<t tx="ekr.20140111164124.4414">vc = c.viewController
views = g.findNodeAnywhere(c,'@views')
if views: views.deleteAllChildren()
    # Start with a pristine @views tree.
root_before  = g.findNodeInTree(c,p,'root_before')
    # Root before: used to generate @auto-view tree.
root_restore = g.findNodeInTree(c,p,'root_restore')
    # Create root_after from root_restore.
assert root_before,root_restore
root_after  = g.findNodeInTree(c,p,'root_after')
if root_after: root_after.doDelete()
    # Root after: the results of the previous test.
c.selectPosition(root_restore)
c.copyOutline()
c.selectPosition(root_before)
c.pasteOutline()
# The roots must look like @auto nodes.
root_after = c.p
assert root_after.h == 'root_restore',root_after.h
root_before.h = '@auto root_before'
root_after.h = '@auto root_after' 
try:
    vc.init() # Required.
    vc.update_before_write_at_auto_file(root_before)
    at_organizers = vc.has_at_organizers_node(root_before)
    assert at_organizers
    vc.create_organizer_nodes(at_organizers,root_after)
    ok = vc.compare_test_trees(root_before,root_after)
    assert ok,'\n\nexpected...\n%s\ngot...\n%s' % (
        vc.trial_write(root_before),vc.trial_write(root_after))
finally:
     # Make sure the roots are *not* @auto nodes.
    root_before.h = 'root_before'
    root_after.h = 'root_after'
    c.redraw()
</t>
<t tx="ekr.20140111164124.4415">@others
</t>
<t tx="ekr.20140111164124.4416">class aClass:
    @others
</t>
<t tx="ekr.20140111164124.4417">def before(self):
    pass
</t>
<t tx="ekr.20140111164124.4418">def child11(self):
    pass
</t>
<t tx="ekr.20140111164124.4419">def child12(self):
    pass
</t>
<t tx="ekr.20140111164124.4420">def middle():
    pass
</t>
<t tx="ekr.20140111164124.4421">def child21(self):
    pass
</t>
<t tx="ekr.20140111164124.4422">def child22(self):
    pass
</t>
<t tx="ekr.20140111164124.4423">def after(self):
    pass
</t>
<t tx="ekr.20140111164124.4424">def last1():
    pass
</t>
<t tx="ekr.20140111164124.4425">def top1():
    pass
</t>
<t tx="ekr.20140111164124.4426">def top2():
    pass
</t>
<t tx="ekr.20140111164124.4427">@others
</t>
<t tx="ekr.20140111164124.4428">class aClass:
    @others
</t>
<t tx="ekr.20140111164124.4429">def before(self):
    pass
</t>
<t tx="ekr.20140111164124.4430"></t>
<t tx="ekr.20140111164124.4431"></t>
<t tx="ekr.20140111164124.4432">def child11(self):
    pass
</t>
<t tx="ekr.20140111164124.4433">def child12(self):
    pass
</t>
<t tx="ekr.20140111164124.4434">def middle():
    pass
</t>
<t tx="ekr.20140111164124.4435"></t>
<t tx="ekr.20140111164124.4436">def child21(self):
    pass
</t>
<t tx="ekr.20140111164124.4437">def child22(self):
    pass
</t>
<t tx="ekr.20140111164124.4438">def after(self):
    pass
</t>
<t tx="ekr.20140111164124.4439"></t>
<t tx="ekr.20140111164124.4440">def last1():
    pass
</t>
<t tx="ekr.20140111164124.4441"></t>
<t tx="ekr.20140111164124.4442">def top1():
    pass
</t>
<t tx="ekr.20140111164124.4443">def top2():
    pass
</t>
<t tx="ekr.20140113034711.4461">def extra2():
    pass
</t>
<t tx="ekr.20140121160228.4834">@others
</t>
<t tx="ekr.20140121160228.4835">class aClass:
    @others
</t>
<t tx="ekr.20140121160228.4836">def spam_before(self):
    pass
</t>
<t tx="ekr.20140121160228.4837">def spam11(self):
    pass
</t>
<t tx="ekr.20140121160228.4838">def spam12(self):
    pass
</t>
<t tx="ekr.20140121160228.4839">def middle_spam():
    pass
</t>
<t tx="ekr.20140121160228.4840">def spam21(self):
    pass
</t>
<t tx="ekr.20140121160228.4841">def spam22(self):
    pass
</t>
<t tx="ekr.20140121160228.4842">def spam_after(self):
    pass
</t>
<t tx="ekr.20140121160228.4843">def spam_last1():
    pass
</t>
<t tx="ekr.20140121160228.4844">def spam_top1():
    pass
</t>
<t tx="ekr.20140121160228.4845">def spam_top2():
    pass
</t>
<t tx="ekr.20140211090146.4438"></t>
<t tx="ekr.20140211090146.4446">@others
</t>
<t tx="ekr.20140211090146.4447">class aClass:
    @others
</t>
<t tx="ekr.20140211090146.4448">def before():
    pass
</t>
<t tx="ekr.20140211090146.4452">def after():
    pass
</t>
<t tx="ekr.20140211090146.4459"></t>
<t tx="ekr.20140211090146.4460">def child1():
    pass
</t>
<t tx="ekr.20140211090146.4461">def extra2():
    pass
</t>
<t tx="ekr.20140211090146.4462">def child2():
    pass
</t>
<t tx="ekr.20140211090146.4494">@others
</t>
<t tx="ekr.20140211090146.4495">class aClass:
    @others
</t>
<t tx="ekr.20140211090146.4496">def before(self):
    pass
</t>
<t tx="ekr.20140211090146.4502">def after(self):
    pass
</t>
<t tx="ekr.20140211090146.4516"></t>
<t tx="ekr.20140211090146.4518"></t>
<t tx="ekr.20140211090146.4520"></t>
<t tx="ekr.20140211090146.4522"></t>
<t tx="ekr.20140211090146.4525">def middle():
    pass
</t>
<t tx="ekr.20140211090146.4526">def child11(self):
    pass
</t>
<t tx="ekr.20140211090146.4527">def child12(self):
    pass
</t>
<t tx="ekr.20140211090146.4528">def child21(self):
    pass
</t>
<t tx="ekr.20140211090146.4529">def child22(self):
    pass
</t>
<t tx="ekr.20140211090146.4530">def last1():
    pass
</t>
<t tx="ekr.20140211090146.4545">@others
</t>
<t tx="ekr.20140211090146.4546">class aClass:
    @others
</t>
<t tx="ekr.20140211090146.4547">def before(self):
    pass
</t>
<t tx="ekr.20140211090146.4553">def after(self):
    pass
</t>
<t tx="ekr.20140211090146.4567"></t>
<t tx="ekr.20140211090146.4569"></t>
<t tx="ekr.20140211090146.4571"></t>
<t tx="ekr.20140211090146.4573"></t>
<t tx="ekr.20140211090146.4576">def middle():
    pass
</t>
<t tx="ekr.20140211090146.4577">def child11(self):
    pass
</t>
<t tx="ekr.20140211090146.4578">def child12(self):
    pass
</t>
<t tx="ekr.20140211090146.4579">def child21(self):
    pass
</t>
<t tx="ekr.20140211090146.4580">def child22(self):
    pass
</t>
<t tx="ekr.20140211090146.4581">def last1():
    pass
</t>
<t tx="ekr.20140906072925.5224"></t>
<t tx="ekr.20150214063940.11"></t>
<t tx="ekr.20150529183247.1">import leo.core.leoBeautify as leoBeautify
for p in p.children():
    b = leoBeautify.PythonTokenBeautifier(c)
    s1 = p.b
    comment,s = b.comment_leo_lines(p)
    s2 = b.uncomment_leo_lines(comment,p,s)
    assert s1 == s2,('\ns...\n%s\ns2...\n%s' % (s,s2))
</t>
<t tx="ekr.20150529183259.1">def f ():
    pass
@ Line 1
    Line 2
</t>
<t tx="ekr.20150529184545.1">def f(): 
    pass
@ The following could be added to the 'else' clause::
    # Accumulate everything else.
</t>
<t tx="ekr.20190113114613.10"></t>
<t tx="ekr.20190113114613.100">node 2 line 1 changed
node 2 line 2 changed
</t>
<t tx="ekr.20190113114613.101"></t>
<t tx="ekr.20190113114613.102">@others
</t>
<t tx="ekr.20190113114613.103">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20190113114613.104">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.105">@others
</t>
<t tx="ekr.20190113114613.106">node 1 line 1
node 1 line 2 changed
</t>
<t tx="ekr.20190113114613.107">node 2 line 1 changed
node 2 line 2 changed
</t>
<t tx="ekr.20190113114613.108"></t>
<t tx="ekr.20190113114613.109">@others
</t>
<t tx="ekr.20190113114613.11">@others
</t>
<t tx="ekr.20190113114613.110">node 1 line 1
node 1 line 2
node 1 line 3
</t>
<t tx="ekr.20190113114613.111">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.112">@others
</t>
<t tx="ekr.20190113114613.113">node 1 line 1
</t>
<t tx="ekr.20190113114613.114">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.115"></t>
<t tx="ekr.20190113114613.116">@others
</t>
<t tx="ekr.20190113114613.117">node 1 line 1
</t>
<t tx="ekr.20190113114613.118">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20190113114613.119">@others
</t>
<t tx="ekr.20190113114613.12">node 1 line 1
node 1 old line 1
node 1 old line 2
node 1 old line 3
node 1 old line 4
node 1 line 2
</t>
<t tx="ekr.20190113114613.120">node 1 line 1
</t>
<t tx="ekr.20190113114613.121">node 2 line 3
</t>
<t tx="ekr.20190113114613.122"></t>
<t tx="ekr.20190113114613.123">@others
</t>
<t tx="ekr.20190113114613.124">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3
</t>
<t tx="ekr.20190113114613.125">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20190113114613.126">@others
</t>
<t tx="ekr.20190113114613.127">node 1 line 1
line 1 line 3
</t>
<t tx="ekr.20190113114613.128">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20190113114613.129"></t>
<t tx="ekr.20190113114613.13">@others
</t>
<t tx="ekr.20190113114613.130">@others
</t>
<t tx="ekr.20190113114613.131">node 1 line 1
</t>
<t tx="ekr.20190113114613.132">@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
node 2 line 2
</t>
<t tx="ekr.20190113114613.133">@others
</t>
<t tx="ekr.20190113114613.134">node 1 line 1
</t>
<t tx="ekr.20190113114613.135">node 2 line 2
</t>
<t tx="ekr.20190113114613.136"></t>
<t tx="ekr.20190113114613.137">@others
</t>
<t tx="ekr.20190113114613.138">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3
</t>
<t tx="ekr.20190113114613.139">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20190113114613.14">node 1 line 1
node 1 new line 1
node 1 new line 2
node 1 line 2
</t>
<t tx="ekr.20190113114613.140">@others
</t>
<t tx="ekr.20190113114613.141">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
line 1 line 3
</t>
<t tx="ekr.20190113114613.142">node 2 line 1
node 2 line 2
node 2 line 3
</t>
<t tx="ekr.20190113114613.143"></t>
<t tx="ekr.20190113114613.144">@others
</t>
<t tx="ekr.20190113114613.145">node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
#@ should be handled by verbatim
</t>
<t tx="ekr.20190113114613.146">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.147">@others
</t>
<t tx="ekr.20190113114613.148">node 1 line 1
</t>
<t tx="ekr.20190113114613.149">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.15"></t>
<t tx="ekr.20190113114613.150"># This fails because the @all read logic inserts a second verbatim, I think.
</t>
<t tx="ekr.20190113114613.151">@others
</t>
<t tx="ekr.20190113114613.152">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20190113114613.153">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.154">@others
</t>
<t tx="ekr.20190113114613.155">node 1 line 1
@verbatim
#@ should be handled by verbatim
node 1 line 2
</t>
<t tx="ekr.20190113114613.156">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.157"></t>
<t tx="ekr.20190113114613.158">line
</t>
<t tx="ekr.20190113114613.159">line
</t>
<t tx="ekr.20190113114613.16">line 1
line 2
line 3
</t>
<t tx="ekr.20190113114613.160"># This test, if run at all, should be run elsewhere:
# Actually importing plugins affects other unit tests.

import glob
import inspect
import unittest

changed = c.isChanged() ; p1 = c.p
&lt;&lt; class testRoutineTestCase &gt;&gt;
@others

plugins = getAllPlugins()

# g.printList(plugins)

print('@suite run all plugin test routines')

if 1:
    g.app.unitTestDict["fail"] = False
    suite = unittest.makeSuite(unittest.TestCase)
    for plugin in plugins:
        n = addTestRoutinesInPluginToSuite(c,g,plugin,suite)
        if n:
            plural = g.choose(n==1,'','s')
            s = 'found %2d test routine%s for %s' % (n,plural,plugin)
            g.es_print(s)
    # if 1: # For @suite nodes.  Better for unit testing.
        # g.app.scriptDict['suite'] = suite
    # else: # For script button nodes.  Good for testing.
        # # Verbosity: 1: print just dots.
        # unittest.TextTestRunner(verbosity=1).run(suite)
        # c.setChanged(changed) # Restore changed state.
        # c.selectVnode(p1) # N.B. Restore the selected node.
</t>
<t tx="ekr.20190113114613.161">class testRoutineTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
</t>
<t tx="ekr.20190113114613.162">def __init__ (self,c,g,moduleName,theClass,f,code,verbose=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.moduleName = moduleName
    self.theClass = theClass
    self.f = f
    self.g = g
    self.code = code
    self.p = c.p.copy()
    self.verbose = verbose
</t>
<t tx="ekr.20190113114613.163">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)
</t>
<t tx="ekr.20190113114613.164">def runTest (self):

    f = self.f ; name = f.__name__ ; theClass = self.theClass

    d = {'c':self.c,'g':self.g,'p':self.p}

    if 1: # Use dead text to ensure a clean environment.
        # The present code assumes all leading whitespace is consistent.
        code = removeLeadingWs(self.code)
        # The code is a def statement.  We concoct a call to the function or method.
        if theClass:
            s = '%s\n%s(self=None)\n' % (code,name)
        else:
            s = '%s\n%s()\n' % (code,name)

        if self.verbose:
            g.trace('executing...\n\n%s' % s)

        exec(s,d) # Execute s in a environment containing c, g and p.

    else: # Use live objects.
        if theClass:
            # Create a subclass of f's original class.
            class __dummyClass(theClass):
                # Create a ctor with a known signature.
                def __init__(self): pass
            # Make f a method of the dummyClass with name 'f'.
            # N.B. f is still a method of theClass, and must be called as such!
            if 0: # Override the method with f's actual name.
                g.funcToMethod(f,__dummyClass,name)
                obj = __dummyClass()
                f = getattr(obj,name)
                f(obj)
            else:
                # Use the name 'f' for f's name.
                g.funcToMethod(f,__dummyClass,'f')
                # Create an instance of __dummyClass and call it's f method.
                obj = __dummyClass()
                obj.f()
        else: # Execute a plain function.
            f(**keys)
</t>
<t tx="ekr.20190113114613.165">def shortDescription (self):

    return 'test function',repr(self.f)
</t>
<t tx="ekr.20190113114613.166">def addTestRoutinesInPluginToSuite (c,g,pluginName,suite):

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))

    plugin = g.importFromPath(pluginName,path,verbose=True)
    if not plugin:
        return len([])

    tests = findTestsInModule(plugin,pluginName)

    for test in tests:
        theClass,f = test
        code = inspect.getsource(f)
        testCase = testRoutineTestCase(c,g,pluginName,theClass,f,code,verbose=False)
        suite.addTest(testCase)

    return len(tests)
</t>
<t tx="ekr.20190113114613.167">def findTestsInModule (module,moduleName):

    # g.trace(moduleName)

    toString = g.listToString
    try:
        functions = inspect.getmembers(module,inspect.isfunction)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isfunction) for %s' % moduleName)
        functions = []
    try:
        classes = inspect.getmembers(module,inspect.isclass)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isclass) for %s' % moduleName)
        classes = []

    # Ignore subclasses of TestCase.
    classes = [theClass for className,theClass in classes
        if not issubclass(theClass,unittest.TestCase)]

    allMethods = []
    for theClass in classes:
        try:
            methods = inspect.getmembers(theClass,inspect.ismethod)
        except Exception:
            # This looks like a bug in inspect: The zodb classes have no methods.
            # g.trace('Exception in inspect.getmembers(theClass,inspect.ismethod) for %s' % moduleName)
            methods = []
        # print('\nmethods of class %s...\n\n%s' % (theClass,toString(methods)))
        methods = [(theClass,f) for name,f in methods if name.startswith('test_')]
        allMethods.extend(methods)

    # Hack: remove duplicate tests from leoGlobals.py.
    functions = [(None,f) for name,f in functions
        if name.startswith('test_') and not name.startswith('test_g_')]
    if 0:
        &lt;&lt; print classes, methods &amp; functions &gt;&gt;
    result = functions
    result.extend(allMethods)
    return result
</t>
<t tx="ekr.20190113114613.168">print('=' * 40)

if classes:
    print('classes in %s...\n%s' % (moduleName,toString(classes)))
else:
    print('no classes in %s' % (moduleName))
if allMethods:
    print('test methods in %s...\n%s'   % (moduleName,toString(allMethods)))
else:
    print('no test methods in %s' % (moduleName))
if functions:
    print('test functions in %s...\n%s' % (moduleName,toString(functions)))
else:
    print('no test functions in %s' % (moduleName))
</t>
<t tx="ekr.20190113114613.169">def removeLeadingWs (code):

    if not code.strip():
        return ''
    lines = g.splitLines(code)
    line = lines[0]
    i = g.skip_ws(line,0)
    ws = line[0:i]
    if not ws:
        return code
    result = [] ; n = len(ws)
    for line in lines:
        if line.startswith(ws):
            result.append(line[n:])
        elif not line.strip() and line.endswith('\n'):
            result.append('\n')
        else:
            print('unitTest.leo:underindented line:%s' % repr(line))
            result.append(line)
    result = ''.join(result)
    return result
</t>
<t tx="ekr.20190113114613.17">line 1
line 2 changed
line 3
</t>
<t tx="ekr.20190113114613.170">x = c.shadowController

lines1 = ('a','b','c')
lines2 = ('a','x','c')

x.show_error(
    lines1,lines2,
    message = "Test of x.show_error",
    lines1_message = "lines1",
    lines2_message = "lines2")
</t>
<t tx="ekr.20190113114613.171">c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20190113114613.172">Line 1

@last last line 1: no newline
</t>
<t tx="ekr.20190113114613.173">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@nonl
#@-node:#@file
#@-leo
last line 1: no newline
</t>
<t tx="ekr.20190113114613.174">c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20190113114613.175">Line 1

@last last line 1: newline
</t>
<t tx="ekr.20190113114613.176">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@-node:#@file
#@-leo
last line 1: newline
</t>
<t tx="ekr.20190113114613.177">c.testManager.runAtFileTest(p)
</t>
<t tx="ekr.20190113114613.178">Line 1

@last last line 1: two trailing newlines
</t>
<t tx="ekr.20190113114613.179">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@-node:#@file
#@-leo
last line 1: two trailing newlines
</t>
<t tx="ekr.20190113114613.18"></t>
<t tx="ekr.20190113114613.180">h = '@file ../test/unittest/at-file-test.py'
p = g.findNodeAnywhere(c,h)
assert p
assert not p.isDirty(),p.h # Do not ignore this failure!

table = (
    (p.firstChild(),'spam'),
    (p.firstChild().next(),'eggs')
)

for p2,h2 in table:
    assert p2.h == h2
    assert len(p2.b) &gt; 10
</t>
<t tx="ekr.20190113114613.181"># Not valid for external tests: uses @&lt;file&gt; node.
if not g.app.isExternalUnitTest:

    h = '@shadow ../test/unittest/at-shadow-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert len(p2.h) == len(h2)
</t>
<t tx="ekr.20190113114613.182">import time

c.frame.body.addEditor()

time.sleep(0.5)

c.frame.body.deleteEditor()

time.sleep(0.5)
</t>
<t tx="ekr.20190113114613.183">import sys

if sys.platform.lower().startswith('win'):


    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','AdminPermission.java'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=s,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20190113114613.184">self.skipTest('at.deleteUnvisitedNodes not used')

def clone (p,parent,n):
    p2 = p.clone()
    p2.moveToNthChildOf(parent,n)
    return p2

def make (parent,n,h):
    child = parent.insertAsNthChild(n)
    child.h = h
    return child

def delete_r():
    '''Delete all 'Resurrected Nodes' nodes.'''
    while True:
        r = g.findNodeAnywhere(c,'Resurrected Nodes')
        if r: r.doDelete(newNode=p)
        else: break

def delete_children():
    # Delete all children of p.
    while p.hasChildren():
        p.firstChild().doDelete(newNode=p)

def test(p,h,tag):
    assert p,'p'
    assert p.h == 'From root','p.h %s' % tag
    assert p.numberOfChildren() == 1,'number of children %s' % tag
    assert p.firstChild().h == h,'child.h %s' % tag

delete_r()
delete_children()

# Create some children.
root = make(p,0,'root')
child1 = make(root,0,'child1')
child2 = make(root,1,'child2')
child3 = make(root,2,'child3')
child11 = make(child1,0,'child11')
child21 = make(child2,0,'child21')
child31 = make(child3,0,'child31')
# Create some clones.
if 0:
    child4 = clone(child31,root,3)
# Set all bits except for child2 &amp; child31.
for z in root.self_and_subtree():
    z.setVisited()
for z in child2,child31: # These should be moved.
    z.clearVisited()
if 1:
    c.atFileCommands.deleteUnvisitedNodes(root)
    c.redraw()
if 1:
    r = g.findNodeAnywhere(c,'Resurrected Nodes')
    assert r,'r'
    r1 = r.firstChild()
    r2 = r1.next()
    # r3 = r2.next()
    test(r1,'child31','r1')
    test(r2,'child2','r2')
    # assert root.numberOfChildren() == 3,'root.n'
if 1:
    delete_r()
if 1:
    delete_children()
c.redraw()
</t>
<t tx="ekr.20190113114613.185">at = c.atFileCommands

# A mininimal test.

at.startSentinelComment = '&lt;!--'
at.endSentinelComment = '--&gt;'

s1 = '&lt;!--\nline 2.\n--&gt;\n'
s2 = at.massageAtDocPart(s1)

assert s2 == 'line 2.\n',repr(s2)
</t>
<t tx="ekr.20190113114613.186">### This method no longer exists.
at = c.atFileCommands
x = c.shadowController
filename = x.pathName('xyzzy')
assert not g.os_path_exists(filename)
try:
    kind,theFile = at.openForWrite(filename)
    assert kind == 'check'
    if theFile: theFile.close()
finally:
    if g.os_path_exists(filename):
        x.unlink(filename)
        assert not g.os_path_exists(filename)
</t>
<t tx="ekr.20190113114613.187">import os
at = c.atFileCommands
exists = g.os_path_exists
path = g.os_path_join(g.app.testDir,'xyzzy')
path2 = g.os_path_join(g.app.testDir,'xyzzy2')
# Create both paths.
for p in (path,path2):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = open(p,'w')
    f.write('test %s' % p)
    f.close()
    assert exists(p)
assert at.rename(path,path2,verbose=True)
assert exists(path2)
f = open(path2)
s = f.read()
f.close()
assert s == 'test %s' % path
os.remove(path2)
assert not exists(path)
</t>
<t tx="ekr.20190113114613.188">@first # -*- coding: utf-8 -*-

at = c.atFileCommands
at.errors = 0

if g.isPython3:
    # Do not call g.ue: it will crash.
    s = 'La Pea'
else:
    s = g.ue('La Pea','utf-8')

at.printError('test of at.printError:',s)

# important: this test will fail if sitecustomize.py
# does not contain sys.setdefaultencoding('utf-8')
</t>
<t tx="ekr.20190113114613.189"># Test that changing c.frame.body.bodyCtrl also changes c.frame.body.wrapper.
if 0:
    # A very dangerous test.
    # A failure here will destroy all following tests!
    # Furthermore, it is not needed.  bodyCtrl exists nowhere in Leo.
    body = c.frame.body
    old_w = body.wrapper
    try:
        assert old_w is not None
        body.bodyCtrl = None
        assert body.wrapper is None
    finally:
        body.wrapper = old_w
    assert hasattr(c.frame.body,'bodyCtrl')
    assert hasattr(c.frame.log,'logCtrl')
</t>
<t tx="ekr.20190113114613.19">line 1
line 2
line 3
</t>
<t tx="ekr.20190113114613.190">import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(
        g.app.loadDir,'..','test','big-c#-test.c#'))
    f = open(fileName)
    s = f.read()
    f.close()
    c.importCommands.cSharpUnitTest(p,s=s,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20190113114613.191">result = c.checkAllPythonCode(unittest=True,ignoreAtIgnore=True)

assert result=="ok", "checkPythonCode returns: %s" % result
</t>
<t tx="ekr.20190113114613.192"># Disabled because modifying errorTest.py creates annoying bzr conflicts.

import os

path = g.os_path_finalize_join(g.app.testDir,'unittest','errorTest.py')
assert g.os_path_exists(path),path
timeStamp = c.timeStampDict.get(path)
val = c.checkFileTimeStamp(path)
assert val == True

f = open(path)
s = f.read()
lines = g.splitLines(s)
result = [] ; found = False
tag = '# timestamp:'
for line in lines:
    if line.startswith(tag):
        timeStamp = os.path.getmtime(path)
        result.append('%s %s\n' % (tag,timeStamp))
        found = True
    else:
        result.append(line)
f.close()

assert found,' no line starts with "%s"' % tag

f = open(path,'w')
f.write(''.join(result))
f.close()

timeStamp2 = os.path.getmtime(path)
assert timeStamp != timeStamp2
val = c.checkFileTimeStamp(path)
assert not val,repr(val)
c.setFileTimeStamp(path)
val = c.checkFileTimeStamp(path)
assert val,repr(val)
</t>
<t tx="ekr.20190113114613.193">arg = ''
arg0 = 'one'
fn = '&lt;fn&gt;'
filename = '' # g.os.path.basename(arg)
vtuple = [arg0,fn]

table = (
    #('os.system',       'os.system(%s)' % (arg+fn)),
    #('os.startfile',    'os.startfile(%s)' % (arg+fn)),
    #('exec',            'exec(%s)' % (arg+fn)),
    #('os.spawnl',       'os.spawnl(%s,%s,%s)' % (arg,filename,fn)),
    #('os.spawnv',       'os.spawnv(%s,%s)' % (arg0,vtuple)),
    ('subprocess.Popen','subprocess.Popen(%s)' % vtuple),
    ('huh?',            'bad command:'+'huh?'),
)

for openType,result in table:
    if openType in ('os.spawnv','subprocess.Popen'):
        arg2 = ['one']
    else:
        arg2 = None
    result2 = c.openTempFileInExternalEditor(
        arg2,fn,openType,testing=True)
    assert result==result2,'expected %s, got %s' % (
        repr(result),repr(result2))
</t>
<t tx="ekr.20190113114613.194">import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','constants.java'))

    f = open(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=None,fileName=fileName,showTree=False)
</t>
<t tx="ekr.20190113114613.195"># This causes trouble if executed quickly after the add-editor command.
# Presumably this is a timing condition that will never happen in practice.

if 0:
    c.frame.body.deleteEditor()
</t>
<t tx="ekr.20190113114613.196">import leo.plugins.detect_urls as detect_urls

# print(c.frame.body.wrapper)
w = c.frame.body.wrapper
s = w.getAllText()

# s will be empty when running unit tests dynamically.
if s:
    if s.endswith('\n'): s = s[:-1]
    w.setInsertPoint(len(s))
    url = detect_urls.openURL(tag='test',keywords={'c':c})
    assert url == 'http://webpages.charter.net/edreamleo/front.html','Got:%s' % repr(url)
    
@ The last line is the url
http://webpages.charter.net/edreamleo/front.html
</t>
<t tx="ekr.20190113114613.197">efc = g.app.externalFilesController
d = {'ext':'.py',}
fn = efc.create_temp_file(c,d,p)
assert g.os_path_exists(fn),fn
efc.shut_down()
assert not g.os_path_exists(fn),fn
</t>
<t tx="ekr.20190113114613.198"># More suitable as a hand test:
# it makes no effort to delete the 'Recovered Nodes' node.

c.nodeConflictList = []

for i in range(2):
    c.nodeConflictList.append(g.bunch(
        tag='(uncached)',
        gnx='gnx %s' % (i),
        fileName ='filename %s' % (i),
        b_old='old body %s' % (i),
        b_new='new body %s' % (i),
        h_old='head %s' % (i),
        h_new='head %s' % (i),
    ))

c.fileCommands.handleNodeConflicts()

c.nodeConflictList = []

c.redraw()
</t>
<t tx="ekr.20190113114613.199">@pagewidth 80
    # Required for external unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20190113114613.2">###@nosearch</t>
<t tx="ekr.20190113114613.20">line 1 changed
line 2
line 3
</t>
<t tx="ekr.20190113114613.200">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20190113114613.201">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms,
2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes.
Potentially deadly
weather impacts every American.
Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20190113114613.202">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20190113114613.203">@pagewidth 80
    # Required for external unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20190113114613.204">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20190113114613.205">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms,
2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes.
Potentially deadly
weather impacts every American.
Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20190113114613.206">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20190113114613.207">import leo.core.leoEditCommands as leoEditCommands
s = 'foo' ; wrapper = c.frame.body.wrapper
c.searchCommands.openFindTab()
h = c.searchCommands.findTabHandler
w = h.find_ctrl
w.setAllText(s)
c.bodyWantsFocus()
wrapper.setInsertPoint(0)
c.searchCommands.findTabFindNext()
w = c.get_focus()
wName = g.app.gui.widget_name(w)
assert 'body' in wName, 'focus: %s = %s, expected %s = %s' % (
    w,wName,wrapper,g.app.gui.widget_name(wrapper))
</t>
<t tx="ekr.20190113114613.208"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-rst unittest/at-auto-rst-line-number-test.txt'
        # This must not be a python file
    root = g.findNodeAnywhere(c, h)
    assert root
    assert root.isAtAutoRstNode(), root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print('get_external_file_with_sentinels returns...')
        # print(''.join(['%3s %r' % (i, s) for i, s in enumerate(g.splitLines(s))]))
        g.printList(g.splitLines(s))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 9, n
            break
</t>
<t tx="ekr.20190113114613.209">#if this starts failing due to much refacting in unitTest.leo,
# adjust accordingly

# These seem to fail if various nodes are cloned.
import random,fnmatch

all_h = [z.copy().h for z in c.find_h('.')]

assert len(all_h) &gt; 1000,'fail 1'

sample = random.sample(all_h, 20)    

# Test that all nodes are found at least once.
for h in sample:
    pat = fnmatch.translate(h)
    pl = c.find_h(pat)
    assert len(pl) &gt; 0 and len(pl) &lt; len(all_h),'fail 2'

tests = c.find_h('@test(.*)')

bm = tests.filter_b('(.*)all_positions')
forloops = 0
for node in bm:   
    # many of these are for loops
    for m in node.matchiter:
        if 'for' in m.group(1):
            forloops += 1

assert forloops &gt; 10,'fail for'

# all of these should also be found by find_b
all_bm = c.find_b('(.*)all_positions')
assert len(all_bm) &gt;= len(bm),'fail len'

assert set(el.h for el in bm).issubset(set(el.h for el in all_bm)),'fail set'

itertest = c.find_h('@test p.iters and v.iters')
assert len(itertest) &gt;= 1,'fail 3'
tn = itertest[0]
assert tn.h == '@test p.iters and v.iters','fail h'
assert len(itertest.filter_b('notfound, really')) == 0,'fail 4'
assert len(itertest.filter_b('leoNodes')) == 1,'fail 5'
chi = itertest.children().filter_h('child?')
assert chi[0].h == 'child1','fail 6'
assert chi[1].h == 'child2','fail 7'
# twice, in clones
chi_b = chi.children().filter_h('a').children().filter_h('b')

if 0:
    assert len(chi_b) == 2,'fail len 2: %s: %s' % (chi_b,len(chi_b))
    assert chi_b[0].h == chi_b[1].h == 'b'
    chi_e = chi.children().filter_h('d').children().filter_h('e')
    assert len(chi_e) == 1,'fail 8'
    assert chi_e[0].h == 'e','fail 9'

</t>
<t tx="ekr.20190113114613.21"></t>
<t tx="ekr.20190113114613.210"># This tests is valid only if not g.new_config.

sd = g.app.config.localShortcutsDict
d = sd.get(c.hash(),{})
try:
    sd[c.hash()] = {}
    key,aList = c.config.getShortcut('new')
    # print(key,aList)
    assert aList,'key: %s' % (key)
finally:
    sd[c.hash()] = d
</t>
<t tx="ekr.20190113114613.211">if c.config.redirect_execute_script_output_to_log_pane:
    pass # Test doesn't work when redirection is on.
else:
    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) &gt; -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) &gt; -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20190113114613.212">@first # -*- coding: utf-8 -*-

# g.reportBadChars no longer exists.

table = (
    ('ab',                    'ascii'),
    (g.ue('ab','utf-8'),      'ascii'),
    ('',                       'ascii'),
    (g.ue('','utf-8'),         'ascii'),
    ('ab',                     'utf-8'),
    (g.ue('ab','utf-8'),       'utf-8'),
    ('',                       'utf-8'),
    (g.ue('','utf-8'),         'utf-8'),
)
for s,encoding in table:
    g.reportBadChars(s,encoding)
</t>
<t tx="ekr.20190113114613.213"># A good test, but we don't want this large a file included in the distro.

# fn = r'c:\recent\data4.html'
fn = r'c:\recent\data.html'

root = p.copy()

# Fails with more tags: a newline gets inserted between tags.

html_tags = ('body','head','html','table','xxx',)
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)
try:
    c.importCommands.importFilesCommand(files=[fn],treeType='@file')
finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete()
        c.redraw()
    assert not root.hasChildren()
fail = g.app.unitTestDict.get('fail')
assert not fail
</t>
<t tx="ekr.20190113114613.214"># Disabled: this now fails *regardless* of python.v2 switch

ic = c.importCommands

def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

fn = g.os_path_finalize_join(g.app.loadDir,'..','test','unittest','at-auto-section-ref-test.py')
# fn = r'c:\Users\edreamleo\at-auto-test.py'
assert g.os_path_exists(fn),fn

try:
    setup(p)
    child = p.insertAsNthChild(0)
    child.h = 'child'
    assert child

    ic.errors = 0
    ic.createOutline (fn,parent=child,s=None,ext=None)
    assert ic.errors == 0
finally:
    setup(p)
    c.redraw(p)
</t>
<t tx="ekr.20190113114613.215">tm = c.testManager
before   = g.findNodeInTree(c,p,'before')
expected = g.findNodeInTree(c,p,'expected')
assert before,expected
try:
    c.selectPosition(before)
    before.h = 'expected' # To make the compare work.
    c.importCommands.parse_body(before)
    # compare tree.
    assert tm.compareOutlines(before,expected,compareHeadlines=True,tag='',report=True)
    c.undoer.undo()
finally:
    before.h = 'before'
    c.redraw()
</t>
<t tx="ekr.20190113114613.216">class aClass:
    def __init__(self):
        pass
    def spam(self):
        pass
bClass = aClass
</t>
<t tx="ekr.20190113114613.217">@others
</t>
<t tx="ekr.20190113114613.218">class aClass:
    @others
</t>
<t tx="ekr.20190113114613.219">def __init__(self):
    pass
</t>
<t tx="ekr.20190113114613.22">line 1
line 2
line 3
</t>
<t tx="ekr.20190113114613.220">def spam(self):
    pass
</t>
<t tx="ekr.20190113114613.221">bClass = aClass
</t>
<t tx="ekr.20190113114613.222">@others
bClass = aClass
</t>
<t tx="ekr.20190113114613.223">class aClass:
    @others
</t>
<t tx="ekr.20190113114613.224">def __init__(self):
    pass
</t>
<t tx="ekr.20190113114613.225">def spam(self):
    pass
</t>
<t tx="ekr.20190113114613.226">tm = c.testManager
before   = g.findNodeInTree(c,p,'before')
expected = g.findNodeInTree(c,p,'expected')
assert before,expected
try:
    c.selectPosition(before)
    before.h = 'expected' # To make the compare work.
    c.importCommands.parse_body(before)
    # compare tree.
    assert tm.compareOutlines(before,expected,compareHeadlines=True,tag='',report=True)
    c.undoer.undo()
finally:
    before.h = 'before'
    c.redraw()
</t>
<t tx="ekr.20190113114613.227">class TypeJoinVisitor(TypeVisitor[Type]):
    """Implementation of the least upper bound algorithm.

    Attributes:
      s: The other (left) type operand.
    """

    def __init__(self, s: Type) -&gt; None:
        self.s = s

    def visit_unbound_type(self, t: UnboundType) -&gt; Type:
        if isinstance(self.s, Void) or isinstance(self.s, ErrorType):
            return ErrorType()
        else:
            return AnyType()

    def visit_union_type(self, t: UnionType) -&gt; Type:
        if is_subtype(self.s, t):
            return t
        else:
            return UnionType(t.items + [self.s])

    def visit_error_type(self, t: ErrorType) -&gt; Type:
        return t

    def visit_type_list(self, t: TypeList) -&gt; Type:
        assert False, 'Not supported'

    def visit_any(self, t: AnyType) -&gt; Type:
        return t

    def visit_void(self, t: Void) -&gt; Type:
        if isinstance(self.s, Void):
            return t
        else:
            return ErrorType()

    def visit_none_type(self, t: NoneTyp) -&gt; Type:
        if not isinstance(self.s, Void):
            return self.s
        else:
            return self.default(self.s)

    def visit_erased_type(self, t: ErasedType) -&gt; Type:
        return self.s

    def visit_type_var(self, t: TypeVarType) -&gt; Type:
        if isinstance(self.s, TypeVarType) and (cast(TypeVarType, self.s)).id == t.id:
            return self.s
        else:
            return self.default(self.s)

    def visit_instance(self, t: Instance) -&gt; Type:
        if isinstance(self.s, Instance):
            return join_instances(t, cast(Instance, self.s))
        elif isinstance(self.s, FunctionLike):
            return join_types(t, self.s.fallback)
        else:
            return self.default(self.s)

    def visit_callable_type(self, t: CallableType) -&gt; Type:
        # TODO: Consider subtyping instead of just similarity.
        if isinstance(self.s, CallableType) and is_similar_callables(
                t, cast(CallableType, self.s)):
            return combine_similar_callables(t, cast(CallableType, self.s))
        elif isinstance(self.s, Overloaded):
            # Switch the order of arguments to that we'll get to visit_overloaded.
            return join_types(t, self.s)
        else:
            return join_types(t.fallback, self.s)

    def visit_overloaded(self, t: Overloaded) -&gt; Type:
        # This is more complex than most other cases. Here are some
        # examples that illustrate how this works.
        #
        # First let's define a concise notation:
        #  - Cn are callable types (for n in 1, 2, ...)
        #  - Ov(C1, C2, ...) is an overloaded type with items C1, C2, ...
        #  - Callable[[T, ...], S] is written as [T, ...] -&gt; S.
        #
        # We want some basic properties to hold (assume Cn are all
        # unrelated via Any-similarity):
        #
        #   join(Ov(C1, C2), C1) == C1
        #   join(Ov(C1, C2), Ov(C1, C2)) == Ov(C1, C2)
        #   join(Ov(C1, C2), Ov(C1, C3)) == C1
        #   join(Ov(C2, C2), C3) == join of fallback types
        #
        # The presence of Any types makes things more interesting. The join is the
        # most general type we can get with respect to Any:
        #
        #   join(Ov([int] -&gt; int, [str] -&gt; str), [Any] -&gt; str) == Any -&gt; str
        #
        # We could use a simplification step that removes redundancies, but that's not
        # implemented right now. Consider this example, where we get a redundancy:
        #
        #   join(Ov([int, Any] -&gt; Any, [str, Any] -&gt; Any), [Any, int] -&gt; Any) ==
        #       Ov([Any, int] -&gt; Any, [Any, int] -&gt; Any)
        #
        # TODO: Use callable subtyping instead of just similarity.
        result = []  # type: List[CallableType]
        s = self.s
        if isinstance(s, FunctionLike):
            # The interesting case where both types are function types.
            for t_item in t.items():
                for s_item in s.items():
                    if is_similar_callables(t_item, s_item):
                        result.append(combine_similar_callables(t_item, s_item))
            if result:
                # TODO: Simplify redundancies from the result.
                if len(result) == 1:
                    return result[0]
                else:
                    return Overloaded(result)
            return join_types(t.fallback, s.fallback)
        return join_types(t.fallback, s)

    def visit_tuple_type(self, t: TupleType) -&gt; Type:
        if (isinstance(self.s, TupleType) and
                cast(TupleType, self.s).length() == t.length()):
            items = []  # type: List[Type]
            for i in range(t.length()):
                items.append(self.join(t.items[i],
                                       (cast(TupleType, self.s)).items[i]))
            # TODO: What if the fallback types are different?
            return TupleType(items, t.fallback)
        else:
            return self.default(self.s)

    def join(self, s: Type, t: Type) -&gt; Type:
        return join_types(s, t)

    def default(self, typ: Type) -&gt; Type:
        if isinstance(typ, Instance):
            return object_from_instance(typ)
        elif isinstance(typ, UnboundType):
            return AnyType()
        elif isinstance(typ, Void) or isinstance(typ, ErrorType):
            return ErrorType()
        elif isinstance(typ, TupleType):
            return self.default(typ.fallback)
        elif isinstance(typ, FunctionLike):
            return self.default(typ.fallback)
        elif isinstance(typ, TypeVarType):
            return self.default(typ.upper_bound)
        else:
            return AnyType()
</t>
<t tx="ekr.20190113114613.228">@others
</t>
<t tx="ekr.20190113114613.229">class TypeJoinVisitor(TypeVisitor[Type]):
    """Implementation of the least upper bound algorithm.

    Attributes:
      s: The other (left) type operand.
    """

    def __init__(self, s: Type) -&gt; None:
        self.s = s

    def visit_unbound_type(self, t: UnboundType) -&gt; Type:
        if isinstance(self.s, Void) or isinstance(self.s, ErrorType):
            return ErrorType()
        else:
            return AnyType()

    def visit_union_type(self, t: UnionType) -&gt; Type:
        if is_subtype(self.s, t):
            return t
        else:
            return UnionType(t.items + [self.s])

    def visit_error_type(self, t: ErrorType) -&gt; Type:
        return t

    def visit_type_list(self, t: TypeList) -&gt; Type:
        assert False, 'Not supported'

    def visit_any(self, t: AnyType) -&gt; Type:
        return t

    def visit_void(self, t: Void) -&gt; Type:
        if isinstance(self.s, Void):
            return t
        else:
            return ErrorType()

    def visit_none_type(self, t: NoneTyp) -&gt; Type:
        if not isinstance(self.s, Void):
            return self.s
        else:
            return self.default(self.s)

    def visit_erased_type(self, t: ErasedType) -&gt; Type:
        return self.s

    def visit_type_var(self, t: TypeVarType) -&gt; Type:
        if isinstance(self.s, TypeVarType) and (cast(TypeVarType, self.s)).id == t.id:
            return self.s
        else:
            return self.default(self.s)

    def visit_instance(self, t: Instance) -&gt; Type:
        if isinstance(self.s, Instance):
            return join_instances(t, cast(Instance, self.s))
        elif isinstance(self.s, FunctionLike):
            return join_types(t, self.s.fallback)
        else:
            return self.default(self.s)

    def visit_callable_type(self, t: CallableType) -&gt; Type:
        # TODO: Consider subtyping instead of just similarity.
        if isinstance(self.s, CallableType) and is_similar_callables(
                t, cast(CallableType, self.s)):
            return combine_similar_callables(t, cast(CallableType, self.s))
        elif isinstance(self.s, Overloaded):
            # Switch the order of arguments to that we'll get to visit_overloaded.
            return join_types(t, self.s)
        else:
            return join_types(t.fallback, self.s)

    def visit_overloaded(self, t: Overloaded) -&gt; Type:
        # This is more complex than most other cases. Here are some
        # examples that illustrate how this works.
        #
        # First let's define a concise notation:
        #  - Cn are callable types (for n in 1, 2, ...)
        #  - Ov(C1, C2, ...) is an overloaded type with items C1, C2, ...
        #  - Callable[[T, ...], S] is written as [T, ...] -&gt; S.
        #
        # We want some basic properties to hold (assume Cn are all
        # unrelated via Any-similarity):
        #
        #   join(Ov(C1, C2), C1) == C1
        #   join(Ov(C1, C2), Ov(C1, C2)) == Ov(C1, C2)
        #   join(Ov(C1, C2), Ov(C1, C3)) == C1
        #   join(Ov(C2, C2), C3) == join of fallback types
        #
        # The presence of Any types makes things more interesting. The join is the
        # most general type we can get with respect to Any:
        #
        #   join(Ov([int] -&gt; int, [str] -&gt; str), [Any] -&gt; str) == Any -&gt; str
        #
        # We could use a simplification step that removes redundancies, but that's not
        # implemented right now. Consider this example, where we get a redundancy:
        #
        #   join(Ov([int, Any] -&gt; Any, [str, Any] -&gt; Any), [Any, int] -&gt; Any) ==
        #       Ov([Any, int] -&gt; Any, [Any, int] -&gt; Any)
        #
        # TODO: Use callable subtyping instead of just similarity.
        result = []  # type: List[CallableType]
        s = self.s
        if isinstance(s, FunctionLike):
            # The interesting case where both types are function types.
            for t_item in t.items():
                for s_item in s.items():
                    if is_similar_callables(t_item, s_item):
                        result.append(combine_similar_callables(t_item, s_item))
            if result:
                # TODO: Simplify redundancies from the result.
                if len(result) == 1:
                    return result[0]
                else:
                    return Overloaded(result)
            return join_types(t.fallback, s.fallback)
        return join_types(t.fallback, s)

    def visit_tuple_type(self, t: TupleType) -&gt; Type:
        if (isinstance(self.s, TupleType) and
                cast(TupleType, self.s).length() == t.length()):
            items = []  # type: List[Type]
            for i in range(t.length()):
                items.append(self.join(t.items[i],
                                       (cast(TupleType, self.s)).items[i]))
            # TODO: What if the fallback types are different?
            return TupleType(items, t.fallback)
        else:
            return self.default(self.s)

    def join(self, s: Type, t: Type) -&gt; Type:
        return join_types(s, t)

    def default(self, typ: Type) -&gt; Type:
        if isinstance(typ, Instance):
            return object_from_instance(typ)
        elif isinstance(typ, UnboundType):
            return AnyType()
        elif isinstance(typ, Void) or isinstance(typ, ErrorType):
            return ErrorType()
        elif isinstance(typ, TupleType):
            return self.default(typ.fallback)
        elif isinstance(typ, FunctionLike):
            return self.default(typ.fallback)
        elif isinstance(typ, TypeVarType):
            return self.default(typ.upper_bound)
        else:
            return AnyType()
</t>
<t tx="ekr.20190113114613.23">line 1
line 2
line 3 changed
</t>
<t tx="ekr.20190113114613.230">@others
</t>
<t tx="ekr.20190113114613.231">class TypeJoinVisitor(TypeVisitor[Type]):
    """Implementation of the least upper bound algorithm.

    Attributes:
      s: The other (left) type operand.
    """
    @others
</t>
<t tx="ekr.20190113114613.232">
def __init__(self, s: Type) -&gt; None:
    self.s = s

</t>
<t tx="ekr.20190113114613.233">def visit_unbound_type(self, t: UnboundType) -&gt; Type:
    if isinstance(self.s, Void) or isinstance(self.s, ErrorType):
        return ErrorType()
    else:
        return AnyType()

</t>
<t tx="ekr.20190113114613.234">def visit_union_type(self, t: UnionType) -&gt; Type:
    if is_subtype(self.s, t):
        return t
    else:
        return UnionType(t.items + [self.s])

</t>
<t tx="ekr.20190113114613.235">def visit_error_type(self, t: ErrorType) -&gt; Type:
    return t

</t>
<t tx="ekr.20190113114613.236">def visit_type_list(self, t: TypeList) -&gt; Type:
    assert False, 'Not supported'

</t>
<t tx="ekr.20190113114613.237">def visit_any(self, t: AnyType) -&gt; Type:
    return t

</t>
<t tx="ekr.20190113114613.238">def visit_void(self, t: Void) -&gt; Type:
    if isinstance(self.s, Void):
        return t
    else:
        return ErrorType()

</t>
<t tx="ekr.20190113114613.239">def visit_none_type(self, t: NoneTyp) -&gt; Type:
    if not isinstance(self.s, Void):
        return self.s
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20190113114613.24"></t>
<t tx="ekr.20190113114613.240">def visit_erased_type(self, t: ErasedType) -&gt; Type:
    return self.s

</t>
<t tx="ekr.20190113114613.241">def visit_type_var(self, t: TypeVarType) -&gt; Type:
    if isinstance(self.s, TypeVarType) and (cast(TypeVarType, self.s)).id == t.id:
        return self.s
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20190113114613.242">def visit_instance(self, t: Instance) -&gt; Type:
    if isinstance(self.s, Instance):
        return join_instances(t, cast(Instance, self.s))
    elif isinstance(self.s, FunctionLike):
        return join_types(t, self.s.fallback)
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20190113114613.243">def visit_callable_type(self, t: CallableType) -&gt; Type:
    # TODO: Consider subtyping instead of just similarity.
    if isinstance(self.s, CallableType) and is_similar_callables(
            t, cast(CallableType, self.s)):
        return combine_similar_callables(t, cast(CallableType, self.s))
    elif isinstance(self.s, Overloaded):
        # Switch the order of arguments to that we'll get to visit_overloaded.
        return join_types(t, self.s)
    else:
        return join_types(t.fallback, self.s)

</t>
<t tx="ekr.20190113114613.244">def visit_overloaded(self, t: Overloaded) -&gt; Type:
    # This is more complex than most other cases. Here are some
    # examples that illustrate how this works.
    #
    # First let's define a concise notation:
    #  - Cn are callable types (for n in 1, 2, ...)
    #  - Ov(C1, C2, ...) is an overloaded type with items C1, C2, ...
    #  - Callable[[T, ...], S] is written as [T, ...] -&gt; S.
    #
    # We want some basic properties to hold (assume Cn are all
    # unrelated via Any-similarity):
    #
    #   join(Ov(C1, C2), C1) == C1
    #   join(Ov(C1, C2), Ov(C1, C2)) == Ov(C1, C2)
    #   join(Ov(C1, C2), Ov(C1, C3)) == C1
    #   join(Ov(C2, C2), C3) == join of fallback types
    #
    # The presence of Any types makes things more interesting. The join is the
    # most general type we can get with respect to Any:
    #
    #   join(Ov([int] -&gt; int, [str] -&gt; str), [Any] -&gt; str) == Any -&gt; str
    #
    # We could use a simplification step that removes redundancies, but that's not
    # implemented right now. Consider this example, where we get a redundancy:
    #
    #   join(Ov([int, Any] -&gt; Any, [str, Any] -&gt; Any), [Any, int] -&gt; Any) ==
    #       Ov([Any, int] -&gt; Any, [Any, int] -&gt; Any)
    #
    # TODO: Use callable subtyping instead of just similarity.
    result = []  # type: List[CallableType]
    s = self.s
    if isinstance(s, FunctionLike):
        # The interesting case where both types are function types.
        for t_item in t.items():
            for s_item in s.items():
                if is_similar_callables(t_item, s_item):
                    result.append(combine_similar_callables(t_item, s_item))
        if result:
            # TODO: Simplify redundancies from the result.
            if len(result) == 1:
                return result[0]
            else:
                return Overloaded(result)
        return join_types(t.fallback, s.fallback)
    return join_types(t.fallback, s)

</t>
<t tx="ekr.20190113114613.245">def visit_tuple_type(self, t: TupleType) -&gt; Type:
    if (isinstance(self.s, TupleType) and
            cast(TupleType, self.s).length() == t.length()):
        items = []  # type: List[Type]
        for i in range(t.length()):
            items.append(self.join(t.items[i],
                                   (cast(TupleType, self.s)).items[i]))
        # TODO: What if the fallback types are different?
        return TupleType(items, t.fallback)
    else:
        return self.default(self.s)

</t>
<t tx="ekr.20190113114613.246">def join(self, s: Type, t: Type) -&gt; Type:
    return join_types(s, t)

</t>
<t tx="ekr.20190113114613.247">def default(self, typ: Type) -&gt; Type:
    if isinstance(typ, Instance):
        return object_from_instance(typ)
    elif isinstance(typ, UnboundType):
        return AnyType()
    elif isinstance(typ, Void) or isinstance(typ, ErrorType):
        return ErrorType()
    elif isinstance(typ, TupleType):
        return self.default(typ.fallback)
    elif isinstance(typ, FunctionLike):
        return self.default(typ.fallback)
    elif isinstance(typ, TypeVarType):
        return self.default(typ.upper_bound)
    else:
        return AnyType()
</t>
<t tx="ekr.20190113114613.248">guiname = g.app.gui.guiName()

tkinter = c.config.getBool('test_tkinter_setting')
wx      = c.config.getBool('test_wxWindows_setting')

print(guiname)

if guiname == 'tkinter':
    assert(tkinter)
    assert(not wx)

if guiname == 'wxWindows':
    assert(not tkinter)
    assert(wx)
</t>
<t tx="ekr.20190113114613.249"># This test is no longer valid because of per-position node expansions.
def test_sibs(parent_p,parent_item):
    trace = False
    tree = c.frame.tree
    sib_items = tree.childItems(parent_item)
    sibs = [z.copy() for z in parent_p.self_and_siblings_iter()]
    assert len(sib_items) == len(sibs),(
        'child_items: %s, children: %s' % (
            g.listToString(sib_items),g.listToString(sibs)))
    for item,p in zip(sib_items,sibs):
        p2 = tree.item2position(item)
        if trace: print (id(item),p2 and p2.headString() or not p2 and '**None**')
        assert p == p2, 'item: %s, p: %s, p2: %s' % (id(item),p,p2)
        # Recursively test.
        child = p.firstChild()
        if child.isVisible(c):
            test_sibs(child,parent_item=item)
if hasattr(c.frame.tree,'item2position'):
    c.redraw()
    test_sibs(c.rootPosition(),None)
</t>
<t tx="ekr.20190113114613.25">line 1
line 2
line 3
</t>
<t tx="ekr.20190113114613.250">s = '''\

// Convert a string to it's JSON representation by encoding control characters, double quotes and backslash. See json.org
String.prototype.toJSONString = function()
{
	var m = {
		'\\b': '\\\\b',
		'\\f': '\\\\f',
		'\\n': '\\\\n',
		'\\r': '\\\\r',
		'\\t': '\\\\t',
		'"' : '\\\\"',
		'\\\\': '\\\\\\\\'
		};
	var replaceFn = function(a,b) {
		var c = m[b];
		if(c)
			return c;
		c = b.charCodeAt();
		return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
		};
    if(/["\\\\\\x00-\\x1f]/.test(this))
		return '"' + this.replace(/([\\x00-\\x1f\\"])/g,replaceFn) + '"';

	return '"' + this + '"';
};

'''


c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
</t>
<t tx="ekr.20190113114613.251"># This test is difficult to get right on all platforms.
# It's not worth doing.

try:
    k = c.k
    w = c.frame.body.wrapper
    ac = k.autoCompleter
    # Set the insertion point.
    s = w.getAllText()
    w.setInsertPoint(len(s)-1)
    # Just test that this doesn't crash.
    ac.w = w
    ac.calltip()
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor()

# c.frame
</t>
<t tx="ekr.20190113114613.252">import leo.plugins.macros as macros

controller = macros.ParamClass(c)
controller.parameterize()
    # Not much will happen because there are no children.
    # However, this does test recent changes.
</t>
<t tx="ekr.20190113114613.253">gnx = g.app.nodeIndices.toString(None)
assert(gnx not in (None,'None'))
assert(len(gnx) &gt; 1)
</t>
<t tx="ekr.20190113114613.254"># p.__getattr__ must be enabled for this test to work.

for p in c.all_positions():
    assert(p.t == p.v)
</t>
<t tx="ekr.20190113114613.255">pd = c.persistenceController
root = c.rootPosition().insertAfter()
root.h = 'root'
child1 = root.insertAsLastChild()
child1.h = 'child1'
child2 = child1.insertAfter()
child2.h = 'child2'
child11 = child1.insertAsLastChild()
child11.h = 'child11'
try:
    for unl in ('root','root--&gt;child1','root--&gt;child2','root--&gt;child1--&gt;child11'):
        p = pd.find_absolute_unl_node(unl)
        parts = unl.split('--&gt;')
        assert p,unl
        assert p.h == parts[-1],p.h
finally:
    root.doDelete()
    c.selectPosition(p)
    c.redraw()
</t>
<t tx="ekr.20190113114613.256"># At present, neither the pack nor the unpack commands exist.
pd = c.persistenceController
persistence = pd.find_at_persistence_node()
assert persistence
persistence.deleteAllChildren()
view = g.findNodeInTree(c,p,'@view test')
assert view
assert c.positionExists(view)
try:
    c.selectPosition(view)
    v_b = view.b
    pd.pack()
    assert c.p.v == view.v
    pd.unpack()
    assert view.b == v_b,view.b
    assert view.lastChild().isCloned()
finally:
    # views.deleteAllChildren()
    c.undoer.clearUndoState()
    c.redraw()
</t>
<t tx="ekr.20190113114613.258">view body
</t>
<t tx="ekr.20190113114613.259">not a clone text
</t>
<t tx="ekr.20190113114613.26">line 2
line 3
</t>
<t tx="ekr.20190113114613.260">clone body
</t>
<t tx="ekr.20190113114613.261"># This was part of the ill-fated leoViews project.
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    h = '@persistence'
    p1 = pd.find_at_persistence_node()
    assert p1
    p2 = pd.has_at_persistence_node()
    assert p1 == p2,(p1,p2)
    print(p1.h)
    pd.prepass(p2)
</t>
<t tx="ekr.20190113114613.262">pd = c.persistenceController
at_persistence = pd.find_at_persistence_node()
assert at_persistence
at_persistence.deleteAllChildren()
root = at_persistence.insertAsLastChild()
root.h = 'test root'
root.b = root.gnx
at_data = pd.find_at_data_node(root)
assert at_data
try:
    at_uas = at_data.insertAsLastChild()
    at_uas.h = '@uas'
    at_ua = at_uas.insertAsLastChild()
    at_ua.h = '@ua:dummy-gnx'
    at_ua.b = 'unl:dummy-unl\nua:dummy-ua'
    at_recovery = pd.find_at_recovery_node(root)
    if at_recovery:
        at_recovery.deleteAllChildren()
    pd.recover_ua_for_gnx('dummy-gnx',root,'dummy-unl')
    assert at_recovery
    at_ua2 = g.findNodeInTree(c,at_recovery,'@ua:dummy-gnx')
    assert at_ua2
    assert at_ua2.h == at_ua.h
    assert at_ua2.b == at_ua.b,repr(at_ua2.b)
finally:
    pass # root.doDelete()

</t>
<t tx="ekr.20190113114613.263">print('calls to jedit.setTag: %s' %
     c.frame.body.colorizer.highlighter.colorer.n_setTag)
</t>
<t tx="ekr.20190113114613.264">print('end python tests')
</t>
<t tx="ekr.20190113114613.265">print('start python tests')
</t>
<t tx="ekr.20190113114613.266"># Applies to options doc parts as well.
</t>
<t tx="ekr.20190113114613.267">d = g.app.extra_extension_dict

for ext in g.app.extension_dict.keys():
    language =  c.importCommands.languageForExtension(ext)
    language2 = c.importCommands.languageForExtension('.'+ext)
    assert language == language2

    # Now a many-one relationship.
    if language:
        # Do not test extensions that have 'none' as the value of d.get(ext)
        # Otherwise, test only d.get(ext).
        language2 = d.get(ext)
        if language2 in ('None','none'):  continue
        if language2: language = language2
        # Made-up languages do not have mode files.
        if not language.endswith('_language') and language not in ('autohotkey','rest','rst','typescript',):
            path = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
            assert g.os_path_exists(path), 'for ext=%s does not exist: %s' % (ext,path)

    if 0:
        if language is None:
            print('no language for ext=%s' % (ext))
</t>
<t tx="ekr.20190113114613.268"># print('-' * 30)

@others

# This can't be run externally,
# And it is no longer an effective test.

p = c.rootPosition()
ok = True
while p and ok:
    if p.isAnyAtFileNode():
        h = p.h
        if h.endswith('.py'):
            ok = checkFile(p)
        p.moveToNodeAfterTree()
    else:
        p.moveToThreadNext()
assert ok
</t>
<t tx="ekr.20190113114613.269">def checkFile(p):

    # print('checking',p.h)
    # Check all the descendant nodes.
    ok = True
    for p2 in p.subtree_iter():
        h = p2.h
        for tag in ('@test','@suite'):
            if h.startswith(tag):
                s = p2.b
                lines = g.splitLines(s)
                for line in lines:
                    # print('line',line)
                    if not line.strip() or line.startswith('#'):
                        continue
                    elif line.startswith('if g.unitTesting:'):
                        break
                    else:
                        print('in %s' % p.h)
                        print('missing "if g.unitTesting:" %s' % h)
                        ok = False
    return ok
</t>
<t tx="ekr.20190113114613.27"></t>
<t tx="ekr.20190113114613.270">for p in c.all_positions():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        firstChild = p.v.children[0]
        assert childv == firstChild
</t>
<t tx="ekr.20190113114613.271">import sys
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Qt not available in TravisCI')
if sys.platform.startswith('linux'):
    self.skipTest('Linux test')
from leo.core.leoQt import QtCore,QtGui,QtWidgets
import leo.plugins.qt_events as qt_events
wrapper = c.frame.body.wrapper
w = wrapper.widget
assert g.isTextWrapper(wrapper),wrapper
assert g.isTextWidget(w),w
filter_obj = qt_events.LeoQtEventFilter(c,w=w)
g.app.unitTestDict[p.h] = filter_obj
    # keep a pointer to the filter.
for z in c.k.bindingsDict.keys():
    if z.s == 'Alt+Key-9':
        self.skipTest('Alt-Key-9 is bound')
if 0: # Too dangerous, and not useful enough.
    # Create an Alt-9 key event.
    ev = QtCore.QEvent
    e = QtGui.QKeyEvent(ev.KeyPress,ord('9'),QtCore.Qt.AltModifier)
    filter_obj.eventFilter(w,e)
    # Assert that handleUnboundChar actually ignored it.
    assert g.app.unitTestDict.get('handleUnboundChar-ignore-alt-or-ctrl')
</t>
<t tx="ekr.20190113114613.272">p1 = p.copy()
a = p.firstChild()
b = a.firstChild()
c2 = b.firstChild()
limit = a.next()
d = limit.firstChild()
e = limit.next()
assert e.h == 'e'
for p2,h in ((a,'a'),(b,'b'),(c2,'c2'),(d,'d'),(limit,'limit')):
    p2.expand()
    assert p2.h==h,'headString mismatch'

try: # Tests without hoist...
    p1.expand()
    assert not c.hoistStack
    c.selectPosition(limit)
    result = limit.copy().moveToVisBack(c)
    assert result==c2,'visBack != c2: %s' % result
    #
    result = limit.copy().moveToVisNext(c)
    assert result==d,'visNext != d: %s' % result
finally:
    p1.contract()

try: # Tests with hoist.
    p1.expand()
    c.selectPosition(limit)
    c.hoist()
    result = limit.copy().moveToVisBack(c)
    assert not result,'limited visBack: %s' % result
    #
    result = limit.copy().moveToVisNext(c)
    assert result==d,'limited visNext !=d: %s' % result
finally:
    c.dehoist()
    c.selectPosition(p1)
    p1.contract()
    c.redraw_now()

</t>
<t tx="ekr.20190113114613.273"></t>
<t tx="ekr.20190113114613.274"></t>
<t tx="ekr.20190113114613.275"></t>
<t tx="ekr.20190113114613.276"></t>
<t tx="ekr.20190113114613.277"></t>
<t tx="ekr.20190113114613.278"></t>
<t tx="ekr.20190113114613.279">if 0: # x.rename no longer exists
    x = c.shadowController

    filename = x.pathName('xyzzy')
    assert not g.os_path_exists(filename)
    n = x.errors
    x.rename('xyzzy','xyzzy2',silent=True)
    assert x.errors == n+1
    assert x.last_error.startswith('can not rename')
    # print(x.last_error)
</t>
<t tx="ekr.20190113114613.28">line 1
line 2
line 3
</t>
<t tx="ekr.20190113114613.280"></t>
<t tx="ekr.20190113114613.281">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20190113114613.282">@nosearch</t>
<t tx="ekr.20190113114613.283">@language python
@tabwidth -4
@others
# end.
</t>
<t tx="ekr.20190113114613.284"># ~/at-auto-test.py

# This is valid Python, but it looks like a section reference.
a = b &lt;&lt; c &gt;&gt; d

</t>
<t tx="ekr.20190113114613.285">#section 1
Sec 1.

#section 2
Sec 2.
@language python
@tabwidth -4
@ignore
</t>
<t tx="ekr.20190113114613.286">if isPython3: # g.not defined yet.
    &lt;&lt; u:1 &gt;&gt;
    &lt;&lt; ue:1 &gt;&gt;
else:
    &lt;&lt; u:2 &gt;&gt;
    &lt;&lt; ue: 2&gt;&gt;
</t>
<t tx="ekr.20190113114613.287">def u(s):
    '''Return s, converted to unicode from Qt widgets.'''
    return s</t>
<t tx="ekr.20190113114613.288">def ue(s, encoding):
    return s if g.isUnicode(s) else str(s, encoding)</t>
<t tx="ekr.20190113114613.289">def u(s):
    '''Return s, converted to unicode from Qt widgets.'''
    return builtins.unicode(s) # Suppress pyflakes complaint.</t>
<t tx="ekr.20190113114613.29">line 1
line 3
</t>
<t tx="ekr.20190113114613.290">def ue(s, encoding):
    return builtins.unicode(s, encoding)</t>
<t tx="ekr.20190113114613.291"># This was used by @test writing a .leo file retains orphan bits.
# but this test is moot because Leo no longer writes orphan bits.</t>
<t tx="ekr.20190113114613.292">@others</t>
<t tx="ekr.20190113114613.293">def spam():
    pass</t>
<t tx="ekr.20190113114613.294">def eggs():
    pass</t>
<t tx="ekr.20190113114613.295">@others</t>
<t tx="ekr.20190113114613.296">def spam():
    pass</t>
<t tx="ekr.20190113114613.297">def eggs():
    pass</t>
<t tx="ekr.20190113114613.298">@language python
@tabwidth -4

# Begin

@others

# End
</t>
<t tx="ekr.20190113114613.299"># node 1 text A.
</t>
<t tx="ekr.20190113114613.3">import unittest
import leo.core.leoShadow as leoShadow
# Possible: replace this suite with individual @test nodes
# exec(g.findTestScript(c,'@common @shadow test code'))
x = c.shadowController
suite = unittest.makeSuite(unittest.TestCase)
root = g.findNodeInTree(c,p,'@shadow-tests')
assert root, 'Node not found: @shadow-tests'
delims = '//','',''
for p in root.children_iter():
    h = p.h.strip()
    if h.startswith('@shadow-test'):
        test = x.AtShadowTestCase(c,p,x,delims=delims,trace=False)
        suite.addTest(test)
</t>
<t tx="ekr.20190113114613.30"></t>
<t tx="ekr.20190113114613.300"># node 2 text B.
</t>
<t tx="ekr.20190113114613.301">@language python
@others</t>
<t tx="ekr.20190113114613.302">def spam():
    pass</t>
<t tx="ekr.20190113114613.303">def eggs():
    pass</t>
<t tx="ekr.20190113114613.304"># changed.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190113114613.305">def at_auto_child():
    pass
</t>
<t tx="ekr.20190113114613.306">@language md
@tabwidth -4
</t>
<t tx="ekr.20190113114613.307">Header line.

</t>
<t tx="ekr.20190113114613.308">Sec 1.

</t>
<t tx="ekr.20190113114613.309">Sec 2.

</t>
<t tx="ekr.20190113114613.31">line 1
line 2
line 3
</t>
<t tx="ekr.20190113114613.310">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190113114613.311">def spam():
    pass
</t>
<t tx="ekr.20190113114613.312">def eggs():
    pass


</t>
<t tx="ekr.20190113114613.313">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190113114613.314">class class1:
    @others
</t>
<t tx="ekr.20190113114613.315">def class1_method1():
    pass
</t>
<t tx="ekr.20190113114613.316">def class1_method2():
    pass
# After @others in child1.
</t>
<t tx="ekr.20190113114613.317">class class2:
    @others
# last line
</t>
<t tx="ekr.20190113114613.318">def class2_method1():
    pass
</t>
<t tx="ekr.20190113114613.319">def class2_method2():
    pass
</t>
<t tx="ekr.20190113114613.32">line 1
line 2
</t>
<t tx="ekr.20190113114613.320">Leading text in root node of subtree

Etc. etc.
</t>
<t tx="ekr.20190113114613.321">This would be the text in this level one node.

And this.
</t>
<t tx="ekr.20190113114613.322">Another one
</t>
<t tx="ekr.20190113114613.323">See what we did there - one more '#' - this is a subnode.
</t>
<t tx="ekr.20190113114613.324">Introduction line 1.
Introduction line 2.
@language plain
@tabwidth -4
</t>
<t tx="ekr.20190113114613.325">Sec 1.
</t>
<t tx="ekr.20190113114613.326">Sec 2.
</t>
<t tx="ekr.20190113114613.327">@language plain
@tabwidth -4
</t>
<t tx="ekr.20190113114613.328"></t>
<t tx="ekr.20190113114613.329">Sec 1.
</t>
<t tx="ekr.20190113114613.33"></t>
<t tx="ekr.20190113114613.330">Sec 2.
</t>
<t tx="ekr.20190113114613.331">@language rest
@tabwidth -4
</t>
<t tx="ekr.20190113114613.332">@language c
@tabwidth -4
// before @others // line 1
@others
// last line: line 6
</t>
<t tx="ekr.20190113114613.333">def spam(): // line 2
    pass
</t>
<t tx="ekr.20190113114613.334">def eggs(): // line 4
    pass
</t>
<t tx="ekr.20190113114613.335">@language python
@tabwidth -4
# Before @others: line 1
@others
# Last line: line 6
</t>
<t tx="ekr.20190113114613.336">def spam(): # line 2
    pass
</t>
<t tx="ekr.20190113114613.337">def eggs(): # line 4
    pass
</t>
<t tx="ekr.20190113114613.338">@language cweb
@ % This file is part of CWEB.
% This program by Silvio Levy and Donald E. Knuth
% is based on a program by Knuth.
% It is distributed WITHOUT ANY WARRANTY, express or implied.
% Version 3.61 --- July 2000
% (essentially the same as version 3.6, which added
%  recently introduced features of standard C++ to version 3.4)

% Copyright (C) 1987,1990,1993,2000 Silvio Levy and Donald E. Knuth

% Permission is granted to make and distribute verbatim copies of this
% document provided that the copyright notice and this permission notice
% are preserved on all copies.

% Permission is granted to copy and distribute modified versions of this
% document under the conditions for verbatim copying, provided that the
% entire resulting derived work is given a different name and distributed
% under the terms of a permission notice identical to this one.

% Here is TeX material that gets inserted after \input cwebmac
\def\hang{\hangindent 3em\indent\ignorespaces}
\def\pb{$\.|\ldots\.|$} % C brackets (|...|)
\def\v{\char'174} % vertical (|) in typewriter font
\def\dleft{[\![} \def\dright{]\!]} % double brackets
\mathchardef\RA="3221 % right arrow
\mathchardef\BA="3224 % double arrow
\def\({} % ) kludge for alphabetizing certain section names
\def\TeXxstring{\\{\TEX/\_string}}
\def\skipxTeX{\\{skip\_\TEX/}}
\def\copyxTeX{\\{copy\_\TEX/}}

\def\title{CWEAVE (Version 3.61)}
\def\topofcontents{\null\vfill
  \centerline{\titlefont The {\ttitlefont CWEAVE} processor}
  \vskip 15pt
  \centerline{(Version 3.61)}
  \vfill}
\def\botofcontents{\vfill
\noindent
Copyright \copyright\ 1987, 1990, 1993, 2000 Silvio Levy and Donald E. Knuth
\bigskip\noindent
Permission is granted to make and distribute verbatim copies of this
document provided that the copyright notice and this permission notice
are preserved on all copies.

\smallskip\noindent
Permission is granted to copy and distribute modified versions of this
document under the conditions for verbatim copying, provided that the
entire resulting derived work is given a different name and distributed
under the terms of a permission notice identical to this one.
}
\pageno=\contentspagenumber \advance\pageno by 1
\let\maybe=\iftrue
@s not_eq normal @q unreserve a C++ keyword @&gt;@** Introduction. This is the \.{CWEAVE} program by Silvio Levy and Donald E. Knuth, based on \.{WEAVE} by Knuth. We are thankful to Steve Avery, Nelson Beebe, Hans-Hermann Bode (to whom the original \CPLUSPLUS/ adaptation is due), Klaus Guntermann, Norman Ramsey, Tomas Rokicki, Joachim Schnitter, Joachim Schrod, Lee Wittenberg, Saroj Mahapatra, Cesar Augusto Rorato Crusius, and others who have contributed improvements.  The ``banner line'' defined here should be changed whenever \.{CWEAVE} is modified.

@d banner "This is CWEAVE (Version 3.61)\n"

@c @&lt;Include files@&gt;@/
@h
@&lt;Common code for \.{CWEAVE} and \.{CTANGLE}@&gt;@/
@&lt;Typedef declarations@&gt;@/
@&lt;Global variables@&gt;@/
@&lt;Predeclaration of procedures@&gt;
@ We predeclare several standard system functions here instead of including their system header files, because the names of the header files are not as standard as the names of the functions. (For example, some \CEE/ environments have \.{&lt;string.h&gt;} where others have \.{&lt;strings.h&gt;}.)

@&lt;Predeclaration of procedures@&gt;=
extern int strlen(); /* length of string */
extern int strcmp(); /* compare strings lexicographically */
extern char* strcpy(); /* copy one string to another */
extern int strncmp(); /* compare up to $n$ string characters */
extern char* strncpy(); /* copy up to $n$ string characters */
@ \.{CWEAVE} has a fairly straightforward outline.  It operates in three phases: First it inputs the source file and stores cross-reference data, then it inputs the source once again and produces the \TEX/ output file, finally it sorts and outputs the index.  Please read the documentation for \.{common}, the set of routines common to \.{CTANGLE} and \.{CWEAVE}, before proceeding further.

@c
int main (ac, av)
int ac; /* argument count */
char **av; /* argument values */
{
  argc=ac; argv=av;
  program=cweave;
  make_xrefs=force_lines=1; /* controlled by command-line options */
  common_init();
  @&lt;Set initial values@&gt;;
  if (show_banner) printf(banner); /* print a ``banner line'' */
  @&lt;Store all the reserved words@&gt;;
  phase_one(); /* read all the user's text and store the cross-references */
  phase_two(); /* read all the text again and translate it to \TEX/ form */
  phase_three(); /* output the cross-reference index */
  return wrap_up(); /* and exit gracefully */
}@ We have to get \CEE/'s reserved words into the hash table, and the simplest way to do this is to insert them every time \.{CWEAVE} is run.  Fortunately there are relatively few reserved words. (Some of these are not strictly ``reserved,'' but are defined in header files of the ISO Standard \CEE/ Library.) @^reserved words@&gt;

@&lt;Store all the reserved words@&gt;=
id_lookup("and",NULL,alfop);
id_lookup("and_eq",NULL,alfop);
id_lookup("asm",NULL,sizeof_like);
id_lookup("auto",NULL,int_like);
id_lookup("bitand",NULL,alfop);
id_lookup("bitor",NULL,alfop);
id_lookup("bool",NULL,raw_int);
id_lookup("break",NULL,case_like);
id_lookup("case",NULL,case_like);
id_lookup("catch",NULL,catch_like);
id_lookup("char",NULL,raw_int);
id_lookup("class",NULL,struct_like);
id_lookup("clock_t",NULL,raw_int);
id_lookup("compl",NULL,alfop);
id_lookup("const",NULL,const_like);
id_lookup("const_cast",NULL,raw_int);
id_lookup("continue",NULL,case_like);
id_lookup("default",NULL,case_like);
id_lookup("define",NULL,define_like);
id_lookup("defined",NULL,sizeof_like);
id_lookup("delete",NULL,delete_like);
id_lookup("div_t",NULL,raw_int);
id_lookup("do",NULL,do_like);
id_lookup("double",NULL,raw_int);
id_lookup("dynamic_cast",NULL,raw_int);
id_lookup("elif",NULL,if_like);
id_lookup("else",NULL,else_like);
id_lookup("endif",NULL,if_like);
id_lookup("enum",NULL,struct_like);
id_lookup("error",NULL,if_like);
id_lookup("explicit",NULL,int_like);
id_lookup("export",NULL,int_like);
id_lookup("extern",NULL,int_like);
id_lookup("FILE",NULL,raw_int);
id_lookup("float",NULL,raw_int);
id_lookup("for",NULL,for_like);
id_lookup("fpos_t",NULL,raw_int);
id_lookup("friend",NULL,int_like);
id_lookup("goto",NULL,case_like);
id_lookup("if",NULL,if_like);
id_lookup("ifdef",NULL,if_like);
id_lookup("ifndef",NULL,if_like);
id_lookup("include",NULL,if_like);
id_lookup("inline",NULL,int_like);
id_lookup("int",NULL,raw_int);
id_lookup("jmp_buf",NULL,raw_int);
id_lookup("ldiv_t",NULL,raw_int);
id_lookup("line",NULL,if_like);
id_lookup("long",NULL,raw_int);
id_lookup("mutable",NULL,int_like);
id_lookup("namespace",NULL,struct_like);
id_lookup("new",NULL,new_like);
id_lookup("not",NULL,alfop);
id_lookup("not_eq",NULL,alfop);
id_lookup("NULL",NULL,custom);
id_lookup("offsetof",NULL,raw_int);
id_lookup("operator",NULL,operator_like);
id_lookup("or",NULL,alfop);
id_lookup("or_eq",NULL,alfop);
id_lookup("pragma",NULL,if_like);
id_lookup("private",NULL,public_like);
id_lookup("protected",NULL,public_like);
id_lookup("ptrdiff_t",NULL,raw_int);
id_lookup("public",NULL,public_like);
id_lookup("register",NULL,int_like);
id_lookup("reinterpret_cast",NULL,raw_int);
id_lookup("return",NULL,case_like);
id_lookup("short",NULL,raw_int);
id_lookup("sig_atomic_t",NULL,raw_int);
id_lookup("signed",NULL,raw_int);
id_lookup("size_t",NULL,raw_int);
id_lookup("sizeof",NULL,sizeof_like);
id_lookup("static",NULL,int_like);
id_lookup("static_cast",NULL,raw_int);
id_lookup("struct",NULL,struct_like);
id_lookup("switch",NULL,for_like);
id_lookup("template",NULL,template_like);
id_lookup("this",NULL,custom);
id_lookup("throw",NULL,case_like);
id_lookup("time_t",NULL,raw_int);
id_lookup("try",NULL,else_like);
id_lookup("typedef",NULL,typedef_like);
id_lookup("typeid",NULL,raw_int);
id_lookup("typename",NULL,struct_like);
id_lookup("undef",NULL,if_like);
id_lookup("union",NULL,struct_like);
id_lookup("unsigned",NULL,raw_int);
id_lookup("using",NULL,int_like);
id_lookup("va_dcl",NULL,decl); /* Berkeley's variable-arg-list convention */
id_lookup("va_list",NULL,raw_int); /* ditto */
id_lookup("virtual",NULL,int_like);
id_lookup("void",NULL,raw_int);
id_lookup("volatile",NULL,const_like);
id_lookup("wchar_t",NULL,raw_int);
id_lookup("while",NULL,for_like);
id_lookup("xor",NULL,alfop);
id_lookup("xor_eq",NULL,alfop);
res_wd_end=name_ptr;
id_lookup("TeX",NULL,custom);
id_lookup("make_pair",NULL,func_template);
@ The following parameters were sufficient in the original \.{WEAVE} to handle \TEX/, so they should be sufficient for most applications of \.{CWEAVE}. If you change |max_bytes|, |max_names|, |hash_size|, or |buf_size| you have to change them also in the file |"common.w"|.

@d max_bytes 90000 /* the number of bytes in identifiers,
  index entries, and section names */
@d max_names 4000 /* number of identifiers, strings, section names;
  must be less than 10240; used in |"common.w"| */
@d max_sections 2000 /* greater than the total number of sections */
@d hash_size 353 /* should be prime */
@d buf_size 100 /* maximum length of input line, plus one */
@d longest_name 10000 /* section names and strings shouldn't be longer than this */
@d long_buf_size (buf_size+longest_name)
@d line_length 80 /* lines of \TEX/ output have at most this many characters;
  should be less than 256 */
@d max_refs 20000 /* number of cross-references; must be less than 65536 */
@d max_toks 20000 /* number of symbols in \CEE/ texts being parsed;
  must be less than 65536 */
@d max_texts 4000 /* number of phrases in \CEE/ texts being parsed;
  must be less than 10240 */
@d max_scraps 2000 /* number of tokens in \CEE/ texts being parsed */
@d stack_size 400 /* number of simultaneous output levels */

@ The next few sections contain stuff from the file |"common.w"| that must
be included in both |"ctangle.w"| and |"cweave.w"|. It appears in
file |"common.h"|, which needs to be updated when |"common.w"| changes.

@i common.h@* Data structures exclusive to {\tt CWEAVE}. As explained in \.{common.w}, the field of a |name_info| structure that contains the |rlink| of a section name is used for a completely different purpose in the case of identifiers.  It is then called the |ilk| of the identifier, and it is used to distinguish between various types of identifiers, as follows:  \yskip\hang |normal| and |func_template| identifiers are part of the \CEE/ program that will  appear in italic type (or in typewriter type if all uppercase).  \yskip\hang |custom| identifiers are part of the \CEE/ program that will be typeset in special ways.  \yskip\hang |roman| identifiers are index entries that appear after \.{@@\^} in the \.{CWEB} file.  \yskip\hang |wildcard| identifiers are index entries that appear after \.{@@:} in the \.{CWEB} file.  \yskip\hang |typewriter| identifiers are index entries that appear after \.{@@.} in the \.{CWEB} file.  \yskip\hang |alfop|, \dots, |template_like| identifiers are \CEE/ or \CPLUSPLUS/ reserved words whose |ilk| explains how they are to be treated when \CEE/ code is being formatted.

@d ilk dummy.Ilk
@d normal 0 /* ordinary identifiers have |normal| ilk */
@d roman 1 /* normal index entries have |roman| ilk */
@d wildcard 2 /* user-formatted index entries have |wildcard| ilk */
@d typewriter 3 /* `typewriter type' entries have |typewriter| ilk */
@d abnormal(a) (a-&gt;ilk&gt;typewriter) /* tells if a name is special */
@d func_template 4 /* identifiers that can be followed by optional template */
@d custom 5 /* identifiers with user-given control sequence */
@d alfop 22 /* alphabetic operators like \&amp;{and} or \&amp;{not\_eq} */
@d else_like 26 /* \&amp;{else} */
@d public_like 40 /* \&amp;{public}, \&amp;{private}, \&amp;{protected} */
@d operator_like 41 /* \&amp;{operator} */
@d new_like 42 /* \&amp;{new} */
@d catch_like 43 /* \&amp;{catch} */
@d for_like 45 /* \&amp;{for}, \&amp;{switch}, \&amp;{while} */
@d do_like 46 /* \&amp;{do} */
@d if_like 47 /* \&amp;{if}, \&amp;{ifdef}, \&amp;{endif}, \&amp;{pragma}, \dots */
@d delete_like 48 /* \&amp;{delete} */
@d raw_ubin 49 /* `\.\&amp;' or `\.*' when looking for \&amp;{const} following */
@d const_like 50 /* \&amp;{const}, \&amp;{volatile} */
@d raw_int 51 /* \&amp;{int}, \&amp;{char}, \dots; also structure and class names  */
@d int_like 52 /* same, when not followed by left parenthesis or \DC\ */
@d case_like 53 /* \&amp;{case}, \&amp;{return}, \&amp;{goto}, \&amp;{break}, \&amp;{continue} */
@d sizeof_like 54 /* \&amp;{sizeof} */
@d struct_like 55 /* \&amp;{struct}, \&amp;{union}, \&amp;{enum}, \&amp;{class} */
@d typedef_like 56 /* \&amp;{typedef} */
@d define_like 57 /* \&amp;{define} */
@d template_like 58 /* \&amp;{template} */
@ We keep track of the current section number in |section_count|, which is the total number of sections that have started.  Sections which have been altered by a change file entry have their |changed_section| flag turned on during the first phase.

@&lt;Global variables@&gt;=
boolean change_exists; /* has any section changed? */

@ The other large memory area in \.{CWEAVE} keeps the cross-reference data. All uses of the name |p| are recorded in a linked list beginning at |p-&gt;xref|, which points into the |xmem| array. The elements of |xmem| are structures consisting of an integer, |num|, and a pointer |xlink| to another element of |xmem|.  If |x=p-&gt;xref| is a pointer into |xmem|, the value of |x-&gt;num| is either a section number where |p| is used, or |cite_flag| plus a section number where |p| is mentioned, or |def_flag| plus a section number where |p| is defined; and |x-&gt;xlink| points to the next such cross-reference for |p|, if any. This list of cross-references is in decreasing order by section number. The next unused slot in |xmem| is |xref_ptr|. The linked list ends at |&amp;xmem[0]|.  The global variable |xref_switch| is set either to |def_flag| or to zero, depending on whether the next cross-reference to an identifier is to be underlined or not in the index. This switch is set to |def_flag| when \.{@@!} or \.{@

@d} is scanned, and it is cleared to zero when
the next identifier or index entry cross-reference has been made.
Similarly, the global variable |section_xref_switch| is either
|def_flag| or |cite_flag| or zero, depending
on whether a section name is being defined, cited or used in \CEE/ text.

@&lt;Typedef declarations@&gt;=
typedef struct xref_info {
  sixteen_bits num; /* section number plus zero or |def_flag| */
  struct xref_info *xlink; /* pointer to the previous cross-reference */
} xref_info;
typedef xref_info *xref_pointer;

@ @&lt;Global...@&gt;=
xref_info xmem[max_refs]; /* contains cross-reference information */
xref_pointer xmem_end = xmem+max_refs-1;
xref_pointer xref_ptr; /* the largest occupied position in |xmem| */
sixteen_bits xref_switch,section_xref_switch; /* either zero or |def_flag| */

@ A section that is used for multi-file output (with the \.{@@(} feature) has a special first cross-reference whose |num| field is |file_flag|.

@d file_flag (3*cite_flag)
@d def_flag (2*cite_flag)
@d cite_flag 10240 /* must be strictly larger than |max_sections| */
@d xref equiv_or_xref

@&lt;Set initial values@&gt;=
xref_ptr=xmem; name_dir-&gt;xref=(char*)xmem; xref_switch=0; section_xref_switch=0;
xmem-&gt;num=0; /* sentinel value */@ A new cross-reference for an identifier is formed by calling |new_xref|, which discards duplicate entries and ignores non-underlined references to one-letter identifiers or \CEE/'s reserved words.  If the user has sent the |no_xref| flag (the \.{-x} option of the command line), it is unnecessary to keep track of cross-references for identifiers. If one were careful, one could probably make more changes around section 100 to avoid a lot of identifier looking up.

@d append_xref(c) if (xref_ptr==xmem_end) overflow("cross-reference");
  else (++xref_ptr)-&gt;num=c;
@d no_xref (flags['x']==0)
@d make_xrefs flags['x'] /* should cross references be output? */
@d is_tiny(p) ((p+1)-&gt;byte_start==(p)-&gt;byte_start+1)
@d unindexed(a) (a&lt;res_wd_end &amp;&amp; a-&gt;ilk&gt;=custom)
      /* tells if uses of a name are to be indexed */

@c
void
new_xref(p)
name_pointer p;
{
  xref_pointer q; /* pointer to previous cross-reference */
  sixteen_bits m, n; /* new and previous cross-reference value */
  if (no_xref) return;
  if ((unindexed(p) || is_tiny(p)) &amp;&amp; xref_switch==0) return;
  m=section_count+xref_switch; xref_switch=0; q=(xref_pointer)p-&gt;xref;
  if (q != xmem) {
    n=q-&gt;num;
    if (n==m || n==m+def_flag) return;
    else if (m==n+def_flag) {
        q-&gt;num=m; return;
    }
  }
  append_xref(m); xref_ptr-&gt;xlink=q; p-&gt;xref=(char*)xref_ptr;
}@ The cross-reference lists for section names are slightly different. Suppose that a section name is defined in sections $m_1$, \dots, $m_k$, cited in sections $n_1$, \dots, $n_l$, and used in sections $p_1$, \dots, $p_j$.  Then its list will contain $m_1+|def_flag|$, \dots, $m_k+|def_flag|$, $n_1+|cite_flag|$, \dots, $n_l+|cite_flag|$, $p_1$, \dots, $p_j$, in this order.  Although this method of storage takes quadratic time with respect to the length of the list, under foreseeable uses of \.{CWEAVE} this inefficiency is insignificant.

@c
void
new_section_xref(p)
name_pointer p;
{
  xref_pointer q,r; /* pointers to previous cross-references */
  q=(xref_pointer)p-&gt;xref; r=xmem;
  if (q&gt;xmem)
        while (q-&gt;num&gt;section_xref_switch) {r=q; q=q-&gt;xlink;}
  if (r-&gt;num==section_count+section_xref_switch)
        return; /* don't duplicate entries */
  append_xref(section_count+section_xref_switch);
  xref_ptr-&gt;xlink=q; section_xref_switch=0;
  if (r==xmem) p-&gt;xref=(char*)xref_ptr;
  else r-&gt;xlink=xref_ptr;
}@ The cross-reference list for a section name may also begin with |file_flag|. Here's how that flag gets put~in.

@c
void
set_file_flag(p)
name_pointer p;
{
  xref_pointer q;
  q=(xref_pointer)p-&gt;xref;
  if (q-&gt;num==file_flag) return;
  append_xref(file_flag);
  xref_ptr-&gt;xlink = q;
  p-&gt;xref = (char *)xref_ptr;
}@ A third large area of memory is used for sixteen-bit `tokens', which appear in short lists similar to the strings of characters in |byte_mem|. Token lists are used to contain the result of \CEE/ code translated into \TEX/ form; further details about them will be explained later. A |text_pointer| variable is an index into |tok_start|.

@&lt;Typedef declarations@&gt;=
typedef sixteen_bits token;
typedef token *token_pointer;
typedef token_pointer *text_pointer;

@ The first position of |tok_mem| that is unoccupied by replacement text is called |tok_ptr|, and the first unused location of |tok_start| is called |text_ptr|. Thus, we usually have |*text_ptr==tok_ptr|.

@&lt;Global variables@&gt;=
token tok_mem[max_toks]; /* tokens */
token_pointer tok_mem_end = tok_mem+max_toks-1; /* end of |tok_mem| */
token_pointer tok_start[max_texts]; /* directory into |tok_mem| */
token_pointer tok_ptr; /* first unused position in |tok_mem| */
text_pointer text_ptr; /* first unused position in |tok_start| */
text_pointer tok_start_end = tok_start+max_texts-1; /* end of |tok_start| */
token_pointer max_tok_ptr; /* largest value of |tok_ptr| */
text_pointer max_text_ptr; /* largest value of |text_ptr| */

@ @&lt;Set init...@&gt;=
tok_ptr=tok_mem+1; text_ptr=tok_start+1; tok_start[0]=tok_mem+1;
tok_start[1]=tok_mem+1;
max_tok_ptr=tok_mem+1; max_text_ptr=tok_start+1;@ Here are the three procedures needed to complete |id_lookup|:

@c
int names_match(p,first,l,t)
name_pointer p; /* points to the proposed match */
char *first; /* position of first character of string */
int l; /* length of identifier */
eight_bits t; /* desired ilk */
{
  if (length(p)!=l) return 0;
  if (p-&gt;ilk!=t &amp;&amp; !(t==normal &amp;&amp; abnormal(p))) return 0;
  return !strncmp(first,p-&gt;byte_start,l);
}

void
init_p(p,t)
name_pointer p;
eight_bits t;
{
  p-&gt;ilk=t; p-&gt;xref=(char*)xmem;
}

void
init_node(p)
name_pointer p;
{
  p-&gt;xref=(char*)xmem;
}@* Lexical scanning. Let us now consider the subroutines that read the \.{CWEB} source file and break it into meaningful units. There are four such procedures: One simply skips to the next `\.{@@\ }' or `\.{@

@*}' that begins a
section; another passes over the \TEX/ text at the beginning of a
section; the third passes over the \TEX/ text in a \CEE/ comment;
and the last, which is the most interesting, gets the next token of
a \CEE/ text.  They all use the pointers |limit| and |loc| into
the line of input currently being studied.@ Control codes in \.{CWEB}, which begin with `\.{@@}', are converted into a numeric code designed to simplify \.{CWEAVE}'s logic; for example, larger numbers are given to the control codes that denote more significant milestones, and the code of |new_section| should be the largest of all. Some of these numeric control codes take the place of |char| control codes that will not otherwise appear in the output of the scanning routines. @^ASCII code dependencies@&gt;

@d ignore 00 /* control code of no interest to \.{CWEAVE} */
@d verbatim 02 /* takes the place of extended ASCII \.{\char2} */
@d begin_short_comment 03 /* \CPLUSPLUS/ short comment */
@d begin_comment '\t' /* tab marks will not appear */
@d underline '\n' /* this code will be intercepted without confusion */
@d noop 0177 /* takes the place of ASCII delete */
@d xref_roman 0203 /* control code for `\.{@@\^}' */
@d xref_wildcard 0204 /* control code for `\.{@@:}' */
@d xref_typewriter 0205 /* control code for `\.{@@.}' */
@d TeX_string 0206 /* control code for `\.{@@t}' */
@f TeX_string TeX
@d ord 0207 /* control code for `\.{@@'}' */
@d join 0210 /* control code for `\.{@@\&amp;}' */
@d thin_space 0211 /* control code for `\.{@@,}' */
@d math_break 0212 /* control code for `\.{@@\v}' */
@d line_break 0213 /* control code for `\.{@@/}' */
@d big_line_break 0214 /* control code for `\.{@@\#}' */
@d no_line_break 0215 /* control code for `\.{@@+}' */
@d pseudo_semi 0216 /* control code for `\.{@@;}' */
@d macro_arg_open 0220 /* control code for `\.{@@[}' */
@d macro_arg_close 0221 /* control code for `\.{@@]}' */
@d trace 0222 /* control code for `\.{@@0}', `\.{@@1}' and `\.{@@2}' */
@d translit_code 0223 /* control code for `\.{@@l}' */
@d output_defs_code 0224 /* control code for `\.{@@h}' */
@d format_code 0225 /* control code for `\.{@@f}' and `\.{@@s}' */
@d definition 0226 /* control code for `\.{@@d}' */
@d begin_C 0227 /* control code for `\.{@@c}' */
@d section_name 0230 /* control code for `\.{@@&lt;}' */
@d new_section 0231 /* control code for `\.{@@\ }' and `\.{@@*}' */

@ Control codes are converted to \.{CWEAVE}'s internal representation by means of the table |ccode|.

@&lt;Global variables@&gt;=
eight_bits ccode[256]; /* meaning of a char following \.{@@} */

@ @&lt;Set ini...@&gt;=
{int c; for (c=0; c&lt;256; c++) ccode[c]=0;}
ccode[' ']=ccode['\t']=ccode['\n']=ccode['\v']=ccode['\r']=ccode['\f']
   =ccode['*']=new_section;
ccode['@@']='@@'; /* `quoted' at sign */
ccode['=']=verbatim;
ccode['d']=ccode['D']=definition;
ccode['f']=ccode['F']=ccode['s']=ccode['S']=format_code;
ccode['c']=ccode['C']=ccode['p']=ccode['P']=begin_C;
ccode['t']=ccode['T']=TeX_string;
ccode['l']=ccode['L']=translit_code;
ccode['q']=ccode['Q']=noop;
ccode['h']=ccode['H']=output_defs_code;
ccode['&amp;']=join; ccode['&lt;']=ccode['(']=section_name;
ccode['!']=underline; ccode['^']=xref_roman;
ccode[':']=xref_wildcard; ccode['.']=xref_typewriter; ccode[',']=thin_space;
ccode['|']=math_break; ccode['/']=line_break; ccode['#']=big_line_break;
ccode['+']=no_line_break; ccode[';']=pseudo_semi;
ccode['[']=macro_arg_open; ccode[']']=macro_arg_close;
ccode['\'']=ord;
@&lt;Special control codes for debugging@&gt;@;

@ Users can write \.{@@2}, \.{@@1}, and \.{@@0} to turn tracing fully on, partly on, and off, respectively.

@&lt;Special control codes for debugging@&gt;=
ccode['0']=ccode['1']=ccode['2']=trace;
@ The |skip_limbo| routine is used on the first pass to skip through portions of the input that are not in any sections, i.e., that precede the first section. After this procedure has been called, the value of |input_has_ended| will tell whether or not a section has actually been found.  There's a complication that we will postpone until later: If the \.{@@s} operation appears in limbo, we want to use it to adjust the default interpretation of identifiers.

@&lt;Predeclaration of procedures@&gt;=
void skip_limbo();

@ @c
void
skip_limbo() {
  while(1) {
    if (loc&gt;limit &amp;&amp; get_line()==0) return;
    *(limit+1)='@@';
    while (*loc!='@@') loc++; /* look for '@@', then skip two chars */
    if (loc++ &lt;=limit) { int c=ccode[(eight_bits)*loc++];
      if (c==new_section) return;
      if (c==noop) skip_restricted();
      else if (c==format_code) @&lt;Process simple format in limbo@&gt;;
    }
  }
}
@ During the definition and \CEE/ parts of a section, cross-references are made for all identifiers except reserved words. However, the right identifier in a format definition is not referenced, and the left identifier is referenced only if it has been explicitly underlined (preceded by \.{@@!}). The \TEX/ code in comments is, of course, ignored, except for \CEE/ portions enclosed in \pb; the text of a section name is skipped entirely, even if it contains \pb\ constructions.  The variables |lhs| and |rhs| point to the respective identifiers involved in a format definition.

@&lt;Global variables@&gt;=
name_pointer lhs, rhs; /* pointers to |byte_start| for format identifiers */
name_pointer res_wd_end; /* pointer to the first nonreserved identifier */

@ A much simpler processing of format definitions occurs when the definition is found in limbo.

@&lt;Process simple format in limbo@&gt;=
{
  if (get_next()!=identifier)
    err_print("! Missing left identifier of @@s");
@.Missing left identifier...@&gt;
  else {
    lhs=id_lookup(id_first,id_loc,normal);
    if (get_next()!=identifier)
      err_print("! Missing right identifier of @@s");
@.Missing right identifier...@&gt;
    else {
      rhs=id_lookup(id_first,id_loc,normal);
      lhs-&gt;ilk=rhs-&gt;ilk;
    }
  }
}
@ The |skip_TeX| routine is used on the first pass to skip through the \TEX/ code at the beginning of a section. It returns the next control code or `\.{\v}' found in the input. A |new_section| is assumed to exist at the very end of the file.

@f skip_TeX TeX

@c
unsigned
skip_TeX() /* skip past pure \TEX/ code */
{
  while (1) {
    if (loc&gt;limit &amp;&amp; get_line()==0) return(new_section);
    *(limit+1)='@@';
    while (*loc!='@@' &amp;&amp; *loc!='|') loc++;
    if (*loc++ =='|') return('|');
    if (loc&lt;=limit) return(ccode[(eight_bits)*(loc++)]);
  }
}@*1 Inputting the next token. As stated above, \.{CWEAVE}'s most interesting lexical scanning routine is the |get_next| function that inputs the next token of \CEE/ input. However, |get_next| is not especially complicated.  The result of |get_next| is either a |char| code for some special character, or it is a special code representing a pair of characters (e.g., `\.{!=}'), or it is the numeric value computed by the |ccode| table, or it is one of the following special codes:  \yskip\hang |identifier|: In this case the global variables |id_first| and |id_loc| will have been set to the beginning and ending-plus-one locations in the buffer, as required by the |id_lookup| routine.  \yskip\hang |string|: The string will have been copied into the array |section_text|; |id_first| and |id_loc| are set as above (now they are pointers into |section_text|).  \yskip\hang |constant|: The constant is copied into |section_text|, with slight modifications; |id_first| and |id_loc| are set.  \yskip\noindent Furthermore, some of the control codes cause |get_next| to take additional actions:  \yskip\hang |xref_roman|, |xref_wildcard|, |xref_typewriter|, |TeX_string|, |verbatim|: The values of |id_first| and |id_loc| will have been set to the beginning and ending-plus-one locations in the buffer.  \yskip\hang |section_name|: In this case the global variable |cur_section| will point to the |byte_start| entry for the section name that has just been scanned. The value of |cur_section_char| will be |'('| if the section name was preceded by \.{@@(} instead of \.{@

@&lt;}.

\yskip\noindent If |get_next| sees `\.{@@!}'
it sets |xref_switch| to |def_flag| and goes on to the next token.

@d constant 0200 /* \CEE/ constant */
@d string 0201 /* \CEE/ string */
@d identifier 0202 /* \CEE/ identifier or reserved word */

@&lt;Global variables@&gt;=
name_pointer cur_section; /* name of section just scanned */
char cur_section_char; /* the character just before that name */@ @&lt;Include...@&gt;=
#include &lt;ctype.h&gt; /* definition of |isalpha|, |isdigit| and so on */
#include &lt;stdlib.h&gt; /* definition of |exit| */
@ As one might expect, |get_next| consists mostly of a big switch that branches to the various special cases that can arise. \CEE/ allows underscores to appear in identifiers, and some \CEE/ compilers even allow the dollar sign.

@d isxalpha(c) ((c)=='_' || (c)=='$')
   /* non-alpha characters allowed in identifier */
@d ishigh(c) ((eight_bits)(c)&gt;0177)
@^high-bit character handling@&gt;

@&lt;Predeclaration of procedures@&gt;=
eight_bits get_next();
@ @c
eight_bits
get_next() /* produces the next input token */
{@+eight_bits c; /* the current character */
  while (1) {
    @&lt;Check if we're at the end of a preprocessor command@&gt;;
    if (loc&gt;limit &amp;&amp; get_line()==0) return(new_section);
    c=*(loc++);
    if (xisdigit(c) || c=='\\' || c=='.') @&lt;Get a constant@&gt;@;
    else if (c=='\'' || c=='"' || (c=='L'&amp;&amp;(*loc=='\'' || *loc=='"'))@|
           || (c=='&lt;' &amp;&amp; sharp_include_line==1))
        @&lt;Get a string@&gt;@;
    else if (xisalpha(c) || isxalpha(c) || ishigh(c))
      @&lt;Get an identifier@&gt;@;
    else if (c=='@@') @&lt;Get control code and possible section name@&gt;@;
    else if (xisspace(c)) continue; /* ignore spaces and tabs */
    if (c=='#' &amp;&amp; loc==buffer+1) @&lt;Raise preprocessor flag@&gt;;
    mistake: @&lt;Compress two-symbol operator@&gt;@;
    return(c);
  }
}
@ Because preprocessor commands do not fit in with the rest of the syntax of \CEE/, we have to deal with them separately.  One solution is to enclose such commands between special markers.  Thus, when a \.\# is seen as the first character of a line, |get_next| returns a special code |left_preproc| and raises a flag |preprocessing|.  We can use the same internal code number for |left_preproc| as we do for |ord|, since |get_next| changes |ord| into a string.

@d left_preproc ord /* begins a preprocessor command */
@d right_preproc 0217 /* ends a preprocessor command */

@&lt;Global variables@&gt;=
boolean preprocessing=0; /* are we scanning a preprocessor command? */

@ @&lt;Raise prep...@&gt;= {
  preprocessing=1;
  @&lt;Check if next token is |include|@&gt;;
  return (left_preproc);
}
@ An additional complication is the freakish use of \.&lt; and \.&gt; to delimit a file name in lines that start with \.{\#include}.  We must treat this file name as a string.

@&lt;Global variables@&gt;=
boolean sharp_include_line=0; /* are we scanning a |#include| line? */

@ @&lt;Check if next token is |include|@&gt;=
while (loc&lt;=buffer_end-7 &amp;&amp; xisspace(*loc)) loc++;
if (loc&lt;=buffer_end-6 &amp;&amp; strncmp(loc,"include",7)==0) sharp_include_line=1;
@ When we get to the end of a preprocessor line, we lower the flag and send a code |right_preproc|, unless the last character was a \.\\.

@&lt;Check if we're at the end of a preprocessor command@&gt;=
  while (loc==limit-1 &amp;&amp; preprocessing &amp;&amp; *loc=='\\')
    if (get_line()==0) return(new_section); /* still in preprocessor mode */
  if (loc&gt;=limit &amp;&amp; preprocessing) {
    preprocessing=sharp_include_line=0;
    return(right_preproc);
  }
@ The following code assigns values to the combinations
\.{++}, \.{--}, \.{-&gt;}, \.{&gt;=}, \.{&lt;=}, \.{==}, \.{&lt;&lt;},
\.{&gt;&gt;}, \.{!=}, \.{\v\v}, and \.{\&amp;\&amp;}, and to the \CPLUSPLUS/ combinations \.{...}, \.{::}, \.{.*} and \.{-&gt;*}. The compound assignment operators (e.g., \.{+=}) are treated as separate tokens.

@d compress(c) if (loc++&lt;=limit) return(c)

@&lt;Compress two-symbol operator@&gt;=
switch(c) {
  case '/': if (*loc=='*') {compress(begin_comment);}
    else if (*loc=='/') compress(begin_short_comment); break;
  case '+': if (*loc=='+') compress(plus_plus); break;
  case '-': if (*loc=='-') {compress(minus_minus);}
    else if (*loc=='&gt;') if (*(loc+1)=='*') {loc++; compress(minus_gt_ast);}
                        else compress(minus_gt); break;
  case '.': if (*loc=='*') {compress(period_ast);}
            else if (*loc=='.' &amp;&amp; *(loc+1)=='.') {
              loc++; compress(dot_dot_dot);
            }
            break;
  case ':': if (*loc==':') compress(colon_colon); break;
  case '=': if (*loc=='=') compress(eq_eq); break;
  case '&gt;': if (*loc=='=') {compress(gt_eq);}
    else if (*loc=='&gt;') compress(gt_gt); break;
  case '&lt;': if (*loc=='=') {compress(lt_eq);}
    else if (*loc=='&lt;') compress(lt_lt); break;
  case '&amp;': if (*loc=='&amp;') compress(and_and); break;
  case '|': if (*loc=='|') compress(or_or); break;
  case '!': if (*loc=='=') compress(not_eq); break;
}
@ @&lt;Get an identifier@&gt;= {
  id_first=--loc;
  while (isalpha(*++loc) || isdigit(*loc) || isxalpha(*loc) || ishigh(*loc));
  id_loc=loc; return(identifier);
}
@ Different conventions are followed by \TEX/ and \CEE/ to express octal and hexadecimal numbers; it is reasonable to stick to each convention within its realm.  Thus the \CEE/ part of a \.{CWEB} file has octals introduced by \.0 and hexadecimals by \.{0x}, but \.{CWEAVE} will print with \TeX/ macros that the user can redefine to fit the context. In order to simplify such macros, we replace some of the characters.  Notice that in this section and the next, |id_first| and |id_loc| are pointers into the array |section_text|, not into |buffer|.

@&lt;Get a constant@&gt;= {
  id_first=id_loc=section_text+1;
  if (*(loc-1)=='\\') {*id_loc++='~';
  while (xisdigit(*loc)) *id_loc++=*loc++;} /* octal constant */
  else if (*(loc-1)=='0') {
    if (*loc=='x' || *loc=='X') {*id_loc++='^'; loc++;
      while (xisxdigit(*loc)) *id_loc++=*loc++;} /* hex constant */
    else if (xisdigit(*loc)) {*id_loc++='~';
      while (xisdigit(*loc)) *id_loc++=*loc++;} /* octal constant */
    else goto dec; /* decimal constant */
  }
  else { /* decimal constant */
    if (*(loc-1)=='.' &amp;&amp; !xisdigit(*loc)) goto mistake; /* not a constant */
    dec: *id_loc++=*(loc-1);
    while (xisdigit(*loc) || *loc=='.') *id_loc++=*loc++;
    if (*loc=='e' || *loc=='E') { /* float constant */
      *id_loc++='_'; loc++;
      if (*loc=='+' || *loc=='-') *id_loc++=*loc++;
      while (xisdigit(*loc)) *id_loc++=*loc++;
    }
  }
  while (*loc=='u' || *loc=='U' || *loc=='l' || *loc=='L'
         || *loc=='f' || *loc=='F') {
    *id_loc++='$'; *id_loc++=toupper(*loc); loc++;
  }
  return(constant);
}
@ \CEE/ strings and character constants, delimited by double and single quotes, respectively, can contain newlines or instances of their own delimiters if they are protected by a backslash.  We follow this convention, but do not allow the string to be longer than |longest_name|.

@&lt;Get a string@&gt;= {
  char delim = c; /* what started the string */
  id_first = section_text+1;
  id_loc = section_text;
  if (delim=='\'' &amp;&amp; *(loc-2)=='@@') {*++id_loc='@@'; *++id_loc='@@';}
  *++id_loc=delim;
  if (delim=='L') { /* wide character constant */
    delim=*loc++; *++id_loc=delim;
  }
  if (delim=='&lt;') delim='&gt;'; /* for file names in |#include| lines */
  while (1) {
    if (loc&gt;=limit) {
      if(*(limit-1)!='\\') {
        err_print("! String didn't end"); loc=limit; break;
@.String didn't end@&gt;
      }
      if(get_line()==0) {
        err_print("! Input ended in middle of string"); loc=buffer; break;
@.Input ended in middle of string@&gt;
      }
    }
    if ((c=*loc++)==delim) {
      if (++id_loc&lt;=section_text_end) *id_loc=c;
      break;
    }
    if (c=='\\') if (loc&gt;=limit) continue;
      else if (++id_loc&lt;=section_text_end) {
        *id_loc = '\\'; c=*loc++;
      }
    if (++id_loc&lt;=section_text_end) *id_loc=c;
  }
  if (id_loc&gt;=section_text_end) {
    printf("\n! String too long: ");
@.String too long@&gt;
    term_write(section_text+1,25);
    printf("..."); mark_error;
  }
  id_loc++;
  return(string);
}
@ After an \.{@@} sign has been scanned, the next character tells us whether there is more work to do.

@&lt;Get control code and possible section name@&gt;= {
  c=*loc++;
  switch(ccode[(eight_bits)c]) {
    case translit_code: err_print("! Use @@l in limbo only"); continue;
@.Use @@l in limbo...@&gt;
    case underline: xref_switch=def_flag; continue;
    case trace: tracing=c-'0'; continue;
    case xref_roman: case xref_wildcard: case xref_typewriter:
    case noop: case TeX_string: c=ccode[c]; skip_restricted(); return(c);
    case section_name:
      @&lt;Scan the section name and make |cur_section| point to it@&gt;;
    case verbatim: @&lt;Scan a verbatim string@&gt;;
    case ord: @&lt;Get a string@&gt;;
    default: return(ccode[(eight_bits)c]);
  }
}
@ The occurrence of a section name sets |xref_switch| to zero, because the section name might (for example) follow \&amp;{int}.

@&lt;Scan the section name and make |cur_section| point to it@&gt;= {
  char *k; /* pointer into |section_text| */
  cur_section_char=*(loc-1);
  @&lt;Put section name into |section_text|@&gt;;
  if (k-section_text&gt;3 &amp;&amp; strncmp(k-2,"...",3)==0)
        cur_section=section_lookup(section_text+1,k-3,1); /* 1 indicates a prefix */
  else cur_section=section_lookup(section_text+1,k,0);
  xref_switch=0; return(section_name);
}
@ At the present point in the program we have |*(loc-1)==verbatim|; we set |id_first| to the beginning of the string itself, and |id_loc| to its ending-plus-one location in the buffer.  We also set |loc| to the position just after the ending delimiter.

@&lt;Scan a verbatim string@&gt;= {
  id_first=loc++; *(limit+1)='@@'; *(limit+2)='&gt;';
  while (*loc!='@@' || *(loc+1)!='&gt;') loc++;
  if (loc&gt;=limit) err_print("! Verbatim string didn't end");
@.Verbatim string didn't end@&gt;
  id_loc=loc; loc+=2;
  return (verbatim);
}
@ Section names are placed into the |section_text| array with consecutive spaces, tabs, and carriage-returns replaced by single spaces. There will be no spaces at the beginning or the end. (We set |section_text[0]=' '| to facilitate this, since the |section_lookup| routine uses |section_text[1]| as the first character of the name.)

@&lt;Set initial values@&gt;=section_text[0]=' ';

@ @&lt;Put section name...@&gt;=
k=section_text;
while (1) {
  if (loc&gt;limit &amp;&amp; get_line()==0) {
    err_print("! Input ended in section name");
@.Input ended in section name@&gt;
    loc=buffer+1; break;
  }
  c=*loc;
  @&lt;If end of name or erroneous control code, |break|@&gt;;
  loc++; if (k&lt;section_text_end) k++;
  if (xisspace(c)) {
    c=' '; if (*(k-1)==' ') k--;
  }
*k=c;
}
if (k&gt;=section_text_end) {
  printf("\n! Section name too long: ");
@.Section name too long@&gt;
  term_write(section_text+1,25);
  printf("..."); mark_harmless;
}
if (*k==' ' &amp;&amp; k&gt;section_text) k--;
@ @&lt;If end of name...@&gt;=
if (c=='@@') {
  c=*(loc+1);
  if (c=='&gt;') {
    loc+=2; break;
  }
  if (ccode[(eight_bits)c]==new_section) {
    err_print("! Section name didn't end"); break;
@.Section name didn't end@&gt;
  }
  if (c!='@@') {
    err_print("! Control codes are forbidden in section name"); break;
@.Control codes are forbidden...@&gt;
  }
  *(++k)='@@'; loc++; /* now |c==*loc| again */
}
@ This function skips over a restricted context at relatively high speed.

@&lt;Predeclaration of procedures@&gt;=
void skip_restricted();

@ @c
void
skip_restricted()
{
  id_first=loc; *(limit+1)='@@';
false_alarm:
  while (*loc!='@@') loc++;
  id_loc=loc;
  if (loc++&gt;limit) {
    err_print("! Control text didn't end"); loc=limit;
@.Control text didn't end@&gt;
  }
  else {
    if (*loc=='@@'&amp;&amp;loc&lt;=limit) {loc++; goto false_alarm;}
    if (*loc++!='&gt;')
      err_print("! Control codes are forbidden in control text");
@.Control codes are forbidden...@&gt;
  }
}
@** Phase one processing. We now have accumulated enough subroutines to make it possible to carry out \.{CWEAVE}'s first pass over the source file. If everything works right, both phase one and phase two of \.{CWEAVE} will assign the same numbers to sections, and these numbers will agree with what \.{CTANGLE} does.  The global variable |next_control| often contains the most recent output of |get_next|; in interesting cases, this will be the control code that ended a section or part of a section.

@&lt;Global variables@&gt;=
eight_bits next_control; /* control code waiting to be acting upon */@ The overall processing strategy in phase one has the following straightforward outline.

@&lt;Predeclaration of procedures@&gt;=
void phase_one();

@ @c
void
phase_one() {
  phase=1; reset_input(); section_count=0;
  skip_limbo(); change_exists=0;
  while (!input_has_ended)
    @&lt;Store cross-reference data for the current section@&gt;;
  changed_section[section_count]=change_exists;
    /* the index changes if anything does */
  phase=2; /* prepare for second phase */
  @&lt;Print error messages about unused or undefined section names@&gt;;
}
@ @&lt;Store cross-reference data...@&gt;=
{
  if (++section_count==max_sections) overflow("section number");
  changed_section[section_count]=changing;
     /* it will become 1 if any line changes */
  if (*(loc-1)=='*' &amp;&amp; show_progress) {
    printf("*%d",section_count);
    update_terminal; /* print a progress report */
  }
  @&lt;Store cross-references in the \TEX/ part of a section@&gt;;
  @&lt;Store cross-references in the definition part of a section@&gt;;
  @&lt;Store cross-references in the \CEE/ part of a section@&gt;;
  if (changed_section[section_count]) change_exists=1;
}
@ In the \TEX/ part of a section, cross-reference entries are made only for the identifiers in \CEE/ texts enclosed in \pb, or for control texts enclosed in \.{@@\^}$\,\ldots\,$\.{@@&gt;} or \.{@@.}$\,\ldots\,$\.{@@&gt;} or \.{@@:}$\,\ldots\,$\.{@@&gt;}.

@&lt;Store cross-references in the \TEX/ part of a section@&gt;=
while (1) {
  switch (next_control=skip_TeX()) {
    case translit_code: err_print("! Use @@l in limbo only"); continue;
@.Use @@l in limbo...@&gt;
    case underline: xref_switch=def_flag; continue;
    case trace: tracing=*(loc-1)-'0'; continue;
    case '|': C_xref(section_name); break;
    case xref_roman: case xref_wildcard: case xref_typewriter:
    case noop: case section_name:
      loc-=2; next_control=get_next(); /* scan to \.{@@&gt;} */
      if (next_control&gt;=xref_roman &amp;&amp; next_control&lt;=xref_typewriter) {
        @&lt;Replace |"@@@@"| by |"@@"| @&gt;@;
        new_xref(id_lookup(id_first, id_loc,next_control-identifier));
      }
      break;
  }
  if (next_control&gt;=format_code) break;
}
@ @&lt;Replace |"@@@@"| by |"@@"| @&gt;=
{
  char *src=id_first,*dst=id_first;
  while(src&lt;id_loc){
    if(*src=='@@') src++;
    *dst++=*src++;
  }
  id_loc=dst;
  while (dst&lt;src) *dst++=' '; /* clean up in case of error message display */
}
@ When we get to the following code we have |next_control&gt;=format_code|.

@&lt;Store cross-references in the definition part of a section@&gt;=
while (next_control&lt;=definition) { /* |format_code| or |definition| */
  if (next_control==definition) {
    xref_switch=def_flag; /* implied \.{@@!} */
    next_control=get_next();
  } else @&lt;Process a format definition@&gt;;
  outer_xref();
}
@ Error messages for improper format definitions will be issued in phase two. Our job in phase one is to define the |ilk| of a properly formatted identifier, and to remove cross-references to identifiers that we now discover should be unindexed.

@&lt;Process a format definition@&gt;= {
  next_control=get_next();
  if (next_control==identifier) {
    lhs=id_lookup(id_first, id_loc,normal); lhs-&gt;ilk=normal;
    if (xref_switch) new_xref(lhs);
    next_control=get_next();
    if (next_control==identifier) {
      rhs=id_lookup(id_first, id_loc,normal);
      lhs-&gt;ilk=rhs-&gt;ilk;
      if (unindexed(lhs)) { /* retain only underlined entries */
        xref_pointer q,r=NULL;
        for (q=(xref_pointer)lhs-&gt;xref;q&gt;xmem;q=q-&gt;xlink)
          if (q-&gt;num&lt;def_flag)
            if (r) r-&gt;xlink=q-&gt;xlink;
            else lhs-&gt;xref=(char*)q-&gt;xlink;
          else r=q;
      }
      next_control=get_next();
    }
  }
}
@ Finally, when the \TEX/ and definition parts have been treated, we have |next_control&gt;=begin_C|.

@&lt;Store cross-references in the \CEE/ part of a section@&gt;=
if (next_control&lt;=section_name) {  /* |begin_C| or |section_name| */
  if (next_control==begin_C) section_xref_switch=0;
  else {
    section_xref_switch=def_flag;
    if(cur_section_char=='(' &amp;&amp; cur_section!=name_dir)
      set_file_flag(cur_section);
  }
  do {
    if (next_control==section_name &amp;&amp; cur_section!=name_dir)
      new_section_xref(cur_section);
    next_control=get_next(); outer_xref();
  } while ( next_control&lt;=section_name);
}
@ @&lt;Print error messages about un...@&gt;=section_check(root)
@ The |C_xref| subroutine stores references to identifiers in \CEE/ text material beginning with the current value of |next_control| and continuing until |next_control| is `\.\{' or `\.{\v}', or until the next ``milestone'' is passed (i.e., |next_control&gt;=format_code|). If |next_control&gt;=format_code| when |C_xref| is called, nothing will happen; but if |next_control=='|'| upon entry, the procedure assumes that this is the `\.{\v}' preceding \CEE/ text that is to be processed.  The parameter |spec_ctrl| is used to change this behavior. In most cases |C_xref| is called with |spec_ctrl==ignore|, which triggers the default processing described above. If |spec_ctrl==section_name|, section names will be gobbled. This is used when \CEE/ text in the \TEX/ part or inside comments is parsed: It allows for section names to appear in \pb, but these strings will not be entered into the cross reference lists since they are not definitions of section names.  The program uses the fact that our internal code numbers satisfy the relations |xref_roman==identifier+roman| and |xref_wildcard==identifier +wildcard| and |xref_typewriter==identifier+typewriter|, as well as |normal==0|.

@&lt;Predeclaration of procedures@&gt;=
void C_xref();

@ @c
void
C_xref( spec_ctrl ) /* makes cross-references for \CEE/ identifiers */
  eight_bits spec_ctrl;
{
  name_pointer p; /* a referenced name */
  while (next_control&lt;format_code || next_control==spec_ctrl) {
    if (next_control&gt;=identifier &amp;&amp; next_control&lt;=xref_typewriter) {
      if (next_control&gt;identifier) @&lt;Replace |"@@@@"| by |"@@"| @&gt;@;
      p=id_lookup(id_first, id_loc,next_control-identifier); new_xref(p);
    }
    if (next_control==section_name) {
      section_xref_switch=cite_flag;
      new_section_xref(cur_section);
    }
    next_control=get_next();
    if (next_control=='|' || next_control==begin_comment ||
        next_control==begin_short_comment) return;
  }
}
@ The |outer_xref| subroutine is like |C_xref| except that it begins with |next_control!='|'| and ends with |next_control&gt;=format_code|. Thus, it handles \CEE/ text with embedded comments.

@&lt;Predeclaration of procedures@&gt;=
void outer_xref();

@ @c
void
outer_xref() /* extension of |C_xref| */
{
  int bal; /* brace level in comment */
  while (next_control&lt;format_code)
    if (next_control!=begin_comment &amp;&amp; next_control!=begin_short_comment)
      C_xref(ignore);
    else {
      boolean is_long_comment=(next_control==begin_comment);
      bal=copy_comment(is_long_comment,1); next_control='|';
      while (bal&gt;0) {
        C_xref(section_name); /* do not reference section names in comments */
        if (next_control=='|') bal=copy_comment(is_long_comment,bal);
        else bal=0; /* an error message will occur in phase two */
      }
    }
}
@ After phase one has looked at everything, we want to check that each section name was both defined and used.  The variable |cur_xref| will point to cross-references for the current section name of interest.

@&lt;Global variables@&gt;=
xref_pointer cur_xref; /* temporary cross-reference pointer */
boolean an_output; /* did |file_flag| precede |cur_xref|? */

@ The following recursive procedure walks through the tree of section names and prints out anomalies. @^recursion@&gt;

@&lt;Predeclaration of procedures@&gt;=
void section_check();

@ @c
void
section_check(p)
name_pointer p; /* print anomalies in subtree |p| */
{
  if (p) {
    section_check(p-&gt;llink);
    cur_xref=(xref_pointer)p-&gt;xref;
    if (cur_xref-&gt;num==file_flag) {an_output=1; cur_xref=cur_xref-&gt;xlink;}
    else an_output=0;
    if (cur_xref-&gt;num &lt;def_flag) {
      printf("\n! Never defined: &lt;"); print_section_name(p); putchar('&gt;'); mark_harmless;
@.Never defined: &lt;section name&gt;@&gt;
    }
    while (cur_xref-&gt;num &gt;=cite_flag) cur_xref=cur_xref-&gt;xlink;
    if (cur_xref==xmem &amp;&amp; !an_output) {
      printf("\n! Never used: &lt;"); print_section_name(p); putchar('&gt;'); mark_harmless;
@.Never used: &lt;section name&gt;@&gt;
    }
    section_check(p-&gt;rlink);
  }
}
@* Low-level output routines. The \TEX/ output is supposed to appear in lines at most |line_length| characters long, so we place it into an output buffer. During the output process, |out_line| will hold the current line number of the line about to be output.

@&lt;Global variables@&gt;=
char out_buf[line_length+1]; /* assembled characters */
char *out_ptr; /* just after last character in |out_buf| */
char *out_buf_end = out_buf+line_length; /* end of |out_buf| */
int out_line; /* number of next line to be output */@ The |flush_buffer| routine empties the buffer up to a given breakpoint, and moves any remaining characters to the beginning of the next line. If the |per_cent| parameter is 1 a |'%'| is appended to the line that is being output; in this case the breakpoint |b| should be strictly less than |out_buf_end|. If the |per_cent| parameter is |0|, trailing blanks are suppressed. The characters emptied from the buffer form a new line of output; if the |carryover| parameter is true, a |"%"| in that line will be carried over to the next line (so that \TEX/ will ignore the completion of commented-out text).

@d c_line_write(c) fflush(active_file),fwrite(out_buf+1,sizeof(char),c,active_file)
@d tex_putc(c) putc(c,active_file)
@d tex_new_line putc('\n',active_file)
@d tex_printf(c) fprintf(active_file,c)

@c
void
flush_buffer(b,per_cent,carryover)
char *b;  /* outputs from |out_buf+1| to |b|,where |b&lt;=out_ptr| */
boolean per_cent,carryover;
{
  char *j; j=b; /* pointer into |out_buf| */
  if (! per_cent) /* remove trailing blanks */
    while (j&gt;out_buf &amp;&amp; *j==' ') j--;
  c_line_write(j-out_buf);
  if (per_cent) tex_putc('%');
  tex_new_line; out_line++;
  if (carryover)
    while (j&gt;out_buf)
      if (*j--=='%' &amp;&amp; (j==out_buf || *j!='\\')) {
        *b--='%'; break;
      }
  if (b&lt;out_ptr) strncpy(out_buf+1,b+1,out_ptr-b);
  out_ptr-=b-out_buf;
}@ When we are copying \TEX/ source material, we retain line breaks that occur in the input, except that an empty line is not output when the \TEX/ source line was nonempty. For example, a line of the \TEX/ file that contains only an index cross-reference entry will not be copied. The |finish_line| routine is called just before |get_line| inputs a new line, and just after a line break token has been emitted during the output of translated \CEE/ text.

@c
void
finish_line() /* do this at the end of a line */
{
  char *k; /* pointer into |buffer| */
  if (out_ptr&gt;out_buf) flush_buffer(out_ptr,0,0);
  else {
    for (k=buffer; k&lt;=limit; k++)
      if (!(xisspace(*k))) return;
    flush_buffer(out_buf,0,0);
  }
}@ In particular, the |finish_line| procedure is called near the very beginning of phase two. We initialize the output variables in a slightly tricky way so that the first line of the output file will be `\.{\\input cwebmac}'.

@&lt;Set initial values@&gt;=
out_ptr=out_buf+1; out_line=1; active_file=tex_file;
*out_ptr='c'; tex_printf("\\input cwebma");
@ When we wish to append one character |c| to the output buffer, we write `|out(c)|'; this will cause the buffer to be emptied if it was already full.  If we want to append more than one character at once, we say |out_str(s)|, where |s| is a string containing the characters.  A line break will occur at a space or after a single-nonletter \TEX/ control sequence.

@d out(c) {if (out_ptr&gt;=out_buf_end) break_out(); *(++out_ptr)=c;}

@c
void
out_str(s) /* output characters from |s| to end of string */
char *s;
{
  while (*s) out(*s++);
}@ The |break_out| routine is called just before the output buffer is about to overflow. To make this routine a little faster, we initialize position 0 of the output buffer to `\.\\'; this character isn't really output.

@&lt;Set initial values@&gt;=
out_buf[0]='\\';

@ A long line is broken at a blank space or just before a backslash that isn't preceded by another backslash. In the latter case, a |'%'| is output at the break.

@&lt;Predeclaration of procedures@&gt;=
void break_out();

@ @c
void
break_out() /* finds a way to break the output line */
{
  char *k=out_ptr; /* pointer into |out_buf| */
  while (1) {
    if (k==out_buf) @&lt;Print warning message, break the line, |return|@&gt;;
    if (*k==' ') {
      flush_buffer(k,0,1); return;
    }
    if (*(k--)=='\\' &amp;&amp; *k!='\\') { /* we've decreased |k| */
      flush_buffer(k,1,1); return;
    }
  }
}
@ We get to this section only in the unusual case that the entire output line consists of a string of backslashes followed by a string of nonblank non-backslashes. In such cases it is almost always safe to break the line by putting a |'%'| just before the last character.

@&lt;Print warning message, break the line, |return|@&gt;=
{
  printf("\n! Line had to be broken (output l. %d):\n",out_line);
@.Line had to be broken@&gt;
  term_write(out_buf+1, out_ptr-out_buf-1);
  new_line; mark_harmless;
  flush_buffer(out_ptr-1,1,1); return;
}
@ Here is a macro that outputs a section number in decimal notation. The number to be converted by |out_section| is known to be less than |def_flag|, so it cannot have more than five decimal digits.  If the section is changed, we output `\.{\\*}' just after the number.

@c
void
out_section(n)
sixteen_bits n;
{
  char s[6];
  sprintf(s,"%d",n); out_str(s);
  if(changed_section[n]) out_str ("\\*");
@.\\*@&gt;
}@ The |out_name| procedure is used to output an identifier or index entry, enclosing it in braces.

@c
void
out_name(p,quote_xalpha)
name_pointer p;
boolean quote_xalpha;
{
  char *k, *k_end=(p+1)-&gt;byte_start; /* pointers into |byte_mem| */
  out('{');
  for (k=p-&gt;byte_start; k&lt;k_end; k++) {
    if (isxalpha(*k) &amp;&amp; quote_xalpha) out('\\');
@.\\\$@&gt;
@.\\\_@&gt;
    out(*k);
  }
  out('}');
}@* Routines that copy \TEX/ material. During phase two, we use subroutines |copy_limbo|, |copy_TeX|, and |copy_comment| in place of the analogous |skip_limbo|, |skip_TeX|, and |skip_comment| that were used in phase one. (Well, |copy_comment| was actually written in such a way that it functions as |skip_comment| in phase one.)  The |copy_limbo| routine, for example, takes \TEX/ material that is not part of any section and transcribes it almost verbatim to the output file. The use of `\.{@@}' signs is severely restricted in such material: `\.{@@@@}' pairs are replaced by singletons; `\.{@@l}' and `\.{@@q}' and `\.{@@s}' are interpreted.

@c
void
copy_limbo()
{
  char c;
  while (1) {
    if (loc&gt;limit &amp;&amp; (finish_line(), get_line()==0)) return;
    *(limit+1)='@@';
    while (*loc!='@@') out(*(loc++));
    if (loc++&lt;=limit) {
      c=*loc++;
      if (ccode[(eight_bits)c]==new_section) break;
      switch (ccode[(eight_bits)c]) {
        case translit_code: out_str("\\ATL"); break;
@.\\ATL@&gt;
        case '@@': out('@@'); break;
        case noop: skip_restricted(); break;
        case format_code: if (get_next()==identifier) get_next();
          if (loc&gt;=limit) get_line(); /* avoid blank lines in output */
          break; /* the operands of \.{@@s} are ignored on this pass */
        default: err_print("! Double @@ should be used in limbo");
@.Double @@ should be used...@&gt;
        out('@@');
      }
    }
  }
}@ The |copy_TeX| routine processes the \TEX/ code at the beginning of a
section; for example, the words you are now reading were copied in this
way. It returns the next control code or `\.{\v}' found in the input.
We don't copy spaces or tab marks into the beginning of a line. This
makes the test for empty lines in |finish_line| work.

@ @f copy_TeX TeX
@c
eight_bits
copy_TeX()
{
  char c; /* current character being copied */
  while (1) {
    if (loc&gt;limit &amp;&amp; (finish_line(), get_line()==0)) return(new_section);
    *(limit+1)='@@';
    while ((c=*(loc++))!='|' &amp;&amp; c!='@@') {
      out(c);
      if (out_ptr==out_buf+1 &amp;&amp; (xisspace(c))) out_ptr--;
    }
    if (c=='|') return('|');
    if (loc&lt;=limit) return(ccode[(eight_bits)*(loc++)]);
  }
}@ The |copy_comment| function issues a warning if more braces are opened than closed, and in the case of a more serious error it supplies enough braces to keep \TEX/ from complaining about unbalanced braces. Instead of copying the \TEX/ material into the output buffer, this function copies it into the token memory (in phase two only). The abbreviation |app_tok(t)| is used to append token |t| to the current token list, and it also makes sure that it is possible to append at least one further token without overflow.

@d app_tok(c) {if (tok_ptr+2&gt;tok_mem_end) overflow("token"); *(tok_ptr++)=c;}

@&lt;Predeclaration of procedures@&gt;=
int copy_comment();

@ @c
int copy_comment(is_long_comment,bal) /* copies \TEX/ code in comments */
boolean is_long_comment; /* is this a traditional \CEE/ comment? */
int bal; /* brace balance */
{
  char c; /* current character being copied */
  while (1) {
    if (loc&gt;limit) {
      if (is_long_comment) {
        if (get_line()==0) {
          err_print("! Input ended in mid-comment");
@.Input ended in mid-comment@&gt;
          loc=buffer+1; goto done;
        }
      }
      else {
        if (bal&gt;1) err_print("! Missing } in comment");
@.Missing \} in comment@&gt;
        goto done;
      }
    }
    c=*(loc++);
    if (c=='|') return(bal);
    if (is_long_comment) @&lt;Check for end of comment@&gt;;
    if (phase==2) {
      if (ishigh(c)) app_tok(quoted_char);
      app_tok(c);
    }
    @&lt;Copy special things when |c=='@@', '\\'|@&gt;;
    if (c=='{') bal++;
    else if (c=='}') {
      if(bal&gt;1) bal--;
      else {err_print("! Extra } in comment");
@.Extra \} in comment@&gt;
        if (phase==2) tok_ptr--;
      }
    }
  }
done:@&lt;Clear |bal| and |return|@&gt;;
}
@ @&lt;Check for end of comment@&gt;=
if (c=='*' &amp;&amp; *loc=='/') {
  loc++;
  if (bal&gt;1) err_print("! Missing } in comment");
@.Missing \} in comment@&gt;
  goto done;
}
@ @&lt;Copy special things when |c=='@@'...@&gt;=
if (c=='@@') {
  if (*(loc++)!='@@') {
    err_print("! Illegal use of @@ in comment");
@.Illegal use of @@...@&gt;
    loc-=2; if (phase==2) *(tok_ptr-1)=' '; goto done;
  }
}
else if (c=='\\' &amp;&amp; *loc!='@@')
  if (phase==2) app_tok(*(loc++)) else loc++;
@ We output enough right braces to keep \TEX/ happy.

@&lt;Clear |bal| and |return|@&gt;=
if (phase==2) while (bal-- &gt;0) app_tok('}');
return(0);
@** Parsing.
The most intricate part of \.{CWEAVE} is its mechanism for converting
\CEE/-like code into \TEX/ code, and we might as well plunge into this
aspect of the program now. A ``bottom up'' approach is used to parse the
\CEE/-like material, since \.{CWEAVE} must deal with fragmentary
constructions whose overall ``part of speech'' is not known.

At the lowest level, the input is represented as a sequence of entities
that we shall call {\it scraps}, where each scrap of information consists
of two parts, its {\it category} and its {\it translation}. The category
is essentially a syntactic class, and the translation is a token list that
represents \TEX/ code. Rules of syntax and semantics tell us how to
combine adjacent scraps into larger ones, and if we are lucky an entire
\CEE/ text that starts out as hundreds of small scraps will join
together into one gigantic scrap whose translation is the desired \TEX/
code. If we are unlucky, we will be left with several scraps that don't
combine; their translations will simply be output, one by one.

The combination rules are given as context-sensitive productions that are
applied from left to right. Suppose that we are currently working on the
sequence of scraps $s_1\,s_2\ldots s_n$. We try first to find the longest
production that applies to an initial substring $s_1\,s_2\ldots\,$; but if
no such productions exist, we try to find the longest production
applicable to the next substring $s_2\,s_3\ldots\,$; and if that fails, we
try to match $s_3\,s_4\ldots\,$, etc.

A production applies if the category codes have a given pattern. For
example, one of the productions (see rule~3) is
$$\hbox{|exp| }\left\{\matrix{\hbox{|binop|}\cr\hbox{|ubinop|}}\right\}
\hbox{ |exp| }\RA\hbox{ |exp|}$$
and it means that three consecutive scraps whose respective categories are
|exp|, |binop| (or |ubinop|),
and |exp| are converted to one scrap whose category
is |exp|.  The translations of the original
scraps are simply concatenated.  The case of
$$\hbox{|exp| |comma| |exp| $\RA$ |exp|} \hskip4emE_1C\,\\{opt}9\,E_2$$
(rule 4) is only slightly more complicated:
Here the resulting |exp| translation
consists not only of the three original translations, but also of the
tokens |opt| and 9 between the translations of the
|comma| and the following |exp|.
In the \TEX/ file, this will specify an optional line break after the
comma, with penalty 90.

At each opportunity the longest possible production is applied.  For
example, if the current sequence of scraps is |int_like| |cast|
|lbrace|, rule 31 is applied; but if the sequence is |int_like| |cast|
followed by anything other than |lbrace|, rule 32 takes effect.

Translation rules such as `$E_1C\,\\{opt}9\,E_2$' above use subscripts
to distinguish between translations of scraps whose categories have the
same initial letter; these subscripts are assigned from left to right.@ Here is a list of the category codes that scraps can have. (A few others, like |int_like|, have already been defined; the |cat_name| array contains a complete list.)

@d exp 1 /* denotes an expression, including perhaps a single identifier */
@d unop 2 /* denotes a unary operator */
@d binop 3 /* denotes a binary operator */
@d ubinop 4
  /* denotes an operator that can be unary or binary, depending on context */
@d cast 5 /* denotes a cast */
@d question 6 /* denotes a question mark and possibly the expressions flanking it */
@d lbrace 7 /* denotes a left brace */
@d rbrace 8 /* denotes a right brace */
@d decl_head 9 /* denotes an incomplete declaration */
@d comma 10 /* denotes a comma */
@d lpar 11 /* denotes a left parenthesis or left bracket */
@d rpar 12 /* denotes a right parenthesis or right bracket */
@d prelangle 13 /* denotes `$&lt;$' before we know what it is */
@d prerangle 14 /* denotes `$&gt;$' before we know what it is */
@d langle 15 /* denotes `$&lt;$' when it's used as angle bracket in a template */
@d colcol 18 /* denotes `::' */
@d base 19 /* denotes a colon that introduces a base specifier */
@d decl 20 /* denotes a complete declaration */
@d struct_head 21 /* denotes the beginning of a structure specifier */
@d stmt 23 /* denotes a complete statement */
@d function 24 /* denotes a complete function */
@d fn_decl 25 /* denotes a function declarator */
@d semi 27 /* denotes a semicolon */
@d colon 28 /* denotes a colon */
@d tag 29 /* denotes a statement label */
@d if_head 30 /* denotes the beginning of a compound conditional */
@d else_head 31 /* denotes a prefix for a compound statement */
@d if_clause 32 /* pending \.{if} together with a condition */
@d lproc 35 /* begins a preprocessor command */
@d rproc 36 /* ends a preprocessor command */
@d insert 37 /* a scrap that gets combined with its neighbor */
@d section_scrap 38 /* section name */
@d dead 39 /* scrap that won't combine */
@d ftemplate 59 /* \\{make\_pair} */
@d new_exp 60 /* \&amp;{new} and a following type identifier */
@d begin_arg 61 /* \.{@@[} */
@d end_arg 62 /* \.{@@]} */

@&lt;Global variables@&gt;=
char cat_name[256][12];
eight_bits cat_index;

@ @&lt;Set in...@&gt;=
    for (cat_index=0;cat_index&lt;255;cat_index++)
      strcpy(cat_name[cat_index],"UNKNOWN");
@.UNKNOWN@&gt;
    strcpy(cat_name[exp],"exp");
    strcpy(cat_name[unop],"unop");
    strcpy(cat_name[binop],"binop");
    strcpy(cat_name[ubinop],"ubinop");
    strcpy(cat_name[cast],"cast");
    strcpy(cat_name[question],"?");
    strcpy(cat_name[lbrace],"{"@q}@&gt;);
    strcpy(cat_name[rbrace],@q{@&gt;"}");
    strcpy(cat_name[decl_head],"decl_head");
    strcpy(cat_name[comma],",");
    strcpy(cat_name[lpar],"(");
    strcpy(cat_name[rpar],")");
    strcpy(cat_name[prelangle],"&lt;");
    strcpy(cat_name[prerangle],"&gt;");
    strcpy(cat_name[langle],"\\&lt;");
    strcpy(cat_name[colcol],"::");
    strcpy(cat_name[base],"\\:");
    strcpy(cat_name[decl],"decl");
    strcpy(cat_name[struct_head],"struct_head");
    strcpy(cat_name[alfop],"alfop");
    strcpy(cat_name[stmt],"stmt");
    strcpy(cat_name[function],"function");
    strcpy(cat_name[fn_decl],"fn_decl");
    strcpy(cat_name[else_like],"else_like");
    strcpy(cat_name[semi],";");
    strcpy(cat_name[colon],":");
    strcpy(cat_name[tag],"tag");
    strcpy(cat_name[if_head],"if_head");
    strcpy(cat_name[else_head],"else_head");
    strcpy(cat_name[if_clause],"if()");
    strcpy(cat_name[lproc],"#{"@q}@&gt;);
    strcpy(cat_name[rproc],@q{@&gt;"#}");
    strcpy(cat_name[insert],"insert");
    strcpy(cat_name[section_scrap],"section");
    strcpy(cat_name[dead],"@@d");
    strcpy(cat_name[public_like],"public");
    strcpy(cat_name[operator_like],"operator");
    strcpy(cat_name[new_like],"new");
    strcpy(cat_name[catch_like],"catch");
    strcpy(cat_name[for_like],"for");
    strcpy(cat_name[do_like],"do");
    strcpy(cat_name[if_like],"if");
    strcpy(cat_name[delete_like],"delete");
    strcpy(cat_name[raw_ubin],"ubinop?");
    strcpy(cat_name[const_like],"const");
    strcpy(cat_name[raw_int],"raw");
    strcpy(cat_name[int_like],"int");
    strcpy(cat_name[case_like],"case");
    strcpy(cat_name[sizeof_like],"sizeof");
    strcpy(cat_name[struct_like],"struct");
    strcpy(cat_name[typedef_like],"typedef");
    strcpy(cat_name[define_like],"define");
    strcpy(cat_name[template_like],"template");
    strcpy(cat_name[ftemplate],"ftemplate");
    strcpy(cat_name[new_exp],"new_exp");
    strcpy(cat_name[begin_arg],"@@["@q]@&gt;);
    strcpy(cat_name[end_arg],@q[@&gt;"@@]");
    strcpy(cat_name[0],"zero");
@ This code allows \.{CWEAVE} to display its parsing steps.

@c
void
print_cat(c) /* symbolic printout of a category */
eight_bits c;
{
  printf(cat_name[c]);
}@ The token lists for translated \TEX/ output contain some special control symbols as well as ordinary characters. These control symbols are interpreted by \.{CWEAVE} before they are written to the output file.  \yskip\hang |break_space| denotes an optional line break or an en space;  \yskip\hang |force| denotes a line break;  \yskip\hang |big_force| denotes a line break with additional vertical space;  \yskip\hang |preproc_line| denotes that the line will be printed flush left;  \yskip\hang |opt| denotes an optional line break (with the continuation line indented two ems with respect to the normal starting position)---this code is followed by an integer |n|, and the break will occur with penalty $10n$;  \yskip\hang |backup| denotes a backspace of one em;  \yskip\hang |cancel| obliterates any |break_space|, |opt|, |force|, or |big_force| tokens that immediately precede or follow it and also cancels any |backup| tokens that follow it;  \yskip\hang |indent| causes future lines to be indented one more em;  \yskip\hang |outdent| causes future lines to be indented one less em.  \yskip\noindent All of these tokens are removed from the \TEX/ output that comes from \CEE/ text between \pb\ signs; |break_space| and |force| and |big_force| become single spaces in this mode. The translation of other \CEE/ texts results in \TEX/ control sequences \.{\\1}, \.{\\2}, \.{\\3}, \.{\\4}, \.{\\5}, \.{\\6}, \.{\\7}, \.{\\8} corresponding respectively to |indent|, |outdent|, |opt|, |backup|, |break_space|, |force|, |big_force| and |preproc_line|. However, a sequence of consecutive `\.\ ', |break_space|, |force|, and/or |big_force| tokens is first replaced by a single token (the maximum of the given ones).  The token |math_rel| will be translated into \.{\\MRL\{}, and it will get a matching \.\} later. Other control sequences in the \TEX/ output will be `\.{\\\\\{}$\,\ldots\,$\.\}' surrounding identifiers, `\.{\\\&amp;\{}$\,\ldots\,$\.\}' surrounding reserved words, `\.{\\.\{}$\,\ldots\,$\.\}' surrounding strings, `\.{\\C\{}$\,\ldots\,$\.\}$\,$|force|' surrounding comments, and `\.{\\X$n$:}$\,\ldots\,$\.{\\X}' surrounding section names, where |n| is the section number.

@d math_rel 0206
@d big_cancel 0210 /* like |cancel|, also overrides spaces */
@d cancel 0211 /* overrides |backup|, |break_space|, |force|, |big_force| */
@d indent 0212 /* one more tab (\.{\\1}) */
@d outdent 0213 /* one less tab (\.{\\2}) */
@d opt 0214 /* optional break in mid-statement (\.{\\3}) */
@d backup 0215 /* stick out one unit to the left (\.{\\4}) */
@d break_space 0216 /* optional break between statements (\.{\\5}) */
@d force 0217 /* forced break between statements (\.{\\6}) */
@d big_force 0220 /* forced break with additional space (\.{\\7}) */
@d preproc_line 0221 /* begin line without indentation (\.{\\8}) */
@^high-bit character handling@&gt;

@d quoted_char 0222
        /* introduces a character token in the range |0200|--|0377| */
@d end_translation 0223 /* special sentinel token at end of list */
@d inserted 0224 /* sentinel to mark translations of inserts */
@d qualifier 0225 /* introduces an explicit namespace qualifier */
@ The raw input is converted into scraps according to the following table, which gives category codes followed by the translations. \def\stars {\.{**}}% The symbol `\stars' stands for `\.{\\\&amp;\{{\rm identifier}\}}', i.e., the identifier itself treated as a reserved word. The right-hand column is the so-called |mathness|, which is explained further below.  An identifier |c| of length 1 is translated as \.{\\\v c} instead of as \.{\\\\\{c\}}. An identifier \.{CAPS} in all caps is translated as \.{\\.\{CAPS\}} instead of as \.{\\\\\{CAPS\}}. An identifier that has become a reserved word via |typedef| is translated with \.{\\\&amp;} replacing \.{\\\\} and |raw_int| replacing |exp|.  A string of length greater than 20 is broken into pieces of size at most~20 with discretionary breaks in between.  \yskip\halign{\quad#\hfil&amp;\quad#\hfil&amp;\quad\hfil#\hfil\cr \.{!=}&amp;|binop|: \.{\\I}&amp;yes\cr \.{&lt;=}&amp;|binop|: \.{\\Z}&amp;yes\cr \.{&gt;=}&amp;|binop|: \.{\\G}&amp;yes\cr \.{==}&amp;|binop|: \.{\\E}&amp;yes\cr \.{\&amp;\&amp;}&amp;|binop|: \.{\\W}&amp;yes\cr \.{\v\v}&amp;|binop|: \.{\\V}&amp;yes\cr \.{++}&amp;|unop|: \.{\\PP}&amp;yes\cr \.{--}&amp;|unop|: \.{\\MM}&amp;yes\cr \.{-&gt;}&amp;|binop|: \.{\\MG}&amp;yes\cr \.{&gt;&gt;}&amp;|binop|: \.{\\GG}&amp;yes\cr \.{&lt;&lt;}&amp;|binop|: \.{\\LL}&amp;yes\cr \.{::}&amp;|colcol|: \.{\\DC}&amp;maybe\cr \.{.*}&amp;|binop|: \.{\\PA}&amp;yes\cr \.{-&gt;*}&amp;|binop|: \.{\\MGA}&amp;yes\cr \.{...}&amp;|raw_int|: \.{\\,\\ldots\\,}&amp;yes\cr \."string\."&amp;|exp|: \.{\\.\{}string with special characters quoted\.\}&amp;maybe\cr \.{@@=}string\.{@@&gt;}&amp;|exp|: \.{\\vb\{}string with special characters   quoted\.\}&amp;maybe\cr \.{@@'7'}&amp;|exp|: \.{\\.\{@@'7'\}}&amp;maybe\cr \.{077} or \.{\\77}&amp;|exp|: \.{\\T\{\\\~77\}}&amp;maybe\cr \.{0x7f}&amp;|exp|: \.{\\T\{\\\^7f\}}&amp;maybe\cr \.{77}&amp;|exp|: \.{\\T\{77\}}&amp;maybe\cr \.{77L}&amp;|exp|: \.{\\T\{77\\\$L\}}&amp;maybe\cr \.{0.1E5}&amp;|exp|: \.{\\T\{0.1\\\_5\}}&amp;maybe\cr \.+&amp;|ubinop|: \.+&amp;yes\cr \.-&amp;|ubinop|: \.-&amp;yes\cr \.*&amp;|raw_ubin|: \.*&amp;yes\cr \./&amp;|binop|: \./&amp;yes\cr \.&lt;&amp;|prelangle|: \.{\\langle}&amp;yes\cr \.=&amp;|binop|: \.{\\K}&amp;yes\cr \.&gt;&amp;|prerangle|: \.{\\rangle}&amp;yes\cr \..&amp;|binop|: \..&amp;yes\cr \.{\v}&amp;|binop|: \.{\\OR}&amp;yes\cr \.\^&amp;|binop|: \.{\\XOR}&amp;yes\cr \.\%&amp;|binop|: \.{\\MOD}&amp;yes\cr \.?&amp;|question|: \.{\\?}&amp;yes\cr \.!&amp;|unop|: \.{\\R}&amp;yes\cr \.\~&amp;|unop|: \.{\\CM}&amp;yes\cr \.\&amp;&amp;|raw_ubin|: \.{\\AND}&amp;yes\cr \.(&amp;|lpar|: \.(&amp;maybe\cr \.[&amp;|lpar|: \.[&amp;maybe\cr \.)&amp;|rpar|: \.)&amp;maybe\cr \.]&amp;|rpar|: \.]&amp;maybe\cr \.\{&amp;|lbrace|: \.\{&amp;yes\cr \.\}&amp;|lbrace|: \.\}&amp;yes\cr \.,&amp;|comma|: \.,&amp;yes\cr \.;&amp;|semi|: \.;&amp;maybe\cr \.:&amp;|colon|: \.:&amp;no\cr \.\# (within line)&amp;|ubinop|: \.{\\\#}&amp;yes\cr \.\# (at beginning)&amp;|lproc|:  |force| |preproc_line| \.{\\\#}&amp;no\cr end of \.\# line&amp;|rproc|:  |force|&amp;no\cr identifier&amp;|exp|: \.{\\\\\{}identifier with underlines and              dollar signs quoted\.\}&amp;maybe\cr \.{and}&amp;|alfop|: \stars&amp;yes\cr \.{and\_eq}&amp;|alfop|: \stars&amp;yes\cr \.{asm}&amp;|sizeof_like|: \stars&amp;maybe\cr \.{auto}&amp;|int_like|: \stars&amp;maybe\cr \.{bitand}&amp;|alfop|: \stars&amp;yes\cr \.{bitor}&amp;|alfop|: \stars&amp;yes\cr \.{bool}&amp;|raw_int|: \stars&amp;maybe\cr \.{break}&amp;|case_like|: \stars&amp;maybe\cr \.{case}&amp;|case_like|: \stars&amp;maybe\cr \.{catch}&amp;|catch_like|: \stars&amp;maybe\cr \.{char}&amp;|raw_int|: \stars&amp;maybe\cr \.{class}&amp;|struct_like|: \stars&amp;maybe\cr \.{clock\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{compl}&amp;|alfop|: \stars&amp;yes\cr \.{const}&amp;|const_like|: \stars&amp;maybe\cr \.{const\_cast}&amp;|raw_int|: \stars&amp;maybe\cr \.{continue}&amp;|case_like|: \stars&amp;maybe\cr \.{default}&amp;|case_like|: \stars&amp;maybe\cr \.{define}&amp;|define_like|: \stars&amp;maybe\cr \.{defined}&amp;|sizeof_like|: \stars&amp;maybe\cr \.{delete}&amp;|delete_like|: \stars&amp;maybe\cr \.{div\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{do}&amp;|do_like|: \stars&amp;maybe\cr \.{double}&amp;|raw_int|: \stars&amp;maybe\cr \.{dynamic\_cast}&amp;|raw_int|: \stars&amp;maybe\cr \.{elif}&amp;|if_like|: \stars&amp;maybe\cr \.{else}&amp;|else_like|: \stars&amp;maybe\cr \.{endif}&amp;|if_like|: \stars&amp;maybe\cr \.{enum}&amp;|struct_like|: \stars&amp;maybe\cr \.{error}&amp;|if_like|: \stars&amp;maybe\cr \.{explicit}&amp;|int_like|: \stars&amp;maybe\cr \.{export}&amp;|int_like|: \stars&amp;maybe\cr \.{extern}&amp;|int_like|: \stars&amp;maybe\cr \.{FILE}&amp;|raw_int|: \stars&amp;maybe\cr \.{float}&amp;|raw_int|: \stars&amp;maybe\cr \.{for}&amp;|for_like|: \stars&amp;maybe\cr \.{fpos\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{friend}&amp;|int_like|: \stars&amp;maybe\cr \.{goto}&amp;|case_like|: \stars&amp;maybe\cr \.{if}&amp;|if_like|: \stars&amp;maybe\cr \.{ifdef}&amp;|if_like|: \stars&amp;maybe\cr \.{ifndef}&amp;|if_like|: \stars&amp;maybe\cr \.{include}&amp;|if_like|: \stars&amp;maybe\cr \.{inline}&amp;|int_like|: \stars&amp;maybe\cr \.{int}&amp;|raw_int|: \stars&amp;maybe\cr \.{jmp\_buf}&amp;|raw_int|: \stars&amp;maybe\cr \.{ldiv\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{line}&amp;|if_like|: \stars&amp;maybe\cr \.{long}&amp;|raw_int|: \stars&amp;maybe\cr \.{make\_pair}&amp;|ftemplate|: \.{\\\\\{make\\\_pair\}}&amp;maybe\cr \.{mutable}&amp;|int_like|: \stars&amp;maybe\cr \.{namespace}&amp;|struct_like|: \stars&amp;maybe\cr \.{new}&amp;|new_like|: \stars&amp;maybe\cr \.{not}&amp;|alfop|: \stars&amp;yes\cr \.{not\_eq}&amp;|alfop|: \stars&amp;yes\cr \.{NULL}&amp;|exp|: \.{\\NULL}&amp;yes\cr \.{offsetof}&amp;|raw_int|: \stars&amp;maybe\cr \.{operator}&amp;|operator_like|: \stars&amp;maybe\cr \.{or}&amp;|alfop|: \stars&amp;yes\cr \.{or\_eq}&amp;|alfop|: \stars&amp;yes\cr \.{pragma}&amp;|if_like|: \stars&amp;maybe\cr \.{private}&amp;|public_like|: \stars&amp;maybe\cr \.{protected}&amp;|public_like|: \stars&amp;maybe\cr \.{ptrdiff\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{public}&amp;|public_like|: \stars&amp;maybe\cr \.{register}&amp;|int_like|: \stars&amp;maybe\cr \.{reinterpret\_cast}&amp;|raw_int|: \stars&amp;maybe\cr \.{return}&amp;|case_like|: \stars&amp;maybe\cr \.{short}&amp;|raw_int|: \stars&amp;maybe\cr \.{sig\_atomic\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{signed}&amp;|raw_int|: \stars&amp;maybe\cr \.{size\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{sizeof}&amp;|sizeof_like|: \stars&amp;maybe\cr \.{static}&amp;|int_like|: \stars&amp;maybe\cr \.{static\_cast}&amp;|raw_int|: \stars&amp;maybe\cr \.{struct}&amp;|struct_like|: \stars&amp;maybe\cr \.{switch}&amp;|for_like|: \stars&amp;maybe\cr \.{template}&amp;|template_like|: \stars&amp;maybe\cr \.{TeX}&amp;|exp|: \.{\\TeX}&amp;yes\cr \.{this}&amp;|exp|: \.{\\this}&amp;yes\cr \.{throw}&amp;|case_like|: \stars&amp;maybe\cr \.{time\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{try}&amp;|else_like|: \stars&amp;maybe\cr \.{typedef}&amp;|typedef_like|: \stars&amp;maybe\cr \.{typeid}&amp;|raw_int|: \stars&amp;maybe\cr \.{typename}&amp;|struct_like|: \stars&amp;maybe\cr \.{undef}&amp;|if_like|: \stars&amp;maybe\cr \.{union}&amp;|struct_like|: \stars&amp;maybe\cr \.{unsigned}&amp;|raw_int|: \stars&amp;maybe\cr \.{using}&amp;|int_like|: \stars&amp;maybe\cr \.{va\_dcl}&amp;|decl|: \stars&amp;maybe\cr \.{va\_list}&amp;|raw_int|: \stars&amp;maybe\cr \.{virtual}&amp;|int_like|: \stars&amp;maybe\cr \.{void}&amp;|raw_int|: \stars&amp;maybe\cr \.{volatile}&amp;|const_like|: \stars&amp;maybe\cr \.{wchar\_t}&amp;|raw_int|: \stars&amp;maybe\cr \.{while}&amp;|for_like|: \stars&amp;maybe\cr \.{xor}&amp;|alfop|: \stars&amp;yes\cr \.{xor\_eq}&amp;|alfop|: \stars&amp;yes\cr \.{@@,}&amp;|insert|: \.{\\,}&amp;maybe\cr \.{@@\v}&amp;|insert|:  |opt| \.0&amp;maybe\cr \.{@@/}&amp;|insert|:  |force|&amp;no\cr \.{@@\#}&amp;|insert|:  |big_force|&amp;no\cr \.{@@+}&amp;|insert|:  |big_cancel| \.{\{\}} |break_space|   \.{\{\}} |big_cancel|&amp;no\cr \.{@@;}&amp;|semi|: &amp;maybe\cr \.{@@[@q]@&gt;}&amp;|begin_arg|: &amp;maybe\cr \.{@q[@&gt;@@]}&amp;|end_arg|: &amp;maybe\cr \.{@@\&amp;}&amp;|insert|: \.{\\J}&amp;maybe\cr \.{@@h}&amp;|insert|: |force| \.{\\ATH} |force|&amp;no\cr \.{@

@&lt;}\thinspace section name\thinspace\.{@@&gt;}&amp;|section_scrap|:
 \.{\\X}$n$\.:translated section name\.{\\X}&amp;maybe\cr
\.{@@(@q)@&gt;}\thinspace section name\thinspace\.{@@&gt;}&amp;|section_scrap|:
 \.{\\X}$n$\.{:\\.\{}section name with special characters
      quoted\.{\ \}\\X}&amp;maybe\cr
\.{/*}comment\.{*/}&amp;|insert|: |cancel|
      \.{\\C\{}translated comment\.\} |force|&amp;no\cr
\.{//}comment&amp;|insert|: |cancel|
      \.{\\SHC\{}translated comment\.\} |force|&amp;no\cr
}

\smallskip
The construction \.{@@t}\thinspace stuff\/\thinspace\.{@@&gt;} contributes
\.{\\hbox\{}\thinspace  stuff\/\thinspace\.\} to the following scrap.

@i prod.w
@* Implementing the productions. More specifically, a scrap is a structure consisting of a category |cat| and a |text_pointer| |trans|, which points to the translation in |tok_start|.  When \CEE/ text is to be processed with the grammar above, we form an array |scrap_info| containing the initial scraps. Our production rules have the nice property that the right-hand side is never longer than the left-hand side. Therefore it is convenient to use sequential allocation for the current sequence of scraps. Five pointers are used to manage the parsing:  \yskip\hang |pp| is a pointer into |scrap_info|.  We will try to match the category codes |pp-&gt;cat,@,@,(pp+1)-&gt;cat|$,\,\,\ldots\,$ to the left-hand sides of productions.  \yskip\hang |scrap_base|, |lo_ptr|, |hi_ptr|, and |scrap_ptr| are such that the current sequence of scraps appears in positions |scrap_base| through |lo_ptr| and |hi_ptr| through |scrap_ptr|, inclusive, in the |cat| and |trans| arrays. Scraps located between |scrap_base| and |lo_ptr| have been examined, while those in positions |&gt;=hi_ptr| have not yet been looked at by the parsing process.  \yskip\noindent Initially |scrap_ptr| is set to the position of the final scrap to be parsed, and it doesn't change its value. The parsing process makes sure that |lo_ptr&gt;=pp+3|, since productions have as many as four terms, by moving scraps from |hi_ptr| to |lo_ptr|. If there are fewer than |pp+3| scraps left, the positions up to |pp+3| are filled with blanks that will not match in any productions. Parsing stops when |pp==lo_ptr+1| and |hi_ptr==scrap_ptr+1|.  Since the |scrap| structure will later be used for other purposes, we declare its second element as a union.

@&lt;Typedef declarations@&gt;=
typedef struct {
  eight_bits cat;
  eight_bits mathness;
  union {
    text_pointer Trans;
    @&lt;Rest of |trans_plus| union@&gt;@;
  } trans_plus;
} scrap;
typedef scrap *scrap_pointer;@ @d trans trans_plus.Trans /* translation texts of scraps */

@&lt;Global variables@&gt;=
scrap scrap_info[max_scraps]; /* memory array for scraps */
scrap_pointer scrap_info_end=scrap_info+max_scraps -1; /* end of |scrap_info| */
scrap_pointer pp; /* current position for reducing productions */
scrap_pointer scrap_base; /* beginning of the current scrap sequence */
scrap_pointer scrap_ptr; /* ending of the current scrap sequence */
scrap_pointer lo_ptr; /* last scrap that has been examined */
scrap_pointer hi_ptr; /* first scrap that has not been examined */
scrap_pointer max_scr_ptr; /* largest value assumed by |scrap_ptr| */

@ @&lt;Set init...@&gt;=
scrap_base=scrap_info+1;
max_scr_ptr=scrap_ptr=scrap_info;
@ Token lists in |@!tok_mem| are composed of the following kinds of items for \TEX/ output.  \yskip\item{$\bullet$}Character codes and special codes like |force| and |math_rel| represent themselves;  \item{$\bullet$}|id_flag+p| represents \.{\\\\\{{\rm identifier $p$}\}};  \item{$\bullet$}|res_flag+p| represents \.{\\\&amp;\{{\rm identifier $p$}\}};  \item{$\bullet$}|section_flag+p| represents section name |p|;  \item{$\bullet$}|tok_flag+p| represents token list number |p|;  \item{$\bullet$}|inner_tok_flag+p| represents token list number |p|, to be translated without line-break controls.

@d id_flag 10240 /* signifies an identifier */
@d res_flag 2*id_flag /* signifies a reserved word */
@d section_flag 3*id_flag /* signifies a section name */
@d tok_flag 4*id_flag /* signifies a token list */
@d inner_tok_flag 5*id_flag /* signifies a token list in `\pb' */

@c
void
print_text(p) /* prints a token list for debugging; not used in |main| */
text_pointer p;
{
  token_pointer j; /* index into |tok_mem| */
  sixteen_bits r; /* remainder of token after the flag has been stripped off */
  if (p&gt;=text_ptr) printf("BAD");
  else for (j=*p; j&lt;*(p+1); j++) {
    r=*j%id_flag;
    switch (*j/id_flag) {
      case 1: printf("\\\\{"@q}@&gt;); print_id((name_dir+r)); printf(@q{@&gt;"}");
        break; /* |id_flag| */
      case 2: printf("\\&amp;{"@q}@&gt;); print_id((name_dir+r)); printf(@q{@&gt;"}");
        break; /* |res_flag| */
      case 3: printf("&lt;"); print_section_name((name_dir+r)); printf("&gt;");
        break; /* |section_flag| */
      case 4: printf("[[%d]]",r); break; /* |tok_flag| */
      case 5: printf("|[[%d]]|",r); break; /* |inner_tok_flag| */
      default: @&lt;Print token |r| in symbolic form@&gt;;
    }
  }
  fflush(stdout);
}@ @&lt;Print token |r|...@&gt;=
switch (r) {
  case math_rel: printf("\\mathrel{"@q}@&gt;); break;
  case big_cancel: printf("[ccancel]"); break;
  case cancel: printf("[cancel]"); break;
  case indent: printf("[indent]"); break;
  case outdent: printf("[outdent]"); break;
  case backup: printf("[backup]"); break;
  case opt: printf("[opt]"); break;
  case break_space: printf("[break]"); break;
  case force: printf("[force]"); break;
  case big_force: printf("[fforce]"); break;
  case preproc_line: printf("[preproc]"); break;
  case quoted_char: j++; printf("[%o]",(unsigned)*j); break;
  case end_translation: printf("[quit]"); break;
  case inserted: printf("[inserted]"); break;
  default: putxchar(r);
}
@ The production rules listed above are embedded directly into \.{CWEAVE}, since it is easier to do this than to write an interpretive system that would handle production systems in general. Several macros are defined here so that the program for each production is fairly short.  All of our productions conform to the general notion that some |k| consecutive scraps starting at some position |j| are to be replaced by a single scrap of some category |c| whose translation is composed from the translations of the disappearing scraps. After this production has been applied, the production pointer |pp| should change by an amount |d|. Such a production can be represented by the quadruple |(j,k,c,d)|. For example, the production `|exp@,comma@,exp| $\RA$ |exp|' would be represented by `|(pp,3,exp,-2)|'; in this case the pointer |pp| should decrease by 2 after the production has been applied, because some productions with |exp| in their second or third positions might now match, but no productions have |exp| in the fourth position of their left-hand sides. Note that the value of |d| is determined by the whole collection of productions, not by an individual one. The determination of |d| has been done by hand in each case, based on the full set of productions but not on the grammar of \CEE/ or on the rules for constructing the initial scraps.  We also attach a serial number to each production, so that additional information is available when debugging. For example, the program below contains the statement `|reduce(pp,3,exp,-2,4)|' when it implements the production just mentioned.  Before calling |reduce|, the program should have appended the tokens of the new translation to the |tok_mem| array. We commonly want to append copies of several existing translations, and macros are defined to simplify these common cases. For example, \\{app2}|(pp)| will append the translations of two consecutive scraps, |pp-&gt;trans| and |(pp+1)-&gt;trans|, to the current token list. If the entire new translation is formed in this way, we write `|squash(j,k,c,d,n)|' instead of `|reduce(j,k,c,d,n)|'. For example, `|squash(pp,3,exp,-2,3)|' is an abbreviation for `\\{app3}|(pp); reduce(pp,3,exp,-2,3)|'.  A couple more words of explanation: Both |big_app| and |app| append a token (while |big_app1| to |big_app4| append the specified number of scrap translations) to the current token list. The difference between |big_app| and |app| is simply that |big_app| checks whether there can be a conflict between math and non-math tokens, and intercalates a `\.{\$}' token if necessary.  When in doubt what to use, use |big_app|.  The |mathness| is an attribute of scraps that says whether they are to be printed in a math mode context or not.  It is separate from the ``part of speech'' (the |cat|) because to make each |cat| have a fixed |mathness| (as in the original \.{WEAVE}) would multiply the number of necessary production rules.  The low two bits (i.e. |mathness % 4|) control the left boundary. (We need two bits because we allow cases |yes_math|, |no_math| and |maybe_math|, which can go either way.) The next two bits (i.e. |mathness / 4|) control the right boundary. If we combine two scraps and the right boundary of the first has a different mathness from the left boundary of the second, we insert a \.{\$} in between.  Similarly, if at printing time some irreducible scrap has a |yes_math| boundary the scrap gets preceded or followed by a \.{\$}. The left boundary is |maybe_math| if and only if the right boundary is.  The code below is an exact translation of the production rules into \CEE/, using such macros, and the reader should have no difficulty understanding the format by comparing the code with the symbolic productions as they were listed earlier.

@d no_math 2 /* should be in horizontal mode */
@d yes_math 1 /* should be in math mode */
@d maybe_math 0 /* works in either horizontal or math mode */
@d big_app2(a) big_app1(a);big_app1(a+1)
@d big_app3(a) big_app2(a);big_app1(a+2)
@d big_app4(a) big_app3(a);big_app1(a+3)
@d app(a) *(tok_ptr++)=a
@d app1(a) *(tok_ptr++)=tok_flag+(int)((a)-&gt;trans-tok_start)

@&lt;Global variables@&gt;=
int cur_mathness, init_mathness;
@ @c
void
app_str(s)
char *s;
{
  while (*s) app_tok(*(s++));
}

void
big_app(a)
token a;
{
        if (a==' ' || (a&gt;=big_cancel &amp;&amp; a&lt;=big_force)) /* non-math token */ {
                if (cur_mathness==maybe_math) init_mathness=no_math;
                else if (cur_mathness==yes_math) app_str("{}$");
                cur_mathness=no_math;
        }
        else {
                if (cur_mathness==maybe_math) init_mathness=yes_math;
                else if (cur_mathness==no_math) app_str("${}");
                cur_mathness=yes_math;
        }
        app(a);
}

void
big_app1(a)
scrap_pointer a;
{
  switch (a-&gt;mathness % 4) { /* left boundary */
  case (no_math):
    if (cur_mathness==maybe_math) init_mathness=no_math;
    else if (cur_mathness==yes_math) app_str("{}$");
    cur_mathness=a-&gt;mathness / 4; /* right boundary */
    break;
  case (yes_math):
    if (cur_mathness==maybe_math) init_mathness=yes_math;
    else if (cur_mathness==no_math) app_str("${}");
    cur_mathness=a-&gt;mathness / 4; /* right boundary */
    break;
  case (maybe_math): /* no changes */ break;
  }
  app(tok_flag+(int)((a)-&gt;trans-tok_start));
}
@ In \CEE/, new specifier names can be defined via |typedef|, and we want to make the parser recognize future occurrences of the identifier thus defined as specifiers.  This is done by the procedure |make_reserved|, which changes the |ilk| of the relevant identifier.  We first need a procedure to recursively seek the first identifier in a token list, because the identifier might be enclosed in parentheses, as when one defines a function returning a pointer.  If the first identifier found is a keyword like `\&amp;{case}', we return the special value |case_found|; this prevents underlining of identifiers in case labels.  If the first identifier is the keyword `\&amp;{operator}', we give up; users who want to index definitions of overloaded \CPLUSPLUS/ operators should say, for example, `\.{@@!@@\^\\\&amp;\{operator\} \$+\{=\}\$@@&gt;}' (or, more properly alphebetized, `\.{@@!@@:operator+=\}\{\\\&amp;\{operator\} \$+\{=\}\$@@&gt;}').

@d no_ident_found (token_pointer)0 /* distinct from any identifier token */
@d case_found (token_pointer)1 /* likewise */
@d operator_found (token_pointer)2 /* likewise */

@c
token_pointer
find_first_ident(p)
text_pointer p;
{
  token_pointer q; /* token to be returned */
  token_pointer j; /* token being looked at */
  sixteen_bits r; /* remainder of token after the flag has been stripped off */
  if (p&gt;=text_ptr) confusion("find_first_ident");
  for (j=*p; j&lt;*(p+1); j++) {
    r=*j%id_flag;
    switch (*j/id_flag) {
      case 2: /* |res_flag| */
        if (name_dir[r].ilk==case_like) return case_found;
        if (name_dir[r].ilk==operator_like) return operator_found;
        if (name_dir[r].ilk!=raw_int) break;
      case 1: return j;
      case 4: case 5: /* |tok_flag| or |inner_tok_flag| */
        if ((q=find_first_ident(tok_start+r))!=no_ident_found)
          return q;
      default: ; /* char, |section_flag|, fall thru: move on to next token */
        if (*j==inserted) return no_ident_found; /* ignore inserts */
        else if (*j==qualifier) j++; /* bypass namespace qualifier */
    }
  }
  return no_ident_found;
}@ The scraps currently being parsed must be inspected for any occurrence of the identifier that we're making reserved; hence the |for| loop below.

@c
void
make_reserved(p) /* make the first identifier in |p-&gt;trans| like |int| */
scrap_pointer p;
{
  sixteen_bits tok_value; /* the name of this identifier, plus its flag*/
  token_pointer tok_loc; /* pointer to |tok_value| */
  if ((tok_loc=find_first_ident(p-&gt;trans))&lt;=operator_found)
    return; /* this should not happen */
  tok_value=*tok_loc;
  for (;p&lt;=scrap_ptr; p==lo_ptr? p=hi_ptr: p++) {
    if (p-&gt;cat==exp) {
      if (**(p-&gt;trans)==tok_value) {
        p-&gt;cat=raw_int;
        **(p-&gt;trans)=tok_value%id_flag+res_flag;
      }
    }
  }
  (name_dir+(sixteen_bits)(tok_value%id_flag))-&gt;ilk=raw_int;
  *tok_loc=tok_value%id_flag+res_flag;
}@ In the following situations we want to mark the occurrence of an identifier as a definition: when |make_reserved| is just about to be used; after a specifier, as in |char **argv|; before a colon, as in \\{found}:; and in the declaration of a function, as in \\{main}()$\{\ldots;\}$.  This is accomplished by the invocation of |make_underlined| at appropriate times.  Notice that, in the declaration of a function, we find out that the identifier is being defined only after it has been swallowed up by an |exp|.

@c
void
make_underlined(p)
/* underline the entry for the first identifier in |p-&gt;trans| */
scrap_pointer p;
{
  token_pointer tok_loc; /* where the first identifier appears */
  if ((tok_loc=find_first_ident(p-&gt;trans))&lt;=operator_found)
    return; /* this happens, for example, in |case found:| */
  xref_switch=def_flag;
  underline_xref(*tok_loc%id_flag+name_dir);
}@ We cannot use |new_xref| to underline a cross-reference at this point because this would just make a new cross-reference at the end of the list. We actually have to search through the list for the existing cross-reference.

@&lt;Predeclaration of procedures@&gt;=
void  underline_xref();

@ @c
void
underline_xref(p)
name_pointer p;
{
  xref_pointer q=(xref_pointer)p-&gt;xref; /* pointer to cross-reference being examined */
  xref_pointer r; /* temporary pointer for permuting cross-references */
  sixteen_bits m; /* cross-reference value to be installed */
  sixteen_bits n; /* cross-reference value being examined */
  if (no_xref) return;
  m=section_count+xref_switch;
  while (q != xmem) {
    n=q-&gt;num;
    if (n==m) return;
    else if (m==n+def_flag) {
        q-&gt;num=m; return;
    }
    else if (n&gt;=def_flag &amp;&amp; n&lt;m) break;
    q=q-&gt;xlink;
  }
  @&lt;Insert new cross-reference at |q|, not at beginning of list@&gt;;
}
@ We get to this section only when the identifier is one letter long, so it didn't get a non-underlined entry during phase one.  But it may have got some explicitly underlined entries in later sections, so in order to preserve the numerical order of the entries in the index, we have to insert the new cross-reference not at the beginning of the list (namely, at |p-&gt;xref|), but rather right before |q|.

@&lt;Insert new cross-reference at |q|, not at beginning of list@&gt;=
  append_xref(0); /* this number doesn't matter */
  xref_ptr-&gt;xlink=(xref_pointer)p-&gt;xref; r=xref_ptr;
  p-&gt;xref=(char*)xref_ptr;
  while (r-&gt;xlink!=q) {r-&gt;num=r-&gt;xlink-&gt;num; r=r-&gt;xlink;}
  r-&gt;num=m; /* everything from |q| on is left undisturbed */
@ Now here's the |reduce| procedure used in our code for productions.  The `|freeze_text|' macro is used to give official status to a token list. Before saying |freeze_text|, items are appended to the current token list, and we know that the eventual number of this token list will be the current value of |text_ptr|. But no list of that number really exists as yet, because no ending point for the current list has been stored in the |tok_start| array. After saying |freeze_text|, the old current token list becomes legitimate, and its number is the current value of |text_ptr-1| since |text_ptr| has been increased. The new current token list is empty and ready to be appended to. Note that |freeze_text| does not check to see that |text_ptr| hasn't gotten too large, since it is assumed that this test was done beforehand.

@d freeze_text *(++text_ptr)=tok_ptr

@c
void
reduce(j,k,c,d,n)
scrap_pointer j;
eight_bits c;
short k, d, n;
{
  scrap_pointer i, i1; /* pointers into scrap memory */
  j-&gt;cat=c; j-&gt;trans=text_ptr;
  j-&gt;mathness=4*cur_mathness+init_mathness;
  freeze_text;
  if (k&gt;1) {
    for (i=j+k, i1=j+1; i&lt;=lo_ptr; i++, i1++) {
      i1-&gt;cat=i-&gt;cat; i1-&gt;trans=i-&gt;trans;
      i1-&gt;mathness=i-&gt;mathness;
    }
    lo_ptr=lo_ptr-k+1;
  }
  pp=(pp+d&lt;scrap_base? scrap_base: pp+d);
  @&lt;Print a snapshot of the scrap list if debugging @&gt;;
  pp--; /* we next say |pp++| */
}@ Here's the |squash| procedure, which takes advantage of the simplification that occurs when |k==1|.

@c
void
squash(j,k,c,d,n)
scrap_pointer j;
eight_bits c;
short k, d, n;
{
  scrap_pointer i; /* pointers into scrap memory */
  if (k==1) {
    j-&gt;cat=c; pp=(pp+d&lt;scrap_base? scrap_base: pp+d);
    @&lt;Print a snapshot...@&gt;;
    pp--; /* we next say |pp++| */
    return;
  }
  for (i=j; i&lt;j+k; i++) big_app1(i);
  reduce(j,k,c,d,n);
}@ If \.{CWEAVE} is being run in debugging mode, the production numbers and current stack categories will be printed out when |tracing| is set to 2; a sequence of two or more irreducible scraps will be printed out when |tracing| is set to 1.

@&lt;Global variables@&gt;=
int tracing; /* can be used to show parsing details */

@ @&lt;Print a snapsh...@&gt;=
{ scrap_pointer k; /* pointer into |scrap_info| */
  if (tracing==2) {
    printf("\n%d:",n);
    for (k=scrap_base; k&lt;=lo_ptr; k++) {
      if (k==pp) putxchar('*'); else putxchar(' ');
      if (k-&gt;mathness %4 ==  yes_math) putchar('+');
      else if (k-&gt;mathness %4 ==  no_math) putchar('-');
      print_cat(k-&gt;cat);
      if (k-&gt;mathness /4 ==  yes_math) putchar('+');
      else if (k-&gt;mathness /4 ==  no_math) putchar('-');
    }
    if (hi_ptr&lt;=scrap_ptr) printf("..."); /* indicate that more is coming */
  }
}
@ The |translate| function assumes that scraps have been stored in positions |scrap_base| through |scrap_ptr| of |cat| and |trans|. It applies productions as much as possible. The result is a token list containing the translation of the given sequence of scraps.  After calling |translate|, we will have |text_ptr+3&lt;=max_texts| and |tok_ptr+6&lt;=max_toks|, so it will be possible to create up to three token lists with up to six tokens without checking for overflow. Before calling |translate|, we should have |text_ptr&lt;max_texts| and |scrap_ptr&lt;max_scraps|, since |translate| might add a new text and a new scrap before it checks for overflow.

@c
text_pointer
translate() /* converts a sequence of scraps */
{
  scrap_pointer i, /* index into |cat| */
  j; /* runs through final scraps */
  pp=scrap_base; lo_ptr=pp-1; hi_ptr=pp;
  @&lt;If tracing, print an indication of where we are@&gt;;
  @&lt;Reduce the scraps...@&gt;;
  @&lt;Combine the irreducible scraps that remain@&gt;;
}@ @&lt;If tracing,...@&gt;=
if (tracing==2) {
  printf("\nTracing after l. %d:\n",cur_line); mark_harmless;
@.Tracing after...@&gt;
  if (loc&gt;buffer+50) {
    printf("...");
    term_write(loc-51,51);
  }
  else term_write(buffer,loc-buffer);
}
@ And here now is the code that applies productions as long as possible. Before applying the production mechanism, we must make sure it has good input (at least four scraps, the length of the lhs of the longest rules), and that there is enough room in the memory arrays to hold the appended tokens and texts.  Here we use a very conservative test; it's more important to make sure the program will still work if we change the production rules (within reason) than to squeeze the last bit of space from the memory arrays.

@d safe_tok_incr 20
@d safe_text_incr 10
@d safe_scrap_incr 10

@&lt;Reduce the scraps using the productions until no more rules apply@&gt;=
while (1) {
  @&lt;Make sure the entries |pp| through |pp+3| of |cat| are defined@&gt;;
  if (tok_ptr+safe_tok_incr&gt;tok_mem_end) {
    if (tok_ptr&gt;max_tok_ptr) max_tok_ptr=tok_ptr;
    overflow("token");
  }
  if (text_ptr+safe_text_incr&gt;tok_start_end) {
    if (text_ptr&gt;max_text_ptr) max_text_ptr=text_ptr;
    overflow("text");
  }
  if (pp&gt;lo_ptr) break;
  init_mathness=cur_mathness=maybe_math;
  @&lt;Match a production...@&gt;;
}
@ If we get to the end of the scrap list, category codes equal to zero are stored, since zero does not match anything in a production.

@&lt;Make sure the entries |pp| through |pp+3| of |cat| are defined@&gt;=
if (lo_ptr&lt;pp+3) {
  while (hi_ptr&lt;=scrap_ptr &amp;&amp; lo_ptr!=pp+3) {
    (++lo_ptr)-&gt;cat=hi_ptr-&gt;cat; lo_ptr-&gt;mathness=(hi_ptr)-&gt;mathness;
    lo_ptr-&gt;trans=(hi_ptr++)-&gt;trans;
  }
  for (i=lo_ptr+1;i&lt;=pp+3;i++) i-&gt;cat=0;
}
@ Let us consider the big switch for productions now, before looking at its context. We want to design the program so that this switch works, so we might as well not keep ourselves in suspense about exactly what code needs to be provided with a proper environment.

@d cat1 (pp+1)-&gt;cat
@d cat2 (pp+2)-&gt;cat
@d cat3 (pp+3)-&gt;cat
@d lhs_not_simple (pp-&gt;cat!=public_like
        &amp;&amp; pp-&gt;cat!=semi
        &amp;&amp; pp-&gt;cat!=prelangle
        &amp;&amp; pp-&gt;cat!=prerangle
        &amp;&amp; pp-&gt;cat!=template_like
        &amp;&amp; pp-&gt;cat!=new_like
        &amp;&amp; pp-&gt;cat!=new_exp
        &amp;&amp; pp-&gt;cat!=ftemplate
        &amp;&amp; pp-&gt;cat!=raw_ubin
        &amp;&amp; pp-&gt;cat!=const_like
        &amp;&amp; pp-&gt;cat!=raw_int
        &amp;&amp; pp-&gt;cat!=operator_like)
 /* not a production with left side length 1 */

@&lt;Match a production at |pp|, or increase |pp| if there is no match@&gt;= {
  if (cat1==end_arg &amp;&amp; lhs_not_simple)
    if (pp-&gt;cat==begin_arg) squash(pp,2,exp,-2,124);
    else squash(pp,2,end_arg,-1,125);
  else if (cat1==insert) squash(pp,2,pp-&gt;cat,-2,0);
  else if (cat2==insert) squash(pp+1,2,(pp+1)-&gt;cat,-1,0);
  else if (cat3==insert) squash(pp+2,2,(pp+2)-&gt;cat,0,0);
  else
  switch (pp-&gt;cat) {
    case exp: @&lt;Cases for |exp|@&gt;; @+break;
    case lpar: @&lt;Cases for |lpar|@&gt;; @+break;
    case unop: @&lt;Cases for |unop|@&gt;; @+break;
    case ubinop: @&lt;Cases for |ubinop|@&gt;; @+break;
    case binop: @&lt;Cases for |binop|@&gt;; @+break;
    case cast: @&lt;Cases for |cast|@&gt;; @+break;
    case sizeof_like: @&lt;Cases for |sizeof_like|@&gt;; @+break;
    case int_like: @&lt;Cases for |int_like|@&gt;; @+break;
    case public_like: @&lt;Cases for |public_like|@&gt;; @+break;
    case colcol: @&lt;Cases for |colcol|@&gt;; @+break;
    case decl_head: @&lt;Cases for |decl_head|@&gt;; @+break;
    case decl: @&lt;Cases for |decl|@&gt;; @+break;
    case base: @&lt;Cases for |base|@&gt;; @+break;
    case struct_like: @&lt;Cases for |struct_like|@&gt;; @+break;
    case struct_head: @&lt;Cases for |struct_head|@&gt;; @+break;
    case fn_decl: @&lt;Cases for |fn_decl|@&gt;; @+break;
    case function: @&lt;Cases for |function|@&gt;; @+break;
    case lbrace: @&lt;Cases for |lbrace|@&gt;; @+break;
    case if_like: @&lt;Cases for |if_like|@&gt;; @+break;
    case else_like: @&lt;Cases for |else_like|@&gt;; @+break;
    case else_head: @&lt;Cases for |else_head|@&gt;; @+break;
    case if_clause: @&lt;Cases for |if_clause|@&gt;; @+break;
    case if_head: @&lt;Cases for |if_head|@&gt;; @+break;
    case do_like: @&lt;Cases for |do_like|@&gt;; @+break;
    case case_like: @&lt;Cases for |case_like|@&gt;; @+break;
    case catch_like: @&lt;Cases for |catch_like|@&gt;; @+break;
    case tag: @&lt;Cases for |tag|@&gt;; @+break;
    case stmt: @&lt;Cases for |stmt|@&gt;; @+break;
    case semi: @&lt;Cases for |semi|@&gt;; @+break;
    case lproc: @&lt;Cases for |lproc|@&gt;; @+break;
    case section_scrap: @&lt;Cases for |section_scrap|@&gt;; @+break;
    case insert: @&lt;Cases for |insert|@&gt;; @+break;
    case prelangle: @&lt;Cases for |prelangle|@&gt;; @+break;
    case prerangle: @&lt;Cases for |prerangle|@&gt;; @+break;
    case langle: @&lt;Cases for |langle|@&gt;; @+break;
    case template_like: @&lt;Cases for |template_like|@&gt;; @+break;
    case new_like: @&lt;Cases for |new_like|@&gt;; @+break;
    case new_exp: @&lt;Cases for |new_exp|@&gt;; @+break;
    case ftemplate: @&lt;Cases for |ftemplate|@&gt;; @+break;
    case for_like: @&lt;Cases for |for_like|@&gt;; @+break;
    case raw_ubin: @&lt;Cases for |raw_ubin|@&gt;; @+break;
    case const_like: @&lt;Cases for |const_like|@&gt;; @+break;
    case raw_int: @&lt;Cases for |raw_int|@&gt;; @+break;
    case operator_like: @&lt;Cases for |operator_like|@&gt;; @+break;
    case typedef_like: @&lt;Cases for |typedef_like|@&gt;; @+break;
    case delete_like: @&lt;Cases for |delete_like|@&gt;; @+break;
    case question: @&lt;Cases for |question|@&gt;; @+break;
  }
  pp++; /* if no match was found, we move to the right */
}
@ Now comes the code that tries to match each production starting with a particular type of scrap. Whenever a match is discovered, the |squash| or |reduce| macro will cause the appropriate action to be performed, followed by |goto found|.

@&lt;Cases for |exp|@&gt;=
if (cat1==lbrace || cat1==int_like || cat1==decl) {
  make_underlined(pp); big_app1(pp); big_app(indent); app(indent);
  reduce(pp,1,fn_decl,0,1);
}
else if (cat1==unop) squash(pp,2,exp,-2,2);
else if ((cat1==binop || cat1==ubinop) &amp;&amp; cat2==exp)
        squash(pp,3,exp,-2,3);
else if (cat1==comma &amp;&amp; cat2==exp) {
  big_app2(pp);
  app(opt); app('9'); big_app1(pp+2); reduce(pp,3,exp,-2,4);
}
else if (cat1==lpar &amp;&amp; cat2==rpar &amp;&amp; cat3==colon) squash(pp+3,1,base,0,5);
else if (cat1==cast &amp;&amp; cat2==colon) squash(pp+2,1,base,0,5);
else if (cat1==semi) squash(pp,2,stmt,-1,6);
else if (cat1==colon) {
  make_underlined (pp);  squash(pp,2,tag,-1,7);
}
else if (cat1==rbrace) squash(pp,1,stmt,-1,8);
else if (cat1==lpar &amp;&amp; cat2==rpar &amp;&amp; (cat3==const_like || cat3==case_like)) {
  big_app1(pp+2); big_app(' '); big_app1(pp+3); reduce(pp+2,2,rpar,0,9);
}
else if (cat1==cast &amp;&amp; (cat2==const_like || cat2==case_like)) {
  big_app1(pp+1); big_app(' '); big_app1(pp+2); reduce(pp+1,2,cast,0,9);
}
else if (cat1==exp || cat1==cast) squash(pp,2,exp,-2,10);
@ @&lt;Cases for |lpar|@&gt;=
if ((cat1==exp||cat1==ubinop) &amp;&amp; cat2==rpar) squash(pp,3,exp,-2,11);
else if (cat1==rpar) {
  big_app1(pp); app('\\'); app(','); big_app1(pp+1);
@.\\,@&gt;
  reduce(pp,2,exp,-2,12);
}
else if ((cat1==decl_head || cat1==int_like || cat1==cast) &amp;&amp; cat2==rpar)
 squash(pp,3,cast,-2,13);
else if ((cat1==decl_head || cat1==int_like || cat1==exp) &amp;&amp; cat2==comma) {
  big_app3(pp); app(opt); app('9'); reduce(pp,3,lpar,-1,14);
}
else if (cat1==stmt || cat1==decl) {
  big_app2(pp); big_app(' '); reduce(pp,2,lpar,-1,15);
}
@ @&lt;Cases for |unop|@&gt;=
if (cat1==exp || cat1==int_like) squash(pp,2,exp,-2,16);
@ @&lt;Cases for |ubinop|@&gt;=
if (cat1==cast &amp;&amp; cat2==rpar) {
  big_app('{'); big_app1(pp); big_app('}'); big_app1(pp+1);
  reduce(pp,2,cast,-2,17);
}
else if (cat1==exp || cat1==int_like) {
  big_app('{'); big_app1(pp); big_app('}'); big_app1(pp+1);
  reduce(pp,2,cat1,-2,18);
}
else if (cat1==binop) {
  big_app(math_rel); big_app1(pp); big_app('{'); big_app1(pp+1); big_app('}');
  big_app('}'); reduce(pp,2,binop,-1,19);
}
@ @&lt;Cases for |binop|@&gt;=
if (cat1==binop) {
  big_app(math_rel); big_app('{'); big_app1(pp); big_app('}');
  big_app('{'); big_app1(pp+1); big_app('}');
  big_app('}'); reduce(pp,2,binop,-1,20);
}
@ @&lt;Cases for |cast|@&gt;=
if (cat1==lpar) squash(pp,2,lpar,-1,21);
else if (cat1==exp) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,exp,-2,21);
}
else if (cat1==semi) squash(pp,1,exp,-2,22);
@ @&lt;Cases for |sizeof_like|@&gt;=
if (cat1==cast) squash(pp,2,exp,-2,23);
else if (cat1==exp) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,exp,-2,24);
}
@ @&lt;Cases for |int_like|@&gt;=
if (cat1==int_like|| cat1==struct_like) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,cat1,-2,25);
}
else if (cat1==exp &amp;&amp; (cat2==raw_int||cat2==struct_like))
  squash(pp,2,int_like,-2,26);
else if (cat1==exp || cat1==ubinop || cat1==colon) {
  big_app1(pp); big_app(' '); reduce(pp,1,decl_head,-1,27);
}
else if (cat1==semi || cat1==binop) squash(pp,1,decl_head,0,28);
@ @&lt;Cases for |public_like|@&gt;=
if (cat1==colon) squash(pp,2,tag,-1,29);
else squash(pp,1,int_like,-2,30);
@ @&lt;Cases for |colcol|@&gt;=
if (cat1==exp||cat1==int_like) {
  app(qualifier); squash(pp,2,cat1,-2,31);
}@+else if (cat1==colcol) squash(pp,2,colcol,-1,32);
@ @&lt;Cases for |decl_head|@&gt;=
if (cat1==comma) {
  big_app2(pp); big_app(' '); reduce(pp,2,decl_head,-1,33);
}
else if (cat1==ubinop) {
  big_app1(pp); big_app('{'); big_app1(pp+1); big_app('}');
  reduce(pp,2,decl_head,-1,34);
}
else if (cat1==exp &amp;&amp; cat2!=lpar &amp;&amp; cat2!=exp &amp;&amp; cat2!=cast) {
  make_underlined(pp+1); squash(pp,2,decl_head,-1,35);
}
else if ((cat1==binop||cat1==colon) &amp;&amp; cat2==exp &amp;&amp; (cat3==comma ||
    cat3==semi || cat3==rpar))
  squash(pp,3,decl_head,-1,36);
else if (cat1==cast) squash(pp,2,decl_head,-1,37);
else if (cat1==lbrace || cat1==int_like || cat1==decl) {
  big_app1(pp); big_app(indent); app(indent); reduce(pp,1,fn_decl,0,38);
}
else if (cat1==semi) squash(pp,2,decl,-1,39);
@ @&lt;Cases for |decl|@&gt;=
if (cat1==decl) {
  big_app1(pp); big_app(force); big_app1(pp+1);
  reduce(pp,2,decl,-1,40);
}
else if (cat1==stmt || cat1==function) {
  big_app1(pp); big_app(big_force);
  big_app1(pp+1); reduce(pp,2,cat1,-1,41);
}
@ @&lt;Cases for |base|@&gt;=
if (cat1==int_like || cat1==exp) {
  if (cat2==comma) {
    big_app1(pp); big_app(' '); big_app2(pp+1);
    app(opt); app('9'); reduce(pp,3,base,0,42);
  }
  else if (cat2==lbrace) {
    big_app1(pp); big_app(' '); big_app1(pp+1); big_app(' '); big_app1(pp+2);
    reduce(pp,3,lbrace,-2,43);
  }
}
@ @&lt;Cases for |struct_like|@&gt;=
if (cat1==lbrace) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,struct_head,0,44);
}
else if (cat1==exp||cat1==int_like) {
  if (cat2==lbrace || cat2==semi) {
    make_underlined(pp+1); make_reserved(pp+1);
    big_app1(pp); big_app(' '); big_app1(pp+1);
    if (cat2==semi) reduce(pp,2,decl_head,0,45);
    else {
      big_app(' '); big_app1(pp+2);reduce(pp,3,struct_head,0,46);
    }
  }
  else if (cat2==colon) squash(pp+2,1,base,2,47);
  else if (cat2!=base) {
    big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,int_like,-2,48);
  }
}
@ @&lt;Cases for |struct_head|@&gt;=
if ((cat1==decl || cat1==stmt || cat1==function) &amp;&amp; cat2==rbrace) {
  big_app1(pp); big_app(indent); big_app(force); big_app1(pp+1);
  big_app(outdent); big_app(force);  big_app1(pp+2);
  reduce(pp,3,int_like,-2,49);
}
else if (cat1==rbrace) {
  big_app1(pp); app_str("\\,"); big_app1(pp+1);
@.\\,@&gt;
  reduce(pp,2,int_like,-2,50);
}
@ @&lt;Cases for |fn_decl|@&gt;=
if (cat1==decl) {
  big_app1(pp); big_app(force); big_app1(pp+1); reduce(pp,2,fn_decl,0,51);
}
else if (cat1==stmt) {
  big_app1(pp); app(outdent); app(outdent); big_app(force);
  big_app1(pp+1); reduce(pp,2,function,-1,52);
}
@ @&lt;Cases for |function|@&gt;=
if (cat1==function || cat1==decl || cat1==stmt) {
  big_app1(pp); big_app(big_force); big_app1(pp+1); reduce(pp,2,cat1,-1,53);
}
@ @&lt;Cases for |lbrace|@&gt;=
if (cat1==rbrace) {
  big_app1(pp); app('\\'); app(','); big_app1(pp+1);
@.\\,@&gt;
  reduce(pp,2,stmt,-1,54);
}
else if ((cat1==stmt||cat1==decl||cat1==function) &amp;&amp; cat2==rbrace) {
  big_app(force); big_app1(pp);  big_app(indent); big_app(force);
  big_app1(pp+1); big_app(force); big_app(backup);  big_app1(pp+2);
  big_app(outdent); big_app(force); reduce(pp,3,stmt,-1,55);
}
else if (cat1==exp) {
  if (cat2==rbrace) squash(pp,3,exp,-2,56);
  else if (cat2==comma &amp;&amp; cat3==rbrace) squash(pp,4,exp,-2,56);
}
@ @&lt;Cases for |if_like|@&gt;=
if (cat1==exp) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,if_clause,0,57);
}
@ @&lt;Cases for |else_like|@&gt;=
if (cat1==colon) squash(pp+1,1,base,1,58);
else if (cat1==lbrace) squash(pp,1,else_head,0,59);
else if (cat1==stmt) {
  big_app(force); big_app1(pp); big_app(indent); big_app(break_space);
  big_app1(pp+1); big_app(outdent); big_app(force);
  reduce(pp,2,stmt,-1,60);
}
@ @&lt;Cases for |else_head|@&gt;=
if (cat1==stmt || cat1==exp) {
  big_app(force); big_app1(pp); big_app(break_space); app(noop);
  big_app(cancel); big_app1(pp+1); big_app(force);
  reduce(pp,2,stmt,-1,61);
}
@ @&lt;Cases for |if_clause|@&gt;=
if (cat1==lbrace) squash(pp,1,if_head,0,62);
else if (cat1==stmt) {
  if (cat2==else_like) {
    big_app(force); big_app1(pp); big_app(indent); big_app(break_space);
    big_app1(pp+1); big_app(outdent); big_app(force); big_app1(pp+2);
    if (cat3==if_like) {
      big_app(' '); big_app1(pp+3); reduce(pp,4,if_like,0,63);
    }@+else reduce(pp,3,else_like,0,64);
  }
  else squash(pp,1,else_like,0,65);
}
@ @&lt;Cases for |if_head|@&gt;=
if (cat1==stmt || cat1==exp) {
  if (cat2==else_like) {
    big_app(force); big_app1(pp); big_app(break_space); app(noop);
    big_app(cancel); big_app1(pp+1); big_app(force); big_app1(pp+2);
    if (cat3==if_like) {
      big_app(' '); big_app1(pp+3); reduce(pp,4,if_like,0,66);
    }@+else reduce(pp,3,else_like,0,67);
  }
  else squash(pp,1,else_head,0,68);
}
@ @&lt;Cases for |do_like|@&gt;=
if (cat1==stmt &amp;&amp; cat2==else_like &amp;&amp; cat3==semi) {
  big_app1(pp); big_app(break_space); app(noop); big_app(cancel);
  big_app1(pp+1); big_app(cancel); app(noop); big_app(break_space);
  big_app2(pp+2); reduce(pp,4,stmt,-1,69);
}
@ @&lt;Cases for |case_like|@&gt;=
if (cat1==semi) squash(pp,2,stmt,-1,70);
else if (cat1==colon) squash(pp,2,tag,-1,71);
else if (cat1==exp) {
  big_app1(pp); big_app(' ');  big_app1(pp+1);  reduce(pp,2,exp,-2,72);
}
@ @&lt;Cases for |catch_like|@&gt;=
if (cat1==cast || cat1==exp) {
  big_app2(pp); big_app(indent); big_app(indent); reduce(pp,2,fn_decl,0,73);
}
@ @&lt;Cases for |tag|@&gt;=
if (cat1==tag) {
  big_app1(pp); big_app(break_space); big_app1(pp+1); reduce(pp,2,tag,-1,74);
}
else if (cat1==stmt||cat1==decl||cat1==function) {
  big_app(force); big_app(backup); big_app1(pp); big_app(break_space);
  big_app1(pp+1); reduce(pp,2,cat1,-1,75);
}
@ The user can decide at run-time whether short statements should be grouped together on the same line.

@d force_lines flags['f'] /* should each statement be on its own line? */
@&lt;Cases for |stmt|@&gt;=
if (cat1==stmt||cat1==decl||cat1==function) {
  big_app1(pp);
  if (cat1==function) big_app(big_force);
  else if (cat1==decl) big_app(big_force);
  else if (force_lines) big_app(force);
  else big_app(break_space);
  big_app1(pp+1); reduce(pp,2,cat1,-1,76);
}
@ @&lt;Cases for |semi|@&gt;=
big_app(' '); big_app1(pp); reduce(pp,1,stmt,-1,77);
@ @&lt;Cases for |lproc|@&gt;=
if (cat1==define_like) make_underlined(pp+2);
if (cat1==else_like || cat1==if_like ||cat1==define_like)
  squash(pp,2,lproc,0,78);
else if (cat1==rproc) {
  app(inserted); big_app2(pp); reduce(pp,2,insert,-1,79);
} else if (cat1==exp || cat1==function) {
  if (cat2==rproc) {
    app(inserted); big_app1(pp); big_app(' '); big_app2(pp+1);
    reduce(pp,3,insert,-1,80);
  }
  else if (cat2==exp &amp;&amp; cat3==rproc &amp;&amp; cat1==exp) {
    app(inserted); big_app1(pp); big_app(' '); big_app1(pp+1); app_str(" \\5");
@.\\5@&gt;
    big_app2(pp+2); reduce(pp,4,insert,-1,80);
  }
}
@ @&lt;Cases for |section_scrap|@&gt;=
if (cat1==semi) {
  big_app2(pp); big_app(force); reduce(pp,2,stmt,-2,81);
}
else squash(pp,1,exp,-2,82);
@ @&lt;Cases for |insert|@&gt;=
if (cat1)
  squash(pp,2,cat1,0,83);
@ @&lt;Cases for |prelangle|@&gt;=
init_mathness=cur_mathness=yes_math;
app('&lt;'); reduce(pp,1,binop,-2,84);
@ @&lt;Cases for |prerangle|@&gt;=
init_mathness=cur_mathness=yes_math;
app('&gt;'); reduce(pp,1,binop,-2,85);
@ @&lt;Cases for |langle|@&gt;=
if (cat1==prerangle) {
  big_app1(pp); app('\\'); app(','); big_app1(pp+1);
@.\\,@&gt;
  reduce(pp,2,cast,-1,86);
}
else if (cat1==decl_head || cat1==int_like || cat1==exp) {
  if (cat2==prerangle) squash(pp,3,cast,-1,87);
  else if (cat2==comma) {
    big_app3(pp); app(opt); app('9'); reduce(pp,3,langle,0,88);
  }
}
@ @&lt;Cases for |template_like|@&gt;=
if (cat1==exp &amp;&amp; cat2==prelangle) squash(pp+2,1,langle,2,89);
else if (cat1==exp || cat1==raw_int) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,cat1,-2,90);
}@+ else squash(pp,1,raw_int,0,91);
@ @&lt;Cases for |new_like|@&gt;=
if (cat1==lpar &amp;&amp; cat2==exp &amp;&amp; cat3==rpar) squash(pp,4,new_like,0,92);
else if (cat1==cast) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,exp,-2,93);
}
else if (cat1!=lpar) squash(pp,1,new_exp,0,94);
@ @&lt;Cases for |new_exp|@&gt;=
if (cat1==int_like || cat1==const_like) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,new_exp,0,95);
}
else if (cat1==struct_like &amp;&amp; (cat2==exp || cat2==int_like)) {
  big_app1(pp); big_app(' '); big_app1(pp+1); big_app(' ');
  big_app1(pp+2); reduce(pp,3,new_exp,0,96);
}
else if (cat1==raw_ubin) {
  big_app1(pp); big_app('{'); big_app1(pp+1); big_app('}');
  reduce(pp,2,new_exp,0,97);
}
else if (cat1==lpar) squash(pp,1,exp,-2,98);
else if (cat1==exp) {
  big_app1(pp); big_app(' '); reduce(pp,1,exp,-2,98);
}
else if (cat1!=raw_int &amp;&amp; cat1!=struct_like &amp;&amp; cat1!=colcol)
  squash(pp,1,exp,-2,99);
@ @&lt;Cases for |ftemplate|@&gt;=
if (cat1==prelangle) squash(pp+1,1,langle,1,100);
else squash(pp,1,exp,-2,101);
@ @&lt;Cases for |for_like|@&gt;=
if (cat1==exp) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,else_like,-2,102);
}
@ @&lt;Cases for |raw_ubin|@&gt;=
if (cat1==const_like) {
  big_app2(pp); app_str("\\ "); reduce(pp,2,raw_ubin,0,103);
@.\\\ @&gt;
} else squash(pp,1,ubinop,-2,104);
@ @&lt;Cases for |const_like|@&gt;=
squash(pp,1,int_like,-2,105);
@ @&lt;Cases for |raw_int|@&gt;=
if (cat1==prelangle) squash(pp+1,1,langle,1,106);
else if (cat1==colcol) squash(pp,2,colcol,-1,107);
else if (cat1==cast) squash(pp,2,raw_int,0,108);
else if (cat1==lpar) squash(pp,1,exp,-2,109);
else if (cat1!=langle) squash(pp,1,int_like,-3,110);
@ @&lt;Cases for |operator_like|@&gt;=
if (cat1==binop || cat1==unop || cat1==ubinop) {
  if (cat2==binop) break;
  big_app1(pp); big_app('{'); big_app1(pp+1); big_app('}');
  reduce(pp,2,exp,-2,111);
}
else if (cat1==new_like || cat1==delete_like) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,exp,-2,112);
}
else if (cat1==comma) squash(pp,2,exp,-2,113);
else if (cat1!=raw_ubin) squash(pp,1,new_exp,0,114);
@ @&lt;Cases for |typedef_like|@&gt;=
if ((cat1==int_like || cat1==cast) &amp;&amp; (cat2==comma || cat2==semi))
  squash(pp+1,1,exp,-1,115);
else if (cat1==int_like) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,typedef_like,0,116);
}
else if (cat1==exp &amp;&amp; cat2!=lpar &amp;&amp; cat2!=exp &amp;&amp; cat2!=cast) {
  make_underlined(pp+1); make_reserved(pp+1);
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,typedef_like,0,117);
}
else if (cat1==comma) {
  big_app2(pp); big_app(' '); reduce(pp,2,typedef_like,0,118);
}
else if (cat1==semi) squash(pp,2,decl,-1,119);
else if (cat1==ubinop &amp;&amp; (cat2==ubinop || cat2==cast)) {
  big_app('{'); big_app1(pp+1); big_app('}'); big_app1(pp+2);
  reduce(pp+1,2,cat2,0,120);
}
@ @&lt;Cases for |delete_like|@&gt;=
if (cat1==lpar &amp;&amp; cat2==rpar) {
  big_app2(pp); app('\\'); app(','); big_app1(pp+2);
@.\\,@&gt;
  reduce(pp,3,delete_like,0,121);
}
else if (cat1==exp) {
  big_app1(pp); big_app(' '); big_app1(pp+1); reduce(pp,2,exp,-2,122);
}
@ @&lt;Cases for |question|@&gt;=
if (cat1==exp &amp;&amp; (cat2==colon || cat2==base)) {
  (pp+2)-&gt;mathness=5*yes_math; /* this colon should be in math mode */
  squash(pp,3,binop,-2,123);
}
@ If the initial sequence of scraps does not reduce to a single scrap, we concatenate the translations of all remaining scraps, separated by blank spaces, with dollar signs surrounding the translations of scraps where appropriate.

@&lt;Combine the irreducible scraps that remain@&gt;= {
  @&lt;If semi-tracing, show the irreducible scraps@&gt;;
  for (j=scrap_base; j&lt;=lo_ptr; j++) {
    if (j!=scrap_base) app(' ');
    if (j-&gt;mathness % 4 == yes_math) app('$');
    app1(j);
    if (j-&gt;mathness / 4 == yes_math) app('$');
    if (tok_ptr+6&gt;tok_mem_end) overflow("token");
  }
  freeze_text; return(text_ptr-1);
}
@ @&lt;If semi-tracing, show the irreducible scraps@&gt;=
if (lo_ptr&gt;scrap_base &amp;&amp; tracing==1) {
  printf("\nIrreducible scrap sequence in section %d:",section_count);
@.Irreducible scrap sequence...@&gt;
  mark_harmless;
  for (j=scrap_base; j&lt;=lo_ptr; j++) {
    printf(" "); print_cat(j-&gt;cat);
  }
}
@* Initializing the scraps. If we are going to use the powerful production mechanism just developed, we must get the scraps set up in the first place, given a \CEE/ text. A table of the initial scraps corresponding to \CEE/ tokens appeared above in the section on parsing; our goal now is to implement that table. We shall do this by implementing a subroutine called |C_parse| that is analogous to the |C_xref| routine used during phase one.  Like |C_xref|, the |C_parse| procedure starts with the current value of |next_control| and it uses the operation |next_control=get_next()| repeatedly to read \CEE/ text until encountering the next `\.{\v}' or `\.{/*}', or until |next_control&gt;=format_code|. The scraps corresponding to what it reads are appended into the |cat| and |trans| arrays, and |scrap_ptr| is advanced.

@c
void
C_parse(spec_ctrl) /* creates scraps from \CEE/ tokens */
  eight_bits spec_ctrl;
{
  int count; /* characters remaining before string break */
  while (next_control&lt;format_code || next_control==spec_ctrl) {
    @&lt;Append the scrap appropriate to |next_control|@&gt;;
    next_control=get_next();
    if (next_control=='|' || next_control==begin_comment ||
        next_control==begin_short_comment) return;
  }
}@ The following macro is used to append a scrap whose tokens have just been appended:

@d app_scrap(c,b) {
  (++scrap_ptr)-&gt;cat=(c); scrap_ptr-&gt;trans=text_ptr;
  scrap_ptr-&gt;mathness=5*(b); /* no no, yes yes, or maybe maybe */
  freeze_text;
}
@ @&lt;Append the scr...@&gt;=
@&lt;Make sure that there is room for the new scraps, tokens, and texts@&gt;;
switch (next_control) {
  case section_name:
    app(section_flag+(int)(cur_section-name_dir));
    app_scrap(section_scrap,maybe_math);
    app_scrap(exp,yes_math);@+break;
  case string: case constant: case verbatim: @&lt;Append a string or constant@&gt;;
   @+break;
  case identifier: app_cur_id(1);@+break;
  case TeX_string: @&lt;Append a \TEX/ string, without forming a scrap@&gt;;@+break;
  case '/': case '.':
    app(next_control); app_scrap(binop,yes_math);@+break;
  case '&lt;': app_str("\\langle");@+app_scrap(prelangle,yes_math);@+break;
@.\\langle@&gt;
  case '&gt;': app_str("\\rangle");@+app_scrap(prerangle,yes_math);@+break;
@.\\rangle@&gt;
  case '=': app_str("\\K"); app_scrap(binop,yes_math);@+break;
@.\\K@&gt;
  case '|': app_str("\\OR"); app_scrap(binop,yes_math);@+break;
@.\\OR@&gt;
  case '^': app_str("\\XOR"); app_scrap(binop,yes_math);@+break;
@.\\XOR@&gt;
  case '%': app_str("\\MOD"); app_scrap(binop,yes_math);@+break;
@.\\MOD@&gt;
  case '!': app_str("\\R"); app_scrap(unop,yes_math);@+break;
@.\\R@&gt;
  case '~': app_str("\\CM"); app_scrap(unop,yes_math);@+break;
@.\\CM@&gt;
  case '+': case '-': app(next_control); app_scrap(ubinop,yes_math);@+break;
  case '*': app(next_control); app_scrap(raw_ubin,yes_math);@+break;
  case '&amp;': app_str("\\AND"); app_scrap(raw_ubin,yes_math);@+break;
@.\\AND@&gt;
  case '?': app_str("\\?"); app_scrap(question,yes_math);@+break;
@.\\?@&gt;
  case '#': app_str("\\#"); app_scrap(ubinop,yes_math);@+break;
@.\\\#@&gt;
  case ignore: case xref_roman: case xref_wildcard:
  case xref_typewriter: case noop:@+break;
  case '(': case '[': app(next_control); app_scrap(lpar,maybe_math);@+break;
  case ')': case ']': app(next_control); app_scrap(rpar,maybe_math);@+break;
  case '{': app_str("\\{"@q}@&gt;); app_scrap(lbrace,yes_math);@+break;
@.\\\{@&gt;@q}@&gt;
  case '}': app_str(@q{@&gt;"\\}"); app_scrap(rbrace,yes_math);@+break;
@q{@&gt;@.\\\}@&gt;
  case ',': app(','); app_scrap(comma,yes_math);@+break;
  case ';': app(';'); app_scrap(semi,maybe_math);@+break;
  case ':': app(':'); app_scrap(colon,no_math);@+break;@/
  @t\4@&gt;  @&lt;Cases involving nonstandard characters@&gt;@;
  case thin_space: app_str("\\,"); app_scrap(insert,maybe_math);@+break;
@.\\,@&gt;
  case math_break: app(opt); app_str("0");
    app_scrap(insert,maybe_math);@+break;
  case line_break: app(force); app_scrap(insert,no_math);@+break;
  case left_preproc: app(force); app(preproc_line);
    app_str("\\#"); app_scrap(lproc,no_math);@+break;
@.\\\#@&gt;
  case right_preproc: app(force); app_scrap(rproc,no_math);@+break;
  case big_line_break: app(big_force); app_scrap(insert,no_math);@+break;
  case no_line_break: app(big_cancel); app(noop); app(break_space);
    app(noop); app(big_cancel);
    app_scrap(insert,no_math);@+break;
  case pseudo_semi: app_scrap(semi,maybe_math);@+break;
  case macro_arg_open: app_scrap(begin_arg,maybe_math);@+break;
  case macro_arg_close: app_scrap(end_arg,maybe_math);@+break;
  case join: app_str("\\J"); app_scrap(insert,no_math);@+break;
@.\\J@&gt;
  case output_defs_code: app(force); app_str("\\ATH"); app(force);
    app_scrap(insert,no_math);@+break;
@.\\ATH@&gt;
  default: app(inserted); app(next_control);
    app_scrap(insert,maybe_math);@+break;
}
@ @&lt;Make sure that there is room for the new...@&gt;=
if (scrap_ptr+safe_scrap_incr&gt;scrap_info_end ||
  tok_ptr+safe_tok_incr&gt;tok_mem_end @| ||
  text_ptr+safe_text_incr&gt;tok_start_end) {
  if (scrap_ptr&gt;max_scr_ptr) max_scr_ptr=scrap_ptr;
  if (tok_ptr&gt;max_tok_ptr) max_tok_ptr=tok_ptr;
  if (text_ptr&gt;max_text_ptr) max_text_ptr=text_ptr;
  overflow("scrap/token/text");
}
@ Some nonstandard characters may have entered \.{CWEAVE} by means of standard ones. They are converted to \TEX/ control sequences so that it is possible to keep \.{CWEAVE} from outputting unusual |char| codes.

@&lt;Cases involving nonstandard characters@&gt;=
case not_eq: app_str("\\I");@+app_scrap(binop,yes_math);@+break;
@.\\I@&gt;
case lt_eq: app_str("\\Z");@+app_scrap(binop,yes_math);@+break;
@.\\Z@&gt;
case gt_eq: app_str("\\G");@+app_scrap(binop,yes_math);@+break;
@.\\G@&gt;
case eq_eq: app_str("\\E");@+app_scrap(binop,yes_math);@+break;
@.\\E@&gt;
case and_and: app_str("\\W");@+app_scrap(binop,yes_math);@+break;
@.\\W@&gt;
case or_or: app_str("\\V");@+app_scrap(binop,yes_math);@+break;
@.\\V@&gt;
case plus_plus: app_str("\\PP");@+app_scrap(unop,yes_math);@+break;
@.\\PP@&gt;
case minus_minus: app_str("\\MM");@+app_scrap(unop,yes_math);@+break;
@.\\MM@&gt;
case minus_gt: app_str("\\MG");@+app_scrap(binop,yes_math);@+break;
@.\\MG@&gt;
case gt_gt: app_str("\\GG");@+app_scrap(binop,yes_math);@+break;
@.\\GG@&gt;
case lt_lt: app_str("\\LL");@+app_scrap(binop,yes_math);@+break;
@.\\LL@&gt;
case dot_dot_dot: app_str("\\,\\ldots\\,");@+app_scrap(raw_int,yes_math);
  @+break;
@.\\,@&gt;
@.\\ldots@&gt;
case colon_colon: app_str("\\DC");@+app_scrap(colcol,maybe_math);@+break;
@.\\DC@&gt;
case period_ast: app_str("\\PA");@+app_scrap(binop,yes_math);@+break;
@.\\PA@&gt;
case minus_gt_ast: app_str("\\MGA");@+app_scrap(binop,yes_math);@+break;
@.\\MGA@&gt;
@ The following code must use |app_tok| instead of |app| in order to protect against overflow. Note that |tok_ptr+1&lt;=max_toks| after |app_tok| has been used, so another |app| is legitimate before testing again.  Many of the special characters in a string must be prefixed by `\.\\' so that \TEX/ will print them properly. @^special string characters@&gt;

@&lt;Append a string or constant@&gt;=
count= -1;
if (next_control==constant) app_str("\\T{"@q}@&gt;);
@.\\T@&gt;
else if (next_control==string) {
  count=20; app_str("\\.{"@q}@&gt;);
}
@.\\.@&gt;
else app_str("\\vb{"@q}@&gt;);
@.\\vb@&gt;
while (id_first&lt;id_loc) {
  if (count==0) { /* insert a discretionary break in a long string */
     app_str(@q(@&gt;@q{@&gt;"}\\)\\.{"@q}@&gt;); count=20;
@q(@&gt;@.\\)@&gt;
  }
@^high-bit character handling@&gt;
  if((eight_bits)(*id_first)&gt;0177) {
    app_tok(quoted_char);
    app_tok((eight_bits)(*id_first++));
  }
  else {
    switch (*id_first) {
      case  ' ':case '\\':case '#':case '%':case '$':case '^':
      case '{': case '}': case '~': case '&amp;': case '_': app('\\'); break;
@.\\\ @&gt;
@.\\\\@&gt;
@.\\\#@&gt;
@.\\\%@&gt;
@.\\\$@&gt;
@.\\\^@&gt;
@.\\\{@&gt;@q}@&gt;
@q{@&gt;@.\\\}@&gt;
@.\\\~@&gt;
@.\\\&amp;@&gt;
@.\\\_@&gt;
      case '@@': if (*(id_first+1)=='@@') id_first++;
        else err_print("! Double @@ should be used in strings");
@.Double @@ should be used...@&gt;
    }
    app_tok(*id_first++);
  }
  count--;
}
app(@q{@&gt;'}');
app_scrap(exp,maybe_math);
@ We do not make the \TEX/ string into a scrap, because there is no telling what the user will be putting into it; instead we leave it open, to be picked up by the next scrap. If it comes at the end of a section, it will be made into a scrap when |finish_C| is called.  There's a known bug here, in cases where an adjacent scrap is |prelangle| or |prerangle|. Then the \TEX/ string can disappear when the \.{\\langle} or \.{\\rangle} becomes \.{&lt;} or \.{&gt;}. For example, if the user writes \.{\v x&lt;@@ty@@&gt;\v}, the \TEX/ string \.{\\hbox\{y\}} eventually becomes part of an |insert| scrap, which is combined with a |prelangle| scrap and eventually lost. The best way to work around this bug is probably to enclose the \.{@@t...@@&gt;} in \.{@@[...@@]} so that the \TEX/ string is treated as an expression. @^bug, known@&gt;

@&lt;Append a \TEX/ string, without forming a scrap@&gt;=
app_str("\\hbox{"@q}@&gt;);
@^high-bit character handling@&gt;
while (id_first&lt;id_loc)
  if((eight_bits)(*id_first)&gt;0177) {
    app_tok(quoted_char);
    app_tok((eight_bits)(*id_first++));
  }
  else {
    if (*id_first=='@@') id_first++;
    app_tok(*id_first++);
  }
app(@q{@&gt;'}');
@ The function |app_cur_id| appends the current identifier to the token list; it also builds a new scrap if |scrapping==1|.

@&lt;Predeclaration of procedures@&gt;=
void app_cur_id();

@ @c
void
app_cur_id(scrapping)
boolean scrapping; /* are we making this into a scrap? */
{
  name_pointer p=id_lookup(id_first,id_loc,normal);
  if (p-&gt;ilk&lt;=custom) { /* not a reserved word */
    app(id_flag+(int)(p-name_dir));
    if (scrapping) app_scrap(p-&gt;ilk==func_template? ftemplate: exp,
                             p-&gt;ilk==custom? yes_math: maybe_math);
@.\\NULL@&gt;
  } else {
    app(res_flag+(int)(p-name_dir));
    if (scrapping) {
      if (p-&gt;ilk==alfop) app_scrap(ubinop,yes_math)@;
      else app_scrap(p-&gt;ilk,maybe_math);
    }
  }
}
@ When the `\.{\v}' that introduces \CEE/ text is sensed, a call on |C_translate| will return a pointer to the \TEX/ translation of that text. If scraps exist in |scrap_info|, they are unaffected by this translation process.

@c
text_pointer
C_translate()
{
  text_pointer p; /* points to the translation */
  scrap_pointer save_base; /* holds original value of |scrap_base| */
  save_base=scrap_base; scrap_base=scrap_ptr+1;
  C_parse(section_name); /* get the scraps together */
  if (next_control!='|') err_print("! Missing '|' after C text");
@.Missing '|'...@&gt;
  app_tok(cancel); app_scrap(insert,maybe_math);
        /* place a |cancel| token as a final ``comment'' */
  p=translate(); /* make the translation */
  if (scrap_ptr&gt;max_scr_ptr) max_scr_ptr=scrap_ptr;
  scrap_ptr=scrap_base-1; scrap_base=save_base; /* scrap the scraps */
  return(p);
}@ The |outer_parse| routine is to |C_parse| as |outer_xref| is to |C_xref|: It constructs a sequence of scraps for \CEE/ text until |next_control&gt;=format_code|. Thus, it takes care of embedded comments.  The token list created from within `\pb' brackets is output as an argument to \.{\\PB}, if the user has invoked \.{CWEAVE} with the \.{+e} flag. Although \.{cwebmac} ignores \.{\\PB}, other macro packages might use it to localize the special meaning of the macros that mark up program text.

@d make_pb flags['e']

@c
void
outer_parse() /* makes scraps from \CEE/ tokens and comments */
{
  int bal; /* brace level in comment */
  text_pointer p, q; /* partial comments */
  while (next_control&lt;format_code)
    if (next_control!=begin_comment &amp;&amp; next_control!=begin_short_comment)
      C_parse(ignore);
    else {
      boolean is_long_comment=(next_control==begin_comment);
      @&lt;Make sure that there is room for the new...@&gt;;
      app(cancel); app(inserted);
      if (is_long_comment) app_str("\\C{"@q}@&gt;);
@.\\C@&gt;
      else app_str("\\SHC{"@q}@&gt;);
@.\\SHC@&gt;
      bal=copy_comment(is_long_comment,1); next_control=ignore;
      while (bal&gt;0) {
        p=text_ptr; freeze_text; q=C_translate();
         /* at this point we have |tok_ptr+6&lt;=max_toks| */
        app(tok_flag+(int)(p-tok_start));
        if (make_pb) app_str("\\PB{");
@.\\PB@&gt;
        app(inner_tok_flag+(int)(q-tok_start));
        if (make_pb)  app_tok('}');
        if (next_control=='|') {
          bal=copy_comment(is_long_comment,bal);
          next_control=ignore;
        }
        else bal=0; /* an error has been reported */
      }
      app(force); app_scrap(insert,no_math);
        /* the full comment becomes a scrap */
    }
}@* Output of tokens.
So far our programs have only built up multi-layered token lists in
\.{CWEAVE}'s internal memory; we have to figure out how to get them into
the desired final form. The job of converting token lists to characters in
the \TEX/ output file is not difficult, although it is an implicitly
recursive process. Four main considerations had to be kept in mind when
this part of \.{CWEAVE} was designed.  (a) There are two modes of output:
|outer| mode, which translates tokens like |force| into line-breaking
control sequences, and |inner| mode, which ignores them except that blank
spaces take the place of line breaks. (b) The |cancel| instruction applies
to adjacent token or tokens that are output, and this cuts across levels
of recursion since `|cancel|' occurs at the beginning or end of a token
list on one level. (c) The \TEX/ output file will be semi-readable if line
breaks are inserted after the result of tokens like |break_space| and
|force|.  (d) The final line break should be suppressed, and there should
be no |force| token output immediately after `\.{\\Y\\B}'.@ The output process uses a stack to keep track of what is going on at different ``levels'' as the token lists are being written out. Entries on this stack have three parts:  \yskip\hang |end_field| is the |tok_mem| location where the token list of a particular level will end;  \yskip\hang |tok_field| is the |tok_mem| location from which the next token on a particular level will be read;  \yskip\hang |mode_field| is the current mode, either |inner| or |outer|.  \yskip\noindent The current values of these quantities are referred to quite frequently, so they are stored in a separate place instead of in the |stack| array. We call the current values |cur_end|, |cur_tok|, and |cur_mode|.  The global variable |stack_ptr| tells how many levels of output are currently in progress. The end of output occurs when an |end_translation| token is found, so the stack is never empty except when we first begin the output process.

@d inner 0 /* value of |mode| for \CEE/ texts within \TEX/ texts */
@d outer 1 /* value of |mode| for \CEE/ texts in sections */

@&lt;Typedef declarations@&gt;= typedef int mode;
typedef struct {
  token_pointer end_field; /* ending location of token list */
  token_pointer tok_field; /* present location within token list */
  boolean mode_field; /* interpretation of control tokens */
} output_state;
typedef output_state *stack_pointer;

@ @d cur_end cur_state.end_field /* current ending location in |tok_mem| */
@d cur_tok cur_state.tok_field /* location of next output token in |tok_mem| */
@d cur_mode cur_state.mode_field /* current mode of interpretation */
@d init_stack stack_ptr=stack;cur_mode=outer /* initialize the stack */

@&lt;Global variables@&gt;=
output_state cur_state; /* |cur_end|, |cur_tok|, |cur_mode| */
output_state stack[stack_size]; /* info for non-current levels */
stack_pointer stack_ptr; /* first unused location in the output state stack */
stack_pointer stack_end=stack+stack_size-1; /* end of |stack| */
stack_pointer max_stack_ptr; /* largest value assumed by |stack_ptr| */

@ @&lt;Set init...@&gt;=
max_stack_ptr=stack;
@ To insert token-list |p| into the output, the |push_level| subroutine is called; it saves the old level of output and gets a new one going. The value of |cur_mode| is not changed.

@c
void
push_level(p) /* suspends the current level */
text_pointer p;
{
  if (stack_ptr==stack_end) overflow("stack");
  if (stack_ptr&gt;stack) { /* save current state */
    stack_ptr-&gt;end_field=cur_end;
    stack_ptr-&gt;tok_field=cur_tok;
    stack_ptr-&gt;mode_field=cur_mode;
  }
  stack_ptr++;
  if (stack_ptr&gt;max_stack_ptr) max_stack_ptr=stack_ptr;
  cur_tok=*p; cur_end=*(p+1);
}@ Conversely, the |pop_level| routine restores the conditions that were in force when the current level was begun. This subroutine will never be called when |stack_ptr==1|.

@c
void
pop_level()
{
  cur_end=(--stack_ptr)-&gt;end_field;
  cur_tok=stack_ptr-&gt;tok_field; cur_mode=stack_ptr-&gt;mode_field;
}@ The |get_output| function returns the next byte of output that is not a reference to a token list. It returns the values |identifier| or |res_word| or |section_code| if the next token is to be an identifier (typeset in italics), a reserved word (typeset in boldface), or a section name (typeset by a complex routine that might generate additional levels of output). In these cases |cur_name| points to the identifier or section name in question.

@&lt;Global variables@&gt;=
name_pointer cur_name;

@ @d res_word 0201 /* returned by |get_output| for reserved words */
@d section_code 0200 /* returned by |get_output| for section names */

@c
eight_bits
get_output() /* returns the next token of output */
{
  sixteen_bits a; /* current item read from |tok_mem| */
  restart: while (cur_tok==cur_end) pop_level();
  a=*(cur_tok++);
  if (a&gt;=0400) {
    cur_name=a % id_flag + name_dir;
    switch (a / id_flag) {
      case 2: return(res_word); /* |a==res_flag+cur_name| */
      case 3: return(section_code); /* |a==section_flag+cur_name| */
      case 4: push_level(a % id_flag + tok_start); goto restart;
        /* |a==tok_flag+cur_name| */
      case 5: push_level(a % id_flag + tok_start); cur_mode=inner; goto restart;
        /* |a==inner_tok_flag+cur_name| */
      default: return(identifier); /* |a==id_flag+cur_name| */
    }
  }
  return(a);
}@ The real work associated with token output is done by |make_output|. This procedure appends an |end_translation| token to the current token list, and then it repeatedly calls |get_output| and feeds characters to the output buffer until reaching the |end_translation| sentinel. It is possible for |make_output| to be called recursively, since a section name may include embedded \CEE/ text; however, the depth of recursion never exceeds one level, since section names cannot be inside of section names.  A procedure called |output_C| does the scanning, translation, and output of \CEE/ text within `\pb' brackets, and this procedure uses |make_output| to output the current token list. Thus, the recursive call of |make_output| actually occurs when |make_output| calls |output_C| while outputting the name of a section. @^recursion@&gt;

@c
void
output_C() /* outputs the current token list */
{
  token_pointer save_tok_ptr;
  text_pointer save_text_ptr;
  sixteen_bits save_next_control; /* values to be restored */
  text_pointer p; /* translation of the \CEE/ text */
  save_tok_ptr=tok_ptr; save_text_ptr=text_ptr;
  save_next_control=next_control; next_control=ignore; p=C_translate();
  app(inner_tok_flag+(int)(p-tok_start));
  if (make_pb) {
    out_str("\\PB{"); make_output(); out('}');
@.\\PB@&gt;
  }@+else make_output(); /* output the list */
  if (text_ptr&gt;max_text_ptr) max_text_ptr=text_ptr;
  if (tok_ptr&gt;max_tok_ptr) max_tok_ptr=tok_ptr;
  text_ptr=save_text_ptr; tok_ptr=save_tok_ptr; /* forget the tokens */
  next_control=save_next_control; /* restore |next_control| to original state */
}@ Here is \.{CWEAVE}'s major output handler.

@&lt;Predeclaration of procedures@&gt;=
void make_output();

@ @c
void
make_output() /* outputs the equivalents of tokens */
{
  eight_bits a, /* current output byte */
  b; /* next output byte */
  int c; /* count of |indent| and |outdent| tokens */
  char scratch[longest_name]; /* scratch area for section names */
  char *k, *k_limit; /* indices into |scratch| */
  char *j; /* index into |buffer| */
  char *p; /* index into |byte_mem| */
  char delim; /* first and last character of string being copied */
  char *save_loc, *save_limit; /* |loc| and |limit| to be restored */
  name_pointer cur_section_name; /* name of section being output */
  boolean save_mode; /* value of |cur_mode| before a sequence of breaks */
  app(end_translation); /* append a sentinel */
  freeze_text; push_level(text_ptr-1);
  while (1) {
    a=get_output();
    reswitch: switch(a) {
      case end_translation: return;
      case identifier: case res_word: @&lt;Output an identifier@&gt;; break;
      case section_code: @&lt;Output a section name@&gt;; break;
      case math_rel: out_str("\\MRL{"@q}@&gt;);
@.\\MRL@&gt;
      case noop: case inserted: break;
      case cancel: case big_cancel: c=0; b=a;
        while (1) {
          a=get_output();
          if (a==inserted) continue;
          if ((a&lt;indent &amp;&amp; !(b==big_cancel&amp;&amp;a==' ')) || a&gt;big_force) break;
          if (a==indent) c++; else if (a==outdent) c--;
          else if (a==opt) a=get_output();
        }
        @&lt;Output saved |indent| or |outdent| tokens@&gt;;
        goto reswitch;
      case indent: case outdent: case opt: case backup: case break_space:
      case force: case big_force: case preproc_line:
	  	@&lt;Output a control,look ahead in case of line breaks, possibly |goto reswitch|@&gt;; break;
      case quoted_char: out(*(cur_tok++));
      case qualifier: break;
      default: out(a); /* otherwise |a| is an ordinary character */
    }
  }
}
@ @&lt;Output saved...@&gt;=
  for (;c&gt;0;c--) out_str("\\1");
@.\\1@&gt;
  for (;c&lt;0;c++) out_str("\\2");
@.\\2@&gt;
@ The current mode does not affect the behavior of \.{CWEAVE}'s output routine except when we are outputting control tokens.

@&lt;Output a control...@&gt;=
if (a&lt;break_space || a==preproc_line) {
  if (cur_mode==outer) {
    out('\\'); out(a-cancel+'0');
@.\\1@&gt;
@.\\2@&gt;
@.\\3@&gt;
@.\\4@&gt;
@.\\8@&gt;
    if (a==opt) {
      b=get_output(); /* |opt| is followed by a digit */
      if (b!='0' || force_lines==0) out(b)@;
      else out_str("{-1}"); /* |force_lines| encourages more \.{@@\v} breaks */
    }
  } else if (a==opt) b=get_output(); /* ignore digit following |opt| */
  }
else @&lt;Look ahead for strongest line break, |goto reswitch|@&gt;
@ If several of the tokens |break_space|, |force|, |big_force| occur in a row, possibly mixed with blank spaces (which are ignored), the largest one is used. A line break also occurs in the output file, except at the very end of the translation. The very first line break is suppressed (i.e., a line break that follows `\.{\\Y\\B}').

@&lt;Look ahead for strongest line break, |goto reswitch|@&gt;= {
  b=a; save_mode=cur_mode; c=0;
  while (1) {
    a=get_output();
    if (a==inserted) continue;
    if (a==cancel || a==big_cancel) {
      @&lt;Output saved |indent| or |outdent| tokens@&gt;;
      goto reswitch; /* |cancel| overrides everything */
    }
    if ((a!=' ' &amp;&amp; a&lt;indent) || a==backup || a&gt;big_force) {
      if (save_mode==outer) {
        if (out_ptr&gt;out_buf+3 &amp;&amp; strncmp(out_ptr-3,"\\Y\\B",4)==0)
          goto reswitch;
        @&lt;Output saved |indent| or |outdent| tokens@&gt;;
        out('\\'); out(b-cancel+'0');
@.\\5@&gt;
@.\\6@&gt;
@.\\7@&gt;
        if (a!=end_translation) finish_line();
      }
      else if (a!=end_translation &amp;&amp; cur_mode==inner) out(' ');
      goto reswitch;
    }
    if (a==indent) c++;
    else if (a==outdent) c--;
    else if (a==opt) a=get_output();
    else if (a&gt;b) b=a; /* if |a==' '| we have |a&lt;b| */
  }
}
@ An identifier of length one does not have to be enclosed in braces, and it looks slightly better if set in a math-italic font instead of a (slightly narrower) text-italic font. Thus we output `\.{\\\v}\.{a}' but `\.{\\\\\{aa\}}'.

@&lt;Output an identifier@&gt;=
out('\\');
if (a==identifier) {
  if (cur_name-&gt;ilk==custom &amp;&amp; !doing_format) {
 custom_out:
    for (p=cur_name-&gt;byte_start;p&lt;(cur_name+1)-&gt;byte_start;p++)
      out(*p=='_'? 'x': *p=='$'? 'X': *p);
    break;
  } else if (is_tiny(cur_name)) out('|')@;
@.\\|@&gt;
  else { delim='.';
    for (p=cur_name-&gt;byte_start;p&lt;(cur_name+1)-&gt;byte_start;p++)
      if (xislower(*p)) { /* not entirely uppercase */
         delim='\\'; break;
      }
  out(delim);
  }
@.\\\\@&gt;
@.\\.@&gt;
}@+else if (cur_name-&gt;ilk==alfop) {
  out('X');
  goto custom_out;
}@+else out('&amp;'); /* |a==res_word| */
@.\\\&amp;@&gt;
if (is_tiny(cur_name)) {
  if (isxalpha((cur_name-&gt;byte_start)[0]))
    out('\\');
  out((cur_name-&gt;byte_start)[0]);
}
else out_name(cur_name,1);
@ The remaining part of |make_output| is somewhat more complicated. When we output a section name, we may need to enter the parsing and translation routines, since the name may contain \CEE/ code embedded in \pb\ constructions. This \CEE/ code is placed at the end of the active input buffer and the translation process uses the end of the active |tok_mem| area.

@&lt;Output a section name@&gt;= {
  out_str("\\X");
@.\\X@&gt;
  cur_xref=(xref_pointer)cur_name-&gt;xref;
  if (cur_xref-&gt;num==file_flag) {an_output=1; cur_xref=cur_xref-&gt;xlink;}
  else an_output=0;
  if (cur_xref-&gt;num&gt;=def_flag) {
    out_section(cur_xref-&gt;num-def_flag);
    if (phase==3) {
      cur_xref=cur_xref-&gt;xlink;
      while (cur_xref-&gt;num&gt;=def_flag) {
        out_str(", ");
        out_section(cur_xref-&gt;num-def_flag);
      cur_xref=cur_xref-&gt;xlink;
      }
    }
  }
  else out('0'); /* output the section number, or zero if it was undefined */
  out(':');
  if (an_output) out_str("\\.{"@q}@&gt;);
@.\\.@&gt;
  @&lt;Output the text of the section name@&gt;;
  if (an_output) out_str(@q{@&gt;" }");
  out_str("\\X");
}
@ @&lt;Output the text...@&gt;=
sprint_section_name(scratch,cur_name);
k=scratch;
k_limit=scratch+strlen(scratch);
cur_section_name=cur_name;
while (k&lt;k_limit) {
  b=*(k++);
  if (b=='@@') @&lt;Skip next character, give error if not `\.{@@}'@&gt;;
  if (an_output)
    switch (b) {
 case  ' ':case '\\':case '#':case '%':case '$':case '^':
 case '{': case '}': case '~': case '&amp;': case '_':
    out('\\'); /* falls through */
@.\\\ @&gt;
@.\\\\@&gt;
@.\\\#@&gt;
@.\\\%@&gt;
@.\\\$@&gt;
@.\\\^@&gt;
@.\\\{@&gt;@q}@&gt;
@q{@&gt;@.\\\}@&gt;
@.\\\~@&gt;
@.\\\&amp;@&gt;
@.\\\_@&gt;
 default: out(b);
    }
  else if (b!='|') out(b)
  else {
    @&lt;Copy the \CEE/ text into the |buffer| array@&gt;;
    save_loc=loc; save_limit=limit; loc=limit+2; limit=j+1;
    *limit='|'; output_C();
    loc=save_loc; limit=save_limit;
  }
}
@ @&lt;Skip next char...@&gt;=
if (*k++!='@@') {
  printf("\n! Illegal control code in section name: &lt;");
@.Illegal control code...@&gt;
  print_section_name(cur_section_name); printf("&gt; "); mark_error;
}
@ The \CEE/ text enclosed in \pb\ should not contain `\.{\v}' characters, except within strings. We put a `\.{\v}' at the front of the buffer, so that an error message that displays the whole buffer will look a little bit sensible. The variable |delim| is zero outside of strings, otherwise it equals the delimiter that began the string being copied.

@&lt;Copy the \CEE/ text into the |buffer| array@&gt;=
j=limit+1; *j='|'; delim=0;
while (1) {
  if (k&gt;=k_limit) {
    printf("\n! C text in section name didn't end: &lt;");
@.C text...didn't end@&gt;
    print_section_name(cur_section_name); printf("&gt; "); mark_error; break;
  }
  b=*(k++);
  if (b=='@@' || (b=='\\' &amp;&amp; delim!=0))
     @&lt;Copy a quoted character into the buffer@&gt;
  else {
    if (b=='\'' || b=='"')
      if (delim==0) delim=b;
      else if (delim==b) delim=0;
    if (b!='|' || delim!=0) {
      if (j&gt;buffer+long_buf_size-3) overflow("buffer");
      *(++j)=b;
    }
    else break;
  }
}
@ @&lt;Copy a quoted char...@&gt;= {
  if (j&gt;buffer+long_buf_size-4) overflow("buffer");
  *(++j)=b; *(++j)=*(k++);
}
@** Phase two processing. We have assembled enough pieces of the puzzle in order to be ready to specify the processing in \.{CWEAVE}'s main pass over the source file. Phase two is analogous to phase one, except that more work is involved because we must actually output the \TEX/ material instead of merely looking at the \.{CWEB} specifications.
@&lt;Predeclaration of procedures@&gt;=
void phase_two();

@ @c
void
phase_two() {
reset_input(); if (show_progress) printf("\nWriting the output file...");
@.Writing the output file...@&gt;
section_count=0; format_visible=1; copy_limbo();
finish_line(); flush_buffer(out_buf,0,0); /* insert a blank line, it looks nice */
while (!input_has_ended) @&lt;Translate the current section@&gt;;
}
@ The output file will contain the control sequence \.{\\Y} between non-null sections of a section, e.g., between the \TEX/ and definition parts if both are nonempty. This puts a little white space between the parts when they are printed. However, we don't want \.{\\Y} to occur between two definitions within a single section. The variables |out_line| or |out_ptr| will change if a section is non-null, so the following macros `|save_position|' and `|emit_space_if_needed|' are able to handle the situation:

@d save_position save_line=out_line; save_place=out_ptr
@d emit_space_if_needed if (save_line!=out_line || save_place!=out_ptr)
  out_str("\\Y");
  space_checked=1
@.\\Y@&gt;

@&lt;Global variables@&gt;=
int save_line; /* former value of |out_line| */
char *save_place; /* former value of |out_ptr| */
int sec_depth; /* the integer, if any, following \.{@@*} */
boolean space_checked; /* have we done |emit_space_if_needed|? */
boolean format_visible; /* should the next format declaration be output? */
boolean doing_format=0; /* are we outputting a format declaration? */
boolean group_found=0; /* has a starred section occurred? */

@ @&lt;Translate the current section@&gt;= {
  section_count++;
  @&lt;Output the code for the beginning of a new section@&gt;;
  save_position;
  @&lt;Translate the \TEX/ part of the current section@&gt;;
  @&lt;Translate the definition part of the current section@&gt;;
  @&lt;Translate the \CEE/ part of the current section@&gt;;
  @&lt;Show cross-references to this section@&gt;;
  @&lt;Output the code for the end of a section@&gt;;
}
@ Sections beginning with the \.{CWEB} control sequence `\.{@@\ }' start in the output with the \TEX/ control sequence `\.{\\M}', followed by the section number. Similarly, `\.{@

@*}' sections lead to the control sequence `\.{\\N}'. In this case there's an additional parameter, representing one plus the specified depth, immediately after the \.{\\N}. If the section has changed, we put \.{\\*} just after the section number.

@&lt;Output the code for the beginning of a new section@&gt;=
if (*(loc-1)!='*') out_str("\\M");
@.\\M@&gt;
else {
  while (*loc == ' ') loc++;
  if (*loc=='*') { /* ``top'' level */
    sec_depth = -1;
    loc++;
  }
  else {
    for (sec_depth=0; xisdigit(*loc);loc++)
      sec_depth = sec_depth*10 + (*loc) -'0';
  }
  while (*loc == ' ') loc++; /* remove spaces before group title */
  group_found=1;
  out_str("\\N");
@.\\N@&gt;
  {@+ char s[32];@+sprintf(s,"{%d}",sec_depth+1);@+out_str(s);@+}
  if (show_progress)
  printf("*%d",section_count); update_terminal; /* print a progress report */
}
out_str("{");out_section(section_count); out_str("}");
@ In the \TEX/ part of a section, we simply copy the source text, except that index entries are not copied and \CEE/ text within \pb\ is translated.

@&lt;Translate the \TEX/ part of the current section@&gt;= do {
  next_control=copy_TeX();
  switch (next_control) {
    case '|': init_stack; output_C(); break;
    case '@@': out('@@'); break;
    case TeX_string: case noop:
    case xref_roman: case xref_wildcard: case xref_typewriter:
    case section_name: loc-=2; next_control=get_next(); /* skip to \.{@@&gt;} */
      if (next_control==TeX_string)
        err_print("! TeX string should be in C text only"); break;
@.TeX string should be...@&gt;
    case thin_space: case math_break: case ord:
    case line_break: case big_line_break: case no_line_break: case join:
    case pseudo_semi: case macro_arg_open: case macro_arg_close:
    case output_defs_code:
        err_print("! You can't do that in TeX text"); break;
@.You can't do that...@&gt;
  }
} while (next_control&lt;format_code);
@ When we get to the following code we have |next_control&gt;=format_code|, and the token memory is in its initial empty state.

@&lt;Translate the definition part of the current section@&gt;=
space_checked=0;
while (next_control&lt;=definition) { /* |format_code| or |definition| */
  init_stack;
  if (next_control==definition) @&lt;Start a macro definition@&gt;@;
  else @&lt;Start a format definition@&gt;;
  outer_parse(); finish_C(format_visible); format_visible=1;
  doing_format=0;
}
@ Keeping in line with the conventions of the \CEE/ preprocessor (and otherwise contrary to the rules of \.{CWEB}) we distinguish here between the case that `\.(' immediately follows an identifier and the case that the two are separated by a space.  In the latter case, and if the identifier is not followed by `\.(' at all, the replacement text starts immediately after the identifier.  In the former case, it starts after we scan the matching `\.)'.

@&lt;Start a macro definition@&gt;= {
  if (save_line!=out_line || save_place!=out_ptr || space_checked) app(backup);
  if(!space_checked){emit_space_if_needed;save_position;}
  app_str("\\D"); /* this will produce `\&amp;{define }' */
@.\\D@&gt;
  if ((next_control=get_next())!=identifier)
    err_print("! Improper macro definition");
@.Improper macro definition@&gt;
  else {
    app('$'); app_cur_id(0);
    if (*loc=='(')
  reswitch: switch (next_control=get_next()) {
      case '(': case ',': app(next_control); goto reswitch;
      case identifier: app_cur_id(0); goto reswitch;
      case ')': app(next_control); next_control=get_next(); break;
      default: err_print("! Improper macro definition"); break;
    }
    else next_control=get_next();
    app_str("$ "); app(break_space);
    app_scrap(dead,no_math); /* scrap won't take part in the parsing */
  }
}
@ @&lt;Start a format...@&gt;= {
  doing_format=1;
  if(*(loc-1)=='s' || *(loc-1)=='S') format_visible=0;
  if(!space_checked){emit_space_if_needed;save_position;}
  app_str("\\F"); /* this will produce `\&amp;{format }' */
@.\\F@&gt;
  next_control=get_next();
  if (next_control==identifier) {
    app(id_flag+(int)(id_lookup(id_first, id_loc,normal)-name_dir));
    app(' ');
    app(break_space); /* this is syntactically separate from what follows */
    next_control=get_next();
    if (next_control==identifier) {
      app(id_flag+(int)(id_lookup(id_first, id_loc,normal)-name_dir));
      app_scrap(exp,maybe_math); app_scrap(semi,maybe_math);
      next_control=get_next();
    }
  }
  if (scrap_ptr!=scrap_info+2) err_print("! Improper format definition");
@.Improper format definition@&gt;
}
@ Finally, when the \TEX/ and definition parts have been treated, we have |next_control&gt;=begin_C|. We will make the global variable |this_section| point to the current section name, if it has a name.

@&lt;Global variables@&gt;=
name_pointer this_section; /* the current section name, or zero */

@ @&lt;Translate the \CEE/...@&gt;=
this_section=name_dir;
if (next_control&lt;=section_name) {
  emit_space_if_needed; init_stack;
  if (next_control==begin_C) next_control=get_next();
  else {
    this_section=cur_section;
    @&lt;Check that '=' or '==' follows this section name, and emit the scraps to start the section definition@&gt;;
  }
  while  (next_control&lt;=section_name) {
    outer_parse();
    @&lt;Emit the scrap for a section name if present@&gt;;
  }
  finish_C(1);
}
@ The title of the section and an $\E$ or $\mathrel+\E$ are made into a scrap that should not take part in the parsing.

@&lt;Check that '='...@&gt;=
do next_control=get_next();
  while (next_control=='+'); /* allow optional `\.{+=}' */
if (next_control!='=' &amp;&amp; next_control!=eq_eq)
  err_print("! You need an = sign after the section name");
@.You need an = sign...@&gt;
  else next_control=get_next();
if (out_ptr&gt;out_buf+1 &amp;&amp; *out_ptr=='Y' &amp;&amp; *(out_ptr-1)=='\\') app(backup);
    /* the section name will be flush left */
@.\\Y@&gt;
app(section_flag+(int)(this_section-name_dir));
cur_xref=(xref_pointer)this_section-&gt;xref;
if(cur_xref-&gt;num==file_flag) cur_xref=cur_xref-&gt;xlink;
app_str("${}");
if (cur_xref-&gt;num!=section_count+def_flag) {
  app_str("\\mathrel+"); /*section name is multiply defined*/
  this_section=name_dir; /*so we won't give cross-reference info here*/
}
app_str("\\E"); /* output an equivalence sign */
@.\\E@&gt;
app_str("{}$");
app(force); app_scrap(dead,no_math);
        /* this forces a line break unless `\.{@@+}' follows */
@ @&lt;Emit the scrap...@&gt;=
if (next_control&lt;section_name) {
  err_print("! You can't do that in C text");
@.You can't do that...@&gt;
  next_control=get_next();
}
else if (next_control==section_name) {
  app(section_flag+(int)(cur_section-name_dir));
  app_scrap(section_scrap,maybe_math);
  next_control=get_next();
}
@ Cross references relating to a named section are given after the section ends.

@&lt;Show cross-references to this section@&gt;=
if (this_section&gt;name_dir) {
  cur_xref=(xref_pointer)this_section-&gt;xref;
  if (cur_xref-&gt;num==file_flag){an_output=1;cur_xref=cur_xref-&gt;xlink;}
  else an_output=0;
  if (cur_xref-&gt;num&gt;def_flag)
    cur_xref=cur_xref-&gt;xlink; /* bypass current section number */
  footnote(def_flag); footnote(cite_flag); footnote(0);
}
@ @&lt;Output the code for the end of a section@&gt;=
out_str("\\fi"); finish_line();
@.\\fi@&gt;
flush_buffer(out_buf,0,0); /* insert a blank line, it looks nice */
@ The |footnote| procedure gives cross-reference information about multiply defined section names (if the |flag| parameter is |def_flag|), or about references to a section name (if |flag==cite_flag|), or to its uses (if |flag==0|). It assumes that |cur_xref| points to the first cross-reference entry of interest, and it leaves |cur_xref| pointing to the first element not printed.  Typical outputs: `\.{\\A101.}'; `\.{\\Us 370\\ET1009.}'; `\.{\\As 8, 27\\*\\ETs64.}'.  Note that the output of \.{CWEAVE} is not English-specific; users may supply new definitions for the macros \.{\\A}, \.{\\As}, etc.

@&lt;Predeclaration of procedures@&gt;=
void footnote();

@ @c
void
footnote(flag) /* outputs section cross-references */
sixteen_bits flag;
{
  xref_pointer q; /* cross-reference pointer variable */
  if (cur_xref-&gt;num&lt;=flag) return;
  finish_line(); out('\\');
@.\\A@&gt;
@.\\Q@&gt;
@.\\U@&gt;
  out(flag==0? 'U': flag==cite_flag? 'Q': 'A');
  @&lt;Output all the section numbers on the reference list |cur_xref|@&gt;;
  out('.');
}
@ The following code distinguishes three cases, according as the number of cross-references is one, two, or more than two. Variable |q| points to the first cross-reference, and the last link is a zero.

@&lt;Output all the section numbers on the reference list |cur_xref|@&gt;=
q=cur_xref; if (q-&gt;xlink-&gt;num&gt;flag) out('s'); /* plural */
while (1) {
  out_section(cur_xref-&gt;num-flag);
  cur_xref=cur_xref-&gt;xlink; /* point to the next cross-reference to output */
  if (cur_xref-&gt;num&lt;=flag) break;
  if (cur_xref-&gt;xlink-&gt;num&gt;flag) out_str(", "); /* not the last */
  else {out_str("\\ET"); /* the last */
@.\\ET@&gt;
  if (cur_xref != q-&gt;xlink) out('s'); /* the last of more than two */
  }
}
@ The |finish_C| procedure outputs the translation of the current scraps, preceded by the control sequence `\.{\\B}' and followed by the control sequence `\.{\\par}'. It also restores the token and scrap memories to their initial empty state.  A |force| token is appended to the current scraps before translation takes place, so that the translation will normally end with \.{\\6} or \.{\\7} (the \TEX/ macros for |force| and |big_force|). This \.{\\6} or \.{\\7} is replaced by the concluding \.{\\par} or by \.{\\Y\\par}.

@&lt;Predeclaration of procedures@&gt;=
void finish_C();

@ @c
void
finish_C(visible) /* finishes a definition or a \CEE/ part */
  boolean visible; /* nonzero if we should produce \TEX/ output */
{
  text_pointer p; /* translation of the scraps */
  if (visible) {
    out_str("\\B"); app_tok(force); app_scrap(insert,no_math);
    p=translate();
@.\\B@&gt;
    app(tok_flag+(int)(p-tok_start)); make_output(); /* output the list */
    if (out_ptr&gt;out_buf+1)
      if (*(out_ptr-1)=='\\')
@.\\6@&gt;
@.\\7@&gt;
@.\\Y@&gt;
        if (*out_ptr=='6') out_ptr-=2;
        else if (*out_ptr=='7') *out_ptr='Y';
    out_str("\\par"); finish_line();
  }
  if (text_ptr&gt;max_text_ptr) max_text_ptr=text_ptr;
  if (tok_ptr&gt;max_tok_ptr) max_tok_ptr=tok_ptr;
  if (scrap_ptr&gt;max_scr_ptr) max_scr_ptr=scrap_ptr;
  tok_ptr=tok_mem+1; text_ptr=tok_start+1; scrap_ptr=scrap_info;
    /* forget the tokens and the scraps */
}
@** Phase three processing. We are nearly finished! \.{CWEAVE}'s only remaining task is to write out the index, after sorting the identifiers and index entries.  If the user has set the |no_xref| flag (the \.{-x} option on the command line), just finish off the page, omitting the index, section name list, and table of contents.

@&lt;Predeclaration of procedures@&gt;=
void phase_three();@ @c
void
phase_three() {
if (no_xref) {
  finish_line();
  out_str("\\end");
@.\\end@&gt;
  finish_line();
}
else {
  phase=3; if (show_progress) printf("\nWriting the index...");
@.Writing the index...@&gt;
  finish_line();
  if ((idx_file=fopen(idx_file_name,"w"))==NULL)
    fatal("! Cannot open index file ",idx_file_name);
@.Cannot open index file@&gt;
  if (change_exists) {
    @&lt;Tell about changed sections@&gt;; finish_line(); finish_line();
  }
  out_str("\\inx"); finish_line();
@.\\inx@&gt;
  active_file=idx_file; /* change active file to the index file */
  @&lt;Do the first pass of sorting@&gt;;
  @&lt;Sort and output the index@&gt;;
  finish_line(); fclose(active_file); /* finished with |idx_file| */
  active_file=tex_file; /* switch back to |tex_file| for a tic */
  out_str("\\fin"); finish_line();
@.\\fin@&gt;
  if ((scn_file=fopen(scn_file_name,"w"))==NULL)
    fatal("! Cannot open section file ",scn_file_name);
@.Cannot open section file@&gt;
  active_file=scn_file; /* change active file to section listing file */
  @&lt;Output all the section names@&gt;;
  finish_line(); fclose(active_file); /* finished with |scn_file| */
  active_file=tex_file;
  if (group_found) out_str("\\con");@+else out_str("\\end");
@.\\con@&gt;
@.\\end@&gt;
  finish_line();
  fclose(active_file);
}
if (show_happiness) printf("\nDone.");
check_complete(); /* was all of the change file used? */
}
@ Just before the index comes a list of all the changed sections, including the index section itself.

@&lt;Global variables@&gt;=
sixteen_bits k_section; /* runs through the sections */

@ @&lt;Tell about changed sections@&gt;= {
  /* remember that the index is already marked as changed */
  k_section=0;
  while (!changed_section[++k_section]);
  out_str("\\ch ");
@.\\ch@&gt;
  out_section(k_section);
  while (k_section&lt;section_count) {
    while (!changed_section[++k_section]);
    out_str(", "); out_section(k_section);
  }
  out('.');
}
@ A left-to-right radix sorting method is used, since this makes it easy to adjust the collating sequence and since the running time will be at worst proportional to the total length of all entries in the index. We put the identifiers into 102 different lists based on their first characters. (Uppercase letters are put into the same list as the corresponding lowercase letters, since we want to have `$t&lt;\\{TeX}&lt;\&amp;{to}$'.) The list for character |c| begins at location |bucket[c]| and continues through the |blink| array.

@&lt;Global variables@&gt;=
name_pointer bucket[256];
name_pointer next_name; /* successor of |cur_name| when sorting */
name_pointer blink[max_names]; /* links in the buckets */

@ To begin the sorting, we go through all the hash lists and put each entry having a nonempty cross-reference list into the proper bucket.

@&lt;Do the first pass of sorting@&gt;= {
int c;
for (c=0; c&lt;=255; c++) bucket[c]=NULL;
for (h=hash; h&lt;=hash_end; h++) {
  next_name=*h;
  while (next_name) {
    cur_name=next_name; next_name=cur_name-&gt;link;
    if (cur_name-&gt;xref!=(char*)xmem) {
      c=(eight_bits)((cur_name-&gt;byte_start)[0]);
      if (xisupper(c)) c=tolower(c);
      blink[cur_name-name_dir]=bucket[c]; bucket[c]=cur_name;
    }
  }
}
}
@ During the sorting phase we shall use the |cat| and |trans| arrays from
\.{CWEAVE}'s parsing algorithm and rename them |depth| and |head|. They now
represent a stack of identifier lists for all the index entries that have
not yet been output. The variable |sort_ptr| tells how many such lists are
present; the lists are output in reverse order (first |sort_ptr|, then
|sort_ptr-1|, etc.). The |j|th list starts at |head[j]|, and if the first
|k| characters of all entries on this list are known to be equal we have
|depth[j]==k|.

@ @&lt;Rest of |trans_plus| union@&gt;=
name_pointer Head;

@ @d depth cat /* reclaims memory that is no longer needed for parsing */
@d head trans_plus.Head /* ditto */
@f sort_pointer int
@d sort_pointer scrap_pointer /* ditto */
@d sort_ptr scrap_ptr /* ditto */
@d max_sorts max_scraps /* ditto */

@&lt;Global variables@&gt;=
eight_bits cur_depth; /* depth of current buckets */
char *cur_byte; /* index into |byte_mem| */
sixteen_bits cur_val; /* current cross-reference number */
sort_pointer max_sort_ptr; /* largest value of |sort_ptr| */

@ @&lt;Set init...@&gt;=
max_sort_ptr=scrap_info;

@ The desired alphabetic order is specified by the |collate| array; namely, $|collate|[0]&lt;|collate|[1]&lt;\cdots&lt;|collate|[100]$.

@&lt;Global variables@&gt;=
eight_bits collate[102+128]; /* collation order */
@^high-bit character handling@&gt;

@ We use the order $\hbox{null}&lt;\.\ &lt;\hbox{other characters}&lt;{}$\.\_${}&lt; \.A=\.a&lt;\cdots&lt;\.Z=\.z&lt;\.0&lt;\cdots&lt;\.9.$ Warning: The collation mapping needs to be changed if ASCII code is not being used. @^ASCII code dependencies@&gt; @^high-bit character handling@&gt;  We initialize |collate| by copying a few characters at a time, because some \CEE/ compilers choke on long strings.

@&lt;Set initial values@&gt;=
collate[0]=0;
strcpy(collate+1," \1\2\3\4\5\6\7\10\11\12\13\14\15\16\17");
/* 16 characters + 1 = 17 */
strcpy(collate+17,"\20\21\22\23\24\25\26\27\30\31\32\33\34\35\36\37");
/* 16 characters + 17 = 33 */
strcpy(collate+33,"!\42#$%&amp;'()*+,-./:;&lt;=&gt;?@@[\\]^`{|}~_");
/* 32 characters + 33 = 65 */
strcpy(collate+65,"abcdefghijklmnopqrstuvwxyz0123456789");
/* (26 + 10) characters + 65 = 101 */
strcpy(collate+101,"\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217");
/* 16 characters + 101 = 117 */
strcpy(collate+117,"\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237");
/* 16 characters + 117 = 133 */
strcpy(collate+133,"\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257");
/* 16 characters + 133 = 149 */
strcpy(collate+149,"\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277");
/* 16 characters + 149 = 165 */
strcpy(collate+165,"\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317");
/* 16 characters + 165 = 181 */
strcpy(collate+181,"\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337");
/* 16 characters + 181 = 197 */
strcpy(collate+197,"\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357");
/* 16 characters + 197 = 213 */
strcpy(collate+213,"\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377");
/* 16 characters + 213 = 229 */

@ @&lt;Sort and output...@&gt;=
sort_ptr=scrap_info; unbucket(1);
while (sort_ptr&gt;scrap_info) {
  cur_depth=sort_ptr-&gt;depth;
  if (blink[sort_ptr-&gt;head-name_dir]==0 || cur_depth==infinity)
    @&lt;Output index entries for the list at |sort_ptr|@&gt;@;
  else @&lt;Split the list at |sort_ptr| into further lists@&gt;;
}
@ @&lt;Split the list...@&gt;= {
  eight_bits c;
  next_name=sort_ptr-&gt;head;
  do {
    cur_name=next_name; next_name=blink[cur_name-name_dir];
    cur_byte=cur_name-&gt;byte_start+cur_depth;
    if (cur_byte==(cur_name+1)-&gt;byte_start) c=0; /* hit end of the name */
    else {
      c=(eight_bits) *cur_byte;
      if (xisupper(c)) c=tolower(c);
    }
  blink[cur_name-name_dir]=bucket[c]; bucket[c]=cur_name;
  } while (next_name);
  --sort_ptr; unbucket(cur_depth+1);
}
@ @&lt;Output index...@&gt;= {
  cur_name=sort_ptr-&gt;head;
  do {
    out_str("\\I");
@.\\I@&gt;
    @&lt;Output the name at |cur_name|@&gt;;
    @&lt;Output the cross-references at |cur_name|@&gt;;
    cur_name=blink[cur_name-name_dir];
  } while (cur_name);
  --sort_ptr;
}
@ @&lt;Output the name...@&gt;=
switch (cur_name-&gt;ilk) {
  case normal: case func_template: if (is_tiny(cur_name)) out_str("\\|");
    else {char *j;
      for (j=cur_name-&gt;byte_start;j&lt;(cur_name+1)-&gt;byte_start;j++)
        if (xislower(*j)) goto lowcase;
      out_str("\\."); break;
lowcase: out_str("\\\\");
    }
  break;
@.\\|@&gt;
@.\\.@&gt;
@.\\\\@&gt;
  case wildcard: out_str("\\9");@+ goto not_an_identifier;
@.\\9@&gt;
  case typewriter: out_str("\\.");
@.\\.@&gt;
  case roman: not_an_identifier: out_name(cur_name,0); goto name_done;
  case custom: {char *j; out_str("$\\");
    for (j=cur_name-&gt;byte_start;j&lt;(cur_name+1)-&gt;byte_start;j++)
      out(*j=='_'? 'x': *j=='$'? 'X': *j);
    out('$');
    goto name_done;
    }
  default: out_str("\\&amp;");
@.\\\&amp;@&gt;
}
out_name(cur_name,1);
name_done:@;
@ Section numbers that are to be underlined are enclosed in `\.{\\[}$\,\ldots\,$\.]'.

@&lt;Output the cross-references at |cur_name|@&gt;=
@&lt;Invert the cross-reference list at |cur_name|, making |cur_xref| the head@&gt;;
do {
  out_str(", "); cur_val=cur_xref-&gt;num;
  if (cur_val&lt;def_flag) out_section(cur_val);
  else {out_str("\\["); out_section(cur_val-def_flag); out(']');}
@.\\[@&gt;
  cur_xref=cur_xref-&gt;xlink;
} while (cur_xref!=xmem);
out('.'); finish_line();
@ List inversion is best thought of as popping elements off one stack and pushing them onto another. In this case |cur_xref| will be the head of the stack that we push things onto.

@&lt;Global variables@&gt;=
xref_pointer next_xref, this_xref;
  /* pointer variables for rearranging a list */

@ @&lt;Invert the cross-reference list at |cur_name|, making |cur_xref| the head@&gt;=
this_xref=(xref_pointer)cur_name-&gt;xref; cur_xref=xmem;
do {
  next_xref=this_xref-&gt;xlink; this_xref-&gt;xlink=cur_xref;
  cur_xref=this_xref; this_xref=next_xref;
} while (this_xref!=xmem);
@ @&lt;Output all the section names@&gt;=section_print(root)
@ Procedure |unbucket| goes through the buckets and adds nonempty lists to the stack, using the collating sequence specified in the |collate| array. The parameter to |unbucket| tells the current depth in the buckets. Any two sequences that agree in their first 255 character positions are regarded as identical.

@d infinity 255 /* $\infty$ (approximately) */

@&lt;Predeclaration of procedures@&gt;=
void  unbucket();

@ @c
void
unbucket(d) /* empties buckets having depth |d| */
eight_bits d;
{
  int c;  /* index into |bucket|; cannot be a simple |char| because of sign
    comparison below*/
  for (c=100+128; c&gt;= 0; c--) if (bucket[collate[c]]) {
@^high-bit character handling@&gt;
    if (sort_ptr&gt;=scrap_info_end) overflow("sorting");
    sort_ptr++;
    if (sort_ptr&gt;max_sort_ptr) max_sort_ptr=sort_ptr;
    if (c==0) sort_ptr-&gt;depth=infinity;
    else sort_ptr-&gt;depth=d;
    sort_ptr-&gt;head=bucket[collate[c]]; bucket[collate[c]]=NULL;
  }
}
@ The following recursive procedure walks through the tree of section names and prints them. @^recursion@&gt;

@&lt;Predeclaration of procedures@&gt;=
void section_print();

@ @c
void
section_print(p) /* print all section names in subtree |p| */
name_pointer p;
{
  if (p) {
    section_print(p-&gt;llink); out_str("\\I");
@.\\I@&gt;
    tok_ptr=tok_mem+1; text_ptr=tok_start+1; scrap_ptr=scrap_info; init_stack;
    app(p-name_dir+section_flag); make_output();
    footnote(cite_flag);
    footnote(0); /* |cur_xref| was set by |make_output| */
    finish_line();@/
    section_print(p-&gt;rlink);
  }
}
@ Because on some systems the difference between two pointers is a |long| rather than an |int|, we use \.{\%ld} to print these quantities.

@c
void
print_stats() {
  printf("\nMemory usage statistics:\n");
@.Memory usage statistics:@&gt;
  printf("%ld names (out of %ld)\n",
            (long)(name_ptr-name_dir),(long)max_names);
  printf("%ld cross-references (out of %ld)\n",
            (long)(xref_ptr-xmem),(long)max_refs);
  printf("%ld bytes (out of %ld)\n",
            (long)(byte_ptr-byte_mem),(long)max_bytes);
  printf("Parsing:\n");
  printf("%ld scraps (out of %ld)\n",
            (long)(max_scr_ptr-scrap_info),(long)max_scraps);
  printf("%ld texts (out of %ld)\n",
            (long)(max_text_ptr-tok_start),(long)max_texts);
  printf("%ld tokens (out of %ld)\n",
            (long)(max_tok_ptr-tok_mem),(long)max_toks);
  printf("%ld levels (out of %ld)\n",
            (long)(max_stack_ptr-stack),(long)stack_size);
  printf("Sorting:\n");
  printf("%ld levels (out of %ld)\n",
            (long)(max_sort_ptr-scrap_info),(long)max_scraps);
}@** Index.
If you have read and understood the code for Phase III above, you know what
is in this index and how it got here. All sections in which an identifier is
used are listed with that identifier, except that reserved words are
indexed only when they appear in format definitions, and the appearances
of identifiers in section names are not indexed. Underlined entries
correspond to where the identifier was declared. Error messages, control
sequences put into the output, and a few
other things like ``recursion'' are indexed here too.
</t>
<t tx="ekr.20190113114613.339">@language c
@tabwidth -4
@others
</t>
<t tx="ekr.20190113114613.34">line 1
line 2
line 3
</t>
<t tx="ekr.20190113114613.340">def child():
    pass
</t>
<t tx="ekr.20190113114613.341">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20190113114613.342">def child():
    pass
</t>
<t tx="ekr.20190113114613.343">\begin{document}
&lt;&lt; Document &gt;&gt;
% hidden comment
\end{document}
</t>
<t tx="ekr.20190113114613.344">@ Write master document here...........
</t>
<t tx="ekr.20190113114613.345">@first # -*- coding: utf-16 -*-
@encoding utf-16

Test of utf-16.
</t>
<t tx="ekr.20190113114613.346">@language python
@tabwidth -4
# before @others: line 1
@others
# last line: line 6</t>
<t tx="ekr.20190113114613.347">def spam(): # line 2
    pass
</t>
<t tx="ekr.20190113114613.348">def eggs(): # line 4
    pass</t>
<t tx="ekr.20190113114613.349">@first
@language python
@others
</t>
<t tx="ekr.20190113114613.35">inserted line
line 1
line 2
line 3
</t>
<t tx="ekr.20190113114613.350">def spam():
    pass # Unicode test:  after.
</t>
<t tx="ekr.20190113114613.351">def eggs():
    pass
</t>
<t tx="ekr.20190113114613.352">@language html

&lt;&lt; a section reference &gt;&gt;

after.
</t>
<t tx="ekr.20190113114613.353">&lt;p&gt; a paragraph. &lt;/p&gt;
</t>
<t tx="ekr.20190113114613.354">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20190113114613.355">def child():
    pass
</t>
<t tx="ekr.20190113114613.356">@language python
@others
</t>
<t tx="ekr.20190113114613.357">def spam():
    pass
</t>
<t tx="ekr.20190113114613.358">def eggs():
    pass
</t>
<t tx="ekr.20190113114613.359"># A file to be executed in batch mode as part of unit testing.
# This file is defined in unitTest.leo

@language python
@tabwidth -4

trace = False
import leo.core.leoGlobals as g
path = g.os_path_join(g.app.loadDir,"..","test","unittest","createdFile.txt")
if trace:
    print("batchTest.py: creating: %s" % path)
try:
    with open(path,"w") as f:
        f.write("This file was written by unittest/batchTest.py")
except IOError:
    print("batchTest.py: Can not create: %s" % path)
except Exception:
    print("batchTest.py: unexpected exception creating: %s" % path)
    g.es_exception()
assert g.os_path_exists(path), 'batchTest.py failed'
</t>
<t tx="ekr.20190113114613.36"></t>
<t tx="ekr.20190113114613.360"># A file that contains functions with errors in them.
# This is used to test error reporting in scripts

@language python
@tabwidth -4

def testIndexError():

    a = []
    b = a[2]

# The next line is used by @test c.checkFileTimeStamp.   
# timestamp: 1231502468.77
</t>
<t tx="ekr.20190113114613.361">@nosearch</t>
<t tx="ekr.20190113114613.362">import glob
import os
if 0: # Preamble...
    g.cls()
    if c.isChanged(): c.save()
    # import leo
    import leo.core.leoImport as leoImport
    # import leo.plugins.importers.basescanner as basescanner
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.python
    # Reload all.
    import imp
    # imp.reload(leo.plugins.importers.basescanner)
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.python)
    imp.reload(leoImport)
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

try:
    base_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'core')
    assert g.os_path_exists(base_dir), base_dir
    files = glob.glob('%s%s%s' % (base_dir, os.sep, '*.py'))
    files = [z for z in files if g.shortFileName(z).startswith('leo')]
    # leoTangle contains section refs in @c sections.
    files = [z for z in files
        if not g.shortFileName(z).endswith('leoTangle.py')]
    if 0: # Do only files in the table.
        table = (
            'leoColorizer.py',
            'leoFileCommands.py',
            'leoNodes.py',
        )
        result = []
        for fn in files:
            for z in table:
                if g.shortFileName(fn).endswith(z):
                    result.append(fn)
        files = result
    test_node = p.copy()
    fails = []
    test_node.deleteAllChildren()
    for fn in files:
        sfn = g.shortFileName(fn)
        s = g.readFileIntoUnicodeString(fn)
        s2 = ic.removeSentinelLines(s, '#', None, None)
        try:
            print(sfn)
            ic.pythonUnitTest(p,s=s2,showTree=True)
            test_node.lastChild().h = '@@file %s' % sfn
        except AssertionError:
            print('FAIL: %6s %6s %s' % (len(s), len(s2), sfn))
            fails.append(sfn)
            # break
    if fails:
        print('%s failures' % (len(fails)))
        g.printList(sorted(fails))
    elif 1:
        test_node.deleteAllChildren()
finally:
    c.redraw()
</t>
<t tx="ekr.20190113114613.363"># Don't even think about deleting these tests.
# They are extremely important when developing or changing a gui.
</t>
<t tx="ekr.20190113114613.364">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
child = p.firstChild()
assert child
assert child.h == 'child',child.h
c.selectPosition(child)
table = (
    'import-file',
    'open-outline',
    'read-at-auto-nodes',
    'read-at-file-nodes',
    'read-at-shadow-nodes',
   # 'read-file-into-node',
   # 'read-outline-only',
   'save-file',
   'save-file-as',
   'save-file-to',
    'write-at-auto-nodes',
    'write-at-file-nodes',
    'write-at-shadow-nodes',
    'write-dirty-at-auto-nodes',
    'write-dirty-at-file-nodes',
    'write-dirty-at-shadow-nodes',
    #'write-file-from-node',
    'write-missing-at-file-nodes',
    #'write-outline-only',
)
tags = (
    ('init_error_dialogs',2),
    ('raise_error_dialogs',1),
)
d = g.app.unitTestDict
for commandName in table:
    for tag,n in tags:
        d[tag] = 0
    c.k.simulateCommand(commandName)
    for tag,n in tags:
        assert d.get(tag) == n,'commandName: %s,tag: %s, n: %s' % (commandName,tag,d.get(tag))
</t>
<t tx="ekr.20190113114613.365"></t>
<t tx="ekr.20190113114613.366">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Qt Required')
from leo.core.leoQt import QtGui,QtWidgets
log = c.frame.log
name = log.__class__.__name__
assert name == 'LeoQtLog',name
assert log.logCtrl.__class__.__name__ == 'QTextEditWrapper',log.logCtrl
assert not issubclass(log.logCtrl.__class__,QtWidgets.QWidget.__class__)
    # leoQTextEditWidget us a poor name: it is not a Qt widget.
assert log.logCtrl.widget.__class__.__name__ == 'LeoQTextBrowser'
assert hasattr(log.logCtrl,'widget') and log.logCtrl.widget
assert hasattr(log.logCtrl.widget,'leo_log_wrapper')
wrapper = log.logCtrl.widget.leo_log_wrapper
assert wrapper == log.logCtrl
</t>
<t tx="ekr.20190113114613.367">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
log = c.frame.log
d = log.contentsDict
keys = list(d.keys())
tabs = log.orderedTabNames()
n = len(keys)
n2 = log.numberOfVisibleTabs()
n3 = len(tabs)
assert n == n2,'n: %s n2: %s' % (n,n2)
# The spell tab may not be in d.keys.
assert n &lt;= n3,'n: %s len(log.orederedTabNames() %s): %s' % (n,n3,tabs)
</t>
<t tx="ekr.20190113114613.368">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
log = c.frame.log
log.put(p.h)
log.putnl()
</t>
<t tx="ekr.20190113114613.369">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
d = g.app.unitTestDict
tag = 'minimize-all'
assert not d.get(tag)
c.frame.minimizeAll()
assert d.get(tag) is True
</t>
<t tx="ekr.20190113114613.37">line 1
line 2
line 3
</t>
<t tx="ekr.20190113114613.370"># target.

if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
try:
    w = c.frame.body.wrapper
    s = w.getAllText()
    w.setInsertPoint(len(s))
    c.k.previousSelection = 2,8
    event = g.app.gui.create_key_event(c,w=w)
    c.frame.pasteText(event=event,middleButton=True)
    s2 = w.getAllText()
    assert len(s2) == len(s) + len('target')
finally:
    w.setAllText(s)
    p.setBodyString(s)
    # g.trace(repr(s))
    c.recolor()

# end
</t>
<t tx="ekr.20190113114613.371"># target

if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

try:
    w = c.frame.body.wrapper
    s2 = p.b
    s = w.getAllText()
    assert s == s2, 'w.getAllText() != p.b: len(w)=%d, len(p)=%d' % (len(s),len(s2))
    w.setInsertPoint(len(s))
    c.k.previousSelection = 2,8
    event = g.app.gui.create_key_event(c,w=w)
    c.frame.pasteText(event=event,middleButton=True)
    s2 = w.getAllText()
    assert len(s2) == len(s) + len('target')
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor()

# end5target
</t>
<t tx="ekr.20190113114613.372"># The actual code contains the unit test.
# This test will have effect only when run locally.

if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

d = g.app.unitTestDict
tag = 'resize-to-screen'
assert not d.get(tag)
c.frame.resizeToScreen()
assert d.get(tag) is True
</t>
<t tx="ekr.20190113114613.373">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')
from leo.core.leoQt import QtCore,QtGui,QtWidgets

import leo.plugins.qt_events as qt_events

def setup(p):
    delete_children(p)
    p2 = p.insertAsLastChild()
    c.selectPosition(p2)
    p2.h = 'first-child'

def delete_children(p):
    while p.hasChildren():
        p.firstChild().doDelete()

app = g.app.gui.qtApp
assert issubclass(app.__class__,QtWidgets.QApplication)
wrapper = c.frame.body.wrapper
w = wrapper.widget
assert g.isTextWrapper(wrapper),wrapper
assert g.isTextWidget(w),w
# w_name = w.__class__.__name__
# bassert w_name in('QsciScintilla','LeoQTextBrowser'),w_name
p1 = p.copy()
filter_obj = qt_events.LeoQtEventFilter(c,w=w)
g.app.unitTestDict[p.h] = filter_obj # preserve a pointer to the filter.
try:
    ev = QtCore.QEvent
    table = (
        ev.KeyPress,
        # ev.KeyRelease, # Ignored except in QLineEdit's.
        # ev.ShortcutOverride, # Ignored everywhere.
    )
    for theType in table:
        # Create the event.
        setup(p1)
        e = QtGui.QKeyEvent(theType,ord('i'),QtCore.Qt.ControlModifier)
        # Pass it to eventFilter.
        filter_obj.eventFilter(w,e)
        # Check the results.
        c.redraw()
        n = p1.numberOfChildren()
        assert n==2,'%s children' % (n)
        delete_children(p1)
finally:
    delete_children(p1)
    c.redraw()
</t>
<t tx="ekr.20190113114613.374">'''Test that cycle-all-focus cycles through all tabs.'''
if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
log = c.frame.log
c.bodyWantsFocusNow()
w_name = g.app.gui.widget_name
w = c.frame.body
seen = []
while w:
    event = g.bunch(widget=w)
    c.editCommands.cycleAllFocus(event=event)
    w = g.app.gui.get_focus()
    if w in seen: break
    seen.append(w)
assert len(seen) &gt;2, "expected &gt;2, got %s" % len(seen)
</t>
<t tx="ekr.20190113114613.375">'''Test that cycle-all-focus cycles through all tabs.'''
if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
log = c.frame.log
tabs = log.orderedTabNames()[1:]
tabs.append('Log')
# Set up the initial state.
c.k.keyboardQuit()
c.bodyWantsFocusNow()
for tab in tabs:
    log.cycleTabFocus(event=None)
    assert log.tabName == tab,'expected %s, got %s' % (tab,log.tabName)
</t>
<t tx="ekr.20190113114613.376">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')
exec(g.findTestScript(c,'@common leoEditCommands test code'))
runEditCommandTest(c,p,inHeadline=False)
runEditCommandTest(c,p,inHeadline=True)
</t>
<t tx="ekr.20190113114613.377">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20190113114613.378">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20190113114613.379">aaaa bbbb dddd
</t>
<t tx="ekr.20190113114613.38">line 1
inserted line
line 2
line 3
</t>
<t tx="ekr.20190113114613.380">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')
import sys
exec(g.findTestScript(c,'@common leoEditCommands test code'))
runEditCommandTest(c,p,inHeadline=False)
runEditCommandTest(c,p,inHeadline=True)
</t>
<t tx="ekr.20190113114613.381">aaaa bbcc dddd
</t>
<t tx="ekr.20190113114613.382">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20190113114613.383">aaaa bbcc dddd
</t>
<t tx="ekr.20190113114613.384">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.setBodyString(p,'a')
c.redraw_now() # To make node visible and to set the icon.
try:
    c.bodyWantsFocus()
    n = c.frame.tree.redrawCount
    w = c.frame.body.wrapper
    w.setInsertPoint('end')
    g.app.gui.event_generate(c,'\b','BackSpace',w)
    n2 = c.frame.tree.redrawCount
    if not g.app.isExternalUnitTest:
        # This test is meaningless with a nullGui.
        assert n2 == n + 1,'too many or too few redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw_now()
</t>
<t tx="ekr.20190113114613.385">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = '@test editLabel selects entire headline'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
assert w
s = w.getAllText()
selectAll = c.config.getBool('select_all_text_when_editing_headlines')
i,j = w.getSelectionRange()
if selectAll:
    assert i == 0 and j == len(s),('oops1',i,j,len(s))
else:
    assert i == len(s) and j == len(s),('oops2',i,j,len(s))
</t>
<t tx="ekr.20190113114613.386">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
import leo.core.leoFrame as leoFrame
assert not isinstance(c.frame,leoFrame.NullFrame)
def closeEnough(f1,f2):
    return abs(f1-f2) &lt; 0.01
f = c.frame
ratio,ratio2 = f.ratio,f.secondary_ratio
table = (
    c.bodyWantsFocusNow,
    c.logWantsFocusNow,
    c.treeWantsFocusNow,
)
for func in table:
    name = func.__name__
    func()
    f.contractPane()
    if func == c.logWantsFocusNow:
        assert ratio2 != f.secondary_ratio,'fail 1'
    else:
        assert ratio != f.ratio,'fail 2: %s, %s: %s' % (ratio,f.ratio,name)
    func()
    f.expandPane()
    assert closeEnough(ratio,f.ratio),'fail 3 %s != %s: %s' % (
        ratio,f.ratio,name)
    assert closeEnough(ratio2,f.secondary_ratio),'fail 4 %s != %s: %s' % (
        ratio2,f.secondary_ratio,name)
</t>
<t tx="ekr.20190113114613.387">'''Make sure that g.trace doesn't add an extra newline.'''
if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

import sys

def test():
    g.es_print('a')
    g.es_print('b')

try:
    sys.stdout = g.fileLikeObject()
    test()
    result = sys.stdout.get()
    assert result == 'a\nb\n',repr(result)
finally:
    sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20190113114613.388">@first # -*- coding: utf-8 -*-
if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

import sys
s = 'test '

def test():
    g.es_trace(s,color='red')

try:
    # Don't worry about the exact output.
    # Just test that it doesn't throw an exception.
    sys.stdout = g.fileLikeObject()
    test()
finally:
    sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20190113114613.389">'''Make sure that g.trace doesn't add an extra newline.'''
if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

import sys

def test():
    g.pr('a')
    g.pr('b')

try:
    sys.stdout = g.fileLikeObject()
    test()
    result = sys.stdout.get()
    assert result == 'a\nb\n',repr(result)
finally:
    sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20190113114613.39"></t>
<t tx="ekr.20190113114613.390">if g.isPython3:
    self.skipTest('Requires Python 2')
if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

import leo.core.leoQt as leoQt
QString = leoQt.QString
s = g.toUnicode(QString('abc'))
assert s == 'abc',repr(s)
</t>
<t tx="ekr.20190113114613.391">'''Make sure that g.trace doesn't add an extra newline.'''
if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

import sys

def test():
    g.trace('a')
    g.trace('b')

try:
    sys.stdout = g.fileLikeObject()
    test()
    result = sys.stdout.get()
    assert result == 'test a\ntest b\n',repr(result)
finally:
    sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20190113114613.392">'''Test that dragging this node onto the child node generates a warning.'''
if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

fn = '&lt;file name&gt;'
p2 = p.firstChild()
tree = c.frame.tree
if hasattr(tree,'treeWidget'):
    w = tree.treeWidget
    for w.was_control_drag in (True,False):
        tree.treeWidget.intraFileDrop(fn,p,p2)
        assert True==g.app.unitTestDict['checkMoveWithParentWithWarning']
</t>
<t tx="ekr.20190113114613.393"></t>
<t tx="ekr.20190113114613.394">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
import leo.core.leoFrame as leoFrame
import leo.plugins.qt_text as qt_text
from leo.core.leoQt import Qsci,QtWidgets
if Qsci:
    w = Qsci.QsciScintilla()
    q = qt_text.QScintillaWrapper(widget=w,c=c,name='test')
    q_list = [z for z in sorted(dir(q)) if not z.startswith('__')]
# Check the text wrappers.
W = leoFrame.WrapperAPI(c)
tw = QtWidgets.QTextBrowser()
t = qt_text.QTextEditWrapper(widget=tw,name='test2')
W_list = [z for z in sorted(dir(W)) if not z.startswith('__')]
t_list = [z for z in sorted(dir(t)) if not z.startswith('__')]
ignore = [
    'set_focus', # synonym for setFocus
    'mutable_methods', # maybe for unit test, not actually used.
]
for z in W_list:
    if z not in t_list and z not in ignore:
        assert False,'In WrapperAPI but not in QTextEditWrapper: %s' % z
if Qsci:
    for z in W_list:
        if z not in q_list and z not in ignore:
            assert False,'In WrapperAPI but not in QScintillaWrapper: %s' % z
# Check Null classes that are not subclasses of a base type:
table = (
    ('NullIconBarClass',leoFrame.NullIconBarClass(c,None),
     # 'c.frame.iconBar',c.frame.iconBar,
     'IconBarAPI',leoFrame.IconBarAPI(c,None),
    ),
    ('NullStatusLineClass',leoFrame.NullStatusLineClass(c,None),
     # 'c.frame.statusLine',c.frame.statusLine,
     'StatusLineAPI',leoFrame.StatusLineAPI(c,None)
    )
)
for name1,L,name2,W in table:
    W_list = [z for z in sorted(dir(W)) if not z.startswith('__')]
    L_list = [z for z in sorted(dir(L)) if not z.startswith('__')]
    for z in W_list:
        assert z in L_list,'In %s but not in %s: %s' % (name2,name1,z)
</t>
<t tx="ekr.20190113114613.395">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
if 'Find' not in c.frame.log.frameDict:
    self.skipTest('No Find tab')

tabs = ('Log', 'Find')
log = c.frame.log
c.bodyWantsFocusNow()
last_widget = c.frame.body
for tab in tabs:
    # A small hack: fudge up the widget to pass to the command.
    event = g.bunch(widget=last_widget)
    c.editCommands.cycleAllFocus(event=event)
    assert log.tabName == tab,'expected %s, got %s' % (
        tab,log.tabName)
    last_widget = log.contentsDict.get(tab)
    event = g.bunch(widget=last_widget)
    # This throws exception: LeoQTextBrowser has no attribute logCtrl.
    c.k.handleDefaultChar(event, stroke='a')
</t>
<t tx="ekr.20190113114613.396">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

exec(g.findTestScript(c,'@common x-marked-nodes test code'))

def test(p):
    setup_test(p)
    n = p.numberOfChildren()
    assert n == 4 ,'delete: children: %s' % (n)
    c.moveMarked()
    assert c.p.h == 'Moved marked nodes'
    n = p.numberOfChildren()
    assert n == 2 ,'delete: children: %s' % (n)
    if 0:
        # The new move-marked-nodes command doesn't
        # leave the result in the root node.
        root = c.rootPosition()
        assert root.h == 'Moved marked nodes',root.h
    if 0: # The move-marked-nodes command is no longer undoable.
        c.undoer.undo()
        n = p.numberOfChildren()
        assert n == 4,'undo: children: %s' % (n)
        c.undoer.redo()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
try:
    test(p)
finally:
    tear_down(p,'Moved marked nodes')
</t>
<t tx="ekr.20190113114613.397"></t>
<t tx="ekr.20190113114613.398"># This hack is needed only for tkinter gui.
if not g.app.gui.guiName() == 'tkinter':
    self.skipTest('Only for tkinter')

p.OnHyperLinkControlClick(event=None)
</t>
<t tx="ekr.20190113114613.399">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
if c.k.defaultUnboundKeyAction != 'insert':
    self.skipTest('Wrong binding')
    
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p)
c.bodyWantsFocus()
paste = 'ABC'
g.app.gui.replaceClipboardWith(paste)
event = g.app.gui.create_key_event(c,w=c.frame.body.wrapper)
c.frame.pasteText(event)

# Move around and and make sure it doesn't change.
try:
    assert p.b == paste, 'paste1 failed'
    c.selectPosition(p.threadBack())
    assert p.b == paste, 'stick failed'
    c.selectPosition(p)
    assert p.b == paste, 'revisit failed'
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20190113114613.4">@

All the tags should be tested at least once (equal, replace, delete, insert).

The replace, delete, insert operations should happen at least once:
    1. At the beginning of a node.
    2. In the middle of a node.
    3. At the end of a node.

For the delete and replace operators we must also test the case that the
deletion or replacement spans more than one block.
</t>
<t tx="ekr.20190113114613.40">line 1
line 2
line 3
</t>
<t tx="ekr.20190113114613.400"># Should be a comment
if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
w = c.frame.body.wrapper
n = c.frame.body.colorizer.recolorCount
# print(c.frame.body.colorizer)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.bodyWantsFocus()
paste = '# Should be a comment'
g.app.gui.replaceClipboardWith(paste)
c.outerUpdate()
event = g.app.gui.create_key_event(c,w=c.frame.body.wrapper)
c.frame.pasteText(event)
try:
    assert c.frame.body.colorizer.recolorCount &gt; n
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20190113114613.401">if g.in_bridge:
    # No need for this extra output.
    self.skipTest('In bridge')
tree = c.frame.tree
if hasattr(tree,'redrawCount'):
    g.pr('%s: %s' % (p.h,tree.redrawCount))
</t>
<t tx="ekr.20190113114613.402">if g.in_bridge:
    self.skipTest('Not for TravisCI')
if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
table = (
    # ('ignore_case','toggle-find-ignore-case-option'),
        # This option now can be set automagically.
    ('search_body','toggle-find-in-body-option'),
    ('search_headline','toggle-find-in-headline-option'),
    ('mark_changes','toggle-find-mark-changes-option'),
    ('mark_finds','toggle-find-mark-finds-option'),
    ('pattern_match','toggle-find-regex-option'),
    # ('reverse','toggle-find-reverse-option'),
    ('whole_word','toggle-find-word-option'),
    ('wrap','toggle-find-wrap-around-option'),
)
fc = c.findCommands
for ivar,command in table:
    val1 = getattr(fc,ivar)
    try:
        c.k.simulateCommand(command)
        val2 = getattr(fc,ivar)
        assert val2 == (not val1),'failed 1 %s' % command
        c.k.simulateCommand(command)
        val3 = getattr(fc,ivar)
        assert val3 == val1,'failed 2 %s' % command
    finally:
        setattr(fc,ivar,val1)
</t>
<t tx="ekr.20190113114613.403">if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
import sys
if sys.platform.startswith('linux'):
    # Fails for strange reasons.
    self.skipTest('Not for Linux')


h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.bodyWantsFocus()
c.redraw(p) # To make node visible
n = c.frame.tree.redrawCount
assert not p.b, 'oops1'
try:
    assert p == c.p,'position has changed!'
    w = c.frame.body.wrapper
    if c.vim_mode and c.vimCommands:
        if c.vimCommands.state == 'normal':
            # Enter insert mode ;-)
            g.app.gui.event_generate(c,'i','i',w)
    g.app.gui.event_generate(c,'a','a',w)
    assert p.b == 'a', 'expected "a", got: %s' % repr(p.b)
    if g.app.gui.guiName() != 'nullGui':
        n2 = c.frame.tree.redrawCount
        c.outerUpdate() # Force the coloring before doing the test.
        assert n2 == n + 1,'too many or too few redraws: expected 1: got: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20190113114613.404"># See https://github.com/leo-editor/leo-editor/issues/512</t>
<t tx="ekr.20190113114613.405">======================================================================
ERROR: runTest (leo.core.leoTest.GeneralTestCase)
@test x.makeShadowDirectory
@test all commands have an event arg

@test add/delete html comments

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/mnt/usr1/usr1/home/tbrown/t/Package/leo/git/leo-editor/leo/core/leoTest.py", line 211, in runTest
    builtins.execfile(scriptFile, d)
  File "/home/tbrown/.leo/scriptFile.py", line 27, in &lt;module&gt;
    assert p.b == s,'fail5: s\n%s\nresult\n%s' % (repr(s),repr(p.b))
AssertionError: fail5: s
u'@language html\n&lt;html&gt;\n    text \n&lt;/html&gt;\n'
result
u'@language html\n&lt;html&gt;\n   text \n&lt;/html&gt;\n'

======================================================================
FAIL: runTest (leo.core.leoTest.EditBodyTestCase)
EditBodyTestCase: addComments
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/mnt/usr1/usr1/home/tbrown/t/Package/leo/git/leo-editor/leo/core/leoTest.py", line 105, in runTest
    self.editBody()
  File "/mnt/usr1/usr1/home/tbrown/t/Package/leo/git/leo-editor/leo/core/leoTest.py", line 85, in editBody
    compareHeadlines=False), '%s: before undo1' % commandName
AssertionError: addComments: before undo1</t>
<t tx="ekr.20190113114613.406">import glob
import os
x = c.shadowController
@others
shadow_fn  = x.shadowPathName('unittest/xyzzy/test.py')
shadow_dir = x.shadowDirName('unittest/xyzzy/test.py')
if g.os_path_exists(shadow_fn):
    g.utils_remove(shadow_fn,verbose=True)
    # assert not os.path.exists(shadow_fn),'still exists: %s' % shadow_fn
    if os.path.exists(shadow_fn):
        # Fix bug #512: Just skip this test.
        self.skipTest('Can not delete the directory.')
deleteShadowDir(shadow_dir)
x.makeShadowDirectory(shadow_dir)
assert os.path.exists(shadow_dir)
deleteShadowDir(shadow_dir)
</t>
<t tx="ekr.20190113114613.407">def deleteShadowDir(shadowDir):

    if g.os_path_exists(shadow_dir):
        files = g.os_path_abspath(g.os_path_join(shadow_dir,"*.*"))
        files = glob.glob(files)
        for z in files:
            if z != shadow_dir:
                # g.trace(z)
                os.unlink(z)
        # g.trace(shadow_dir)
        os.rmdir(shadow_dir)
        assert not os.path.exists(shadow_dir),'still exists: %s' % shadow_dir
</t>
<t tx="ekr.20190113114613.408">import inspect

d = c.commandsDict
keys = sorted(d.keys())
table = ('bookmark', 'quickmove_', 'screen-capture', 'stickynote')
for key in keys:
    continue_flag = False
    for prefix in table:
        if key.startswith(prefix):
            continue_flag = True
            break # These plugins have their own signatures.
    if continue_flag:
        continue
    f = d.get(key)
    # print(key, f.__name__ if f else repr(f))
    # Test true __call__ methods if they exist.
    name = getattr(f,'__name__',None) or repr(f)
    if hasattr(f,'__call__') and inspect.ismethod(f.__call__):
        f = getattr(f,'__call__')
    args, varargs, varkw, defaults = data = inspect.getargspec(f)
    arg0 = len(args) &gt; 0 and args[0]
    arg1 = len(args) &gt; 1 and args[1]
    expected = ('event',)
    message = '\nno event arg for command %s, func: %s\nargs: %s' % (key,name,data)
    assert arg0 in expected or arg1 in expected, message
</t>
<t tx="ekr.20190113114613.409"></t>
<t tx="ekr.20190113114613.41">line 1
line 2
inserted line
line 3
</t>
<t tx="ekr.20190113114613.410">w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'rest and python')
assert p,'not found: rest and python'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        False,
        '@language rest\nrest text.\n@language python\ndef spam():\n    pass\n# after',
        '@language rest\nrest text.\n@language python\ndef spam():\n#     pass\n# after',
    ),
    (
        True,
        '@language rest\nrest text.\n@language python\ndef spam():\n    pass\n# after',
        '@language rest\nrest text.\n@language python\ndef spam():\n    # pass\n# after',
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('pass')
        assert i &gt; -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test add-comments
        c.addComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
</t>
<t tx="ekr.20190113114613.411">@language rest
rest text.
@language python
def spam():
    # pass
# after
</t>
<t tx="ekr.20190113114613.412">w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'rest and python')
assert p,'not found: rest and python'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        False,
        '@language rest\nrest text.\n@language python\ndef spam():\n#     pass\n# after',
        '@language rest\nrest text.\n@language python\ndef spam():\n    pass\n# after',
    ),
    (
        True,
        '@language rest\nrest text.\n@language python\ndef spam():\n    # pass\n# after',
        '@language rest\nrest text.\n@language python\ndef spam():\n    pass\n# after',
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('pass')
        assert i &gt; -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test add-comments
        c.deleteComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
</t>
<t tx="ekr.20190113114613.413">@language rest
rest text.
@language python
def spam():
    pass
# after
</t>
<t tx="ekr.20190113114613.414">w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'html')
assert p,'not found: html'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        False,
        '@language html\n&lt;html&gt;\ntext\n&lt;/html&gt;\n',
        '@language html\n&lt;html&gt;\n&lt;!-- text --&gt;\n&lt;/html&gt;\n',
    ),
    (
        True,
        '@language html\n&lt;html&gt;\n    text\n&lt;/html&gt;\n',
        '@language html\n&lt;html&gt;\n    &lt;!-- text --&gt;\n&lt;/html&gt;\n'
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('text')
        assert i &gt; -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test add-comments
        c.addComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
</t>
<t tx="ekr.20190113114613.415">@language html
</t>
<t tx="ekr.20190113114613.416">@language html
&lt;html&gt;
    &lt;!-- text --&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20190113114613.417">w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'html')
assert p,'not found: html'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        False,
        '@language html\n&lt;html&gt;\n&lt;!-- text --&gt;\n&lt;/html&gt;\n',
        '@language html\n&lt;html&gt;\ntext\n&lt;/html&gt;\n',
    ),
    (
        True,
        '@language html\n&lt;html&gt;\n    &lt;!-- text --&gt;\n&lt;/html&gt;\n',
        '@language html\n&lt;html&gt;\n    text\n&lt;/html&gt;\n',
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('text')
        assert i &gt; -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test delete-comments
        c.deleteComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
</t>
<t tx="ekr.20190113114613.418">@language html
</t>
<t tx="ekr.20190113114613.419">@language html
&lt;html&gt;
    text
&lt;/html&gt;
</t>
<t tx="ekr.20190113114613.42"></t>
<t tx="ekr.20190113114613.420">w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'python')
assert p,'not found: python'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        True,
        '@language python\ndef spam():\n    pass\n\n# after',
        '@language python\ndef spam():\n    # pass\n\n# after',
    ),
    (
        False,
        '@language python\ndef spam():\n    pass\n\n# after',
        '@language python\ndef spam():\n#     pass\n\n# after',
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('pass')
        assert i &gt; -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test add-comments
        c.addComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
</t>
<t tx="ekr.20190113114613.421">@language python
def spam():
#     pass

# after
</t>
<t tx="ekr.20190113114613.422">w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'python')
assert p,'not found: python'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        True,
        '@language python\ndef spam():\n    # pass\n\n# after',
        '@language python\ndef spam():\n    pass\n\n# after',
    ),
    (
        False,
        '@language python\ndef spam():\n#     pass\n\n# after',
        '@language python\ndef spam():\n    pass\n\n# after',
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('pass')
        assert i &gt; -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test delete-comments
        c.deleteComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
</t>
<t tx="ekr.20190113114613.423">@language python
def spam():
    pass

# after
</t>
<t tx="ekr.20190113114613.424"></t>
<t tx="ekr.20190113114613.425">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

s = '''\
.. toc

.. The section name contains trailing whitespace.

=======
Chapter 
=======

The top chapter.
'''
table = (
    "!Dummy chapter",
    "Chapter",
)
try:
    c.importCommands.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20190113114613.426">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

top
====

The top section

section 1
---------

section 1, line 1
--
section 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''
table = (
    '!Dummy chapter',
    'top',
    'section 1',
    'section 2',
    'section 2.1',
    'section 2.1.1',
    'section 3',
    'placeholder',
    'section 3.1.1',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20190113114613.427">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

====
top
====

The top section

section 1
---------

section 1, line 1
--
section 1, line 2

section 2
---------

section 2, line 1

section 2.1
~~~~~~~~~~~

section 2.1, line 1

section 2.1.1
.............

section 2.2.1 line 1

section 3
---------

section 3, line 1

section 3.1.1
.............

section 3.1.1, line 1
'''
table = (
    '!Dummy chapter',
    'top',
    'section 1',
    'section 2',
    'section 2.1',
    'section 2.1.1',
    'section 3',
    'placeholder',
    'section 3.1.1',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20190113114613.428">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

s = '''\
.. toc

.. The section name contains trailing whitespace.

======
top 
======

The top section.
'''
table = (
    "!Dummy chapter",
    "top",
)
try:
    c.importCommands.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20190113114613.429">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

s = '''\
.. toc

======
top
======

The top section
'''
table = (
    "!Dummy chapter",
    "top",
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20190113114613.43">line 1
line 2
line 3
</t>
<t tx="ekr.20190113114613.430">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

if 0: # Preamble
    if c.isChanged(): c.save()
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands
s = '''\
.. toc

top
-------------

The top section
'''
table = (
    '!Dummy chapter',
    'top',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
    c.redraw()
</t>
<t tx="ekr.20190113114613.431">import leo.core.leoImport as leoImport
if leoImport.docutils is None:
    self.skipTest('no docutils')

if 0:
    # The preamble...
    if c.isChanged(): c.save()
    import leo
    import leo.core.leoImport as leoImport
    import leo.plugins.importers.linescanner as linescanner
    import leo.plugins.importers.leo_rst as leo_rst
    # Reload all.
    import imp
    imp.reload(leo.plugins.importers.linescanner)
    imp.reload(leo.plugins.importers.leo_rst)
    imp.reload(leoImport)
    g.app.loadManager.createAllImporetersData()
    ic = leoImport.LeoImportCommands(c)
else:
    ic = c.importCommands

# Notes:
# All heading must be followed by an empty line.
### g.app.suppressImportChecks = True
s = '''\
  #########
Chapter 1
  #########

It was a dark and stormy night.
section 1
+++++++++

Sec 1.
section 2
+++++++++

Sec 2.
'''
table = (
    '!Dummy chapter',
    'section 1',
    'section 2',
)
try:
    ic.rstUnitTest(p,s=s,showTree=True)
    if 1:
        root = c.p.lastChild()
        assert root.h.startswith('@@'), root.h
        p2 = root.firstChild()
        for h in table:
            assert p2.h == h, (p2.h, h)
            p2.moveToThreadNext()
        assert not root.isAncestorOf(p2), p2.h # Extra nodes
finally:
    if 1:
        p.deleteAllChildren()
        c.redraw()
</t>
<t tx="ekr.20190113114613.432">@language rest
@wrap

I'm also having 3 failed tests with current master, some of those seem to be different from Terry's ones:

Trying to create a QVariant instance of QMetaType::Void type, an invalid QVariant will be constructed instead


======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test g.app.config @buttons and @commands logic

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\dev\Leo-5.4\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\Users\sysadmin\.leo\scriptFile.py", line 26, in &lt;module&gt;
    assert fn in aList,'%s not in unitTestDict[%s]' % (fn,key)
AssertionError: myLeoSettings.leo not in unitTestDict[config.doCommands-file-names]

======================================================================
FAIL: runTest (leo.core.leoTest.GeneralTestCase)
@test unbound Alt-9 key is completely ignored

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\dev\Leo-5.4\leo\core\leoTest.py", line 209, in runTest
    exec(compile(script, scriptFile, 'exec'), d)
  File "C:\Users\sysadmin\.leo\scriptFile.py", line 27, in &lt;module&gt;
    assert g.app.unitTestDict.get('handleUnboundChar-ignore-alt-or-ctrl')
AssertionError

----------------------------------------------------------------------
Ran 905 tests in 120.272s

FAILED (failures=3, skipped=11)

@language python


</t>
<t tx="ekr.20190113114613.433">if g.app.gui.guiName() == 'browser':
    self.skipTest('browser gui')
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
if getattr(g.app, 'isBrowserTest', None):
    # Set only in test_browser_gui.py.
    self.skipTest('Browser Gui test')
d = g.app.config.unitTestDict # Always created for this unit test.
keys = ('config.doButtons-file-names','config.doCommands-file-names')
for key in keys:
    aList = d.get(key,[])
    for base in ('leoSettings', 'unitTest'):
        for ext in ('.leo', '.db'):
            if base+ext in aList:
                break
        else:
            print('key', key, 'ext', ext, 'base', base)
            g.printObj(aList)
            assert False,'%s not in unitTestDict[%s]' % (base,key)
</t>
<t tx="ekr.20190113114613.44">line 1
line 2
line 3
inserted line
</t>
<t tx="ekr.20190113114613.45"></t>
<t tx="ekr.20190113114613.46">@others
</t>
<t tx="ekr.20190113114613.47">node 1 line 1
</t>
<t tx="ekr.20190113114613.48">node 2 line 1
</t>
<t tx="ekr.20190113114613.49">@others
</t>
<t tx="ekr.20190113114613.5"></t>
<t tx="ekr.20190113114613.50">node 1 line 1
inserted node at end of node 1
</t>
<t tx="ekr.20190113114613.51">node 2 line 1
</t>
<t tx="ekr.20190113114613.52"></t>
<t tx="ekr.20190113114613.53">@others
</t>
<t tx="ekr.20190113114613.54">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20190113114613.55">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.56">@others
</t>
<t tx="ekr.20190113114613.57">node 1 line 1
</t>
<t tx="ekr.20190113114613.58">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.59"></t>
<t tx="ekr.20190113114613.6">@others
</t>
<t tx="ekr.20190113114613.60">@others
</t>
<t tx="ekr.20190113114613.61">node 1 line 1
</t>
<t tx="ekr.20190113114613.62">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.63">@others
</t>
<t tx="ekr.20190113114613.64">node 1 line 1
</t>
<t tx="ekr.20190113114613.65">node 2 line 2
</t>
<t tx="ekr.20190113114613.66"></t>
<t tx="ekr.20190113114613.67">@others
</t>
<t tx="ekr.20190113114613.68">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20190113114613.69">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.7">@
node 1 old line 1
node 1 old line 2
node 1 line 2
</t>
<t tx="ekr.20190113114613.70">@others
</t>
<t tx="ekr.20190113114613.71">node 1 line 1
node 1 line 1 changed
</t>
<t tx="ekr.20190113114613.72">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.73"></t>
<t tx="ekr.20190113114613.74">@others
</t>
<t tx="ekr.20190113114613.75">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20190113114613.76">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.77">@others
</t>
<t tx="ekr.20190113114613.78">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20190113114613.79">node 2 line 1 changed
node 2 line 2
</t>
<t tx="ekr.20190113114613.8">@others
</t>
<t tx="ekr.20190113114613.80"></t>
<t tx="ekr.20190113114613.81">@others
</t>
<t tx="ekr.20190113114613.82">node 1 line 1
inserted node 1 at end of node 1
inserted node 2 at end of node 1
</t>
<t tx="ekr.20190113114613.83">node 2 line 1
</t>
<t tx="ekr.20190113114613.84">@others
</t>
<t tx="ekr.20190113114613.85">node 1 line 1
</t>
<t tx="ekr.20190113114613.86">node 2 line 1
</t>
<t tx="ekr.20190113114613.87"></t>
<t tx="ekr.20190113114613.88">@others
</t>
<t tx="ekr.20190113114613.89">node 1 line 1
node 1 line 2
node 1 line 3
</t>
<t tx="ekr.20190113114613.9">@
node 1 old line 1
node 1 old line 2
node 1 line 2
</t>
<t tx="ekr.20190113114613.90">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.91">@others
</t>
<t tx="ekr.20190113114613.92">node 1 line 1
node 1 line 2 changed
node 1 line 3 changed
</t>
<t tx="ekr.20190113114613.93">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.94"></t>
<t tx="ekr.20190113114613.95">@others
</t>
<t tx="ekr.20190113114613.96">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20190113114613.97">node 2 line 1
node 2 line 2
</t>
<t tx="ekr.20190113114613.98">@others
</t>
<t tx="ekr.20190113114613.99">node 1 line 1
node 1 line 2
</t>
<t tx="ekr.20190113114631.1"></t>
<t tx="ekr.20190113123110.1">at = c.atFileCommands

# at.toString is set by the execute-script command.
# at.outputFile = f = g.fileLikeObject() # Re-allocate for the test.
f = at.openAtShadowStringFile('abc')
assert isinstance(f,g.fileLikeObject)
s = 'abc'
f.write(s)
s2 = at.closeAtShadowStringFile(f)
assert s == s2,s2
# assert at.toString
</t>
<t tx="ekr.20190114095901.2">import os
s = 'abc'
fn = 'unitTestFile.py'
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','unittest',fn))
try:
    c.atFileCommands.replaceFileWithString(path,s)
    f = open(path)
    s2 = f.read()
    f.close()
    assert s == s2
finally:
    if g.os_path_exists(path):
        os.unlink(path)
</t>
<t tx="ekr.20190114095901.3">at = c.atFileCommands

fn = 'does/not/exist'
assert not g.os_path_exists(fn)
assert not at.replaceFileWithString (fn,'abc')
</t>
</tnodes>
</leo_file>
