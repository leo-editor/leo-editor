<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ville.20090627211608.5782"><vh>Welcome to Leo!</vh></v>
<v t="ekr.20090628091852.6030"><vh>Startup</vh>
<v t="ville.20090627211608.5783"><vh>@chapters</vh></v>
<v t="ekr.20090628091852.6031"><vh>@settings</vh>
<v t="ekr.20090628091852.8471"><vh>@string target_language = rest</vh></v>
<v t="ekr.20090628092246.4267"><vh>@int page_width = 60</vh></v>
<v t="ekr.20180410083042.1"><vh>@bool body_pane_wraps = True</vh></v>
<v t="mhw.20181210131031.1"><vh>@bool put-expansion-bits-in-leo-files = False</vh></v>
</v>
<v t="ekr.20090628092604.1829"><vh>change log</vh></v>
</v>
<v t="ville.20090627211608.5784"><vh>Tree manipulation basics</vh></v>
<v t="ville.20090630234425.12394"><vh>Programming</vh>
<v t="ville.20090627211608.10118"><vh>External files</vh>
<v t="ville.20090627211608.10116"><vh>\@file (explanation &amp; exercise)</vh>
<v t="ville.20090627211608.10119"><vh>@path ~</vh>
<v t="ville.20090627211608.10117"><vh>@@file myfile_file.py</vh>
<v t="ville.20090627211608.10120"><vh>imports &amp; setup routines</vh>
<v t="ville.20090627211608.10127"><vh>imports</vh></v>
<v t="ville.20090627211608.10128"><vh>init1, init2</vh></v>
</v>
<v t="ville.20090627211608.10122"><vh>class Foo</vh>
<v t="ville.20090630145410.1514"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ville.20090627211608.10124"><vh>spam</vh></v>
<v t="ville.20090627211608.10125"><vh>eggs</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20180410082027.1"><vh>\@clean</vh>
<v t="ekr.20180410082058.2"><vh>@path ~</vh>
<v t="ekr.20180410082058.3"><vh>@@clean myfile_clean.py</vh>
<v t="ekr.20180410082058.4"><vh>imports &amp; setup routines</vh>
<v t="ekr.20180410082058.5"><vh>imports</vh></v>
<v t="ekr.20180410082058.6"><vh>init1, init2</vh></v>
</v>
<v t="ekr.20180410082058.7"><vh>class Foo</vh>
<v t="ekr.20180410082058.8"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20180410082058.9"><vh>spam</vh></v>
<v t="ekr.20180410082058.10"><vh>eggs</vh></v>
</v>
</v>
</v>
</v>
<v t="ville.20090627211608.10129"><vh>\@auto</vh>
<v t="ville.20090630145410.1517"><vh>@path ~</vh>
<v t="ville.20090630145410.1509"><vh>@@auto myfile_auto.py</vh>
<v t="ekr.20130916065121.11556"><vh>myfile_auto declarations</vh></v>
<v t="ekr.20130916065121.11557"><vh>init1</vh></v>
<v t="ekr.20130916065121.11558"><vh>init2</vh></v>
<v t="ekr.20130916065121.11559"><vh>class Foo</vh>
<v t="ekr.20130916065121.11560"><vh>spam</vh></v>
<v t="ekr.20130916065121.11561"><vh>eggs</vh></v>
</v>
</v>
</v>
</v>
<v t="ville.20090701175849.1532"><vh>\@shadow</vh>
<v t="ville.20090701175849.1542"><vh>@path ~</vh>
<v t="ville.20090701175849.1543"><vh>@@shadow myfile_shadow.py</vh>
<v t="ville.20090701175849.1544"><vh>imports &amp; setup routines</vh>
<v t="ville.20090701175849.1545"><vh>imports</vh></v>
<v t="ville.20090701175849.1546"><vh>init1, init2</vh></v>
</v>
<v t="ville.20090701175849.1547"><vh>class Foo</vh>
<v t="ville.20090701175849.1548"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ville.20090701175849.1549"><vh>spam</vh></v>
<v t="ville.20090701175849.1550"><vh>eggs</vh></v>
</v>
</v>
</v>
</v>
<v t="ville.20090701184416.1554"><vh>reStructuredText (@auto-rst)</vh>
<v t="ville.20090701184416.1555"><vh>@path ~</vh>
<v t="ville.20090701184416.1556"><vh>@@auto-rst myfile_rst.txt</vh>
<v t="ville.20090701184416.1557"><vh>Main heading</vh>
<v t="ville.20090701184416.1558"><vh>subheading 1</vh></v>
<v t="ville.20090703222440.1472"><vh>subheading 2</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="ville.20090630234425.12395"><vh>Configuration (enabling plugins etc.)</vh>
<v t="ville.20090630234425.14847"><vh>Find out your ~/.leo directory (script)</vh></v>
<v t="ekr.20160429174727.1"><vh>Creating Windows file associations</vh></v>
<v t="ville.20090630234425.12396"><vh>\@settings</vh>
<v t="ville.20090728003644.3957"><vh>@enabled-plugins</vh></v>
<v t="ville.20090708172716.16846"><vh>@@string initial_split_orientation = horizontal</vh></v>
<v t="ville.20090806210322.1435"><vh>Themes</vh></v>
<v t="ville.20090806182306.6324"><vh>@int qt_max_colorized_chars = 200000</vh></v>
<v t="ville.20091008194838.3931"><vh>@data contextmenu_commands</vh></v>
<v t="ville.20120303151721.3838"><vh>@bool use_body_focus_border = False</vh></v>
<v t="ville.20121120220349.2862"><vh>@shortcut key bindings</vh></v>
</v>
<v t="ville.20121024204851.1498"><vh>Using your favorite editor to edit nodes</vh></v>
</v>
<v t="ville.20090701182804.1550"><vh>Search and replace</vh></v>
<v t="ville.20090701182804.1551"><vh>Minibuffer</vh></v>
<v t="ville.20101221125548.2199"><vh>Scripting Leo</vh>
<v t="ville.20101221131940.2204"><vh>Executing scripts with ctrl+b</vh>
<v t="ville.20101221131940.2211"><vh>Press ctrl+b here</vh></v>
</v>
<v t="ville.20101221131940.2217"><vh>Creating script buttons</vh>
<v t="ville.20101221131940.2218"><vh>@button example-btn</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20090628091852.6030">This node contains settings and other "machinery" that you can usually ignore.
</t>
<t tx="ekr.20090628091852.6031"></t>
<t tx="ekr.20090628091852.8471"></t>
<t tx="ekr.20090628092246.4267">The page width for wrapping doc parts in derived files.

Valid values: any nonzero positive integer.</t>
<t tx="ekr.20090628092604.1829">Added settings to use rest by default and use a page width
of 60 for wrapping paragraphs.

Created the startup node and its descendants.</t>
<t tx="ekr.20130916065121.11556">import os
import sys

</t>
<t tx="ekr.20130916065121.11557">def init1():
    print("init1")

</t>
<t tx="ekr.20130916065121.11558">def init2():
    print("init2")
</t>
<t tx="ekr.20130916065121.11559">class Foo:
    """ Some sort of useful class """
    @others
</t>
<t tx="ekr.20130916065121.11560">def spam(self):
    pass

</t>
<t tx="ekr.20130916065121.11561">def eggs(self):
    pass


</t>
<t tx="ekr.20160429174727.1">*Important*: Leo's binary Windows installer sets file associations
automatically, so this section is needed only if you are installing Leo
from a .zip file or other sources.

There are two ways of associating .leo files with Leo. The first uses the
Windows control panel, the second, the Windows console.

**Method 1: Using the Windows Control Panel**

The goal is that you want to associate .leo files with the following command::

    "&lt;path to python&gt;\python.exe" "&lt;path to launchLeo.py&gt;\launchLeo.py" "%1"
    
Before Windows 7, you do this with using the Folder Options control panel.
In Windows 7, you do this with the Default Programs control panel.

*Note*: "%1" passes just the file being clicked on, quoted for spaces etc.
The quotation marks are needed to handle file paths containing spaces.

*Warning:* In a batch file, %1 passes just the first command line parameter.
It is logical to expect %* to work for file associations just as in batch
files. Alas, it does not.

**Method 2: Using the Windows Console**

Open a Windows console with administrator privileges, then type::

    ftype LeoFile="&lt;path to python&gt;\pythonw.exe" "&lt;path to launchLeo.py&gt;\launchLeo.py" "%1" %*
    assoc .leo=LeoFile

And put this leo.bat in %PATH%::

    @start /b "Leo" "&lt;path to python&gt;\python.exe" "&lt;path to launchLeo.py&gt;\launchLeo.py" %*
    
You may omit the /b option if you want to create a separate console window for Leo.
</t>
<t tx="ekr.20180410082027.1">In this tree, you can experiment with @clean. It combines the benefits of @file and @auto. That is, it publishes a file without sentinels, but still allows the tree structure to survive, even if the external file is edited outside Leo.

Experiment by editing the external file outside Leo and doing Right click
-&gt; refresh from disk on the @clean node. </t>
<t tx="ekr.20180410082058.10">def eggs(self):
    pass</t>
<t tx="ekr.20180410082058.2"></t>
<t tx="ekr.20180410082058.3">@language python
@nowrap
@others
</t>
<t tx="ekr.20180410082058.4"></t>
<t tx="ekr.20180410082058.5">import os
import sys

</t>
<t tx="ekr.20180410082058.6">def init1():
    print("init1")

def init2():
    print("init2")</t>
<t tx="ekr.20180410082058.7">class Foo:
    &lt;&lt; docstring &gt;&gt;
    @others


</t>
<t tx="ekr.20180410082058.8">""" Some sort of useful class """

</t>
<t tx="ekr.20180410082058.9">def spam(self):
    pass

</t>
<t tx="ekr.20180410083042.1"></t>
<t tx="mhw.20181210131031.1">True (recommended):
    Write "E" attribute bits in &lt;v&gt; elements.
    Leo outlines will record the expansion state of all nodes.
    
False: (Good for files like unitTest.leo)
    Suppress "E" attribute bits in &lt;v&gt; elements.
    Only the ancestors of the presently selected node will
    be expanded when Leo opens an outline.</t>
<t tx="ville.20090627211608.10116">Remove the first @ from @file in the subtree below and save (ctrl+s) to create an **external file** which is directly usable outside leo. Try opening the resulting myfile.py in a normal text editor (e.g. from right-click menu on the @file node) to see what it looks like.

Note the @others directive, and the the lines that look like

#@-node:ville.20090627211608.10122:class Foo

These are called **sentinels**. They are needed to preserve the tree structure in the external files. They allow your tree structure to survive, even when someone else edits the source (or you edit it yourself in an external editor).
</t>
<t tx="ville.20090627211608.10117">@language python
@others
</t>
<t tx="ville.20090627211608.10118">An **External file*** is a file that resides on your file system. If you are programming, these are the files you eventually want to create to get something useful out of Leo, for example, your C++ or Python source code files.
</t>
<t tx="ville.20090627211608.10119"> </t>
<t tx="ville.20090627211608.10120"></t>
<t tx="ville.20090627211608.10122">class Foo:
    &lt;&lt; docstring &gt;&gt;
    @others

</t>
<t tx="ville.20090627211608.10124">def spam(self):
    pass

</t>
<t tx="ville.20090627211608.10125">def eggs(self):
    pass</t>
<t tx="ville.20090627211608.10127">import os
import sys

</t>
<t tx="ville.20090627211608.10128">def init1():
    print("init1")

def init2():
    print("init2")</t>
<t tx="ville.20090627211608.10129">If the sentinels in @file nodes are unacceptable for your workflow (typically the case when you are the only one using Leo in a particular project), you can use @auto nodes to "play well with others". @auto nodes understand the structure of the source code (parsers exist for popular languages), and create the "typical" outline for the code when the file is loaded. When you save, the outline is written back.

Do the same thing you did with @@file - i.e., 

- Remove the first @, and save. 
- Check the resulting file (`/myfile_auto.py) and observe that it has 
  no sentinels.   
- There is no "magic" involved. If you execute 'File -&gt; Read auto nodes" 
  (or right click on @auto node and choose "Refresh from disk", or reopen 
  this document), you'll note that  the outline structure was lost, 
  and the "parsed" structure is created instead. This is the cost
  of using @auto nodes.</t>
<t tx="ville.20090627211608.5782">This is a brief tutorial for getting familiar with basic Leo functionality. Click around and experiment.

Note that you probably want to save your own "working copy" of this file before proceeding further. Do that by "File -&gt; Save as".

This guide is intentionally quite brief and minimal - therefore, it merely scratches the surface of what Leo can do. You can begin leveraging Leo for mindmapping-like tasks by just reading the node "Tree manipulation basics", and moving on to other topics after acquiring some basic familiarity.
</t>
<t tx="ville.20090627211608.5783"></t>
<t tx="ville.20090627211608.5784">You can use Leo as fairly typical outliner. Play around with some of the commands from the Outline menu:

- Click the expansion box of nodes_ to show and hide their
  children.

- The ``Insert Node`` command (``Ctrl+I``) inserts a new
  headline into the outline.

- The ``Cut Node`` command (``Ctrl+Shift+X``) deletes a
  headline and all its children, and copies the structure to
  clipboard - ready to paste with ``Paste Node`` command
  (``Ctrl+Shift+V``). Use ``Copy Node`` command
  (``Ctrl+Shift+C``) to copy node to clipboard without
  deleting it from outline. Copy-paste command family works
  across different Leo documents and processes.

- The ``Move Up`` (``Ctrl+U``), ``Move Down`` (``Ctrl+D``),
  ``Move Left`` (``Ctrl+L``) and ``Move Right`` (``Ctrl+R``)
  commands move the currently selected node, along with all
  its descendants.

- The ``Promote`` (``Ctrl+{``) command makes all the
  children of a headline siblings of the headline. The
  ``Demote`` (``Ctrl+}``) command makes all following
  siblings_ of a headline children of the headline.

- Move around the tree and expand/collapse nodes by pressing
  Alt + arrow keys. This also moves the focus to tree, so,
  after pressing Alt + arrow, you can move around by using
  arrow keys alone. Return the focus to the body control by
  pressing ``Enter``.

- To edit the headline, use press ``Ctrl+H``. This works
  regardless of whether body or headline has focus.

You enter `body text` for any node by selecting the node's headline in the outline pane and then typing in the body pane. Leo has a full range of `editing commands` that apply to the body pane.

See Leo's documentation for more detailed discussion.</t>
<t tx="ville.20090630145410.1509">@language python
@tabwidth -4
@nowrap
@others
</t>
<t tx="ville.20090630145410.1514">""" Some sort of useful class """

</t>
<t tx="ville.20090630145410.1517"></t>
<t tx="ville.20090630234425.12394"></t>
<t tx="ville.20090630234425.12395">If you are just starting, you should create your own myLeoSettings.leo in ~/.leo. We'll do that next.

Create the file first: 
  - File -&gt; New (or ctrl+N)
  - File -&gt; Save as
  - Navigate to ~/.leo
  - save as myLeoSettings.leo

In the current tree, there is @@settings subtree. We are copying this to the new file. Go to node @@settings, and copy the whole tree to clipboard (ctrl+shift+c).
  
Select the document that has myLeoSettings.leo (the one you just created). Drop the settings tree there (ctrl+shift+v), Remove extra @ from @@settings, and save again.

Now, you should be all set. Verify that it worked by Help-&gt;open myLeoSettings.leo
</t>
<t tx="ville.20090630234425.12396"></t>
<t tx="ville.20090630234425.14847"># execute this script by ctrl+b to find out where your ~/.leo is

g.es('Homedir is at ',g.app.homeLeoDir)

</t>
<t tx="ville.20090701175849.1532">In this tree, you can experiment with @shadow. Like @clean, it publishes files without sentinels. However, @clean saves reference data in the outline itself, while @shadow creates a "shadow file" that remembers the structure.

My advice is to use @clean rather than @shadow in most cases.

Experiment by editing the external file outside Leo and doing Right click
-&gt; refresh from disk on the @shadow node. </t>
<t tx="ville.20090701175849.1542"></t>
<t tx="ville.20090701175849.1543">@language python
@nowrap
@others
</t>
<t tx="ville.20090701175849.1544"></t>
<t tx="ville.20090701175849.1545">import os
import sys

</t>
<t tx="ville.20090701175849.1546">def init1():
    print("init1")

def init2():
    print("init2")</t>
<t tx="ville.20090701175849.1547">class Foo:
    &lt;&lt; docstring &gt;&gt;
    @others


</t>
<t tx="ville.20090701175849.1548">""" Some sort of useful class """

</t>
<t tx="ville.20090701175849.1549">def spam(self):
    pass

</t>
<t tx="ville.20090701175849.1550">def eggs(self):
    pass</t>
<t tx="ville.20090701182804.1550">Press ctrl + F to enter "minibuffer find" mode. Press F3 to "find again".

For large scale searches (classic "find in files" functionality for the whole tree), look for the "Nav" tab in the log pane (in upper right of the screen). Enter your search string and press enter, then click on the matches.

You can also activate the "Nav" functionality with ctrl+shift+f.

To perform find-and replace, press ctrl-f, enter the text to search, then press ctrl+shift+r, and enter the text to replace the matches with, and press Enter.

To limit the replace operations to particular external file, you can use your external editor. That is, right click on the @file node (say, @file myfile.py), choose "Edit myfile.py in MYEDITOR", and perform the necessary operations. After that, right click on the node and choose "Refresh from disk".
</t>
<t tx="ville.20090701182804.1551">The minibuffer is the text input area at the bottom of the screen, familiar to users of emacs and vi.

Press alt-x to enter a minibuffer command (e.g. alt-x fill-paragraph). Press ctrl+p (repeat-complex-command) followed by Enter to re-run a previous minibuffer command.
</t>
<t tx="ville.20090701184416.1554">reStructuredText (http://docutils.sourceforge.net/rst.html) is an efficient way of authoring documentation as plain text. Leo provides first-class support for RST authoring, including the unique feature of representing RST outline structure as Leo tree. You can find an example in the tree below - again, just remove the first @ character from @@auto-rst and save, opening the external file afterwards.
</t>
<t tx="ville.20090701184416.1555"></t>
<t tx="ville.20090701184416.1556" rst-import="7d710028580b000000756e6465726c696e657332710158000000007102580b000000756e6465726c696e65733171036802752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.

</t>
<t tx="ville.20090701184416.1557">Observe the underlining style of the headings.
</t>
<t tx="ville.20090701184416.1558">Some text in first other chapter.
</t>
<t tx="ville.20090703222440.1472">More text in other chapter.</t>
<t tx="ville.20090708172716.16846">horizontal: body pane to the left
vertical: body pane on the bottom.

vertical is the default; you may prefer horizontal for small but wide screens (e.g. on laptops)</t>
<t tx="ville.20090728003644.3957"># Leo loads plugins in the order they appear here.

# **Important**: to change these defaults, put
# an @enabled-plugins node in myLeoSettings.leo.

# Highly-recommended plugins:

plugins_menu.py
# free_layout.py
    # Now loaded automatically.
    # needs to be early

# Recommended plugins:

contextmenu.py
    # This is required by the vim.py and xemacs.py plugins.
leo_to_html.py
mod_scripting.py
nav_qt.py
quicksearch.py
stickynotes.py
todo.py
viewrendered.py

# Alphabetical list of all Leo plugins.

# active_path.py
# add_directives.py
# at_folder.py
# at_produce.py
# at_view.py
# attrib_edit.py
# backlink.py
# bibtex.py
# bookmarks.py
# bzr_qcommands.py
# chapter_hoist.py
# codewisecompleter.py
# colorize_headlines.py
# contextmenu.py
# ctagscompleter.py
# cursesGui.py
# datenodes.py
# debugger_pudb.py
# detect_urls.py
# dragdropgoodies.py
# dtest.py
# dump_globals.py
# empty_leo_file.py
# enable_gc.py
# expfolder.py
# FileActions.py
# free_layout.py
# ftp.py
# geotag.py
# gitarchive.py
# graphcanvas.py
# import_cisco_config.py
# initinclass.py
# interact.py
# ipython.py
# jinjarender.py
# leo_interface.py
# leo_pdf.py
# leo_to_html.py
# leo_to_rtf.py
# leocursor.py
# leofeeds.py
# leomail.py
# leomylyn.py
# leoOPML.py
# leoremote.py
# leoscreen.py
# lineNumbers.py
# macros.py
# maximizeNewWindows.py
# mime.py
# mnplugins.py
# mod_autosave.py
# mod_framesize.py
# mod_http.py
# mod_leo2ascd.py
# mod_read_dir_outline.py
# mod_scripting.py
# mod_speedups.py
# mod_tempfname.py
# mod_timestamp.py
# multifile.py
# nav_qt.py
# nested_splitter.py
# niceNosent.py
# nodeActions.py
# notebook.py
# open_shell.py
# outline_export.py
# paste_as_headlines.py
# plugins_menu.py
# pluginsTest.py
# pretty_print.py
# projectwizard.py
# qt_quicksearch.py
# qtframecommands.py
# quickMove.py
# quicksearch.py
# quit_leo.py
# read_only_nodes.py
# redirect_to_log.py
# rst3.py
# run_nodes.py
# screen_capture.py
# screencast.py
# screenshots.py
# script_io_to_body.py
# scripts_menu.py
# setHomeDirectory.py
# slideshow.py
# spydershell.py
# startfile.py
# stickynotes.py
# stickynotes_plus.py
# systray.py
# testRegisterCommand.py
# textnode.py
# todo.py
# tomboy_import.py
# trace_gc_plugin.py
# trace_keys.py
# trace_tags.py
# valuespace.py
# viewrendered.py
# vim.py
# word_count.py
# word_export.py
# xemacs.py
# xml_edit.py
# xsltWithNodes.py
# zenity_file_dialogs.py
</t>
<t tx="ville.20090806182306.6324">If zero, all nodes are colorized, regardless of length of body text.
If &gt; 0, only nodes whose body text are smaller than this limit are colorized.</t>
<t tx="ville.20090806210322.1435">To enable a theme .leo file, put the following setting in myLeoSettings.leo::

    @string theme-name = &lt;theme file, without the .leo extension&gt;

The leo/themes folder contains the actual themes files.

Leo's open-theme-file command will prompt you for a theme file, then open that file in a separate process so you can see it in action.</t>
<t tx="ville.20091008194838.3931"># Add commands to contextmenu
# The format is &lt;command&gt; SPACE &lt;description&gt;

# stickynote Create a sticky note
# read-at-file-nodes Read file node</t>
<t tx="ville.20101221125548.2199">Eventually, you will want to add extra functionality to your Leo documents. There are a few simple ways, and unlimited power for advanced users.

For more information, see CheatSheat.leo. You can open it with the leo-cheat-sheet command.
</t>
<t tx="ville.20101221131940.2204">You can write scripts in your document trees, and execute them with ctrl+b. Try it on the child of this node - it should display the list of nodes that have a headline starting with @ in the log pane.

It will also append the summary as a new node under itself.

</t>
<t tx="ville.20101221131940.2211">@language python
@nowrap

# c is "commander", central api object specific to current document 

# get a list of "position" objects
nodes = c.find_h('^@')

res = []
for n in nodes:
    # .b gets the body text, .h is headline
    body = n.b
    res.append("- " + n.h)
    
    res.append("   " + str(body.count('\n')) + " lines")
    
# 'p' is the 'current position'    
child = p.insertAsLastChild()    
child.b = "\n".join(res)
child.h = "Report"

c.redraw()    </t>
<t tx="ville.20101221131940.2217">You can create buttons in the button bar by adding @button nodes to your outline.

A button does not appear automatically when you add it - you need to reopen the document to make it appear.
</t>
<t tx="ville.20101221131940.2218"># p is current position

g.es("p.h is " + p.h)</t>
<t tx="ville.20120303151721.3838">Avoid red focus borders in body pane (if it's not in your aesthetic taste)</t>
<t tx="ville.20121024204851.1498">If you occasionally want to use an alternative editor to
edit body text (e.g. when Leo is still missing a feature
your regular editor has), you can right click on a node and
select "edit in FOO" (where FOO is your alternative editor).
You can change the suggested editor by setting environment
variable LEO_EDITOR - as an example, add this to your
~/.bashrc:

export LEO_EDITOR=gedit

(you obviously need to parse ~/.bashrc before it takes
effect).

If LEO_EDITOR is not defined, EDITOR is used instead.

You can also change the external editor directly from Leo by
executing this as a Leo script:

g.app.db['LEO_EDITOR'] = "gvim"
</t>
<t tx="ville.20121120220349.2862">go-anywhere = ctrl+g</t>
</tnodes>
</leo_file>
