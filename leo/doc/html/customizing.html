<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Chapter 8: Customizing Leo</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\customizing.html -->
<p><a class="reference" href="scripting.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="history.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="chapter-8-customizing-leo">
<h1><a class="toc-backref" href="#id2">Chapter 8: Customizing Leo</a></h1>
<p>This chapter discusses how to customize Leo using the plugins and other means.
See <a class="reference" href="commands.html#specifying-settings">Specifying settings</a> for a description of how to change Leo's settings.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference" href="#chapter-8-customizing-leo" id="id2" name="id2">Chapter 8: Customizing Leo</a><ul>
<li><a class="reference" href="#id1" id="id3" name="id3">Specifying settings</a><ul>
<li><a class="reference" href="#organizer-nodes" id="id4" name="id4">Organizer nodes</a></li>
<li><a class="reference" href="#ignore-nodes" id="id5" name="id5">&#64;ignore nodes</a></li>
<li><a class="reference" href="#simple-settings-nodes" id="id6" name="id6">Simple settings nodes</a></li>
<li><a class="reference" href="#complex-settings-nodes" id="id7" name="id7">Complex settings nodes</a></li>
</ul>
</li>
<li><a class="reference" href="#input-modes" id="id8" name="id8">Input modes</a></li>
<li><a class="reference" href="#adding-extensible-attributes-to-nodes-and-leo-files" id="id9" name="id9">Adding extensible attributes to nodes and .leo files</a></li>
<li><a class="reference" href="#specifying-tk-options-using-leo-xresources" id="id10" name="id10">Specifying Tk options using .leo_xresources</a></li>
</ul>
</li>
</ul>
</div>
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id3">Specifying settings</a></h2>
<p>Leo stores options in <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> trees, that is, outlines whose headline is
<tt class="docutils literal"><span class="pre">&#64;settings</span></tt>. When opening a .leo file, Leo looks for <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> trees not only
in the outline being opened but also in various leoSettings.leo files.
The key design goal of <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> trees was that Leo's user options must be
infinitely flexible. That goal has been accomplished. Indeed, users can create
arbitrarily complex user options with <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> trees. Leo settings outlines
are, in fact, much more flexible and powerful than any scheme based on
flat text.</p>
<p><strong>New in Leo 4.4.2</strong>: The <tt class="docutils literal"><span class="pre">myLeoSettings.leo</span></tt> file is a way of ensuring that your
customized settings are not altered when updating Leo from cvs or while
installing a new version of Leo. The myLeoSettings.leo acts much like Python's
site-customize.py file. The <tt class="docutils literal"><span class="pre">myLeoSettings.leo</span></tt> file will never be part of any Leo
distribution, and it will never exist in Leo's cvs repository. This solution is
<em>much</em> better than tring to update leoSettings.leo with scripts.</p>
<p>The <tt class="docutils literal"><span class="pre">Settings</span></tt> command opens the file leoSettings.leo.</p>
<p>Leo stores options in <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> trees, that is, parts of Leo outlines whose root
node has the headline <tt class="docutils literal"><span class="pre">&#64;settings</span></tt>. When opening a .leo file, Leo looks for
<tt class="docutils literal"><span class="pre">&#64;settings</span></tt> trees in the following places:</p>
<ul class="simple">
<li>The file <tt class="docutils literal"><span class="pre">leoSettings.leo</span></tt> in the leo/config directory.</li>
<li>The file <tt class="docutils literal"><span class="pre">leoSettings.leo</span></tt> in the user's home directory.</li>
<li>The file <tt class="docutils literal"><span class="pre">myLeoSettings.leo</span></tt> in the leo/config directory.</li>
<li>The file <tt class="docutils literal"><span class="pre">myLeoSettings.leo</span></tt> in the user's home directory.</li>
<li>The file being loaded.</li>
</ul>
<p>Settings that appear later in the above list override settings found earlier. For
example, any setting specified in an <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> tree in the file being loaded
overrides any setting seen in any <tt class="docutils literal"><span class="pre">leoSettings.leo</span></tt> file.</p>
<p>The following sections describe the kinds of nodes in <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> trees.</p>
<div class="section" id="organizer-nodes">
<h3><a class="toc-backref" href="#id4">Organizer nodes</a></h3>
<p>Organizer nodes have headlines that do no start with &#64;.
Organizer nodes may be inserted freely without changing the meaning of an &#64;setting tree.</p>
</div>
<div class="section" id="ignore-nodes">
<h3><a class="toc-backref" href="#id5">&#64;ignore nodes</a></h3>
<p>Leo ignores any subtree of an <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> tree whose headline starts with <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt>.</p>
<p>You can use several other kinds of nodes to cause Leo to ignore parts of  an <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> tree:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">&#64;if</span></tt> <em>expression</em></p>
<p>A node whose headline starts with <tt class="docutils literal"><span class="pre">&#64;if</span></tt> <em>expression</em> acts like an organizer node if the expression evaluates to True,
otherwise acts like an <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> node.
If the expression is empty the body text should contain a script that will be evaluated (in an empty context).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">&#64;ifplatform</span></tt> <em>platform-name</em></p>
<p>Same as <tt class="docutils literal"><span class="pre">&#64;if</span> <span class="pre">sys.platform</span> <span class="pre">==</span> <span class="pre">&quot;platform-name&quot;:</span></tt> except that it isn't necessary to import sys.</p>
</li>
</ul>
</div>
<div class="section" id="simple-settings-nodes">
<h3><a class="toc-backref" href="#id6">Simple settings nodes</a></h3>
<p>Simple settings nodes have headlines of the form:</p>
<pre class="literal-block">
&#64;&lt;type&gt; name = val
</pre>
<p>set the value of <tt class="docutils literal"><span class="pre">name</span></tt> to <tt class="docutils literal"><span class="pre">val</span></tt>, with the indicated type.</p>
<p>&lt;type&gt; may be one of the following:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr><td>&lt;type&gt;</td>
<td>Valid values</td>
</tr>
<tr><td>&#64;bool</td>
<td>True, False, 0, 1</td>
</tr>
<tr><td>&#64;color</td>
<td>A Tk color name or value, such as 'red' or 'xf2fddff' (without the quotes)</td>
</tr>
<tr><td>&#64;directory</td>
<td>A path to a directory</td>
</tr>
<tr><td>&#64;float</td>
<td>A floating point number of the form nn.ff.</td>
</tr>
<tr><td>&#64;int</td>
<td>An integer</td>
</tr>
<tr><td>&#64;ints[list]</td>
<td>An integer (must be one of the ints in the list).
Example: &#64;ints meaningOfLife[0,42,666]=42</td>
</tr>
<tr><td>&#64;keys[name]</td>
<td>Gives a name to a set of bindings for the Check Bindings script in leoSettings.leo.</td>
</tr>
<tr><td>&#64;path</td>
<td>A path to a directory or file</td>
</tr>
<tr><td>&#64;ratio</td>
<td>A floating point number between 0.0 and 1.0, inclusive.</td>
</tr>
<tr><td>&#64;string</td>
<td>A string</td>
</tr>
<tr><td>&#64;strings[list]</td>
<td>A string (must be one of the strings in the list).
Example: &#64;strings tk_relief['flat','groove','raised']='groove'</td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: For a list of Tk color specifiers see:</p>
<ul class="simple">
<li><a class="reference" href="http://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm">http://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm</a></li>
<li><a class="reference" href="http://www.tcl.tk/man/tcl8.4/TkLib/GetColor.htm">http://www.tcl.tk/man/tcl8.4/TkLib/GetColor.htm</a></li>
</ul>
<p><strong>Important</strong>: you can use the show-colors minibuffer command to guide you in making these settings.</p>
</div>
<div class="section" id="complex-settings-nodes">
<h3><a class="toc-backref" href="#id7">Complex settings nodes</a></h3>
<p>Complex settings nodes have headlines of the form:</p>
<pre class="literal-block">
&#64;&lt;type&gt; description
</pre>
<p>The type may be one of the following:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<tbody valign="top">
<tr><td>&lt;type&gt;</td>
<td>Valid values</td>
</tr>
<tr><td>&#64;buttons</td>
<td>Child &#64;button nodes create global buttons</td>
</tr>
<tr><td>&#64;enabled-plugins</td>
<td>Body text contains a list of enabled plugins</td>
</tr>
<tr><td>&#64;font</td>
<td>Body text contains a font description</td>
</tr>
<tr><td>&#64;menus</td>
<td>Child &#64;menu and &#64;item nodes create menus and menu items.</td>
</tr>
<tr><td>&#64;mode [name]</td>
<td>Body text contains a list of shortcut specifiers.</td>
</tr>
<tr><td>&#64;recentfiles</td>
<td>Body text contains a list of file paths.</td>
</tr>
<tr><td>&#64;shortcuts</td>
<td>Body text contains a list of shortcut specifies.</td>
</tr>
</tbody>
</table>
<p>The actual settings are specified in the body text.  At present, there are seven kinds of complex settings nodes:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">&#64;buttons</span></tt></p>
<p><strong>New in Leo 4.4.4</strong>: All &#64;buttons tree in a settings file defines global buttons that
are created in the icon area of all .leo files.
You define &#64;button nodes in the &#64;buttons tree as usual.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">&#64;data</span></tt></p>
<p><strong>New in Leo 4.4.5</strong>: The body text contains a list of strings, one per line.
Lines starting with '#' are ignored.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">&#64;enabled-plugins</span></tt></p>
<p><strong>New in Leo 4.4.3</strong>: The body text of the &#64;enabled plugins node contains a list of enabled plugins.
This body text is treated exactly as the contents of the pluginsManager.txt file.
Notes:</p>
<blockquote>
<ol class="upperalpha simple">
<li>Leo attempts to load all plugins every time an &#64;enabled-plugins node is seen.
If the plugin has already been loaded, Leo silently ignores the
request to re-enable the plugin.
Leo never attempts to disable a plugin while processing enabled plugin
strings. Thus, plugins enabled in an &#64;enabled-plugins node in leoSettings.leo
<em>will</em> be enabled regardless of the contents of any other &#64;enabled-plugins node.</li>
<li>Leo will read the pluginsManager.txt file only if no &#64;enabled-plugins node is
found. The pluginsManager.txt file will no longer be part of the Leo
distribution. Instead, the default plugins will be enabled in an &#64;enabled-plugins
node in leoSettings.leo.</li>
<li>g.app.gui.getEnabledPlugins contains the last value last processed &#64;enabled-plugins node, or the
contents of the first pluginsManager.txt file encountered.</li>
</ol>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">&#64;font</span></tt></p>
<p>The body text contains a list of settings for a font.  For example:</p>
<pre class="literal-block">
body_text_font_family = Courier New
body_text_font_size = None
body_text_font_slant = None
body_text_font_weight = None
</pre>
<p><strong>Important</strong>: you can use the show-fonts minibuffer command to guide you in making these settings.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">&#64;menus</span></tt></p>
<p><strong>New in Leo 4.4.4</strong>: Leo creates its menus from the &#64;menu and &#64;item nodes in the &#64;menus tree.
Within &#64;menus trees, &#64;menu nodes create menus and &#64;item nodes create menu items.</p>
<p>The menu name always follows &#64;menu. If the menu name is 'Plugins', Leo will
create the Plugins menu and populate the menu by calling the
'create-optional-menus' hook. This creates the Plugins menu as usual. Nested
&#64;menu nodes define submenus.</p>
<p>The command name follows &#64;item. If the body text of an &#64;item node exists, this
body text is the menu name. Otherwise, the menu name is the command name.
However, if the command name starts with a '*', hyphens are removed from the
menu name. Menu names and command names may contain a single ampersand (&amp;). If
present, the following character is underlined in the name. If the command
name in an &#64;item node is just a hyphen (-), the item represents a menu
separator.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">&#64;mode</span></tt> <em>&lt;mode name&gt;</em></p>
<p>The body text contains a list of shortcut specifiers.
<tt class="docutils literal"><span class="pre">&#64;mode</span></tt> nodes work just like <tt class="docutils literal"><span class="pre">&#64;shortcuts</span></tt> nodes,
but in addition they have the side effect of creating the <tt class="docutils literal"><span class="pre">enter-&lt;mode</span> <span class="pre">name&gt;-mode</span></tt> command.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">&#64;recentfiles</span></tt></p>
<p>The body text contains a list of paths of recently opened files, one path per line.
Leo writes the list of recent files to <tt class="docutils literal"><span class="pre">.leoRecentFiles.txt</span></tt> in Leo's <tt class="docutils literal"><span class="pre">config</span></tt> directory,
again one file per line.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">&#64;shortcuts</span></tt></p>
<p>The body text contains a list of shortcut specifiers.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="input-modes">
<h2><a class="toc-backref" href="#id8">Input modes</a></h2>
<p>Leo now allows you to specify input modes. You enter mode <tt class="docutils literal"><span class="pre">x</span></tt> with the
<tt class="docutils literal"><span class="pre">enter-x-mode</span></tt> command. The purpose of a mode is to create different bindings
for keys within a mode. Often plain keys are useful in input modes.</p>
<p>You can specify modes with <tt class="docutils literal"><span class="pre">&#64;mode</span></tt> nodes in leoSettings.leo. <tt class="docutils literal"><span class="pre">&#64;mode</span></tt> nodes work
just like <tt class="docutils literal"><span class="pre">&#64;shortcuts</span></tt> nodes, but in addition they have the side effect of
creating the <tt class="docutils literal"><span class="pre">enter-&lt;mode</span> <span class="pre">name&gt;-mode</span></tt> command.</p>
<p>Notes:</p>
<ul class="simple">
<li>You can exit any mode using the <tt class="docutils literal"><span class="pre">keyboard-quit</span></tt> (Control-g) command. This is the
<strong>only</strong> binding that is automatically created in each mode. All other bindings
must be specified in the <tt class="docutils literal"><span class="pre">&#64;mode</span></tt> node. In particular, the bindings specified in
&#64;shortcuts nodes are <strong>not</strong> in effect in mode (again, except for the
keyboard-quit binding).</li>
<li>Leo supports something akin to tab completion within modes: if you type a key
that isn't bound in a mode a 'Mode' tab will appear in the log pane. This tab
shows all the keys that you can type and the commands to which they are bound.
The mode-help command does the same thing.</li>
<li><tt class="docutils literal"><span class="pre">&#64;shortcuts</span></tt> nodes specify the bindings for what might be called the 'top-level'
mode. These are the bindings in effect when no internal state is present, for
example, just after executing the keyboard-quit command.</li>
<li>The <tt class="docutils literal"><span class="pre">top_level_unbound_key_action</span></tt> setting determines what happens to
unbound keys in the top-level mode. Leo ignores unbound keys in all other modes.
The possibilities are 'insert', 'replace' and 'ignore'.</li>
<li>The <tt class="docutils literal"><span class="pre">set-insert-mode</span></tt>, <tt class="docutils literal"><span class="pre">set-overwrite-mode</span></tt> and <tt class="docutils literal"><span class="pre">set-ignore-mode</span></tt>
commands alter what happens to unbound keys in the top-level mode.</li>
</ul>
<p>With all these options it should be possible to emulate the keyboard behavior of any other editor.</p>
</div>
<div class="section" id="adding-extensible-attributes-to-nodes-and-leo-files">
<h2><a class="toc-backref" href="#id9">Adding extensible attributes to nodes and .leo files</a></h2>
<p>Leo's .leo file format is extensible. The basis for extending .leo files are the
<tt class="docutils literal"><span class="pre">t.unknownAttributes</span></tt> and <tt class="docutils literal"><span class="pre">v.unknownAttributes</span></tt> ivars of tnodes and vnodes,
or uA's for short. Leo translates between uA's and xml attributes in the
corresponding <tt class="docutils literal"><span class="pre">&lt;v&gt;</span></tt> and <tt class="docutils literal"><span class="pre">&lt;t&gt;</span></tt> elements in .leo files. Plugins may also use
<tt class="docutils literal"><span class="pre">v.tempAttributes</span></tt> or <tt class="docutils literal"><span class="pre">t.tempAttributes</span></tt> ivars to hold temporary information
that will <em>not</em> be written to the .leo file.</p>
<p>Collectively, these four kinds of ivars are called <strong>attribute ivars</strong>.
Attribute ivars must be Python dictionaries, whose keys are names of plugins and
whose values are <em>other</em> dictionaries, called <strong>inner dictionaries</strong>, for
exclusive use of each plugin. For example, a plugin named 'xyzzy' would set
<tt class="docutils literal"><span class="pre">t.unknownAttributes</span></tt> as follows:</p>
<pre class="literal-block">
# Create the uA if necessary.
if not hasattr(p.v.t,'unknownAttributes'):
    p.v.t.unknownAttributes = {}

# Get the inner dictionary for the 'xyzzy' plugin, creating it if necessary.
d = p.v.t.unknownAttributes.get('xyzzy',{})

# Set some values. These values must be picklable.
d ['duration'] = 5
d ['notes'] = &quot;This is a note.&quot;

# Update the uA.
p.v.t.unknownAttributes ['xyzzy'] = d

if hasattr(p.v.t,&quot;unknownAttributes&quot;):
    d = p.v.t.unknownAttributes.get(&quot;xyzzy&quot;,{})
    g.es(d['duration'])
    g.es(d['notes'])
</pre>
<p>Plugins would use similar code to create <tt class="docutils literal"><span class="pre">v.unknownAttributes</span></tt>,
<tt class="docutils literal"><span class="pre">t.tempAttributes</span></tt>, and <tt class="docutils literal"><span class="pre">v.tempAttributes</span></tt> ivars.</p>
<p><strong>Important</strong>: All members of inner dictionaries should be picklable: Leo
uses Python's Pickle module to encode all values in these dictionaries. Leo will
discard any attributes that can not be pickled. This should not be a major
problem to plugins. For example, instead of putting a tnode into these
dictionaries, a plugin could put the tnode's gnx (a string) in the dictionary.</p>
<p><strong>Note</strong>: Leo does <em>not</em> pickle members of inner dictionaries whose name (key) starts with <tt class="docutils literal"><span class="pre">str_</span></tt>.
The values of such members should be a Python string.
This convention allows strings to appear in .leo files in a more readable format.</p>
<p><strong>Important</strong>: Plugins must <em>not</em> use <tt class="docutils literal"><span class="pre">v.unknownAttributes</span></tt> inside <tt class="docutils literal"><span class="pre">&#64;thin</span></tt>
trees. Indeed Leo uses <strong>hidden machinery</strong> to write <tt class="docutils literal"><span class="pre">t.unknownAttributes</span></tt>.
Leo does <em>not</em> write <tt class="docutils literal"><span class="pre">t.unknownAttributes</span></tt> to thin derived files. Instead Leo
writes a representation of all <tt class="docutils literal"><span class="pre">t.unknownAttributes</span></tt> contained in the
<tt class="docutils literal"><span class="pre">&#64;thin</span></tt> tree to a special xml attribute called
<tt class="docutils literal"><span class="pre">descendentTnodeUnknownAttributes</span></tt> in the <tt class="docutils literal"><span class="pre">&lt;v&gt;</span></tt> element corresponding to the
<tt class="docutils literal"><span class="pre">&#64;thin</span></tt> node. Yes, this is complicated, but it works. Leo can <em>not</em> write
<tt class="docutils literal"><span class="pre">v.unknownAttributes</span></tt> in <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> trees because <strong>only tnodes have gnx's in
thin derived files</strong>. In effect, vnodes are anonymous.</p>
<p>Plugins that must associate attributes with vnodes should support only <tt class="docutils literal"><span class="pre">&#64;file</span></tt>
trees. A completely different alternative would be for the plugin to extend how
Leo reads and writes <tt class="docutils literal"><span class="pre">&lt;v&gt;</span></tt> elements in .leo files, but that would be much more
complicated than using <tt class="docutils literal"><span class="pre">t.unknownAttributes</span></tt></p>
<p>Here are the details about how Leo associates uA's with <tt class="docutils literal"><span class="pre">&lt;v&gt;</span></tt> and <tt class="docutils literal"><span class="pre">&lt;t&gt;</span></tt> elements in .leo files:</p>
<ul class="simple">
<li><strong>Native xml attributes</strong> are the attributes of <tt class="docutils literal"><span class="pre">&lt;v&gt;</span></tt> and <tt class="docutils literal"><span class="pre">&lt;t&gt;</span></tt> elements that are
known (treated specially) by Leo's read/write code.
The only native attribute of <tt class="docutils literal"><span class="pre">&lt;t&gt;</span></tt> elements is <tt class="docutils literal"><span class="pre">tx</span></tt>.
The native attributes of <tt class="docutils literal"><span class="pre">&lt;v&gt;</span></tt> elements are <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">t</span></tt>, <tt class="docutils literal"><span class="pre">vtag</span></tt>, <tt class="docutils literal"><span class="pre">tnodeList</span></tt>,
<tt class="docutils literal"><span class="pre">marks</span></tt>, <tt class="docutils literal"><span class="pre">expanded</span></tt> and <tt class="docutils literal"><span class="pre">descendentTnodeUnknownAttributes</span></tt>.
All other attributes of <tt class="docutils literal"><span class="pre">&lt;v&gt;</span></tt> and <tt class="docutils literal"><span class="pre">&lt;t&gt;</span></tt> elements are <strong>foreign xml attributes</strong>.</li>
<li>When reading a .leo file, Leo will create <tt class="docutils literal"><span class="pre">t.unknownAttributes</span></tt> or <tt class="docutils literal"><span class="pre">v.unknownAttributes</span></tt> ivars for
any <tt class="docutils literal"><span class="pre">tnode</span></tt> or <tt class="docutils literal"><span class="pre">vnode</span></tt> whose corresponding <tt class="docutils literal"><span class="pre">&lt;v&gt;</span></tt> or <tt class="docutils literal"><span class="pre">&lt;t&gt;</span></tt> element contains a foreign xml attribute.</li>
<li>When writing a file, Leo will write foreign xml attributes in <tt class="docutils literal"><span class="pre">&lt;v&gt;</span></tt> or <tt class="docutils literal"><span class="pre">&lt;t&gt;</span></tt> elements
if the corresponding  vnode or tnode contains an <tt class="docutils literal"><span class="pre">unknownAttributes</span></tt> ivar.</li>
<li>Leo performs the usual xml escapes on these strings when reading or writing the <tt class="docutils literal"><span class="pre">unknownAttributes</span></tt> ivars.</li>
</ul>
</div>
<div class="section" id="specifying-tk-options-using-leo-xresources">
<h2><a class="toc-backref" href="#id10">Specifying Tk options using .leo_xresources</a></h2>
<p>Leo looks for a file called <tt class="docutils literal"><span class="pre">.leo_xresources</span></tt> in the users home directory. If
found, Leo will pass that file to Tk's <tt class="docutils literal"><span class="pre">option_readfile</span></tt> method for the top
widget. This allows users to set Tk options.</p>
<hr class="docutils" />
<p><a class="reference" href="scripting.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="history.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
