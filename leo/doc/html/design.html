<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title>Chapter 6: Leo and Literate Programming</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document" id="chapter-6-leo-and-literate-programming">
<h1 class="title">Chapter 6: Leo and Literate Programming</h1>

<!-- rst3: filename: html\design.html -->
<p>This chapter discusses Leo's relationship with traditional <a class="reference external" href="glossary.html#literate-programming">literate programming</a>.</p>
<!-- .. contents:: -->
<!-- Relative links... -->
<div class="section" id="why-i-like-literate-programming">
<h1>Why I like Literate Programming</h1>
<p>The following paragraphs discuss the main benefits of traditional <a class="reference external" href="glossary.html#literate-programming">literate programming</a>.
<strong>Note</strong>: none of these benefits depends on printed output.</p>
<p><strong>Design and coding happen at the highest possible level</strong>.
The names of <a class="reference external" href="glossary.html#sections">sections</a> are constrained only by one's design skill, not by any
rules of language. You say what you mean, and that becomes both the design and
the code. You never have to simulate a concept because concepts become <a class="reference external" href="glossary.html#section-names">section
names</a>.</p>
<p><strong>The visual weight of code is separate from its actual length</strong>.
The visual weight of a <a class="reference external" href="glossary.html#section">section</a> is simply the length and complexity of the
<a class="reference external" href="glossary.html#section-name">section name</a>, regardless of how complex the actual definition of the section
is. The results of this separation are spectacular. No longer is one reluctant
to do extensive error handling (or any other kind of minutia) for fear that it
would obscure the essence of the program. Donald Knuth stresses this aspect of
literate programming and I fully agree.</p>
<p><strong>Sections show relations between snippets of code</strong>.
<a class="reference external" href="glossary.html#sections">Sections</a> can show and enforce relationships between apparently unrelated pieces
of code. Comments, macros or functions are other ways to indicate such
relationships, but often sections are ideal. Indeed, a natural progression is to
create sections as a matter of course. I typically convert a section to a
function only when it becomes apparent that a function's greater generality
outweighs the inconvenience of having to declare and define the function.</p>
<p><strong>Complex section names invite improvements</strong>.
A <a class="reference external" href="glossary.html#section-name">section name</a> is complex when it implies unwholesome dependencies between the
caller (user) of the section and the <a class="reference external" href="glossary.html#section">section</a> itself. Such section names tend to
be conspicuous, so that the programmer is lead to revise both the section name
and its purpose. Many times my attention has been drawn to a poorly conceived
section because I didn't like what its name implied. I have always been able to
revise the code to improve the design, either by splitting a section into parts
or be simplifying its relation to colleagues.</p>
<p><strong>Sections create a place for extensive comments</strong>.
One of the most surprising thing about <a class="reference external" href="glossary.html#literate-programming">literate programming</a> is how severely
traditional programming tends to limit comments. In a conventional program the
formatting of code must indicate structure, and comments obscure that
formatting. <a class="reference external" href="glossary.html#sections">Sections</a> in literate programming provide a place for lengthy
comments that do not clutter the code at the place the section is
<a class="reference external" href="glossary.html#referenced">referenced</a>.</p>
<p><strong>Section names eliminate mundane comments</strong>.
The <a class="reference external" href="glossary.html#section-name">section name</a> often says it all. The <a class="reference external" href="glossary.html#reference">reference</a> to the section says everything
that the user needs to know, and the section name at the point of definition
also eliminates the need for many comments.</p>
<p><strong>Sections create comments automatically</strong>.
A typical <a class="reference external" href="glossary.html#root-node">&#64;root node</a> starts out with something like:</p>
<pre class="literal-block">
&lt;&lt; includes for class x &gt;&gt;
&lt;&lt; private data for class x &gt;&gt;
&lt;&lt; private prototypes for class x &gt;&gt;
&lt;&lt; functions of class x &gt;&gt;
</pre>
<p>In the derived file there is a comment that looks like this:</p>
<pre class="literal-block">
/// &lt;&lt; includes for class x &gt;&gt;
</pre>
<p>It would be silly to write this comment by hand, though often programmers do
just that in order to have a place holder for a mark in the source file. With
<a class="reference external" href="glossary.html#literate-programming">literate programming</a> the situation is different: the comment indicates that the
code came from a particular <a class="reference external" href="glossary.html#section">section</a>; that is, the comment servers a real
purpose.</p>
<p><strong>Literate programming clarifies the shape of code</strong>.
These last several paragraphs have discussed comments in detail because the net
effect of &quot;putting comments where they belong&quot; is that comments don't clutter
the code. <a class="reference external" href="glossary.html#section-references">Section references</a> hide irrelevant detail, so larger-scale patterns
within functions (or declarations) become more apparent. Often just recasting
code into web format has created Aha's about my own code, with no special
attention to recoding or redesign! Recasting a function as a web raises the real
and apparent level of abstraction.</p>
<p><strong>I spend less time formatting code</strong>.
Formatting no longer has to indicate overall design; sections do that. I am less
obsessive about formatting code; it simply doesn't matter much whether different
sections are formatted consistently because the format of one section has no
effect on the look of other sections. Also, I don't worry about most line breaks
within <cite>documentation parts</cite>, or about adding comment delimiters.</p>
<p><strong>Literate programming creates a new design dimension</strong>.
<a class="reference external" href="glossary.html#sections">Sections</a> add a new dimension to the design and coding process. Choices about
what sections do, what they are named, what order they appear in, are choices in
a design space different from &quot;normal&quot; programming. This an abstract concept, to
be sure. However, the previous paragraphs are really a manifestation of
working in this new design space.</p>
</div>
<div class="section" id="how-leo-improves-literate-programming">
<h1>How Leo Improves Literate Programming</h1>
<p><a class="reference external" href="glossary.html#outlines">Outlines</a> add something brand new to traditional <a class="reference external" href="glossary.html#literate-programming">literate programming</a>, namely an
explicit mechanism for expressing structure at any level of detail, from largest
overall view to smallest detail. The following paragraphs elaborate on this theme.</p>
<p><strong>Outlines add context</strong>.
There are too many <a class="reference external" href="glossary.html#sections">sections</a> in conventional <cite>literate programming</cite>. It becomes
difficult to understand the relationships between sections. Using an <a class="reference external" href="glossary.html#outline">outline</a> to
express a literate programming instantly solves this problem. The programmer is
always aware of how sections are related.</p>
<p><strong>Outlines provide scope for commands</strong>.
<a class="reference external" href="glossary.html#outlines">Outlines</a> provide a convenient way of expressing the intended scope of commands.
For example, the <tt class="docutils literal"><span class="pre">Tangle</span></tt> command operates only on the presently selected <a class="reference external" href="glossary.html#tree">tree</a>.
The <tt class="docutils literal"><span class="pre">Extract</span> <span class="pre">Section</span></tt> command creates a new <a class="reference external" href="glossary.html#section">section</a> as the last <a class="reference external" href="glossary.html#child">child</a> of the
present <a class="reference external" href="glossary.html#node">node</a>.</p>
<p><strong>Clones create different views and focus attention</strong>.
<a class="reference external" href="glossary.html#clones">Clones</a> can create different views of the outline. An <a class="reference external" href="glossary.html#outline">outline</a> can contain many such views.
<a class="reference external" href="intro.html#clones-views">Clones &amp; views</a> discusses the implications of clones in detail.</p>
<p><strong>Outlines increase flexibility</strong>.
<a class="reference external" href="intro.html#good-style-and-bad-sections-vs-others">Organizer nodes</a> do not affect derived files in any way, but organizer nodes
often convey the most information about the structure and design of a large
system. Decoupling structure from content in this way is precisely what is
needed for flexibility: one can reorganize at will without worrying about
changing the meaning of the code.</p>
<p><strong>Outlines express hierarchy directly</strong>.
Hierarchy is often implicit in programming: for example, the grouping of
functions into files, or the organization of a single file as a set of
functions, etc. An <a class="reference external" href="glossary.html#outline">outline</a> directly expresses hierarchy. Many of Leo's <a class="reference external" href="commands.html">commands</a>
operate on the presently selected node. It is natural to apply operations on
selected <a class="reference external" href="glossary.html#node">node</a> of the outline.</p>
<p><strong>reStructuredText is much easier to use than CWEB markup.</strong>
Leo's <a class="reference external" href="glossary.html#rst3-plugin">rst3 plugin</a> makes it easy to use <a class="reference external" href="glossary.html#restructuredtext">reStructuredText</a> (rST) instead of <a class="reference external" href="glossary.html#cweb">CWEB</a>
markup. For most purposes, rST suffices, and rST is much easier to use and less
intrusive than <a class="reference external" href="glossary.html#cweb">CWEB</a>.</p>
<p><strong>Outlines create new design dimensions</strong>.
There are many ways to express a program as a Leo outline. Such choices are
important. They add clarity to the entire program. These are different <em>kind</em> of
choices. They simply can not be expressed at all in other editors. In other
words, such choices exist in a new design space.</p>
<p><strong>Leo improves tangling and adds untangling</strong>.
<a class="reference external" href="glossary.html#tangling">Tangling</a> and <a class="reference external" href="glossary.html#untangling">untangling</a> are fundamental operations of <a class="reference external" href="glossary.html#literate-programming">literate programming</a>.
Leo tangles and untangles files derived from <a class="reference external" href="glossary.html#file-trees">&#64;file trees</a> automatically. This
is an important convenience.</p>
</div>
<div class="section" id="how-leo-changes-the-notion-of-literate-programming">
<h1>How Leo Changes the Notion of Literate Programming</h1>
<p>Leo changes the theory and practice of literate programming as follows:</p>
<p><strong>Leo reduces the need for comments</strong>.
In particular, bridge or transition phrases are almost always unnecessary in a
Leo <a class="reference external" href="glossary.html#outline">outline</a>. One never needs to say something like, &quot;having just finished
with topic x, we turn now to topic y.&quot; Leo's outlines tend to be far less
chatty than flat literate programs.</p>
<p><strong>Leo reduces the need for printed listings</strong>.
Experience with the <tt class="docutils literal"><span class="pre">Weave</span></tt> command shows that an outline can easily become
unintelligible when printed, no matter how &quot;beautiful&quot; the typeset printout is.
No printed listing can be as clear as Leo's outline view.</p>
<p><strong>Leo reduces the need for indices and tables of contents</strong>.
You could say the entire outline is a table of contents. Moreover, <a class="reference external" href="glossary.html#sections">sections</a>
must always be defined in a descendant of the <a class="reference external" href="glossary.html#node">node</a> containing the <a class="reference external" href="glossary.html#section-reference">section
reference</a>, so there is very little need for an index.</p>
<p><strong>Leo shows that outline structure is more powerful than narrative.</strong>
Indeed, narrative style creates severe maintenance problems. The narrative is
soon forgotten, and when that happens it becomes difficult to find anything. The
few times I have tried narrative organization I soon regretted it: things just
weren't where I expected them to be.</p>
<p><strong>Leo shows that traditional literate programming encourages a too creative approach to programming.</strong>
A dictionary is a better model for programs than a novel. Leo's outlines provide
a more regular organization, while providing space for the most lengthy
discussions when those discussions are required.</p>
</div>
</div>
</body>
</html>
