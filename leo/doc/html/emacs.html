<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Chapter 18: Leo and Emacs</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\emacs.html -->
<!-- September 13, 2006 -->
<p><a class="reference" href="zodb.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="leoBridge.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="chapter-18-leo-and-emacs">
<h1><a class="toc-backref" href="#id1">Chapter 18: Leo and Emacs</a></h1>
<p>This chapter several topics relating to the Emacs editor.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference" href="#chapter-18-leo-and-emacs" id="id1" name="id1">Chapter 18: Leo and Emacs</a><ul>
<li><a class="reference" href="#controlling-leo-from-emacs-using-pymacs" id="id2" name="id2">Controlling Leo from Emacs using Pymacs</a></li>
<li><a class="reference" href="#functions-in-leopymacs-py" id="id3" name="id3">Functions in leoPymacs.py</a></li>
<li><a class="reference" href="#the-minibuffer" id="id4" name="id4">The minibuffer</a></li>
</ul>
</li>
</ul>
</div>
<!-- Links -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section" id="controlling-leo-from-emacs-using-pymacs">
<h2><a class="toc-backref" href="#id2">Controlling Leo from Emacs using Pymacs</a></h2>
<p>Leo's leoPymacs module is a simple 'server' for the <a class="reference" href="http://pymacs.progiciels-bpi.ca/index.html">pymacs</a> package.
Using pymacs and leoPymacs, <a class="reference" href="http://en.wikipedia.org/wiki/Emacs_Lisp">elisp</a> scripts in <a class="reference" href="http://www.xemacs.org/">Emacs</a> can open .leo files and execute <em>Python</em> scripts
as if they were executed inside Leo.
In particular, such scripts can use Leo's predefined c, g and p variables.
Thus, <em>Python</em> scripts running in Emacs can:</p>
<ul class="simple">
<li>Open any .leo file.</li>
<li>Access any part of the outline.</li>
<li>Change any part of the outline, including derived files,</li>
<li>Save .leo files.</li>
<li>Execute <em>any</em> Leo script.</li>
</ul>
<p>In short, you can now do from Emacs anything that you can do with Leo scripting inside Leo.</p>
<p>Here are step-by-step instructions for executing Python scripts in Emacs:</p>
<p><strong>Step 1. Install pymacs</strong></p>
<blockquote>
<p>The pymacs installation instructions should be clear enough.
A clarification is needed about two-way communication between Python and lisp scripts:
in truth, Python scripts can call the Pymacs.lisp function <em>only</em> if the Python script
was invoked from emacs.
Otherwise, calling Pymacs.lisp will hang the process making the call.
For example, executing the following script as an ordinary Leo script will hang Leo:</p>
<pre class="literal-block">
from Pymacs import lisp
print lisp(&quot;&quot;&quot;2+2&quot;&quot;&quot;) # Hangs
</pre>
</blockquote>
<p><strong>Step 2. Load the leoPymacs module from Emacs, creating a hidden Leo application</strong></p>
<blockquote>
<p>From inside Emacs, you load Leo's leoPymacs module as follows:</p>
<pre class="literal-block">
(pymacs-load &quot;leoPymacs&quot; &quot;leo-&quot;)
</pre>
<p>The call to pymacs-load is similar to <tt class="docutils literal"><span class="pre">'import</span> <span class="pre">leoPymacs</span> <span class="pre">as</span> <span class="pre">leo-'</span></tt> in Python.
The side effect of pymacs-load is to define the elisp function leo-x for every top-level function x in leoPymacs.py,
namely leo-dump, leo-get-app, leo-get-g, leo-get-script-result, leo-init, leo-open and leo-run-script.
The first call to any of these functions creates a <strong>hidden Leo application</strong>
in which .leo files may be loaded, modified and saved,
and in which Leo scripts may be executed.
This hidden Leo application uses Leo's nullGui class as its gui,
so Leo commands and Leo scripts that require a fully functional gui will not work as
expected in the hidden Leo application.
Steps 3 and 4 tell how to use this hidden Leo application.</p>
<p>pymacs-load works like a Python reload, so you can redefine leoPymacs.py while Emacs is running.
However, calling pymacs-load destroys the old hidden Leo application and creates a new one,
so typically you would want to call pymacs-load only once per Emacs session.
Like this:</p>
<pre class="literal-block">
(setq reload nil) ; change nil to t to force a reload.

(if (or reload (not (boundp 'leoPymacs)))
    (setq leoPymacs (pymacs-load &quot;leoPymacs&quot; &quot;leo-&quot;))
    (message &quot;leoPymacs already loaded&quot;)
)
</pre>
</blockquote>
<p><strong>Step 3. From Emacs, open .leo files</strong></p>
<blockquote>
<p>Once we have loaded the leoPymacs module
we can open a .leo file as follows:</p>
<pre class="literal-block">
(setq c (leo-open fileName))
</pre>
<p>This binds the elisp <tt class="docutils literal"><span class="pre">c</span></tt> variable to the Leo commander created by opening fileName.
fileName should be the full path to a .leo file.
In the next step we will use this <tt class="docutils literal"><span class="pre">c</span></tt> variable to execute <em>Leo</em> scripts in the
context of an open Leo outline.</p>
<p>Sometimes we want to execute a Leo script before opening any Leo commanders.
For example, we might want to compute the fileName passed to leo-open.
leo-run-script allows the <tt class="docutils literal"><span class="pre">c</span></tt> argument to be nil,
in which case leo-run-script creates a dummy commander in which to run the script.
For example, the following script calls <tt class="docutils literal"><span class="pre">g.os_path_join</span></tt> and <tt class="docutils literal"><span class="pre">g.os_path_abspath</span></tt>:</p>
<pre class="literal-block">
(setq script &quot;g.app.scriptResult =
    g.os_path_abspath(g.os_path_join(
        g.app.loadDir,'..','test','ut.leo'))&quot;
)

(setq fileName (leo-run-script nil script))
</pre>
<p>leo-run-script returns the value of <tt class="docutils literal"><span class="pre">g.app.scriptResult</span></tt>
As shown above, Python scripts may set <tt class="docutils literal"><span class="pre">g.app.scriptResult</span></tt> to indicate their result.
elisp scripts can also get <tt class="docutils literal"><span class="pre">g.app.scriptResult</span></tt> using leo-script-result.
Note that the Python script may span multiple lines.</p>
</blockquote>
<p><strong>Step 4. From Emacs, execute Leo (Python) scripts</strong></p>
<blockquote>
<p>From emacs we can execute a Python script <strong>as if</strong> it were executed in an
open Leo outline.
Suppose aLeoScript is an <strong>elisp</strong> string containing a Leo (Python) script.
We can execute that script in the hidden Leo application as follows:</p>
<pre class="literal-block">
(leo-run-script c aLeoScript)
</pre>
<p>For example:</p>
<pre class="literal-block">
(setq c (leo-open fileName)
(csetq script &quot;print 'c',c,'h',c.currentPosition().h&quot;)
(leo-run-script c script)
</pre>
</blockquote>
<p>Putting this all together, we get:</p>
<pre class="literal-block">
; Step 1: load leoPymacs if it has not already been loaded.
(setq reload nil)
(if (or reload (not (boundp 'leoPymacs)))
    (setq leoPymacs (pymacs-load &quot;leoPymacs&quot; &quot;leo-&quot;))
    (message &quot;leoPymacs already loaded&quot;)
)

; Step 2: compute the path to leo/test/ut.leo using a Leo script.
(setq script
    &quot;g.app.scriptResult = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test','ut.leo'))&quot;
)
(setq fileName (leo-run-script nil script))

; Step 3: execute a script in ut.leo.
(setq c (leo-open fileName))
(setq script &quot;print 'c',c.shortFileName() ,'current:',c.currentPosition().h&quot;)
(leo-run-script c script)
</pre>
</div>
<div class="section" id="functions-in-leopymacs-py">
<h2><a class="toc-backref" href="#id3">Functions in leoPymacs.py</a></h2>
<p>The leoPymacs module is intended to be called from Emacs using pymacs.  It contains the following top-level functions:</p>
<ul>
<li><p class="first">get_app()</p>
<p>Returns the hidden app created by the leoPymacs.init function.</p>
</li>
<li><p class="first">dump(anyPythonObject)</p>
<p>Returns str(repr(anyPythonObject)).</p>
</li>
<li><p class="first">get_g()</p>
<p>Returns the leoGlobals module of the hidden app created by the leoPymacs.init function.</p>
</li>
<li><p class="first">get_script_result()</p>
<p>Returns g.app.scriptResult, where g.app is the hidden app.</p>
</li>
<li><p class="first">init()
Calls leo.run(pymacs=True) to create a hidden Leo application.
Later calls to open can open hidden Leo outlines that can be accessed via runScript.</p>
</li>
<li><p class="first">open(fileName)</p>
<p>Opens the .leo file given by fileName.
fileName must be the full path to a .leo file.
Returns the commander of the open Leo outline, or None if the outline could not be opened.</p>
</li>
<li><p class="first">run_script(c,script,p=None)</p>
<p>Executes a script in the context of a commander <tt class="docutils literal"><span class="pre">c</span></tt> returned by the leoPymacs.open.
c may be None, in which case a dummy commander is created in which to run the script.
In the executed script, p is set to c.currentPosition() if no p argument is specified.
Returns g.app.scriptResult, where g.app is the hidden app.</p>
</li>
</ul>
</div>
<div class="section" id="the-minibuffer">
<h2><a class="toc-backref" href="#id4">The minibuffer</a></h2>
<p>Leo's mini-buffer is a text area at the bottom of the body pane.
You use Leo's minibuffer like the Emacs mini-buffer to invoke commands by their so-called <em>long name</em>.
The following commands affect the minibuffer:</p>
<ul class="simple">
<li><strong>full-command</strong>: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a
full command name, then hit &lt;Return&gt; to execute the command. Tab completion
works, but not yet for file names.</li>
<li><strong>quick-command-mode</strong>: (default shortcut: Alt-x) Like Emacs Control-C. This mode is
defined in leoSettings.leo. It is useful for commonly-used commands.</li>
<li><strong>universal-argument</strong>: (default shortcut: Alt-u) Like Emacs Ctrl-u. Adds a repeat
count for later command. Ctrl-u 999 a adds 999 a's.</li>
<li><strong>keyboard-quit</strong>: (default shortcut: Ctrl-g) Exits any minibuffer mode and puts
the focus in the body pane.</li>
</ul>
<p>For example, to print a list of all commands type Alt-X print-commands &lt;Return&gt;.</p>
<hr class="docutils" />
<p><a class="reference" href="zodb.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="leoBridge.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
