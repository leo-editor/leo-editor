<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Chapter 4: Writing Programs in Leo</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\directives.html -->
<!-- August 28, 2005 -->
<p><a class="reference" href="outlines.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="commands.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="chapter-4-writing-programs-in-leo">
<h1><a class="toc-backref" href="#id1">Chapter 4: Writing Programs in Leo</a></h1>
<!-- External links... -->
<!-- Relative links... -->
<!-- WARNING: image targets may not have upper case letters! -->
<p>This chapter is a <em>reference guide</em> to computer programming with Leo.
This chapter does <em>not</em> teach you how to use Leo:
for that you should read <a class="reference" href="intro.html">Leo's tutorial</a>.
This chapter assumes you are thoroughly familiar with the terminology introduced in the tutorial.
<strong>Note</strong>: Are you <em>sure</em> you want to read this chapter?
It contains many details that are no interest to the average user of Leo.
I recommend using Leo for two weeks, or longer, before attempting this chapter.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference" href="#chapter-4-writing-programs-in-leo" id="id1" name="id1">Chapter 4: Writing Programs in Leo</a><ul>
<li><a class="reference" href="#overview-the-seven-ways-of-creating-derived-files" id="id2" name="id2">Overview: the seven ways of creating derived files</a></li>
<li><a class="reference" href="#overview-summary-of-directives" id="id3" name="id3">Overview: summary of directives</a></li>
<li><a class="reference" href="#reference-all-about-directives" id="id4" name="id4">Reference: all about directives</a><ul>
<li><a class="reference" href="#and-doc" id="id5" name="id5">&#64; and &#64;doc</a></li>
<li><a class="reference" href="#all" id="id6" name="id6">&#64;all</a></li>
<li><a class="reference" href="#c-and-code" id="id7" name="id7">&#64;c and &#64;code</a></li>
<li><a class="reference" href="#color-nocolor-and-killcolor" id="id8" name="id8">&#64;color, &#64;nocolor and &#64;killcolor</a></li>
<li><a class="reference" href="#comment" id="id9" name="id9">&#64;comment</a></li>
<li><a class="reference" href="#delims" id="id10" name="id10">&#64;delims</a></li>
<li><a class="reference" href="#encoding" id="id11" name="id11">&#64;encoding</a></li>
<li><a class="reference" href="#first" id="id12" name="id12">&#64;first</a></li>
<li><a class="reference" href="#ignore" id="id13" name="id13">&#64;ignore</a></li>
<li><a class="reference" href="#language" id="id14" name="id14">&#64;language</a></li>
<li><a class="reference" href="#last" id="id15" name="id15">&#64;last</a></li>
<li><a class="reference" href="#lineending" id="id16" name="id16">&#64;lineending</a></li>
<li><a class="reference" href="#others" id="id17" name="id17">&#64;others</a></li>
<li><a class="reference" href="#path" id="id18" name="id18">&#64;path</a></li>
<li><a class="reference" href="#pagewidth" id="id19" name="id19">&#64;pagewidth</a></li>
<li><a class="reference" href="#tabwidth" id="id20" name="id20">&#64;tabwidth</a></li>
<li><a class="reference" href="#raw-and-end-raw" id="id21" name="id21">&#64;raw and &#64;end_raw</a></li>
<li><a class="reference" href="#root-code-and-root-doc" id="id22" name="id22">&#64;root-code and &#64;root-doc</a></li>
<li><a class="reference" href="#verbose-terse-quiet-and-silent" id="id23" name="id23">&#64;verbose, &#64;terse, &#64;quiet and &#64;silent</a></li>
<li><a class="reference" href="#wrap-and-nowrap" id="id24" name="id24">&#64;wrap and &#64;nowrap</a></li>
</ul>
</li>
<li><a class="reference" href="#reference-the-seven-ways-of-creating-derived-files" id="id25" name="id25">Reference: the seven ways of creating derived files</a><ul>
<li><a class="reference" href="#auto" id="id26" name="id26">&#64;auto</a><ul>
<li><a class="reference" href="#perfect-import-checks" id="id27" name="id27">Perfect import checks</a></li>
<li><a class="reference" href="#commands-related-to-auto" id="id28" name="id28">Commands related to &#64;auto</a></li>
</ul>
</li>
<li><a class="reference" href="#thin-and-file" id="id29" name="id29">&#64;thin and &#64;file</a></li>
<li><a class="reference" href="#nosent" id="id30" name="id30">&#64;nosent</a></li>
<li><a class="reference" href="#asis-and-noref" id="id31" name="id31">&#64;asis and &#64;noref</a></li>
<li><a class="reference" href="#root" id="id32" name="id32">&#64;root</a><ul>
<li><a class="reference" href="#sections-and-section-definitions" id="id33" name="id33">Sections and section definitions</a></li>
<li><a class="reference" href="#tangling-root-trees-with-the-tangle-commands" id="id34" name="id34">Tangling &#64;root trees with the Tangle commands</a></li>
<li><a class="reference" href="#untangling-root-trees-with-the-untangle-commands" id="id35" name="id35">Untangling &#64;root trees with the Untangle commands</a></li>
</ul>
</li>
<li><a class="reference" href="#converting-root-trees-to-file-trees" id="id36" name="id36">Converting &#64;root trees to &#64;file trees</a></li>
</ul>
</li>
<li><a class="reference" href="#cweb-mode" id="id37" name="id37">CWEB mode</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview-the-seven-ways-of-creating-derived-files">
<h2><a class="toc-backref" href="#id2">Overview: the seven ways of creating derived files</a></h2>
<p>You can create derived files using seven kinds of directives.
Unlike most directives, these directives may only appear in headlines.</p>
<p>The first five,
<tt class="docutils literal"><span class="pre">&#64;auto</span></tt>, <tt class="docutils literal"><span class="pre">&#64;file-thin</span></tt>, <tt class="docutils literal"><span class="pre">&#64;file</span></tt>, <tt class="docutils literal"><span class="pre">&#64;file-nosent</span></tt>, <tt class="docutils literal"><span class="pre">&#64;file-noref</span></tt>, <tt class="docutils literal"><span class="pre">&#64;file-asis</span></tt>,
are collectively known as <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees.
The abbreviated forms are most common:
<tt class="docutils literal"><span class="pre">&#64;thin</span></tt>, <tt class="docutils literal"><span class="pre">&#64;file</span></tt>, <tt class="docutils literal"><span class="pre">&#64;nosent</span></tt>, <tt class="docutils literal"><span class="pre">&#64;noref</span></tt> and <tt class="docutils literal"><span class="pre">&#64;asis</span></tt>.
There is also a sixth directive: <tt class="docutils literal"><span class="pre">&#64;root</span></tt>.</p>
<p><strong>Important</strong>: You create the <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees by putting
<tt class="docutils literal"><span class="pre">&#64;thin</span></tt>, <tt class="docutils literal"><span class="pre">&#64;file</span></tt>, <tt class="docutils literal"><span class="pre">&#64;nosent</span></tt>, <tt class="docutils literal"><span class="pre">&#64;noref</span></tt> or <tt class="docutils literal"><span class="pre">&#64;asis</span></tt> (or the long forms) in a <em>headline</em>.
In contrast, you create <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees by putting the <tt class="docutils literal"><span class="pre">root</span></tt> directive in <em>body text</em>.
The term 'directive' usually refers to a construct in Leo's body text.
In this chapter <em>I'll stretch the term</em> to include all 10 <tt class="docutils literal"><span class="pre">&#64;file</span></tt> forms,
as well as the true <tt class="docutils literal"><span class="pre">&#64;root</span></tt> directive.
Here are the six ways of creating derived files:</p>
<dl class="docutils">
<dt>&#64;auto</dt>
<dd>Import the derived file when Leo reads an outline.
See <a class="reference" href="#auto">&#64;auto</a> for full details.</dd>
<dt>&#64;thin</dt>
<dd>Use this unless you have a good reason not to.
It is the 'state-of-the-art' in derived files.
This form is easy to use and is cvs friendly.
Using <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> reduces the size of .leo files,
and saves all essential information in the derived file.
<tt class="docutils literal"><span class="pre">&#64;all</span></tt> directives are valid only in <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> trees.</dd>
<dt>&#64;file</dt>
<dd>This was the old 'state-of-the-art' directive.
There is not much reason to use it now,
except that its sentinels are more readable than <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> sentinels.
However, <tt class="docutils literal"><span class="pre">&#64;file</span></tt> is not nearly as cvs friendly as <tt class="docutils literal"><span class="pre">&#64;thin</span></tt>;
avoid <tt class="docutils literal"><span class="pre">&#64;file</span></tt> in cooperative environments.</dd>
<dt>&#64;nosent</dt>
<dd><p class="first">Use this directive only if you absolutely can not tolerate any sentinels in derived files.
Without sentinels, Leo can not update <tt class="docutils literal"><span class="pre">&#64;nosent</span></tt> trees from changes made to the derived files.
<em>Consider using &#64;thin even if you must produce derived files without sentinels</em>.
You can use <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> for most work, then change <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> to <tt class="docutils literal"><span class="pre">&#64;nosent</span></tt>
when showing your derived files to the world.</p>
<p class="last">The &#64;bool force_newlines_in_at_nosent_bodies setting
controls whether Leo writes a trailing newline if non-empty body text does not
end in a newline. The default is True. In effect, the default value of this
setting was False in previous versions of Leo.</p>
</dd>
<dt>&#64;noref</dt>
<dd>This directive produces derived files with minimal sentinels.
Section references are not allowed.
This is the least often used way of producing derived files.
Don't use this unless you are sure you must.</dd>
<dt>&#64;asis</dt>
<dd>This directive copies body text verbatim,
without even ensuring that newlines terminate each node.
Use this directive only when you must have complete control over every character of the derived file.</dd>
<dt>&#64;root</dt>
<dd>This directive is the most flexible, and the most difficult to use.
<strong>Note</strong>: <tt class="docutils literal"><span class="pre">&#64;root</span></tt> is a true directive: you put <tt class="docutils literal"><span class="pre">&#64;root</span></tt> in body text.
Historically, this was the first directive that created derived files.
It comes closest in spirit to traditional literate programming tools.
However, it is seldom necessary to suffer the drawbacks of using <tt class="docutils literal"><span class="pre">&#64;root</span></tt>.
It is certainly never necessary when programming in Python.
My advice is to avoid using <tt class="docutils literal"><span class="pre">&#64;root</span></tt> unless you have a compelling reason.</dd>
</dl>
<p>To complicate matters further,
you can use <a class="reference" href="http://www-cs-faculty.stanford.edu/~knuth/cweb.html">CWEB</a> markup instead of <a class="reference" href="http://www.eecs.harvard.edu/~nr/noweb/">noweb</a> markup.
See the section called <a class="reference" href="#cweb-mode">CWEB mode</a> for the details.
The choice between CWEB and noweb is independent of the directive is used to create derived files.</p>
</div>
<div class="section" id="overview-summary-of-directives">
<h2><a class="toc-backref" href="#id3">Overview: summary of directives</a></h2>
<p>Here is a brief summary of each directive:</p>
<ul class="simple">
<li><strong>&#64;</strong>
Starts a doc part. <tt class="docutils literal"><span class="pre">&#64;doc</span></tt> is a deprecated synonym.</li>
<li><strong>&#64;all</strong>
Copies <em>all</em> descendant nodes to the derived file.
Not valid in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees.</li>
<li><strong>&#64;auto</strong>
Imports the derived file every time Leo reads the outline.
The read-at-auto-nodes and write-at-auto-nodes commands can
be used to read and write and &#64;auto nodes.</li>
<li><strong>&#64;c</strong>
Starts a code part. <tt class="docutils literal"><span class="pre">&#64;code</span></tt> is a deprecated synonym.</li>
<li><strong>&#64;color</strong>, <strong>&#64;nocolor</strong> and <strong>&#64;killcolor</strong>
Control syntax coloring.</li>
<li><strong>&#64;comment</strong>
Sets comment delimiters in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> and <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> trees.</li>
<li><strong>&#64;delims</strong>
Sets comment delimiters in <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees.</li>
<li><strong>&#64;encoding</strong>
Sets the Unicode encoding used in derived files.</li>
<li><strong>&#64;first</strong>
Forces lines to appear before the first sentinel of a derived file.</li>
<li><strong>&#64;ignore</strong>
Causes Leo to ignore all or part of a derived file.
Works differently in <tt class="docutils literal"><span class="pre">&#64;file</span></tt> and <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees.</li>
<li><strong>&#64;language</strong>
Sets the language used for syntax coloring <strong>and</strong>
sets the comment delimiters used in sentinel lines and in doc parts.</li>
<li><strong>&#64;last</strong>
Forces lines to appear after the last sentinel of a derived file.</li>
<li><strong>&#64;lineending</strong>
Sets the line ending to be used in derived files.</li>
<li><strong>&#64;others</strong>
Copies all nodes <em>except</em> section definition nodes to the derived file.</li>
<li><strong>&#64;pagewidth</strong>
Sets the page width used to break doc parts into lines.</li>
<li><strong>&#64;path</strong>
Set the path to be appended to filenames.</li>
<li><strong>&#64;raw</strong> and <strong>&#64;end_raw</strong>
Delimit a section of 'raw' text.
Not valid in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> or <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> trees.</li>
<li><strong>&#64;root</strong>, <strong>&#64;root-code</strong> and <strong>&#64;root-code</strong>
Start an <tt class="docutils literal"><span class="pre">&#64;root</span></tt> tree.
The last two forms set the starting mode for body text.</li>
<li><strong>&#64;tabwidth</strong>
Sets the width of tabs.
Negative tab widths cause Leo to convert tabs to spaces.</li>
<li><strong>&#64;verbose</strong>, <strong>&#64;terse</strong>, <strong>&#64;quiet</strong> and <strong>&#64;silent</strong>
Set the verbosity of sentinels in files derived from <tt class="docutils literal"><span class="pre">&#64;root</span></tt>.</li>
<li><strong>&#64;wrap</strong> and <strong>&#64;nowrap</strong>
Enable or disable line wrapping the Leo's body pane.</li>
</ul>
</div>
<div class="section" id="reference-all-about-directives">
<h2><a class="toc-backref" href="#id4">Reference: all about directives</a></h2>
<p>The following sections give full details about each directive.
The directives listed here may appear in headlines or body text.</p>
<div class="section" id="and-doc">
<h3><a class="toc-backref" href="#id5">&#64; and &#64;doc</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;</span></tt> directive starts a doc part.
Doc parts continue until an <tt class="docutils literal"><span class="pre">&#64;c</span></tt> directive or the end of the body text.
For example:</p>
<pre class="literal-block">
&#64; This is a comment in a doc part.
Doc parts can span multiple lines.
The next line ends the doc part
&#64;c
</pre>
<p><tt class="docutils literal"><span class="pre">&#64;doc</span></tt> is a synonym for <tt class="docutils literal"><span class="pre">&#64;</span></tt>, but <tt class="docutils literal"><span class="pre">&#64;</span></tt> is preferred.</p>
</div>
<div class="section" id="all">
<h3><a class="toc-backref" href="#id6">&#64;all</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;all</span></tt> directive is valid only in <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> trees.
The <tt class="docutils literal"><span class="pre">&#64;all</span></tt> directive is similar to <tt class="docutils literal"><span class="pre">&#64;others</span></tt>, but it is less restrictive:
it dumps <em>all</em> nodes to the derived file, including <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> nodes and nodes that
in an <tt class="docutils literal"><span class="pre">&#64;others</span></tt> tree would be considered to be orphan nodes.</p>
<p>The <tt class="docutils literal"><span class="pre">&#64;all</span></tt> directive is required for files such as <tt class="docutils literal"><span class="pre">&#64;thin</span> <span class="pre">leoProjects.txt</span></tt> in <tt class="docutils literal"><span class="pre">LeoPy.leo</span></tt>.
<tt class="docutils literal"><span class="pre">leoProjects.txt</span></tt> contains so-called project nodes.
It doesn't have any meaning as a program file: it is simply a collection of unrelated data.
<tt class="docutils literal"><span class="pre">&#64;others</span></tt> would not work at all: it would complain about lots of orphan nodes.</p>
</div>
<div class="section" id="c-and-code">
<h3><a class="toc-backref" href="#id7">&#64;c and &#64;code</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;c</span></tt> directive ends a doc part and begins a code part.
<tt class="docutils literal"><span class="pre">&#64;code</span></tt> is a synonym for <tt class="docutils literal"><span class="pre">&#64;c</span></tt>, but <tt class="docutils literal"><span class="pre">&#64;c</span></tt> is preferred.</p>
<p>In <tt class="docutils literal"><span class="pre">&#64;root</span></tt> and <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> trees, the headline must contain a valid section name.</p>
</div>
<div class="section" id="color-nocolor-and-killcolor">
<h3><a class="toc-backref" href="#id8">&#64;color, &#64;nocolor and &#64;killcolor</a></h3>
<p>Syntax coloring is on by default in all body text.
Leo formats comments and documentation parts in red,
directives and C keywords in blue,
strings and character constants in gray and all other text in code parts in black.
The <tt class="docutils literal"><span class="pre">&#64;nocolor</span></tt> directive disables syntax coloring for the body text in which it appears.
No syntax coloring is done until an <tt class="docutils literal"><span class="pre">&#64;color</span></tt> directive re-enables syntax coloring.</p>
<p>If a node contains neither the <tt class="docutils literal"><span class="pre">&#64;color</span></tt> nor the <tt class="docutils literal"><span class="pre">&#64;nocolor</span></tt> directive
it may inherit the syntax coloring attribute from an ancestor.
The nearest ancestor that contains exactly one of the <tt class="docutils literal"><span class="pre">&#64;color</span></tt> or <tt class="docutils literal"><span class="pre">&#64;nocolor</span></tt> directives
will control the syntax coloring.
<strong>Ambiguous nodes</strong>, nodes containing both the <tt class="docutils literal"><span class="pre">&#64;color</span></tt> and <tt class="docutils literal"><span class="pre">&#64;nocolor</span></tt> directives,
never affect the coloring of their offspring.</p>
<p>The <tt class="docutils literal"><span class="pre">&#64;killcolor</span></tt> directive completely disables the colorizer for that node.
The result much faster syntax coloring of large body text.
As usual <tt class="docutils literal"><span class="pre">&#64;killcolor</span></tt> may itself be overridden in descendant nodes.
The differences between <tt class="docutils literal"><span class="pre">&#64;killcolor</span></tt> and <tt class="docutils literal"><span class="pre">&#64;nocolor</span></tt>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">&#64;nocolor</span></tt> suppresses coloring only until the next <tt class="docutils literal"><span class="pre">&#64;color</span></tt> directive.</li>
<li><tt class="docutils literal"><span class="pre">&#64;killcolor</span></tt> overrides <tt class="docutils literal"><span class="pre">&#64;nocolor</span></tt> and <tt class="docutils literal"><span class="pre">&#64;color</span></tt> directives.
Any node containing &#64;killcolor is unambiguously a <tt class="docutils literal"><span class="pre">&#64;killcolor</span></tt> node regardless of
whether that node also contains <tt class="docutils literal"><span class="pre">&#64;color</span></tt> or <tt class="docutils literal"><span class="pre">&#64;nocolor</span></tt> directives.</li>
</ul>
<p><strong>Note</strong>:
the <tt class="docutils literal"><span class="pre">&#64;color</span></tt>, <tt class="docutils literal"><span class="pre">&#64;nocolor</span></tt> and <tt class="docutils literal"><span class="pre">&#64;killcolor</span></tt> directives do not affect the <tt class="docutils literal"><span class="pre">Tangle</span></tt> commands in any way.
In particular, the <tt class="docutils literal"><span class="pre">Tangle</span></tt> commands will recognize section definitions as usual even
after an <tt class="docutils literal"><span class="pre">&#64;nocolor</span></tt> directive is seen.</p>
</div>
<div class="section" id="comment">
<h3><a class="toc-backref" href="#id9">&#64;comment</a></h3>
<p><strong>Note</strong>:
the <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> directive is deprecated:
you should use the <tt class="docutils literal"><span class="pre">&#64;language</span></tt> directive whenever possible.
However, sometimes using both <tt class="docutils literal"><span class="pre">&#64;language</span></tt> and <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> is useful.
For this to be effective the <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> directive should appear after the <tt class="docutils literal"><span class="pre">&#64;language</span></tt> directive (in outline order).</p>
<p>The <tt class="docutils literal"><span class="pre">Untangle</span></tt> command will not process an <tt class="docutils literal"><span class="pre">&#64;root</span></tt> or <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> node if
an <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> directive is in effect because
<tt class="docutils literal"><span class="pre">Untangle</span></tt> can't be sure of properly parsing a derived file if the language of the derived file isn't known.
It might be possible to assume some defaults in this case,
but that is not done at present and is not a high priority.
By default, the <tt class="docutils literal"><span class="pre">Tangle</span></tt> commands produces C-language comments.
Single-line comments generated during tangling start with <tt class="docutils literal"><span class="pre">///</span></tt>,
while documentation parts are surrounded by <tt class="docutils literal"><span class="pre">/*</span></tt> and <tt class="docutils literal"><span class="pre">*/</span></tt>.
The <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> directive allows you to use <tt class="docutils literal"><span class="pre">Tangle</span></tt> to produce shell and make files,
as well as source code for other programming languages.</p>
<p>The <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> directive may be followed by zero to three delimiters, separated by whitespace.
This directive sets the single-line comment delimiter and the opening and closing block comment delimiters as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<tbody valign="top">
<tr><td>&#64;comment</td>
<td>no args: restores the defaults to ///, /* and */</td>
</tr>
<tr><td>&#64;comment ///</td>
<td>1 arg: sets the single-line comment and clears the other delims.</td>
</tr>
<tr><td>&#64;comment /* */</td>
<td>2 args: sets the block comment delims; clears the single-line delim.</td>
</tr>
<tr><td>&#64;comment /// /* */</td>
<td>3 args: sets all three delimiters.</td>
</tr>
</tbody>
</table>
<p>If only one delimiter is given, Leo does not write any documentation parts while tangling.
If two delimiters are given, block-style comments are used instead of single-line comments.
For example, the <tt class="docutils literal"><span class="pre">&#64;comment</span> <span class="pre">{</span> <span class="pre">}</span></tt> directive could be used to tangle Pascal files.</p>
<p>The <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> directive is only recognized in <tt class="docutils literal"><span class="pre">&#64;root</span></tt>, <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> or <tt class="docutils literal"><span class="pre">&#64;file</span></tt> nodes,
and the <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> directive must precede the first section name or <tt class="docutils literal"><span class="pre">&#64;code</span></tt> directive.
An <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> directive in the body text of an <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> directive specifies the current global defaults.
An <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> directive in the body text of an <tt class="docutils literal"><span class="pre">&#64;root</span></tt> directive affects comments generated for one root only.
Comments in all other roots are governed by the global defaults.</p>
<p>Leo will convert underscores in the <tt class="docutils literal"><span class="pre">&#64;comment</span></tt> directives to significant spaces.  For example:</p>
<pre class="literal-block">
&#64;comment REM_
</pre>
<p>causes the comment delimiter to be &quot;REM &quot; (Note the trailing space).</p>
</div>
<div class="section" id="delims">
<h3><a class="toc-backref" href="#id10">&#64;delims</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;delims</span></tt> directive changes the comment strings used to mark sentinel lines.
This directive is often used to place Javascript text inside XML or HTML files.
The <tt class="docutils literal"><span class="pre">delims</span></tt> directive is not valid in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> or <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> trees.</p>
<p>The <tt class="docutils literal"><span class="pre">&#64;delims</span></tt> directive contains one or two delimiters, separated by whitespace.
If only one delim is present it delimits single-line comments.
If two delims are present they delimit block comments.
The <tt class="docutils literal"><span class="pre">&#64;delims</span></tt> directive can not be used to change the comment strings at the start of the derived file,
that is, the comment strings for the <tt class="docutils literal"><span class="pre">&#64;+leo</span></tt> sentinel and the initial <tt class="docutils literal"><span class="pre">&#64;+body</span></tt> and <tt class="docutils literal"><span class="pre">&#64;+node</span></tt> sentinels.</p>
<p>The <tt class="docutils literal"><span class="pre">&#64;delims</span></tt> directive inserts <tt class="docutils literal"><span class="pre">&#64;&#64;delims</span></tt> sentinels into the derived file.
The new delimiter strings continue in effect until the next <tt class="docutils literal"><span class="pre">&#64;&#64;delims</span></tt> sentinel in the derived file or
the end of the derived file.</p>
<p><strong>Note</strong>: Leo can not revert to previous delimiters automatically;
you must change back to previous delimiters using another <tt class="docutils literal"><span class="pre">&#64;delims</span></tt> directive. For example:</p>
<pre class="literal-block">
&#64;delims /* */
Javascript stuff
&#64;delims &lt;-- --&gt;
HTML stuff
</pre>
<p>Adding, deleting or changing <tt class="docutils literal"><span class="pre">&#64;&#64;delims</span></tt> sentinels will destroy Leo's ability to read the derived file.
Mistakes using the <tt class="docutils literal"><span class="pre">&#64;delims</span></tt> directive have no effect on Leo,
though such mistakes will thoroughly mess up a derived file as far as compilers,
HTML renderers, etc. are concerned.</p>
</div>
<div class="section" id="encoding">
<h3><a class="toc-backref" href="#id11">&#64;encoding</a></h3>
<p>You may use the <tt class="docutils literal"><span class="pre">&#64;encoding</span></tt> directive to specify the encoding used in a derived file.
You can't mix encodings in a single derived file.  For example:</p>
<pre class="literal-block">
&#64;encoding iso-8859-1
</pre>
<p>If the encoding used in a derived file is not &quot;utf-8&quot; it is represented in the &#64;+leo sentinel line, like this:</p>
<pre class="literal-block">
#&#64;+leo-encoding=iso-8859-1.
</pre>
<p>The <tt class="docutils literal"><span class="pre">utf-8</span></tt> encoding is used by default.
The <tt class="docutils literal"><span class="pre">utf-8</span></tt> encoding is a &quot;lossless&quot; encoding (it can represent all unicode code points),
so encoding and decoding to and from <tt class="docutils literal"><span class="pre">utf-8</span></tt> plain strings will never cause a problem.
When reading or writing a character not in a &quot;lossy&quot; encoding (such as <tt class="docutils literal"><span class="pre">iso-8859-1</span></tt>),
Leo converts such characters to <tt class="docutils literal"><span class="pre">'?'</span></tt> and issues a warning.</p>
</div>
<div class="section" id="first">
<h3><a class="toc-backref" href="#id12">&#64;first</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;first</span></tt> directive allows you to place lines at the very start of files derived from <tt class="docutils literal"><span class="pre">&#64;file</span></tt> nodes.
For example, the body text of <tt class="docutils literal"><span class="pre">&#64;file</span> <span class="pre">spam.py</span></tt> might be:</p>
<pre class="literal-block">
&#64;first #! /usr/bin/env python
</pre>
<p>The body text of <tt class="docutils literal"><span class="pre">&#64;file</span> <span class="pre">foo.perl</span></tt> might be:</p>
<pre class="literal-block">
&#64;first #/usr/bin/perl
</pre>
<p><tt class="docutils literal"><span class="pre">&#64;first</span></tt> directives are recognized only at the start of the body text of <tt class="docutils literal"><span class="pre">&#64;file</span></tt> nodes.
No text may precede <tt class="docutils literal"><span class="pre">&#64;first</span></tt> directives.
More than one <tt class="docutils literal"><span class="pre">&#64;first</span></tt> directive may exist, like this:</p>
<pre class="literal-block">
&#64;first #! /usr/bin/env python
&#64;first # more comments.
</pre>
<p>The <tt class="docutils literal"><span class="pre">&#64;first</span></tt> directive is not valid in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> or <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> trees.</p>
</div>
<div class="section" id="ignore">
<h3><a class="toc-backref" href="#id13">&#64;ignore</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> directive is valid <em>only</em> in the root node of <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees.
The <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> directive has several uses:</p>
<ul class="simple">
<li>In the root node of an <tt class="docutils literal"><span class="pre">&#64;file</span></tt> tree, <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> prevents Leo from writing the derived file.</li>
<li>In <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees, <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> excludes the <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> tree from the derived file.</li>
<li>Outside of <tt class="docutils literal"><span class="pre">&#64;file</span></tt> and <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees, <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> can be used by scripts.</li>
</ul>
</div>
<div class="section" id="language">
<h3><a class="toc-backref" href="#id14">&#64;language</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;language</span></tt> directive specifies the comment delimiters and string types used by the
<tt class="docutils literal"><span class="pre">Tangle</span></tt> and <tt class="docutils literal"><span class="pre">Untangle</span></tt> commands.
This directive over-rides the default specified in the settings dialog.</p>
<p>When the threading_colorizer plugin is enabled, the valid &#64;language directives are:</p>
<pre class="literal-block">
&#64;language x
</pre>
<p>where the leo/modes folder contains the file x.py.  When the threading_colorizier plugin is not enabled,
the 'old' colorizer is used and the valid <tt class="docutils literal"><span class="pre">&#64;language</span></tt> directives are:</p>
<pre class="literal-block">
&#64;language actionscript
&#64;language c
&#64;language c++
&#64;language cweb
&#64;language elisp
&#64;language html
&#64;language java
&#64;language latex
&#64;language objective-c
&#64;language pascal
&#64;language perl
&#64;language perlpod
&#64;language plain
&#64;language python
&#64;language rebol
&#64;language shell
&#64;language tcltk
</pre>
<p>Shell files have comments that start with <cite>#</cite>.
Case is ignored in the language specifiers, but not in the <tt class="docutils literal"><span class="pre">&#64;language</span></tt> itself.
Thus, the following are equivalent:</p>
<pre class="literal-block">
&#64;language html
&#64;language HTML
&#64;language hTmL
</pre>
<p>but the following is invalid:</p>
<pre class="literal-block">
&#64;LANGUAGE html
</pre>
</div>
<div class="section" id="last">
<h3><a class="toc-backref" href="#id15">&#64;last</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;last</span></tt> directive allows you to place lines at the very end of files derived from <tt class="docutils literal"><span class="pre">&#64;file</span></tt> nodes.
The <tt class="docutils literal"><span class="pre">&#64;last</span></tt> directive is recognized only at the end of body text of <tt class="docutils literal"><span class="pre">&#64;file</span></tt> nodes.
No text may follow <tt class="docutils literal"><span class="pre">&#64;last</span></tt> directives.
More than one <tt class="docutils literal"><span class="pre">&#64;last</span></tt> directive may exist.
For example, here is how a PHP file might be set up:</p>
<pre class="literal-block">
&#64;first &lt;?php
...
&#64;last ?&gt;
</pre>
</div>
<div class="section" id="lineending">
<h3><a class="toc-backref" href="#id16">&#64;lineending</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;lineending</span></tt> directive sets the line endings for individual derived files.
This directive will override the <tt class="docutils literal"><span class="pre">output_newline</span></tt> setting.
The <tt class="docutils literal"><span class="pre">&#64;lineending</span></tt> <em>never</em> affects the line endings in .leo files themselves:
.leo files must have consistent line endings!</p>
<p>The valid forms of the <tt class="docutils literal"><span class="pre">&#64;lineending</span></tt> directive are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr><td>&#64;lineending nl</td>
<td>The default, Linux.</td>
</tr>
<tr><td>&#64;lineending cr</td>
<td>Mac</td>
</tr>
<tr><td>&#64;lineending crlf</td>
<td>Windows</td>
</tr>
<tr><td>&#64;lineending lf</td>
<td>Same as 'nl', not recommended</td>
</tr>
<tr><td>&#64;lineending platform</td>
<td>Same as platform value for <tt class="docutils literal"><span class="pre">output_newline</span></tt> setting.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="others">
<h3><a class="toc-backref" href="#id17">&#64;others</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive refers to the body text of all nodes <em>except</em> section definition nodes.
The <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive places the body text of section definition nodes in the derived file in outline order.</p>
<p>An <tt class="docutils literal"><span class="pre">&#64;file</span></tt> tree may contain more than one <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive.
<tt class="docutils literal"><span class="pre">&#64;others</span></tt> directives that descend from other <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directives refer only to unnamed nodes that descend from them.
The <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive that occurs highest in the <tt class="docutils literal"><span class="pre">&#64;file</span></tt> tree refers to all other unnamed nodes.</p>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li>No node may contain more than one <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive.</li>
<li>No section definition node may intervene between an non-section definition node containing body text and
an <tt class="docutils literal"><span class="pre">&#64;others</span></tt> node.
In practice this is never a problem.</li>
<li>The <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive is not valid in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> or <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> trees.</li>
</ul>
</div>
<div class="section" id="path">
<h3><a class="toc-backref" href="#id18">&#64;path</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;path</span></tt> directives override the deprecated <tt class="docutils literal"><span class="pre">default_tangle_directory</span></tt> setting.</p>
<p>The form of the &#64;path directive is <tt class="docutils literal"><span class="pre">&#64;path</span></tt> <em>filename</em>,
where <em>filename</em> is taken to be everything following &#64;path to the end of the line.</p>
<p>If <em>filename</em> is an absolute filename the location of the derived file is specified only by the filename.
Otherwise, if <em>filename</em> is a relative filename, the location of the derived file is relative to:</p>
<ol class="arabic simple">
<li>the directory specified the applicable <tt class="docutils literal"><span class="pre">&#64;path</span></tt> directive, or</li>
<li>the &quot;Default Tangle Directory&quot; in the Settings dialog if no <tt class="docutils literal"><span class="pre">&#64;path</span></tt> directive is in effect, or</li>
<li>the directory in which the .leo file resides if the .leo file has ever been saved.</li>
</ol>
<p>An error occurs if no absolute path can be computed according to these rules,
or if <em>filename</em> does not exist.</p>
</div>
<div class="section" id="pagewidth">
<h3><a class="toc-backref" href="#id19">&#64;pagewidth</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;pagewidth</span></tt> directive overrides the <tt class="docutils literal"><span class="pre">page_width</span></tt> setting.
The form of the <tt class="docutils literal"><span class="pre">&#64;pagewidth</span></tt> directive is <tt class="docutils literal"><span class="pre">&#64;pagewidth</span></tt> <em>n</em>,
where n is a positive integer that indicates the width of tangled pages in columns.
For example:</p>
<pre class="literal-block">
&#64;pagewidth 100
</pre>
<p>This setting only affects how Leo reformats doc parts, and how the <tt class="docutils literal"><span class="pre">Tangle</span></tt> command outputs block comments.</p>
</div>
<div class="section" id="tabwidth">
<h3><a class="toc-backref" href="#id20">&#64;tabwidth</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;tabwidth</span></tt> directive overrides the <tt class="docutils literal"><span class="pre">tab_width</span></tt> setting.
The form of the <tt class="docutils literal"><span class="pre">&#64;tabwidth</span></tt> directive is <tt class="docutils literal"><span class="pre">&#64;tabwidth</span></tt> <em>n</em>,
where n is a positive integer that indicates the width of tabs in spaces.
For example:</p>
<pre class="literal-block">
&#64;tabwidth -4
</pre>
<p>Negative values cause Leo to convert tabs to blanks.</p>
</div>
<div class="section" id="raw-and-end-raw">
<h3><a class="toc-backref" href="#id21">&#64;raw and &#64;end_raw</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;raw</span></tt> and <tt class="docutils literal"><span class="pre">&#64;end_raw</span></tt> directives are valid only within <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees.
The <tt class="docutils literal"><span class="pre">&#64;raw</span></tt> directive starts a section of &quot;raw&quot; text.
The <tt class="docutils literal"><span class="pre">&#64;end_raw</span></tt> directive ends such a section, as does the end of body text.
No section references are recognized within raw text,
and no additional leading whitespace is generated within raw text when writing the derived file.</p>
</div>
<div class="section" id="root-code-and-root-doc">
<h3><a class="toc-backref" href="#id22">&#64;root-code and &#64;root-doc</a></h3>
<p>Leo allows you to choose whether body text in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees will start in code mode or doc mode by default.
<tt class="docutils literal"><span class="pre">&#64;root-doc</span></tt> <em>filename</em> and <tt class="docutils literal"><span class="pre">&#64;root-code</span></tt> <em>filename</em> directives
specify that body text is assumed to start in doc mode or code mode respectively.
The options (<tt class="docutils literal"><span class="pre">-doc</span></tt> and <tt class="docutils literal"><span class="pre">-code</span></tt>) must follow <tt class="docutils literal"><span class="pre">&#64;root</span></tt> immediately with no intervening whitespace.
In effect, <tt class="docutils literal"><span class="pre">&#64;root-code</span></tt> and <tt class="docutils literal"><span class="pre">&#64;root-doc</span></tt> are two new directives.</p>
<p>These <tt class="docutils literal"><span class="pre">&#64;root</span></tt> options override the <tt class="docutils literal"><span class="pre">at_root_bodies_start_in_doc_mode</span></tt> setting.
This setting affects only &#64;root trees without options.
Such &quot;plain&quot; <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees are now deprecated,
which only means that it is better style to use either <tt class="docutils literal"><span class="pre">&#64;root-code</span></tt> or <tt class="docutils literal"><span class="pre">&#64;root-doc</span></tt>.
The reason is simple:
the meaning of plain <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees will depend on the <tt class="docutils literal"><span class="pre">at_root_bodies_start_in_doc_mode</span></tt> setting.
It's better to be explicit.
By default, <tt class="docutils literal"><span class="pre">at_root_bodies_start_in_doc_mode</span> <span class="pre">=</span> <span class="pre">1</span></tt> for compatibility for old <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees.
I actually don't think this option is good for much;
I created it before I created <tt class="docutils literal"><span class="pre">&#64;root-doc</span></tt> and <tt class="docutils literal"><span class="pre">&#64;root-code</span></tt> settings,
and I decided it wouldn't hurt to leave it in.
Anyway, you now have complete flexibility about how <tt class="docutils literal"><span class="pre">&#64;root</span></tt> works,
and in particular you can make <tt class="docutils literal"><span class="pre">&#64;root</span></tt> work just like <tt class="docutils literal"><span class="pre">&#64;file</span></tt>.</p>
</div>
<div class="section" id="verbose-terse-quiet-and-silent">
<h3><a class="toc-backref" href="#id23">&#64;verbose, &#64;terse, &#64;quiet and &#64;silent</a></h3>
<p>The <tt class="docutils literal"><span class="pre">&#64;verbose</span></tt>, <tt class="docutils literal"><span class="pre">&#64;terse</span></tt>, <tt class="docutils literal"><span class="pre">&#64;quiet</span></tt> and <tt class="docutils literal"><span class="pre">&#64;silent</span></tt> directives determine
how the <tt class="docutils literal"><span class="pre">Tangle</span></tt> command outputs comments in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees.
Comments written by the user in code sections are always output.
These directives control only:
a) the comments containing doc sections and
b) sentinel comments that delimit the beginning and end of code sections.</p>
<p>When <tt class="docutils literal"><span class="pre">&#64;verbose</span></tt> is in effect <tt class="docutils literal"><span class="pre">Tangle</span></tt> outputs all comments.
When <tt class="docutils literal"><span class="pre">&#64;terse</span></tt> is in effect, <tt class="docutils literal"><span class="pre">Tangle</span></tt> outputs only those comments necessary for <tt class="docutils literal"><span class="pre">Untangle</span></tt> to work.
When <tt class="docutils literal"><span class="pre">&#64;silent</span></tt> is in effect Tangle adds no additional comments.
The <tt class="docutils literal"><span class="pre">&#64;quiet</span></tt> directive is like &#64;silent except that it does output leading sentinels as comments.
Like <tt class="docutils literal"><span class="pre">&#64;silent</span></tt>, <tt class="docutils literal"><span class="pre">&#64;quiet</span></tt> inhibits untangling.
<tt class="docutils literal"><span class="pre">&#64;verbose</span></tt> is the default.
If more than one of these directives appear in the same body text the &quot;most verbose&quot; of these options will be in effect.</p>
</div>
<div class="section" id="wrap-and-nowrap">
<h3><a class="toc-backref" href="#id24">&#64;wrap and &#64;nowrap</a></h3>
<p>By default, the <tt class="docutils literal"><span class="pre">body_pane_wraps</span></tt> setting controls whether body text wraps.
You may override this setting for a particular tree using the <tt class="docutils literal"><span class="pre">&#64;wrap</span></tt> and <tt class="docutils literal"><span class="pre">&#64;nowrap</span></tt> directives.
Only the first <tt class="docutils literal"><span class="pre">&#64;wrap</span></tt> or <tt class="docutils literal"><span class="pre">&#64;nowrap</span></tt> directive in a node has any effect.</p>
</div>
</div>
<div class="section" id="reference-the-seven-ways-of-creating-derived-files">
<h2><a class="toc-backref" href="#id25">Reference: the seven ways of creating derived files</a></h2>
<p>In the following table all terms in each row are equivalent.
The spelling in the first column is preferred:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="35%" />
<col width="40%" />
</colgroup>
<tbody valign="top">
<tr><td>&#64;asis</td>
<td>&#64;file-asis</td>
<td>&#64;silent</td>
</tr>
<tr><td>&#64;nosent</td>
<td>&#64;file-nosent</td>
<td>&#64;nosentinelsfile</td>
</tr>
<tr><td>&#64;noref</td>
<td>&#64;file-noref</td>
<td>&#64;rawfile</td>
</tr>
</tbody>
</table>
<p>You can get any combination of sentinels/no sentinels and references/no references using
<tt class="docutils literal"><span class="pre">&#64;auto</span></tt>, <tt class="docutils literal"><span class="pre">&#64;file</span></tt>, <tt class="docutils literal"><span class="pre">&#64;thin</span></tt>, <tt class="docutils literal"><span class="pre">&#64;nosent</span></tt>, <tt class="docutils literal"><span class="pre">&#64;noref</span></tt> and <tt class="docutils literal"><span class="pre">&#64;asis</span></tt> trees:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="30%" />
<col width="48%" />
</colgroup>
<tbody valign="top">
<tr><td>Type</td>
<td>Sentinels?</td>
<td>Sections and
&#64;others expanded?</td>
</tr>
<tr><td>&#64;asis</td>
<td>no</td>
<td>no</td>
</tr>
<tr><td>&#64;auto</td>
<td>no</td>
<td>no</td>
</tr>
<tr><td>&#64;file</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td>&#64;noref</td>
<td>yes</td>
<td>no</td>
</tr>
<tr><td>&#64;nosent</td>
<td>no</td>
<td>yes</td>
</tr>
<tr><td>&#64;root</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td>&#64;thin</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
<p>Leo can not update the outline from changes made from derived files unless those files contain sentinels.
The primary source for <tt class="docutils literal"><span class="pre">&#64;nosent</span></tt> and <tt class="docutils literal"><span class="pre">&#64;asis</span></tt> trees are the outlines from which those files were derived.</p>
<div class="section" id="auto">
<h3><a class="toc-backref" href="#id26">&#64;auto</a></h3>
<p>&#64;auto trees allow people to use Leo in collaborative environments without using
sentinels in the files Leo generates. In contrast to &#64;nosent, &#64;auto trees can
change when the corresponding file changes outside of Leo.</p>
<p>Leo will automatically recreate (import) all &#64;auto trees when reading a .leo
file, and will write all dirty &#64;auto trees when saving a .leo file. There are
two exceptions to this statement:</p>
<p>1. Leo will never read (import) or write an &#64;auto tree if
the root &#64;auto tree is under the influence of an &#64;ignore directive.</p>
<p>2. Saving a .leo file does not save &#64;auto nodes if a) they haven't been changed
or b) they do not contain a <strong>significant</strong> amount of informtion. An &#64;auto tree
contains a significant amount of information if it has  children or if the
root node contains more than 10 characters.</p>
<p>Leo creates &#64;auto trees by parsing the corresponding derived file. Parsers
create descendant nodes of the &#64;auto tree: one node for each class, method and
function in the derived file.</p>
<p>Parsers presently exist for C, elisp, Java, Javascript, Pascal, PHP, Python and xml. Leo
determines the language using the file's extension.  Notes:</p>
<ul class="simple">
<li>If no parser exists for a language, the entire body of the derived file is
copied to the body of the &#64;auto node.</li>
<li>Javascript regexps that look like section references cause problems, but that
can not be helped.</li>
<li>Use the &#64;data import_xml_tags setting in leoSettings.leo to specify the xml
tags that create outline nodes. By default, the <strong>organizer tags</strong> are html,
body, head, and div.</li>
</ul>
<div class="section" id="perfect-import-checks">
<h4><a class="toc-backref" href="#id27">Perfect import checks</a></h4>
<p>Leo performs several checks to ensure that the result of importing an external
file will be equivlant to the file that writing the &#64;auto tree would produce.</p>
<p>These checks can produces <strong>errors</strong> or <strong>warnings</strong>. Errors indicate a
potentially serious problem. Leo inserts an &#64;ignore directive in the &#64;auto tree
if any error is found. This &#64;ignore directive prevents the &#64;auto tree from
modifying the external file. If you &#64;ignore directive, a later write of the
&#64;auto tree will attempt to fix the problems that gave rise to the errors. There
are no guarantees however.</p>
<p>Before importing a file, Leo <strong>regularizes</strong> the leading whitespace of all lines
of the original source file. That is, Leo converts blanks to tabs or tabs to
blanks depending on the value of the &#64;tabwidth directive in effect for the &#64;auto
node. Leo also checks that the indentation of any non-blank line is not a
multiple of the indentation specified by the &#64;tabwidth dirctive in effect for
the &#64;auto node.</p>
<p>Leo cannot guarantee to reproduce the original source file exactly if problems
are discovered while regularizing leading whitespace. <strong>Strict languages</strong> are
languages such as Python for which leading whitespace must be preserved exactly
as it appears in the original source file. Problems during regularizing generate
errors for strict languages and warnings for non-strict languages.</p>
<p>After importing a file, Leo verifies that writing the &#64;auto node would create
<em>exactly</em> the same file as the original file. Such file comparison mismatches
generate errors unless the problem involves only leading whitespace for
non-strict languages. Whenever a mismatch occurs the first non-matching line is
printed.</p>
<p>File comparison mismatches can arise for several reasons:</p>
<ol class="arabic simple">
<li>Bugs in the import parsers. Please report any suspected bugs immediately.</li>
<li>Underindented lines in classes, methods or function. An <strong>underindented
line</strong> is a line that is indented less then the starting line of the class,
method or function in which it appears. Leo outlines can not represent such
lines exactly: every line of node implicitly has at least the indentation of
any unindented line of the node.</li>
</ol>
<p>Leo will issue a warning (not an error) for underindented Python comment lines.
Such lines can not change the meaning of Python programs.</p>
</div>
<div class="section" id="commands-related-to-auto">
<h4><a class="toc-backref" href="#id28">Commands related to &#64;auto</a></h4>
<p>Three commands in the <a class="reference" href="File:Read/Write">File:Read/Write</a> menu allow you to manually read and
write &#64;auto nodes from the presently selected outline. As always, an &#64;ignore
directive in the &#64;auto node or its ancestors will suppress any of these
commands:</p>
<ul class="simple">
<li>The Read &#64;auto Nodes (read-at-auto-nodes) command reads all &#64;auto nodes in the
presently selected outline. An &#64;ignore directive will suppress this import.</li>
<li>The Write &#64;auto Nodes (write-at-auto-nodes) command writes all &#64;auto nodes. An
&#64;ignore directive will suppress this import. Caution: the write will occur even
if Leo has not previously read the &#64;auto node.</li>
<li>The Write Dirty &#64;auto Nodes (write-dirty-at-auto-nodes) is the same as the
write-at-auto-nodes command, except that only changed &#64;auto trees are written.</li>
</ul>
<p>Most users will rarely use these explicit commands, because reading and writing
.leo files handles &#64;auto nodes well enough. However, you can use the
read-at-auto-nodes command to update &#64;auto nodes without having to reload the
.leo file.</p>
</div>
</div>
<div class="section" id="thin-and-file">
<h3><a class="toc-backref" href="#id29">&#64;thin and &#64;file</a></h3>
<p>In most respects <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> works just like <tt class="docutils literal"><span class="pre">&#64;file</span></tt>.
In fact, you can convert from <tt class="docutils literal"><span class="pre">&#64;file</span></tt> to <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> simply by opening an outline,
changing <tt class="docutils literal"><span class="pre">&#64;file</span></tt> to <tt class="docutils literal"><span class="pre">&#64;thin</span></tt>, and saving the outline.</p>
<p>Here are the differences between <tt class="docutils literal"><span class="pre">&#64;file</span></tt> and <tt class="docutils literal"><span class="pre">&#64;thin</span></tt>:</p>
<ul>
<li><p class="first">Leo does not save the information contained in the <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> tree in the .leo file.</p>
</li>
<li><p class="first">Files derived from <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> (&quot;thin&quot; derived files) contain all information needed to
recreate the <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> tree in the outline.
In particular, <tt class="docutils literal"><span class="pre">&#64;+node</span></tt> and <tt class="docutils literal"><span class="pre">&#64;-node</span></tt> sentinels use timestamps to uniquely identify nodes.</p>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">&#64;all</span></tt> directive is valid only in <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> trees.</p>
</li>
<li><p class="first">Thin derived files are much more friendly to cvs than files derived from <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees.
Developers only need to commit thin derived files to cvs.</p>
<p>The cvs repository contains <strong>reference</strong> .leo files.
These reference files should containing nothing but <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> nodes.
Reference files will change only when new derived files get added to the project.</p>
<p>Developers will use local copies of reference files for their own work.
For example, instead of using LeoPyRef.leo directly, I use a copy called <tt class="docutils literal"><span class="pre">LeoPy.leo</span></tt>.
My local copy can contain nodes other than <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> nodes.</p>
</li>
</ul>
</div>
<div class="section" id="nosent">
<h3><a class="toc-backref" href="#id30">&#64;nosent</a></h3>
<p>Leo writes <tt class="docutils literal"><span class="pre">&#64;nosent</span></tt> trees just as for <tt class="docutils literal"><span class="pre">&#64;thin</span></tt> trees,
but Leo writes no sentinels at all.</p>
<p>The &#64;bool force_newlines_in_at_nosent_bodies setting
controls whether Leo writes a trailing newline if non-empty body text does not
end in a newline. The default is True. In effect, the default value of this
setting was False in previous versions of Leo.</p>
</div>
<div class="section" id="asis-and-noref">
<h3><a class="toc-backref" href="#id31">&#64;asis and &#64;noref</a></h3>
<p>The only difference between <tt class="docutils literal"><span class="pre">&#64;asis</span></tt> and <tt class="docutils literal"><span class="pre">&#64;noref</span></tt> trees is that files derived from
<tt class="docutils literal"><span class="pre">&#64;noref</span></tt> contain sentinels while files derived from <tt class="docutils literal"><span class="pre">&#64;asis</span></tt> do not.</p>
<p>Leo creates files derived from <tt class="docutils literal"><span class="pre">&#64;noref</span></tt> and <tt class="docutils literal"><span class="pre">&#64;asis</span></tt> trees by
writing the body text of all nodes of the tree in outline order.
Leo writes the body text <em>as is</em>, without recognizing section definitions,
without expanding section references, and without treating directives specially in any way.
In particular, Leo copies all directives,
including <tt class="docutils literal"><span class="pre">&#64;</span></tt> or <tt class="docutils literal"><span class="pre">&#64;c</span></tt> directives, to the derived file as text.</p>
<p>Leo does recognize the <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> directive in the <em>ancestors</em> of <tt class="docutils literal"><span class="pre">&#64;noref</span></tt> or <tt class="docutils literal"><span class="pre">&#64;asis</span></tt> nodes,
so you may use the <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> directive as usual to prevent Leo from writing <tt class="docutils literal"><span class="pre">&#64;noref</span></tt> or <tt class="docutils literal"><span class="pre">&#64;asis</span></tt> trees.</p>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li>When writing <tt class="docutils literal"><span class="pre">&#64;noref</span></tt> trees,
Leo writes only the <tt class="docutils literal"><span class="pre">&#64;+leo</span></tt>, <tt class="docutils literal"><span class="pre">&#64;-leo</span></tt>, <tt class="docutils literal"><span class="pre">&#64;+node</span></tt>, <tt class="docutils literal"><span class="pre">&#64;-node</span></tt>, <tt class="docutils literal"><span class="pre">&#64;+body</span></tt> and <tt class="docutils literal"><span class="pre">&#64;-body</span></tt> sentinels.</li>
<li>Within <tt class="docutils literal"><span class="pre">&#64;asis</span></tt> trees only, if a headline starts with <tt class="docutils literal"><span class="pre">&#64;&#64;</span></tt>,
Leo writes everything in the headline following the <tt class="docutils literal"><span class="pre">&#64;&#64;</span></tt> just before the corresponding body text.</li>
<li>Files derived from <tt class="docutils literal"><span class="pre">&#64;asis</span></tt> trees contain <em>nothing</em> not contained in body text (or <tt class="docutils literal"><span class="pre">&#64;&#64;</span></tt> headlines).
In particular, if body text does not end in a newline,
the first line from the next node will concatenated to the last line of the preceding node.</li>
</ul>
</div>
<div class="section" id="root">
<h3><a class="toc-backref" href="#id32">&#64;root</a></h3>
<p>This section discusses all aspects of <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees.
You should carefully consider whether the extra flexibility afforded by
<tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees is worth the extra bother.
Indeed, <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees are much easier to use than <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees use less markup than <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees.
In particular, the &#64;others directive is valid only within <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees.</li>
<li>You must explicitly tangle and untangle <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees using the <tt class="docutils literal"><span class="pre">Tangle</span></tt> and <tt class="docutils literal"><span class="pre">Untangle</span></tt> commands.</li>
</ul>
<p>However, <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees are more flexible than <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees:</p>
<ul class="simple">
<li>Sections may be defined anywhere within <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees.
Moreover, the <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> directive expands the scope of section definitions in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees
so that a section may be referenced in several <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees.</li>
<li>The meaning of section definitions in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees are independent of their position within the tree.</li>
</ul>
<div class="section" id="sections-and-section-definitions">
<h4><a class="toc-backref" href="#id33">Sections and section definitions</a></h4>
<p>Just as with <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees, <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees may contain code parts and doc parts.
Code parts start with section definition lines (see below) or the <tt class="docutils literal"><span class="pre">&#64;c</span></tt> directive.
Doc parts start with <tt class="docutils literal"><span class="pre">&#64;</span></tt> directive.
Doc parts continue until the end of body text or until the next <tt class="docutils literal"><span class="pre">&#64;c</span></tt> or <tt class="docutils literal"><span class="pre">&#64;</span></tt> directive.</p>
<p>Body text in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees contain zero or more code and doc parts in any order.
The <tt class="docutils literal"><span class="pre">&#64;c</span></tt> directive starts a named code section if the node's headline starts with <tt class="docutils literal"><span class="pre">&lt;&lt;section</span> <span class="pre">name&gt;&gt;</span></tt>.
Otherwise, the <tt class="docutils literal"><span class="pre">&#64;c</span></tt> directive is invalid.</p>
<p><strong>Section definition lines</strong> are lines of the form:</p>
<pre class="literal-block">
&lt;&lt; section name&gt;&gt;=
</pre>
<p>(note the equal sign).
Such lines also start named code parts.
Named code parts in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees may be defined in several places.
The definition of a named code part is the concatenation of all code parts with the same name.
Body text that defines no code part is ignored.
At least one non-blank line must follow the section definition line;
empty sections are not allowed.</p>
<p>As in <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees, paired <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> characters on the same line always denote a section name,
even within comments and strings.
Thus, <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> characters that do not delimit a section name must be placed on separate lines.
If <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> are not paired on a line, they are treated as ordinary <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> characters.</p>
<p>Here is a typical example of body text within an &#64;root tree:</p>
<pre class="literal-block">
&#64; This method puts an open node sentinel for node v.
&lt;&lt;atFile methods&gt;&gt;=
def putOpenNodeSentinel(self,v):
    if v.isAtFileNode() and v != self.root:
        &lt;&lt; issue an error message &gt;&gt;
    else:
        s = self.nodeSentinelText(v)
        self.putSentinel(&quot;&#64;+node:&quot; + s)
</pre>
<p>Provided that the node's headline starts with &lt;&lt;atFile methods&gt;&gt;,
the example above is equivalent to:</p>
<pre class="literal-block">
&#64; This method puts an open node sentinel for node v.
&#64;c
def putOpenNodeSentinel(self,v):
    if v.isAtFileNode() and v != self.root:
        &lt;&lt; issue an error message &gt;&gt;
    else:
        s = self.nodeSentinelText(v)
        self.putSentinel(&quot;&#64;+node:&quot; + s)
</pre>
<p>We may not eliminate &#64;c directives in &#64;root trees.
If we convert the doc part to a comment we are left with:</p>
<pre class="literal-block">
&#64;c
# This method puts an open node sentinel for node v.
def putOpenNodeSentinel(self,v):
    if v.isAtFileNode() and v != self.root:
        &lt;&lt; issue an error message &gt;&gt;
    else:
        s = self.nodeSentinelText(v)
        self.putSentinel(&quot;&#64;+node:&quot; + s)
</pre>
<p>The following escape convention applies only in <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees.
Within a code part <tt class="docutils literal"><span class="pre">&#64;&#64;</span></tt> in the first column (and only in the first column) stands for a single <tt class="docutils literal"><span class="pre">&#64;</span></tt> sign.</p>
</div>
<div class="section" id="tangling-root-trees-with-the-tangle-commands">
<h4><a class="toc-backref" href="#id34">Tangling &#64;root trees with the Tangle commands</a></h4>
<p>Each <tt class="docutils literal"><span class="pre">&#64;root</span></tt> tree represents a single derived file.
<strong>Tangling</strong> is the process of creating derived files from <tt class="docutils literal"><span class="pre">&#64;file</span></tt> or <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees.
Leo tangles <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees automatically whenever an outline is saved.
The user must tangle <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees explicitly using one of the <tt class="docutils literal"><span class="pre">Tangle</span></tt> commands.</p>
<p>Leo creates derived files by expanding all section references in an <tt class="docutils literal"><span class="pre">&#64;root</span></tt> node.
Leo expands a section reference by substituting the code section itself for the section reference.
This is a recursive process:
the substituted code section may contain other code references which are themselves expanded, and so on.</p>
<p>The outline provides a natural way of organizing an sections as follows:</p>
<pre class="literal-block">
Place the definition of a section S in a child of
the node containing the reference to S.
</pre>
<p>If a section is referenced in more than one node,
I usually place its definition in a node containing all the nodes that refer to it.
Using this rule of thumb creates an outline whose structure mirrors the intrinsic organization of a program.</p>
<p>The <tt class="docutils literal"><span class="pre">Tangle</span></tt> command creates derived files from <tt class="docutils literal"><span class="pre">&#64;root</span></tt> node.
The <tt class="docutils literal"><span class="pre">&#64;root</span></tt> directive indicates which sections constitute an output file.
The text following a &#64;root directive forms the entire content of the file,
that is, after section references are expanded.
An outline can contain arbitrarily many <tt class="docutils literal"><span class="pre">&#64;root</span></tt> directives:
Leo's <tt class="docutils literal"><span class="pre">Tangle</span></tt> commands will create one output file for each.
The process of creating derived files is called &quot;tangling&quot; because
the code from the outline is rearranged to create the derived files.</p>
<p>For example, the following <tt class="docutils literal"><span class="pre">&#64;root</span></tt> section shows a typical way of specifying a header file <tt class="docutils literal"><span class="pre">xx.h</span></tt>:</p>
<pre class="literal-block">
&#64;root xx.h
#ifndef xx_defined
#define xx_defined
&lt;&lt; declarations of public constants of the xx class &gt;&gt;
&lt;&lt; declarations of public types of the xx class &gt;&gt;
&lt;&lt; declarations of public variables of the xx class &gt;&gt;
&lt;&lt; public prototypes of the xx class &gt;&gt;
#endif
</pre>
<p>The <tt class="docutils literal"><span class="pre">Tangle</span></tt> commands will create the file <tt class="docutils literal"><span class="pre">xx.h</span></tt> from this body text by expanding all the section references.
Incidentally, the introductory documentation will be included in the header file:
any text preceding the <tt class="docutils literal"><span class="pre">&#64;root</span></tt> directive is treated just like the doc part of a section definition.</p>
<p>As another example, the following shows a typical way of specifying the corresponding <tt class="docutils literal"><span class="pre">xx.c</span></tt> file:</p>
<pre class="literal-block">
&#64;root xx.c
&lt;&lt; public variables of the xx class &gt;&gt;
&lt;&lt; private types of the xx class &gt;&gt;
&lt;&lt; private variables of the xx class &gt;&gt;
&lt;&lt; private function prototypes of the xx class &gt;&gt;
&lt;&lt; methods of the xx class &gt;&gt;
</pre>
<p>There are three menu commands that tangle an outline: <tt class="docutils literal"><span class="pre">Tangle</span></tt>, <tt class="docutils literal"><span class="pre">Tangle</span> <span class="pre">All</span></tt> and <tt class="docutils literal"><span class="pre">Tangle</span> <span class="pre">Marked</span></tt>.
These commands are identical except for how much of the outline is tangled.
The <tt class="docutils literal"><span class="pre">Tangle</span></tt> command tangles only the selected portion of the outline,
the <tt class="docutils literal"><span class="pre">Tangle</span> <span class="pre">All</span></tt> command tangles the entire outline,
and the <tt class="docutils literal"><span class="pre">Tangle</span> <span class="pre">Marked</span></tt> command tangles only marked headlines.</p>
<p>The <tt class="docutils literal"><span class="pre">&#64;root</span></tt> directive has three forms.
All three forms mean exactly the same thing:</p>
<pre class="literal-block">
&#64;root filename
&#64;root &quot;filename&quot;
&#64;root &lt;filename&gt;
</pre>
<p>If <em>filename</em> is an absolute filename the location of the derived file is specified only by the filename.
Otherwise, if the <tt class="docutils literal"><span class="pre">&#64;root</span></tt> node contains a relative filename, the location of the derived file is relative to:</p>
<ol class="arabic simple">
<li>the directory specified by an <tt class="docutils literal"><span class="pre">&#64;path</span></tt> directive, or</li>
<li>the <tt class="docutils literal"><span class="pre">default_tangle_directory</span></tt> setting if no <tt class="docutils literal"><span class="pre">&#64;path</span></tt> directive is in effect, or</li>
<li>the directory in which the .leo resides if the .leo file has ever been saved.</li>
</ol>
<p>An error occurs if no absolute path can be computed according to these rules,
or if the filename or directory does not exist.</p>
<p>The scope of a definition is the tree in which the definition is known.
By default, <tt class="docutils literal"><span class="pre">Tangle</span></tt> commands look for section definitions only
in the suboutline of the <tt class="docutils literal"><span class="pre">&#64;root</span></tt> node being tangled.
That is, all sections are assumed to be defined either in the body text of the headline,
say h, containing the <tt class="docutils literal"><span class="pre">&#64;root</span></tt> directive, or in the body texts of the descendants of h.
The <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> directive explicitly indicates the scope of section definitions.
When a <tt class="docutils literal"><span class="pre">Tangle</span></tt> command encounters the <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> directive it treats the suboutline containing
the <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> command as the scope for all enclosed roots.
This ensures that the group of roots in the subtree use the same section definitions.</p>
<p>For example, suppose we have a tree organized as follows:</p>
<pre class="literal-block">
+ &#64;unit
        + &#64;root A
            sections in A
        + &#64;root B
            sections in B
</pre>
<p>The <tt class="docutils literal"><span class="pre">&#64;unit</span></tt> directive insures that
only sections defined in the unit can affect files A and B and
that all sections definitions in A and B are compatible with each other.</p>
<p>The <tt class="docutils literal"><span class="pre">Tangle</span></tt> commands ignore any tree containing an <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> directive.
This ensures that trees that contain cloned nodes or other subsidiary information
do not cause the tangle commands to issue spurious error messages.
It also ensures that a tree can never contribute a section definition to another part of the outline by mistake.</p>
</div>
<div class="section" id="untangling-root-trees-with-the-untangle-commands">
<h4><a class="toc-backref" href="#id35">Untangling &#64;root trees with the Untangle commands</a></h4>
<p>The <tt class="docutils literal"><span class="pre">Untangle</span></tt>, <tt class="docutils literal"><span class="pre">Untangle</span> <span class="pre">All</span></tt> and <tt class="docutils literal"><span class="pre">Untangle</span> <span class="pre">Marked</span></tt> commands are the
reverse of the corresponding <tt class="docutils literal"><span class="pre">Tangle</span></tt> commands.
They update one or more <tt class="docutils literal"><span class="pre">&#64;root</span></tt> nodes based on changes made to the corresponding derived files.</p>
<p>For example, suppose you create a new part of the outline and tangle it for the first time.
When you compile derived files for the first you are likely to get many syntax errors.
You could fix those errors in the outline and tangle the outline again, but there is a much easier way:
you fix the errors in the derived files using the compiler's editor,
then run the untangle command on the part of the outline that created the derived file.
The <tt class="docutils literal"><span class="pre">Untangle</span></tt> command updates the selected outline to match the changes in the derived files.
It's as simple as that.
By the way, the <tt class="docutils literal"><span class="pre">Untangle</span></tt> command marks all the nodes in the outline that it updates,
and you can examine all such nodes with the <tt class="docutils literal"><span class="pre">Go</span> <span class="pre">To</span> <span class="pre">Next</span> <span class="pre">Marked</span></tt> command in the <tt class="docutils literal"><span class="pre">Outline</span></tt> menu.</p>
<p>You cannot use <tt class="docutils literal"><span class="pre">Untangle</span></tt> to update doc parts, or leading comments in code parts or
&quot;trivial&quot; whitespace in code parts.
This is a limitation of the <tt class="docutils literal"><span class="pre">Untangle</span></tt> command that cannot be fixed;
<tt class="docutils literal"><span class="pre">Untangle</span></tt> has no way of knowing whether leading comments came from doc parts or are just leading comments.</p>
<p><tt class="docutils literal"><span class="pre">Untangle</span></tt> never changes the structure of an outline;
it never inserts, deletes or moves nodes.
Don't attempt to change the structure of an outline by modifying derived files; it won't work.
Also, never delete, move or alter the sentinel lines in derived files written by the <tt class="docutils literal"><span class="pre">Tangle</span></tt> command.
Such lines start with the comment delimiter followed by a section name.</p>
<p>If you change the section name in a sentinel line <tt class="docutils literal"><span class="pre">Untangle</span></tt> will not update the code in the outline
(with the old name) that generated the renamed section.
<tt class="docutils literal"><span class="pre">Untangle</span></tt> warns about sections that appear in a derived file but not in the outline.
<tt class="docutils literal"><span class="pre">Untangle</span></tt> has no trouble with changed section references in derived files;
it is only changed sentinel lines that cause problems.</p>
<p>Cloned nodes that generate code in several files may cause problems for <tt class="docutils literal"><span class="pre">Untangle</span></tt>.
If <tt class="docutils literal"><span class="pre">Untangle</span></tt> is run separately on these derived files,
<tt class="docutils literal"><span class="pre">Untangle</span></tt> will update all cloned nodes each time it is run,
so only the code in the last Untangle run will take effect.
Therefore, the safe way to update text in cloned nodes is to make the change in the .leo file rather than the derived files.</p>
</div>
</div>
<div class="section" id="converting-root-trees-to-file-trees">
<h3><a class="toc-backref" href="#id36">Converting &#64;root trees to &#64;file trees</a></h3>
<p>To convert an <tt class="docutils literal"><span class="pre">&#64;root</span></tt> tree to an <tt class="docutils literal"><span class="pre">&#64;file</span></tt> tree, choose the root of the tree to be converted,
then do the following in the Python window:</p>
<pre class="literal-block">
import c2py
c2py.leo1to2()
</pre>
<p>This script makes numerous changes throughout the tree.
It does not, however, change <tt class="docutils literal"><span class="pre">&#64;root</span></tt> to <tt class="docutils literal"><span class="pre">&#64;file</span></tt>, or insert the needed <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directives.
You must do that by hand.</p>
<p>To convert <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees to <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees by hand:</p>
<ol class="arabic simple">
<li>Change the <tt class="docutils literal"><span class="pre">&#64;root</span></tt> node to an <tt class="docutils literal"><span class="pre">&#64;file</span></tt> node.
That is, delete the <tt class="docutils literal"><span class="pre">&#64;root</span> <span class="pre">&lt;filename&gt;</span></tt> from the body text and insert <tt class="docutils literal"><span class="pre">&#64;file</span> <span class="pre">&lt;filename&gt;</span></tt> in the headline.
Typically, the root node contains a reference like <tt class="docutils literal"><span class="pre">&lt;&lt;methods</span> <span class="pre">of</span> <span class="pre">class</span> <span class="pre">x&gt;&gt;</span></tt> as the last body text.
Replace this reference with the <tt class="docutils literal"><span class="pre">&#64;others</span></tt> directive.
The expansion of &#64;others is all text that is not part of a section definition.</li>
<li>Add <tt class="docutils literal"><span class="pre">&#64;</span></tt> to the start of all doc parts.
Leo starts syntax coloring in code mode rather than doc mode,
so if a doc part starts body text it should start with <tt class="docutils literal"><span class="pre">&#64;</span></tt></li>
<li>Replace all section definition lines (like <tt class="docutils literal"><span class="pre">&lt;&lt;name&gt;&gt;=</span></tt>) by <tt class="docutils literal"><span class="pre">&#64;c</span></tt>.
This results in the node being added to the expansion of <tt class="docutils literal"><span class="pre">&#64;others</span></tt>.</li>
<li>Remove all unused code from the <tt class="docutils literal"><span class="pre">&#64;file</span></tt> tree.
Leo does not write derived files whose <tt class="docutils literal"><span class="pre">&#64;file</span></tt> trees contain orphan or <tt class="docutils literal"><span class="pre">&#64;ignore</span></tt> nodes.</li>
<li>Make sure that all nodes defining a section have a headline that starts with <tt class="docutils literal"><span class="pre">&lt;&lt;section&gt;&gt;</span></tt>.
This will typically be true when converting <tt class="docutils literal"><span class="pre">&#64;root</span></tt> trees that use the <tt class="docutils literal"><span class="pre">&#64;code</span></tt> directive.</li>
<li>If a section is referenced in more than one node (a rare occurrence in my code),
clone the defining node and move one clone under each referencing node.</li>
<li>If a node contains the definitions of several sections,
place each different definition in a different node.</li>
</ol>
</div>
</div>
<div class="section" id="cweb-mode">
<h2><a class="toc-backref" href="#id37">CWEB mode</a></h2>
<p>See <a class="reference" href="http://www-cs-faculty.stanford.edu/~knuth/cweb.html">CWEB</a> for a discussion of the CWEB language.
CWEB mode refers to how Leo tangles an outline when <tt class="docutils literal"><span class="pre">&#64;language</span> <span class="pre">cweb</span></tt> is in effect or
the <tt class="docutils literal"><span class="pre">cweb</span></tt> setting is in effect.
Leo treats <em>all</em> cweb code in cweb mode as unevaluated text.
That is, Leo treats cweb control codes, including
<tt class="docutils literal"><span class="pre">&#64;&lt;...&#64;&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&#64;&lt;..&#64;&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">&#64;c</span></tt>, <tt class="docutils literal"><span class="pre">&#64;</span></tt>, <tt class="docutils literal"><span class="pre">&#64;*</span></tt> and <tt class="docutils literal"><span class="pre">&#64;**</span></tt> as &quot;raw&quot; text within cweb mode.
Leo does <em>not</em> expand <em>cweb</em> section references when writing derived files in cweb mode.
However, Leo <em>does</em> expand <em>noweb</em> section references,
so you may use noweb sections to organize cweb files!
You can create <em>noweb</em> code and doc sections using the <tt class="docutils literal"><span class="pre">&#64;code</span></tt> and <tt class="docutils literal"><span class="pre">&#64;doc</span></tt> directives
in place of <tt class="docutils literal"><span class="pre">&#64;c</span></tt> and <tt class="docutils literal"><span class="pre">&#64;</span></tt> directives.</p>
<p>By default, cweb colors <tt class="docutils literal"><span class="pre">&#64;</span></tt>, <tt class="docutils literal"><span class="pre">&#64;*</span></tt> and <tt class="docutils literal"><span class="pre">&#64;**</span></tt> sections using the same syntax coloring as for <tt class="docutils literal"><span class="pre">LaTeX</span></tt>.
In addition, cweb colors <tt class="docutils literal"><span class="pre">C</span></tt> <tt class="docutils literal"><span class="pre">//</span></tt> and <tt class="docutils literal"><span class="pre">/*..*/</span></tt> comments using <tt class="docutils literal"><span class="pre">LaTeX</span></tt> coloring by default.
You may change these defaults using the
<tt class="docutils literal"><span class="pre">color_cweb_doc_parts_with_latex</span></tt> and <tt class="docutils literal"><span class="pre">color_cweb_comments_with_latex</span></tt> settings.</p>
<hr class="docutils" />
<p><a class="reference" href="outlines.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="commands.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
