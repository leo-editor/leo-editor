<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Chapter 17: Using ZODB with Leo</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\zodb.html -->
<!-- September 13, 2006 -->
<p><a class="reference" href="debuggers.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="emacs.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="chapter-17-using-zodb-with-leo">
<h1><a class="toc-backref" href="#id1">Chapter 17: Using ZODB with Leo</a></h1>
<p>This chapter discusses how to write Leo scripts that store and retrieve data using <a class="reference" href="http://www.zope.org/Wikis/ZODB/guide/zodb.html">ZODB</a>.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference" href="#chapter-17-using-zodb-with-leo" id="id1" name="id1">Chapter 17: Using ZODB with Leo</a><ul>
<li><a class="reference" href="#configuring-leo-to-use-zodb" id="id2" name="id2">Configuring Leo to use zodb</a></li>
<li><a class="reference" href="#initing-zodb" id="id3" name="id3">Initing zodb</a></li>
<li><a class="reference" href="#writing-data-to-zodb" id="id4" name="id4">Writing data to zodb</a></li>
<li><a class="reference" href="#defining-zodb-keys" id="id5" name="id5">Defining zodb keys</a></li>
<li><a class="reference" href="#reading-data-from-zodb" id="id6" name="id6">Reading data from zodb</a></li>
<li><a class="reference" href="#about-connections" id="id7" name="id7">About connections</a></li>
<li><a class="reference" href="#convenience-routines" id="id8" name="id8">Convenience routines</a><ul>
<li><a class="reference" href="#g-init-zodb-pathtozodbstorage-verbose-true" id="id9" name="id9">g.init_zodb (pathToZodbStorage,verbose=True)</a></li>
<li><a class="reference" href="#v-detach" id="id10" name="id10">v.detach()</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<!-- External links... -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section" id="configuring-leo-to-use-zodb">
<h2><a class="toc-backref" href="#id2">Configuring Leo to use zodb</a></h2>
<p>To enable zodb scripting within Leo, you must set <tt class="docutils literal"><span class="pre">use_zodb</span> <span class="pre">=</span> <span class="pre">True</span></tt> in the root node of leoNodes.py.
You must also install ZODB itself.  See <a class="reference" href="http://www.zope.org/Wikis/ZODB/guide/node3.html#SECTION000310000000000000000">Installing ZODB</a> for details.</p>
<p>When ZODB is installed and <tt class="docutils literal"><span class="pre">use_zodb</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>
Leo's vnode and tnode classes become subclasses of ZODB.Persistence.Persistent.
This is all that is needed to save/retrieve vnodes or tnodes to/from the ZODB.</p>
<p><strong>Important notes</strong>:</p>
<ul class="simple">
<li>Scripts <strong>should not</strong> store or retrieve positions using the ZODB!
Doing so makes sense neither from Leo's point of view nor from ZODB's point of view.</li>
<li>The examples below show how to store or retrieve Leo data by accessing
the so-called root of a ZODB connection.
However, these are only examples.
Scripts are free to do with Leo's vnodes and tnodes <em>anything</em> that can
be done with ZODB.Persistence.Persistent objects.</li>
</ul>
</div>
<div class="section" id="initing-zodb">
<h2><a class="toc-backref" href="#id3">Initing zodb</a></h2>
<p>Scripts should call g.init_zodb to open a ZODB.Storage file.
g.init_zodb returns an instance of ZODB.DB.  For example:</p>
<pre class="literal-block">
db = g.init_zodb (zodbStorageFileName)
</pre>
<p>You can call g.init_zodb as many times as you like.
Only the first call for any path actually does anything:
subsequent calls for a previously opened path simply return the same value as the first call.</p>
</div>
<div class="section" id="writing-data-to-zodb">
<h2><a class="toc-backref" href="#id4">Writing data to zodb</a></h2>
<p>The following script writes v, a tree of vnodes, to zodb:</p>
<pre class="literal-block">
db = g.init_zodb (zodbStorageFileName)
connection = db.open()
try:
    root = connection.root()
    root[aKey] = v # See next section for how to define aKey.
finally:
    get_transaction().commit()
    connection.close()
</pre>
<p>Notes:</p>
<ul>
<li><p class="first">v must be a vnode (or a tnode).
Scripts should <em>not</em> attempt to store Leo positions in the zodb.
v can be the root of an entire outline or a subtree.
For example, either of the following would be reasonable:</p>
<pre class="literal-block">
root[aKey] = c.rootPosition().v
root[aKey] = c.p.v
</pre>
</li>
<li><p class="first">To write a single vnode without writing any of its children you can use v.detach.
For example:</p>
<pre class="literal-block">
root[aKey] = v.detach()
</pre>
</li>
<li><p class="first"><strong>Important</strong>: It is simplest if only one zodb connection is open at any one time,
so scripts would typically close the zodb connection immediately after processing the data.
The correct way to do this is in a finally statement, as shown above.</p>
</li>
<li><p class="first">The script above does not define aKey.
The following section discusses how to define reasonable zodb keys.</p>
</li>
</ul>
</div>
<div class="section" id="defining-zodb-keys">
<h2><a class="toc-backref" href="#id5">Defining zodb keys</a></h2>
<p>The keys used to store and retrieve data in connection.root() can be any string that uniquely identifies the data.
The following are only suggestions: you are free to use any string you like.</p>
<ol class="arabic">
<li><p class="first">When saving a file, you would probably use a key that is similar to a real file path.
For example:</p>
<pre class="literal-block">
aKey = c.fileName()
</pre>
</li>
<li><p class="first">When saving a single vnode or tree of vnodes, say v,
a good choice would be to use v's gnx, namely:</p>
<pre class="literal-block">
aKey = g.app.nodeIndices.toString(v.t.fileIndex)
</pre>
<p>Note that v.detach() does not automatically copy v.t.fileIndex to the detached node,
so when writing a detached node you would typically do the following:</p>
<pre class="literal-block">
v2 = v.detach()
v2.t.fileIndex = v.t.fileIndex
aKey = g.app.nodeIndices.toString(v2.t.fileIndex)
</pre>
</li>
</ol>
</div>
<div class="section" id="reading-data-from-zodb">
<h2><a class="toc-backref" href="#id6">Reading data from zodb</a></h2>
<p>The following script reads a tree of vnodes from zodb and sets p as the root position of the tree:</p>
<pre class="literal-block">
try:
    connection = db.open()
    root = connection.root()
    v = root.get(aKey)
    p = leoNodes.position(v)
finally:
    get_transaction().commit()
    connection.close()
</pre>
</div>
<div class="section" id="about-connections">
<h2><a class="toc-backref" href="#id7">About connections</a></h2>
<p>The scripts shown above close the zodb connection after processing the data.
This is by far the simplest strategy.
I recommend it for typical scripts.</p>
<p><strong>Important</strong>: you must <strong>leave the connection open</strong> if your script modifies persistent data in any way.
(Actually, this statement is not really true,
but you must define zodb transaction managers if you intend to use multiple connections simultaneously.
This complication is beyond the scope of this documentation.)
For example, it would be possible to create a new Leo outline from the data just read,
but the script must leave the connection open.
I do not recommend this tactic, but for the adventurous here is some sample code:</p>
<pre class="literal-block">
connection = self.db.open()
root = connection.root()
v = root.get(fileName)
if v:
    c2 = c.new()
    c2.openDirectory = c.openDirectory # A hack.
    c2.mFileName = fileName # Another hack.
    c2.beginUpdate()
    try:
        c2.setRootVnode(v)
        c2Root = c2.rootPosition()
        c2.atFileCommands.readAll(c2Root)
        g.es_print('zodb read: %s' % (fileName))
    finally:
        c2.endUpdate()
    # Do *not* close the connection while the new Leo window is open!
else:
    g.es_print('zodb read: not found: %s' % (fileName))
</pre>
<p>This will work <strong>provided</strong> that no other zodb connection is ever opened while this connection is opened.
Unless special zodb precautions are taken (like defining zodb transaction managers)
calling get_transaction().commit() will affect <strong>all</strong> open connections.
You have been warned.</p>
</div>
<div class="section" id="convenience-routines">
<h2><a class="toc-backref" href="#id8">Convenience routines</a></h2>
<div class="section" id="g-init-zodb-pathtozodbstorage-verbose-true">
<h3><a class="toc-backref" href="#id9">g.init_zodb (pathToZodbStorage,verbose=True)</a></h3>
<p>This function inits the zodb.
pathToZodbStorage is the full path to the zodb storage file.
You can call g.init_zodb as many times as you like.
Only the first call for any path actually does anything:
subsequent calls for a previously opened path simply return the same value as the first call.</p>
</div>
<div class="section" id="v-detach">
<h3><a class="toc-backref" href="#id10">v.detach()</a></h3>
<p>This vnode method returns v2, a copy of v that is completely detached from the outline.
v2.t is a completely new tnode.
v2.fileIndex is None initially, but is may be convenient to copy this field:</p>
<pre class="literal-block">
v2 = v.detach()
v2.t.fileIndex = v.t.fileIndex
</pre>
<hr class="docutils" />
<p><a class="reference" href="debuggers.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="emacs.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</div>
</body>
</html>
